{"id":"../src/2d/layers/labels/border-layer.vs","dependencies":[],"generated":{"js":"module.exports = \"precision highp float;\\n\\nvarying vec4 vertexColor;\\n\\nvoid main() {\\n  float borderScale = mix(fontScale, 1.0, float(scaling == 3.0));\\n\\n  // Determine final screen size of label\\n  vec3 screenSize = cameraSpaceSize(vec3(size * scale * borderScale / scaleFactor / maxScale, 1.0));\\n\\n  // Test whether the label is larger on the screen than the font size\\n  bool largerOnScreen = screenSize.y > size.y || screenSize.x > size.x;\\n\\n  // Determines if a scale mode should be used or not for the vertex\\n  float useScaleMode = float(\\n    (\\n      scaling == 3.0 ||                  // NEVER mode - keep the image the same size always\\n      (largerOnScreen && scaling == 2.0) // BOUND_MAX mode - only if we're larger than the font size do we scale down\\n    ) &&\\n    scaling != 1.0                       // ALWAYS mode - the image stays completely in world space allowing it to scale freely\\n  );\\n\\n  // Correct aspect ratio. Sufficient fix for most applications.\\n  // Will need another solution in the case of:\\n  // (cameraScale2D y != cameraScale2D.x) && (cameraScale2D.x != 1 && cameraScale2D.y != 1)\\n\\n  // If zooms are unequal, assume one is filtered to be 1.0\\n  float unequalZooms = float(cameraScale2D.x != cameraScale2D.y);\\n\\n  vec2 adjustedSize = mix(\\n    size,\\n    (size * cameraScale2D.yx),\\n    unequalZooms\\n  );\\n\\n  // Destructure threejs's bug with the position requirement\\n  float normal = normals.x;\\n  float side = normals.y;\\n\\n  vec2 scaledAnchor = anchor * scale;\\n\\n  // Get the location of the anchor in world space\\n  vec2 worldAnchor = location + scaledAnchor;\\n\\n  vec2 adjustedAnchor = mix(\\n    scaledAnchor,\\n    (scaledAnchor * cameraScale2D.yx),\\n    unequalZooms\\n  );\\n\\n  // Get the position of the current vertex\\n  vec2 vertex = vec2(side, float(normal == 1.0)) * scale * adjustedSize + location - adjustedAnchor;\\n\\n  // See how scaled the size on screen will be from the actual height of the label\\n  float labelScreenScale = mix(\\n    screenSize.y / adjustedSize.y,\\n    screenSize.x / adjustedSize.x,\\n    float((cameraScale2D.x != 1.0))\\n  );\\n\\n  float currentScale = labelScreenScale * scale;\\n\\n  // If our screen rendering is larger than the size the label is supposed to be, then we automagically\\n  // scale down our label to stay the correct size, centered on the anchor point\\n  vec2 anchorToVertex = vertex - location;\\n\\n  // We now choose between keeping the same image size or keeping it in world space\\n  vertex = mix(\\n    // This option keeps the image size in world space\\n    vertex + textAreaOrigin,\\n    // This option counters the scaling of the image on the screen keeping it a static size\\n    (anchorToVertex + location - textAreaAnchor) / labelScreenScale + textAreaOrigin + textAreaAnchor,\\n    // This is the flag determining if a scale mode should be applied to the vertex\\n    useScaleMode\\n  );\\n\\n  // --Texture and Color\\n  // Apply the label's color as a tint to the label (all labels are rendered white to the base texture)\\n  vertexColor = color;\\n\\n  gl_Position = clipSpace(vec3(vertex, depth));\\n}\\n\""},"sourceMaps":null,"error":null,"hash":"00585c722b869c2b04301870b6e8b6e4","cacheData":{}}