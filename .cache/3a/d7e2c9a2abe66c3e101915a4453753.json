{"id":"../src/2d/layers/images/image-layer.vs","dependencies":[],"generated":{"js":"module.exports = \"precision highp float;\\n\\n\\n\\nvarying vec4 vertexColor;\\nvarying vec2 texCoord;\\n\\nvoid main() {\\n  // Figure out the size of the image as it'd show on the screen\\n  vec3 screenSize = cameraSpaceSize(vec3(size, 1.0));\\n  // Do the test for when the image is larger on the screen than the font size\\n  bool largerOnScreen = screenSize.y > size.y;\\n\\n  // Determines if a scale mode should be used or not for the vertex\\n  float useScaleMode = float(\\n    (\\n      scaling == 3.0 ||                  // NEVER mode - keep the image the same size always\\n      (largerOnScreen && scaling == 2.0) // BOUND_MAX mode - only if we're larger than the font size do we scale down\\n    ) &&\\n    scaling != 1.0                       // ALWAYS mode - the image stays completely in world space allowing it to scale freely\\n  );\\n  // If zooms are unequal, assume one is filtered to be 1.0\\n  float unequalZooms = float(cameraScale2D.x != cameraScale2D.y);\\n\\n  // Destructure the normal information\\n  float normal = normals.x;\\n  float side = normals.y;\\n\\n  // Get the location of the anchor in world space\\n  vec2 worldAnchor = location + anchor;\\n\\n  // Get the tex coord from our inject texture info\\n  texCoord = texture.xy + ((texture.zw - texture.xy) * vec2(side, float(normal == -1.0)));\\n  // Apply the image's tint as a tint to the image\\n  vertexColor = tint;\\n\\n  // Correct aspect ratio.\\n  vec2 adjustedSize = mix(\\n    size,\\n    (size * cameraScale2D.yx),\\n    unequalZooms\\n  );\\n\\n  vec2 adjustedAnchor = mix(\\n    anchor,\\n    (anchor * cameraScale2D.yx),\\n    unequalZooms\\n  );\\n\\n  vec2 vertex = vec2(side, float(normal == 1.0)) * adjustedSize + location - adjustedAnchor;\\n\\n  // See how scaled the size on screen will be from the actual height of the image\\n  float imageScreenScale = mix(\\n    screenSize.y / adjustedSize.y,\\n    screenSize.x / adjustedSize.x,\\n    float((cameraScale2D.x < 1.0) || (cameraScale2D.x > 1.0))\\n  );\\n\\n  // If our screen rendering is larger than the size the image is supposed to be, then we automagically\\n  // scale down our image to stay the correct size, centered on the anchor point\\n  vec2 anchorToVertex = vertex - location;\\n\\n  // We now choose between keeping the same image size or keeping it in world space\\n  vertex = mix(\\n    // This option keeps the image size in world space\\n    vertex,\\n    // This option counters the scaling of the image on the screen keeping it a static size\\n    (anchorToVertex / imageScreenScale) + location,\\n    // This is the flag determining if a scale mode should be applied to the vertex\\n    useScaleMode\\n  );\\n\\n  gl_Position = clipSpace(vec3(vertex, depth));\\n}\\n\""},"sourceMaps":null,"error":null,"hash":"64157f885e8d63adae357341f3686556","cacheData":{}}