{"id":"../src/2d/layers/edges/shader/edge-layer-screen-curve.vs","dependencies":[],"generated":{"js":"module.exports = \"/**\\n  This vertex shader calculates edges based in world space to make an edge based on\\n  bezier curves with 0, 1, and 2 control points.\\n**/\\nprecision highp float;\\n\\n\\n\\nvarying vec4 vertexColor;\\n\\n// Interpolation type injection\\n${interpolation}\\n\\nvoid main() {\\n  // Destructure threejs's bug with the position requirement\\n  float normal = vertex.x;\\n  float interpolationTime = vertex.y;\\n  float interpolationIncrement = 1.0 / vertex.z;\\n\\n  // Convert our world points to screen space\\n  vec4 startClip = clipSpace(vec3(start, depth));\\n  vec4 endClip = clipSpace(vec3(end, depth));\\n  vec2 startScreen = (startClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\n  vec2 endScreen = (endClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\n  // Controls for this mode are screen space deltas from the end points\\n  vec2 control1 = startScreen + vec2(control.x, -control.y) * scaleFactor;\\n  vec2 control2 = endScreen + vec2(control.z, -control.w) * scaleFactor;\\n\\n  // Get the position of the current vertex\\n  vec2 currentPosition = interpolation(interpolationTime, startScreen, endScreen, control1, control2);\\n  // Calculate the next and previous segment's location on the line\\n  vec2 prePosition = interpolation(interpolationTime - interpolationIncrement, startScreen, endScreen, control1, control2);\\n  vec2 nextPosition = interpolation(interpolationTime + interpolationIncrement, startScreen, endScreen, control1, control2);\\n\\n  vec2 preLine = prePosition - currentPosition;\\n  vec2 nextLine = nextPosition - currentPosition;\\n\\n  // Get a spliced nromal at the joining of two segments to make a crisper curve\\n  vec2 currentNormal = mix(\\n    // Pick this value if we're at the beginning of the line\\n    normalize(vec2(preLine.y, -preLine.x)),\\n    mix(\\n      // Pick this value when we're between the ends\\n      normalize(vec2(preLine.y, -preLine.x) + vec2(-nextLine.y, nextLine.x)),\\n      // Pick this value if we're at the end of the line\\n      normalize(vec2(-nextLine.y, nextLine.x)),\\n      float(vertex.x >= 1.0)\\n    ),\\n    float(vertex.x > 0.0)\\n  );\\n\\n  // Get the thickness based on the side we're on\\n  float lineThickness = mix(thickness.x, thickness.y, interpolationTime) / 2.0;\\n  // Start on the calculated line and push out by the normal's value\\n  vec2 vertexPos = currentPosition + currentNormal * (-normal * lineThickness * scaleFactor);\\n  // Get the color based on where we are on the line\\n  vertexColor = mix(startColor, endColor, interpolationTime);\\n\\n  gl_Position = vec4((vertexPos / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), startClip.zw);\\n  gl_PointSize = 5.0;\\n}\\n\""},"sourceMaps":null,"error":null,"hash":"7c749020c920b230a217fe93b632c391","cacheData":{}}