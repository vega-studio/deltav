{"id":"../src/2d/layers/arcs/arc-layer-screen-space.vs","dependencies":[],"generated":{"js":"module.exports = \"precision highp float;\\n\\n/**\\n  This vertex shader calculates edges whose curve and width is in screen space where the curve is\\n  bezier curves with 0, 1, and 2 control points.\\n**/\\nvarying vec4 vertexColor;\\n\\nvec2 interpolation(float t, vec2 center, float radius, float start, float end) {\\n  float angle = (end - start) * t + start;\\n  return center + vec2(cos(angle) * radius, sin(angle) * radius);\\n}\\n\\nvoid main() {\\n  // Destructure some of the vec injections\\n  float startAngle = angle.x;\\n  float endAngle = angle.y;\\n  float widthStart = thickness.x;\\n  float widthEnd = thickness.y;\\n\\n  // Convert world points to screen space\\n  vec4 centerClip = clipSpace(vec3(center, depth));\\n  vec2 centerScreen = (centerClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\n  // Destructure threejs's bug with the position requirement\\n  float normal = position.x;\\n  float interpolationTime = position.y;\\n  float interpolationIncrement = 1.0 / position.z;\\n  // Get the position of the current vertex\\n  vec2 currentPosition = interpolation(interpolationTime, centerScreen, radius, startAngle, endAngle);\\n  // Get normal with currentPosition and center\\n  vec2 currentNormal = normalize(currentPosition - centerScreen);\\n  // Get the thickness based on the side we're on\\n  float lineThickness = mix(widthStart, widthEnd, interpolationTime) / 2.0;\\n  // Start on the calculated line and push out by the normal's value\\n  vec2 vertex = currentPosition + currentNormal * (normal * lineThickness);\\n  // Get the color based on where we are on the line\\n  vertexColor = mix(colorStart, colorEnd, interpolationTime);\\n  vertexColor *= vertexColor.a;\\n\\n  gl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), centerClip.zw);\\n  gl_PointSize = 5.0;\\n}\\n\""},"sourceMaps":null,"error":null,"hash":"7bb86d8a09effd0a2b937b7b8d41b900","cacheData":{}}