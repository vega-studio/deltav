{"id":"../node_modules/@diniden/signal-processing/dist/lib.js","dependencies":[{"name":"/Users/diniden/Desktop/VoidRay/fiesta/node_modules/@diniden/signal-processing/dist/lib.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/diniden/Desktop/VoidRay/fiesta/package.json","includedInParent":true,"mtime":1570672381660},{"name":"/Users/diniden/Desktop/VoidRay/fiesta/node_modules/@diniden/signal-processing/package.json","includedInParent":true,"mtime":1570671212463}],"generated":{"js":"var define;\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nparcelRequire = function (e, r, n, t) {\n  var i = 'function' == typeof parcelRequire && parcelRequire,\n      o = 'function' == typeof require && require;\n\n  function u(n, t) {\n    if (!r[n]) {\n      if (!e[n]) {\n        var f = 'function' == typeof parcelRequire && parcelRequire;\n        if (!t && f) return f(n, !0);\n        if (i) return i(n, !0);\n        if (o && 'string' == typeof n) return o(n);\n        var c = new Error(\"Cannot find module '\" + n + \"'\");\n        throw c.code = 'MODULE_NOT_FOUND', c;\n      }\n\n      p.resolve = function (r) {\n        return e[n][1][r] || r;\n      }, p.cache = {};\n      var l = r[n] = new u.Module(n);\n      e[n][0].call(l.exports, p, l, l.exports, this);\n    }\n\n    return r[n].exports;\n\n    function p(e) {\n      return u(p.resolve(e));\n    }\n  }\n\n  u.isParcelRequire = !0, u.Module = function (e) {\n    this.id = e, this.bundle = u, this.exports = {};\n  }, u.modules = e, u.cache = r, u.parent = i, u.register = function (r, n) {\n    e[r] = [function (e, r) {\n      r.exports = n;\n    }, {}];\n  };\n\n  for (var f = 0; f < n.length; f++) {\n    u(n[f]);\n  }\n\n  if (n.length) {\n    var c = u(n[n.length - 1]);\n    'object' == (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) && 'undefined' != typeof module ? module.exports = c : 'function' == typeof define && define.amd ? define(function () {\n      return c;\n    }) : t && (this[t] = c);\n  }\n\n  return u;\n}({\n  yHOA: [function (require, module, exports) {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: !0\n    });\n\n    var t =\n    /*#__PURE__*/\n    function () {\n      function t(_t, i) {\n        _classCallCheck(this, t);\n\n        if (this.coefficients = _t.map(function (t) {\n          return t[0];\n        }), this.filter = _t.map(function (t) {\n          return t[1];\n        }), void 0 !== i) {\n          var _t2 = 0;\n          this.coefficients.forEach(function (i) {\n            return _t2 += i;\n          }), this.coefficients = this.coefficients.map(function (e) {\n            return e / _t2 * i;\n          });\n        }\n      }\n\n      _createClass(t, [{\n        key: \"reset\",\n        value: function reset(t) {\n          this.filter = this.filter.map(function () {\n            return t;\n          });\n        }\n      }, {\n        key: \"stream\",\n        value: function stream(t) {\n          var i = 0;\n          this.filter.pop(), this.filter.unshift(t);\n\n          for (var e = 0, s = this.coefficients.length; e < s; ++e) {\n            i += this.coefficients[e] * this.filter[e];\n          }\n\n          return this.filter.shift(), this.filter.unshift(i), i;\n        }\n      }, {\n        key: \"run\",\n        value: function run(t, i) {\n          var e = this.filter.slice(0),\n              s = i.slice(0);\n          this.reset(t);\n          var f = [];\n\n          for (; s.length > 0;) {\n            f.push(this.stream(s.shift() || 0));\n          }\n\n          return this.filter = e, f;\n        }\n      }]);\n\n      return t;\n    }();\n\n    exports.FIRFilter = t;\n  }, {}],\n  KM9m: [function (require, module, exports) {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: !0\n    });\n\n    var e =\n    /*#__PURE__*/\n    function () {\n      function e(_e) {\n        _classCallCheck(this, e);\n\n        if (0 === _e) return;\n        var t = [[1]],\n            s = _e - 1;\n\n        for (var l = 0; l < s; ++l) {\n          var _e2 = t[l],\n              _s = [1];\n\n          for (var _t3 = 0, _l = _e2.length - 1; _t3 < _l; ++_t3) {\n            _s.push(_e2[_t3] + _e2[_t3 + 1]);\n          }\n\n          _s.push(1), t.push(_s);\n        }\n\n        this.elements = t;\n      }\n\n      _createClass(e, [{\n        key: \"gaussianKernal\",\n        value: function gaussianKernal(e, t) {\n          var s = 2 * t;\n          var l = [];\n\n          for (var a = 0, o = this.elements.length; a < o && this.elements[a].length - s <= e; ++a) {\n            l = this.elements[a];\n          }\n\n          l.length - s !== e && console.warn('Error in pascal triangle gaussian kernal', 'Requested size', e, 'Row', l, 'Trim amount', t, 'Elements', this.elements);\n          var n = l.slice(t, l.length - t);\n          var r = n.reduce(function (e, t) {\n            return t + e;\n          }, 0);\n          return {\n            kernal: n = n.map(function (e) {\n              return e / r;\n            }),\n            total: r\n          };\n        }\n      }]);\n\n      return e;\n    }();\n\n    exports.PascalTriangle = e;\n  }, {}],\n  '5Rhe': [function (require, module, exports) {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: !0\n    });\n\n    var e = require('./pascal-triangle'),\n        t = Math.min,\n        n = Math.max;\n\n    function l(e, l, s) {\n      return n(t(e, s), l);\n    }\n\n    var s =\n    /*#__PURE__*/\n    function () {\n      function s(e) {\n        _classCallCheck(this, s);\n\n        this.options = e, this.update(e);\n      }\n\n      _createClass(s, [{\n        key: \"generate\",\n        value: function generate(e) {\n          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,\n              n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,\n              s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,\n              r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;\n          if (!e || !e[0] || !e[0].length) return e;\n          var o = this.options.passes,\n              i = this.kernal,\n              a = e.map(function (e) {\n            return e.slice(0);\n          }),\n              h = e.length,\n              u = e[0].length,\n              c = {\n            1: [0],\n            3: [-1, 0, 1],\n            5: [-2, -1, 0, 1, 2],\n            7: [-3, -2, -1, 0, 1, 2, 3],\n            9: [-4, -3, -2, -1, 0, 1, 2, 3, 4]\n          }[i.length];\n          if (!c) return console.warn('No offset suitable for kernal size'), e;\n          var f = [];\n\n          for (var _l2 = 0; _l2 < h; ++_l2) {\n            f.push([]);\n          }\n\n          for (var g = 0; g < o; ++g) {\n            var _e3 = void 0,\n                _o = void 0;\n\n            for (var _g = t, p = h - s; _g < p; ++_g) {\n              var _t4 = f[_g],\n                  _s2 = a[_g];\n\n              for (var _a = n, _h = u - r; _a < _h; ++_a) {\n                _e3 = 0;\n\n                for (var _t5 = 0, _n = i.length; _t5 < _n; ++_t5) {\n                  _e3 += (_s2[_o = l(_a + c[_t5], 0, _h - 1)] || 0) * i[_t5];\n                }\n\n                _t4[_a] = _e3;\n              }\n            }\n\n            for (var _g2 = t, _p = h - s; _g2 < _p; ++_g2) {\n              var _t6 = a[_g2];\n\n              for (var _s3 = n, _a2 = u - r; _s3 < _a2; ++_s3) {\n                _e3 = 0;\n\n                for (var _t7 = 0, _n2 = i.length; _t7 < _n2; ++_t7) {\n                  _e3 += ((f[_o = l(_g2 + c[_t7], 0, _p - 1)] || [])[_s3] || 0) * i[_t7];\n                }\n\n                _t6[_s3] = _e3;\n              }\n            }\n          }\n\n          return a;\n        }\n      }, {\n        key: \"update\",\n        value: function update(t) {\n          Object.assign(this.options, t), t.kernalSize && (this.kernal = new e.PascalTriangle(15).gaussianKernal(t.kernalSize, 2).kernal);\n        }\n      }]);\n\n      return s;\n    }();\n\n    exports.GaussianBlur = s;\n  }, {\n    './pascal-triangle': 'KM9m'\n  }],\n  zv8l: [function (require, module, exports) {\n    'use strict';\n\n    function e(e, r) {\n      return function (t) {\n        return (t - e[0]) / (e[1] - e[0]) * (r[1] - r[0] + r[0]);\n      };\n    }\n\n    Object.defineProperty(exports, '__esModule', {\n      value: !0\n    }), exports.scaleLinear = e;\n  }, {}],\n  FHmy: [function (require, module, exports) {\n    'use strict';\n\n    function t(t) {\n      return function () {\n        var e = t.apply(this, arguments);\n        return new Promise(function (t, n) {\n          return function s(a, o) {\n            try {\n              var i = e[a](o),\n                  r = i.value;\n            } catch (l) {\n              return void n(l);\n            }\n\n            if (!i.done) return Promise.resolve(r).then(function (t) {\n              s('next', t);\n            }, function (t) {\n              s('throw', t);\n            });\n            t(r);\n          }('next');\n        });\n      };\n    }\n\n    Object.defineProperty(exports, '__esModule', {\n      value: !0\n    });\n\n    var e = require('./gaussian-blur'),\n        n = require('./scale-linear'),\n        s = Math.abs,\n        a = Math.floor,\n        o = Math.max,\n        i = Math.min,\n        r = Math.random;\n\n    var l =\n    /*#__PURE__*/\n    function () {\n      _createClass(l, [{\n        key: \"width\",\n        get: function () {\n          return this.options.width;\n        }\n      }, {\n        key: \"height\",\n        get: function () {\n          return this.options.height;\n        }\n      }]);\n\n      function l(t) {\n        _classCallCheck(this, l);\n\n        this.options = t, this.blur = new e.GaussianBlur({\n          passes: t.blendPasses,\n          kernalSize: 9\n        }), this.update(t);\n      }\n\n      _createClass(l, [{\n        key: \"generate\",\n        value: function generate() {\n          var e = this;\n          return t(\n          /*#__PURE__*/\n          regeneratorRuntime.mark(function _callee() {\n            var _e$options, t, s, i, l, h, d, u, c, _e6, _t11, _e7, _e8, _t12, _e9;\n\n            return regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _e$options = e.options, t = _e$options.width, s = _e$options.height, i = _e$options.octaves, l = _e$options.valueRange;\n                    h = [];\n                    i.forEach(function (e) {\n                      var o = [],\n                          i = e[0],\n                          l = e[1],\n                          d = n.scaleLinear([0, t], [0, i]),\n                          u = n.scaleLinear([0, s], [0, l]);\n\n                      for (var _t8 = 0; _t8 < i; ++_t8) {\n                        var _t9 = [];\n                        o.push(_t9);\n\n                        for (var _e4 = 0; _e4 < l; ++_e4) {\n                          _t9.push(r());\n                        }\n                      }\n\n                      for (var _n3 = 0; _n3 < t; ++_n3) {\n                        var _t10 = h[_n3] = h[_n3] || [];\n\n                        for (var _e5 = 0; _e5 < s; ++_e5) {\n                          _t10[_e5] = (_t10[_e5] || 1) * o[a(d(_n3))][a(u(_e5))];\n                        }\n                      }\n                    }), h = e.blur.generate(h);\n                    d = -1;\n                    u = l[1] - l[0], c = l[0];\n\n                    for (_e6 = 0; _e6 < t; ++_e6) {\n                      _t11 = h[_e6];\n\n                      for (_e7 = 0; _e7 < s; ++_e7) {\n                        d = o(_t11[_e7], d);\n                      }\n                    }\n\n                    for (_e8 = 0; _e8 < t; ++_e8) {\n                      _t12 = h[_e8];\n\n                      for (_e9 = 0; _e9 < s; ++_e9) {\n                        _t12[_e9] /= d, _t12[_e9] = _t12[_e9] * u + c;\n                      }\n                    }\n\n                    e.data = h;\n\n                  case 8:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee);\n          }))();\n        }\n      }, {\n        key: \"generateOnce\",\n        value: function generateOnce() {\n          var e = this;\n          return t(\n          /*#__PURE__*/\n          regeneratorRuntime.mark(function _callee2() {\n            return regeneratorRuntime.wrap(function _callee2$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    _context2.t0 = e.data;\n\n                    if (_context2.t0) {\n                      _context2.next = 4;\n                      break;\n                    }\n\n                    _context2.next = 4;\n                    return e.generate();\n\n                  case 4:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _callee2);\n          }))();\n        }\n      }, {\n        key: \"sample\",\n        value: function sample(t, e, n, a, o) {\n          var r = [];\n          if (o) for (var _l3 = t, h = i(this.data.length, t + n); _l3 < h; ++_l3) {\n            r.push(this.data[_l3].slice(e, e + a).map(function (t) {\n              return s(t) > o ? t : 0;\n            }));\n          } else for (var _s4 = t, _l4 = i(this.data.length, t + n); _s4 < _l4; ++_s4) {\n            r.push(this.data[_s4].slice(e, e + a));\n          }\n          return r;\n        }\n      }, {\n        key: \"update\",\n        value: function update(t) {\n          Object.assign(this.options, t), t.blendPasses && this.blur.update({\n            passes: t.blendPasses\n          });\n        }\n      }, {\n        key: \"debug\",\n        value: function debug() {\n          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;\n          if (arguments.length > 1 ? arguments[1] : void 0) return void (this.debugContext && this.debugContext.remove());\n          var e = document.createElement('canvas').getContext('2d');\n\n          if (e) {\n            var _n4 = this.options.valueRange,\n                _a3 = e.canvas;\n            document.getElementsByTagName('body')[0].appendChild(e.canvas);\n\n            var _o2 = _a3.width = this.data.length,\n                _i = _a3.height = this.data[0].length,\n                _r = e.getImageData(0, 0, _o2, _i);\n\n            var _l5 = 0;\n            var h = _n4[1] - _n4[0],\n                d = _n4[0];\n            if (t) for (var _e10 = 0, u = this.data.length; _e10 < u; ++_e10) {\n              var _n5 = this.data[_e10];\n\n              for (var _e11 = 0, _a4 = _n5.length; _e11 < _a4; ++_e11) {\n                var _a5 = 255 * (s(_n5[_e11]) > t ? 1 : 0);\n\n                _r.data[4 * _l5] = _a5, _r.data[4 * _l5 + 1] = _a5, _r.data[4 * _l5 + 2] = _a5, _r.data[4 * _l5 + 3] = 255, _l5++;\n              }\n            } else for (var _t13 = 0, _e12 = this.data.length; _t13 < _e12; ++_t13) {\n              var _e13 = this.data[_t13];\n\n              for (var _t14 = 0, _n6 = _e13.length; _t14 < _n6; ++_t14) {\n                var _n7 = (_e13[_t14] - d) / h * 255;\n\n                _r.data[4 * _l5] = _n7, _r.data[4 * _l5 + 1] = _n7, _r.data[4 * _l5 + 2] = _n7, _r.data[4 * _l5 + 3] = 255, _l5++;\n              }\n            }\n            e.putImageData(_r, 0, 0), _a3.style.position = 'fixed', _a3.style.top = '0px', _a3.style.left = '0px', _a3.style.zIndex = '9999', this.debugContext = _a3;\n          }\n        }\n      }]);\n\n      return l;\n    }();\n\n    exports.PerlinNoise = l;\n  }, {\n    './gaussian-blur': '5Rhe',\n    './scale-linear': 'zv8l'\n  }],\n  UL96: [function (require, module, exports) {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: !0\n    });\n  }, {}],\n  '7QCb': [function (require, module, exports) {\n    'use strict';\n\n    function e(e) {\n      for (var r in e) {\n        exports.hasOwnProperty(r) || (exports[r] = e[r]);\n      }\n    }\n\n    Object.defineProperty(exports, '__esModule', {\n      value: !0\n    }), e(require('./FIR')), e(require('./gaussian-blur')), e(require('./pascal-triangle')), e(require('./perlin-noise')), e(require('./types'));\n  }, {\n    './FIR': 'yHOA',\n    './gaussian-blur': '5Rhe',\n    './pascal-triangle': 'KM9m',\n    './perlin-noise': 'FHmy',\n    './types': 'UL96'\n  }]\n}, {}, ['7QCb'], null);"},"sourceMaps":{"js":{"mappings":[{"source":"FIR.ts","name":null,"original":{"line":7,"column":0},"generated":{"line":11,"column":0}},{"source":"FIR.ts","name":null,"original":{"line":7,"column":0},"generated":{"line":11,"column":6}},{"source":"FIR.ts","name":null,"original":{"line":7,"column":0},"generated":{"line":11,"column":7}},{"source":"FIR.ts","name":null,"original":{"line":7,"column":0},"generated":{"line":11,"column":10}},{"source":"FIR.ts","name":null,"original":{"line":7,"column":0},"generated":{"line":11,"column":24}},{"source":"FIR.ts","name":null,"original":{"line":7,"column":0},"generated":{"line":11,"column":31}},{"source":"FIR.ts","name":null,"original":{"line":7,"column":0},"generated":{"line":11,"column":44}},{"source":"FIR.ts","name":null,"original":{"line":7,"column":0},"generated":{"line":11,"column":48}},{"source":"FIR.ts","name":null,"original":{"line":7,"column":0},"generated":{"line":11,"column":61}},{"source":"FIR.ts","name":null,"original":{"line":7,"column":0},"generated":{"line":12,"column":0}},{"source":"FIR.ts","name":null,"original":{"line":7,"column":0},"generated":{"line":12,"column":49}},{"source":"pascal-triangle.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":14,"column":0}},{"source":"pascal-triangle.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":14,"column":11}},{"source":"pascal-triangle.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":14,"column":12}},{"source":"pascal-triangle.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":14,"column":13}},{"source":"pascal-triangle.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":14,"column":14}},{"source":"pascal-triangle.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":14,"column":16}},{"source":"pascal-triangle.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":14,"column":17}},{"source":"pascal-triangle.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":14,"column":19}},{"source":"gaussian-blur.ts","name":null,"original":{"line":19,"column":0},"generated":{"line":16,"column":0}},{"source":"gaussian-blur.ts","name":null,"original":{"line":19,"column":0},"generated":{"line":16,"column":10}},{"source":"gaussian-blur.ts","name":null,"original":{"line":19,"column":0},"generated":{"line":16,"column":11}},{"source":"gaussian-blur.ts","name":null,"original":{"line":19,"column":0},"generated":{"line":16,"column":12}},{"source":"gaussian-blur.ts","name":null,"original":{"line":19,"column":0},"generated":{"line":16,"column":13}},{"source":"gaussian-blur.ts","name":null,"original":{"line":19,"column":0},"generated":{"line":16,"column":14}},{"source":"gaussian-blur.ts","name":null,"original":{"line":19,"column":0},"generated":{"line":16,"column":15}},{"source":"gaussian-blur.ts","name":null,"original":{"line":19,"column":0},"generated":{"line":16,"column":17}},{"source":"scale-linear.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":18,"column":0}},{"source":"scale-linear.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":18,"column":12}},{"source":"scale-linear.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":18,"column":13}},{"source":"scale-linear.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":18,"column":14}},{"source":"scale-linear.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":18,"column":18}},{"source":"scale-linear.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":18,"column":19}},{"source":"scale-linear.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":18,"column":21}},{"source":"scale-linear.ts","name":null,"original":{"line":3,"column":42},"generated":{"line":18,"column":28}},{"source":"scale-linear.ts","name":null,"original":{"line":4,"column":9},"generated":{"line":18,"column":29}},{"source":"scale-linear.ts","name":null,"original":{"line":4,"column":9},"generated":{"line":18,"column":30}},{"source":"scale-linear.ts","name":null,"original":{"line":4,"column":9},"generated":{"line":18,"column":31}},{"source":"scale-linear.ts","name":null,"original":{"line":4,"column":9},"generated":{"line":18,"column":33}},{"source":"scale-linear.ts","name":null,"original":{"line":4,"column":9},"generated":{"line":18,"column":34}},{"source":"scale-linear.ts","name":null,"original":{"line":4,"column":9},"generated":{"line":18,"column":35}},{"source":"scale-linear.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":18,"column":36}},{"source":"perlin-noise.ts","name":null,"original":{"line":33,"column":0},"generated":{"line":20,"column":0}},{"source":"perlin-noise.ts","name":null,"original":{"line":33,"column":0},"generated":{"line":20,"column":12}},{"source":"perlin-noise.ts","name":null,"original":{"line":33,"column":0},"generated":{"line":20,"column":13}},{"source":"perlin-noise.ts","name":null,"original":{"line":33,"column":0},"generated":{"line":20,"column":17}},{"source":"perlin-noise.ts","name":null,"original":{"line":33,"column":0},"generated":{"line":20,"column":29}},{"source":"perlin-noise.ts","name":null,"original":{"line":33,"column":0},"generated":{"line":20,"column":36}},{"source":"perlin-noise.ts","name":null,"original":{"line":33,"column":0},"generated":{"line":20,"column":37}},{"source":"perlin-noise.ts","name":null,"original":{"line":33,"column":0},"generated":{"line":20,"column":39}},{"source":"perlin-noise.ts","name":null,"original":{"line":33,"column":0},"generated":{"line":20,"column":46}},{"source":"perlin-noise.ts","name":null,"original":{"line":33,"column":0},"generated":{"line":20,"column":47}},{"source":"perlin-noise.ts","name":null,"original":{"line":33,"column":0},"generated":{"line":20,"column":48}},{"source":"perlin-noise.ts","name":null,"original":{"line":33,"column":0},"generated":{"line":20,"column":49}},{"source":"perlin-noise.ts","name":null,"original":{"line":33,"column":0},"generated":{"line":20,"column":50}},{"source":"index.ts","name":null,"original":{"line":5,"column":0},"generated":{"line":25,"column":0}},{"source":"index.ts","name":null,"original":{"line":5,"column":0},"generated":{"line":25,"column":6}},{"source":"index.ts","name":null,"original":{"line":5,"column":0},"generated":{"line":25,"column":7}},{"source":"index.ts","name":null,"original":{"line":5,"column":0},"generated":{"line":25,"column":8}},{"source":"index.ts","name":null,"original":{"line":5,"column":0},"generated":{"line":25,"column":15}},{"source":"index.ts","name":null,"original":{"line":5,"column":0},"generated":{"line":25,"column":18}},{"source":"index.ts","name":null,"original":{"line":5,"column":0},"generated":{"line":25,"column":28}},{"source":"index.ts","name":null,"original":{"line":5,"column":0},"generated":{"line":25,"column":29}},{"source":"index.ts","name":null,"original":{"line":5,"column":0},"generated":{"line":25,"column":31}},{"source":"index.ts","name":null,"original":{"line":5,"column":0},"generated":{"line":27,"column":7}},{"source":"index.ts","name":null,"original":{"line":5,"column":0},"generated":{"line":27,"column":21}}],"sources":{"FIR.ts":"import { Vec2 } from './types';\n\n/**\n * Performs a frequency filtration across a provided streamed in signal.\n * This filter can be adjusted via the seed values provided.\n */\nexport class FIRFilter {\n  coefficients: number[];\n  filter: number[];\n\n  /**\n   * The seed values work in tuples [FIR filter coefficient, starting bias];\n   * When normalize is activated, the seed values are normalized to the provided value.\n   * When normalize is a value of 1, this behaves like a low pass FIR filter.\n   */\n  constructor(seedValues: Vec2[], normalize?: number) {\n    this.coefficients = seedValues.map(seed => seed[0]);\n    this.filter = seedValues.map(seed => seed[1]);\n\n    if (normalize !== undefined) {\n      let total = 0;\n      this.coefficients.forEach(c => (total += c));\n      this.coefficients = this.coefficients.map(\n        value => (value / total) * normalize\n      );\n    }\n  }\n\n  /**\n   * Reset the filter to have all of it's filter values set to the provided value\n   */\n  reset(value: number) {\n    this.filter = this.filter.map(() => value);\n  }\n\n  /**\n   * This streams in a value into the filter and outputs the next computed value\n   */\n  stream(value: number) {\n    let out = 0;\n    this.filter.pop();\n    this.filter.unshift(value);\n\n    for (let i = 0, end = this.coefficients.length; i < end; ++i) {\n      out += this.coefficients[i] * this.filter[i];\n    }\n\n    this.filter.shift();\n    this.filter.unshift(out);\n\n    return out;\n  }\n\n  /**\n   * Runs a list of values through the filter and returns an array of each step\n   */\n  run(start: number, values: number[]) {\n    const current = this.filter.slice(0);\n    const toProcess = values.slice(0);\n    this.reset(start);\n    const out: number[] = [];\n\n    while (toProcess.length > 0) {\n      out.push(this.stream(toProcess.shift() || 0));\n    }\n\n    // Reset the filter back to where it was\n    this.filter = current;\n\n    return out;\n  }\n}\n","pascal-triangle.ts":"export class PascalTriangle {\n  /** Contains the triangles elements [[1], [1, 1], [1, 2, 1], etc] */\n  elements: number[][];\n\n  constructor(levels: number) {\n    if (levels === 0) return;\n    const elements: number[][] = [[1]];\n    const _levels = levels - 1;\n\n    // i will be the index pointing to the previous row\n    for (let i = 0; i < _levels; ++i) {\n      const previous = elements[i];\n      const row = [1];\n\n      for (let k = 0, endk = previous.length - 1; k < endk; ++k) {\n        row.push(previous[k] + previous[k + 1]);\n      }\n\n      row.push(1);\n      elements.push(row);\n    }\n\n    this.elements = elements;\n  }\n\n  /**\n   * Tries to generate a gaussian kernal based on the pascal triangle where the kernal has so many elements\n   * To get a higher quality kernal trim off the ends of the triangle's row but keep the kernal number.\n   * This causes a deeper triangle to be calculated.\n   */\n  gaussianKernal(size: number, trim: number) {\n    const toTrim = trim * 2;\n    let row: number[] = [];\n\n    // Loop until we hit a row with enough elements to make the kernal\n    for (\n      let i = 0, end = this.elements.length;\n      i < end && this.elements[i].length - toTrim <= size;\n      ++i\n    ) {\n      row = this.elements[i];\n    }\n\n    // Make sure the elements matches the requested elements size exactly\n    if (row.length - toTrim !== size) {\n      console.warn(\n        'Error in pascal triangle gaussian kernal',\n        'Requested size',\n        size,\n        'Row',\n        row,\n        'Trim amount',\n        trim,\n        'Elements',\n        this.elements\n      );\n    }\n\n    // Copy and remove trimed elements\n    let kernal = row.slice(trim, row.length - trim);\n    // Get the new total of the row\n    const total = kernal.reduce((prev, next) => next + prev, 0);\n    // Normalize the kernal\n    kernal = kernal.map(value => value / total);\n\n    return {\n      kernal,\n      total,\n    };\n  }\n}\n","gaussian-blur.ts":"import { PascalTriangle } from './pascal-triangle';\n\nexport interface IGaussianBlurOptions {\n  /** Number of samples taken per data slot */\n  kernalSize: number;\n  /** Number of times the blur is applied */\n  passes: number;\n}\n\nconst { min, max } = Math;\n\nfunction clamp(val: number, minVal: number, maxVal: number) {\n  return max(min(val, maxVal), minVal);\n}\n\n/**\n * Performs a gaussian blur on a set of numerical data.\n */\nexport class GaussianBlur {\n  // This is a blur kernal used for blending\n  private kernal: number[];\n  // These are the options for the blur operation\n  options: IGaussianBlurOptions;\n\n  constructor(options: IGaussianBlurOptions) {\n    this.options = options;\n    this.update(options);\n  }\n\n  /**\n   * Applies the blur to the input data, returns a blurred version without affecting the source.\n   */\n  generate(\n    data: number[][],\n    offsetLeft: number = 0,\n    offsetTop: number = 0,\n    offsetRight: number = 0,\n    offsetBottom: number = 0\n  ) {\n    if (!data || !data[0] || !data[0].length) return data;\n\n    const { passes } = this.options;\n    const kernal = this.kernal;\n    const outPass = data.map(col => col.slice(0));\n    const width = data.length;\n    const height = data[0].length;\n\n    const offsets: { [key: number]: number[] } = {\n      1: [0],\n      3: [-1, 0, 1],\n      5: [-2, -1, 0, 1, 2],\n      7: [-3, -2, -1, 0, 1, 2, 3],\n      9: [-4, -3, -2, -1, 0, 1, 2, 3, 4],\n    };\n    const offset = offsets[kernal.length];\n\n    if (!offset) {\n      console.warn('No offset suitable for kernal size');\n      return data;\n    }\n\n    // Instantiate our vertical pass so we don't recreate every pass\n    const verticalPass: number[][] = [];\n    for (let x = 0; x < width; ++x) {\n      verticalPass.push([]);\n    }\n\n    for (let blurCount = 0; blurCount < passes; ++blurCount) {\n      // After the octaves have been loaded in, we can blur filter the result\n      let value;\n      let sample;\n\n      // Vertical Gaussian blur pass\n      for (let x = offsetLeft, endx = width - offsetRight; x < endx; ++x) {\n        const outCol = verticalPass[x];\n        const inCol = outPass[x];\n\n        for (let y = offsetTop, endy = height - offsetBottom; y < endy; ++y) {\n          value = 0;\n\n          for (let k = 0, endk = kernal.length; k < endk; ++k) {\n            sample = clamp(y + offset[k], 0, endy - 1);\n            value += (inCol[sample] || 0) * kernal[k];\n          }\n\n          outCol[y] = value;\n        }\n      }\n\n      // Horizontal Gaussian blur into our perlin data\n      for (let x = offsetLeft, endx = width - offsetRight; x < endx; ++x) {\n        const outCol = outPass[x];\n\n        for (let y = offsetTop, endy = height - offsetBottom; y < endy; ++y) {\n          value = 0;\n\n          for (let k = 0, endk = kernal.length; k < endk; ++k) {\n            sample = clamp(x + offset[k], 0, endx - 1);\n            value += ((verticalPass[sample] || [])[y] || 0) * kernal[k];\n          }\n\n          outCol[y] = value;\n        }\n      }\n    }\n\n    return outPass;\n  }\n\n  update(options: Partial<IGaussianBlurOptions>) {\n    Object.assign(this.options, options);\n\n    if (options.kernalSize) {\n      // This is a blur kernal that will be used for sampling the zoomed in octaves\n      this.kernal = new PascalTriangle(15).gaussianKernal(\n        options.kernalSize,\n        2\n      ).kernal;\n    }\n  }\n}\n","scale-linear.ts":"import { Vec2 } from './types';\n\nexport function scaleLinear(domain: Vec2, range: Vec2) {\n  return function(x: number) {\n    return (\n      ((x - domain[0]) / (domain[1] - domain[0])) *\n      (range[1] - range[0] + range[0])\n    );\n  };\n}\n","perlin-noise.ts":"import { GaussianBlur } from './gaussian-blur';\nimport { scaleLinear } from './scale-linear';\nimport { Vec2 } from './types';\n\nconst { abs, floor, max, min, random } = Math;\n\nexport interface IPerlinOptions {\n  /** Output width */\n  width: number;\n  /** Output height */\n  height: number;\n  /** The amount of blurring to apply to the combined octaves */\n  blendPasses: number;\n  /**\n   * An octave is the start of perlin noise with a gaussian noise map. Each octave should be smaller\n   * than the end result. The octave is then scaled up then averaged with the\n   * other octaves. Octaves closer to the output size creates greater detail in regions, while\n   * octaves that are smaller creates larger features.\n   *\n   * Octaves are in the format [width, height]\n   */\n  octaves: Vec2[];\n  /**\n   * This sets the values that should appear within the perlin dataset.\n   */\n  valueRange: Vec2;\n}\n\n/**\n * This generates a 2d plane of perlin noise that is gray scale with values\n * that are 0 - 1.\n */\nexport class PerlinNoise {\n  /** The blurring kernal used to blur the data */\n  private blur: GaussianBlur;\n  /** The perlin data with values 0 - 1 */\n  data: number[][];\n  /** Used for debug rendering the output */\n  private debugContext: HTMLCanvasElement;\n  /** The options used to construct the data */\n  options: IPerlinOptions;\n\n  get width() {\n    return this.options.width;\n  }\n\n  get height() {\n    return this.options.height;\n  }\n\n  /**\n   * Provide the output size, and the size of the octaves generated.\n   */\n  constructor(options: IPerlinOptions) {\n    this.options = options;\n    this.blur = new GaussianBlur({\n      passes: options.blendPasses,\n      kernalSize: 9,\n    });\n\n    this.update(options);\n  }\n\n  /**\n   * Generates a new perlin dataset\n   */\n  async generate() {\n    const { width, height, octaves, valueRange } = this.options;\n    // This will contain the end perlin result\n    let perlin: number[][] = [];\n\n    // Loop through each octave and multiply it into the perlin output\n    octaves.forEach(octave => {\n      // Start with a smaller sized map of pure gray scale noise\n      const small: number[][] = [];\n      const smallWidth = octave[0];\n      const smallHeight = octave[1];\n      const scaleX = scaleLinear([0, width], [0, smallWidth]);\n      const scaleY = scaleLinear([0, height], [0, smallHeight]);\n\n      // Make the octave base\n      for (let x = 0; x < smallWidth; ++x) {\n        const col: number[] = [];\n        small.push(col);\n\n        for (let y = 0; y < smallHeight; ++y) {\n          col.push(random());\n        }\n      }\n\n      // Sample the octave into the size of the output perlin image\n      for (let x = 0; x < width; ++x) {\n        const col = (perlin[x] = perlin[x] || []);\n\n        for (let y = 0; y < height; ++y) {\n          col[y] = (col[y] || 1) * small[floor(scaleX(x))][floor(scaleY(y))];\n        }\n      }\n    });\n\n    // Run through the perlin noise data with our blur filter\n    perlin = this.blur.generate(perlin);\n\n    // We now normalize the ranges to keep details brighter\n    // We also make the data within each cell reflect the data range\n    // that is specified\n    let maxVal = -1;\n    const range = valueRange[1] - valueRange[0];\n    const base = valueRange[0];\n\n    for (let x = 0; x < width; ++x) {\n      const col = perlin[x];\n\n      for (let y = 0; y < height; ++y) {\n        // First brigten up darkened areas\n        // perlin[x][y] *= 1 / (perlin[x][y] + 1);\n        // Now get the max value\n        maxVal = max(col[y], maxVal);\n      }\n    }\n\n    for (let x = 0; x < width; ++x) {\n      const col = perlin[x];\n\n      for (let y = 0; y < height; ++y) {\n        col[y] /= maxVal;\n        col[y] = col[y] * range + base;\n      }\n    }\n\n    this.data = perlin;\n  }\n\n  /**\n   * Will just ensure the data object is populated with a generation.\n   */\n  async generateOnce() {\n    if (!this.data) {\n      await this.generate();\n    }\n  }\n\n  /**\n   * Retrieves a rectangular sample from the perlin data.\n   * If a threshold is included, absolute values below it will be zero'ed out.\n   */\n  sample(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    threshold?: number\n  ) {\n    const out: number[][] = [];\n\n    if (threshold) {\n      for (let i = x, end = min(this.data.length, x + width); i < end; ++i) {\n        out.push(\n          this.data[i]\n            .slice(y, y + height)\n            .map(value => (abs(value) > threshold ? value : 0))\n        );\n      }\n    } else {\n      for (let i = x, end = min(this.data.length, x + width); i < end; ++i) {\n        out.push(this.data[i].slice(y, y + height));\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Update the options for the noise generation.\n   */\n  update(options: Partial<IPerlinOptions>) {\n    Object.assign(this.options, options);\n\n    if (options.blendPasses) {\n      this.blur.update({\n        passes: options.blendPasses,\n      });\n    }\n  }\n\n  /**\n   * Renders a canvas on the screen showing the generated output.\n   */\n  debug(threshold: number = 0, clear?: boolean) {\n    if (clear) {\n      if (this.debugContext) {\n        this.debugContext.remove();\n      }\n      return;\n    }\n\n    const canvas = document.createElement('canvas').getContext('2d');\n\n    if (canvas) {\n      const { valueRange } = this.options;\n      const element = canvas.canvas;\n      document.getElementsByTagName('body')[0].appendChild(canvas.canvas);\n      const width = (element.width = this.data.length);\n      const height = (element.height = this.data[0].length);\n      const data = canvas.getImageData(0, 0, width, height);\n      let index = 0;\n      const range = valueRange[1] - valueRange[0];\n      const base = valueRange[0];\n\n      if (threshold) {\n        for (let x = 0, end = this.data.length; x < end; ++x) {\n          const col = this.data[x];\n\n          for (let y = 0, endy = col.length; y < endy; ++y) {\n            const val = 255 * (abs(col[y]) > threshold ? 1 : 0);\n            data.data[index * 4] = val;\n            data.data[index * 4 + 1] = val;\n            data.data[index * 4 + 2] = val;\n            data.data[index * 4 + 3] = 255;\n            index++;\n          }\n        }\n      } else {\n        for (let x = 0, end = this.data.length; x < end; ++x) {\n          const col = this.data[x];\n\n          for (let y = 0, endy = col.length; y < endy; ++y) {\n            const val = 255 * ((col[y] - base) / range);\n            data.data[index * 4] = val;\n            data.data[index * 4 + 1] = val;\n            data.data[index * 4 + 2] = val;\n            data.data[index * 4 + 3] = 255;\n            index++;\n          }\n        }\n      }\n\n      canvas.putImageData(data, 0, 0);\n      element.style.position = 'fixed';\n      element.style.top = '0px';\n      element.style.left = '0px';\n      element.style.zIndex = '9999';\n\n      this.debugContext = element;\n    }\n  }\n}\n","index.ts":"export * from './FIR';\nexport * from './gaussian-blur';\nexport * from './pascal-triangle';\nexport * from './perlin-noise';\nexport * from './types';\n"},"lineCount":null}},"error":null,"hash":"fad40a6764b5708815595b69632f080f","cacheData":{"env":{}}}