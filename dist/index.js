!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("three"),require("bowser")):"function"==typeof define&&define.amd?define(["three","bowser"],t):"object"==typeof exports?exports.voidgl=t(require("three"),require("bowser")):e.voidgl=t(e.three,e.bowser)}(window,function(e,t){return function(e){var t={};function n(i){if(t[i])return t[i].exports;var s=t[i]={i:i,l:!1,exports:{}};return e[i].call(s.exports,s,s.exports,n),s.l=!0,s.exports}return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="/",n(n.s=129)}([function(e,t,n){"use strict";var i;Object.defineProperty(t,"__esModule",{value:!0}),function(e){e[e.ONE=1]="ONE",e[e.TWO=2]="TWO",e[e.THREE=3]="THREE",e[e.FOUR=4]="FOUR"}(t.InstanceBlockIndex||(t.InstanceBlockIndex={})),function(e){e[e.ONE=1]="ONE",e[e.TWO=2]="TWO",e[e.THREE=3]="THREE",e[e.FOUR=4]="FOUR",e[e.ATLAS=99]="ATLAS"}(i=t.InstanceAttributeSize||(t.InstanceAttributeSize={})),t.instanceAttributeSizeFloatCount={[i.ONE]:1,[i.TWO]:2,[i.THREE]:3,[i.FOUR]:4,[i.ATLAS]:4},function(e){e[e.ONE=1]="ONE",e[e.TWO=2]="TWO",e[e.THREE=3]="THREE",e[e.FOUR=4]="FOUR",e[e.MATRIX3=9]="MATRIX3",e[e.MATRIX4=16]="MATRIX4",e[e.ATLAS=99]="ATLAS"}(t.UniformSize||(t.UniformSize={})),function(e){e[e.ONE=1]="ONE",e[e.TWO=2]="TWO",e[e.THREE=3]="THREE",e[e.FOUR=4]="FOUR"}(t.VertexAttributeSize||(t.VertexAttributeSize={})),function(e){e[e.VERTEX=1]="VERTEX",e[e.FRAGMENT=2]="FRAGMENT",e[e.ALL=3]="ALL"}(t.ShaderInjectionTarget||(t.ShaderInjectionTarget={})),function(e){e[e.NONE=0]="NONE",e[e.ALL=1]="ALL",e[e.SINGLE=2]="SINGLE"}(t.PickType||(t.PickType={})),function(e){e[e.CHANGE=0]="CHANGE",e[e.INSERT=1]="INSERT",e[e.REMOVE=2]="REMOVE"}(t.InstanceDiffType||(t.InstanceDiffType={}))},function(t,n){t.exports=e},function(e,t,n){"use strict";function i(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),i(n(125)),i(n(24)),i(n(22)),i(n(13)),i(n(46)),i(n(120)),i(n(21)),i(n(119)),i(n(47)),i(n(23)),i(n(20)),i(n(44)),i(n(118))},function(e,t,n){"use strict";function i(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),i(n(48)),i(n(114)),i(n(13))},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class i{constructor(e){this.x=0,this.y=0,this.width=0,this.height=0,this.x=e.x||e.left||0,this.y=e.y||e.top||0,this.height=e.height||(e.bottom||0)-this.y||0,this.width=e.width||(e.right||0)-this.x||0}get area(){return this.width*this.height}get bottom(){return this.y+this.height}get left(){return this.x}get mid(){return{x:this.x+this.width/2,y:this.y+this.height/2}}get right(){return this.x+this.width}get top(){return this.y}static emptyBounds(){return new i({height:0,width:0,x:0,y:0})}containsPoint(e){return!(e.x<this.x||e.y<this.y||e.x>this.right||e.y>this.bottom)}encapsulate(e){return e instanceof i?(e.x<this.x&&(this.width+=Math.abs(e.x-this.x),this.x=e.x),e.y<this.y&&(this.height+=Math.abs(e.y-this.y),this.y=e.y),this.right<e.right&&(this.width+=e.right-this.right),this.bottom<e.bottom&&(this.height+=e.bottom-this.bottom),!0):(e.x<this.x&&(this.width+=this.x-e.x,this.x=e.x),e.x>this.right&&(this.width+=e.x-this.x),e.y<this.y&&(this.height+=this.y-e.y,this.y=e.y),e.y>this.bottom&&(this.height+=e.y-this.y),!0)}fits(e){return this.width===e.width&&this.height===e.height?1:this.width>=e.width&&this.height>=e.height?2:0}hitBounds(e){return!(this.right<e.x||this.x>e.right||this.bottom<e.y||this.y>e.height)}isInside(e){return this.x>=e.x&&this.right<=e.right&&this.y>=e.y&&this.bottom<=e.bottom}toString(){return`{x: ${this.x} y:${this.y} w:${this.width} h:${this.height}}`}}t.Bounds=i},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e[e.BottomLeft=0]="BottomLeft",e[e.BottomMiddle=1]="BottomMiddle",e[e.BottomRight=2]="BottomRight",e[e.Custom=3]="Custom",e[e.Middle=4]="Middle",e[e.MiddleLeft=5]="MiddleLeft",e[e.MiddleRight=6]="MiddleRight",e[e.TopLeft=7]="TopLeft",e[e.TopMiddle=8]="TopMiddle",e[e.TopRight=9]="TopRight"}(t.AnchorType||(t.AnchorType={})),function(e){e[e.ALWAYS=1]="ALWAYS",e[e.BOUND_MAX=2]="BOUND_MAX",e[e.NEVER=3]="NEVER"}(t.ScaleType||(t.ScaleType={}))},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isBufferLocation=function(e){return e&&e.buffer&&e.buffer.value},t.isBufferLocationGroup=function(e){return e&&e.propertyToBufferLocation};t.BufferManagerBase=class{constructor(e,t){this.layer=e,this.scene=t}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1),s=n(0),r=n(2),o=n(12),a=n(112),c=n(104);class l extends o.IdentifyByKey{constructor(e){super(e),this.depth=0,this.instanceById=new Map,this.instanceVertexCount=0,this.props=Object.assign({},l.defaultProps||{},e);const{picking:t=s.PickType.NONE}=this.props;if(t===s.PickType.ALL){const e=this.getInstancePickingMethods();this.picking={currentPickMode:s.PickType.NONE,hitTest:e.hitTest,quadTree:new r.TrackedQuadTree(0,1,0,1,e.boundsAccessor),type:s.PickType.ALL}}else t===s.PickType.SINGLE?this.picking={currentPickMode:s.PickType.NONE,type:s.PickType.SINGLE,uidToInstance:new Map}:this.picking={currentPickMode:s.PickType.NONE,type:s.PickType.NONE}}get bufferManager(){return this._bufferManager}get bufferType(){return this._bufferType}destroy(){this.bufferManager&&(this.bufferManager.scene&&this.bufferManager.scene.removeLayer(this),this.bufferManager.removeFromScene(),this.bufferManager.destroy())}didUpdateProps(){}draw(){let e,t;const n=this.props.data.changeList;let i,s,r;const o=this.diffManager,a=o.processing,c=o.processor;c.incomingChangeList(n);for(let e=0,t=n.length;e<t;++e)s=(i=n[e])[0],r=this.bufferManager.getBufferLocations(s),a[i[1]](c,s,Object.values(i[2]),r);c.commit(),this.props.data.resolve();for(let n=0,i=this.uniforms.length;n<i;++n)e=this.uniforms[n],t=e.update(e),e.materialUniforms.forEach(e=>e.value=t)}getInstancePickingMethods(){throw new Error("When picking is set to PickType.ALL, the layer MUST have this method implemented; otherwise, the layer is incompatible with this picking mode.")}getModelType(){return{drawMode:i.TrianglesDrawMode,modelType:i.Mesh}}getMaterialOptions(){return{}}initShader(){return{fs:n(103),instanceAttributes:[],uniforms:[],vertexAttributes:[],vertexCount:0,vs:n(102)}}makeInstanceAttribute(e,t,n,i,s,r){return{atlas:r,block:e,blockIndex:t,name:n,size:i,update:s}}makeUniform(e,t,n,i,s){return{name:e,qualifier:s,shaderInjection:i,size:t,update:n}}setBufferManager(e){this._bufferManager?console.warn("You can not change a layer's buffer strategy once it has been instantiated."):(this._bufferManager=e,this.diffManager=new a.InstanceDiffManager(this,e),this.diffManager.makeProcessor(),this.interactions=new c.LayerInteractionHandler(this))}setBufferType(e){void 0===this._bufferType?this._bufferType=e:console.warn("You can not change a layers buffer strategy once it has been instantiated.")}willUpdateInstances(e){}willUpdateProps(e){}didUpdate(){this.props.data.resolve()}}l.defaultProps={},t.Layer=l},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(0),s=n(2),r=n(111);var o;function a(e,t,n,r){let a;if(void 0!==t.bufferType)return t.bufferType;if(s.WebGLStat.HARDWARE_INSTANCING){let e=0;for(let t=0,i=n.length;t<i;++t){const i=n[t];e+=Math.ceil(i.size/4)}for(let t=0,n=r.length;t<n;++t){const n=r[t];e+=Math.ceil(i.instanceAttributeSizeFloatCount[n.size||1]/4)}a=e>s.WebGLStat.MAX_VERTEX_ATTRIBUTES?o.UNIFORM:o.INSTANCE_ATTRIBUTE}return a||(a=o.UNIFORM),t.setBufferType(a),a}!function(e){e[e.UNIFORM=0]="UNIFORM",e[e.INSTANCE_ATTRIBUTE=1]="INSTANCE_ATTRIBUTE"}(o=t.LayerBufferType||(t.LayerBufferType={})),t.getLayerBufferType=a,t.makeLayerBufferManager=function(e,t,n){switch(a(0,t,t.vertexAttributes,t.instanceAttributes)){case o.INSTANCE_ATTRIBUTE:t.setBufferManager(new r.InstanceAttributeBufferManager(t,n));break;default:t.setBufferManager(new r.UniformBufferManager(t,n))}}},function(e,t,n){"use strict";function i(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),i(n(4)),i(n(113))},function(e,t,n){"use strict";function i(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),i(n(39)),i(n(83)),i(n(37)),i(n(36)),i(n(35)),i(n(82)),i(n(16)),i(n(34))},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1);t.generateLayerModel=function(e,t,n){const s=e.getModelType(),r=new s.modelType(t,n);return function(e){return Boolean(e.isMesh)}(r)&&(r.drawMode=void 0===s.drawMode?i.TriangleStripDrawMode:s.drawMode),r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.IdentifyByKey=class{get id(){return this.key}constructor(e){this.key=e.key}}},function(e,t,n){"use strict";var i=this&&this.__decorate||function(e,t,n,i){var s,r=arguments.length,o=r<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,n):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,i);else for(var a=e.length-1;a>=0;a--)(s=e[a])&&(o=(r<3?s(o):r>3?s(t,n,o):s(t,n))||o);return r>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const s=n(48);let r=0;class o{constructor(e){this._attributeMapping=new Map,this._easing=new Map,this.observableStorage=[],this._uid=o.newUID,this._id=e.id||"",this.active=e.active||this.active}static get newUID(){return r=++r%16777215}destroy(){}get observableDisposer(){return()=>delete this._observer}get observer(){return this._observer||null}set observer(e){const t=this._observer;t&&t!==e&&t.remove(this),this._observer=e}get attributeMapping(){return this._attributeMapping}get easing(){return this._easing}get id(){return this._id}get uid(){return this._uid}resourceTrigger(){}}i([s.observable],o.prototype,"active",void 0),t.Instance=o},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(51),s=n(4),r=n(12),o=n(20);function a(e){return"left"in e}!function(e){e[e.COLOR=1]="COLOR",e[e.DEPTH=2]="DEPTH",e[e.STENCIL=4]="STENCIL"}(t.ClearFlags||(t.ClearFlags={}));class c extends r.IdentifyByKey{constructor(e){super(e),this.depth=0,this.pixelRatio=window.devicePixelRatio,Object.assign(this,e)}screenToPixelSpace(e,t){const n=t||{x:0,y:0};return n.x=e.x*this.pixelRatio,n.y=e.y*this.pixelRatio,n}pixelSpaceToScreen(e,t){const n=t||{x:0,y:0};return n.x=e.x/this.pixelRatio,n.y=e.y/this.pixelRatio,n}screenToView(e,t){const n=this.screenToPixelSpace(e,t);return n.x=n.x-this.viewBounds.x,n.y=n.y-this.viewBounds.y,n}viewToScreen(e,t){const n={x:0,y:0};return n.x=e.x+this.viewBounds.x,n.y=e.y+this.viewBounds.y,this.pixelSpaceToScreen(n,t)}screenToWorld(e,t){const n=this.pixelSpaceToScreen(this.screenToView(e)),i=t||{x:0,y:0};return i.x=(n.x-this.camera.offset[0]*this.camera.scale[0])/this.camera.scale[0],i.y=(n.y-this.camera.offset[1]*this.camera.scale[1])/this.camera.scale[1],this.viewCamera.type===o.ViewCameraType.CUSTOM&&console.warn("Custom View Camera projections not supported yet"),i}worldToScreen(e,t){const n={x:0,y:0};return n.x=(e.x*this.camera.scale[0]+this.camera.offset[0]*this.camera.scale[0])*this.pixelRatio,n.y=(e.y*this.camera.scale[1]+this.camera.offset[1]*this.camera.scale[1])*this.pixelRatio,this.viewCamera.type===o.ViewCameraType.CUSTOM&&console.warn("Custom View Camera projections not supported yet"),this.viewToScreen(n,t)}viewToWorld(e,t){const n=t||{x:0,y:0},i=this.pixelSpaceToScreen(e);return n.x=(i.x-this.camera.offset[0]*this.camera.scale[0])/this.camera.scale[0],n.y=(i.y-this.camera.offset[1]*this.camera.scale[1])/this.camera.scale[1],this.viewCamera.type===o.ViewCameraType.CUSTOM&&console.warn("Custom View Camera projections not supported yet"),n}worldToView(e,t){const n=t||{x:0,y:0};return n.x=e.x*this.camera.scale[0]+this.camera.offset[0]*this.camera.scale[0],n.y=e.y*this.camera.scale[1]+this.camera.offset[1]*this.camera.scale[1],this.viewCamera.type===o.ViewCameraType.CUSTOM&&console.warn("Custom View Camera projections not supported yet"),n}fitViewtoViewport(e){if(this.viewCamera.type===o.ViewCameraType.CONTROLLED&&a(this.viewCamera.baseCamera)){const t=i.getAbsolutePositionBounds(this.viewport,e,this.pixelRatio),n=t.width,r=t.height,o={bottom:-r/2,far:1e7,left:-n/2,near:-100,right:n/2,top:r/2},a=1,c=1,l=this.viewCamera.baseCamera;Object.assign(l,o),l.position.set(-t.width/2*a,t.height/2*c,l.position.z),l.scale.set(a,-c,1),l.updateMatrix(),l.updateMatrixWorld(!0),l.updateProjectionMatrix(),this.viewBounds=t,this.viewBounds.data=this,this.screenBounds=new s.Bounds({height:this.viewBounds.height/this.pixelRatio,width:this.viewBounds.width/this.pixelRatio,x:this.viewBounds.x/this.pixelRatio,y:this.viewBounds.y/this.pixelRatio})}else a(this.viewCamera.baseCamera)||console.warn("Fit to viewport does not support non-orthographic cameras as a default behavior.")}}c.DEFAULT_VIEW_ID="__default__",t.View=c},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1),s=n(12);function r(e,t){return e.depth-t.depth}class o extends s.IdentifyByKey{constructor(e){super(e),this.container=new i.Scene,this.pickingContainer=new i.Scene,this.layers=[],this.sortIsDirty=!1,this.viewById=new Map,this.container.frustumCulled=!1,this.container.autoUpdate=!1}addLayer(e){this.layers.push(e),this.sortIsDirty=!0}addView(e){this.viewById.set(e.id,e)}destroy(){delete this.container}removeLayer(e){if(this.layers){const t=this.layers.indexOf(e);if(t>=0)return void this.layers.splice(t,1)}console.warn("Could not remove a layer from the scene as the layer was not a part of the scene to start. Scene:",this.id,"Layer:",e.id)}sortLayers(){this.sortIsDirty&&this.layers.sort(r)}}o.DEFAULT_SCENE_ID="__default__",t.Scene=o},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(17);t.LabelAtlasResource=class extends i.BaseAtlasResource{constructor(e){super(),this.label=e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.BaseAtlasResource=class{constructor(){this.sampleScale=1}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e[e.NONE=0]="NONE",e[e.SCREEN_CURVE=1]="SCREEN_CURVE"}(t.EdgeScaleType||(t.EdgeScaleType={})),function(e){e[e.LINE=0]="LINE",e[e.BEZIER=1]="BEZIER",e[e.BEZIER2=2]="BEZIER2"}(t.EdgeType||(t.EdgeType={})),function(e){e[e.ALL=0]="ALL",e[e.PASS_Y=1]="PASS_Y",e[e.PASS_X=2]="PASS_X"}(t.EdgeBroadphase||(t.EdgeBroadphase={}))},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(6),s=n(41),r=["x","y","z","w"],o=[];t.UniformDiffProcessor=class extends s.BaseDiffProcessor{addInstance(e,t,n,s){if(s)e.changeInstance(e,t,o,s);else{const n=e.layer.bufferManager.add(t);i.isBufferLocation(n)&&(t.active=!0,e.updateInstance(e.layer,t,n))}}changeInstance(e,t,n,i){i?e.updateInstance(e.layer,t,i):e.addInstance(e,t,o,i)}removeInstance(e,t,n,i){i&&(t.active=!1,e.updateInstance(e.layer,t,i),e.layer.bufferManager.remove(t))}updateInstance(e,t,n){if(t.active){const i=n.buffer,s=n.range[0],o=i.value;let a,c,l,h,d,u;for(let n=0,i=e.instanceAttributes.length;n<i;++n)if(c=(a=e.instanceAttributes[n]).update(t),l=o[s+a.block],a.atlas&&e.resource.setTargetAtlas(a.atlas.key),void 0!==(h=a.blockIndex))for(d=h,u=c.length+h;d<u;++d)l[r[d]]=c[d-h];i.value=o}else{const i=n.buffer,s=n.range[0],o=i.value;let a,c,l,h;if(c=(a=e.activeAttribute).update(t),l=o[s+a.block],a.atlas&&e.resource.setTargetAtlas(a.atlas.key),void 0!==(h=a.blockIndex))for(let e=h,t=c.length+h;e<t;++e)l[r[e]]=c[e-h];i.value=o}}commit(){}incomingChangeList(e){}}},function(e,t,n){"use strict";var i;Object.defineProperty(t,"__esModule",{value:!0}),function(e){e[e.CONTROLLED=0]="CONTROLLED",e[e.CUSTOM=1]="CUSTOM"}(i=t.ViewCameraType||(t.ViewCameraType={}));t.ViewCamera=class{constructor(){this.type=i.CONTROLLED}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.shaderTemplate=function(e,t,n){const i=new Map,s=new Map,r=new Map,o=new Map,a=e.replace(/\$\{(\w+)\}/g,(e,n)=>(o.set(n,(o.get(n)||0)+1),n in t?(i.set(n,(i.get(n)||0)+1),t[n]):(s.set(n,(s.get(n)||0)+1),"")));Object.keys(t).forEach(e=>{i.get(e)||r.set(e,(r.get(e)||0)+1)});const c={resolvedShaderOptions:i,shader:a,shaderProvidedOptions:o,unresolvedProvidedOptions:r,unresolvedShaderOptions:s};return n&&n.values.forEach(e=>{c.unresolvedProvidedOptions.get(e)?console.error(`${n.name}: Could not resolve all the required inputs. Input:`,e):c.unresolvedShaderOptions.get(e)?console.error(`${n.name}: A required option was not provided in the options parameter. Option:`,e):c.resolvedShaderOptions.get(e)||console.error(`${n.name}: A required option was not provided in the options parameter. Option:`,e)}),c}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});let i=0;function s(e,t){e&&t&&e.splice(0,t.length,...t)}t.ChartCamera=class{constructor(e){this._id=i++,this.offset=[0,0,0],this.scale=[1,1,1],e&&(s(this.offset,e.offset),s(this.scale,e.scale))}get id(){return this._id}position(e){this.offset=e.slice(0)}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const{sqrt:i}=Math;function s(e,t){return[e[0]+t[0]]}function r(e,t){return[e[0]*t]}function o(e,t){return[e[0]-t[0]]}function a(e,t){return[e[0]*t[0]]}function c(e,t){return e[0]*t[0]}function l(e,t,n){return r(s(o(t,e),e),n)}function h(e){return i(c(e,e))}function d(e,t){return[e[0]+t[0],e[1]+t[1]]}function u(e,t){return[e[0]*t,e[1]*t]}function p(e,t){return[e[0]-t[0],e[1]-t[1]]}function f(e,t){return[e[0]*t[0],e[1]*t[1]]}function g(e,t){return e[0]*t[0]+e[1]*t[1]}function m(e,t,n){return u(d(p(t,e),e),n)}function y(e){return i(g(e,e))}function b(e,t){return[e[0]+t[0],e[1]+t[1],e[2]+t[2]]}function v(e,t){return[e[0]*t,e[1]*t,e[2]*t]}function w(e,t){return[e[0]-t[0],e[1]-t[1],e[2]-t[2]]}function x(e,t){return[e[0]*t[0],e[1]*t[1],e[2]*t[2]]}function T(e,t,n){return v(b(w(t,e),e),n)}function I(e){return i(E(e,e))}function E(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function M(e,t){return[e[0]+t[0],e[1]+t[1],e[2]+t[2],e[3]+t[3]]}function S(e,t){return[e[0]*t,e[1]*t,e[2]*t,e[3]*t]}function A(e,t){return[e[0]-t[0],e[1]-t[1],e[2]-t[2],e[3]-t[3]]}function _(e,t){return[e[0]*t[0],e[1]*t[1],e[2]*t[2],e[3]*t[3]]}function C(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}function O(e,t,n){return S(M(A(t,e),e),n)}function k(e){return i(C(e,e))}t.add1=s,t.scale1=r,t.subtract1=o,t.multiply1=a,t.dot1=c,t.linear1=l,t.length1=h,t.add2=d,t.scale2=u,t.subtract2=p,t.multiply2=f,t.dot2=g,t.linear2=m,t.length2=y,t.add3=b,t.scale3=v,t.subtract3=w,t.multiply3=x,t.linear3=T,t.length3=I,t.dot3=E,t.add4=M,t.scale4=S,t.subtract4=A,t.multiply4=_,t.dot4=C,t.linear4=O,t.length4=k,t.vec1Methods={add:s,dot:c,length:h,linear:l,multiply:a,scale:r,subtract:o},t.vec2Methods={add:d,dot:g,length:y,linear:m,multiply:f,scale:u,subtract:p},t.vec3Methods={add:b,dot:E,length:I,linear:T,multiply:x,scale:v,subtract:w},t.vec4Methods={add:M,dot:C,length:k,linear:O,multiply:_,scale:S,subtract:A},t.VecMath=function(e){let n;return n=1===e.length?t.vec1Methods:2===e.length?t.vec2Methods:3===e.length?t.vec3Methods:t.vec4Methods}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(23),{min:s,max:r,pow:o,round:a,sin:c,PI:l}=Math,h=a(1e3*l)/1e3;function d(e,t,n){return s(r(e,t),n)}var u;!function(e){e[e.NONE=1]="NONE",e[e.CONTINUOUS=4]="CONTINUOUS",e[e.REPEAT=2]="REPEAT",e[e.REFLECT=3]="REFLECT"}(u=t.AutoEasingLoopStyle||(t.AutoEasingLoopStyle={}));const p="\n${easingMethod} {\n  return end;\n}\n",f="\n${easingMethod} {\n  return (end - start) * t + start;\n}\n",g="\n${easingMethod} {\n  float time = t * t;\n  return (end - start) * time + start;\n}\n",m="\n${easingMethod} {\n  float time = t * (2.0 - t);\n  return (end - start) * time + start;\n}\n",y="\n${easingMethod} {\n  float time = t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;\n  return (end - start) * time + start;\n}\n",b="\n${easingMethod} {\n  float time = t * t * t;\n  return (end - start) * time + start;\n}\n",v="\n${easingMethod} {\n  float t1 = t - 1.0;\n  float time = t1 * t1 * t1 + 1.0;\n  return (end - start) * time + start;\n}\n",w="\n${easingMethod} {\n  float time = t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0;\n  return (end - start) * time + start;\n}\n",x="\n${easingMethod} {\n  float time = t * t * t * t;\n  return (end - start) * time + start;\n}\n",T="\n${easingMethod} {\n  float t1 = t - 1.0;\n  float time = 1.0 - t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n",I="\n${easingMethod} {\n  float t1 = t - 1.0;\n  float time = t < 0.5 ? 8.0 * t * t * t * t : 1.0 - 8.0 * t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n",E="\n${easingMethod} {\n  float time = t * t * t * t * t;\n  return (end - start) * time + start;\n}\n",M="\n${easingMethod} {\n  float t1 = t - 1.0;\n  float time = 1.0 + t1 * t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n",S="\n${easingMethod} {\n  float t1 = t - 1.0;\n  float time = t < 0.5 ? 16.0 * t * t * t * t * t : 1.0 + 16.0 * t1 * t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n",A=`\n\${easingMethod} {\n  float p = 0.3;\n  float time = pow(2.0, -10.0 * t) * sin((t - p / 4.0) * (2.0 * ${h}) / p) + 1.0;\n  return (end - start) * time + start;\n}\n`,_=`\n\${easingMethod} {\n  float time = t * t * t - t * 1.05 * sin(t * ${h});\n  return (end - start) * time + start;\n}\n`,C="\n${easingMethod} {\n  float t1 = t - 1.0;\n  float a = 1.7;\n  float time = (t1 * t1 * ((a + 1.0) * t1 + a) + 1.0);\n  return (end - start) * time + start;\n}\n",O="\n${easingMethod} {\n  float a = 1.4;\n  float a1 = a * 1.525;\n  float t1 = t / 0.5;\n  float t2 = t1 - 2.0;\n  float time =\n    (t1 < 1.0) ? 0.5 * (t1 * t1 * (a1 + 1.0) * t1 - a1) :\n    0.5 * (t2 * t2 * ((a1 + 1.0) * t2 + a1) + 2.0)\n  ;\n\n  return (end - start) * time + start;\n}\n",k=`\n\${easingMethod} {\n  \${T} direction = end - start;\n  float amplitude = length(direction) * 2.0;\n  return start + direction * sin(t * ${h} * 2.0) * amplitude;\n}\n`;t.AutoEasingMethod=class{constructor(e,t,n,i){this.delay=0,this.duration=500,this.loop=u.NONE,this.cpu=e,this.gpu=t,this.duration=n||500,this.methodName=i||"easingMethod"}static immediate(e,t=0,n=u.NONE){return{cpu:(e,t,n)=>t,delay:t,duration:e,gpu:p,loop:n,methodName:"immediate"}}static linear(e,t=0,n=u.NONE){return{cpu:(e,t,n)=>{const{add:s,scale:r,subtract:o}=i.VecMath(e);return n=d(n,0,1),s(r(o(t,e),n),e)},delay:t,duration:e,gpu:f,loop:n,methodName:"linear"}}static easeInQuad(e,t=0,n=u.NONE){return{cpu:(e,t,n)=>{const s=(n=d(n,0,1))*n,{add:r,scale:o,subtract:a}=i.VecMath(e);return r(o(a(t,e),s),e)},delay:t,duration:e,gpu:g,loop:n,methodName:"easeInQuad"}}static easeOutQuad(e,t=0,n=u.NONE){return{cpu:(e,t,n)=>{const s=(n=d(n,0,1))*(2-n),{add:r,scale:o,subtract:a}=i.VecMath(e);return r(o(a(t,e),s),e)},delay:t,duration:e,gpu:m,loop:n,methodName:"easeOutQuad"}}static easeInOutQuad(e,t=0,n=u.NONE){return{cpu:(e,t,n)=>{const s=(n=d(n,0,1))<.5?2*n*n:(4-2*n)*n-1,{add:r,scale:o,subtract:a}=i.VecMath(e);return r(o(a(t,e),s),e)},delay:t,duration:e,gpu:y,loop:n,methodName:"easeInOutQuad"}}static easeInCubic(e,t=0,n=u.NONE){return{cpu:(e,t,n)=>{const s=(n=d(n,0,1))*n*n,{add:r,scale:o,subtract:a}=i.VecMath(e);return r(o(a(t,e),s),e)},delay:t,duration:e,gpu:b,loop:n,methodName:"easeInCubic"}}static easeOutCubic(e,t=0,n=u.NONE){return{cpu:(e,t,n)=>{n=d(n,0,1);const s=--n*n*n+1,{add:r,scale:o,subtract:a}=i.VecMath(e);return r(o(a(t,e),s),e)},delay:t,duration:e,gpu:v,loop:n,methodName:"easeOutCubic"}}static easeInOutCubic(e,t=0,n=u.NONE){return{cpu:(e,t,n)=>{const s=(n=d(n,0,1))<.5?4*n*n*n:(n-1)*(2*n-2)*(2*n-2)+1,{add:r,scale:o,subtract:a}=i.VecMath(e);return r(o(a(t,e),s),e)},delay:t,duration:e,gpu:w,loop:n,methodName:"easeInOutCubic"}}static easeInQuart(e,t=0,n=u.NONE){return{cpu:(e,t,n)=>{const s=(n=d(n,0,1))*n*n*n,{add:r,scale:o,subtract:a}=i.VecMath(e);return r(o(a(t,e),s),e)},delay:t,duration:e,gpu:x,loop:n,methodName:"easeInQuart"}}static easeOutQuart(e,t=0,n=u.NONE){return{cpu:(e,t,n)=>{n=d(n,0,1);const s=1- --n*n*n*n,{add:r,scale:o,subtract:a}=i.VecMath(e);return r(o(a(t,e),s),e)},delay:t,duration:e,gpu:T,loop:n,methodName:"easeOutQuart"}}static easeInOutQuart(e,t=0,n=u.NONE){return{cpu:(e,t,n)=>{const s=(n=d(n,0,1))<.5?8*n*n*n*n:1-8*--n*n*n*n,{add:r,scale:o,subtract:a}=i.VecMath(e);return r(o(a(t,e),s),e)},delay:t,duration:e,gpu:I,loop:n,methodName:"easeInOutQuart"}}static easeInQuint(e,t=0,n=u.NONE){return{cpu:(e,t,n)=>{const s=(n=d(n,0,1))*n*n*n*n,{add:r,scale:o,subtract:a}=i.VecMath(e);return r(o(a(t,e),s),e)},delay:t,duration:e,gpu:E,loop:n,methodName:"easeInQuint"}}static easeOutQuint(e,t=0,n=u.NONE){return{cpu:(e,t,n)=>{n=d(n,0,1);const s=1+--n*n*n*n*n,{add:r,scale:o,subtract:a}=i.VecMath(e);return r(o(a(t,e),s),e)},delay:t,duration:e,gpu:M,loop:n,methodName:"easeOutQuint"}}static easeInOutQuint(e,t=0,n=u.NONE){return{cpu:(e,t,n)=>{const s=(n=d(n,0,1))<.5?16*n*n*n*n*n:1+16*--n*n*n*n*n,{add:r,scale:o,subtract:a}=i.VecMath(e);return r(o(a(t,e),s),e)},delay:t,duration:e,gpu:S,loop:n,methodName:"easeInOutQuint"}}static easeOutElastic(e,t=0,n=u.NONE){return{cpu:(e,t,n)=>{n=d(n,0,1);const s=o(2,-10*n)*c(2*l*(n-.075)/.3)+1,{add:r,scale:a,subtract:h}=i.VecMath(e);return r(a(h(t,e),s),e)},delay:t,duration:e,gpu:A,loop:n,methodName:"easeOutElastic"}}static easeBackIn(e,t=0,n=u.NONE){return{cpu:(e,t,n)=>{const s=(n=d(n,0,1))*n*n-1.05*n*c(n*l),{add:r,scale:o,subtract:a}=i.VecMath(e);return r(o(a(t,e),s),e)},delay:t,duration:e,gpu:_,loop:n,methodName:"easeBackIn"}}static easeBackOut(e,t=0,n=u.NONE){return{cpu:(e,t,n)=>{const s=(n=d(n,0,1))-1,r=s*s*(2.7*s+1.7)+1,{add:o,scale:a,subtract:c}=i.VecMath(e);return o(a(c(t,e),r),e)},delay:t,duration:e,gpu:C,loop:n,methodName:"easeBackOut"}}static easeBackInOut(e,t=0,n=u.NONE){return{cpu:(e,t,n)=>{const s=2.5925,r=(n=d(n,0,1))/.5,o=r-2,a=r<1?.5*(r*r*(s+1)*r-s):.5*(o*o*((s+1)*o+s)+2),{add:c,scale:l,subtract:h}=i.VecMath(e);return c(l(h(t,e),a),e)},delay:t,duration:e,gpu:O,loop:n,methodName:"easeBackInOut"}}static continuousSinusoidal(e,t=0,n=u.CONTINUOUS){return{cpu:(e,t,n)=>{const{add:s,length:r,scale:o,subtract:a}=i.VecMath(e);n=d(n,0,1);const h=a(t,e),u=2*r(h);return s(e,o(h,c(n*l*2)*u))},delay:t,duration:e,gpu:k,loop:n,methodName:"repeatingSinusoidal",validation:{ignoreEndValueCheck:!0,ignoreOverTimeCheck:!0}}}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.EventManager=class{getProjection(e){return this.mouseManager.getView(e)}getView(e){return this.mouseManager&&this.mouseManager.getView(e)||null}getViewScreenBounds(e){const t=this.mouseManager.getView(e);return t?t.screenBounds:null}setMouseManager(e){this.mouseManager=e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(46),s=n(50),r=1e3;function o(e,t){return t.data.depth-e.data.depth}function a(e){return Boolean(e)}t.MouseEventManager=class{constructor(e,t,n,i){this.eventCleanup=[],this._waitingForRender=!0,this.getViewsUnderMouse=(e=>{const t=this.quadTree.query(e);return t.sort(o),t}),this.resize=(()=>{this._waitingForRender=!0}),this.context=e,this.setViews(t),this.setControllers(n),this.addContextListeners(i)}get waitingForRender(){return this._waitingForRender}set waitingForRender(e){this._waitingForRender=e,e||(this.quadTree=new s.QuadTree(0,0,0,0),this.quadTree.addAll(this.views.map(e=>e.bounds).filter(a)))}addContextListeners(e){const t=this.context;let n,s;if(e){const e=e=>{const r=i.eventElementPosition(e,t),o=this.makeInteraction(r,s,n),a=this.makeWheel(e);this.controllers.forEach(e=>{e.handleWheel(o,a)}),e.stopPropagation(),e.preventDefault()};"onwheel"in t&&(t.onwheel=e),"addEventListener"in t&&(t.addEventListener("DOMMouseScroll",e),this.eventCleanup.push(["DOMMouseScroll",e]))}t.onmouseleave=(e=>{if(this.waitingForRender)return;const r=i.eventElementPosition(e,t),o=this.makeInteraction(r,s,n);this.controllers.forEach(e=>{e.handleMouseOut(o)})}),t.onmousemove=(e=>{if(this.waitingForRender)return;const r=i.eventElementPosition(e,t),o=this.makeInteraction(r,s,n);this.controllers.forEach(e=>{e.handleMouseMove(o)})}),t.onmousedown=(e=>{if(this.waitingForRender)return;s=i.eventElementPosition(e,t);const o=this.getViewsUnderMouse(s);let a=!0;const c=Date.now();if(o.length<=0)return;n=o[0].data;const l=this.makeInteraction(s,s,n);let h=s;this.controllers.forEach(t=>{t.handleMouseDown(l,e.button)}),e.stopPropagation(),document.onmousemove=(e=>{const r=i.eventElementPosition(e,t),o=this.makeInteraction(r,s,n),c={x:r.x-h.x,y:r.y-h.y},l=this.makeDrag(r,s||{x:0,y:0},h,c);h=r,this.controllers.forEach(e=>{e.handleDrag(o,l)}),a=!1}),document.onmouseup=(e=>{document.onmousemove=null,document.onmouseup=null,document.onmouseover=null}),document.onmouseover=(e=>{const r=i.eventElementPosition(e,t),o=this.makeInteraction(r,s,n);this.controllers.forEach(e=>{e.handleMouseOver(o)}),e.stopPropagation()}),t.onmouseup=(e=>{const o=i.eventElementPosition(e,t),l=this.makeInteraction(o,s,n);this.controllers.forEach(t=>{t.handleMouseUp(l,e.button)}),a&&Date.now()-c<r&&this.controllers.forEach(t=>{t.handleClick(l,e.button)})}),t.onselectstart=function(){return!1}}),this.addTouchContextListeners()}addTouchContextListeners(){const e=this.context;e.ontouchstart=(e=>{}),e.ontouchend=(e=>{}),e.ontouchmove=(e=>{}),e.ontouchcancel=(e=>{})}getView(e){for(const t of this.views)if(t.view.id===e)return t.view;return null}makeDrag(e,t,n,i){return{screen:{current:e,delta:i,previous:n,start:t}}}makeInteraction(e,t,n){const i=this.getViewsUnderMouse(e);return{screen:{mouse:e},start:t&&n&&{mouse:n.view.screenToView(e),view:n.view},target:{mouse:i[0]&&i[0].data.view.screenToView(e),view:i[0]&&i[0].data.view},viewsUnderMouse:i.map(t=>({mouse:t.data.view.screenToView(e),view:t.data.view}))}}makeWheel(e){const t=i.normalizeWheel(e);return{wheel:[t.x,t.y]}}setControllers(e){this.controllers=e;for(const e of this.controllers)e.setMouseManager(this)}setViews(e){this.views=e}destroy(){delete this.quadTree,this.context.onmousedown=null,this.context.onmousemove=null,this.context.onmouseleave=null,this.context.onmousewheel=null,this.eventCleanup.forEach(e=>{this.context.removeEventListener(e[0],e[1])})}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1),s=n(0),r=n(2),o=n(24),a=n(8),{abs:c}=Math,l={[s.InstanceAttributeSize.ONE]:[1],[s.InstanceAttributeSize.TWO]:[1,2],[s.InstanceAttributeSize.THREE]:[1,2,3],[s.InstanceAttributeSize.FOUR]:[1,2,3,4]},h={[s.InstanceAttributeSize.ONE]:[4],[s.InstanceAttributeSize.TWO]:[4,3],[s.InstanceAttributeSize.THREE]:[4,3,2],[s.InstanceAttributeSize.FOUR]:[4,3,2,1]},d=new i.Texture;function u(e){return Boolean(e)&&e.easing&&void 0!==e.size}function p(e){return Boolean(e)}function f(e){return Boolean(e)}function g(e){return Boolean(e)}function m(e){return Object.assign({},e,{materialAttribute:null})}function y(e){return Object.assign({},e,{materialUniforms:[]})}function b(e,t){const n=[];let i=0;void 0===t&&(t=1),e.forEach(e=>{const t=e.block,s=void 0===e.blockIndex?0:e.blockIndex,r=void 0===e.size?0:e.size;for(i=Math.max(t,i);n.length-1<t;)n.push([!1,!1,!1,!1]);for(let e=s-1,i=s-1+r;e<i;++e)n[t][e]=!0});for(let e=0;e<n.length;e++)for(let i=0;i<4;i++)if(!n[e][i])for(let s=i;s<4;s++)if(!n[e][s]&&s-i+1===t)return[e,i+1];return[i+1,s.InstanceBlockIndex.ONE]}function v(e,t){return e.atlas&&!t.atlas?-1:e.easing&&!t.easing?-1:1}function w(e,t){const n=[],i=new Map;return t.forEach(e=>{if(function(e){return Boolean(e)&&e.atlas}(e)){e.size=s.InstanceAttributeSize.FOUR,e.blockIndex=s.InstanceBlockIndex.ONE;const t=e.atlas.shaderInjection||s.ShaderInjectionTarget.FRAGMENT,r=i.get(e.atlas.name);r?i.set(e.atlas.name,[r[0]||t===s.ShaderInjectionTarget.VERTEX||t===s.ShaderInjectionTarget.ALL,r[1]||t===s.ShaderInjectionTarget.FRAGMENT||t===s.ShaderInjectionTarget.ALL]):(n.push(e),i.set(e.atlas.name,[t===s.ShaderInjectionTarget.VERTEX||t===s.ShaderInjectionTarget.ALL,t===s.ShaderInjectionTarget.FRAGMENT||t===s.ShaderInjectionTarget.ALL]))}}),n.map(t=>{let n=s.ShaderInjectionTarget.FRAGMENT;if(t.atlas){const e=i.get(t.atlas.name);e&&(n=e[0]&&e[1]&&s.ShaderInjectionTarget.ALL||e[0]&&!e[1]&&s.ShaderInjectionTarget.VERTEX||!e[0]&&e[1]&&s.ShaderInjectionTarget.FRAGMENT||n)}return{name:t.atlas.name,shaderInjection:n,size:s.UniformSize.ATLAS,update:()=>e.resource.getAtlasTexture(t.atlas.key)||d}})}function x(e,t){if(e.length!==t.length)return!1;for(let n=0,i=e.length;n<i;++n)if(Math.round(100*e[n])/100!=Math.round(100*t[n])/100)return!1;return!0}t.injectShaderIO=function(e,t,n){const i=(n.instanceAttributes||[]).filter(p),d=(n.vertexAttributes||[]).filter(f),T=(n.uniforms||[]).filter(g);!function(e,t,n){t.forEach(i=>{if(void 0===i.name&&console.warn("All instance attributes MUST have a name on Layer:",e.id),t.find(e=>e!==i&&e.name===i.name)&&console.warn("An instance attribute can not have the same name used more than once:",i.name),n.find(e=>e.name===i.name)&&console.warn("An instance attribute and a vertex attribute in a layer can not share the same name:",i.name),i.easing&&i.atlas&&(console.warn("An instance attribute can not have both easing and atlas properties. Undefined behavior will occur."),console.warn(i)),i.atlas||void 0===i.size&&(console.warn("An instance attribute requires the size to be defined."),console.warn(i)),i.easing)if(void 0!==i.size){const e=l[i.size],t=h[i.size],n=i.easing.validation||{};let s=i.easing.cpu(e,t,0);x(s,e)||(console.warn("Auto Easing Validation Failed: using a time of 0 does not produce the start value"),console.warn("Start:",e,"End:",t,"Result:",s),console.warn(i)),s=i.easing.cpu(e,t,1),n.ignoreEndValueCheck||x(s,t)||(console.warn("Auto Easing Validation Failed: using a time of 1 does not produce the end value"),console.warn("Start:",e,"End:",t,"Result:",s),console.warn(i)),x(s=i.easing.cpu(e,t,-1),e)||(console.warn("Auto Easing Validation Failed: using a time of -1 does not produce the start value"),console.warn("Start:",e,"End:",t,"Result:",s),console.warn(i)),s=i.easing.cpu(e,t,2),n.ignoreOverTimeCheck||x(s,t)||(console.warn("Auto Easing Validation Failed: using a time of 2 does not produce the end value"),console.warn("Start:",e,"End:",t,"Result:",s),console.warn(i))}else console.warn("An Instance Attribute with easing MUST have a size declared")})}(t,i,d),function(e,t){const n=[];for(const e of t)u(e)&&n.push(e);for(const i of n){const{cpu:n,loop:a}=i.easing,{name:l,size:h,update:d}=i,u=r.uid();let p;i.update=(t=>{const{delay:s,duration:r}=i.easing,l=d(t),h=e.surface.frameMetrics.currentTime;p=t.easing.get(u)||{duration:r,end:l,start:l,startTime:h};let f=1;switch(a){case o.AutoEasingLoopStyle.CONTINUOUS:f=(h-p.startTime)/r;break;case o.AutoEasingLoopStyle.REPEAT:f=(h-p.startTime)/r%1;break;case o.AutoEasingLoopStyle.REFLECT:const e=(h-p.startTime)/r;f=2*c(e/2%1-.5);break;case o.AutoEasingLoopStyle.NONE:default:f=(h-p.startTime)/r}return p.start=n(p.start,p.end,f),p.startTime=h+s,p.end=l,t.easing.set(u,p),l}),i.childAttributes=[];let f=b(t,h);const g={block:f[0],blockIndex:f[1],name:`_${l}_start`,parentAttribute:i,size:h,update:e=>p.start};i.childAttributes.push(g),t.push(g);const m={block:(f=b(t,s.InstanceAttributeSize.ONE))[0],blockIndex:f[1],name:`_${l}_start_time`,parentAttribute:i,size:s.InstanceAttributeSize.ONE,update:e=>[p.startTime]};i.childAttributes.push(m),t.push(m);const y={block:(f=b(t,s.InstanceAttributeSize.ONE))[0],blockIndex:f[1],name:`_${l}_duration`,parentAttribute:i,size:s.InstanceAttributeSize.ONE,update:e=>[p.duration]};i.childAttributes.push(y),t.push(y)}}(t,i);let I=T.concat(w(t,i));I=(I=I.concat(function(e){return[{name:"projection",size:s.UniformSize.MATRIX4,update:()=>e.view.viewCamera.baseCamera.projectionMatrix.elements},{name:"modelView",size:s.UniformSize.MATRIX4,update:()=>e.view.viewCamera.baseCamera.matrix.elements},{name:"cameraOffset",size:s.UniformSize.THREE,update:()=>e.view.camera.offset},{name:"cameraScale",size:s.UniformSize.THREE,update:()=>e.view.camera.scale},{name:"viewSize",size:s.UniformSize.TWO,update:()=>[e.view.viewBounds.width,e.view.viewBounds.height]},{name:"pixelRatio",size:s.UniformSize.ONE,update:()=>[e.view.pixelRatio]},{name:"currentTime",size:s.UniformSize.ONE,update:()=>[e.surface.frameMetrics.currentTime]}]}(t))).concat(function(e){return e.picking.type===s.PickType.SINGLE?[{name:"pickingActive",shaderInjection:s.ShaderInjectionTarget.ALL,size:s.UniformSize.ONE,update:()=>[e.picking.currentPickMode===s.PickType.SINGLE?1:0]}]:[]}(t));let E=i.concat(function(e,t){const n=b(t,s.InstanceAttributeSize.ONE),i={block:n[0],blockIndex:n[1],name:"_active",size:s.InstanceAttributeSize.ONE,update:e=>[e.active?1:0]};return e.activeAttribute=i,[i]}(t,i));E=E.concat(function(e,t){if(e.picking.type===s.PickType.SINGLE){const e=b(t,s.InstanceAttributeSize.FOUR);return[{block:e[0],blockIndex:e[1],name:"_pickingColor",size:s.InstanceAttributeSize.FOUR,update:e=>{const t=16777215-e.uid;return[(t>>16)/255,((65280&t)>>8)/255,(255&t)/255,1]}}]}return[]}(t,E));const M=I.map(y),S=E.sort(v);return a.getLayerBufferType(e,t,d,S),{instanceAttributes:S,uniforms:M,vertexAttributes:function(e){return e.bufferType===a.LayerBufferType.UNIFORM?[{name:"instance",size:s.VertexAttributeSize.ONE,update:()=>[0]}]:[]}(t).concat(d||[]).map(m)}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1),s=n(0),r={[s.UniformSize.ONE]:"f",[s.UniformSize.TWO]:"v2",[s.UniformSize.THREE]:"v3",[s.UniformSize.FOUR]:"v4",[s.UniformSize.MATRIX3]:"Matrix3fv",[s.UniformSize.MATRIX4]:"Matrix4fv"},o={[s.UniformSize.ONE]:[0],[s.UniformSize.TWO]:[0,0],[s.UniformSize.THREE]:[0,0,0],[s.UniformSize.FOUR]:[0,0,0,0],[s.UniformSize.MATRIX3]:[0,0,0,0,0,0,0,0,0],[s.UniformSize.MATRIX4]:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};function a(e){return{type:r[e.size],value:o[e.size]}}t.generateLayerMaterial=function(e,t,n,s,r){const o=e.getMaterialOptions();o.vertexShader=t,o.fragmentShader=n,o.uniforms={};for(let e=0,t=s.length;e<t;++e){const t=s[e],n=a(t);o.uniforms[t.name]=n}for(let e=0,t=r.length;e<t;++e){const t=r[e];o.uniforms[t.name]={type:t.type,value:t.value}}return new i.RawShaderMaterial(o)}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1),s=n(8);function r(e){return!Array.isArray(e[0])}t.generateLayerGeometry=function(e,t,n,o){const a=[];e.bufferType===s.LayerBufferType.INSTANCE_ATTRIBUTE&&(t=1);for(let e=0,i=n.length;e<i;++e){const i=n[e];a.push(new Float32Array(i.size*o*t))}const c=n.length;let l,h,d,u=!1;for(let e=0,t=o;e<t;++e)for(let t=0;t<c;++t)if(h=n[t],l=a[t],r(d=h.update(e)))for(let t=e*h.size,n=t+h.size,i=0;t<n;++t,++i)l[t]=d[i];else u=!0;u&&console.warn("A vertex buffer updating method should not use arrays of arrays of numbers.");for(let e=0,i=n.length;e<i;++e){const i=n[e].size*o;for(let n=1,s=t;n<s;++n)a[e].copyWithin(i*n,0,i)}if(e.bufferType===s.LayerBufferType.UNIFORM){const e=a[0];for(let n=0,i=t;n<i;++n){const t=n*o;for(let i=0;i<o;++i)e[i+t]=n}}const p=new i.BufferGeometry;for(let e=0,t=n.length;e<t;++e){const t=n[e],s=new i.BufferAttribute(a[e],t.size);t.materialAttribute=s,p.addAttribute(t.name,s)}return p}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1),s=n(22),r=n(20),o=n(15),a=n(14);t.generateDefaultScene=function(e){const t=e.canvas.height,n=e.canvas.width,c={aspectRatio:n/t,bottom:-t/2,far:1e7,left:-n/2,near:-100,right:n/2,top:t/2,viewSize:t},l=new r.ViewCamera;l.baseCamera=new i.OrthographicCamera(c.left,c.right,c.top,c.bottom,c.near,c.far),l.baseCamera.scale.set(1,-1,1),l.baseCamera.position.set(0,0,-300),l.baseCamera.updateMatrixWorld(!0),l.baseCamera.updateMatrix(),l.baseCamera instanceof i.OrthographicCamera&&l.baseCamera.updateProjectionMatrix();const h=new s.ChartCamera,d={bottom:0,left:0,right:0,top:0},u=new a.View({camera:h,key:a.View.DEFAULT_VIEW_ID,viewCamera:l,viewport:d}),p=new o.Scene({key:o.Scene.DEFAULT_SCENE_ID,views:[]});return p.addView(u),{camera:h,scene:p,view:u,viewCamera:l,viewport:d}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(4);class s extends i.Bounds{static emptyBounds(){return new s({height:0,width:0,x:0,y:0})}}t.DataBounds=s},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.templateVars={attributeFragments:"attributeFragments",attributes:"attributes",blocksPerInstance:"blocksPerInstance",easingMethod:"easingMethod",easingMethods:"easingMethods",instanceBlockCount:"instanceBlockCount",instanceDataBinaryTree:"instanceDataBinaryTree",instanceDataRetrieval:"instanceDataRetrieval",instanceDestructuring:"instanceDestructuring",instanceFragments:"instanceFragments",instanceUniformDeclarations:"instanceUniformDeclarations",layerUniforms:"layerUniforms",picking:"picking",projectionMethods:"projectionMethods",shader:"shader",shaderInput:"shaderInput",T:"T",vertexAttributes:"vertexAttributes"}},function(e,t,n){"use strict";function i(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),i(n(81)),i(n(78))},function(e,t,n){"use strict";let i;Object.defineProperty(t,"__esModule",{value:!0});const s=50,{floor:r,max:o,min:a}=Math;t.LabelRasterizer=class{static async awaitContext(){for(;!i;)this.getContext(),await new Promise(e=>setTimeout(e,10))}static calculateLabelSize(e,t,n){n&&this.calculateTrucatedText(e);const s=e.label,r=t||e.sampleScale||1;this.drawLabel(s,e.truncatedText,i,r);const{minX:o,minY:a,maxX:c,maxY:l}=this.measureContents(i);e.rasterization=e.rasterization||{texture:{height:0,width:0},world:{height:0,width:0}},n?(e.rasterization.texture={height:l-a,width:c-o},e.rasterization.canvas=this.createCroppedCanvas(e,a,o),this.calculateLabelSize(e,1,!1)):e.rasterization.world={height:l-a,width:c-o}}static calculateTrucatedText(e){const t=e.label,n=t.maxWidth;if(!n)return void(e.truncatedText=t.text);this.drawLabel(t,t.text,i,1);const s=this.measureContents(i);if(s.maxX-s.minX<=n)return void(e.truncatedText=t.text);const o=t.text;let a=0,c=o.length,l=r((c-a)/2),h=0;for(;c>a&&0!==l&&h++<50;){this.drawLabel(t,`${o.substr(0,l)}...`,i,1);const{minX:e,maxX:s}=this.measureContents(i);s-e<=n?a=l:c=l;const h=r((c-a)/2)+a;if(h===l)break;l=h}e.truncatedText=0===l?"...":`${o.substr(0,l)}...`}static createCroppedCanvas(e,t,n){const s=document.createElement("canvas"),r=s.getContext("2d");if(r){const o=e.rasterization.texture;s.width=o.width,s.height=o.height,r.imageSmoothingEnabled=!1,r.drawImage(i.canvas,n,t,o.width,o.height,0,0,o.width,o.height)}else console.warn("Could not create a canvas 2d context to generate a label's cropped image.");return s}static drawLabel(e,t,n,i){const s=this.getLabelRasterizationFontSize(e,i);n.fillStyle="white",n.font=this.makeCSSFont(e,i),n.canvas.width=n.measureText(e.text).width+s,n.canvas.height=2*s,n.fillStyle="white",n.font=this.makeCSSFont(e,i),n.fillText(t,s/2,s/4+s)}static getContext(){if(!i){const e=document.createElement("canvas").getContext("2d");return e&&(i=e),e}return i}static getLabelRasterizationFontSize(e,t){return e.fontSize*t}static makeCSSFont(e,t){return`${e.fontWeight} ${this.getLabelRasterizationFontSize(e,t)}px ${e.fontFamily}`}static measureContents(e){const{width:t,height:n}=e.canvas,i=e.getImageData(0,0,t,n).data;let s,r=Number.MAX_SAFE_INTEGER,c=Number.MAX_SAFE_INTEGER,l=Number.MIN_SAFE_INTEGER,h=Number.MIN_SAFE_INTEGER;for(let e=0;e<t;++e)for(let d=0;d<n;++d)(s=i[d*(4*t)+4*e])>0&&(r=a(r,d),c=a(c,e),l=o(l,e),h=o(h,d));return h+=2,l+=2,c-=1,r=o(r-=1,0),{minX:c=o(c,0),minY:r,maxX:l,maxY:h}}static async render(e){return await this.awaitContext(),e.label.fontSize>s?(console.warn("Labels only support font sizes up to 50"),e):(this.calculateLabelSize(e,e.sampleScale,!0),e)}static renderSync(e){return this.getContext(),i?e.label.fontSize>s?(console.warn("Labels only support font sizes up to 50"),e):(this.calculateLabelSize(e,e.sampleScale,!0),e):(console.warn("Can not render a label synchronously without the canvas context being ready."),e)}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(17);t.ImageAtlasResource=class extends i.BaseAtlasResource{constructor(e){super(),this.image=e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=2;t.ColorRasterizer=class{static async awaitContext(e){for(let t=e.getContext("2d"),n=0;!Boolean(t)&&n<100;t=e.getContext("2d"),++n)await new Promise(e=>setTimeout(e,10))}static makeCSS(e){return`rgba(${Math.floor(256*e.r)}, ${Math.floor(256*e.g)}, ${Math.floor(256*e.b)}, ${e.opacity})`}static async render(e){const t=document.createElement("canvas"),n=t.getContext("2d");return await this.awaitContext(t),n?(t.width=i,t.height=i,n.imageSmoothingEnabled=!1,n.fillStyle=this.makeCSS(e.color),n.fillRect(0,0,i,i),e.rasterization.canvas=t):console.warn("Could not create a canvas 2d context to generate a color for rasterization."),e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(17);t.ColorAtlasResource=class extends i.BaseAtlasResource{constructor(e){super(),this.color=e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.SubTexture=class{constructor(){this.aspectRatio=1,this.atlasReferenceID="",this.atlasTexture=null,this.atlasTL={x:0,y:0},this.atlasTR={x:0,y:0},this.atlasBL={x:0,y:0},this.atlasBR={x:0,y:0},this.widthOnAtlas=0,this.heightOnAtlas=0,this.isValid=!1,this.pixelWidth=0,this.pixelHeight=0}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1),s=n(12),r=n(84),o=n(38);!function(e){e[e._2=2]="_2",e[e._4=4]="_4",e[e._8=8]="_8",e[e._16=16]="_16",e[e._32=32]="_32",e[e._64=64]="_64",e[e._128=128]="_128",e[e._256=256]="_256",e[e._512=512]="_512",e[e._1024=1024]="_1024",e[e._2048=2048]="_2048",e[e._4096=4096]="_4096"}(t.AtlasSize||(t.AtlasSize={}));t.Atlas=class extends s.IdentifyByKey{constructor(e){super(e),this.validResources=new Map;const t=document.createElement("canvas");this.width=t.width=e.width,this.height=t.height=e.height,this.textureSettings=e.textureSettings,this.packing=new r.PackNode(0,0,e.width,e.height),this.updateTexture(t)}invalidateResource(e){const t={x:0,y:0};e.texture.aspectRatio=1,e.texture.atlasBL=t,e.texture.atlasBR=t,e.texture.atlasTL=t,e.texture.atlasTR=t,e.texture.atlasReferenceID="",e.texture.pixelWidth=0,e.texture.pixelHeight=0,e.texture.isValid=!1}setManager(e){this.manager=e}registerResource(e){if(void 0===this.validResources.get(e)){if(!e.texture||!e.texture.isValid)return e.texture||(e.texture=new o.SubTexture),e.texture.isValid=!0,this.validResources.set(e,!0),!0;console.warn("Atlas Error:",this.id,"Attempted to add a resource to an Atlas that is already a valid resource on another atlas.","Consider Creating a new resource to be loaded into this particular atlas.","Resource:",e)}else console.warn("Atlas Error:",this.id,"A resource was trying to be added to the atlas that has already been added before.","Consider creating a new resource to indicate what you want loaded to the atlas","Resource:",e);return!1}removeResource(e){this.validResources.get(e)?(this.validResources.set(e,!1),this.invalidateResource(e)):console.warn("Atlas Error:",this.id,"Attempted to remove a resource that does not exist on this atlas.","or the resource was already considered invalidated on this atlas.","Resource:",e)}updateTexture(e){if(this.texture){const e=this.texture.image;this.texture.dispose(),this.texture=new i.Texture(e)}else this.texture=new i.Texture(e);this.texture.generateMipmaps=!0,this.texture.premultiplyAlpha=!0,this.textureSettings&&Object.assign(this.texture,this.textureSettings),this.texture.needsUpdate=!0}destroy(){this.texture.dispose(),this.validResources.forEach((e,t)=>{this.invalidateResource(t)})}}},function(e,t,n){"use strict";function i(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),i(n(88)),i(n(85))},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.BaseDiffProcessor=class{constructor(e,t){this.layer=e,this.bufferManager=t}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i="u";t.makeInstanceUniformNameArray=function(){return"instanceData"},t.makeInstanceUniformNameTree=function(e){return`${i}${e.toString(31)}`}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.instanceAttributeShaderName=function(e){return e.easing?`_${e.name}_end`:e.name}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getProgramInfo=function(e,t){const n={attributeCount:0,attributes:new Array,uniformCount:0,uniforms:new Array},i=e.getProgramParameter(t,e.ACTIVE_UNIFORMS),s=e.getProgramParameter(t,e.ACTIVE_ATTRIBUTES),r={35664:"FLOAT_VEC2",35665:"FLOAT_VEC3",35666:"FLOAT_VEC4",35667:"INT_VEC2",35668:"INT_VEC3",35669:"INT_VEC4",35670:"BOOL",35671:"BOOL_VEC2",35672:"BOOL_VEC3",35673:"BOOL_VEC4",35674:"FLOAT_MAT2",35675:"FLOAT_MAT3",35676:"FLOAT_MAT4",35678:"SAMPLER_2D",35680:"SAMPLER_CUBE",5120:"BYTE",5121:"UNSIGNED_BYTE",5122:"SHORT",5123:"UNSIGNED_SHORT",5124:"INT",5125:"UNSIGNED_INT",5126:"FLOAT"},o={35664:1,35665:1,35666:1,35667:1,35668:1,35669:1,35670:1,35671:1,35672:1,35673:1,35674:1,35675:3,35676:4,35678:1,35680:1,5120:1,5121:1,5122:1,5123:1,5124:1,5125:1,5126:1};for(let s=0;s<i;++s){const i=e.getActiveUniform(t,s);i.typeName=r[i.type],n.uniforms.push(i),n.uniformCount+=i.size,i.size=i.size*o[i.type]}for(let i=0;i<s;i++){const s=e.getActiveAttrib(t,i);s.typeName=r[s.type],n.attributes.push(s),n.attributeCount+=s.size}return n};class i{}i.MAX_VERTEX_UNIFORMS=0,i.MAX_FRAGMENT_UNIFORMS=0,i.MAX_VERTEX_ATTRIBUTES=0,i.WEBGL_SUPPORTED=!1,i.MAX_TEXTURE_SIZE=0,i.HARDWARE_INSTANCING=!1,i.HARDWARE_INSTANCING_ANGLE=!1,t.WebGLStat=i,function(){const e=function(){try{const e=document.createElement("canvas");return window.WebGLRenderingContext&&(e.getContext("webgl")||e.getContext("experimental-webgl"))}catch(e){return!1}}();e&&(i.WEBGL_SUPPORTED=!0,i.MAX_VERTEX_UNIFORMS=e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),i.MAX_FRAGMENT_UNIFORMS=e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),i.MAX_VERTEX_ATTRIBUTES=e.getParameter(e.MAX_VERTEX_ATTRIBS),i.MAX_TEXTURE_SIZE=e.getParameter(e.MAX_TEXTURE_SIZE),i.HARDWARE_INSTANCING_ANGLE=Boolean(e.getExtension("ANGLE_instanced_arrays")),i.HARDWARE_INSTANCING=i.HARDWARE_INSTANCING_ANGLE)}()},function(e,t,n){(function(i){function s(){var e;try{e=t.storage.debug}catch(e){}return!e&&void 0!==i&&"env"in i&&(e=i.env.DEBUG),e}(t=e.exports=n(122)).log=function(){return"object"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)},t.formatArgs=function(e){var n=this.useColors;if(e[0]=(n?"%c":"")+this.namespace+(n?" %c":" ")+e[0]+(n?"%c ":" ")+"+"+t.humanize(this.diff),!n)return;var i="color: "+this.color;e.splice(1,0,i,"color: inherit");var s=0,r=0;e[0].replace(/%[a-zA-Z%]/g,function(e){"%%"!==e&&"%c"===e&&(r=++s)}),e.splice(r,0,i)},t.save=function(e){try{null==e?t.storage.removeItem("debug"):t.storage.debug=e}catch(e){}},t.load=s,t.useColors=function(){if("undefined"!=typeof window&&window.process&&"renderer"===window.process.type)return!0;if("undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;return"undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},t.storage="undefined"!=typeof chrome&&void 0!==chrome.storage?chrome.storage.local:function(){try{return window.localStorage}catch(e){}}(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],t.formatters.j=function(e){try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}},t.enable(s())}).call(this,n(123))},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(124),s=n(1),r=n(45)("CommunicationsView:Mouse"),o=1/30,a=-.25,c=100,l=[0,0,0,0],h=.02,d=.1,u=.18,p=.7;let f;t.normalizeWheel=f,i.firefox?(r("Using mouse wheel for firefox"),t.normalizeWheel=f=function(e){const t=e;let n=0,i=0;return Math.sign(l[0])!==Math.sign(i)&&l.splice(0,l.length,0,0,0,0),n=t.deltaX*c,i=t.deltaY*c*h+l[0]*d+l[1]*u+l[2]*p,l.unshift(i),l.pop(),new s.Vector2(-n,-i)}):i.msie&&+i.version>=11?(r("Using mouse wheel for IE 11"),t.normalizeWheel=f=function(e){const t=e;let n=t.deltaX;void 0===n&&(n=void 0!==t.wheelDeltaX?t.wheelDeltaX*o:0);let i=t.deltaY;return void 0===i&&(i=void 0!==t.wheelDeltaY?t.wheelDeltaY*o:(t.wheelDelta||-t.detail)*a),new s.Vector2(-n,-i)}):i.msedge?(r("Using mouse wheel for MS EDGE"),t.normalizeWheel=f=function(e){const t=e;let{deltaX:n,deltaY:i}=t;void 0===n&&(n=void 0!==t.wheelDeltaX?t.wheelDeltaX*o:0),void 0===i&&(i=void 0!==t.wheelDeltaY?t.wheelDeltaY*o:t.wheelDelta||-t.detail);const r=new s.Vector2(n,-i);return r.multiplyScalar(.25),r}):(r("Using mouse wheel for Chrome"),t.normalizeWheel=f=function(e){const t=e;return new s.Vector2(t.deltaX,-t.deltaY)}),t.eventElementPosition=function(e,t){let n=0,i=0,s=0,r=0,o=t||e.nativeEvent&&e.nativeEvent.target||e.target;if(e||(e=window.event),e.pageX||e.pageY?(n=e.pageX,i=e.pageY):(e.clientX||e.clientY)&&(n=e.clientX+document.body.scrollLeft+document.documentElement.scrollLeft,i=e.clientY+document.body.scrollTop+document.documentElement.scrollTop),o.offsetParent)do{s+=o.offsetLeft,r+=o.offsetTop,o=o.offsetParent}while(o);return{x:n-s,y:i-r}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});let i=0;t.uid=function(){return++i};let s=0;t.colorUID=function(){return++s%16777215}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(47);class s{static setObservableMonitor(e){s.gatherIds=e,s.observableIds=[]}static getObservableMonitorIds(e){const t=s.observableIds.slice(0);return e&&(s.observableIds=[]),t}}s.gatherIds=!1,s.observableIds=[],s.observableNamesToUID=new Map,t.ObservableMonitoring=s,t.observable=function(e,t){let n=s.observableNamesToUID.get(t)||0;n||(n=i.uid(),s.observableNamesToUID.set(t,n)),Object.defineProperty(e,t,{configurable:!0,enumerable:!0,get:function(){return s.gatherIds&&s.observableIds.push(n),this.observableStorage[n]},set:function(e){this.observableStorage[n]=e;const t=this.observer;t&&t.instanceUpdated(this,n)}})}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(16);function s(e){return e?[e.atlasTL.x,e.atlasTL.y,e.atlasBR.x,e.atlasBR.y]:[0,0,0,0]}t.AtlasResourceManager=class{constructor(e){this.targetAtlas="",this.requestQueue=new Map,this.requestLookup=new Map,this.atlasManager=e.atlasManager}async dequeueRequests(){let e=!1;for(const[t,n]of Array.from(this.requestQueue.entries()))if(n.length>0){e=!0;const i=n.slice(0);n.length=0,await this.atlasManager.updateAtlas(t,i);const s=this.requestLookup.get(t);s&&i.forEach(e=>{const t=s.get(e);if(s.delete(e),t)for(const[e,n]of t)e.bufferManager.getBufferLocations(n)&&(n.active=!0,n.resourceTrigger())})}return e}destroy(){this.atlasManager.destroy()}getAtlasTexture(e){const t=this.atlasManager.getAtlasTexture(e);return t?t.texture:null}request(e,t,n){const r=n.texture;if(r)return s(r);if(n instanceof i.LabelAtlasResource&&!n.label.text)return s(r);let o=this.requestLookup.get(this.targetAtlas);if(o){const i=o.get(n);if(i)return i.push([e,t]),t.active=!1,s(r)}else o=new Map,this.requestLookup.set(this.targetAtlas,o);t.active=!1;let a=this.requestQueue.get(this.targetAtlas);return a||(a=[],this.requestQueue.set(this.targetAtlas,a)),a.push(n),o.set(n,[[e,t]]),s(r)}setTargetAtlas(e){this.targetAtlas=e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(4),s=5,r=10;t.filterQuery=function(e,t){const n=[];return t.forEach(t=>{e.find(e=>t instanceof e)&&n.push(t)}),n};class o{constructor(e,t){const n=e.mid;this.TL=new a(e.x,n.x,e.y,n.y,t),this.TR=new a(n.x,e.right,e.y,n.y,t),this.BL=new a(e.x,n.x,n.y,e.bottom,t),this.BR=new a(n.x,e.right,n.y,e.bottom,t)}destroy(){this.TL.destroy(),this.TR.destroy(),this.BL.destroy(),this.BR.destroy(),delete this.TL,delete this.TR,delete this.BL,delete this.BR}}t.Quadrants=o;class a{constructor(e,t,n,s,r){this.children=[],this.depth=0,arguments.length>=4?this.bounds=new i.Bounds({height:n-s,width:t-e,x:e,y:n}):this.bounds=new i.Bounds({height:1,width:1,x:0,y:0}),this.depth=r||0}destroy(){delete this.children,delete this.bounds,this.nodes&&(this.nodes.destroy(),delete this.nodes)}add(e,t){return e.isInside(this.bounds)?this.doAdd(e):(this.cover(e),this.add(e,t))}addAll(e,t){t=t||[];let n=Number.MAX_VALUE,s=Number.MAX_VALUE,r=-Number.MAX_VALUE,o=-Number.MAX_VALUE;e.forEach(e=>{e.x<n&&(n=e.x),e.right>r&&(r=e.right),e.bottom>o&&(o=e.bottom),e.y<s&&(s=e.y)}),this.cover(new i.Bounds({height:o-s,width:r-n,x:n,y:s})),e.forEach((e,t)=>this.doAdd(e))}cover(e){if(e.isInside(this.bounds))return;this.bounds.encapsulate(e),this.bounds.x-=1,this.bounds.y-=1,this.bounds.width+=2,this.bounds.height+=4;const t=this.gatherChildren([]);this.nodes&&(this.nodes.destroy(),delete this.nodes),t.forEach((e,t)=>this.doAdd(e))}doAdd(e){return this.nodes?e.isInside(this.nodes.TL.bounds)?this.nodes.TL.doAdd(e):e.isInside(this.nodes.TR.bounds)?this.nodes.TR.doAdd(e):e.isInside(this.nodes.BL.bounds)?this.nodes.BL.doAdd(e):e.isInside(this.nodes.BR.bounds)?this.nodes.BR.doAdd(e):(this.children.push(e),!0):e.isInside(this.bounds)?(this.children.push(e),this.children.length>s&&this.depth<r&&this.split(),!0):(isNaN(e.width+e.height+e.x+e.y)?console.error("Child did not fit into bounds because a dimension is NaN",e):0===e.area&&console.error("Child did not fit into bounds because the area is zero",e),!0)}gatherChildren(e){return e=e.concat(this.children),this.nodes&&(this.nodes.TL.gatherChildren(e),this.nodes.TR.gatherChildren(e),this.nodes.BL.gatherChildren(e),this.nodes.BR.gatherChildren(e)),e}query(e,t){return e instanceof i.Bounds?e.hitBounds(this.bounds)?this.queryBounds(e,[],t):[]:this.bounds.containsPoint(e)?this.queryPoint(e,[],t):[]}queryBounds(e,t,n){return this.children.forEach((n,i)=>{n.hitBounds(e)&&t.push(n)}),n&&n(this),this.nodes&&(e.hitBounds(this.nodes.TL.bounds)&&this.nodes.TL.queryBounds(e,t,n),e.hitBounds(this.nodes.TR.bounds)&&this.nodes.TR.queryBounds(e,t,n),e.hitBounds(this.nodes.BL.bounds)&&this.nodes.BL.queryBounds(e,t,n),e.hitBounds(this.nodes.BR.bounds)&&this.nodes.BR.queryBounds(e,t,n)),t}queryPoint(e,t,n){return this.children.forEach((n,i)=>{n.containsPoint(e)&&t.push(n)}),n&&n(this),this.nodes&&(this.nodes.TL.bounds.containsPoint(e)&&this.nodes.TL.queryPoint(e,t,n),this.nodes.TR.bounds.containsPoint(e)&&this.nodes.TR.queryPoint(e,t,n),this.nodes.BL.bounds.containsPoint(e)&&this.nodes.BL.queryPoint(e,t,n),this.nodes.BR.bounds.containsPoint(e)&&this.nodes.BR.queryPoint(e,t,n)),t}split(){const e=this.gatherChildren([]);for(this.nodes=new o(this.bounds,this.depth+1),this.children=[];e.length>0;){const t=e.pop();t&&this.doAdd(t)}}visit(e){const t=Boolean(e(this));this.nodes&&!t&&(this.nodes.TL.visit(e),this.nodes.TR.visit(e),this.nodes.BL.visit(e),this.nodes.BR.visit(e))}}t.Node=a;t.QuadTree=class extends a{}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(31);function s(e,t,n){const i=`${e}`,s=parseFloat(i);return isNaN(s)?0:i.indexOf("%")>-1?s/100*t:s*n}t.getAbsolutePositionBounds=function(e,t,n){0!==t.width&&0!==t.height||console.warn("An AbsolutePosition evaluated to invalid dimensions.","Please ensure that the object provided and the reference has valid dimensions","to produce dimensions with width and height that are non-zero.","item:",e,"reference:",t.toString());const r=i.DataBounds.emptyBounds();let o,a;if(e.width)r.width=s(e.width,t.width,n),void 0!==e.left?r.x=s(e.left,t.width,n):void 0!==e.right&&(r.x=t.width-s(e.right,t.width,n)-r.width);else{const i=s(e.left||0,t.width,n);(o=t.width-s(e.right||0,t.width,n)-i)<0&&console.warn("An AbsolutePosition evaluated to invalid dimensions.","Please ensure that the object provided and the reference has valid dimensions","to produce dimensions with width and height that are greater than zero.","item:",e,"reference:",t.toString()),r.x=i,r.width=o}if(e.height)r.height=s(e.height,t.height,n),void 0!==e.top?r.y=s(e.top,t.height,n):void 0!==e.bottom&&(r.y=t.height-s(e.bottom,t.height,n)-r.height);else{const i=s(e.top||0,t.height,n);(void 0===(a=t.height-s(e.bottom||0,t.height,n)-i)||a<0)&&console.warn("An AbsolutePosition evaluated to invalid dimensions.","Please ensure that the object provided and the reference has valid dimensions","to produce dimensions with width and height that are greater than zero.","item:",e,"reference:",t.toString()),r.y=i,r.height=a}return(0===r.width||0===r.height||isNaN(r.x+r.y+r.width+r.height))&&(r.x=0,r.y=0,r.width=t.width,r.height=t.height),r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(0),s=n(25);function r(e){return Boolean(e)}t.LayerMouseEvents=class extends s.EventManager{constructor(e){super(),this.isOver=new Map,this.surface=e,this.sceneViews=e.sceneViews}getSceneViewsUnderMouse(e){const t=new Map;for(const e of this.sceneViews)t.set(e.view.id,e);return e.viewsUnderMouse.map(e=>t.get(e.view.id)).filter(r)}getMouseByViewId(e){const t=new Map;for(const n of e.viewsUnderMouse)t.set(n.view.id,n.mouse);return t}handleClick(e,t){this.handleInteraction(e,(e,n,i)=>e.interactions.handleMouseClick(n,i,t))}handleDrag(e,t){this.handleInteraction(e,(e,t,n)=>e.interactions.handleMouseDrag(t,n))}handleInteraction(e,t){const n=this.getSceneViewsUnderMouse(e),i=this.getMouseByViewId(e);for(const e of n)this.handleSceneView(e,i,t);return n}handleMouseDown(e,t){this.handleInteraction(e,(e,n,i)=>e.interactions.handleMouseDown(n,i,t))}handleMouseUp(e,t){this.handleInteraction(e,(e,n,i)=>e.interactions.handleMouseUp(n,i,t))}handleMouseOver(e){}handleMouseOut(e){const t=this.getMouseByViewId(e),n=e.screen.mouse;this.isOver.forEach((e,i)=>{t.set(i.view.id,i.view.screenToView(n)),this.handleSceneView(i,t,(e,t,n)=>e.interactions.handleMouseOut(t,n))}),this.isOver.clear()}handleMouseMove(e){this.surface&&this.surface.updateColorPickRange([e.screen.mouse.x,e.screen.mouse.y],e.viewsUnderMouse.map(e=>e.view));const t=this.handleInteraction(e,(e,t,n)=>e.interactions.handleMouseMove(t,n)),n=this.getMouseByViewId(e),i=e.screen.mouse,s=new Map;t.forEach(e=>s.set(e,!0)),s.forEach((e,t)=>{this.isOver.get(t)||this.handleSceneView(t,n,(e,t,n)=>e.interactions.handleMouseOver(t,n))}),this.isOver.forEach((e,t)=>{s.get(t)||(n.set(t.view.id,t.view.screenToView(i)),this.handleSceneView(t,n,(e,t,n)=>e.interactions.handleMouseOut(t,n)))}),this.isOver=s}handleSceneView(e,t,n){const s=e.view,r=t.get(s.id);if(r)for(const t of e.scene.layers)t.picking&&t.picking.type!==i.PickType.NONE&&n(t,s,r)}handleWheel(e){}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.analyzeColorPickingRendering=function(e,t,n,i){const s={allColors:[],colorData:t,dataHeight:i,dataWidth:n,mouse:e,nearestColor:0},r=new Map;let o=0;const a=[],c=n/2,l=i/2;let h=0,d=Number.MAX_SAFE_INTEGER;for(let e=0;e<i;++e){const i=[];a.push(i);for(let s=0;s<n;++s){const n=t[o],a=t[o+1],u=t[o+2];o+=4;const p=n<<16|a<<8|u;if(r.set(p,!0),i.push(p),0!==p){const t=s-c,n=e-l,i=t*t+n*n;i<d&&(d=i,h=p)}}}return s.allColors=Array.from(r.keys()),s.nearestColor=h,s}},function(e,t){e.exports="// This portion is where the shader assigns the picking color that gets passed to the fragment shader\n  _picking_color_pass_ = _pickingColor;\n"},function(e,t){e.exports="lowp vec4 setColor(vec4 color) {\n  gl_FragColor = color;\n  return gl_FragColor;\n}\n"},function(e,t){e.exports="precision lowp float;\n\n// This contains the method required to be used on a fragment shader when a layer desires to use\n// PickType.SINGLE (color picking).\nvarying vec4 _picking_color_pass_;\n\nvec4 setColor(vec4 color) {\n  gl_FragColor = mix(color, _picking_color_pass_, pickingActive);\n\n  if (color.a == 0.0) {\n    discard;\n  }\n\n  return gl_FragColor;\n}\n"},function(e,t){e.exports="// This is the varying auto generated for the fragment shader that is needed in the vertex shader to pass the\n// color for the instance through to the fragment shader\nvarying vec4 _picking_color_pass_;\n"},function(e,t){e.exports="// These are projection methods utilizing the simpler camera breakdown approach\n\nvec3 cameraSpace(vec3 world) {\n  return (world + cameraOffset) * cameraScale;\n}\n\nvec3 cameraSpaceSize(vec3 worldSize) {\n  return worldSize * cameraScale;\n}\n\nvec4 clipSpace(vec3 world) {\n  return vec4(((projection * modelView) * vec4(cameraSpace(world), 1.0)).xyz, 1.0);\n}\n\nvec4 clipSpaceSize(vec3 worldSize) {\n  return vec4(((projection * modelView) * vec4(cameraSpaceSize(worldSize), 0.0)).xyz, 1.0);\n}\n"},function(e,t){e.exports="// When instancing is enabled, it causes a major list of uniforms to be generated\n// it also generates a massive search tree to retrieve the correct unforms in question.\n${instanceUniformDeclarations}\n\n// This is the uniforms provided by the system along with the uniforms created by the layer\n${layerUniforms}\n\n// This is the attributes generated for vertex attributes\n${vertexAttributes}\n\n// This is the methods and set up needed to retrieve a block of data for an instance\n${instanceDataRetrieval}\n\n// This is the methods generated for the automated easing of attributes\n${easingMethods}\n"},function(e,t){e.exports="// This is the injected dereferencing of the instance attributes\n  ${instanceDestructuring}\n\n  // This is a special injected instance attribute. It lets the system\n  // control specific instances ability to draw, which allows the backend\n  // system greater control on how it optimizes draw calls and it's buffers.\n  if (_active == 0.0) {\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Quick exit to prevent any geometry from arising from the instance\n    return;\n  }\n\n  ${picking}\n"},function(e,t){e.exports="precision highp float;\n\n// This is the fragment shader generated by the system\n${layerUniforms}\n\n${picking}\n\n// --------------- The fragment shader provided by the layer ------------------\n${shader}\n"},function(e,t){e.exports="// This is the vertex shader generated by the system\n${shaderInput}\n${projectionMethods}\n${picking}\n// --------------- Vertex shader provided by the layer -----------------\n${shader}\n"},function(e,t){e.exports="int instanceSize = ${instanceBlockCount};\n\nvec4 getBlock(int index, int instanceIndex) {\n  return instanceData[(instanceSize * instanceIndex) + index];\n}\n"},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1),s=n(8),r=n(0),o=n(24),a=n(21),c=n(32),l=n(42),h=n(63),d=["x","y","z","w"],u={1:"float",2:"vec2",3:"vec3",4:"vec4",9:"mat3",16:"mat4",99:"vec4"};function p(e,t){return e.easing&&!t.easing?1:-1}function f(e){if(!e.easing)return;let t="";switch(e.easing.loop){case o.AutoEasingLoopStyle.CONTINUOUS:t+=`  float _${e.name}_time = (currentTime - _${e.name}_start_time) / _${e.name}_duration;\n`;break;case o.AutoEasingLoopStyle.REPEAT:t+=`  float _${e.name}_time = clamp(fract((currentTime - _${e.name}_start_time) / _${e.name}_duration), 0.0, 1.0);\n`;break;case o.AutoEasingLoopStyle.REFLECT:t+=`  float _${e.name}_timePassed = (currentTime - _${e.name}_start_time) / _${e.name}_duration;\n`,t+=`  float _${e.name}_pingPong = abs((fract(_${e.name}_timePassed / 2.0)) - 0.5) * 2.0;\n`,t+=`  float _${e.name}_time = clamp(_${e.name}_pingPong, 0.0, 1.0);\n`;break;case o.AutoEasingLoopStyle.NONE:default:t+=`  float _${e.name}_time = clamp((currentTime - _${e.name}_start_time) / _${e.name}_duration, 0.0, 1.0);\n`}return t}function g(e,t){return d.slice(e,e+t).join("")}t.makeUniformArrayDeclaration=function(e){return{fragment:`uniform vec4 ${l.makeInstanceUniformNameArray()}[${e}];`,materialUniforms:[{name:l.makeInstanceUniformNameArray(),type:"4fv",value:new Array(e).fill(0).map(()=>new i.Vector4(0,0,0,0))}]}},t.makeInstanceRetrievalArray=function(e){const t={};t[c.templateVars.instanceBlockCount]=`${e}`;const n={name:"makeInstanceRetrievalArray",values:[c.templateVars.instanceBlockCount]};return a.shaderTemplate(h,t,n).shader},t.makeInstanceDestructuringArray=function(e,t,n){let i="";const o=t.slice(0).sort(p);return i=e.bufferType===s.LayerBufferType.INSTANCE_ATTRIBUTE?function(e){let t="";return e.forEach(e=>{e.easing&&e.size&&(t+=f(e),t+=`  ${u[e.size]} ${e.name} = ${e.easing.methodName}(_${e.name}_start, _${e.name}_end, _${e.name}_time);\n`)}),t}(o):function(e,t){let n="int instanceIndex = int(instance);";for(let e=0;e<t;++e)n+=`  vec4 block${e} = getBlock(${e}, instanceIndex);\n`;return e.forEach(e=>{const t=e.block;e.easing&&e.size?(e.size===r.InstanceAttributeSize.FOUR?n+=`  ${u[e.size]} _${e.name}_end = block${t};\n`:n+=`  ${u[e.size||1]} _${e.name}_end = block${t}.${g(e.blockIndex||0,e.size||1)};\n`,n+=f(e),n+=`  ${u[e.size]} ${e.name} = ${e.easing.methodName}(_${e.name}_start, _${e.name}_end, _${e.name}_time);\n`):e.size===r.InstanceAttributeSize.FOUR?n+=`  ${u[e.size]} ${e.name} = block${t};\n`:e.atlas?n+=`  ${u[r.InstanceAttributeSize.ATLAS]} ${e.name} = block${t};\n`:n+=`  ${u[e.size||1]} ${e.name} = block${t}.${g(e.blockIndex||0,e.size||1)};\n`}),n}(o,n)}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(8),s=n(0),r=n(21),o=n(44),a=n(32),c=n(43),l=n(64),h=n(62),d=n(61),u=n(60),p=n(59),f=n(58),g=4,m={1:"float",2:"vec2",3:"vec3",4:"vec4",9:"mat3",16:"mat4",99:"sampler2D"};function y(e,t){let n="";const i=t||s.ShaderInjectionTarget.VERTEX;return e.forEach(e=>{e.shaderInjection=e.shaderInjection||s.ShaderInjectionTarget.VERTEX,e.shaderInjection!==i&&e.shaderInjection!==s.ShaderInjectionTarget.ALL||(n+=`uniform ${e.qualifier||""}${e.qualifier?" ":""}${m[e.size]} ${e.name};\n`)}),n}t.injectFragments=function(e,t,b,v,w){const x=function(e,t,n,h){const d={};let u;e.bufferType===i.LayerBufferType.INSTANCE_ATTRIBUTE?(u={materialUniforms:[],metrics:{blocksPerInstance:0,maxInstancesPerBuffer:0}},d.instanceDataRetrieval="",d.instanceUniformDeclarations=""):u=function(e,t,n,i){const s=o.WebGLStat.MAX_VERTEX_UNIFORMS-function(e){let t=0;for(let n=0,i=e.length;n<i;++n)t+=Math.ceil(e[n].size/4);return t}(i),r=n.slice(0).sort((e,t)=>e.block-t.block);let c=r[0].block,h=0;const d=new Map,u=new Map;r.forEach(t=>{t.block!==c&&(c=t.block,h++);const n=t.size||1,i=d.get(h)||0,s=i+n;if(s>g)return void console.error("An instance attribute was specified that over fills the maximum allowed useage for a block.",`\nSource Layer: ${e.id}`,`\nMax Allowed per block ${g}`,`\nAttribute: ${t.name} Block Specified: ${t.block}`,`\nTotal blocks used with this attribute: ${s}`);d.set(h,s),t.blockIndex=i;const r=u.get(h)||new Map;if(t.blockIndex+n>g)console.error("An instance attribute was specified that would fill indices greater than the block allows.",`\nMax index per block ${g}`,`\nAttribute: ${t.name} Block Index: ${t.blockIndex} Size: ${t.size} Block Index + Size: ${t.blockIndex+(t.size||1)}`);else{for(let e=t.blockIndex;e<t.blockIndex+n;++e)if(r.get(e))return void console.error("An instance attribute was specified who's block index overaps another attributes useage",`\nMax index per block ${g}`,`\nAttribute: ${t.name} Block Index: ${t.blockIndex} Size: ${t.size} Block Index + Size: ${t.blockIndex+(t.size||1)}`);t.block=h}});const p=h+1,f=Math.floor(s/p);return{materialUniforms:function(e,t,n,i){const s=[];for(let e=0;e<t;++e)s.push(e);const r=function(e,t){let n="";const i=new Map;let s=0;t.forEach(e=>{const t=i.get(e.block)||new Map;e.qualifier&&t.set(e.qualifier,!0),s=Math.max(s,e.block)});const r=new Map;i.forEach((e,t)=>{const n=Array.from(e.keys());r.set(t,`${n.join(" ")} `)});const o=l.makeUniformArrayDeclaration(e);return n+=o.fragment,{fragment:n+="\n",materialUniforms:o.materialUniforms}}(t*n,i);return e[a.templateVars.instanceUniformDeclarations]=r.fragment,e[a.templateVars.instanceBlockCount]=`${n}`,e[a.templateVars.instanceDataRetrieval]=l.makeInstanceRetrievalArray(n),{materialUniforms:r.materialUniforms}}(t,f,p,r).materialUniforms,metrics:{blocksPerInstance:p,maxInstancesPerBuffer:f}}}(e,d,n,h);const f={[a.templateVars.layerUniforms]:y(h,s.ShaderInjectionTarget.VERTEX),[a.templateVars.vertexAttributes]:function(e,t,n){let s="";return t.forEach(e=>{s+=`attribute ${m[e.size]} ${e.qualifier||""}${e.qualifier?" ":""} ${e.name};\n`}),e.bufferType===i.LayerBufferType.INSTANCE_ATTRIBUTE&&(s+="\n// Instance Attributes\n",n.forEach(e=>{s+=`attribute ${m[e.size||1]} ${e.qualifier||""}${e.qualifier?" ":""} ${c.instanceAttributeShaderName(e)};\n`})),s}(e,t,n),[a.templateVars.easingMethods]:function(e){const t=new Map;let n="";e.forEach(e=>{if(e.easing&&e.size){let n=t.get(e.easing.methodName);n||(n=new Map,t.set(e.easing.methodName,n)),n.set(e.size,e.easing.gpu)}});const i={name:"Easing Method Generation",values:[a.templateVars.easingMethod]};return t.forEach((e,t)=>{e.forEach((e,s)=>{const o=m[s],c={[a.templateVars.easingMethod]:`${o} ${t}(${o} start, ${o} end, float t)`,[a.templateVars.T]:`${o}`},l=r.shaderTemplate(e,c,i);n+=`${l.shader}\n`})}),n}(n)};Object.assign(d,f);const b={name:"shader input",values:[a.templateVars.instanceDataRetrieval,a.templateVars.instanceUniformDeclarations,a.templateVars.layerUniforms,a.templateVars.vertexAttributes,a.templateVars.easingMethods]};return{fragment:r.shaderTemplate(p,d,b).shader,materialUniforms:u.materialUniforms,metrics:u.metrics}}(e,b,v,w);let T={[a.templateVars.projectionMethods]:r.shaderTemplate(f,{},{name:"projection methods",values:[]}).shader,[a.templateVars.picking]:function(e){return e.picking.type===s.PickType.SINGLE?n(57):""}(e),[a.templateVars.shaderInput]:x.fragment,[a.templateVars.shader]:function(e,t,i,o,c){const h={[a.templateVars.attributes]:function(e,t,i){const o={};o[a.templateVars.blocksPerInstance]=`${i}`,o[a.templateVars.instanceDestructuring]=l.makeInstanceDestructuringArray(e,t,i),o[a.templateVars.picking]=function(e){return e.picking.type===s.PickType.SINGLE?n(54):""}(e);const c={name:"instance attributes fragment",values:[a.templateVars.instanceDestructuring]};return e.picking.type===s.PickType.SINGLE&&c.values.push(a.templateVars.picking),r.shaderTemplate(u,o,c).shader}(e,i,c)},d={name:"layer vertex shader",values:[a.templateVars.attributes]};return r.shaderTemplate(t.vs,h,d).shader}(e,t,v,x.metrics.maxInstancesPerBuffer,x.metrics.blocksPerInstance)},I={name:"vertex shader composition",values:[a.templateVars.projectionMethods,a.templateVars.shaderInput,a.templateVars.shader]};e.picking.type===s.PickType.SINGLE&&I.values.push(a.templateVars.picking);const E=r.shaderTemplate(h,T,I);return T={[a.templateVars.layerUniforms]:y(w,s.ShaderInjectionTarget.FRAGMENT),[a.templateVars.shader]:function(e){return r.shaderTemplate(e.fs,{},{name:"layer fragment shader",values:[]}).shader}(t),[a.templateVars.picking]:function(e){return e.picking.type===s.PickType.SINGLE?n(56):n(55)}(e)},I={name:"fragment shader composition",values:[a.templateVars.layerUniforms,a.templateVars.shader]},e.picking.type===s.PickType.SINGLE&&I.values.push(a.templateVars.picking),{fs:r.shaderTemplate(d,T,I).shader,materialUniforms:x.materialUniforms,maxInstancesPerBuffer:x.metrics.maxInstancesPerBuffer,vs:E.shader}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1),s=n(1),r=n(40),o=n(33),a=n(4),c=n(65),l=n(0),h=n(53),d=n(31),u=n(52),p=n(30),f=n(29),g=n(28),m=n(11),y=n(27),b=n(8),v=n(26),w=n(15),x=n(10),T=n(49),I=n(14),E=new i.Color(1,1,1);function M(e){return Boolean(e.getContext)}t.createLayer=function(e,t){return[e,t]};t.LayerSurface=class{constructor(){this.atlasManager=new x.AtlasManager,this.currentViewport=new Map,this.frameMetrics={currentFrame:0,currentTime:0|Date.now(),previousTime:0|Date.now()},this.isBufferingAtlas=!1,this.layers=new Map,this.pixelRatio=window.devicePixelRatio,this.scenes=new Map,this.sceneViews=[],this.willDisposeLayer=new Map}get gl(){return this.context}addLayer(e){return e.id?this.layers.get(e.id)?(console.warn("All layer's ids must be unique per layer manager"),e):(this.layers.set(e.id,e),this.initLayer(e),e):(console.warn("All layers must have an id"),e)}async commit(e,t,n){if(!this.gl)return;t&&this.frameMetrics.currentFrame++,this.frameMetrics.previousTime=this.frameMetrics.currentTime,void 0===e?this.frameMetrics.currentTime=0|Date.now():(this.frameMetrics.previousTime===this.frameMetrics.currentTime&&(this.frameMetrics.previousTime=e),this.frameMetrics.currentTime=e);const i=Array.from(this.scenes.values()),s={},r={};for(let e=0,t=i.length;e<t;++e){const t=i[e],o=Array.from(t.viewById.values()),c=t.layers;t.sortLayers();for(let e=0,i=o.length;e<i;++e){const i=o[e],h=[];i.fitViewtoViewport(new a.Bounds({height:this.context.canvas.height,width:this.context.canvas.width,x:0,y:0}));for(let e=0,t=c.length;e<t;++e){const t=c[e];t.view=i;try{t.draw(),s[t.id]=t}catch(e){r[t.id]||(r[t.id]=[t,e])}t.picking.type===l.PickType.SINGLE&&h.push(t)}n&&n(t,i,h)}}const o=Object.values(r);if(o.length>0){const e=Object.values(s);console.warn("Some layers errored during their draw update. These layers will be removed. They can be re-added if render() is called again:",o.map(e=>e[0].id)),o.forEach(e=>{console.warn(`Layer ${e[0].id} removed for the following error:`),e[1]&&console.error(e[1].stack||e[1].message)}),this.render(e.map(e=>e.initializer))}}destroy(){this.layers.forEach(e=>e.destroy()),this.resourceManager.destroy(),this.mouseManager.destroy(),this.sceneViews.forEach(e=>e.scene.destroy()),this.renderer.dispose(),this.pickingRenderer.dispose(),this.currentViewport.clear(),o.LabelInstance.destroy(),r.ImageInstance.destroy()}async draw(e){if(this.gl){if(this.commit(e,!0,(e,t,n)=>{if(this.drawSceneView(e.container,t),n.length>0&&this.updateColorPick){const i=this.updateColorPick.mouse,s=this.updateColorPick.views;if(t.id!==this.defaultSceneElements.view.id&&s.indexOf(t)>-1){t.pixelRatio=1;const s=t.clearFlags.slice(0);t.clearFlags=[I.ClearFlags.COLOR,I.ClearFlags.DEPTH],t.fitViewtoViewport(new a.Bounds({height:this.context.canvas.height/this.pixelRatio,width:this.context.canvas.width/this.pixelRatio,x:0,y:0}));for(let e=0,t=n.length;e<t;++e){const t=n[e];t.picking.currentPickMode=l.PickType.SINGLE;try{t.draw()}catch(e){}t.picking.currentPickMode=l.PickType.NONE}this.drawSceneView(e.pickingContainer,t,this.pickingRenderer,this.pickingTarget);const r=5,o=5,c=new Uint8Array(r*o*4);this.pickingRenderer.readRenderTargetPixels(this.pickingTarget,i[0]-t.screenBounds.x-r/2,t.screenBounds.height-(i[1]-t.screenBounds.y)-o/2,r,o,c);const d=h.analyzeColorPickingRendering(i,c,r,o);for(let e=0,t=n.length;e<t;++e){const t=n[e];t.picking.type===l.PickType.SINGLE&&(t.interactions.colorPicking=d)}t.pixelRatio=this.pixelRatio,t.clearFlags=s,t.fitViewtoViewport(new a.Bounds({height:this.context.canvas.height,width:this.context.canvas.width,x:0,y:0}))}}}),this.mouseManager.waitingForRender&&(this.sceneViews.forEach(e=>{e.bounds=new d.DataBounds(e.view.screenBounds),e.bounds.data=e}),this.mouseManager.waitingForRender=!1),!this.isBufferingAtlas){this.isBufferingAtlas=!0;const e=await this.resourceManager.dequeueRequests();this.isBufferingAtlas=!1,e&&this.draw()}delete this.updateColorPick}}drawSceneView(e,t,n,i){n=n||this.renderer;const s={x:t.viewBounds.left,y:t.viewBounds.top},r=t.viewBounds,o=n.getSize(),a=n.getPixelRatio();o.width*=a,o.height*=a;const c=t.background,l=n.getContext();i||(l.enable(l.SCISSOR_TEST),l.scissor(s.x,o.height-s.y-r.height,r.width,r.height),t.background&&l.clearColor(c[0],c[1],c[2],c[3])),t.clearFlags?i?(i.setSize(r.width,r.height),n.setRenderTarget(i),n.clear(t.clearFlags.indexOf(I.ClearFlags.COLOR)>-1,t.clearFlags.indexOf(I.ClearFlags.DEPTH)>-1,t.clearFlags.indexOf(I.ClearFlags.STENCIL)>-1)):n.getContext().clear((t.clearFlags.indexOf(I.ClearFlags.COLOR)>-1?l.COLOR_BUFFER_BIT:0)|(t.clearFlags.indexOf(I.ClearFlags.DEPTH)>-1?l.DEPTH_BUFFER_BIT:0)|(t.clearFlags.indexOf(I.ClearFlags.STENCIL)>-1?l.STENCIL_BUFFER_BIT:0)):i?(i.setSize(r.width,r.height),n.setRenderTarget(i),n.clear(!0,!0)):l.clear(l.COLOR_BUFFER_BIT|l.DEPTH_BUFFER_BIT),n.setViewport(s.x/a,s.y/a,r.width,r.height),n.render(e,t.viewCamera.baseCamera,i)}getViewSize(e){for(const t of this.sceneViews)if(t.view.id===e)return t.view.screenBounds;return null}getViewWorldBounds(e){for(const t of this.sceneViews)if(t.view.id===e){const e=t.view;if(e.screenBounds){const t=e.viewToWorld({x:0,y:0}),n=e.screenToWorld({x:e.screenBounds.right,y:e.screenBounds.bottom});return new a.Bounds({bottom:n.y,left:t.x,right:n.x,top:t.y})}return null}return null}async init(e){return this.pixelRatio=e.pixelRatio||this.pixelRatio,this.setContext(e.context),this.gl?(this.initGL(e),this.initMouseManager(e),await this.initResources(e)):console.warn("Could not establish a GL context. Layer Surface will be unable to render"),this}initGL(e){if(!this.context)return void console.error("Can not initialize Layer Surface as a valid GL context was not established.");const t=this.context.canvas,n=t.width,s=t.height;this.renderer=new i.WebGLRenderer({alpha:e.background&&e.background[3]<1,antialias:!0,canvas:t,preserveDrawingBuffer:!0}),this.pickingRenderer=new i.WebGLRenderer({alpha:!1,antialias:!1,preserveDrawingBuffer:!0}),this.renderer.autoClear=!1,this.setRendererSize(n,s),this.renderer.setPixelRatio(this.pixelRatio),e.background?this.renderer.setClearColor(new i.Color(e.background[0],e.background[1],e.background[2]),e.background[3]):this.renderer.setClearColor(E),this.pickingRenderer.autoClear=!1,this.pickingRenderer.setPixelRatio(1),this.pickingRenderer.setClearColor(new i.Color(0,0,0),1),this.defaultSceneElements=p.generateDefaultScene(this.context),this.defaultSceneElements.view.background=e.background,this.scenes.set(this.defaultSceneElements.scene.id,this.defaultSceneElements.scene);let r=0;this.sceneViews.push({depth:++r,scene:this.defaultSceneElements.scene,view:this.defaultSceneElements.view}),this.context.enable(this.context.SCISSOR_TEST),e.scenes&&e.scenes.forEach(e=>{const t=new w.Scene(e);0===e.views.length&&(t.addView(this.defaultSceneElements.view),this.sceneViews.push({depth:++r,scene:t,view:this.defaultSceneElements.view})),e.views.forEach(e=>{const n=new I.View(e);n.camera=n.camera||this.defaultSceneElements.camera,n.viewCamera=n.viewCamera||this.defaultSceneElements.viewCamera,n.viewport=n.viewport||this.defaultSceneElements.viewport,n.pixelRatio=this.pixelRatio,t.addView(n);for(const e of this.sceneViews)e.view.id===n.id&&console.warn("You can NOT have two views with the same id. Please use unique identifiers for every view generated.");this.sceneViews.push({depth:++r,scene:t,view:n})}),this.scenes.set(e.key,t)})}initLayer(e){e.surface=this,e.resource=this.resourceManager;const t=this.addLayerToScene(e),n=e.initShader();n.instanceAttributes=(n.instanceAttributes||[]).filter(Boolean),n.vertexAttributes=(n.vertexAttributes||[]).filter(Boolean),n.uniforms=(n.uniforms||[]).filter(Boolean);const{vertexAttributes:i,instanceAttributes:s,uniforms:r}=y.injectShaderIO(this.gl,e,n);b.getLayerBufferType(this.gl,e,i,s);const o=c.injectFragments(e,n,i,s,r),a=f.generateLayerGeometry(e,o.maxInstancesPerBuffer,i,n.vertexCount),l=g.generateLayerMaterial(e,o.vs,o.fs,r,o.materialUniforms),h=m.generateLayerModel(e,a,l);return e.geometry=a,e.instanceAttributes=s,e.instanceVertexCount=n.vertexCount,e.material=l,e.maxInstancesPerBuffer=o.maxInstancesPerBuffer,e.model=h,e.uniforms=r,e.vertexAttributes=i,b.makeLayerBufferManager(this.gl,e,t),e}initMouseManager(e){const t=[new u.LayerMouseEvents(this)].concat(e.eventManagers||[]);this.mouseManager=new v.MouseEventManager(this.context.canvas,this.sceneViews,t,e.handlesWheelEvents)}async initResources(e){if(e.atlasResources)for(const t of e.atlasResources)await this.atlasManager.createAtlas(t);this.resourceManager=new T.AtlasResourceManager({atlasManager:this.atlasManager})}addLayerToScene(e){let t=this.scenes.get(e.props.scene||"");return t||(t=this.defaultSceneElements.scene,e.props.scene&&console.warn("Layer specified a scene that is not within the layer surface manager. Layer will be added to the default scene.")),t.addLayer(e),t}removeLayer(e){return e?this.layers.get(e&&e.id)?(e.destroy(),this.layers.delete(e.id),e):(console.warn("Tried to remove a layer that is not in the manager.",e),e):null}render(e){this.gl&&(e&&e.length>0&&e.forEach(e=>{const t=e[0],n=e[1],i=this.layers.get(n.key);if(i)i.willUpdateProps(n),Object.assign(i.props,n),i.initializer[1]=i.props,i.didUpdateProps();else{const i=new t(Object.assign({},t.defaultProps,n));i.initializer=e,this.addLayer(i)}this.willDisposeLayer.set(n.key,!1)}),this.willDisposeLayer.forEach((e,t)=>{if(e){const e=this.layers.get(t);e?this.removeLayer(e):console.warn("this.willDisposeLayer applied to a layer that does not exist in the existing layer check.")}}),this.willDisposeLayer.clear(),this.layers.forEach((e,t)=>{this.willDisposeLayer.set(t,!0)}))}fitContainer(e){const t=this.context.canvas.parentElement;if(t){const e=this.context.canvas;e.className="",e.setAttribute("style",""),t.style.position="relative",e.style.position="absolute",e.style.left="0xp",e.style.top="0xp",e.style.width="100%",e.style.height="100%",e.setAttribute("width",""),e.setAttribute("height","");const n=t.getBoundingClientRect(),i=e.getBoundingClientRect();this.resize(i.width||100,n.height||100)}}resize(e,t,n){this.pixelRatio=n||this.pixelRatio,this.sceneViews.forEach(e=>e.view.pixelRatio=this.pixelRatio),this.setRendererSize(e,t),this.renderer.setPixelRatio(this.pixelRatio),this.pickingRenderer.setPixelRatio(1),this.mouseManager.resize()}setContext(e){if(e)if(function(e){return Boolean(e.canvas)}(e))this.context=e;else if(M(e)){const t=e.getContext("webgl")||e.getContext("experimental-webgl");t?this.context=t:console.warn("A valid GL context was not found for the context provided to the surface. This surface will not be able to operate.")}else if(function(e){return Boolean(e.substr)}(e)){const t=document.getElementById(e);M(t)&&this.setContext(t)}}setRendererSize(e,t){e=e||100,t=t||100,this.renderer.setSize(e,t),this.pickingRenderer.setSize(e,t),this.pickingTarget||(this.pickingTarget=new s.WebGLRenderTarget(e,t,{magFilter:i.LinearFilter,minFilter:i.LinearFilter,stencilBuffer:!1})),this.pickingTarget.setSize(e,t)}updateColorPickRange(e,t){this.updateColorPick={mouse:e,views:t}}}},function(e,t,n){"use strict";function i(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),i(n(66)),i(n(25)),i(n(30)),i(n(29)),i(n(28)),i(n(11)),i(n(27)),i(n(7)),i(n(26)),i(n(15)),i(n(10)),i(n(14))},function(e,t){e.exports="precision highp float;\n\nvarying vec4 vertexColor;\nvarying float edgeSharpness;\nvarying float borderSize;\nvarying vec2 pointCoord;\n\nvoid main() {\n  ${attributes}\n\n  vertexColor = color * color.a;\n  float size = radius * scaleFactor;\n  borderSize = mix(\n    (thickness + 1.5) / size,\n    ((thickness * pixelRatio) / size),\n    float(pixelRatio > 1.0)\n  );\n  edgeSharpness = mix(0.8, 0.01, min((size * 3.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));\n  pointCoord = (position.xy + vec2(1.0, 1.0)) / 2.0;\n\n  // Center within clip space\n  vec4 clipCenter = clipSpace(vec3(center, depth));\n  // Center in screen space\n  vec2 screenCenter = (clipCenter.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\n  // Position in screen space\n  vec2 vertex = (position.xy * size) + screenCenter;\n  // Position back to clip space\n  gl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), clipCenter.zw);\n}\n"},function(e,t){e.exports="precision highp float;\n\n${picking}\n\n/** This is the color of the ring */\nvarying vec4 vertexColor;\n/**\n * This is how sharp the ring renders. For tiny rings, it's best to have\n * less sharpness to better convey the shape of a circle. A good starter setting:\n * edgeSharpness = mix(0.8, 0.01, min(gl_PointSize / 45.0, 1.0));\n */\nvarying float edgeSharpness;\n/**\n * This should be a value that sets the thickness of the ring in normal space\n * relative to the PointSize\n */\nvarying float borderSize;\n/**\n * Since this is now a quad instead of a point sprite, this provides what gl_PointCoord\n * used to provide.\n */\nvarying vec2 pointCoord;\n\nfloat circle(vec2 coord, float radius){\n  vec2 dist = coord - vec2(0.5);\n\n  return 1.0 - smoothstep(\n    radius - (radius * edgeSharpness),\n    radius + (radius * 0.01),\n    dot(dist, dist) * 4.0\n  );\n}\n\nvoid main() {\n  float outer_step_factor = circle(pointCoord, 1.0);\n  float inner_step_factor = circle(pointCoord, 1.0 - borderSize);\n\n  setColor(mix(\n    mix(                        // Select the outer color outside of the inner radius\n      vec4(0.0, 0.0, 0.0, 0.0),    // Select invisible outside of inner and outer radius\n      vertexColor,                  // Select outer color outside of inner, but inside outer\n      outer_step_factor\n    ),\n    vec4(0.0, 0.0, 0.0, 0.0),                 // Select inner color inside inner\n    inner_step_factor\n  ));\n}\n"},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1),s=n(9),r=n(7),o=n(0),a=n(2),{max:c}=Math;t.RingLayer=class extends r.Layer{getInstancePickingMethods(){return{boundsAccessor:e=>new s.Bounds({height:2*e.radius,width:2*e.radius,x:e.x-e.radius,y:e.y-e.radius}),hitTest:(e,t,n)=>{const i=e.radius/c(...n.camera.scale),s=[t.x-e.x,t.y-e.y];return s[0]*s[0]+s[1]*s[1]<i*i}}}initShader(){const e=this.props.scaleFactor||(()=>1),t={0:1,1:1,2:-1,3:1,4:-1,5:-1},i={0:-1,1:-1,2:-1,3:1,4:1,5:1};return{fs:n(69),instanceAttributes:[{block:0,blockIndex:o.InstanceBlockIndex.ONE,name:"center",size:o.InstanceAttributeSize.TWO,update:e=>[e.x,e.y]},{block:0,blockIndex:o.InstanceBlockIndex.THREE,name:"radius",size:o.InstanceAttributeSize.ONE,update:e=>[e.radius]},{block:0,blockIndex:o.InstanceBlockIndex.FOUR,name:"depth",size:o.InstanceAttributeSize.ONE,update:e=>[e.depth]},{block:1,blockIndex:o.InstanceBlockIndex.ONE,name:"color",size:o.InstanceAttributeSize.FOUR,update:e=>e.color},{block:2,blockIndex:o.InstanceBlockIndex.ONE,name:"thickness",size:o.InstanceAttributeSize.ONE,update:e=>[e.thickness]}],uniforms:[{name:"scaleFactor",size:o.UniformSize.ONE,update:t=>[e()]}],vertexAttributes:[{name:"position",size:o.VertexAttributeSize.THREE,update:e=>[t[e],i[e],0]}],vertexCount:6,vs:n(68)}}getModelType(){return{drawMode:i.TriangleStripDrawMode,modelType:i.Mesh}}getMaterialOptions(){return a.CommonMaterialOptions.transparentShape}}},function(e,t,n){"use strict";var i=this&&this.__decorate||function(e,t,n,i){var s,r=arguments.length,o=r<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,n):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,i);else for(var a=e.length-1;a>=0;a--)(s=e[a])&&(o=(r<3?s(o):r>3?s(t,n,o):s(t,n))||o);return r>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const s=n(3),r=n(2);class o extends r.Instance{constructor(e){super(e),this.color=[1,1,1,1],this.depth=0,this.radius=0,this.thickness=1,this.x=0,this.y=0,this.color=e.color||[1,1,1,1],this.depth=e.depth||0,this.radius=e.radius,this.thickness=e.thickness||this.thickness,this.x=e.x,this.y=e.y}get width(){return 2*this.radius}get height(){return 2*this.radius}get innerRadius(){return this.radius-this.thickness}}i([s.observable],o.prototype,"color",void 0),i([s.observable],o.prototype,"depth",void 0),i([s.observable],o.prototype,"radius",void 0),i([s.observable],o.prototype,"thickness",void 0),i([s.observable],o.prototype,"x",void 0),i([s.observable],o.prototype,"y",void 0),t.RingInstance=o},function(e,t,n){"use strict";function i(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),i(n(71)),i(n(70))},function(e,t,n){"use strict";var i=this&&this.__decorate||function(e,t,n,i){var s,r=arguments.length,o=r<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,n):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,i);else for(var a=e.length-1;a>=0;a--)(s=e[a])&&(o=(r<3?s(o):r>3?s(t,n,o):s(t,n))||o);return r>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const s=n(3),r=n(5),o={[r.AnchorType.TopLeft]:(e,t)=>{e.x=-e.padding,e.y=-e.padding},[r.AnchorType.TopMiddle]:(e,t)=>{e.x=t.width/2,e.y=-e.padding},[r.AnchorType.TopRight]:(e,t)=>{e.x=t.width+e.padding,e.y=-e.padding},[r.AnchorType.MiddleLeft]:(e,t)=>{e.x=-e.padding,e.y=t.height/2},[r.AnchorType.Middle]:(e,t)=>{e.x=t.width/2,e.y=t.height/2},[r.AnchorType.MiddleRight]:(e,t)=>{e.x=t.width+e.padding,e.y=t.height/2},[r.AnchorType.BottomLeft]:(e,t)=>{e.x=-e.padding,e.y=t.height+e.padding},[r.AnchorType.BottomMiddle]:(e,t)=>{e.x=t.width/2,e.y=t.height+e.padding},[r.AnchorType.BottomRight]:(e,t)=>{e.x=t.width+e.padding,e.y=t.height+e.padding},[r.AnchorType.Custom]:(e,t)=>{e.x=e.x||0,e.y=e.y||0}};class a extends s.Instance{constructor(e){super(e),this.color=[0,0,0,1],this.depth=0,this.height=1,this.scaling=r.ScaleType.BOUND_MAX,this.width=1,this.x=0,this.y=0,this._anchor={padding:0,type:r.AnchorType.TopLeft,x:0,y:0},this.depth=e.depth||this.depth,this.color=e.color||this.color,this.scaling=e.scaling||this.scaling,this.x=e.x||this.x,this.y=e.y||this.y,this.width=e.width||1,this.height=e.height||1,e.anchor&&this.setAnchor(e.anchor)}get anchor(){return this._anchor}setAnchor(e){const t={padding:e.padding||0,type:e.type,x:e.x||0,y:e.y||0};o[t.type](t,this),this._anchor=t}}i([s.observable],a.prototype,"color",void 0),i([s.observable],a.prototype,"depth",void 0),i([s.observable],a.prototype,"height",void 0),i([s.observable],a.prototype,"scaling",void 0),i([s.observable],a.prototype,"width",void 0),i([s.observable],a.prototype,"x",void 0),i([s.observable],a.prototype,"y",void 0),i([s.observable],a.prototype,"_anchor",void 0),t.RectangleInstance=a},function(e,t){e.exports="precision highp float;\n\nvarying vec4 vertexColor;\n\nvoid main() {\n  ${attributes}\n\n  // Figure out the size of the image as it'd show on the screen\n  vec3 screenSize = cameraSpaceSize(vec3(size, 1.0));\n  // Do the test for when the image is larger on the screen than the font size\n  bool largerOnScreen = screenSize.y > size.y;\n  // Determines if a scale mode should be used or not for the vertex\n  float useScaleMode = float(\n    (\n      scaling == 3.0 ||                  // NEVER mode - keep the image the same size always\n      (largerOnScreen && scaling == 2.0) // BOUND_MAX mode - only if we're larger than the font size do we scale down\n    ) &&\n    scaling != 1.0                       // ALWAYS mode - the image stays completely in world space allowing it to scale freely\n  );\n  // If zooms are unequal, assume one is filtered to be 1.0\n  float unequalZooms = float((cameraScale.x > cameraScale.y || cameraScale.y > cameraScale.x) && useScaleMode != 0.0);\n  // Destructure threejs's bug with the position requirement\n  float normal = position.x;\n  float side = position.y;\n  // Get the location of the anchor in world space\n  vec2 worldAnchor = location + anchor;\n  // Apply the image's tint as a tint to the image\n  vertexColor = color * color.a;\n\n  // Correct aspect ratio.\n  vec2 adjustedSize = mix(\n    size,\n    (size * cameraScale.yx),\n    unequalZooms\n  );\n\n  vec2 adjustedAnchor = mix(\n    anchor,\n    (anchor * cameraScale.yx),\n    unequalZooms\n  );\n\n  vec2 vertex = vec2(side, float(normal == 1.0)) * size + location - adjustedAnchor;\n\n  // See how scaled the size on screen will be from the actual height of the image\n  float imageScreenScale = mix(\n    screenSize.y / adjustedSize.y,\n    screenSize.x / adjustedSize.x,\n    float((cameraScale.x < 1.0) || (cameraScale.x > 1.0))\n  );\n\n  // If our screen rendering is larger than the size the image is supposed to be, then we automagically\n  // scale down our image to stay the correct size, centered on the anchor point\n  vec2 anchorToVertex = vertex - location;\n\n  // We now choose between keeping the same image size or keeping it in world space\n  vertex = mix(\n    // This option keeps the image size in world space\n    vertex,\n    // This option counters the scaling of the image on the screen keeping it a static size\n    (anchorToVertex / imageScreenScale) + location,\n    // This is the flag determining if a scale mode should be applied to the vertex\n    useScaleMode\n  );\n\n  gl_Position = clipSpace(vec3(vertex, depth));\n}\n"},function(e,t){e.exports="precision highp float;\n\n${picking}\nvarying vec4 vertexColor;\n\nvoid main() {\n  setColor(vertexColor);\n}\n"},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1),s=n(9),r=n(7),o=n(0),a=n(2),c=n(5),{min:l,max:h}=Math;t.RectangleLayer=class extends r.Layer{getInstancePickingMethods(){return{boundsAccessor:e=>{const t=[0,0];e.anchor&&(t[0]=e.anchor.x||0,t[1]=e.anchor.y||0);const n=[e.x-t[0],e.y-t[1]];return new s.Bounds({height:e.height,width:e.width,x:n[0],y:n[1]})},hitTest:(e,t,n)=>{const i=h(...n.camera.scale),r=l(...n.camera.scale);if(e.scaling===c.ScaleType.ALWAYS)return!0;if(e.scaling===c.ScaleType.BOUND_MAX){if(r<=1&&i<=1)return!0;{const n=[0,0];e.anchor&&(n[0]=e.anchor.x||0,n[1]=e.anchor.y||0);const r=[e.x-n[0]/i,e.y-n[1]/i];return new s.Bounds({height:e.height/i,width:e.width/i,x:r[0],y:r[1]}).containsPoint(t)}}if(e.scaling===c.ScaleType.NEVER){const i=[0,0];e.anchor&&(i[0]=e.anchor.x||0,i[1]=e.anchor.y||0);const r=n.worldToScreen({x:e.x-i[0]/n.camera.scale[0],y:e.y-i[1]/n.camera.scale[1]}),o=n.worldToScreen(t);return new s.Bounds({height:e.height,width:e.width,x:r.x,y:r.y}).containsPoint(o)}return!0}}}initShader(){const e={0:1,1:1,2:-1,3:1,4:-1,5:-1},t={0:0,1:0,2:0,3:1,4:1,5:1};return{fs:n(75),instanceAttributes:[{block:0,blockIndex:o.InstanceBlockIndex.ONE,name:"location",size:o.InstanceAttributeSize.TWO,update:e=>[e.x,e.y]},{block:0,blockIndex:o.InstanceBlockIndex.THREE,name:"anchor",size:o.InstanceAttributeSize.TWO,update:e=>[e.anchor.x||0,e.anchor.y||0]},{block:1,blockIndex:o.InstanceBlockIndex.ONE,name:"size",size:o.InstanceAttributeSize.TWO,update:e=>[e.width,e.height]},{block:1,blockIndex:o.InstanceBlockIndex.THREE,name:"depth",size:o.InstanceAttributeSize.ONE,update:e=>[e.depth]},{block:1,blockIndex:o.InstanceBlockIndex.FOUR,name:"scaling",size:o.InstanceAttributeSize.ONE,update:e=>[e.scaling]},{block:3,blockIndex:o.InstanceBlockIndex.ONE,name:"color",size:o.InstanceAttributeSize.FOUR,update:e=>e.color}],uniforms:[{name:"scaleFactor",size:o.UniformSize.ONE,update:e=>[1]}],vertexAttributes:[{name:"position",size:o.VertexAttributeSize.THREE,update:n=>[e[n],t[n],0]}],vertexCount:6,vs:n(74)}}getModelType(){return{drawMode:i.TriangleStripDrawMode,modelType:i.Mesh}}getMaterialOptions(){return a.CommonMaterialOptions.transparentShape}}},function(e,t,n){"use strict";function i(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),i(n(76)),i(n(73))},function(e,t,n){"use strict";var i=this&&this.__decorate||function(e,t,n,i){var s,r=arguments.length,o=r<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,n):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,i);else for(var a=e.length-1;a>=0;a--)(s=e[a])&&(o=(r<3?s(o):r>3?s(t,n,o):s(t,n))||o);return r>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const s=n(3),r=n(13),o=n(10),a=n(5),c=new Map,l={[a.AnchorType.TopLeft]:(e,t)=>{e.x=-e.padding,e.y=-e.padding},[a.AnchorType.TopMiddle]:(e,t)=>{e.x=t.width/2,e.y=-e.padding},[a.AnchorType.TopRight]:(e,t)=>{e.x=t.width+e.padding,e.y=-e.padding},[a.AnchorType.MiddleLeft]:(e,t)=>{e.x=-e.padding,e.y=t.height/2},[a.AnchorType.Middle]:(e,t)=>{e.x=t.width/2,e.y=t.height/2},[a.AnchorType.MiddleRight]:(e,t)=>{e.x=t.width+e.padding,e.y=t.height/2},[a.AnchorType.BottomLeft]:(e,t)=>{e.x=-e.padding,e.y=t.height+e.padding},[a.AnchorType.BottomMiddle]:(e,t)=>{e.x=t.width/2,e.y=t.height+e.padding},[a.AnchorType.BottomRight]:(e,t)=>{e.x=t.width+e.padding,e.y=t.height+e.padding},[a.AnchorType.Custom]:(e,t)=>{e.x=e.x||0,e.y=e.y||0}};class h extends r.Instance{constructor(e){super(e),this.color=[0,0,0,1],this.depth=0,this.maxScale=1,this.scaling=a.ScaleType.BOUND_MAX,this.scale=1,this.x=0,this.y=0,this._cssFont="",this._fontFamily="Arial",this._fontSize=12,this._fontStyle="normal",this._fontWeight=400,this._maxWidth=0,this._text="",this._width=0,this._height=0,this._isDestroyed=!1,this._anchor={padding:0,type:a.AnchorType.TopLeft,x:0,y:0},this.depth=e.depth||this.depth,this.color=e.color||this.color,this.maxScale=e.maxScale||this.maxScale,this.scaling=e.scaling||this.scaling,this.scale=e.scale||this.scale,this.x=e.x||this.x,this.y=e.y||this.y,this._fontFamily=e.fontFamily||this._fontFamily,this._fontSize=e.fontSize||this._fontSize,this._fontStyle=e.fontStyle||this._fontStyle,this._fontWeight=e.fontWeight||this._fontWeight,this._maxWidth=e.maxWidth||0,this._text=e.text||this._text,this._cssFont=o.LabelRasterizer.makeCSSFont(this,1);const t=`${this._cssFont}_${this._maxWidth}`;let n,i=c.get(this._text);i?(n=i.get(t))&&n.references++:i=new Map,n||(n={references:1,resource:new o.LabelAtlasResource(this)},e.rasterization&&(n.resource.sampleScale=e.rasterization.scale||1),n.resource.sampleScale=n.resource.sampleScale||1,o.LabelRasterizer.renderSync(n.resource),c.set(this._text,i),i.set(t,n)),this._rasterization=n,this._width=n.resource.rasterization.world.width,this._height=n.resource.rasterization.world.height,e.anchor&&this.setAnchor(e.anchor)}static destroy(){c.clear()}get cssFont(){return this._cssFont}get isDestroyed(){return this._isDestroyed}get fontFamily(){return this._fontFamily}get fontSize(){return this._fontSize}get fontStyle(){return this._fontStyle}get fontWeight(){return this._fontWeight}get maxWidth(){return this._maxWidth}get resource(){return this._rasterization.resource}get text(){return this._text}get truncatedText(){return this._rasterization.resource.truncatedText||this.text}get width(){return this._width}get height(){return this._height}get anchor(){return this._anchor}destroy(){this._isDestroyed||(this._isDestroyed=!0,this._rasterization.references--,0===this._rasterization.references&&this._rasterization.resource)}resourceTrigger(){this._rasterization=this._rasterization,this._width=this._width}setAnchor(e){const t={padding:e.padding||0,type:e.type,x:e.x||0,y:e.y||0};l[t.type](t,this),this._anchor=t}}i([s.observable],h.prototype,"color",void 0),i([s.observable],h.prototype,"depth",void 0),i([s.observable],h.prototype,"maxScale",void 0),i([s.observable],h.prototype,"scaling",void 0),i([s.observable],h.prototype,"scale",void 0),i([s.observable],h.prototype,"x",void 0),i([s.observable],h.prototype,"y",void 0),i([s.observable],h.prototype,"_width",void 0),i([s.observable],h.prototype,"_height",void 0),i([s.observable],h.prototype,"_rasterization",void 0),i([s.observable],h.prototype,"_anchor",void 0),t.LabelInstance=h},function(e,t){e.exports="precision highp float;\n\nvarying vec4 vertexColor;\nvarying vec2 texCoord;\n\nvoid main() {\n  ${attributes}\n\n  // Determine final screen size of label\n  vec3 screenSize = cameraSpaceSize(vec3(size * scale / maxScale, 1.0));\n\n  // Test whether the label is larger on the screen than the font size\n  bool largerOnScreen = screenSize.y > size.y || screenSize.x > size.x;\n\n  // Determines if a scale mode should be used or not for the vertex\n  float useScaleMode = float(\n    (\n      scaling == 3.0 ||                  // NEVER mode - keep the image the same size always\n      (largerOnScreen && scaling == 2.0) // BOUND_MAX mode - only if we're larger than the font size do we scale down\n    ) &&\n    scaling != 1.0                       // ALWAYS mode - the image stays completely in world space allowing it to scale freely\n  );\n\n  // Correct aspect ratio.  Sufficient fix for most applications.\n  // Will need another solution in the case of:\n  //  (cameraScale y != cameraScale.x) && (cameraScale.x != 1 && cameraScale.y != 1)\n\n  // If zooms are unequal, assume one is filtered to be 1.0\n  float unequalZooms = float(cameraScale.x != cameraScale.y);\n\n  vec2 adjustedSize = mix(\n    size,\n    (size * cameraScale.yx),\n    unequalZooms\n  );\n\n  // Destructure threejs's bug with the position requirement\n  float normal = position.x;\n  float side = position.y;\n\n  vec2 scaledAnchor = anchor * scale;\n\n  // Get the location of the anchor in world space\n  vec2 worldAnchor = location + scaledAnchor;\n\n  vec2 adjustedAnchor = mix(\n    scaledAnchor,\n    (scaledAnchor * cameraScale.yx),\n    unequalZooms\n  );\n\n  // Get the position of the current vertex\n  vec2 vertex = vec2(side, float(normal == 1.0)) * scale * size + location - adjustedAnchor;\n\n  // See how scaled the size on screen will be from the actual height of the label\n  float labelScreenScale = mix(\n    screenSize.y / adjustedSize.y,\n    screenSize.x / adjustedSize.x,\n    float((cameraScale.x != 1.0))\n  );\n\n  float currentScale = labelScreenScale * scale;\n\n  // If our screen rendering is larger than the size the label is supposed to be, then we automagically\n  // scale down our label to stay the correct size, centered on the anchor point\n  vec2 anchorToVertex = vertex - location;\n\n  // We now choose between keeping the same image size or keeping it in world space\n  vertex = mix(\n    // This option keeps the image size in world space\n    vertex,\n    // This option counters the scaling of the image on the screen keeping it a static size\n    (anchorToVertex / labelScreenScale) + location,\n    // This is the flag determining if a scale mode should be applied to the vertex\n    useScaleMode\n  );\n\n  // --Texture and Color\n  // Get the tex coord from our inject texture info\n  texCoord = texture.xy + ((texture.zw - texture.xy) * vec2(side, float(normal == -1.0)));\n  // Apply the label's color as a tint to the label (all labels are rendered white to the base texture)\n  vertexColor = color;\n\n  gl_Position = clipSpace(vec3(vertex, depth));\n}\n"},function(e,t){e.exports="precision highp float;\n\n${picking}\nvarying vec4 vertexColor;\nvarying vec2 texCoord;\n\nvoid main() {\n  gl_FragColor = texture2D(labelAtlas, texCoord) * vertexColor;\n  setColor(gl_FragColor * gl_FragColor.a);\n}\n"},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1),s=n(9),r=n(7),o=n(0),a=n(2),c=n(5),{max:l,min:h}=Math;t.LabelLayer=class extends r.Layer{getInstancePickingMethods(){return{boundsAccessor:e=>{const t=[e.anchor.x||0,e.anchor.y||0],n=[e.x-t[0],e.y-t[1]];return new s.Bounds({height:e.height,width:e.width,x:n[0],y:n[1]})},hitTest:(e,t,n)=>{const i=l(...n.camera.scale),r=h(...n.camera.scale);if(e.scaling===c.ScaleType.ALWAYS)return!0;if(e.scaling===c.ScaleType.BOUND_MAX){if(r<=1&&i<=1)return!0;{const i=[e.anchor.x||0,e.anchor.y||0],r=n.worldToScreen({x:e.x-i[0]/n.camera.scale[0],y:e.y-i[1]/n.camera.scale[1]}),o=n.worldToScreen(t);return new s.Bounds({height:e.height,width:e.width,x:r.x,y:r.y}).containsPoint(o)}}if(e.scaling===c.ScaleType.NEVER){const i=[e.anchor.x||0,e.anchor.y||0],r=n.worldToScreen({x:e.x-i[0]/n.camera.scale[0],y:e.y-i[1]/n.camera.scale[1]}),o=n.worldToScreen(t);return new s.Bounds({height:e.height,width:e.width,x:r.x,y:r.y}).containsPoint(o)}return!0}}}initShader(){const e={0:1,1:1,2:-1,3:1,4:-1,5:-1},t={0:0,1:0,2:0,3:1,4:1,5:1};return{fs:n(80),instanceAttributes:[{block:0,blockIndex:o.InstanceBlockIndex.ONE,name:"location",size:o.InstanceAttributeSize.TWO,update:e=>[e.x,e.y]},{block:0,blockIndex:o.InstanceBlockIndex.THREE,name:"anchor",size:o.InstanceAttributeSize.TWO,update:e=>[e.anchor.x||0,e.anchor.y||0]},{block:1,blockIndex:o.InstanceBlockIndex.ONE,name:"size",size:o.InstanceAttributeSize.TWO,update:e=>[e.width,e.height]},{block:1,blockIndex:o.InstanceBlockIndex.THREE,name:"depth",size:o.InstanceAttributeSize.ONE,update:e=>[e.depth]},{block:1,blockIndex:o.InstanceBlockIndex.FOUR,name:"scaling",size:o.InstanceAttributeSize.ONE,update:e=>[e.scaling]},{atlas:{key:this.props.atlas||"",name:"labelAtlas"},block:2,name:"texture",update:e=>this.resource.request(this,e,e.resource)},{block:3,blockIndex:o.InstanceBlockIndex.ONE,name:"color",size:o.InstanceAttributeSize.FOUR,update:e=>e.color},{block:4,blockIndex:o.InstanceBlockIndex.ONE,name:"scale",size:o.InstanceAttributeSize.ONE,update:e=>[e.scale]},{block:4,blockIndex:o.InstanceBlockIndex.TWO,name:"maxScale",size:o.InstanceAttributeSize.ONE,update:e=>[e.maxScale]}],uniforms:[{name:"scaleFactor",size:o.UniformSize.ONE,update:e=>[1]}],vertexAttributes:[{name:"position",size:o.VertexAttributeSize.THREE,update:n=>[e[n],t[n],0]}],vertexCount:6,vs:n(79)}}getModelType(){return{drawMode:i.TriangleStripDrawMode,modelType:i.Mesh}}getMaterialOptions(){return a.CommonMaterialOptions.transparentImage}}},function(e,t,n){"use strict";let i;Object.defineProperty(t,"__esModule",{value:!0});t.ImageRasterizer=class{static async awaitContext(){for(;!i;)this.getContext(),await new Promise(e=>setTimeout(e,10))}static getContext(){return i||(i=document.createElement("canvas").getContext("2d")),i}static calculateImageSize(e,t){const n=e.image.element;n?i?0!==n.width&&0!==n.height?(i.canvas.width=100,i.canvas.height=100,i.drawImage(n,0,0),e.rasterization=e.rasterization||{texture:{height:0,width:0},world:{height:0,width:0}},e.rasterization.texture={height:n.height*e.sampleScale,width:n.width*e.sampleScale},e.rasterization.world={height:n.height,width:n.width},e.rasterization.image=n):console.warn("Images provided shoud have valid dimensions! Please ensure the image is loaded first."):console.warn("The Image rasterizer was unable to establish a valid canvas context. Please ensure the system supports contexts and ensure the document is ready first."):console.warn("Image does not exist! Please ensure the resource contains a valid image.")}static async render(e){return await this.awaitContext(),this.calculateImageSize(e,e.sampleScale),e}static renderSync(e){return this.getContext(),i?(this.calculateImageSize(e,e.sampleScale),e):(console.warn("Can not render a image synchronously without the canvas context being ready."),e)}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(4),s=n(39),r=n(37),o=n(36),a=n(35),c=n(16),l=n(34),h=n(38),d=n(45)("webgl-surface:Atlas"),u={aspectRatio:0,atlasBL:{x:0,y:0},atlasBR:{x:0,y:0},atlasReferenceID:"",atlasTexture:null,atlasTL:{x:0,y:0},atlasTR:{x:0,y:0},heightOnAtlas:0,isValid:!1,pixelHeight:0,pixelWidth:0,widthOnAtlas:0};t.AtlasManager=class{constructor(){this.allAtlas=new Map}async createAtlas(e,t){const n=new s.Atlas(e);return n.setManager(this),this.allAtlas.set(n.id,n),t&&await this.updateAtlas(n.id,t),d("Atlas Created-> %o",n),n}destroy(){this.allAtlas.forEach(e=>e.destroy())}destroyAtlas(e){const t=this.allAtlas.get(e);t&&t.destroy()}setDefaultImage(e,t){return e=Object.assign(e,u,{atlasReferenceID:t})}async draw(e,t){const n=e.texture.image,s=e.id;if(!e.registerResource(t))return console.warn("Could not draw resource to the atlas as the resource was not properly registered to the atlas first",e,t),Promise.resolve(!1);const r=await this.loadImage(t);if(r&&function(e){let t=!1;return e&&e.isValid&&e.pixelWidth&&e.pixelHeight&&(t=!0),t}(t.texture)){const o=t.rasterization,a=t.texture,c={first:a,second:new i.Bounds({bottom:o.texture.height,left:0,right:o.texture.width,top:0})};c.second.width+=1,c.second.height+=1;const l=e.packing.insert(c);if(l){d("Atlas location determined: %o",l),l.nodeImage=a;const t=l.nodeDimensions.x/e.width,c=l.nodeDimensions.y/e.height,h=l.nodeDimensions.width/e.width,u=l.nodeDimensions.height/e.height,p=1/e.width,f=new i.Bounds({bottom:1-c,left:t,right:t+h,top:1-(c+u)}),g=f.bottom,m=f.y,y=f.x,b=f.x+f.width-p;return a.atlasReferenceID=s,a.atlasTL={x:y,y:m},a.atlasBR={x:b,y:g},a.atlasBL={x:y,y:g},a.atlasTR={x:b,y:m},a.widthOnAtlas=Math.abs(a.atlasTR.x-a.atlasTL.x),a.heightOnAtlas=Math.abs(a.atlasTR.y-a.atlasBR.y),a.pixelWidth=o.texture.width,a.pixelHeight=o.texture.height,n.getContext("2d").drawImage(r,l.nodeDimensions.x,l.nodeDimensions.y),!0}return console.error("Could not fit resource into atlas",t),t.texture=this.setDefaultImage(t.texture,s),!1}return console.error("Could not load resource:",t),t.texture=this.setDefaultImage(t.texture,s),!1}getAtlasTexture(e){return this.allAtlas.get(e)}async loadImage(e){let t="";const n=e.texture||new h.SubTexture;if(e.texture=n,e instanceof a.ImageAtlasResource){if(e.image.element){if(0!==e.image.element.width&&0!==e.image.element.height){const t=e.image.element;return n.pixelWidth=t.width,n.pixelHeight=t.height,n.aspectRatio=t.width/t.height,t}return await new Promise((t,i)=>{const s=e.image.element;s?(s.onload=function(){n.pixelWidth=s.width,n.pixelHeight=s.height,n.aspectRatio=s.width/s.height,t(s)},s.onerror=function(){t(null)}):t(null)})}e.image.path&&(t=e.image.path)}else e instanceof c.LabelAtlasResource?(e.rasterization.canvas||await l.LabelRasterizer.render(e),e.rasterization.canvas?(d("Rasterized label %o",e.rasterization),t=e.rasterization.canvas.toDataURL("image/png")):console.warn("The label was not able to be rasterized")):e instanceof r.ColorAtlasResource&&(e.rasterization.canvas||await o.ColorRasterizer.render(e),e.rasterization.canvas?(d("Rasterized color %o",e.rasterization),t=e.rasterization.canvas.toDataURL("image/png")):console.warn("The color was not able to be rasterized"));return t?await new Promise((e,i)=>{const s=new Image;s.onload=function(){n.pixelWidth=s.width,n.pixelHeight=s.height,n.aspectRatio=s.width/s.height,e(s)},s.onerror=function(){e(null)},s.src=t}):null}async updateAtlas(e,t){const n=this.allAtlas.get(e);if(n){for(const e of t)await this.draw(n,e);n.updateTexture()}else console.warn("Can not update non-existing atlas:",e,"These resources will not be loaded:",t)}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(4);class s{constructor(e,t,n,s){this.child=[null,null],this.isLeaf=!0,this.nodeImage=null,this.nodeDimensions=new i.Bounds({height:s,width:n,x:e,y:t})}destroy(){const e=this.child[0],t=this.child[1];this.nodeImage=null,e&&e.destroy(),t&&t.destroy(),this.child[0]=null,this.child[1]=null}hasChild(){const e=this.child[0],t=this.child[1];return e&&!e.nodeImage?!e.isLeaf:!(!t||t.nodeImage)&&!t.isLeaf}insert(e){let t=this.child[0],n=this.child[1];if(!this.isLeaf&&t&&n){const i=t.insert(e);return null!==i?i:n.insert(e)}{if(this.nodeImage)return null;const i=this.nodeDimensions.fits(e.second);if(0===i)return null;if(1===i)return this;this.isLeaf=!1;const r=e.second.width,o=e.second.height,a=this.nodeDimensions.width-r,c=this.nodeDimensions.height-e.second.height;a>c?(t=this.child[0]=new s(this.nodeDimensions.x,this.nodeDimensions.y,r,this.nodeDimensions.height),n=this.child[1]=new s(this.nodeDimensions.x+r,this.nodeDimensions.y,a,this.nodeDimensions.height)):(t=this.child[0]=new s(this.nodeDimensions.x,this.nodeDimensions.y,this.nodeDimensions.width,o),n=this.child[1]=new s(this.nodeDimensions.x,this.nodeDimensions.y+o,this.nodeDimensions.width,c))}return t.insert(e)}remove(e){const t=this.child[0],n=this.child[1];if(n&&t&&!this.isLeaf){let i=t.remove(e);return!!i||(i=n.remove(e),t.hasChild()||n.hasChild()||(this.child[0]=null,this.child[1]=null),i)}return this.nodeImage===e&&(this.nodeImage=null,delete e.atlasReferenceID,e.pixelWidth=0,!0)}}t.PackNode=s},function(e,t,n){"use strict";var i=this&&this.__decorate||function(e,t,n,i){var s,r=arguments.length,o=r<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,n):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,i);else for(var a=e.length-1;a>=0;a--)(s=e[a])&&(o=(r<3?s(o):r>3?s(t,n,o):s(t,n))||o);return r>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const s=n(3),r=n(13),o=n(10),a=n(5),{max:c}=Math,l=new Map,h={[a.AnchorType.TopLeft]:(e,t)=>{e.x=-e.padding,e.y=-e.padding},[a.AnchorType.TopMiddle]:(e,t)=>{e.x=t.width/2,e.y=-e.padding},[a.AnchorType.TopRight]:(e,t)=>{e.x=t.width+e.padding,e.y=-e.padding},[a.AnchorType.MiddleLeft]:(e,t)=>{e.x=-e.padding,e.y=t.height/2},[a.AnchorType.Middle]:(e,t)=>{e.x=t.width/2,e.y=t.height/2},[a.AnchorType.MiddleRight]:(e,t)=>{e.x=t.width+e.padding,e.y=t.height/2},[a.AnchorType.BottomLeft]:(e,t)=>{e.x=-e.padding,e.y=t.height+e.padding},[a.AnchorType.BottomMiddle]:(e,t)=>{e.x=t.width/2,e.y=t.height+e.padding},[a.AnchorType.BottomRight]:(e,t)=>{e.x=t.width+e.padding,e.y=t.height+e.padding},[a.AnchorType.Custom]:(e,t)=>{e.x=e.x||0,e.y=e.y||0}};class d extends r.Instance{constructor(e){super(e),this.tint=[0,0,0,1],this.depth=0,this.height=1,this.scaling=a.ScaleType.BOUND_MAX,this.width=1,this.x=0,this.y=0,this._sourceWidth=0,this._sourceHeight=0,this._isDestroyed=!1,this._anchor={padding:0,type:a.AnchorType.TopLeft,x:0,y:0},this.depth=e.depth||this.depth,this.tint=e.tint||this.tint,this.scaling=e.scaling||this.scaling,this.x=e.x||this.x,this.y=e.y||this.y,this._element=e.element;let t=l.get(this._path||this._element);t&&t.references++,t||((t={references:1,resource:new o.ImageAtlasResource(this)}).resource.sampleScale=t.resource.sampleScale||1,o.ImageRasterizer.renderSync(t.resource),l.set(this._path||this._element,t)),this._rasterization=t,this._sourceWidth=t.resource.rasterization.world.width,this._sourceHeight=t.resource.rasterization.world.height,this.width=e.width||this._sourceWidth||1,this.height=e.height||this._sourceHeight||1,e.anchor&&this.setAnchor(e.anchor)}static destroy(){l.clear()}get size(){return c(this.width,this.height)}set size(e){const t=this.width/this.height;this.width=e*t,this.height=e}get element(){return this._element}get isDestroyed(){return this._isDestroyed}get path(){return this._path}get resource(){return this._rasterization.resource}get sourceWidth(){return this._sourceWidth}get sourceHeight(){return this._sourceHeight}get anchor(){return this._anchor}destroy(){this._isDestroyed||(this._isDestroyed=!0,this._rasterization.references--,0===this._rasterization.references&&(this._rasterization.resource,console.warn("The destroy method still needs completion")))}resourceTrigger(){this._rasterization=this._rasterization}setAnchor(e){const t={padding:e.padding||0,type:e.type,x:e.x||0,y:e.y||0};h[t.type](t,this),this._anchor=t}}i([s.observable],d.prototype,"tint",void 0),i([s.observable],d.prototype,"depth",void 0),i([s.observable],d.prototype,"height",void 0),i([s.observable],d.prototype,"scaling",void 0),i([s.observable],d.prototype,"width",void 0),i([s.observable],d.prototype,"x",void 0),i([s.observable],d.prototype,"y",void 0),i([s.observable],d.prototype,"_rasterization",void 0),i([s.observable],d.prototype,"_anchor",void 0),t.ImageInstance=d},function(e,t){e.exports="precision highp float;\n\nvarying vec4 vertexColor;\nvarying vec2 texCoord;\n\nvoid main() {\n  ${attributes}\n\n  // Figure out the size of the image as it'd show on the screen\n  vec3 screenSize = cameraSpaceSize(vec3(size, 1.0));\n  // Do the test for when the image is larger on the screen than the font size\n  bool largerOnScreen = screenSize.y > size.y;\n\n  // Determines if a scale mode should be used or not for the vertex\n  float useScaleMode = float(\n    (\n      scaling == 3.0 ||                  // NEVER mode - keep the image the same size always\n      (largerOnScreen && scaling == 2.0) // BOUND_MAX mode - only if we're larger than the font size do we scale down\n    ) &&\n    scaling != 1.0                       // ALWAYS mode - the image stays completely in world space allowing it to scale freely\n  );\n  // If zooms are unequal, assume one is filtered to be 1.0\n  float unequalZooms = float(cameraScale.x != cameraScale.y);\n\n  // Destructure threejs's bug with the position requirement\n  float normal = position.x;\n  float side = position.y;\n\n  // Get the location of the anchor in world space\n  vec2 worldAnchor = location + anchor;\n\n  // Get the tex coord from our inject texture info\n  texCoord = texture.xy + ((texture.zw - texture.xy) * vec2(side, float(normal == -1.0)));\n  // Apply the image's tint as a tint to the image\n  vertexColor = tint;\n\n  // Correct aspect ratio.\n  vec2 adjustedSize = mix(\n    size,\n    (size * cameraScale.yx),\n    unequalZooms\n  );\n\n  vec2 adjustedAnchor = mix(\n    anchor,\n    (anchor * cameraScale.yx),\n    unequalZooms\n  );\n\n  vec2 vertex = vec2(side, float(normal == 1.0)) * adjustedSize + location - adjustedAnchor;\n\n  // See how scaled the size on screen will be from the actual height of the image\n  float imageScreenScale = mix(\n    screenSize.y / adjustedSize.y,\n    screenSize.x / adjustedSize.x,\n    float((cameraScale.x < 1.0) || (cameraScale.x > 1.0))\n  );\n\n  // If our screen rendering is larger than the size the image is supposed to be, then we automagically\n  // scale down our image to stay the correct size, centered on the anchor point\n  vec2 anchorToVertex = vertex - location;\n\n  // We now choose between keeping the same image size or keeping it in world space\n  vertex = mix(\n    // This option keeps the image size in world space\n    vertex,\n    // This option counters the scaling of the image on the screen keeping it a static size\n    (anchorToVertex / imageScreenScale) + location,\n    // This is the flag determining if a scale mode should be applied to the vertex\n    useScaleMode\n  );\n\n  gl_Position = clipSpace(vec3(vertex, depth));\n}\n"},function(e,t){e.exports="precision highp float;\n\n${picking}\nvarying vec4 vertexColor;\nvarying vec2 texCoord;\n\nvoid main() {\n  gl_FragColor = texture2D(imageAtlas, texCoord) * vertexColor;\n  setColor(gl_FragColor * gl_FragColor.a);\n}\n"},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1),s=n(9),r=n(7),o=n(0),a=n(2),c=n(5),{min:l,max:h}=Math;t.ImageLayer=class extends r.Layer{getInstancePickingMethods(){return{boundsAccessor:e=>{const t=[0,0];e.anchor&&(t[0]=e.anchor.x||0,t[1]=e.anchor.y||0);const n=[e.x-t[0],e.y-t[1]];return new s.Bounds({height:e.height,width:e.width,x:n[0],y:n[1]})},hitTest:(e,t,n)=>{const i=h(...n.camera.scale),r=l(...n.camera.scale);if(e.scaling===c.ScaleType.ALWAYS)return!0;if(e.scaling===c.ScaleType.BOUND_MAX){if(r<=1&&i<=1)return!0;{const i=[0,0];e.anchor&&(i[0]=e.anchor.x||0,i[1]=e.anchor.y||0);const r=n.worldToScreen({x:e.x-i[0]/n.camera.scale[0],y:e.y-i[1]/n.camera.scale[1]}),o=n.worldToScreen(t);return new s.Bounds({height:e.height,width:e.width,x:r.x,y:r.y}).containsPoint(o)}}if(e.scaling===c.ScaleType.NEVER){const i=[0,0];e.anchor&&(i[0]=e.anchor.x||0,i[1]=e.anchor.y||0);const r=n.worldToScreen({x:e.x-i[0]/n.camera.scale[0],y:e.y-i[1]/n.camera.scale[1]}),o=n.worldToScreen(t);return new s.Bounds({height:e.height,width:e.width,x:r.x,y:r.y}).containsPoint(o)}return!0}}}initShader(){const e={0:1,1:1,2:-1,3:1,4:-1,5:-1},t={0:0,1:0,2:0,3:1,4:1,5:1};return{fs:n(87),instanceAttributes:[{block:0,blockIndex:o.InstanceBlockIndex.ONE,name:"location",size:o.InstanceAttributeSize.TWO,update:e=>[e.x,e.y]},{block:0,blockIndex:o.InstanceBlockIndex.THREE,name:"anchor",size:o.InstanceAttributeSize.TWO,update:e=>[e.anchor.x||0,e.anchor.y||0]},{block:1,blockIndex:o.InstanceBlockIndex.ONE,name:"size",size:o.InstanceAttributeSize.TWO,update:e=>[e.width,e.height]},{block:1,blockIndex:o.InstanceBlockIndex.THREE,name:"depth",size:o.InstanceAttributeSize.ONE,update:e=>[e.depth]},{block:1,blockIndex:o.InstanceBlockIndex.FOUR,name:"scaling",size:o.InstanceAttributeSize.ONE,update:e=>[e.scaling]},{atlas:{key:this.props.atlas||"",name:"imageAtlas"},block:2,name:"texture",update:e=>this.resource.request(this,e,e.resource)},{block:3,blockIndex:o.InstanceBlockIndex.ONE,name:"tint",size:o.InstanceAttributeSize.FOUR,update:e=>e.tint}],uniforms:[{name:"scaleFactor",size:o.UniformSize.ONE,update:e=>[1]}],vertexAttributes:[{name:"position",size:o.VertexAttributeSize.THREE,update:n=>[e[n],t[n],0]}],vertexCount:6,vs:n(86)}}getModelType(){return{drawMode:i.TriangleStripDrawMode,modelType:i.Mesh}}getMaterialOptions(){return a.CommonMaterialOptions.transparentImage}}},function(e,t,n){"use strict";var i=this&&this.__decorate||function(e,t,n,i){var s,r=arguments.length,o=r<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,n):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,i);else for(var a=e.length-1;a>=0;a--)(s=e[a])&&(o=(r<3?s(o):r>3?s(t,n,o):s(t,n))||o);return r>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const s=n(3);class r extends s.Instance{constructor(e){super(e),this.colorStart=[1,1,1,1],this.colorEnd=[1,1,1,1],this.control=[[0,0],[0,0]],this.depth=0,this.end=[0,0],this.start=[0,0],this.widthStart=1,this.widthEnd=1,this.colorStart=e.colorStart||this.colorStart,this.colorEnd=e.colorEnd||this.colorEnd,this.control=e.control||this.control,this.depth=e.depth||this.depth,this.end=e.end||this.end,this.widthStart=e.widthStart||this.widthStart,this.widthEnd=e.widthEnd||this.widthEnd,this.start=e.start||this.start}get length(){const e=[this.end[0]-this.start[0],this.end[1]-this.start[1]];return Math.sqrt(e[0]*e[0]+e[1]*e[1])}get midpoint(){return 0}get perpendicular(){const e=this.length;return[(this.end[1]-this.start[1])/e,-(this.end[0]-this.start[0])/e]}setEdgeWidth(e){e&&(this.widthEnd=e,this.widthStart=e)}setColor(e){this.colorStart=e,this.colorEnd=e}}i([s.observable],r.prototype,"colorStart",void 0),i([s.observable],r.prototype,"colorEnd",void 0),i([s.observable],r.prototype,"control",void 0),i([s.observable],r.prototype,"depth",void 0),i([s.observable],r.prototype,"end",void 0),i([s.observable],r.prototype,"start",void 0),i([s.observable],r.prototype,"widthStart",void 0),i([s.observable],r.prototype,"widthEnd",void 0),t.EdgeInstance=r},function(e,t){e.exports="precision highp float;\n\n${picking}\nvarying vec4 vertexColor;\n\nvoid main() {\n  setColor(vertexColor);\n}\n"},function(e,t){e.exports="/**\n  This vertex shader calculates edges based in world space to make an edge based on\n  bezier curves with 0, 1, and 2 control points.\n**/\nprecision highp float;\n\nvarying vec4 vertexColor;\n\n// Interpolation type injection\n${interpolation}\n\nvoid main() {\n  ${attributes}\n\n  // Destructure threejs's bug with the position requirement\n  float normal = position.x;\n  float interpolationTime = position.y;\n  float interpolationIncrement = 1.0 / position.z;\n\n  // Convert our world points to screen space\n  vec4 startClip = clipSpace(vec3(start, depth));\n  vec4 endClip = clipSpace(vec3(end, depth));\n  vec2 startScreen = (startClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\n  vec2 endScreen = (endClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\n  // Controls for this mode are screen space deltas from the end points\n  vec2 control1 = startScreen + vec2(control.x, -control.y) * scaleFactor;\n  vec2 control2 = endScreen + vec2(control.z, -control.w) * scaleFactor;\n\n  // Get the position of the current vertex\n  vec2 currentPosition = interpolation(interpolationTime, startScreen, endScreen, control1, control2);\n  // Calculate the next and previous segment's location on the line\n  vec2 prePosition = interpolation(interpolationTime - interpolationIncrement, startScreen, endScreen, control1, control2);\n  vec2 nextPosition = interpolation(interpolationTime + interpolationIncrement, startScreen, endScreen, control1, control2);\n\n  vec2 preLine = prePosition - currentPosition;\n  vec2 nextLine = nextPosition - currentPosition;\n\n  // Get a spliced nromal at the joining of two segments to make a crisper curve\n  vec2 currentNormal = mix(\n    // Pick this value if we're at the beginning of the line\n    normalize(vec2(preLine.y, -preLine.x)),\n    mix(\n      // Pick this value when we're between the ends\n      normalize(vec2(preLine.y, -preLine.x) + vec2(-nextLine.y, nextLine.x)),\n      // Pick this value if we're at the end of the line\n      normalize(vec2(-nextLine.y, nextLine.x)),\n      float(position.x >= 1.0)\n    ),\n    float(position.x > 0.0)\n  );\n\n  // Get the thickness based on the side we're on\n  float lineThickness = mix(widthStart, widthEnd, interpolationTime) / 2.0;\n  // Start on the calculated line and push out by the normal's value\n  vec2 vertex = currentPosition + currentNormal * (-normal * lineThickness * scaleFactor);\n  // Get the color based on where we are on the line\n  vertexColor = mix(colorStart, colorEnd, interpolationTime);\n  vertexColor *= vertexColor.a;\n\n  gl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), startClip.zw);\n  gl_PointSize = 5.0;\n}\n"},function(e,t){e.exports="precision highp float;\n\n/**\n  This vertex shader calculates edges whose curve and width is in screen space where the curve is\n  bezier curves with 0, 1, and 2 control points.\n**/\nvarying vec4 vertexColor;\n\n// Interpolation type injection\n${interpolation}\n\nvoid main() {\n  ${attributes}\n\n  // Destructure threejs's bug with the position requirement\n  float normal = position.x;\n  float interpolationTime = position.y;\n  float interpolationIncrement = 1.0 / position.z;\n  // Get the position of the current vertex\n  vec2 currentPosition = interpolation(interpolationTime, start, end, control.xy, control.zw);\n  // Calculate the next and previous segment's location on the line\n  vec2 prePosition = interpolation(interpolationTime - interpolationIncrement, start, end, control.xy, control.zw);\n  vec2 nextPosition = interpolation(interpolationTime + interpolationIncrement, start, end, control.xy, control.zw);\n\n  vec2 preLine = prePosition - currentPosition;\n  vec2 nextLine = nextPosition - currentPosition;\n\n  // Get a spliced nromal at the joining of two segments to make a crisper curve\n  vec2 currentNormal = mix(\n    // Pick this value if we're at the beginning of the line\n    normalize(vec2(preLine.y, -preLine.x)),\n    mix(\n      // Pick this value when we're between the ends\n      normalize(vec2(preLine.y, -preLine.x) + vec2(-nextLine.y, nextLine.x)),\n      // Pick this value if we're at the end of the line\n      normalize(vec2(-nextLine.y, nextLine.x)),\n      float(position.x >= 1.0)\n    ),\n    float(position.x > 0.0)\n  );\n\n  // Get the thickness based on the side we're on\n  float lineThickness = mix(widthStart, widthEnd, interpolationTime) / 2.0;\n  // Start on the calculated line and push out by the normal's value\n  vec2 vertex = currentPosition + currentNormal * (normal * lineThickness);\n  // Get the color based on where we are on the line\n  vertexColor = mix(colorStart, colorEnd, interpolationTime);\n  vertexColor *= vertexColor.a;\n\n  gl_Position = clipSpace(vec3(vertex, depth));\n  gl_PointSize = 5.0;\n}\n"},function(e,t){e.exports="/**\n * Makes a linear interpolation between two points\n *\n * @param {vec2} s The start point\n * @param {vec2} e The end point\n * @param {vec2} c The bezier control point\n * @param {float} t The interpolation value [0, 1]\n *\n * @returns {vec2} A point interpolated between the two provided points\n */\nvec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {\n  float t1 = 1.0 - t;\n  return pow(t1, 3.0) * p1 + 3.0 * t * pow(t1, 2.0) * c1 + 3.0 * pow(t, 2.0) * t1 * c2 + pow(t, 3.0) * p2;\n}\n"},function(e,t){e.exports="/**\n * Makes a linear interpolation between two points\n *\n * @param {vec2} s The start point\n * @param {vec2} e The end point\n * @param {vec2} c The bezier control point\n * @param {float} t The interpolation value [0, 1]\n *\n * @returns {vec2} A point interpolated between the two provided points\n */\nvec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {\n  return (1.0 - t) * (1.0 - t) * p1 + 2.0 * t * (1.0 - t) * c1 + t * t * p2;\n}\n"},function(e,t){e.exports="/**\n * Makes a linear interpolation between two points\n *\n * @param {vec2} s The start point\n * @param {vec2} e The end point\n * @param {vec2} c The bezier control point\n * @param {float} t The interpolation value [0, 1]\n *\n * @returns {vec2} A point interpolated between the two provided points\n */\nvec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {\n  return p1 + (p2 - p1) * t;\n}\n"},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(4),s=n(23),r=n(18),{pow:o}=Math;const a={[r.EdgeType.LINE]:function(e,t,n,i,r){return s.add2(s.scale2(s.subtract2(n,t),e),t)},[r.EdgeType.BEZIER]:function(e,t,n,i,s){return[(1-e)*(1-e)*t[0]+2*e*(1-e)*i[0]+e*e*n[0],(1-e)*(1-e)*t[1]+2*e*(1-e)*i[1]+e*e*n[1]]},[r.EdgeType.BEZIER2]:function(e,t,n,i,s){const r=1-e;return[o(r,3)*t[0]+3*e*o(r,2)*i[0]+3*o(e,2)*r*s[0]+o(e,3)*n[0],o(r,3)*t[1]+3*e*o(r,2)*i[1]+3*o(e,2)*r*s[1]+o(e,3)*n[1]]}};function c(e){return{x:e[0],y:e[1]}}function l(e){return[e.x,e.y]}const h=50;t.edgePicking=function(e){const{broadphase:t,minPickDistance:n=0,scaleType:o,type:d}=e,u=a[e.type],p=s=>{const o=s.widthStart/2+n,a=s.widthEnd/2+n,c=new i.Bounds({height:s.widthStart,width:s.widthStart,x:s.start[0]-o,y:s.start[1]-o});return c.encapsulate(new i.Bounds({height:s.widthEnd,width:s.widthEnd,x:s.end[0]-a,y:s.end[1]-a})),e.type===r.EdgeType.BEZIER?c.encapsulate({x:s.control[0][0],y:s.control[0][1]}):e.type===r.EdgeType.BEZIER2&&(c.encapsulate({x:s.control[0][0],y:s.control[0][1]}),c.encapsulate({x:s.control[1][0],y:s.control[1][1]})),t===r.EdgeBroadphase.PASS_X&&(c.x=Number.MIN_SAFE_INTEGER/2,c.width=Number.MAX_SAFE_INTEGER),t===r.EdgeBroadphase.PASS_Y&&(c.y=Number.MIN_SAFE_INTEGER/2,c.height=Number.MAX_SAFE_INTEGER),c};return o===r.EdgeScaleType.SCREEN_CURVE?{boundsAccessor:p,hitTest:(e,t,i)=>{const o=[(t=i.worldToScreen(t)).x,t.y];let a=0,p=Number.MAX_VALUE,f=0,g=Number.MAX_VALUE;const m=i.worldToScreen(c(e.start)),y=i.worldToScreen(c(e.end));let b=[0,0],v=[0,0];d===r.EdgeType.BEZIER?b=s.add2(l(m),e.control[0]):d===r.EdgeType.BEZIER2&&(b=s.add2(l(m),e.control[0]),v=s.add2(l(y),e.control[1]));const w=l(m),x=l(y);b=e.control.length>0?b:[0,0],v=e.control.length>1?v:[0,0];for(let e=0;e<h;++e){const t=u(e/h,w,x,b,v),n=s.length2(s.subtract2(o,t));n<p?(f=a,g=p,a=e,p=n):n<g&&(f=e,p=n)}const T=a/h,I=(e.widthEnd-e.widthStart)*T+e.widthStart;if(a===f)return!1;const E=u(a/h,w,x,b,v),M=u(f/h,w,x,b,v);return p=function(e,t,n){const i=s.subtract2(e,n),r=s.subtract2(t,e),o=[r[1],-r[0]];return Math.abs(s.dot2(i,o))/s.length2(r)}(E,M,o),!(s.dot2(s.subtract2(M,E),s.subtract2(o,E))<0)&&p<I/2+n}}:{boundsAccessor:p,hitTest:(e,t,n)=>{const i=[t.x,t.y];let r=0,o=Number.MAX_VALUE;for(let t=0;t<h;++t){const n=u(t/h,e.start,e.end,e.control.length>0?e.control[0]:[0,0],e.control.length>1?e.control[1]:[0,0]),a=s.length2(s.subtract2(i,n));a<o&&(r=t,o=a)}const a=r/h;return o<((e.widthEnd-e.widthStart)*a+e.widthStart)/2}}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1),s=n(3),r=n(7),o=n(0),a=n(2),c=n(96),l=n(18);const h={[l.EdgeType.LINE]:n(95),[l.EdgeType.BEZIER]:n(94),[l.EdgeType.BEZIER2]:n(93)},d=n(92),u=n(91),p=n(90);class f extends r.Layer{getInstancePickingMethods(){return c.edgePicking(this.props)}initShader(){const{animate:e={},scaleFactor:t=(()=>1),type:n,scaleType:i=l.EdgeScaleType.NONE}=this.props,{end:s,start:r,colorStart:c,colorEnd:f,control:g}=e,m=n===l.EdgeType.LINE?2:50,y={0:1,[2*m+2]:-1},b={0:0,[2*m+2]:1};let v=1;for(let e=0;e<2*m;++e)y[e+1]=v,b[e+1]=Math.floor(e/2)/(m-1),v*=-1;const w=a.shaderTemplate(i===l.EdgeScaleType.NONE?d:u,{attributes:"${attributes}",interpolation:h[n]},{name:"Edge Layer",values:["interpolation"]});return{fs:p,instanceAttributes:[{block:0,blockIndex:o.InstanceBlockIndex.ONE,easing:r,name:"start",size:o.InstanceAttributeSize.TWO,update:e=>e.start},{block:0,blockIndex:o.InstanceBlockIndex.THREE,easing:s,name:"end",size:o.InstanceAttributeSize.TWO,update:e=>e.end},{block:1,blockIndex:o.InstanceBlockIndex.ONE,name:"widthStart",size:o.InstanceAttributeSize.ONE,update:e=>[e.widthStart]},{block:1,blockIndex:o.InstanceBlockIndex.TWO,name:"widthEnd",size:o.InstanceAttributeSize.ONE,update:e=>[e.widthEnd]},{block:1,blockIndex:o.InstanceBlockIndex.THREE,name:"depth",size:o.InstanceAttributeSize.ONE,update:e=>[e.depth]},{block:2,blockIndex:o.InstanceBlockIndex.ONE,easing:c,name:"colorStart",size:o.InstanceAttributeSize.FOUR,update:e=>e.colorStart},{block:3,blockIndex:o.InstanceBlockIndex.ONE,easing:f,name:"colorEnd",size:o.InstanceAttributeSize.FOUR,update:e=>e.colorEnd},n===l.EdgeType.LINE?{block:4,blockIndex:o.InstanceBlockIndex.ONE,easing:g,name:"control",size:o.InstanceAttributeSize.FOUR,update:e=>[0,0,0,0]}:null,n===l.EdgeType.BEZIER?{block:4,blockIndex:o.InstanceBlockIndex.ONE,easing:g,name:"control",size:o.InstanceAttributeSize.FOUR,update:e=>[e.control[0][0],e.control[0][1],0,0]}:null,n===l.EdgeType.BEZIER2?{block:4,blockIndex:o.InstanceBlockIndex.ONE,easing:g,name:"control",size:o.InstanceAttributeSize.FOUR,update:e=>(function(e){return[e[0][0],e[0][1],e[1][0],e[1][1]]})(e.control)}:null],uniforms:[{name:"scaleFactor",size:o.UniformSize.ONE,update:e=>[t()]}],vertexAttributes:[{name:"position",size:o.VertexAttributeSize.THREE,update:e=>[y[e],b[e],2*m]}],vertexCount:2*m+2,vs:w.shader}}getModelType(){return{drawMode:i.TriangleStripDrawMode,modelType:i.Mesh}}getMaterialOptions(){return a.CommonMaterialOptions.transparentShape}}f.defaultProps={broadphase:l.EdgeBroadphase.ALL,data:new s.InstanceProvider,key:"none",scaleType:l.EdgeScaleType.NONE,type:l.EdgeType.LINE},t.EdgeLayer=f},function(e,t,n){"use strict";function i(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),i(n(97)),i(n(89)),i(n(18))},function(e,t,n){"use strict";var i=this&&this.__decorate||function(e,t,n,i){var s,r=arguments.length,o=r<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,n):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,i);else for(var a=e.length-1;a>=0;a--)(s=e[a])&&(o=(r<3?s(o):r>3?s(t,n,o):s(t,n))||o);return r>3&&o&&Object.defineProperty(t,n,o),o};Object.defineProperty(t,"__esModule",{value:!0});const s=n(3);class r extends s.Instance{constructor(e){super(e),this.color=[1,1,1,1],this.depth=0,this.radius=0,this.x=0,this.y=0,this.color=e.color||this.color,this.radius=e.radius||this.radius,this.x=e.x||this.x,this.y=e.y||this.y,this.depth=e.depth||this.depth}get width(){return 2*this.radius}get height(){return 2*this.radius}}i([s.observable],r.prototype,"color",void 0),i([s.observable],r.prototype,"depth",void 0),i([s.observable],r.prototype,"radius",void 0),i([s.observable],r.prototype,"x",void 0),i([s.observable],r.prototype,"y",void 0),t.CircleInstance=r},function(e,t){e.exports="precision highp float;\n\nvarying vec4 vertexColor;\nvarying float edgeSharpness;\nvarying float edgeSharpnessBase;\nvarying vec2 pointCoord;\n\nvoid main() {\n  ${attributes}\n\n  vertexColor = color * color.a;\n  float size = radius * scaleFactor;\n  edgeSharpness = mix(0.8, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));\n  edgeSharpnessBase = mix(0.1, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));\n  pointCoord = (position.xy + vec2(1.0, 1.0)) / 2.0;\n\n  // Center within clip space\n  vec4 clipCenter = clipSpace(vec3(center, depth));\n  // Center in screen space\n  vec2 screenCenter = (clipCenter.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\n  // Position in screen space\n  vec2 vertex = (position.xy * size) + screenCenter;\n  // Position back to clip space\n  gl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), clipCenter.zw);\n}\n"},function(e,t){e.exports="precision highp float;\n\n${picking}\n\nvarying vec4 vertexColor;\nvarying float edgeSharpness;\nvarying float edgeSharpnessBase;\nvarying vec2 pointCoord;\n\nfloat circle(vec2 coord, float radius){\n  vec2 dist = coord - vec2(0.5);\n\n  return 1.0 - smoothstep(\n    radius - (radius * edgeSharpness),\n    radius + (radius * edgeSharpnessBase),\n    dot(dist, dist) * 4.0\n  );\n}\n\nvoid main() {\n  float step_factor = circle(pointCoord.xy, 1.0);\n\n  setColor(mix(\n    vec4(0.0, 0.0, 0.0, 0.0),\n    vertexColor,\n    step_factor\n  ));\n}\n"},function(e,t){e.exports="void main() {\n  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n}"},function(e,t){e.exports=""},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(0);t.LayerInteractionHandler=class{constructor(e){this.isMouseOver=new Map,this.isMouseDown=new Map,this.layer=e}getColorPickInstance(){return this.colorPicking&&function(e){return e&&e.colorPicking}(this.layer.diffManager.processor)?this.layer.diffManager.processor.colorPicking.uidToInstance.get(16777215-this.colorPicking.nearestColor):null}handleMouseOver(e,t){}handleMouseDown(e,t,n){if(this.layer.picking&&this.layer.picking.type!==i.PickType.NONE){const{onMouseDown:s}=this.layer.props;if(s){const r=e.viewToWorld(t);let o,a,c,l=[];if(this.layer.picking.type===i.PickType.ALL)o=this.layer.picking.hitTest,a=this.layer.picking.quadTree.query.bind(this.layer.picking.quadTree),c=(t=>a(t).filter(t=>o(t,r,e))),l=a(r).filter(t=>o(t,r,e));else if(this.layer.picking.type===i.PickType.SINGLE){const e=this.getColorPickInstance();e&&l.push(e)}s({button:n,instances:l,layer:this.layer.id,projection:e,querySpace:c,screen:[t.x,t.y],world:[r.x,r.y]}),this.isMouseDown.clear(),l.forEach(e=>this.isMouseDown.set(e,!0))}}}handleMouseOut(e,t){if(this.layer.picking&&this.layer.picking.type!==i.PickType.NONE){const{onMouseOut:n}=this.layer.props;if(n){const s=e.viewToWorld(t);let r,o,a;this.layer.picking.type===i.PickType.ALL&&(r=this.layer.picking.hitTest,o=this.layer.picking.quadTree.query.bind(this.layer.picking.quadTree),a=(t=>o(t).filter(t=>r(t,s,e)))),n({instances:Array.from(this.isMouseOver.keys()),layer:this.layer.id,projection:e,querySpace:a,screen:[t.x,t.y],world:[s.x,s.y]})}}this.isMouseOver.clear(),this.isMouseDown.clear()}handleMouseUp(e,t,n){if(this.layer.picking&&this.layer.picking.type!==i.PickType.NONE){const{onMouseUp:s}=this.layer.props;if(s){const r=e.viewToWorld(t);let o,a,c,l=[];if(this.layer.picking.type===i.PickType.ALL)o=this.layer.picking.hitTest,a=this.layer.picking.quadTree.query.bind(this.layer.picking.quadTree),c=(t=>a(t).filter(t=>o(t,r,e))),l=a(r).filter(t=>o(t,r,e));else if(this.layer.picking.type===i.PickType.SINGLE){const e=this.getColorPickInstance();e&&l.push(e)}s({button:n,instances:l,layer:this.layer.id,projection:e,querySpace:c,screen:[t.x,t.y],world:[r.x,r.y]})}}}handleMouseMove(e,t){const{onMouseOver:n,onMouseMove:s,onMouseOut:r}=this.layer.props;if(this.layer.picking&&this.layer.picking.type!==i.PickType.NONE&&(n||s||r)){let o;const a=e.viewToWorld(t);let c,l,h,d=[];if(this.layer.picking.type===i.PickType.ALL)c=this.layer.picking.hitTest,l=this.layer.picking.quadTree.query.bind(this.layer.picking.quadTree),h=(t=>l(t).filter(t=>c(t,a,e))),d=l(a).filter(t=>c(t,a,e));else if(this.layer.picking.type===i.PickType.SINGLE){const e=this.getColorPickInstance();e&&d.push(e)}if(n){const i=d.filter(e=>!this.isMouseOver.get(e));o={instances:i,layer:this.layer.id,projection:e,querySpace:h,screen:[t.x,t.y],world:[a.x,a.y]},i.length>0&&n(o)}s&&s(o={instances:d,layer:this.layer.id,projection:e,querySpace:h,screen:[t.x,t.y],world:[a.x,a.y]});const u=new Map;if(d.forEach(e=>u.set(e,!0)),r){const n=Array.from(this.isMouseOver.keys()).filter(e=>!u.get(e));o={instances:n,layer:this.layer.id,projection:e,querySpace:h,screen:[t.x,t.y],world:[a.x,a.y]},n.length>0&&r(o)}this.isMouseOver=u}}handleMouseClick(e,t,n){if(this.layer.picking&&this.layer.picking.type!==i.PickType.NONE){const{onMouseClick:s}=this.layer.props;if(s){const r=e.viewToWorld(t);let o,a,c,l=[];if(this.layer.picking.type===i.PickType.ALL)o=this.layer.picking.hitTest,a=this.layer.picking.quadTree.query.bind(this.layer.picking.quadTree),c=(t=>a(t).filter(t=>o(t,r,e))),l=a(r).filter(t=>o(t,r,e));else if(this.layer.picking.type===i.PickType.SINGLE){const e=this.getColorPickInstance();e&&l.push(e)}s({button:n,instances:l,layer:this.layer.id,projection:e,querySpace:c,screen:[t.x,t.y],world:[r.x,r.y]})}}}handleMouseDrag(e,t){}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(0),s=n(6),r=n(19),o=[];t.UniformQuadDiffProcessor=class extends r.UniformDiffProcessor{constructor(e,t){super(e,t),e.picking.type===i.PickType.ALL?this.quadPicking=e.picking:console.warn("Diff Processing Error: A layer has a diff processor requesting Quad Processing but the picking type is not valid.")}addInstance(e,t,n,i){if(i)e.changeInstance(e,t,o,i);else{const n=e.layer.bufferManager.add(t);s.isBufferLocation(n)&&(t.active=!0,e.updateInstance(e.layer,t,n),e.quadPicking.quadTree.remove(t),e.quadPicking.quadTree.add(t))}}changeInstance(e,t,n,i){i?(e.updateInstance(e.layer,t,i),e.quadPicking.quadTree.remove(t),e.quadPicking.quadTree.add(t)):e.addInstance(e,t,o,i)}removeInstance(e,t,n,i){i&&(t.active=!1,e.updateInstance(e.layer,t,i),e.layer.bufferManager.remove(t),e.quadPicking.quadTree.remove(t))}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(0),s=n(6),r=n(19),o=[];t.UniformColorDiffProcessor=class extends r.UniformDiffProcessor{constructor(e,t){super(e,t),e.picking.type===i.PickType.SINGLE?(this.colorPicking=e.picking,this.colorPicking.uidToInstance=new Map):console.warn("Diff Processing Error: A layer has a diff processor requesting Color Processing but the picking type is not valid.")}addInstance(e,t,n,i){if(i)e.changeInstance(e,t,o,i);else{const n=e.layer.bufferManager.add(t);s.isBufferLocation(n)?(t.active=!0,e.updateInstance(e.layer,t,n),e.colorPicking.uidToInstance.set(t.uid,t)):console.warn("A data cluster was not provided by the manager to associate an instance with.")}}changeInstance(e,t,n,i){i?e.updateInstance(e.layer,t,i):e.addInstance(e,t,o,i)}removeInstance(e,t,n,i){i&&(t.active=!1,e.updateInstance(e.layer,t,i),e.layer.bufferManager.remove(t),e.colorPicking.uidToInstance.delete(t.uid))}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(6),s=n(41),r=[],{min:o,max:a}=Math;var c;!function(e){e[e.PARTIAL=0]="PARTIAL",e[e.FULL=1]="FULL"}(c||(c={}));t.InstanceAttributeDiffProcessor=class extends s.BaseDiffProcessor{constructor(){super(...arguments),this.diffMode=c.PARTIAL,this.bufferAttributeUpdateRange={},this.bufferAttributeWillUpdate={},this.updateInstance=this.updateInstancePartial}addInstance(e,t,n,s){if(s)e.changeInstance(e,t,r,s);else{const n=e.layer.bufferManager.add(t);i.isBufferLocationGroup(n)&&(t.active=!0,e.updateInstance(e.layer,t,r,n))}}changeInstance(e,t,n,i){i?e.updateInstance(e.layer,t,n,i):e.addInstance(e,t,r,i)}removeInstance(e,t,n,i){i&&(t.active=!1,e.updateInstance(e.layer,t,r,i),e.layer.bufferManager.remove(t))}updateInstancePartial(e,t,n,i){const s=i.propertyToBufferLocation,r=this.bufferAttributeUpdateRange;let c,l,h,d,u;if(t.active){0===n.length&&(n=this.bufferManager.getUpdateAllPropertyIdList());for(let i=0,p=n.length;i<p;++i)if((u=(c=s[n[i]]).attribute).atlas&&e.resource.setTargetAtlas(u.atlas.key),l=u.update(t),c.buffer.value.set(l,c.range[0]),(h=r[u.uid]||[null,Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER])[0]=u,h[1]=o(c.range[0],h[1]),h[2]=a(c.range[1],h[2]),r[u.uid]=h,c.childLocations)for(let e=0,n=(d=c.childLocations).length;e<n;++e)l=(c=d[e]).attribute.update(t),c.buffer.value.set(l,c.range[0]),(h=r[c.attribute.uid]||[null,Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER])[0]=c.attribute,h[1]=o(c.range[0],h[1]),h[2]=a(c.range[1],h[2]),r[c.attribute.uid]=h}else l=(u=(c=s[this.bufferManager.getActiveAttributePropertyId()]).attribute).update(t),c.buffer.value.set(l,c.range[0]),(h=r[u.uid]||[null,Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER])[0]=u,h[1]=o(c.range[0],h[1]),h[2]=a(c.range[1],h[2]),r[u.uid]=h}updateInstanceFull(e,t,n,i){const s=i.propertyToBufferLocation,r=this.bufferAttributeWillUpdate;let o,a,c,l;if(t.active){0===n.length&&(n=this.bufferManager.getUpdateAllPropertyIdList());for(let i=0,h=n.length;i<h;++i)if((l=(o=s[n[i]]).attribute).atlas&&e.resource.setTargetAtlas(l.atlas.key),a=l.update(t),o.buffer.value.set(a,o.range[0]),r[l.uid]=l,o.childLocations)for(let e=0,n=(c=o.childLocations).length;e<n;++e)a=(l=(o=c[e]).attribute).update(t),o.buffer.value.set(a,o.range[0]),r[l.uid]=l}else(l=(o=s[this.bufferManager.getActiveAttributePropertyId()]).attribute).atlas&&e.resource.setTargetAtlas(l.atlas.key),a=l.update(t),o.buffer.value.set(a,o.range[0]),r[l.uid]=l}commit(){if(this.diffMode===c.PARTIAL){const e=Object.values(this.bufferAttributeUpdateRange);for(let t=0,n=e.length;t<n;++t){const n=e[t],i=n[0].bufferAttribute;i.needsUpdate=!0,i.updateRange={count:n[2]-n[1],offset:n[1]}}}else{const e=Object.values(this.bufferAttributeWillUpdate);for(let t=0,n=e.length;t<n;++t){const n=e[t].bufferAttribute;n.needsUpdate=!0,n.updateRange={count:-1,offset:0}}}this.bufferAttributeUpdateRange={}}incomingChangeList(e){0===e.length?this.diffMode=c.PARTIAL:e.length>.7*this.bufferManager.getInstanceCount()?this.diffMode=c.FULL:this.diffMode=c.PARTIAL,this.diffMode===c.PARTIAL?this.updateInstance=this.updateInstancePartial:this.updateInstance=this.updateInstanceFull}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1),s=n(42),r=n(0),o=n(2),a=n(11),c=n(6);t.UniformBufferManager=class extends c.BufferManagerBase{constructor(e,t){super(e,t),this.buffers=[],this.availableClusters=[],this.instanceToCluster={},this.clusterToBuffer=new Map,this.add=function(e){this.availableClusters.length<=0&&this.makeNewBuffer();const t=this.availableClusters.pop();return t?this.instanceToCluster[e.uid]=t:console.warn("No valid cluster available for instance added to uniform manager."),t},this.remove=function(e){const t=this.instanceToCluster[e.uid];return t&&(delete this.instanceToCluster[e.uid],this.availableClusters.push(t)),e};let n=0;e.instanceAttributes.forEach(e=>{n=Math.max(e.block,n)}),this.uniformBlocksPerInstance=n+1}destroy(){this.buffers.forEach(e=>{e.geometry.dispose(),e.material.dispose()})}getBufferLocations(e){return this.instanceToCluster[e.uid]}getActiveAttributePropertyId(){return-1}getInstanceCount(){return-1}getUpdateAllPropertyIdList(){return[]}removeFromScene(){this.buffers.forEach((e,t)=>{this.scene.container.remove(e.model),e.pickModel&&this.scene.pickingContainer.remove(e.pickModel)}),delete this.scene}setScene(e){this.buffers.forEach((e,t)=>{this.scene.container.add(e.model),e.pickModel&&this.scene.pickingContainer.add(e.pickModel)}),this.scene=e}makeNewBuffer(){const e=new i.BufferGeometry;this.layer.vertexAttributes.forEach(t=>{t.materialAttribute&&e.addAttribute(t.name,t.materialAttribute)}),e.drawRange.start=0,e.drawRange.count=this.layer.maxInstancesPerBuffer*this.layer.instanceVertexCount;const t=this.layer.material.clone(),n=a.generateLayerModel(this.layer,e,t);n.frustumCulled=!1;const c={activeInstances:[],clusters:[],firstInstance:0,geometry:e,lastInstance:0,material:t,model:n,pickModel:this.layer.picking.type===r.PickType.SINGLE?n.clone():void 0};this.buffers.push(c);let l=0;const h=s.makeInstanceUniformNameArray(),d=t.uniforms[h];d.value=d.value.map(()=>new i.Vector4(0,0,0,0));const u=Object.assign({},this.layer.instanceAttributes[0],{bufferAttribute:new i.InstancedBufferAttribute(new Float32Array(1),1),uid:o.uid()});for(let e=0,t=this.layer.maxInstancesPerBuffer;e<t;++e){const t={attribute:u,buffer:d,instanceIndex:e,range:[l,0]};l+=this.uniformBlocksPerInstance,t.range[1]=l,c.clusters.push(t),this.availableClusters.push(t),this.clusterToBuffer.set(t,c)}for(let e=0,n=this.layer.uniforms.length;e<n;++e){const n=this.layer.uniforms[e];n.materialUniforms.push(t.uniforms[n.name])}this.scene&&(this.scene.container.add(c.model),c.pickModel&&this.scene.pickingContainer.add(c.pickModel))}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});let i={};t.emitOnce=function(e,t){const n=i[e]||[t,-1,0];i[e]=n,n[2]++,clearTimeout(n[1]),n[1]=window.setTimeout(()=>{t(n[2],e),delete i[e]},1)},t.flushEmitOnce=function(){for(const e in i){const t=i[e];clearTimeout(t[1]),t[0](t[2],e)}i={}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1),s=n(3),r=n(43),o=n(0),a=n(2),c=n(109),l=n(11),h=n(6),{max:d}=Math;t.InstanceAttributeBufferManager=class extends h.BufferManagerBase{constructor(e,t){super(e,t),this.allBufferLocations={},this.availableLocations=[],this.currentInstancedCount=0,this.instanceToBufferLocation={},this.growthCount=0,this.maxInstancedCount=1e3,this.attributeToPropertyIds=new Map,this.updateAllPropertyIdList=[],this.activePropertyId=-1,this.remove=(e=>{const t=this.instanceToBufferLocation[e.uid];return t&&(delete this.instanceToBufferLocation[e.uid],this.availableLocations.push(t)),e}),this.add=this.doAddWithRegistration}doAddWithRegistration(e){this.layer.instanceAttributes.forEach(t=>{if(t.parentAttribute)return;s.ObservableMonitoring.setObservableMonitor(!0),t.update(e);const n=s.ObservableMonitoring.getObservableMonitorIds(!0);this.attributeToPropertyIds.set(t,n),t===this.layer.activeAttribute&&(this.activePropertyId=n[0])}),s.ObservableMonitoring.setObservableMonitor(!1),this.makeUpdateAllPropertyIdList();const t=this.resizeBuffer();return this.gatherLocationsIntoGroups(t.newLocations,t.growth),this.add=this.doAdd,this.doAdd(e)}doAdd(e){if(this.availableLocations.length<=0){const e=this.resizeBuffer();this.gatherLocationsIntoGroups(e.newLocations,e.growth)}const t=this.availableLocations.shift();return t?(this.instanceToBufferLocation[e.uid]=t,this.currentInstancedCount=this.geometry.maxInstancedCount=d(this.currentInstancedCount,t.instanceIndex+1)):console.error("Add Error: Instance Attribute Buffer Manager failed to pair an instance with a buffer location"),t}destroy(){this.geometry.dispose(),this.material.dispose(),this.scene&&this.scene.container&&this.scene.container.remove(this.model)}getBufferLocations(e){return this.instanceToBufferLocation[e.uid]}getActiveAttributePropertyId(){return this.activePropertyId}getUpdateAllPropertyIdList(){return this.updateAllPropertyIdList}makeUpdateAllPropertyIdList(){const e={};this.attributeToPropertyIds.forEach(t=>{e[t[0]]=t[0]}),this.updateAllPropertyIdList=Object.values(e).filter(Boolean)}removeFromScene(){this.scene&&this.scene.container&&this.scene.container.remove(this.model),this.pickModel&&this.scene.pickingContainer.remove(this.pickModel),delete this.scene}resizeBuffer(){let e=0;const t=new Map;if(this.geometry){this.geometry.dispose(),this.geometry=new i.InstancedBufferGeometry;const n=this.maxInstancedCount;this.layer.vertexAttributes.forEach(e=>{e.materialAttribute&&this.geometry.addAttribute(e.name,e.materialAttribute)}),this.growthCount=Math.min(1,this.growthCount+1),e=1e3*Math.pow(10,this.growthCount),this.maxInstancedCount+=e,this.attributes.forEach(e=>{const s=e.bufferAttribute,o=e.size||0;if(s.array instanceof Float32Array){const a=new Float32Array(this.maxInstancedCount*o);a.set(s.array,0);const c=new i.InstancedBufferAttribute(a,o);c.setDynamic(!0),e.bufferAttribute=c,this.geometry.addAttribute(r.instanceAttributeShaderName(e),c);let l=t.get(e.name);const h=this.allBufferLocations[e.name]||[];this.allBufferLocations[e.name]=h;for(let e=0,t=h.length;e<t;++e)h[e].buffer.value=a;l||(l=[],t.set(e.name,l));for(let t=n,i=this.maxInstancedCount;t<i;++t){const n={attribute:e,buffer:{value:a},instanceIndex:t,range:[t*o,t*o+o]};l.push(n),h.push(n)}}}),this.scene.container.remove(this.model)}else{e=this.maxInstancedCount,this.geometry=new i.InstancedBufferGeometry,this.layer.vertexAttributes.forEach(e=>{e.materialAttribute&&this.geometry.addAttribute(e.name,e.materialAttribute)}),this.attributes=this.layer.instanceAttributes.map(e=>{const n=e.size||0,s=new Float32Array(n*this.maxInstancedCount),o=new i.InstancedBufferAttribute(s,n);o.setDynamic(!0),this.geometry.addAttribute(r.instanceAttributeShaderName(e),o);let c=t.get(e.name);c||(c=[],t.set(e.name,c));const l=this.allBufferLocations[e.name]||[];this.allBufferLocations[e.name]=l;const h=Object.assign({},e,{uid:a.uid(),bufferAttribute:o});for(let e=0;e<this.maxInstancedCount;++e){const t={attribute:h,buffer:{value:s},instanceIndex:e,range:[e*n,e*n+n]};c.push(t),l.push(t)}return h}),this.geometry.maxInstancedCount=0,this.material=this.layer.material.clone();for(let e=0,t=this.layer.uniforms.length;e<t;++e){const t=this.layer.uniforms[e];t.materialUniforms.push(this.material.uniforms[t.name])}}return this.scene&&this.model&&this.scene.container.remove(this.model),this.model=l.generateLayerModel(this.layer,this.geometry,this.material),this.model.frustumCulled=!1,this.pickModel=this.layer.picking.type===o.PickType.SINGLE?this.model.clone():void 0,this.scene&&(this.scene.container.add(this.model),this.pickModel&&this.scene.pickingContainer.add(this.pickModel)),{growth:e,newLocations:t}}gatherLocationsIntoGroups(e,t){if(0===this.attributeToPropertyIds.size)return;const n=[];this.attributeToPropertyIds.forEach((t,i)=>{n.push({attribute:i,bufferLocationsForAttribute:e.get(i.name)||[],childBufferLocations:(i.childAttributes||[]).map(t=>e.get(t.name)||[]),ids:t})});for(let e=0;e<t;++e){const e={instanceIndex:-1,propertyToBufferLocation:{}};for(let t=0,i=n.length;t<i;++t){const i=n[t],s=i.attribute,r=i.ids,o=i.bufferLocationsForAttribute;if(!o){c.emitOnce("Instance Attribute Buffer Error",(e,t)=>{console.warn(`${t}: There is an error in forming buffer location groups in InstanceAttributeBufferManager. Error count: ${e}`)});continue}const a=o.shift();if(a){if(-1===e.instanceIndex)e.instanceIndex=a.instanceIndex;else if(a.instanceIndex!==e.instanceIndex){c.emitOnce("Instance Attribute Parallelism Error",(e,t)=>{console.warn(`${t}: A buffer location does not have a matching instance index which means the buffer locations are not in parallel with each other somehow. Error count: ${e}`),console.warn(s.name,a)});continue}if(s.childAttributes){const e=[];for(let t=0,n=s.childAttributes.length;t<n;++t){const n=s.childAttributes[t],r=i.childBufferLocations[t];if(r){const t=r.shift();t?e.push(t):c.emitOnce("Instance Attribute Child Attribute Error",(e,t)=>{console.warn(`${t}: A child attribute does not have a buffer location available. Error count: ${e}`),console.warn(`Parent Attribute: ${s.name} Child Attribute: ${n.name}`)})}}a.childLocations=e}for(let t=0,n=r.length;t<n;++t){const n=r[t];e.propertyToBufferLocation[n]=a}}else c.emitOnce("Instance Attribute Buffer Error",(e,t)=>{console.warn(`${t}: There is an error in forming buffer location groups in InstanceAttributeBufferManager. Error count: ${e}`)})}this.availableLocations.push(e)}c.flushEmitOnce()}getInstanceCount(){return this.maxInstancedCount}}},function(e,t,n){"use strict";function i(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),i(n(6)),i(n(110)),i(n(108))},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(0),s=n(8),r=n(107),o=n(106),a=n(19),c=n(105);t.InstanceDiffManager=class{constructor(e,t){this.layer=e,this.bufferManager=t}makeProcessor(){return this.processing?this.processing:(this.layer.bufferType===s.LayerBufferType.INSTANCE_ATTRIBUTE?this.processor=new r.InstanceAttributeDiffProcessor(this.layer,this.bufferManager):(this.layer.picking&&(this.layer.picking.type===i.PickType.ALL?this.processor=new c.UniformQuadDiffProcessor(this.layer,this.bufferManager):this.layer.picking.type===i.PickType.SINGLE&&(this.processor=new o.UniformColorDiffProcessor(this.layer,this.bufferManager))),this.processor||(this.processor=new a.UniformDiffProcessor(this.layer,this.bufferManager))),this.processing=[this.processor.changeInstance,this.processor.addInstance,this.processor.removeInstance],this.processing)}}},function(e,t,n){"use strict";function i(e,t){const n=e.x-t.x,i=e.y-t.y;return n*n+i*i}Object.defineProperty(t,"__esModule",{value:!0});class s{static add(e,t,n){return n?(n.x=e.x+t.x,n.y=e.y+t.y,n):{x:e.x+t.x,y:e.y+t.y}}static getClosest(e,t){let n,s=Number.MAX_VALUE,r=e;return t.forEach(function(t){(n=i(t,e))<s&&(s=n,r=t)}),r}static getClosestIndex(e,t){let n,s=Number.MAX_VALUE,r=0;return t.forEach(function(t,o){(n=i(t,e))<s&&(s=n,r=o)}),r}static subtract(e,t,n=!1){let i=t.x-e.x,s=t.y-e.y;if(n){const e=Math.sqrt(i*i+s*s);i/=e,s/=e}return{x:i,y:s}}static getDistance(e,t,n=!1){return n?i(e,t):Math.sqrt(i(e,t))}static getMidpoint(e,t){const n=s.subtract(e,t);return{x:n.x/2+e.x,y:n.y/2+e.y}}static make(e,t){return{x:e,y:t}}static scale(e,t,n){return n?(n.x=e.x*t,n.y=e.y*t,n):{x:e.x*t,y:e.y*t}}static zero(){return{x:0,y:0}}}t.Point=s},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(0);t.InstanceProvider=class{constructor(){this.cleanObservation={},this.instanceChanges={},this.allowChanges=!0}get changeList(){return this.allowChanges=!1,Object.values(this.instanceChanges)}add(e){if(this.cleanObservation[e.uid])return e;if(this.allowChanges){e.observer=this;const t=e.observableDisposer;this.cleanObservation[e.uid]=[e,t],this.instanceChanges[e.uid]=[e,i.InstanceDiffType.INSERT,{}]}return e}clear(){const e=Object.values(this.cleanObservation);for(let t=0,n=e.length;t<n;++t)this.remove(e[t][0])}destroy(){const e=Object.values(this.cleanObservation);for(let t=0,n=e.length;t<n;++t)e[t][1]();this.cleanObservation={},this.instanceChanges={}}instanceUpdated(e,t){if(this.allowChanges){const n=this.instanceChanges[e.uid]||[e,i.InstanceDiffType.CHANGE,{}];this.instanceChanges[e.uid]=n,n[1]=i.InstanceDiffType.CHANGE,n[2][t]=t}}remove(e){if(this.allowChanges){const t=this.cleanObservation[e.uid];t&&(t[1](),delete this.cleanObservation[e.uid],this.instanceChanges[e.uid]=[e,i.InstanceDiffType.REMOVE,{}])}return!1}resolve(){this.allowChanges=!0,this.instanceChanges={}}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1),s=n(3),r=n(9),o=n(7),a=n(0),c=n(2);class l extends o.Layer{getInstancePickingMethods(){return{boundsAccessor:e=>new r.Bounds({height:2*e.radius,width:2*e.radius,x:e.x-e.radius,y:e.y-e.radius}),hitTest:(e,t,n)=>{const i=n.worldToScreen(e),s=n.worldToScreen(t),r=e.radius*(this.props.scaleFactor||(()=>1))(),o=[s.x-i.x,s.y-i.y];return o[0]*o[0]+o[1]*o[1]<r*r}}}initShader(){const e=this.props.scaleFactor||(()=>1),t=this.props.animate||{},{center:i,radius:s,color:r}=t,o={0:1,1:1,2:-1,3:1,4:-1,5:-1},c={0:-1,1:-1,2:-1,3:1,4:1,5:1};return{fs:n(101),instanceAttributes:[{block:0,blockIndex:a.InstanceBlockIndex.ONE,easing:i,name:"center",size:a.InstanceAttributeSize.TWO,update:e=>[e.x,e.y]},{block:0,blockIndex:a.InstanceBlockIndex.THREE,easing:s,name:"radius",size:a.InstanceAttributeSize.ONE,update:e=>[e.radius]},{block:0,blockIndex:a.InstanceBlockIndex.FOUR,name:"depth",size:a.InstanceAttributeSize.ONE,update:e=>[e.depth]},{block:1,blockIndex:a.InstanceBlockIndex.ONE,easing:r,name:"color",size:a.InstanceAttributeSize.FOUR,update:e=>e.color}],uniforms:[{name:"scaleFactor",size:a.UniformSize.ONE,update:t=>[e()]}],vertexAttributes:[{name:"position",size:a.VertexAttributeSize.THREE,update:e=>[o[e],c[e],0]}],vertexCount:6,vs:n(100)}}getModelType(){return{drawMode:i.TriangleStripDrawMode,modelType:i.Mesh}}getMaterialOptions(){return c.CommonMaterialOptions.transparentShape}}l.defaultProps={data:new s.InstanceProvider,fadeOutOversized:-1,key:"",scaleFactor:()=>1},t.CircleLayer=l},function(e,t,n){"use strict";function i(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),i(n(115)),i(n(99))},function(e,t,n){"use strict";function i(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),i(n(116)),i(n(98)),i(n(40)),i(n(33)),i(n(77)),i(n(72)),i(n(5))},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(1);class s{}s.transparentShape={premultipliedAlpha:!0,transparent:!0},s.transparentImage={blending:i.CustomBlending,blendSrc:i.OneFactor,premultipliedAlpha:!0,transparent:!0},t.CommonMaterialOptions=s},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(4),s=5,r=10;class o{constructor(e,t,n,i,s){const r=e.mid;this.TL=new a(e.x,r.x,e.y,r.y,n,t),this.TR=new a(r.x,e.right,e.y,r.y,n,t),this.BL=new a(e.x,r.x,r.y,e.bottom,n,t),this.BR=new a(r.x,e.right,r.y,e.bottom,n,t),this.TL.childToNode=i,this.TR.childToNode=i,this.BL.childToNode=i,this.BR.childToNode=i,this.TL.childToBounds=s,this.TR.childToBounds=s,this.BL.childToBounds=s,this.BR.childToBounds=s}destroy(){this.TL.destroy(),this.TR.destroy(),this.BL.destroy(),this.BR.destroy(),delete this.TL,delete this.TR,delete this.BL,delete this.BR}}t.Quadrants=o;class a{constructor(e,t,n,s,r,o=0){this.children=[],this.depth=0,this.nodes=null,arguments.length>=4?this.bounds=new i.Bounds({left:e,right:t,top:n,bottom:s}):this.bounds=new i.Bounds({left:0,right:1,top:1,bottom:0}),this.depth=o,this.getBounds=r,0===this.depth&&(this.nullBounded=[],this.childToNode=new Map,this.childToBounds=new Map)}destroy(){delete this.children,delete this.bounds,this.nodes&&(this.nodes.destroy(),this.nodes=null)}add(e){let t=this.childToBounds.get(e);return t||(t=this.getBounds(e),this.childToBounds.set(e,t)),!t||t.isInside(this.bounds)?this.doAdd(e,t):(this.cover(t),this.add(e))}addAll(e){let t=Number.MAX_VALUE,n=Number.MAX_VALUE,s=-Number.MAX_VALUE,r=-Number.MAX_VALUE;e.forEach(e=>{const i=this.getBounds(e);this.childToBounds.set(e,i),i&&(i.x<t&&(t=i.x),i.right>s&&(s=i.right),i.bottom>r&&(r=i.bottom),i.y<n&&(n=i.y))}),t!==Number.MAX_VALUE&&n!==Number.MAX_VALUE&&s!==-Number.MAX_VALUE&&r!==-Number.MAX_VALUE&&this.cover(new i.Bounds({left:t,right:s,bottom:r,top:n})),e.forEach((e,t)=>this.doAdd(e,this.childToBounds.get(e)||null,!0))}cover(e){if(e.isInside(this.bounds))return;this.bounds.encapsulate(e),this.bounds.x-=1,this.bounds.y-=1,this.bounds.width+=2,this.bounds.height+=2;const t=this.gatherChildren([]);this.children=[],this.nodes&&(this.nodes.destroy(),this.nodes=null),this.childToNode.clear(),t.forEach((e,t)=>this.doAdd(e,this.childToBounds.get(e)||null))}doAdd(e,t,n){return t||0!==this.depth?t?this.nodes?t.isInside(this.nodes.TL.bounds)?this.nodes.TL.doAdd(e,t,n):t.isInside(this.nodes.TR.bounds)?this.nodes.TR.doAdd(e,t,n):t.isInside(this.nodes.BL.bounds)?this.nodes.BL.doAdd(e,t,n):t.isInside(this.nodes.BR.bounds)?this.nodes.BR.doAdd(e,t,n):(this.children.push(e),this.childToNode.set(e,this),!0):t.isInside(this.bounds)?(this.children.push(e),this.childToNode.set(e,this),this.children.length>s&&this.depth<r&&this.split(),!0):(isNaN(t.width+t.height+t.x+t.y)?console.error("Child did not fit into bounds because a dimension is NaN",e,t):0===t.area?console.error("Child did not fit into bounds because the area is zero",e,t):console.error("Child did not get insertted.","Parent:",this.bounds.toString(),"Child:",t.toString(),"Inside Checks:",t.x>=this.bounds.x,t.right<=this.bounds.right,t.y>=this.bounds.y,t.bottom<=this.bounds.bottom),!0):(console.warn("A null bounds was added to a Quad Tree node below the top node, which is invalid."),!1):(this.nullBounded.push(e),this.childToNode.set(e,this),!0)}doRemove(e){const t=this.children.indexOf(e);t>-1&&(this.children.splice(t,1),this.childToNode.delete(e),this.childToBounds.delete(e))}gatherChildren(e){return this.children.forEach(t=>e.push(t)),this.nodes&&(this.nodes.TL.gatherChildren(e),this.nodes.TR.gatherChildren(e),this.nodes.BL.gatherChildren(e),this.nodes.BR.gatherChildren(e)),e}query(e,t){let n=[];return 0===this.depth&&(n=this.nullBounded.slice(0)),e instanceof i.Bounds&&e.hitBounds(this.bounds)?this.queryBounds(e,n,t):this.bounds.containsPoint(e)?this.queryPoint(e,n,t):n}queryBounds(e,t,n){return this.children.forEach(n=>{const i=this.childToBounds.get(n);i&&i.hitBounds(e)&&t.push(n)}),n&&n(this),this.nodes&&(e.hitBounds(this.nodes.TL.bounds)&&this.nodes.TL.queryBounds(e,t,n),e.hitBounds(this.nodes.TR.bounds)&&this.nodes.TR.queryBounds(e,t,n),e.hitBounds(this.nodes.BL.bounds)&&this.nodes.BL.queryBounds(e,t,n),e.hitBounds(this.nodes.BR.bounds)&&this.nodes.BR.queryBounds(e,t,n)),t}queryPoint(e,t,n){return this.children.forEach(n=>{const i=this.childToBounds.get(n);i&&i.containsPoint(e)&&t.push(n)}),n&&n(this),this.nodes&&(this.nodes.TL.bounds.containsPoint(e)&&this.nodes.TL.queryPoint(e,t,n),this.nodes.TR.bounds.containsPoint(e)&&this.nodes.TR.queryPoint(e,t,n),this.nodes.BL.bounds.containsPoint(e)&&this.nodes.BL.queryPoint(e,t,n),this.nodes.BR.bounds.containsPoint(e)&&this.nodes.BR.queryPoint(e,t,n)),t}remove(e){if(this.childToNode){const t=this.childToNode.get(e);if(t&&0===t.depth){const n=t.nullBounded.indexOf(e);if(n>-1)return t.nullBounded.splice(n),this.childToNode.delete(e),void this.childToBounds.delete(e)}t&&t.doRemove(e)}}split(){const e=this.gatherChildren([]);this.nodes=new o(this.bounds,this.depth+1,this.getBounds,this.childToNode,this.childToBounds),this.children=[];for(let t=0,n=e.length;t<n;++t){const n=e[t];this.doAdd(n,this.childToBounds.get(n)||null,!0)}}visit(e){const t=Boolean(e(this));this.nodes&&!t&&(this.nodes.TL.visit(e),this.nodes.TR.visit(e),this.nodes.BL.visit(e),this.nodes.BR.visit(e))}}t.Node=a;t.TrackedQuadTree=class extends a{}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(22);t.ReferenceCamera=class extends i.ChartCamera{constructor(e){super(),this.offsetFilter=(e=>e),this.scaleFilter=(e=>e),Object.assign(this,e)}set offset(e){}get offset(){return this.offsetFilter(this.base.offset)}set scale(e){}get scale(){return this.scaleFilter(this.base.scale)}}},function(e,t){var n=1e3,i=60*n,s=60*i,r=24*s,o=365.25*r;function a(e,t,n){if(!(e<t))return e<1.5*t?Math.floor(e/t)+" "+n:Math.ceil(e/t)+" "+n+"s"}e.exports=function(e,t){t=t||{};var c=typeof e;if("string"===c&&e.length>0)return function(e){if((e=String(e)).length>100)return;var t=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(e);if(!t)return;var a=parseFloat(t[1]);switch((t[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return a*o;case"days":case"day":case"d":return a*r;case"hours":case"hour":case"hrs":case"hr":case"h":return a*s;case"minutes":case"minute":case"mins":case"min":case"m":return a*i;case"seconds":case"second":case"secs":case"sec":case"s":return a*n;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return a;default:return}}(e);if("number"===c&&!1===isNaN(e))return t.long?function(e){return a(e,r,"day")||a(e,s,"hour")||a(e,i,"minute")||a(e,n,"second")||e+" ms"}(e):function(e){if(e>=r)return Math.round(e/r)+"d";if(e>=s)return Math.round(e/s)+"h";if(e>=i)return Math.round(e/i)+"m";if(e>=n)return Math.round(e/n)+"s";return e+"ms"}(e);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))}},function(e,t,n){function i(e){var n;function i(){if(i.enabled){var e=i,s=+new Date,r=s-(n||s);e.diff=r,e.prev=n,e.curr=s,n=s;for(var o=new Array(arguments.length),a=0;a<o.length;a++)o[a]=arguments[a];o[0]=t.coerce(o[0]),"string"!=typeof o[0]&&o.unshift("%O");var c=0;o[0]=o[0].replace(/%([a-zA-Z%])/g,function(n,i){if("%%"===n)return n;c++;var s=t.formatters[i];if("function"==typeof s){var r=o[c];n=s.call(e,r),o.splice(c,1),c--}return n}),t.formatArgs.call(e,o),(i.log||t.log||console.log.bind(console)).apply(e,o)}}return i.namespace=e,i.enabled=t.enabled(e),i.useColors=t.useColors(),i.color=function(e){var n,i=0;for(n in e)i=(i<<5)-i+e.charCodeAt(n),i|=0;return t.colors[Math.abs(i)%t.colors.length]}(e),i.destroy=s,"function"==typeof t.init&&t.init(i),t.instances.push(i),i}function s(){var e=t.instances.indexOf(this);return-1!==e&&(t.instances.splice(e,1),!0)}(t=e.exports=i.debug=i.default=i).coerce=function(e){return e instanceof Error?e.stack||e.message:e},t.disable=function(){t.enable("")},t.enable=function(e){var n;t.save(e),t.names=[],t.skips=[];var i=("string"==typeof e?e:"").split(/[\s,]+/),s=i.length;for(n=0;n<s;n++)i[n]&&("-"===(e=i[n].replace(/\*/g,".*?"))[0]?t.skips.push(new RegExp("^"+e.substr(1)+"$")):t.names.push(new RegExp("^"+e+"$")));for(n=0;n<t.instances.length;n++){var r=t.instances[n];r.enabled=t.enabled(r.namespace)}},t.enabled=function(e){if("*"===e[e.length-1])return!0;var n,i;for(n=0,i=t.skips.length;n<i;n++)if(t.skips[n].test(e))return!1;for(n=0,i=t.names.length;n<i;n++)if(t.names[n].test(e))return!0;return!1},t.humanize=n(121),t.instances=[],t.names=[],t.skips=[],t.formatters={}},function(e,t){var n,i,s=e.exports={};function r(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function a(e){if(n===setTimeout)return setTimeout(e,0);if((n===r||!n)&&setTimeout)return n=setTimeout,setTimeout(e,0);try{return n(e,0)}catch(t){try{return n.call(null,e,0)}catch(t){return n.call(this,e,0)}}}!function(){try{n="function"==typeof setTimeout?setTimeout:r}catch(e){n=r}try{i="function"==typeof clearTimeout?clearTimeout:o}catch(e){i=o}}();var c,l=[],h=!1,d=-1;function u(){h&&c&&(h=!1,c.length?l=c.concat(l):d=-1,l.length&&p())}function p(){if(!h){var e=a(u);h=!0;for(var t=l.length;t;){for(c=l,l=[];++d<t;)c&&c[d].run();d=-1,t=l.length}c=null,h=!1,function(e){if(i===clearTimeout)return clearTimeout(e);if((i===o||!i)&&clearTimeout)return i=clearTimeout,clearTimeout(e);try{i(e)}catch(t){try{return i.call(null,e)}catch(t){return i.call(this,e)}}}(e)}}function f(e,t){this.fun=e,this.array=t}function g(){}s.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];l.push(new f(e,t)),1!==l.length||h||a(p)},f.prototype.run=function(){this.fun.apply(null,this.array)},s.title="browser",s.browser=!0,s.env={},s.argv=[],s.version="",s.versions={},s.on=g,s.addListener=g,s.once=g,s.off=g,s.removeListener=g,s.removeAllListeners=g,s.emit=g,s.prependListener=g,s.prependOnceListener=g,s.listeners=function(e){return[]},s.binding=function(e){throw new Error("process.binding is not supported")},s.cwd=function(){return"/"},s.chdir=function(e){throw new Error("process.chdir is not supported")},s.umask=function(){return 0}},function(e,n){e.exports=t},function(e,t,n){"use strict";function i(e){return!isNaN(e)}Object.defineProperty(t,"__esModule",{value:!0});t.AnimationHelper=class{constructor(e){this.surface=e}groupAnimation(e,t,n,s,r){const o=this.surface.frameMetrics.currentTime;this.surface.commit(o);for(let a=0;a<t;++a){const t=i(s)?s:s(a,e.delay);e.delay=n+t*a,r(a),this.surface.commit(o)}}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=n(4),s=n(25),r=n(2);var o;!function(e){e[e.TOP_LEFT=0]="TOP_LEFT",e[e.TOP_MIDDLE=1]="TOP_MIDDLE",e[e.TOP_RIGHT=2]="TOP_RIGHT",e[e.MIDDLE_LEFT=3]="MIDDLE_LEFT",e[e.MIDDLE=4]="MIDDLE",e[e.MIDDLE_RIGHT=5]="MIDDLE_RIGHT",e[e.BOTTOM_LEFT=6]="BOTTOM_LEFT",e[e.BOTTOM_MIDDLE=7]="BOTTOM_MIDDLE",e[e.BOTTOM_RIGHT=8]="BOTTOM_RIGHT"}(o=t.CameraBoundsAnchor||(t.CameraBoundsAnchor={}));const{max:a,min:c}=Math;t.BasicCameraController=class extends s.EventManager{constructor(e){super(),this.isPanning=!1,this.panFilter=((e,t,n)=>e),this.scaleFilter=((e,t,n)=>e),this.startViews=[],this.onRangeChanged=((e,t)=>{}),this.startViewDidStart=!1,this.applyBounds=(()=>{if(this.bounds&&this.camera){const e=this.getView(this.bounds.view);this.applyScaleBounds(),e&&(this.camera.offset[0]=this.boundsHorizontalOffset(e,this.bounds),this.camera.offset[1]=this.boundsVerticalOffset(e,this.bounds))}}),this.applyScaleBounds=(()=>{this.camera&&this.bounds&&(this.bounds.scaleMin&&(this.camera.scale=[a(this.camera.scale[0],this.bounds.scaleMin[0]),a(this.camera.scale[1],this.bounds.scaleMin[1]),a(this.camera.scale[2],this.bounds.scaleMin[2])]),this.bounds.scaleMax&&(this.camera.scale=[c(this.camera.scale[0],this.bounds.scaleMax[0]),c(this.camera.scale[1],this.bounds.scaleMax[1]),c(this.camera.scale[2],this.bounds.scaleMax[2])]))}),e.bounds&&this.setBounds(e.bounds),this.camera=e.camera,this.scaleFactor=e.scaleFactor||1e3,this.ignoreCoverViews=e.ignoreCoverViews||!1,e.startView&&(this.startViews=Array.isArray(e.startView)?e.startView:[e.startView]),this.panFilter=e.panFilter||this.panFilter,this.scaleFilter=e.scaleFilter||this.scaleFilter,this.onRangeChanged=e.onRangeChanged||this.onRangeChanged}anchoredByBoundsHorizontal(e,t){switch(t.anchor){case o.TOP_LEFT:case o.MIDDLE_LEFT:case o.BOTTOM_LEFT:return-(t.worldBounds.left-t.screenPadding.left/this.camera.scale[0]);case o.TOP_MIDDLE:case o.MIDDLE:case o.BOTTOM_MIDDLE:return-(t.worldBounds.right-t.worldBounds.width/2-(e.screenBounds.width+t.screenPadding.right)/this.camera.scale[0]*.5);case o.TOP_RIGHT:case o.MIDDLE_RIGHT:case o.BOTTOM_RIGHT:return-(t.worldBounds.right-(e.screenBounds.width-t.screenPadding.right)/this.camera.scale[0])}}anchoredByBoundsVertical(e,t){switch(t.anchor){case o.TOP_LEFT:case o.TOP_MIDDLE:case o.TOP_RIGHT:return-t.worldBounds.top- -t.screenPadding.top/this.scale[1];case o.MIDDLE_LEFT:case o.MIDDLE:case o.MIDDLE_RIGHT:return-(t.worldBounds.bottom-t.worldBounds.height/2)+.5*(e.screenBounds.height-t.screenPadding.bottom)/this.scale[1];case o.BOTTOM_LEFT:case o.BOTTOM_MIDDLE:case o.BOTTOM_RIGHT:return-(t.worldBounds.bottom-(e.screenBounds.height-t.screenPadding.bottom)/this.scale[1])}}boundsHorizontalOffset(e,t){const n=e.worldToScreen({x:t.worldBounds.left,y:t.worldBounds.top}),i=e.worldToScreen({x:t.worldBounds.right,y:t.worldBounds.bottom});return i.x-n.x+t.screenPadding.left+t.screenPadding.right-e.screenBounds.width<0?this.anchoredByBoundsHorizontal(e,t):i.x<e.screenBounds.right-t.screenPadding.right?-t.worldBounds.right+(e.screenBounds.width-t.screenPadding.right)/this.camera.scale[0]:n.x>e.screenBounds.left+t.screenPadding.left?-t.worldBounds.left+t.screenPadding.left/this.camera.scale[0]:this.camera.offset[0]}boundsVerticalOffset(e,t){const n=e.worldToScreen({x:t.worldBounds.left,y:t.worldBounds.top}),i=e.worldToScreen({x:t.worldBounds.right,y:t.worldBounds.bottom});return i.y-n.y+t.screenPadding.top+t.screenPadding.bottom-e.screenBounds.height<0?this.anchoredByBoundsVertical(e,t):n.y>e.screenBounds.top-t.screenPadding.top?-(t.worldBounds.top-t.screenPadding.top/this.camera.scale[1]):i.y<e.screenBounds.bottom+t.screenPadding.bottom?-(t.worldBounds.bottom+(-e.screenBounds.height+t.screenPadding.bottom)/this.camera.scale[1]):this.camera.offset[1]}canStart(e){return 0===this.startViews.length||this.startViews&&this.startViews.indexOf(e)>-1||this.startViewDidStart&&this.ignoreCoverViews}findCoveredStartView(e){const t=e.viewsUnderMouse.find(e=>this.startViews.indexOf(e.view.id)>-1);this.startViewDidStart=Boolean(t),t&&(this.coveredStartView=t.view)}getTargetView(e){return this.startViews&&!this.ignoreCoverViews?e.target.view:this.coveredStartView}handleMouseDown(e,t){this.startViews&&(this.findCoveredStartView(e),e.start&&(this.isPanning=this.canStart(e.start.view.id)||this.isPanning))}handleMouseUp(e){this.startViewDidStart=!1,this.isPanning=!1}handleDrag(e,t){if(e.start&&this.canStart(e.start.view.id)){let n=[t.screen.delta.x/this.camera.scale[0],t.screen.delta.y/this.camera.scale[1],0];this.panFilter&&(n=this.panFilter(n,e.start.view,e.viewsUnderMouse.map(e=>e.view))),this.camera.offset[0]+=n[0],this.camera.offset[1]+=n[1],this.applyBounds(),this.onRangeChanged(this.camera,e.start.view),this.applyBounds()}}handleWheel(e,t){if(this.findCoveredStartView(e),this.canStart(e.target.view.id)){const n=this.getTargetView(e),i=n.screenToWorld(e.screen.mouse),s=this.camera.scale[0]||1,r=this.camera.scale[1]||1;let o=[t.wheel[1]/this.scaleFactor*s,t.wheel[1]/this.scaleFactor*r,1];this.scaleFilter&&(o=this.scaleFilter(o,n,e.viewsUnderMouse.map(e=>e.view))),this.camera.scale[0]=s+o[0],this.camera.scale[1]=r+o[1],this.applyScaleBounds();const a=n.screenToWorld(e.screen.mouse);this.camera.offset[0]-=i.x-a.x,this.camera.offset[1]-=i.y-a.y,this.applyBounds(),this.onRangeChanged(this.camera,n),this.applyBounds()}}handleMouseOut(e){}handleClick(e){}handleMouseMove(e){}handleMouseOver(e){}getRange(e){const t=this.getProjection(e),n=this.getViewScreenBounds(e);if(t&&n){const e=t.screenToWorld(n),s=t.screenToWorld({x:n.right,y:n.bottom});return new i.Bounds({height:s.y-e.y,width:s.x-e.x,x:e.x,y:e.y})}return new i.Bounds({x:0,y:0,width:1,height:1})}get pan(){return this.camera.offset}setBounds(e){this.bounds=e,this.applyBounds()}get scale(){return this.camera.scale}setRange(e,t){const n=this.getProjection(t),i=this.getViewScreenBounds(t),s=this.getView(t);if(n&&i&&s){const t=r.subtract3([i.width/e.width,i.height/e.height,1],this.camera.scale);this.camera.scale=r.add3(this.camera.scale,this.scaleFilter(t,s,[s]));const n=r.subtract3([-e.x,-e.y,0],this.camera.offset);this.camera.offset=r.add3(this.camera.offset,this.scaleFilter(n,s,[s])),this.applyBounds(),this.onRangeChanged(this.camera,s),this.applyBounds()}}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}(n(126))},function(e,t,n){"use strict";function i(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}Object.defineProperty(t,"__esModule",{value:!0}),i(n(127)),i(n(117)),i(n(3)),i(n(9)),i(n(67)),i(n(0)),i(n(2))},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])}(n(128))}])});
//# sourceMappingURL=index.js.map