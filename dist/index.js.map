{"version":3,"sources":["webpack://voidgl/webpack/universalModuleDefinition","webpack://voidgl/webpack/bootstrap","webpack://voidgl/./src/voidgl/types.ts","webpack://voidgl/external \"three\"","webpack://voidgl/./src/voidgl/util/index.ts","webpack://voidgl/./src/voidgl/instance-provider/index.ts","webpack://voidgl/./src/voidgl/primitives/bounds.ts","webpack://voidgl/./src/voidgl/base-layers/types.ts","webpack://voidgl/./src/voidgl/surface/buffer-management/buffer-manager-base.ts","webpack://voidgl/./src/voidgl/surface/layer.ts","webpack://voidgl/./src/voidgl/surface/layer-processing/layer-buffer-type.ts","webpack://voidgl/./src/voidgl/primitives/index.ts","webpack://voidgl/./src/voidgl/surface/texture/index.ts","webpack://voidgl/./src/voidgl/surface/layer-processing/generate-layer-model.ts","webpack://voidgl/./src/voidgl/util/identify-by-key.ts","webpack://voidgl/./src/voidgl/instance-provider/instance.ts","webpack://voidgl/./src/voidgl/surface/view.ts","webpack://voidgl/./src/voidgl/surface/scene.ts","webpack://voidgl/./src/voidgl/surface/texture/label-atlas-resource.ts","webpack://voidgl/./src/voidgl/surface/texture/base-atlas-resource.ts","webpack://voidgl/./src/voidgl/base-layers/edges/types.ts","webpack://voidgl/./src/voidgl/surface/buffer-management/diff-processors/uniform-diff-processor.ts","webpack://voidgl/./src/voidgl/util/view-camera.ts","webpack://voidgl/./src/voidgl/util/shader-templating.ts","webpack://voidgl/./src/voidgl/util/chart-camera.ts","webpack://voidgl/./src/voidgl/util/vector.ts","webpack://voidgl/./src/voidgl/util/auto-easing-method.ts","webpack://voidgl/./src/voidgl/surface/event-manager.ts","webpack://voidgl/./src/voidgl/surface/mouse-event-manager.ts","webpack://voidgl/./src/voidgl/surface/layer-processing/inject-shader-io.ts","webpack://voidgl/./src/voidgl/surface/layer-processing/generate-layer-material.ts","webpack://voidgl/./src/voidgl/surface/layer-processing/generate-layer-geometry.ts","webpack://voidgl/./src/voidgl/surface/layer-processing/generate-default-scene.ts","webpack://voidgl/./src/voidgl/util/data-bounds.ts","webpack://voidgl/./src/voidgl/shaders/fragments/template-vars.ts","webpack://voidgl/./src/voidgl/base-layers/labels/index.ts","webpack://voidgl/./src/voidgl/surface/texture/label-rasterizer.ts","webpack://voidgl/./src/voidgl/surface/texture/image-atlas-resource.ts","webpack://voidgl/./src/voidgl/surface/texture/color-rasterizer.ts","webpack://voidgl/./src/voidgl/surface/texture/color-atlas-resource.ts","webpack://voidgl/./src/voidgl/surface/texture/sub-texture.ts","webpack://voidgl/./src/voidgl/surface/texture/atlas.ts","webpack://voidgl/./src/voidgl/base-layers/images/index.ts","webpack://voidgl/./src/voidgl/surface/buffer-management/diff-processors/base-diff-processor.ts","webpack://voidgl/./src/voidgl/shaders/util/make-instance-uniform-name.ts","webpack://voidgl/./src/voidgl/shaders/util/instance-attribute-shader-name.ts","webpack://voidgl/./src/voidgl/util/webgl-stat.ts","webpack://voidgl/./node_modules/debug/src/browser.js","webpack://voidgl/./src/voidgl/util/mouse.ts","webpack://voidgl/./src/voidgl/util/uid.ts","webpack://voidgl/./src/voidgl/instance-provider/observable.ts","webpack://voidgl/./src/voidgl/surface/texture/atlas-resource-manager.ts","webpack://voidgl/./src/voidgl/util/quad-tree.ts","webpack://voidgl/./src/voidgl/primitives/absolute-position.ts","webpack://voidgl/./src/voidgl/surface/event-managers/layer-mouse-events.ts","webpack://voidgl/./src/voidgl/util/color-picking-analysis.ts","webpack://voidgl/./src/voidgl/shaders/fragments/color-picking-assignment.vs","webpack://voidgl/./src/voidgl/shaders/fragments/color-picking-disabled.fs","webpack://voidgl/./src/voidgl/shaders/fragments/color-picking-method.fs","webpack://voidgl/./src/voidgl/shaders/fragments/color-picking-vertex-header.vs","webpack://voidgl/./src/voidgl/shaders/fragments/projection-methods.vs","webpack://voidgl/./src/voidgl/shaders/fragments/shader-input.vs","webpack://voidgl/./src/voidgl/shaders/fragments/instance-destructuring-array.vs","webpack://voidgl/./src/voidgl/shaders/fragments/fragment-shader-composition.fs","webpack://voidgl/./src/voidgl/shaders/fragments/vertex-shader-composition.vs","webpack://voidgl/./src/voidgl/shaders/fragments/instance-retrieval-array.vs","webpack://voidgl/./src/voidgl/shaders/util/uniform-instance-block-array.ts","webpack://voidgl/./src/voidgl/shaders/util/attribute-generation.ts","webpack://voidgl/./src/voidgl/surface/layer-surface.ts","webpack://voidgl/./src/voidgl/surface/index.ts","webpack://voidgl/./src/voidgl/base-layers/rings/ring-layer.vs","webpack://voidgl/./src/voidgl/base-layers/rings/ring-layer.fs","webpack://voidgl/./src/voidgl/base-layers/rings/ring-layer.ts","webpack://voidgl/./src/voidgl/base-layers/rings/ring-instance.ts","webpack://voidgl/./src/voidgl/base-layers/rings/index.ts","webpack://voidgl/./src/voidgl/base-layers/rectangle/rectangle-instance.ts","webpack://voidgl/./src/voidgl/base-layers/rectangle/rectangle-layer.vs","webpack://voidgl/./src/voidgl/base-layers/rectangle/rectangle-layer.fs","webpack://voidgl/./src/voidgl/base-layers/rectangle/rectangle-layer.ts","webpack://voidgl/./src/voidgl/base-layers/rectangle/index.ts","webpack://voidgl/./src/voidgl/base-layers/labels/label-instance.ts","webpack://voidgl/./src/voidgl/base-layers/labels/label-layer.vs","webpack://voidgl/./src/voidgl/base-layers/labels/label-layer.fs","webpack://voidgl/./src/voidgl/base-layers/labels/label-layer.ts","webpack://voidgl/./src/voidgl/surface/texture/image-rasterizer.ts","webpack://voidgl/./src/voidgl/surface/texture/atlas-manager.ts","webpack://voidgl/./src/voidgl/surface/texture/pack-node.ts","webpack://voidgl/./src/voidgl/base-layers/images/image-instance.ts","webpack://voidgl/./src/voidgl/base-layers/images/image-layer.vs","webpack://voidgl/./src/voidgl/base-layers/images/image-layer.fs","webpack://voidgl/./src/voidgl/base-layers/images/image-layer.ts","webpack://voidgl/./src/voidgl/base-layers/edges/edge-instance.ts","webpack://voidgl/./src/voidgl/base-layers/edges/shader/edge-layer.fs","webpack://voidgl/./src/voidgl/base-layers/edges/shader/edge-layer-screen-curve.vs","webpack://voidgl/./src/voidgl/base-layers/edges/shader/edge-layer.vs","webpack://voidgl/./src/voidgl/base-layers/edges/shader/edge-layer-bezier2.vs","webpack://voidgl/./src/voidgl/base-layers/edges/shader/edge-layer-bezier.vs","webpack://voidgl/./src/voidgl/base-layers/edges/shader/edge-layer-line.vs","webpack://voidgl/./src/voidgl/base-layers/edges/edge-picking.ts","webpack://voidgl/./src/voidgl/base-layers/edges/edge-layer.ts","webpack://voidgl/./src/voidgl/base-layers/edges/index.ts","webpack://voidgl/./src/voidgl/base-layers/circles/circle-instance.ts","webpack://voidgl/./src/voidgl/base-layers/circles/circle-layer.vs","webpack://voidgl/./src/voidgl/base-layers/circles/circle-layer.fs","webpack://voidgl/./src/voidgl/shaders/base/no-op.vs","webpack://voidgl/./src/voidgl/shaders/base/no-op.fs","webpack://voidgl/./src/voidgl/surface/layer-interaction-handler.ts","webpack://voidgl/./src/voidgl/surface/buffer-management/diff-processors/uniform-quad-diff-processor.ts","webpack://voidgl/./src/voidgl/surface/buffer-management/diff-processors/uniform-color-diff-processor.ts","webpack://voidgl/./src/voidgl/surface/buffer-management/diff-processors/instance-attribute-diff-processor.ts","webpack://voidgl/./src/voidgl/surface/buffer-management/uniform-buffer-manager.ts","webpack://voidgl/./src/voidgl/util/emit-once.ts","webpack://voidgl/./src/voidgl/surface/buffer-management/instance-attribute-buffer-manager.ts","webpack://voidgl/./src/voidgl/surface/buffer-management/index.ts","webpack://voidgl/./src/voidgl/surface/buffer-management/instance-diff-manager.ts","webpack://voidgl/./src/voidgl/primitives/point.ts","webpack://voidgl/./src/voidgl/instance-provider/instance-provider.ts","webpack://voidgl/./src/voidgl/base-layers/circles/circle-layer.ts","webpack://voidgl/./src/voidgl/base-layers/circles/index.ts","webpack://voidgl/./src/voidgl/base-layers/index.ts","webpack://voidgl/./src/voidgl/util/common-options.ts","webpack://voidgl/./src/voidgl/util/tracked-quad-tree.ts","webpack://voidgl/./src/voidgl/util/reference-camera.ts","webpack://voidgl/./node_modules/ms/index.js","webpack://voidgl/./node_modules/debug/src/debug.js","webpack://voidgl/./node_modules/process/browser.js","webpack://voidgl/external \"bowser\"","webpack://voidgl/./src/voidgl/util/animation-helper.ts","webpack://voidgl/./src/voidgl/base-event-managers/basic-camera-controller.ts","webpack://voidgl/./src/voidgl/base-event-managers/index.ts","webpack://voidgl/./src/voidgl/index.ts","webpack://voidgl/./src/index.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__1__","__WEBPACK_EXTERNAL_MODULE__124__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","InstanceAttributeSize","InstanceBlockIndex","instanceAttributeSizeFloatCount","_a","ONE","TWO","THREE","FOUR","ATLAS","UniformSize","VertexAttributeSize","ShaderInjectionTarget","PickType","InstanceDiffType","__export","Bounds","options","this","x","y","width","height","left","top","bottom","right","emptyBounds","containsPoint","point","encapsulate","item","Math","abs","fits","bounds","hitBounds","isInside","toString","AnchorType","ScaleType","isBufferLocation","val","buffer","isBufferLocationGroup","propertyToBufferLocation","BufferManagerBase","layer","scene","Three","types_1","util_1","identify_by_key_1","instance_diff_manager_1","layer_interaction_handler_1","Layer","_super","props","_this","depth","instanceById","Map","instanceVertexCount","assign","defaultProps","picking","NONE","ALL","pickingMethods","getInstancePickingMethods","currentPickMode","hitTest","quadTree","TrackedQuadTree","boundsAccessor","type","SINGLE","uidToInstance","__extends","_bufferManager","_bufferType","destroy","bufferManager","removeLayer","removeFromScene","didUpdateProps","draw","uniform","change","instance","bufferLocations","changeList","data","diffManager","processing","processor","incomingChangeList","end","length","getBufferLocations","values","commit","resolve","uniforms","update","materialUniforms","forEach","materialUniform","Error","getModelType","drawMode","TrianglesDrawMode","modelType","Mesh","getMaterialOptions","initShader","fs","instanceAttributes","vertexAttributes","vertexCount","vs","makeInstanceAttribute","block","blockIndex","size","atlas","makeUniform","shaderInjection","qualifier","setBufferManager","console","warn","InstanceDiffManager","makeProcessor","interactions","LayerInteractionHandler","setBufferType","undefined","willUpdateInstances","changes","willUpdateProps","newProps","didUpdate","IdentifyByKey","LayerBufferType","buffer_management_1","getLayerBufferType","gl","bufferType","WebGLStat","HARDWARE_INSTANCING","attributesUsed","attribute","ceil","MAX_VERTEX_ATTRIBUTES","UNIFORM","INSTANCE_ATTRIBUTE","makeLayerBufferManager","InstanceAttributeBufferManager","UniformBufferManager","generateLayerModel","geometry","material","modelInfo","model","Boolean","isMesh","TriangleStripDrawMode","key","observable_1","instanceUID","Instance","_attributeMapping","_easing","observableStorage","_uid","newUID","_id","id","active","_observer","oldObserver","remove","resourceTrigger","__decorate","observable","absolute_position_1","bounds_1","view_camera_1","isOrthographic","ClearFlags","View","pixelRatio","devicePixelRatio","screenToPixelSpace","out","pixelSpaceToScreen","screenToView","viewBounds","viewToScreen","screenToWorld","view","world","camera","offset","scale","viewCamera","ViewCameraType","CUSTOM","worldToScreen","screen","viewToWorld","worldToView","fitViewtoViewport","surfaceDimensions","CONTROLLED","baseCamera","getAbsolutePositionBounds","viewport","far","near","position","set","z","updateMatrix","updateMatrixWorld","updateProjectionMatrix","screenBounds","DEFAULT_VIEW_ID","sortByDepth","a","b","Scene","container","pickingContainer","layers","sortIsDirty","viewById","frustumCulled","autoUpdate","addLayer","push","addView","index","indexOf","splice","sortLayers","sort","DEFAULT_SCENE_ID","LabelAtlasResource","label","BaseAtlasResource","sampleScale","EdgeScaleType","EdgeType","EdgeBroadphase","buffer_manager_base_1","VECTOR_ACCESSORS","EMPTY","UniformDiffProcessor","addInstance","manager","_propIds","uniformCluster","changeInstance","add","updateInstance","removeInstance","uniformRangeStart","range","instanceData","instanceUniform","start","k","endk","resource","setTargetAtlas","activeAttribute","_changes","BaseDiffProcessor","ViewCamera","shaderTemplate","shader","required","matched","noValueProvided","notFound","shaderOptions","shaderResults","replace","match","keys","option","results","resolvedShaderOptions","shaderProvidedOptions","unresolvedProvidedOptions","unresolvedShaderOptions","error","chartCameraUID","applyArray","target","source","apply","concat","ChartCamera","location","slice","sqrt","add1","scale1","vec","subtract1","multiply1","dot1","linear1","t","length1","add2","scale2","subtract2","multiply2","dot2","linear2","length2","add3","scale3","subtract3","multiply3","linear3","length3","dot3","add4","scale4","subtract4","multiply4","dot4","linear4","length4","vec1Methods","dot","linear","multiply","subtract","vec2Methods","vec3Methods","vec4Methods","VecMath","AutoEasingLoopStyle","vector_1","min","max","pow","round","sin","PI","GPU_PI","clamp","minVal","maxVal","easeOutElasticGPU","easeBackInGPU","continuousSinusoidalGPU","AutoEasingMethod","cpu","gpu","duration","method","delay","loop","methodName","immediate","easeInQuad","time","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeOutElastic","easeBackIn","easeBackOut","t1","easeBackInOut","a1","t2","continuousSinusoidal","CONTINUOUS","direction","amplitude","validation","ignoreEndValueCheck","ignoreOverTimeCheck","EventManager","getProjection","viewId","mouseManager","getView","getViewScreenBounds","setMouseManager","mouse_1","quad_tree_1","isDefined","MouseEventManager","canvas","views","controllers","handlesWheelEvents","eventCleanup","_waitingForRender","getViewsUnderMouse","mouse","hitViews","query","resize","context","setViews","setControllers","addContextListeners","QuadTree","addAll","map","v","filter","startView","startPosition","element","wheelHandler","event","eventElementPosition","interaction","makeInteraction","wheel","makeWheel","controller","handleWheel","stopPropagation","preventDefault","onwheel","addEventListener","onmouseleave","waitingForRender","handleMouseOut","onmousemove","handleMouseMove","onmousedown","downViews","canClick","clickStartTime","Date","now","currentPosition","handleMouseDown","button","document","delta","drag","makeDrag","handleDrag","onmouseup","onmouseover","handleMouseOver","handleMouseUp","handleClick","onselectstart","addTouchContextListeners","ontouchstart","ontouchend","ontouchmove","ontouchcancel","_i","previous","current","viewsUnderMouse","normalizeWheel","onmousewheel","removeEventListener","auto_easing_method_1","layer_buffer_type_1","testStartVector","testEndVector","_b","emptyTexture","Texture","isEasingAttribute","attr","easing","isInstanceAttribute","isVertexAttribute","isUniform","toVertexAttributeInternal","materialAttribute","toUniformInternal","findEmptyBlock","attributes","seekingSize","usedBlocks","maxBlock","instanceAttribute","ind","breadth","sortNeedsUpdateFirstToTop","generateAtlasResourceUniforms","atlasInstanceAttributes","requestedAtlasInjections","isAtlasAttribute","injection","FRAGMENT","injections","VERTEX","getAtlasTexture","compareVec","injectShaderIO","shaderIO","find","testStart","testEnd","validationRules","test","validateInstanceAttributes","easingAttributes","instanceAttributes_1","easingValues","name_1","easingUID","uid","currentTime","surface","frameMetrics","startTime","timeValue","REPEAT","REFLECT","timePassed","childAttributes","slot","startAttr","parentAttribute","startTimeAttr","durationAttr","easingAttributes_1","generateEasingAttributes","addedUniforms","MATRIX4","projectionMatrix","elements","matrix","generateBaseUniforms","generatePickingUniforms","addedInstanceAttributes","fillBlock","generateBaseInstanceAttributes","emptyFillBlock","color","generatePickingAttributes","allUniforms","allInstanceAttributes","generateBaseVertexAttributes","UNIFORM_SIZE_TO_MATERIAL_TYPE","MATRIX3","DEFAULT_UNIFORM_VALUE","toMaterialUniform","generateLayerMaterial","layerUniforms","instancingUniforms","materialParams","vertexShader","fragmentShader","generatedUniform","RawShaderMaterial","isNumberCluster","Array","isArray","generateLayerGeometry","maxInstancesPerBuffer","vertexBuffers","attribute_1","Float32Array","formatError","j","endj","instanceSize","endk_1","copyWithin","instancingBuffer","instanceStartIndex","BufferGeometry","attribute_3","BufferAttribute","addAttribute","chart_camera_1","scene_1","view_1","generateDefaultScene","aspectRatio","viewSize","defaultCamera","OrthographicCamera","defaultChartCamera","defaultViewport","defaultView","defaultScene","DataBounds","templateVars","attributeFragments","blocksPerInstance","easingMethod","easingMethods","instanceBlockCount","instanceDataBinaryTree","instanceDataRetrieval","instanceDestructuring","instanceFragments","instanceUniformDeclarations","projectionMethods","shaderInput","T","floor","LabelRasterizer","awaitContext","getContext","Promise","setTimeout","sent","calculateLabelSize","calculateTexture","calculateTrucatedText","sampleScaling","drawLabel","truncatedText","measureContents","minX","minY","maxX","maxY","rasterization","texture","createCroppedCanvas","maxWidth","text","firstTest","cursor","safety","substr","nextCursor","cropped","createElement","imageSmoothingEnabled","drawImage","fontSize","getLabelRasterizationFontSize","fillStyle","font","makeCSSFont","measureText","fillText","potentialCanvas","fontWeight","fontFamily","imageData","getImageData","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","render","renderSync","ImageAtlasResource","image","ColorRasterizer","limit","makeCSS","g","opacity","fillRect","ColorAtlasResource","SubTexture","atlasReferenceID","atlasTexture","atlasTL","atlasTR","atlasBL","atlasBR","widthOnAtlas","heightOnAtlas","isValid","pixelWidth","pixelHeight","pack_node_1","sub_texture_1","AtlasSize","Atlas","validResources","textureSettings","packing","PackNode","updateTexture","invalidateResource","zero","setManager","registerResource","removeResource","redoneCanvas","dispose","generateMipmaps","premultiplyAlpha","needsUpdate","INSTANCE_UNIFORM_ATTRIBUTE_PREFIX","makeInstanceUniformNameArray","makeInstanceUniformNameTree","instanceAttributeShaderName","getProgramInfo","program","result","attributeCount","uniformCount","activeUniforms","getProgramParameter","ACTIVE_UNIFORMS","activeAttributes","ACTIVE_ATTRIBUTES","enums","35664","35665","35666","35667","35668","35669","35670","35671","35672","35673","35674","35675","35676","35678","35680","5120","5121","5122","5123","5124","5125","5126","blocks","getActiveUniform","typeName","getActiveAttrib","MAX_VERTEX_UNIFORMS","MAX_FRAGMENT_UNIFORMS","WEBGL_SUPPORTED","MAX_TEXTURE_SIZE","HARDWARE_INSTANCING_ANGLE","WebGLRenderingContext","e","getAContext","getParameter","MAX_VERTEX_UNIFORM_VECTORS","MAX_FRAGMENT_UNIFORM_VECTORS","MAX_VERTEX_ATTRIBS","getExtension","initStats","process","load","storage","debug","env","DEBUG","log","Function","arguments","formatArgs","args","useColors","namespace","humanize","diff","lastC","save","namespaces","removeItem","navigator","userAgent","toLowerCase","documentElement","style","WebkitAppearance","firebug","exception","table","parseInt","RegExp","$1","chrome","local","localStorage","localstorage","colors","formatters","JSON","stringify","err","message","enable","browser","three_1","IE_ADJUSTMENT","OLD_IE_ADJUSTMENT","MAX_FIREFOX_WHEELDELTA","lowPassY","LOW_PASS_U0","LOW_PASS_U1","LOW_PASS_U2","LOW_PASS_U3","firefox","deltaX","deltaY","sign","unshift","pop","Vector2","msie","version","wheelDeltaX","wheelDeltaY","wheelDelta","detail","msedge","multiplyScalar","relative","mouseX","mouseY","eventX","eventY","nativeEvent","pageX","pageY","clientX","clientY","body","scrollLeft","scrollTop","offsetParent","offsetLeft","offsetTop","UID","CUID","colorUID","uid_1","ObservableMonitoring","setObservableMonitor","enabled","gatherIds","observableIds","getObservableMonitorIds","clear","observableNamesToUID","propertyUID","newVal","observer","instanceUpdated","label_atlas_resource_1","toInstanceIOValue","AtlasResourceManager","targetAtlas","requestQueue","requestLookup","atlasManager","dequeueRequests","didDequeue","resources","requests","this_1","updateAtlas","atlasRequests_1","request","delete","request_1","from","entries","atlasRequests","existingRequests","filterQuery","queryValues","filtered","obj","Quadrants","mid","TL","Node","TR","BL","BR","children","nodes","child","doAdd","cover","childrenProps","MAX_VALUE","allChildren","gatherChildren","split","isNaN","area","list","visit","queryBounds","queryPoint","cb","finished","data_bounds_1","ref","scaleRatio","parse","num","parseFloat","reference","top_1","LayerMouseEvents","isOver","sceneViews","getSceneViewsUnderMouse","sceneViewByViewId","sceneView","viewItem","getMouseByViewId","viewMouseByViewId","handleInteraction","handleMouseClick","handleMouseDrag","callback","sceneViews_1","handleSceneView","flag","updateColorPickRange","allSceneViews","currentSceneViews","analyzeColorPickingRendering","pickingData","allColors","colorData","dataHeight","dataWidth","nearestColor","uniqueColors","pixelIndex","distance","row","dx","dy","testDistance","shader_templating_1","template_vars_1","make_instance_uniform_name_1","instanceRetrievalArrayFragment","VECTOR_COMPONENTS","sizeToType","1","2","3","4","9","16","99","orderByPriority","makeAutoEasingTiming","makeVectorSwizzle","join","makeUniformArrayDeclaration","totalBlocks","fragment","fill","Vector4","makeInstanceRetrievalArray","templateOptions","makeInstanceDestructuringArray","orderedAttributes","instanceAttributeDestructuring","uniformInstancingDestructuring","webgl_stat_1","instance_attribute_shader_name_1","uniform_instance_block_array_1","vertexShaderComposition","fragmentShaderComposition","instanceDestructuringArray","MAX_USE_PER_BLOCK","generateUniforms","injectionType","injectFragments","shaders","shaderInputMetrics","instancingInfo","metrics","instanceUniformBlockCount","count","calculateUniformBlockUseage","sortedInstanceAttributes","currentBlock","trueBlockIndex","blockUseage","innerBlockUseage","attributeSize","oldUseage","newUseage","innerUseage","instances","uniformMetrics","blockQualifierDedup","qualifiers","blockQualifiers","qualifierList","allQualifiers","declaration","makeInstanceUniformDeclaration","makeUniformInstanceDataOptions","generateInstanceDataLookupOptions","additionalOptions","generateVertexAttributes","methods","methodSizes","sizeType","generateEasingMethods","generateShaderInputs","generateVertexPicking","makePickingDestructuring","makeInstanceAttributeReferences","generateVertexShader","vertexShaderResults","generateFragmentShader","generateFragmentPickingMethod","images_1","labels_1","attribute_generation_1","color_picking_analysis_1","layer_mouse_events_1","generate_default_scene_1","generate_layer_geometry_1","generate_layer_material_1","generate_layer_model_1","inject_shader_io_1","mouse_event_manager_1","texture_1","atlas_resource_manager_1","DEFAULT_BACKGROUND_COLOR","Color","isCanvas","createLayer","layerClass","LayerSurface","AtlasManager","currentViewport","currentFrame","previousTime","isBufferingAtlas","scenes","willDisposeLayer","initLayer","frameIncrement","onViewReady","validLayers","erroredLayers","pickingPass","errors","passed","stack","initializer","resourceManager","renderer","pickingRenderer","LabelInstance","ImageInstance","drawSceneView","updateColorPick","defaultSceneElements","flags","clearFlags","COLOR","DEPTH","pickingTarget","Uint8Array","pickWidth","readRenderTargetPixels","pickHeight","colorPicking","didBuffer","rendererSize","getSize","getPixelRatio","background","SCISSOR_TEST","scissor","clearColor","setSize","setRenderTarget","STENCIL","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","setViewport","getViewSize","getViewWorldBounds","topLeft","bottomRight","init","setContext","initGL","initMouseManager","initResources","WebGLRenderer","alpha","antialias","preserveDrawingBuffer","autoClear","setRendererSize","setPixelRatio","setClearColor","sceneViewDepth","sceneOptions","newScene","viewOptions","newView","addLayerToScene","shaderMetrics","eventManagers","atlasResources","createAtlas","layerInitializers","existingLayer","layerId","fitContainer","parentElement","className","setAttribute","containerBox","getBoundingClientRect","box","isWebGLContext","canvasContext","isString","getElementById","WebGLRenderTarget","magFilter","LinearFilter","minFilter","stencilBuffer","primitives_1","layer_1","RingLayer","ring","radius","scaleFactor","vertexToNormal","0","5","vertexToSide","thickness","_","vertex","CommonMaterialOptions","transparentShape","instance_provider_1","RingInstance","anchorCalculator","TopLeft","anchor","rectangle","padding","TopMiddle","TopRight","MiddleLeft","Middle","MiddleRight","BottomLeft","BottomMiddle","BottomRight","Custom","RectangleInstance","scaling","BOUND_MAX","_anchor","setAnchor","newAnchor","types_2","RectangleLayer","anchorEffect","projection","maxScale","minScale","ALWAYS","NEVER","screenPoint","u","instance_1","rasterizationLookUp","_cssFont","_fontFamily","_fontSize","_fontStyle","_fontWeight","_maxWidth","_text","_width","_height","_isDestroyed","fontStyle","cssFontLookup","rasterizations","references","_rasterization","LabelLayer","transparentImage","ImageRasterizer","calculateImageSize","atlas_1","color_atlas_resource_1","color_rasterizer_1","image_atlas_resource_1","label_rasterizer_1","ZERO_IMAGE","allAtlas","destroyAtlas","atlasName","setDefaultImage","loadImage","loadedImage","isValidImage","rect","dimensions","first","second","insertedNode","insert","nodeImage","ux","nodeDimensions","uy","uw","uh","onePixelX","atlasDimensions","imageSrc","subTexture","image_1","reject","onload","onerror","path","toDataURL","Image","src","resources_1","isLeaf","child0","child1","hasChild","newNode","fitFlag","imgWidth","imgHeight","dWidth","dHeight","removed","tint","_sourceWidth","_sourceHeight","_element","_path","aspect","ImageLayer","EdgeInstance","colorStart","colorEnd","control","widthStart","widthEnd","setEdgeWidth","setColor","interpolation","LINE","p1","p2","c1","c2","BEZIER","BEZIER2","toPointObject","toPointArray","TEST_RESOLUTION","edgePicking","broadphase","minPickDistance","scaleType","interpolate","edge","edgeWidthStart","edgeWidthEnd","PASS_X","PASS_Y","SCREEN_CURVE","closestIndex","closestDistance","secondClosestIndex","secondClosestDistance","control1","control2","startPoint","endPoint","linePoint","lineWidth","startSegment","endSegment","vector","lineDirection","lineNormal","distanceTo","edge_picking_1","pickVS","baseVS","screenVS","edgeFS","EdgeLayer","animate","_c","_d","animateEnd","animateStart","animateColorStart","animateColorEnd","animateControl","MAX_SEGMENTS","_e","vertexInterpolation","_f","InstanceProvider","CircleInstance","isMouseOver","isMouseDown","getColorPickInstance","isColorProcessor","onMouseDown","hitTest_1","query_1","world_1","querySpace","check","bind","instanceForColor","onMouseOut","hitTest_2","query_2","world_2","onMouseUp","hitTest_3","query_3","world_3","onMouseOver","onMouseMove","hitTest_4","query_4","info","world_4","notOverInstances","isCurrentlyOver_1","noLongerOver","onMouseClick","hitTest_5","query_5","world_5","UniformQuadDiffProcessor","quadPicking","UniformColorDiffProcessor","DiffMode","base_diff_processor_1","InstanceAttributeDiffProcessor","diffMode","PARTIAL","bufferAttributeUpdateRange","bufferAttributeWillUpdate","updateInstancePartial","newBufferLocations","propIds","updateValue","updateRange","childLocations","propertyToLocation","getUpdateAllPropertyIdList","getActiveAttributePropertyId","updateInstanceFull","updates","bufferAttribute","getInstanceCount","FULL","buffers","availableClusters","instanceToCluster","clusterToBuffer","makeNewBuffer","cluster","maxUniformBlock","uniformBlocksPerInstance","pickModel","setScene","newGeometry","drawRange","newMaterial","clone","newModel","activeInstances","clusters","firstInstance","lastInstance","uniformIndex","uniformName","fakeAttribute","InstancedBufferAttribute","instanceIndex","toEmit","emitOnce","emit","clearTimeout","flushEmitOnce","emit_once_1","allBufferLocations","availableLocations","currentInstancedCount","instanceToBufferLocation","growthCount","maxInstancedCount","attributeToPropertyIds","updateAllPropertyIdList","activePropertyId","doAddWithRegistration","propertyIdsForAttribute","makeUpdateAllPropertyIdList","locationInfo","resizeBuffer","gatherLocationsIntoGroups","newLocations","growth","shift","ids","attributeToNewBufferLocations","InstancedBufferGeometry","previousInstanceAmount_1","array","newAttribute","setDynamic","allLocations","newLocation","internalAttribute","totalNewInstances","attributesBufferLocations","bufferLocationsForAttribute","childBufferLocations","group","bufferLocation","childAttribute","bufferLocationsForChildAttribute","childBufferLocation","instance_attribute_diff_processor_1","uniform_color_diff_processor_1","uniform_diff_processor_1","uniform_quad_diff_processor_1","squareDistance","Point","getClosest","testPoint","points","closestPoint","getClosestIndex","amount","normalize","magnitude","getDistance","squared","getMidpoint","make","cleanObservation","instanceChanges","allowChanges","disposer","observableDisposer","INSERT","CHANGE","REMOVE","CircleLayer","circle","circleScreenCenter","mouseScreen","animations","animateCenter","center","animateRadius","animateColor","fadeOutOversized","premultipliedAlpha","transparent","blending","CustomBlending","blendSrc","OneFactor","getBounds","childToNode","childToBounds","nullBounded","fromSplit","doRemove","found","node","ReferenceCamera","offsetFilter","scaleFilter","base","h","plural","ms","str","String","exec","long","fmtLong","fmtShort","createDebug","prevTime","self","curr","prev","coerce","format","formatter","hash","charCodeAt","selectColor","disable","names","skips","len","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","noop","nextTick","title","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","isNumber","AnimationHelper","groupAnimation","groupCount","baseDelay","delayGap","modifyInstances","startFrameTime","gap","CameraBoundsAnchor","event_manager_1","BasicCameraController","isPanning","panFilter","allViews","startViews","onRangeChanged","targetView","startViewDidStart","applyBounds","applyScaleBounds","boundsHorizontalOffset","boundsVerticalOffset","scaleMin","scaleMax","setBounds","ignoreCoverViews","anchoredByBoundsHorizontal","TOP_LEFT","MIDDLE_LEFT","BOTTOM_LEFT","worldBounds","screenPadding","TOP_MIDDLE","MIDDLE","BOTTOM_MIDDLE","TOP_RIGHT","MIDDLE_RIGHT","BOTTOM_RIGHT","anchoredByBoundsVertical","worldTLinScreenSpace","worldBRinScreenSpace","canStart","findCoveredStartView","under","coveredStartView","getTargetView","pan","wheelMetrics","beforeZoom","currentZoomX","currentZoomY","afterZoom","getRange","setRange","newWorld","deltaScale","deltaPan"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"three\"), require(\"bowser\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"three\", \"bowser\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"voidgl\"] = factory(require(\"three\"), require(\"bowser\"));\n\telse\n\t\troot[\"voidgl\"] = factory(root[\"three\"], root[\"bowser\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__1__, __WEBPACK_EXTERNAL_MODULE__124__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 129);\n","import * as Three from 'three';\nimport { Instance } from './instance-provider/instance';\nimport { Bounds } from './primitives/bounds';\nimport { IPoint } from './primitives/point';\nimport { ChartCamera, Vec, Vec2 } from './util';\nimport { IAutoEasingMethod } from './util/auto-easing-method';\nimport { IVisitFunction, TrackedQuadTree } from './util/tracked-quad-tree';\n\nexport type Diff<T extends string, U extends string> = ({ [P in T]: P } &\n  { [P in U]: never } & { [x: string]: never })[T];\nexport type Omit<T, K extends keyof T> = { [P in Diff<keyof T, K>]: T[P] };\nexport type ShaderIOValue =\n  | [number]\n  | [number, number]\n  | [number, number, number]\n  | [number, number, number, number]\n  | Three.Vector4[]\n  | Float32Array;\nexport type InstanceIOValue =\n  | [number]\n  | [number, number]\n  | [number, number, number]\n  | [number, number, number, number];\nexport type UniformIOValue =\n  | number\n  | InstanceIOValue\n  | Float32Array\n  | Three.Texture;\n\nexport enum InstanceBlockIndex {\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4,\n}\n\nexport enum InstanceAttributeSize {\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4,\n  /** Special case for making instance attributes that can target Atlas resources */\n  ATLAS = 99,\n}\n\nexport const instanceAttributeSizeFloatCount: { [key: number]: number } = {\n  [InstanceAttributeSize.ONE]: 1,\n  [InstanceAttributeSize.TWO]: 2,\n  [InstanceAttributeSize.THREE]: 3,\n  [InstanceAttributeSize.FOUR]: 4,\n  [InstanceAttributeSize.ATLAS]: 4,\n};\n\nexport enum UniformSize {\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4,\n  MATRIX3 = 9,\n  MATRIX4 = 16,\n  ATLAS = 99,\n}\n\nexport enum VertexAttributeSize {\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4,\n}\n\n/**\n * This represents a color in the VoidGL system. Ranges are [0 - 1, 0 - 1, 0 - 1, 0 - 1]\n */\nexport type Color = [number, number, number, number];\n\n/**\n * Represents something with a unique id\n */\nexport interface Identifiable {\n  /** A unique identifier */\n  id: string;\n}\n\n/**\n * Information provided in mouse events interacting with instances and\n * layers.\n */\nexport interface IPickInfo<T extends Instance> {\n  /** If a mouse button is involved in the pick, this will be populated */\n  button?: number;\n  /** This is the parent layer id of the instances interacted with */\n  layer: string;\n  /** This is the list of instances that were detected in the interaction */\n  instances: T[];\n  /** If picking is set to ALL then this will be provided which can be used to make additional spatial queries */\n  querySpace?(bounds: Bounds | IPoint, visit?: IVisitFunction<T>): T[];\n  /** This is the screen coordinates of the mouse point that interacted with the instances */\n  screen: [number, number];\n  /** This is the world coordinates of the mouse point that interacted with the instances */\n  world: [number, number];\n  /** Projection methods to easily go between coordinate spaces */\n  projection: IProjection;\n}\n\nexport interface IVertexAttribute {\n  /**\n   * When initWithBuffer and customFill are not specified, this is was the system will initially\n   * load each vertex attribute with.\n   */\n  defaults?: number[];\n  /**\n   * When this is specified it will initialize the model's attribute with the data in this buffer.\n   */\n  initWithBuffer?: Float32Array;\n  /**\n   * When generating this attribute in the shader this will be the prefix to the attribute:\n   * For instance, if you specify 'highp' as the modifier, then the attribute that appears\n   * in the shader will be:\n   * attribute highp vec3 position;\n   */\n  qualifier?: string;\n  /**\n   * This is the name the attribute will be for the model.\n   */\n  name: string;\n  /**\n   * This is the number of floats the attribute will consume. For now, we only allow for up\n   * to four floats per attribute.\n   */\n  size: VertexAttributeSize;\n  /**\n   * This lets you populate the buffer with an automatically called method. This will fire when\n   * necessary updates are detected or on initialization.\n   */\n  update(vertex: number): ShaderIOValue;\n}\n\nexport interface IVertexAttributeInternal extends IVertexAttribute {\n  /** This is the actual attribute generated internally for the ThreeJS interfacing */\n  materialAttribute: Three.BufferAttribute | null;\n}\n\nexport interface IInstanceAttribute<T extends Instance> {\n  /**\n   * If this is specified, this attribute becomes a size of 4 and will have a block index of\n   * 0. This makes this attribute and layer become compatible with reading atlas resources.\n   * The value provided for this property should be the name of the atlas that is created.\n   */\n  atlas?: {\n    /** Specify which generated atlas to target for the resource */\n    key: string;\n    /** Specify the name that will be injected that will be the sampler2D in the shader */\n    name: string;\n    /**\n     * This specifies which of the shaders the sampler2D will be injected into.\n     * Defaults to the Fragment shader only.\n     */\n    shaderInjection?: ShaderInjectionTarget;\n  };\n  /**\n   * This is a block index helping describe the instancing process. It can be any number as\n   * the system will sort and organize them for you. This only helps the system detect when\n   * you cram too much info into a single block. The tighter you pack your blocks the better\n   * your program will perform.\n   */\n  block: number;\n  /**\n   * This is the index within the block this attribute will be available.\n   */\n  blockIndex?: InstanceBlockIndex;\n  /**\n   * If the settings on this attrubute spawns additional attributes, those attributes shall\n   * be populated here. Otherwise this remains undefined.\n   */\n  childAttributes?: IInstanceAttribute<T>[];\n  /**\n   * When this is set, the system will automatically inject necessary Shader IO to facilitate\n   * performing the easing on the GPU, which saves enormous amounts of CPU processing time\n   * trying to calcuate animations and tweens for properties.\n   *\n   * NOTE: Setting this increases the amount of data per instance by: size * 2 + ;\n   * as it injects in a start value, start time, and duration\n   */\n  easing?: IAutoEasingMethod<Vec>;\n  /**\n   * This is the name that will be available in your shader for use. This will only be\n   * available after the ${attributes} declaration.\n   */\n  name: string;\n  /**\n   * If this attribute is created automatically by the system based on the settings of another\n   * attribute, that parent attribute will be set here. Otherwise this remains undefined.\n   */\n  parentAttribute?: IInstanceAttribute<T>;\n  /**\n   * When generating this attribute in the shader this will be the prefix to the attribute:\n   * For instance, if you specify 'highp' as the modifier, then the attribute that appears\n   * in the shader will be:\n   * attribute highp vec3 position;\n   */\n  qualifier?: string;\n  /**\n   * This is how many floats the instance attribute takes up. Due to how instancing is\n   * implemented, we can only take up to 4 floats per variable right now.\n   */\n  size?: InstanceAttributeSize;\n  /**\n   * This is the accessor that executes when the instance needs updating. Simply return the\n   * value that should be populated for this attribute.\n   */\n  update(instance: T): InstanceIOValue;\n}\n\n/**\n * Internal Instance Attributes are ones that actually map to an attribute in the shader and use\n * hardware instancing.\n */\nexport interface IInstanceAttributeInternal<T extends Instance>\n  extends IInstanceAttribute<T> {\n  /** We will keep an internal uid for the  */\n  uid: number;\n  /** This is the actual attribute mapped to a buffer */\n  bufferAttribute: Three.InstancedBufferAttribute;\n}\n\n/**\n * This is an attribute where the atlas is definitely declared.\n */\nexport interface IAtlasInstanceAttribute<T extends Instance>\n  extends IInstanceAttribute<T> {\n  /**\n   * If this is specified, this attribute becomes a size of 4 and will have a block index of\n   * 0. This makes this attribute and layer become compatible with reading atlas resources.\n   * The value provided for this property should be the name of the atlas that is created.\n   */\n  atlas: {\n    /** Specify which generated atlas to target for the resource */\n    key: string;\n    /** Specify the name that will be injected that will be the sampler2D in the shader */\n    name: string;\n    /**\n     * This specifies which of the shaders the sampler2D will be injected into.\n     * Defaults to the Fragment shader only.\n     */\n    shaderInjection?: ShaderInjectionTarget;\n  };\n}\n\n/**\n * This is an attribute that is simply a value\n */\nexport interface IEasingInstanceAttribute<T extends Instance>\n  extends IInstanceAttribute<T> {\n  /**\n   * This MUST be defined to be an Easing attribute\n   */\n  easing: IAutoEasingMethod<Vec>;\n  /**\n   * Easing attributes requires size to be present\n   */\n  size: InstanceAttributeSize;\n}\n\n/**\n * This is an attribute that is simply a value\n */\nexport interface IValueInstanceAttribute<T extends Instance>\n  extends IInstanceAttribute<T> {\n  /**\n   * If this is specified, this attribute becomes a size of 4 and will have a block index of\n   * 0. This makes this attribute and layer become compatible with reading atlas resources.\n   * The value provided for this property should be the name of the atlas that is created.\n   */\n  atlas: undefined;\n}\n\n/** These are flags for indicating which shaders receive certain injection elements */\nexport enum ShaderInjectionTarget {\n  /** ONLY the vertex shader will receive the injection */\n  VERTEX = 1,\n  /** ONLY the fragment shader will receive the injection */\n  FRAGMENT = 2,\n  /** Both the fragment and vertex shader will receive the injection */\n  ALL = 3,\n}\n\nexport interface IUniform {\n  /**\n   * This lets you specify which of the shaders will receive this uniform as available.\n   * This defaults to only injecting into the vertex shader.\n   */\n  shaderInjection?: ShaderInjectionTarget;\n  /** Name of the uniform as will be available in the shaders */\n  name: string;\n  /** How many floats the uniform shall encompass */\n  size: UniformSize;\n  /**\n   * When generating this uniform in the shader this will be the prefix to the uniform:\n   * For instance, if you specify 'highp' as the modifier, then the uniform that appears\n   * in the shader will be:\n   * uniform highp vec3 position;\n   */\n  qualifier?: string;\n  /**\n   * This is the accessor that executes every frame before this layer is drawn. It gives\n   * opportunity to update the uniform's value before every draw.\n   */\n  update(uniform: IUniform): UniformIOValue;\n}\n\nexport interface IUniformInternal extends IUniform {\n  /**\n   * All layers will have many many ShaderMaterials generated per each instance buffer as a single buffer\n   * can only render so many instances. This tracks across all generated ShaderMaterials for each buffer\n   * the material uniforms that need to be updated as a Uniform for a layer is dictated as uniform across\n   * all instances.\n   */\n  materialUniforms: Three.IUniform[];\n}\n\n/**\n * This is the structure of a uniform generated for the sake of instancing\n */\nexport interface IInstancingUniform {\n  name: string;\n  type: 'f' | 'v2' | 'v3' | 'v4' | '4fv' | 'bvec4';\n  value: ShaderIOValue;\n}\n\n/**\n * Represents a complete shader object set.\n */\nexport interface IShaders {\n  fs: string;\n  header?: string;\n  vs: string;\n}\n\n/**\n * Represents an element that has a full list of projection methods\n */\nexport interface IProjection {\n  /** This is the chart camera utilized in the projection of elements */\n  camera: ChartCamera;\n  /** Converts from the pixel density layer to the screen space */\n  pixelSpaceToScreen(point: IPoint, out?: IPoint): IPoint;\n  /** Converts from the screen coordinates to the pixel density layer */\n  screenToPixelSpace(point: IPoint, out?: IPoint): IPoint;\n  /** Converts from screen space to the view's relative coordinates */\n  screenToView(point: IPoint, out?: IPoint): IPoint;\n  /** Converts from screen space to the world space of a scene */\n  screenToWorld(point: IPoint, out?: IPoint): IPoint;\n  /** Converts from a view's space to the screen */\n  viewToScreen(point: IPoint, out?: IPoint): IPoint;\n  /** Converts from a views space to the world coordinates */\n  viewToWorld(point: IPoint, out?: IPoint): IPoint;\n  /** Converts from world coordinate space of a scene to the screen */\n  worldToScreen(point: IPoint, out?: IPoint): IPoint;\n  /** Converts from world coordinate space of a scene to the view's space */\n  worldToView(point: IPoint, out?: IPoint): IPoint;\n}\n\nexport type IMaterialOptions = Partial<\n  Omit<\n    Omit<Omit<Three.ShaderMaterialParameters, 'uniforms'>, 'vertexShader'>,\n    'fragmentShader'\n  >\n>;\n\n/** This is the method signature for determining whether or not a point hits an instance */\nexport type InstanceHitTest<T> = (o: T, p: IPoint, v: IProjection) => boolean;\n\n/**\n * This is the type of picking assigned to a layer. Each mode has performance and functionality\n * tradeoffs.\n */\nexport enum PickType {\n  /** Disable any picking methodology */\n  NONE,\n  /** Pick all instances found underneath the mouse. The Layer must explicitly support this feature. */\n  ALL,\n  /**\n   * NOTE: NOT IMPLEMENTED YET\n   *\n   * Uses highly efficient color rendering method to detect an instance on a pixel by pixel check. Since it is\n   * based on rendering, it will only select the 'visually' top most rendered instance. This means instances can be occluded\n   * by other instances is an instance renders behind another.\n   *\n   * This is vastly more efficient and accurate than ALL. This also will be more readily supported than ALL.\n   */\n  SINGLE,\n}\n\n/**\n * This represents the settings and objects used to facilitate picking in a layer.\n */\nexport interface IPickingMetrics {\n  /** This is the current pick mode that is active during the draw pass of the layer */\n  currentPickMode: PickType;\n  /** This is the picking style to be used */\n  type: PickType;\n}\n\n/**\n * This is the picking settings and objects to facilitate PickType.ALL so we can get\n * all instances underneath the mouse.\n */\nexport interface IQuadTreePickingMetrics<T extends Instance>\n  extends IPickingMetrics {\n  /** This handles the ALL type only */\n  type: PickType.ALL;\n  /** This stores all of our instances in a quad tree to spatially track our instances */\n  quadTree: TrackedQuadTree<T>;\n  /** This is the method for performing a hit test with the provided instance */\n  hitTest: InstanceHitTest<T>;\n}\n\n/**\n * This is the picking settings and objects to facilitate PickType.SINGLE so we can get\n * a single instance underneath the mouse.\n */\nexport interface ISinglePickingMetrics<T extends Instance>\n  extends IPickingMetrics {\n  /** Set the enum for the type */\n  type: PickType.SINGLE;\n  /**\n   * This is a lookup of the instance by it's UID which is all that is needed to decode a color to an instance\n   * The color UINT8 components composited into a single UINT32 IS the UID of the instance\n   */\n  uidToInstance: Map<number, T>;\n}\n\n/**\n * This is the picking settings and objects to facilitate PickType.NONE where no information\n * is retrieved for mouse interactions.\n */\nexport interface INonePickingMetrics extends IPickingMetrics {\n  // Single Picking does not require any special helper information\n  type: PickType.NONE;\n}\n\nexport interface IColorPickingData {\n  /** The mouse target position where the data is rendered */\n  mouse: Vec2;\n  /** The color data loaded for last picking rendering */\n  colorData: Uint8Array;\n  /** The height of the data array */\n  dataHeight: number;\n  /** The width of the data array */\n  dataWidth: number;\n  /** The nearest found color */\n  nearestColor: number;\n  /** All colors in the data */\n  allColors: number[];\n}\n\n/**\n * Diff types that an instance can go through. Used to help the system consume the diff\n * and apply it to the GL framework.\n */\nexport enum InstanceDiffType {\n  CHANGE = 0,\n  INSERT = 1,\n  REMOVE = 2,\n}\n\n/**\n * This is the metrics associated with a frame. Mostly dealing with timing values.\n */\nexport type FrameMetrics = {\n  /** The frame number rendered. Increases by 1 every surface draw */\n  currentFrame: number;\n  /** The start time of the current frame */\n  currentTime: number;\n  /** The start time of the previous frame */\n  previousTime: number;\n};\n\n/**\n * This is the minimum properties required to make all easing functions operate.\n */\nexport interface IEasingProps {\n  start: Vec;\n  end: Vec;\n  startTime: number;\n  duration: number;\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","export * from './animation-helper';\nexport * from './auto-easing-method';\nexport * from './chart-camera';\nexport * from '../instance-provider/instance';\nexport * from './mouse';\nexport * from './reference-camera';\nexport * from './shader-templating';\nexport * from './tracked-quad-tree';\nexport * from './uid';\nexport * from './vector';\nexport * from './view-camera';\nexport * from './webgl-stat';\nexport * from './common-options';\n","export * from './observable';\nexport * from './instance-provider';\nexport * from './instance';\n","import { IPoint } from './point';\n\nexport interface IBoundsOptions {\n  /** Top left x position */\n  x?: number;\n  /** Top left y position */\n  y?: number;\n  /** Width covered */\n  width?: number;\n  /** height covered */\n  height?: number;\n\n  /** Specify the left */\n  left?: number;\n  /** Specify the right */\n  right?: number;\n  /** Specify the top */\n  top?: number;\n  /** Specify the bottom */\n  bottom?: number;\n}\n\n/**\n * Class to manage the x, y, width, and height of an object\n *\n * @template T This specifies the data type associated with this shape and is accessible\n *             via the property 'd'\n */\nexport class Bounds {\n  x: number = 0;\n  y: number = 0;\n  width: number = 0;\n  height: number = 0;\n\n  get area() {\n    return this.width * this.height;\n  }\n\n  get bottom() {\n    return this.y + this.height;\n  }\n\n  get left() {\n    return this.x;\n  }\n\n  get mid() {\n    return {\n      x: this.x + this.width / 2.0,\n      y: this.y + this.height / 2.0,\n    };\n  }\n\n  get right() {\n    return this.x + this.width;\n  }\n\n  get top() {\n    return this.y;\n  }\n\n  static emptyBounds() {\n    return new Bounds({\n      height: 0,\n      width: 0,\n      x: 0,\n      y: 0,\n    });\n  }\n\n  /**\n   * Create a new instance\n   *\n   * @param left  The left side (x coordinate) of the instance\n   * @param right The right side of the instance\n   * @param top The top (y coordinate) of the instance\n   * @param bottom The bottom of the instance\n   */\n  constructor(options: IBoundsOptions) {\n    this.x = options.x || options.left || 0;\n    this.y = options.y || options.top || 0;\n    this.height = options.height || (options.bottom || 0) - this.y || 0;\n    this.width = options.width || (options.right || 0) - this.x || 0;\n  }\n\n  /**\n   * Checks to see if a point is within this bounds object.\n   *\n   * @param point\n   */\n  containsPoint(point: IPoint) {\n    return !(\n      point.x < this.x ||\n      point.y < this.y ||\n      point.x > this.right ||\n      point.y > this.bottom\n    );\n  }\n\n  /**\n   * Grows this bounds object to cover the space of the provided bounds object\n   *\n   * @param item\n   */\n  encapsulate(item: Bounds | IPoint) {\n    if (item instanceof Bounds) {\n      if (item.x < this.x) {\n        this.width += Math.abs(item.x - this.x);\n        this.x = item.x;\n      }\n\n      if (item.y < this.y) {\n        this.height += Math.abs(item.y - this.y);\n        this.y = item.y;\n      }\n\n      if (this.right < item.right) {\n        this.width += item.right - this.right;\n      }\n\n      if (this.bottom < item.bottom) {\n        this.height += item.bottom - this.bottom;\n      }\n\n      return true;\n    } else {\n      if (item.x < this.x) {\n        this.width += this.x - item.x;\n        this.x = item.x;\n      }\n\n      if (item.x > this.right) {\n        this.width += item.x - this.x;\n      }\n\n      if (item.y < this.y) {\n        this.height += this.y - item.y;\n        this.y = item.y;\n      }\n\n      if (item.y > this.bottom) {\n        this.height += item.y - this.y;\n      }\n\n      return true;\n    }\n  }\n\n  /**\n   * Checks to see if the provided bounds object could fit within the dimensions of this bounds object\n   * This ignores position and just checks width and height.\n   *\n   * @param bounds\n   *\n   * @return {number} 0 if it doesn't fit. 1 if it fits perfectly. 2 if it just fits.\n   */\n  fits(bounds: Bounds): 0 | 1 | 2 {\n    // If the same, the bounds fits exactly into this bounds\n    if (this.width === bounds.width && this.height === bounds.height) {\n      return 1;\n    }\n\n    // The bounds can fit within this, then it just fits\n    if (this.width >= bounds.width && this.height >= bounds.height) {\n      return 2;\n    }\n\n    // Otherwise, the bounds does not fit within this bounds\n    return 0;\n  }\n\n  /**\n   * Checks if a bounds object intersects another bounds object.\n   *\n   * @param bounds\n   */\n  hitBounds(bounds: Bounds) {\n    return !(\n      this.right < bounds.x ||\n      this.x > bounds.right ||\n      this.bottom < bounds.y ||\n      this.y > bounds.height\n    );\n  }\n\n  /**\n   * Sees if the provided bounds is completely within this bounds object. Unlike fits() this takes\n   * position into account.\n   *\n   * @param bounds\n   */\n  isInside(bounds: Bounds): boolean {\n    return (\n      this.x >= bounds.x &&\n      this.right <= bounds.right &&\n      this.y >= bounds.y &&\n      this.bottom <= bounds.bottom\n    );\n  }\n\n  /**\n   * Easy readout of this Bounds object.\n   */\n  toString() {\n    return `{x: ${this.x} y:${this.y} w:${this.width} h:${this.height}}`;\n  }\n}\n","export enum AnchorType {\n  BottomLeft,\n  BottomMiddle,\n  BottomRight,\n  Custom,\n  Middle,\n  MiddleLeft,\n  MiddleRight,\n  TopLeft,\n  TopMiddle,\n  TopRight,\n}\n\nexport type Anchor = {\n  /** When the anchor gets calculated on the image, this allows the anchor to go beyond the borders of the image by this amount */\n  padding: number;\n  /** This is the location of the anchor. If a custom anchor is specified, then the x and y are not automatically populated */\n  type: AnchorType;\n  /** This is populated with the anchor's location relative to the image's surface */\n  x?: number;\n  /** This is populated with the anchor's location relative to the image's surface */\n  y?: number;\n};\n\nexport enum ScaleType {\n  /** The size of the image will be tied to world space */\n  ALWAYS = 1,\n  /** The image will scale to it's font size then stop growing */\n  BOUND_MAX = 2,\n  /** The image will alwyas retain it's font size on screen */\n  NEVER = 3,\n}\n","import { Instance } from '../../instance-provider/instance';\nimport { IInstanceAttributeInternal } from '../../types';\nimport { Vec2 } from '../../util';\nimport { Layer } from '../layer';\nimport { Scene } from '../scene';\n\nexport function isBufferLocation(val: any): val is IBufferLocation {\n  return val && val.buffer && val.buffer.value;\n}\n\nexport function isBufferLocationGroup(\n  val: any,\n): val is IBufferLocationGroup<IBufferLocation> {\n  return val && val.propertyToBufferLocation;\n}\n\n/**\n * This defines a base information object that explains where in a buffer a value\n * is represented.\n */\nexport interface IBufferLocation {\n  /** This is the parent attribute of this location */\n  attribute: IInstanceAttributeInternal<Instance>;\n  /**\n   * This is the generic buffer object interface for accessing the actual buffer.\n   */\n  buffer: {\n    value: Float32Array | Uint8Array;\n  };\n  /**\n   * If the attribute has child attributes (attributes auto generated as a consequence of the attributes settings)\n   * then the children's buffer locations can be found here.\n   */\n  childLocations?: IBufferLocation[];\n  /**\n   * This is the instance index indicative of the instance positioning within the buffer.\n   * Keep in mind: This does NOT correlate to a lookup for an Instance object but rather for\n   * the instancing concept designed for GL Buffers.\n   */\n  instanceIndex: number;\n  /**\n   * This is the range within the buffer values should be injected for this location.\n   */\n  range: Vec2;\n}\n\n/**\n * Each instance that comes in can be associated with a group of buffer locations. A buffer location for each\n * instance attribute used in updates. So a grouping is several buffer locations that are keyed by\n * the instance's property's UIDs.\n */\nexport interface IBufferLocationGroup<T extends IBufferLocation> {\n  /** This is the instance index WITHIN THE BUFFERS. This does NOT have relevance to Instance type objects */\n  instanceIndex: number;\n  /** This is a map of property UIDs to an associated buffer location */\n  propertyToBufferLocation: { [key: number]: T };\n}\n\n/**\n * Layers manage instances and those instances require a form of binding to their associated buffers.\n * The buffers have to be intelligently created and managed in this tieing to maximize performance.\n * One can not have a buffer for every instance in most cases, so the buffer manager has to get instances\n * to cooperate sharing a buffer in whatever strategy possible that best suits the hardware and it's limitations.\n *\n * This provides a uniform interface between instances and their corresponding buffer.\n */\nexport abstract class BufferManagerBase<\n  T extends Instance,\n  U extends IBufferLocation\n> {\n  /** The layer this manager glues Instances to Buffers */\n  layer: Layer<T, any>;\n  /** The scene the layer is injecting elements into */\n  scene: Scene;\n\n  /**\n   * Base constructor. A manager always needs to be associated with it's layer and it's scene.\n   */\n  constructor(layer: Layer<T, any>, scene: Scene) {\n    this.layer = layer;\n    this.scene = scene;\n  }\n\n  /**\n   * Destroy all elements that consume GPU resources or consumes otherwise unreleaseable resources.\n   */\n  abstract destroy(): void;\n\n  /**\n   * This adds an instance to the manager and thus ties the instance to an IBuffer location\n   */\n  add: (instance: T) => U | IBufferLocationGroup<U> | undefined;\n\n  /**\n   * Retrieves the buffer locations for the instance provided\n   */\n  abstract getBufferLocations(\n    instance: T,\n  ): U | IBufferLocationGroup<U> | undefined;\n\n  /**\n   * This retrieves the property ID for the active attribute. This is necessary to prevent\n   * the need for lookups to find the active attribute.\n   */\n  abstract getActiveAttributePropertyId(): number;\n\n  /**\n   * This returns how many instances this buffer manager has grown to accommodate.\n   */\n  abstract getInstanceCount(): number;\n\n  /**\n   * This should provide a minimum property id list that represents a set of properties that if triggered\n   * for update, would cause all of the attributes to be updated for the layer.\n   */\n  abstract getUpdateAllPropertyIdList(): number[];\n\n  /**\n   * Disassociates an instance with it's buffer location and makes the instance\n   * in the buffer no longer drawable.\n   */\n  remove: (instance: T) => T;\n\n  /**\n   * Removes the manager from the scene it applied itself to.\n   */\n  abstract removeFromScene(): void;\n}\n","import * as Three from 'three';\nimport { InstanceDiff } from '../instance-provider';\nimport { Instance } from '../instance-provider/instance';\nimport {\n  IInstanceAttribute,\n  IMaterialOptions,\n  INonePickingMetrics,\n  InstanceAttributeSize,\n  InstanceBlockIndex,\n  InstanceDiffType,\n  InstanceHitTest,\n  InstanceIOValue,\n  IPickInfo,\n  IQuadTreePickingMetrics,\n  IShaders,\n  ISinglePickingMetrics,\n  IUniform,\n  IUniformInternal,\n  IVertexAttribute,\n  IVertexAttributeInternal,\n  PickType,\n  ShaderInjectionTarget,\n  UniformIOValue,\n  UniformSize,\n} from '../types';\nimport { BoundsAccessor, TrackedQuadTree } from '../util';\nimport { IdentifyByKey, IdentifyByKeyOptions } from '../util/identify-by-key';\nimport { BufferManagerBase, IBufferLocation } from './buffer-management';\nimport { InstanceDiffManager } from './buffer-management/instance-diff-manager';\nimport { LayerInteractionHandler } from './layer-interaction-handler';\nimport { LayerBufferType } from './layer-processing/layer-buffer-type';\nimport { LayerInitializer, LayerSurface } from './layer-surface';\nimport { AtlasResourceManager } from './texture/atlas-resource-manager';\nimport { View } from './view';\n\nexport interface IShaderInputs<T extends Instance> {\n  /** These are very frequently changing attributes and are uniform across all vertices in the model */\n  instanceAttributes?: (IInstanceAttribute<T> | null)[];\n  /** These are attributes that should be static on a vertex. These are considered unique per vertex. */\n  vertexAttributes?: (IVertexAttribute | null)[];\n  /** Specify how many vertices there are per instance */\n  vertexCount: number;\n  /** These are uniforms in the shader. These are uniform across all vertices and all instances for this layer. */\n  uniforms?: (IUniform | null)[];\n}\n\nexport type IShaderInitialization<T extends Instance> = IShaderInputs<T> &\n  IShaders;\n\nexport interface IModelType {\n  /** This is the draw type of the model to be used */\n  drawMode?: Three.TrianglesDrawModes;\n  /** This is the THREE JS model type */\n  modelType: IModelConstructable;\n}\n\n/**\n * Bare minimum required features a provider must provide to be the data for the layer.\n */\nexport interface IInstanceProvider<T extends Instance> {\n  /** A list of changes to instances */\n  changeList: InstanceDiff<T>[];\n  /** Resolves the changes as consumed */\n  resolve(): void;\n}\n\n/**\n * Constructor options when generating a layer.\n */\nexport interface ILayerProps<T extends Instance> extends IdentifyByKeyOptions {\n  /** This is the data provider where the instancing data is injected and modified. */\n  data: IInstanceProvider<T>;\n  /**\n   * This sets how instances can be picked via the mouse. This activates the mouse events for the layer IFF\n   * the value is not NONE.\n   */\n  picking?: PickType;\n  /**\n   * Used for debugging. Logs the generated shader for the layer in the console.\n   */\n  printShader?: boolean;\n  /**\n   * This identifies the scene we want the layer to be a part of.\n   * Layer's with the same identifiers will render their buffers in the same scene.\n   * This only applies to the layer when the layer is initialized in a layer surface. You shouldn't\n   * be swapping layers from scene to scene.\n   *\n   * The scene identifier must be an identifier used when constructing the layer surface that this layer\n   * is added to.\n   */\n  scene?: string;\n\n  // ---- EVENTS ----\n  /** Executes when the mouse is down on instances and a picking type is set */\n  onMouseDown?(info: IPickInfo<T>): void;\n  /** Executes when the mouse moves on instances and a picking type is set */\n  onMouseMove?(info: IPickInfo<T>): void;\n  /** Executes when the mouse no longer over instances and a picking type is set */\n  onMouseOut?(info: IPickInfo<T>): void;\n  /** Executes when the mouse is newly over instances and a picking type is set */\n  onMouseOver?(info: IPickInfo<T>): void;\n  /** Executes when the mouse button is release when over instances and a picking type is set */\n  onMouseUp?(info: IPickInfo<T>): void;\n  /** Executes when the mouse click gesture is executed over instances and a picking type is set */\n  onMouseClick?(info: IPickInfo<T>): void;\n}\n\nexport interface IModelConstructable {\n  new (\n    geometry?: Three.Geometry | Three.BufferGeometry,\n    material?: Three.Material | Three.Material[],\n  ): any;\n}\n\nexport interface IPickingMethods<T extends Instance> {\n  /** This provides a way to calculate bounds of an Instance */\n  boundsAccessor: BoundsAccessor<T>;\n  /** This is the way the system tests hitting an intsance */\n  hitTest: InstanceHitTest<T>;\n}\n\n/**\n * A base class for generating drawable content\n */\nexport class Layer<\n  T extends Instance,\n  U extends ILayerProps<T>\n> extends IdentifyByKey {\n  static defaultProps: any = {};\n\n  /** This is the attribute that specifies the _active flag for an instance */\n  activeAttribute: IInstanceAttribute<T>;\n  /** This matches an instance to the list of Three uniforms that the instance is responsible for updating */\n  private _bufferManager: BufferManagerBase<T, IBufferLocation>;\n  /** Buffer manager is read only. Must use setBufferManager */\n  get bufferManager() {\n    return this._bufferManager;\n  }\n  /** This is the determined buffering strategy of the layer */\n  private _bufferType: LayerBufferType;\n  /** Buffer type is private and should not be directly modified */\n  get bufferType() {\n    return this._bufferType;\n  }\n  /** This determines the drawing order of the layer within it's scene */\n  depth: number = 0;\n  /** This is the threejs geometry filled with the vertex information */\n  geometry: Three.BufferGeometry;\n  /** This is the initializer used when making this layer. */\n  initializer: LayerInitializer;\n  /** This is all of the instance attributes generated for the layer */\n  instanceAttributes: IInstanceAttribute<T>[];\n  /** A lookup fo an instance by it's ID */\n  instanceById = new Map<string, T>();\n  /** Provides the number of vertices a single instance spans */\n  instanceVertexCount: number = 0;\n  /** This is the handler that manages interactions for the layer */\n  interactions: LayerInteractionHandler<T, U>;\n  /** The official shader material generated for the layer */\n  material: Three.RawShaderMaterial;\n  /** INTERNAL: For the given shader IO provided this is how many instances can be present per buffer. */\n  maxInstancesPerBuffer: number;\n  /** This is the mesh for the Threejs setup */\n  model: Three.Object3D;\n  /** This is all of the picking metrics kept for handling picking scenarios */\n  picking:\n    | IQuadTreePickingMetrics<T>\n    | ISinglePickingMetrics<T>\n    | INonePickingMetrics;\n  /** Properties handed to the Layer during a LayerSurface render */\n  props: U;\n  /** This is the system provided resource manager that lets a layer request Atlas resources */\n  resource: AtlasResourceManager;\n  /** This is the surface this layer is generated under */\n  surface: LayerSurface;\n  /** This is all of the uniforms generated for the layer */\n  uniforms: IUniformInternal[];\n  /** This is all of the vertex attributes generated for the layer */\n  vertexAttributes: IVertexAttributeInternal[];\n  /** This is the view the layer is applied to. The system sets this, modifying will only cause sorrow. */\n  view: View;\n\n  /** This contains the methods and controls for handling diffs for the layer */\n  diffManager: InstanceDiffManager<T>;\n\n  constructor(props: ILayerProps<T>) {\n    // We do not establish bounds in the layer. The surface manager will take care of that for us\n    // After associating the layer with the view it is a part of.\n    super(props);\n    // Keep our props within the layer\n    this.props = Object.assign({}, Layer.defaultProps || {}, props as U);\n    // Set up the pick type for the layer\n    const { picking = PickType.NONE } = this.props;\n\n    // If ALL is specified we set up QUAD tree picking for our instances\n    if (picking === PickType.ALL) {\n      const pickingMethods = this.getInstancePickingMethods();\n\n      this.picking = {\n        currentPickMode: PickType.NONE,\n        hitTest: pickingMethods.hitTest,\n        quadTree: new TrackedQuadTree<T>(\n          0,\n          1,\n          0,\n          1,\n          pickingMethods.boundsAccessor,\n        ),\n        type: PickType.ALL,\n      };\n    } else if (picking === PickType.SINGLE) {\n      this.picking = {\n        currentPickMode: PickType.NONE,\n        type: PickType.SINGLE,\n        uidToInstance: new Map<number, T>(),\n      };\n    } else {\n      this.picking = {\n        currentPickMode: PickType.NONE,\n        type: PickType.NONE,\n      };\n    }\n  }\n\n  /**\n   * Invalidate and free all resources assocated with this layer.\n   */\n  destroy() {\n    if (this.bufferManager) {\n      if (this.bufferManager.scene) this.bufferManager.scene.removeLayer(this);\n      this.bufferManager.removeFromScene();\n      this.bufferManager.destroy();\n    }\n  }\n\n  didUpdateProps() {\n    /** LIFECYCLE */\n  }\n\n  /**\n   * This is where global uniforms should update their values. Executes every frame.\n   */\n  draw() {\n    let uniform: IUniformInternal;\n    let value: UniformIOValue;\n\n    // Consume the diffs for the instances to update each element\n    const changeList = this.props.data.changeList;\n    // Make some holder variables to prevent declaration within the loop\n    let change, instance, bufferLocations;\n    // Fast ref to the processor and manager\n    const diffManager = this.diffManager;\n    const processing = diffManager.processing;\n    const processor = diffManager.processor;\n\n    // Forewarn the processor how many instances are flagged for a change.\n    processor.incomingChangeList(changeList);\n\n    for (let i = 0, end = changeList.length; i < end; ++i) {\n      change = changeList[i];\n      instance = change[0];\n      bufferLocations = this.bufferManager.getBufferLocations(instance);\n      // The diff type is change[1] which we use to find the diff processing method to use\n      processing[change[1]](\n        processor,\n        instance,\n        Object.values(change[2]),\n        bufferLocations,\n      );\n    }\n\n    // Tell the diff processor that it has completed it's task set\n    processor.commit();\n    // Indicate the diffs are consumed\n    this.props.data.resolve();\n\n    // Loop through the uniforms that are across all instances\n    for (let i = 0, end = this.uniforms.length; i < end; ++i) {\n      uniform = this.uniforms[i];\n      value = uniform.update(uniform);\n      uniform.materialUniforms.forEach(\n        materialUniform => (materialUniform.value = value),\n      );\n    }\n  }\n\n  /**\n   * This method is for layers to implement to specify how the bounds for an instance are retrieved or\n   * calculated and how the Instance interacts with a point. This is REQUIRED to support PickType.ALL on the layer.\n   */\n  getInstancePickingMethods(): IPickingMethods<T> {\n    throw new Error(\n      'When picking is set to PickType.ALL, the layer MUST have this method implemented; otherwise, the layer is incompatible with this picking mode.',\n    );\n  }\n\n  /**\n   * The type of Three model as well as the preferred draw mode associated with it.\n   */\n  getModelType(): IModelType {\n    return {\n      drawMode: Three.TrianglesDrawMode,\n      modelType: Three.Mesh,\n    };\n  }\n\n  /**\n   * The options for a three material without uniforms.\n   */\n  getMaterialOptions(): IMaterialOptions {\n    return {};\n  }\n\n  /**\n   * This sets up all of the data bindings that will transport data from the CPU\n   * to the Shader on the GPU.\n   *\n   * Instance Attributes: These are very frequently changing attributes\n   * Vertex Attributes: These are attributes that should be static on a vertex. Conisder it very costly to update.\n   *                    The only time making these modifieable is in the event of GL_POINTS.\n   * Uniforms: These set up the uniforms for the layer, thus having all normal implications of a uniform. Global\n   *           across the fragment and vertex shaders and can be modified with little consequence.\n   */\n  initShader(): IShaderInitialization<T> {\n    return {\n      fs: require('../shaders/base/no-op.fs'),\n      instanceAttributes: [],\n      uniforms: [],\n      vertexAttributes: [],\n      vertexCount: 0,\n      vs: require('../shaders/base/no-op.vs'),\n    };\n  }\n\n  /**\n   * Helper method for making an instance attribute. Depending on set up, this makes creating elements\n   * have better documentation when typing out the elements.\n   */\n  makeInstanceAttribute(\n    block: number,\n    blockIndex: InstanceBlockIndex,\n    name: string,\n    size: InstanceAttributeSize,\n    update: (o: T) => InstanceIOValue,\n    atlas?: {\n      key: string;\n      name: string;\n      shaderInjection?: ShaderInjectionTarget;\n    },\n  ): IInstanceAttribute<T> {\n    return {\n      atlas,\n      block,\n      blockIndex,\n      name,\n      size,\n      update,\n    };\n  }\n\n  /**\n   * Helper method for making a uniform type. Depending on set up, this makes creating elements\n   * have better documentation when typing out the elements.\n   */\n  makeUniform(\n    name: string,\n    size: UniformSize,\n    update: (o: IUniform) => UniformIOValue,\n    shaderInjection?: ShaderInjectionTarget,\n    qualifier?: string,\n  ): IUniform {\n    return {\n      name,\n      qualifier,\n      shaderInjection,\n      size,\n      update,\n    };\n  }\n\n  /**\n   * Applies a buffer manager to the layer which handles instance changes and applies those changes\n   * to an appropriate buffer at the appropriate location.\n   */\n  setBufferManager(bufferManager: BufferManagerBase<T, IBufferLocation>) {\n    if (!this._bufferManager) {\n      this._bufferManager = bufferManager;\n      this.diffManager = new InstanceDiffManager<T>(this, bufferManager);\n      this.diffManager.makeProcessor();\n      this.interactions = new LayerInteractionHandler(this);\n    } else {\n      console.warn(\n        'You can not change a layer\\'s buffer strategy once it has been instantiated.',\n      );\n    }\n  }\n\n  /**\n   * Only allows the buffer type to be set once\n   */\n  setBufferType(val: LayerBufferType) {\n    if (this._bufferType === undefined) {\n      this._bufferType = val;\n    } else {\n      console.warn(\n        'You can not change a layers buffer strategy once it has been instantiated.',\n      );\n    }\n  }\n\n  willUpdateInstances(changes: [T, InstanceDiffType]) {\n    // HOOK: Simple hook so a class can review all of it's changed instances before\n    //       Getting applied to the Shader IO\n  }\n\n  willUpdateProps(newProps: ILayerProps<T>) {\n    /** LIFECYCLE */\n  }\n\n  didUpdate() {\n    this.props.data.resolve();\n  }\n}\n","import { Instance } from '../../instance-provider/instance';\nimport {\n  IInstanceAttribute,\n  instanceAttributeSizeFloatCount,\n  IVertexAttribute,\n} from '../../types';\nimport { WebGLStat } from '../../util';\nimport {\n  InstanceAttributeBufferManager,\n  UniformBufferManager,\n} from '../buffer-management';\nimport { Layer } from '../layer';\nimport { Scene } from '../scene';\n\nexport enum LayerBufferType {\n  // This is a compatibility mode for instance attributes. This is used when:\n  // 1. It would perform better\n  // 2. When instance attributes are not available for the gl context (ANGLE draw instanced arrays)\n  // 3. When the instance attributes + vertex attributes exceeds the max Vertex Attributes for the hardware\n  UNIFORM,\n  // This is a fast and zippy buffering strategy used when the hardware supports it for a provided layer!\n  INSTANCE_ATTRIBUTE,\n}\n\n/**\n * This analyzes a layer and determines if it should use a compatibility instancing mode or use hardware\n * instancing.\n */\nexport function getLayerBufferType<T extends Instance>(\n  gl: WebGLRenderingContext,\n  layer: Layer<T, any>,\n  vertexAttributes: IVertexAttribute[],\n  instanceAttributes: IInstanceAttribute<T>[],\n) {\n  let type;\n\n  // The layer only gets it's buffer type calculated once\n  if (layer.bufferType !== undefined) {\n    return layer.bufferType;\n  }\n\n  // Uncomment this to force the uniform buffer strategy\n  // layer.setBufferType(LayerBufferType.UNIFORM);\n  // return LayerBufferType.UNIFORM;\n\n  if (WebGLStat.HARDWARE_INSTANCING) {\n    let attributesUsed = 0;\n\n    for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n      const attribute = vertexAttributes[i];\n      attributesUsed += Math.ceil(attribute.size / 4);\n    }\n\n    for (let i = 0, end = instanceAttributes.length; i < end; ++i) {\n      const attribute = instanceAttributes[i];\n      attributesUsed += Math.ceil(\n        instanceAttributeSizeFloatCount[attribute.size || 1] / 4,\n      );\n    }\n\n    // Too many attributes. We must use the uniform compatibility mode\n    if (attributesUsed > WebGLStat.MAX_VERTEX_ATTRIBUTES) {\n      type = LayerBufferType.UNIFORM;\n    }\n\n    // If we make it here, we are good to go using hardware instancing! Hooray performance!\n    else {\n      type = LayerBufferType.INSTANCE_ATTRIBUTE;\n    }\n  }\n\n  // No other faster mode supported: use uniform instancing\n  if (!type) type = LayerBufferType.UNIFORM;\n  // Apply the type to the layer\n  layer.setBufferType(type);\n\n  return type;\n}\n\n/**\n * Builds the proper buffer manager for the provided layer\n */\nexport function makeLayerBufferManager<T extends Instance>(\n  gl: WebGLRenderingContext,\n  layer: Layer<T, any>,\n  scene: Scene,\n) {\n  // Esnure the buffering type has been calculated for the layer\n  const type = getLayerBufferType(\n    gl,\n    layer,\n    layer.vertexAttributes,\n    layer.instanceAttributes,\n  );\n\n  switch (type) {\n    // This is the Instance Attribute buffering strategy, which means the system\n    case LayerBufferType.INSTANCE_ATTRIBUTE: {\n      layer.setBufferManager(new InstanceAttributeBufferManager(layer, scene));\n      break;\n    }\n\n    // Anything not utiliziing a specialized buffering strategy will use the uniform compatibility mode\n    default: {\n      layer.setBufferManager(new UniformBufferManager(layer, scene));\n      break;\n    }\n  }\n}\n","export * from './bounds';\nexport * from './circle';\nexport * from './point';\nexport * from './scale';\nexport * from './size';\n","export * from './atlas';\nexport * from './atlas-manager';\nexport * from './color-atlas-resource';\nexport * from './color-rasterizer';\nexport * from './image-atlas-resource';\nexport * from './image-rasterizer';\nexport * from './label-atlas-resource';\nexport * from './label-rasterizer';\n","import * as Three from 'three';\nimport { IModelConstructable, Layer } from '../layer';\n\nfunction isMesh(val: any): val is Three.Mesh {\n  return Boolean(val.isMesh);\n}\n\nexport function generateLayerModel(\n  layer: Layer<any, any>,\n  geometry: Three.BufferGeometry,\n  material: Three.ShaderMaterial,\n): IModelConstructable & Three.Object3D {\n  const modelInfo = layer.getModelType();\n  const model = new modelInfo.modelType(geometry, material);\n\n  if (isMesh(model)) {\n    model.drawMode =\n      modelInfo.drawMode === undefined\n        ? Three.TriangleStripDrawMode\n        : modelInfo.drawMode;\n  }\n\n  return model;\n}\n","export interface IdentifyByKeyOptions {\n  /** The identifier of the object */\n  key: string;\n}\n\n/**\n * This is an object that specifically is generated with a 'key' option that can never\n * be modified on the object and is identified henceforth with the key applied as the\n * 'id' of the object.\n */\nexport class IdentifyByKey {\n  /** Internal key held by the object */\n  private key: string;\n\n  /** READONLY id of the object. */\n  get id() {\n    return this.key;\n  }\n\n  constructor(options: IdentifyByKeyOptions) {\n    this.key = options.key;\n  }\n}\n","import { IBufferLocation } from '../surface/buffer-management';\nimport { Identifiable, IEasingProps } from '../types';\nimport { InstanceProvider } from './instance-provider';\nimport { observable } from './observable';\n\nlet instanceUID = 0;\n\nexport interface IInstanceOptions {\n  /** The instance can be declared with an initial active state */\n  active?: boolean;\n  /** An instance must be declared with an identifier */\n  id?: string;\n}\n\nexport class Instance implements Identifiable {\n  static get newUID() {\n    return (instanceUID = ++instanceUID % 0xffffff);\n  }\n\n  /** This indicates when the instance is active / rendering */\n  @observable active: boolean;\n  /** This is a mapping of an instance's observable properties to their associated Buffer Mapping */\n  private _attributeMapping = new Map<number, IBufferLocation>();\n  /** This is an internal easing object to track properties for automated easing */\n  private _easing = new Map<number, IEasingProps>();\n  /** Internal, non-changeable id */\n  private _id: string;\n  /** This is the observer of the Instance's observable properties */\n  private _observer: InstanceProvider<this> | null;\n  /** This is where observables store their data for the instance */\n  observableStorage: any[] = [];\n  /** A numerical look up for the instance. Numerical identifiers run faster than objects or strings */\n  private _uid = Instance.newUID;\n\n  /**\n   * The system will call this on the instance when it believes the instance may be\n   * harboring resources that are not released.\n   */\n  destroy() {\n    // Generally a No-op\n  }\n\n  get observableDisposer(): () => void {\n    return () => delete this._observer;\n  }\n\n  get observer(): InstanceProvider<this> | null {\n    return this._observer || null;\n  }\n\n  set observer(val: InstanceProvider<this> | null) {\n    // If an observer already is present, we should inform it, that it is being removed\n    // in favor of a new observer\n    const oldObserver = this._observer;\n\n    if (oldObserver && oldObserver !== val) {\n      oldObserver.remove(this);\n    }\n\n    // Apply the new observer as the current observer\n    this._observer = val;\n  }\n\n  get attributeMapping() {\n    return this._attributeMapping;\n  }\n\n  get easing() {\n    return this._easing;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  get uid() {\n    return this._uid;\n  }\n\n  /**\n   * This method is utilized internally to indicate when requested resources are ready.\n   * If you have a property that will be requesting a resource, you should implement this method\n   * to cause a trigger for the property to activate such that the property will update it's buffer.\n   */\n  resourceTrigger() {\n    // For subclasses\n  }\n\n  constructor(options: IInstanceOptions) {\n    this._id = options.id || '';\n    this.active = options.active || this.active;\n  }\n}\n","import * as Three from 'three';\nimport {\n  AbsolutePosition,\n  getAbsolutePositionBounds,\n} from '../primitives/absolute-position';\nimport { Bounds } from '../primitives/bounds';\nimport { IPoint } from '../primitives/point';\nimport { Color } from '../types';\nimport { ChartCamera } from '../util/chart-camera';\nimport { DataBounds } from '../util/data-bounds';\nimport { IdentifyByKey, IdentifyByKeyOptions } from '../util/identify-by-key';\nimport { ViewCamera, ViewCameraType } from '../util/view-camera';\n\nexport enum ClearFlags {\n  COLOR = 0b0001,\n  DEPTH = 0b0010,\n  STENCIL = 0b0100,\n}\n\n/**\n * Defines the input metrics of a view for a scene.\n */\nexport interface IViewOptions extends IdentifyByKeyOptions {\n  /**\n   * The background color that gets cleared out for this view. Performance is\n   * better if this is left clear. Probably better to draw a colored quad instead.\n   * This is just convenient.\n   */\n  background?: Color;\n  /**\n   * This is the spatial charting camera that is concerned with offsets and scales.\n   * It is often easier to work with camera positioning and settings rather than working\n   * with the complex and nuanced viewCamera which works with special transformation matrices\n   * to express orientation.\n   *\n   * If not provided, then this camera will use a default ChartCamera for this camera slot. This\n   * will also cause a normal camera handler to be utilized.\n   */\n  camera?: ChartCamera;\n  /**\n   * This sets what buffers get cleared by webgl before the view is drawn in it's space.\n   */\n  clearFlags?: ClearFlags[];\n  /**\n   * If this is provided, the layer can be rendered with a traditional camera that utilizes\n   * matrix transforms to provide orientation/projection for the view.\n   *\n   * If this is NOT provided, the camera will be a special orthographic camera for 2d spaces\n   * with a y-axis of +y points down with (0, 0) at the top left of the viewport.\n   */\n  viewCamera?: ViewCamera;\n  /**\n   * This specifies the bounds on the canvas this camera will render to. This let's you render\n   * say a little square in the bottom right showing a minimap.\n   *\n   * If this is not specified, the entire canvas will be the viewport.\n   */\n  viewport?: AbsolutePosition;\n}\n\nfunction isOrthographic(val: Three.Camera): val is Three.OrthographicCamera {\n  return 'left' in val;\n}\n\n/**\n * This defines a view of a scene\n */\nexport class View extends IdentifyByKey {\n  static DEFAULT_VIEW_ID = '__default__';\n\n  /** If present, is the cleared color before this view renders */\n  background: Color;\n  /** Camera that defines the individual components of each axis with simpler concepts */\n  camera: ChartCamera;\n  /** These are the clear flags set for this view */\n  clearFlags: ClearFlags[];\n  /**\n   * This is the depth of the view. The higher the depth represents which layer is on top.\n   * Zero always represents the default view.\n   */\n  depth: number = 0;\n  /** This is set to ensure the projections that happen properly translates the pixel ratio to normal Web coordinates */\n  pixelRatio: number = window.devicePixelRatio;\n  /** This is the rendering bounds within screen space */\n  screenBounds: Bounds;\n  /** Camera that defines the view projection matrix */\n  viewCamera: ViewCamera;\n  /** The size positioning of the view */\n  viewport: AbsolutePosition;\n  /** The bounds of the render space on the canvas this view will render on */\n  viewBounds: DataBounds<View>;\n\n  constructor(options: IViewOptions) {\n    super(options);\n    Object.assign(this, options);\n  }\n\n  screenToPixelSpace(point: IPoint, out?: IPoint) {\n    const p = out || { x: 0, y: 0 };\n\n    p.x = point.x * this.pixelRatio;\n    p.y = point.y * this.pixelRatio;\n\n    return p;\n  }\n\n  pixelSpaceToScreen(point: IPoint, out?: IPoint) {\n    const p = out || { x: 0, y: 0 };\n\n    p.x = point.x / this.pixelRatio;\n    p.y = point.y / this.pixelRatio;\n\n    return p;\n  }\n\n  screenToView(point: IPoint, out?: IPoint) {\n    const p = this.screenToPixelSpace(point, out);\n\n    p.x = p.x - this.viewBounds.x;\n    p.y = p.y - this.viewBounds.y;\n\n    return p;\n  }\n\n  viewToScreen(point: IPoint, out?: IPoint) {\n    const p = { x: 0, y: 0 };\n\n    p.x = point.x + this.viewBounds.x;\n    p.y = point.y + this.viewBounds.y;\n\n    return this.pixelSpaceToScreen(p, out);\n  }\n\n  screenToWorld(point: IPoint, out?: IPoint) {\n    const view = this.pixelSpaceToScreen(this.screenToView(point));\n\n    const world = out || { x: 0, y: 0 };\n    world.x =\n      (view.x - this.camera.offset[0] * this.camera.scale[0]) /\n      this.camera.scale[0];\n    world.y =\n      (view.y - this.camera.offset[1] * this.camera.scale[1]) /\n      this.camera.scale[1];\n\n    // If this is a custom camera, we must actually project our world point to the screen\n    if (this.viewCamera.type === ViewCameraType.CUSTOM) {\n      console.warn('Custom View Camera projections not supported yet');\n    }\n\n    return world;\n  }\n\n  worldToScreen(point: IPoint, out?: IPoint) {\n    const screen = { x: 0, y: 0 };\n\n    // Calculate from the camera to view space\n    screen.x =\n      (point.x * this.camera.scale[0] +\n        this.camera.offset[0] * this.camera.scale[0]) *\n      this.pixelRatio;\n    screen.y =\n      (point.y * this.camera.scale[1] +\n        this.camera.offset[1] * this.camera.scale[1]) *\n      this.pixelRatio;\n\n    // If this is a custom camera, we must actually project our world point to the screen\n    if (this.viewCamera.type === ViewCameraType.CUSTOM) {\n      console.warn('Custom View Camera projections not supported yet');\n    }\n\n    // Convert from view to screen space\n    return this.viewToScreen(screen, out);\n  }\n\n  viewToWorld(point: IPoint, out?: IPoint) {\n    const world = out || { x: 0, y: 0 };\n\n    const screen = this.pixelSpaceToScreen(point);\n    world.x =\n      (screen.x - this.camera.offset[0] * this.camera.scale[0]) /\n      this.camera.scale[0];\n    world.y =\n      (screen.y - this.camera.offset[1] * this.camera.scale[1]) /\n      this.camera.scale[1];\n\n    // If this is a custom camera, we must actually project our world point to the screen\n    if (this.viewCamera.type === ViewCameraType.CUSTOM) {\n      console.warn('Custom View Camera projections not supported yet');\n    }\n\n    return world;\n  }\n\n  worldToView(point: IPoint, out?: IPoint) {\n    const screen = out || { x: 0, y: 0 };\n\n    // Calculate from the camera to view space\n    screen.x =\n      point.x * this.camera.scale[0] +\n      this.camera.offset[0] * this.camera.scale[0];\n    screen.y =\n      point.y * this.camera.scale[1] +\n      this.camera.offset[1] * this.camera.scale[1];\n\n    // If this is a custom camera, we must actually project our world point to the screen\n    if (this.viewCamera.type === ViewCameraType.CUSTOM) {\n      console.warn('Custom View Camera projections not supported yet');\n    }\n\n    return screen;\n  }\n\n  /**\n   * This operation makes sure we have the view camera adjusted to the new viewport's needs.\n   * For default behavior this ensures that the coordinate system has no distortion, orthographic,\n   * top left as 0,0 with +y axis pointing down.\n   */\n  fitViewtoViewport(surfaceDimensions: Bounds) {\n    if (\n      this.viewCamera.type === ViewCameraType.CONTROLLED &&\n      isOrthographic(this.viewCamera.baseCamera)\n    ) {\n      const viewBounds = getAbsolutePositionBounds<View>(\n        this.viewport,\n        surfaceDimensions,\n        this.pixelRatio,\n      );\n      const width = viewBounds.width;\n      const height = viewBounds.height;\n\n      const viewport = {\n        bottom: -height / 2,\n        far: 10000000,\n        left: -width / 2,\n        near: -100,\n        right: width / 2,\n        top: height / 2,\n      };\n\n      const scaleX = 1;\n      const scaleY = 1;\n      const camera = this.viewCamera.baseCamera;\n\n      Object.assign(camera, viewport);\n      camera.position.set(\n        -viewBounds.width / 2.0 * scaleX,\n        viewBounds.height / 2.0 * scaleY,\n        camera.position.z,\n      );\n      camera.scale.set(scaleX, -scaleY, 1.0);\n      camera.updateMatrix();\n      camera.updateMatrixWorld(true);\n      camera.updateProjectionMatrix();\n\n      this.viewBounds = viewBounds;\n      this.viewBounds.data = this;\n      this.screenBounds = new Bounds({\n        height: this.viewBounds.height / this.pixelRatio,\n        width: this.viewBounds.width / this.pixelRatio,\n        x: this.viewBounds.x / this.pixelRatio,\n        y: this.viewBounds.y / this.pixelRatio,\n      });\n    } else if (!isOrthographic(this.viewCamera.baseCamera)) {\n      console.warn(\n        'Fit to viewport does not support non-orthographic cameras as a default behavior.',\n      );\n    }\n  }\n}\n","import * as Three from 'three';\nimport { Instance } from '../util';\nimport { IdentifyByKey, IdentifyByKeyOptions } from '../util/identify-by-key';\nimport { ILayerProps, Layer } from './layer';\nimport { IViewOptions, View } from './view';\n\n/**\n * Defines the input for an available scene layers can add themselves to. Each scene can be rendered with multiple\n * views.\n */\nexport interface ISceneOptions extends IdentifyByKeyOptions {\n  /**\n   * This indicates all of the views this scene can be rendered with. For instance: You have a\n   * world scene and you want to render it stereoscopically for VR. Then you can specify two\n   * views with two viewports to render the scene on both halves of the canvas.\n   *\n   * Or perhaps you want an aerial shot as a minimap in the bottom right corner while the rest\n   * of the canvas renders a first person view, then you would make two views for that as well.\n   */\n  views: IViewOptions[];\n}\n\nfunction sortByDepth(a: Layer<any, any>, b: Layer<any, any>) {\n  return a.depth - b.depth;\n}\n\n/**\n * This defines a scene to which layers are added to. It also tracks the views that this scene\n * is rendered with.\n */\nexport class Scene extends IdentifyByKey {\n  static DEFAULT_SCENE_ID = '__default__';\n\n  /** This is the three scene which actually sets up the rendering objects */\n  container: Three.Scene = new Three.Scene();\n  // TODO: This 'could' be smarter when Three is gone. The pipeline could IMMEDIATELY render\n  /** We make a picking container specifically for the cases where objects must be rendered for picking */\n  pickingContainer: Three.Scene = new Three.Scene();\n  /** This is all of the layers tracked to the scene */\n  layers: Layer<any, any>[] = [];\n  /** This indicates the sort is dirty for a set of layers */\n  sortIsDirty = false;\n  /** This is the view */\n  viewById = new Map<string, View>();\n\n  constructor(options: ISceneOptions) {\n    super(options);\n    this.container.frustumCulled = false;\n    this.container.autoUpdate = false;\n  }\n\n  /**\n   * Adds a layer to the scene with the current view setting the layer contains.\n   * The layer can not jump between views or scenes. You must destroy and reconstruct\n   * the layer.\n   */\n  addLayer<T extends Instance, U extends ILayerProps<T>>(layer: Layer<T, U>) {\n    // Add the layer to the list of layers under the view\n    this.layers.push(layer);\n    this.sortIsDirty = true;\n  }\n\n  /**\n   * This adds a view to this scene to be used by the scene\n   */\n  addView(view: View) {\n    this.viewById.set(view.id, view);\n  }\n\n  /**\n   * Release any resources this may be hanging onto\n   */\n  destroy() {\n    delete this.container;\n  }\n\n  /**\n   * Removes a layer from the scene. No resort is needed as remove operations\n   * do not adjust the sorting order.\n   */\n  removeLayer(layer: Layer<any, any>) {\n    if (this.layers) {\n      const index = this.layers.indexOf(layer);\n\n      if (index >= 0) {\n        this.layers.splice(index, 1);\n        return;\n      }\n    }\n\n    console.warn(\n      'Could not remove a layer from the scene as the layer was not a part of the scene to start. Scene:',\n      this.id,\n      'Layer:',\n      layer.id,\n    );\n  }\n\n  sortLayers() {\n    if (this.sortIsDirty) {\n      this.layers.sort(sortByDepth);\n    }\n  }\n}\n","import { Label } from '../../primitives/label';\nimport { BaseAtlasResource } from './base-atlas-resource';\n\nexport class LabelAtlasResource extends BaseAtlasResource {\n  /** This is the label to be loaded into the atlas */\n  label: Label;\n  /** If the label renders */\n  truncatedText: string;\n\n  constructor(label: Label) {\n    super();\n    this.label = label;\n  }\n}\n","import { SubTexture } from './sub-texture';\n\nexport class BaseAtlasResource {\n  /** The rasterization metrics of the label */\n  rasterization: {\n    /**\n     * WARNING: This will ONLY SOMETIMES be populated. The system can choose\n     * when to consume this as it chooses as it can be a major memory eater if\n     * permanently left in place. DO NOT RELY on this being available.\n     */\n    canvas?: HTMLCanvasElement;\n    image?: HTMLImageElement;\n    /** The rasterization dimensions as it is rendered to texture space on an atlas */\n    texture: {\n      height: number;\n      width: number;\n    };\n    /** The rasterization dimensions as it would be rendered in world space */\n    world: {\n      height: number;\n      width: number;\n    };\n  };\n  /**\n   * This sets the ratserization to be a larger value on the texture than is rendered within\n   * the world space. This allows for techniques to be applied in the shaders to incorporate super sampling\n   * or other processes which require higher levels of resolution.\n   *\n   * The default is 1 for a 1 to 1 sample scaling to world space rendering\n   */\n  sampleScale: number = 1;\n  /** Once loaded into the texture, this will be populated */\n  texture: SubTexture;\n}\n","export enum EdgeScaleType {\n  /** All dimensions are within world space */\n  NONE,\n  /**\n   * The control points are a delta from the end points within screen space, and the line thickness is within\n   * screen space as well all measured in pixels. The scaleFactor scales both thickness and control delta values.\n   * The endpoints remain in world space\n   */\n  SCREEN_CURVE,\n}\n\nexport enum EdgeType {\n  /** Makes a straight edge with no curve */\n  LINE,\n  /** Makes a single control point Bezier curve */\n  BEZIER,\n  /** Makes a two control point bezier curve */\n  BEZIER2,\n}\n\n/**\n * This is the broadphase control for edges to help handle quad tree adjustments for picking. If the edge scale type\n * is NONE, you don't need to utilize this. If you use screen space and have camera distortions along an axis, this\n * can help greatly.\n */\nexport enum EdgeBroadphase {\n  /** Use this if the broad phase detection should use both width and height of the edge's bounds */\n  ALL,\n  /** Use this to ensure a test against the edge is performed if the mouse aligns with it on the x-axis */\n  PASS_Y,\n  /** Use this to ensure a test against the edge is performed if the mouse aligns with it on the y axis */\n  PASS_X,\n}\n","import * as Three from 'three';\nimport { Instance, InstanceDiff } from '../../../instance-provider';\nimport { isBufferLocation } from '../buffer-manager-base';\nimport { IInstanceDiffManagerTarget } from '../instance-diff-manager';\nimport { IUniformBufferLocation } from '../uniform-buffer-manager';\nimport { BaseDiffProcessor } from './base-diff-processor';\n\n// This is a mapping of the vector properties as they relate to an array order\nconst VECTOR_ACCESSORS: (keyof Three.Vector4)[] = ['x', 'y', 'z', 'w'];\nconst EMPTY: number[] = [];\n\n/**\n * Manages diffs for layers that are utilizing the base uniform instancing buffer strategy.\n */\nexport class UniformDiffProcessor<T extends Instance> extends BaseDiffProcessor<\n  T\n> {\n  /**\n   * This processes add operations from changes in the instancing data\n   */\n  addInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster?: IUniformBufferLocation,\n  ) {\n    // If the uniform cluster already exists, then we swap over to a change update\n    if (uniformCluster) {\n      manager.changeInstance(manager, instance, EMPTY, uniformCluster);\n    }\n\n    // Otherwise, we DO need to perform an add and we link a Uniform cluster to our instance\n    else {\n      const uniforms = manager.layer.bufferManager.add(instance);\n\n      if (isBufferLocation(uniforms)) {\n        instance.active = true;\n        manager.updateInstance(manager.layer, instance, uniforms);\n      }\n    }\n  }\n\n  /**\n   * This processes change operations from changes in the instancing data\n   */\n  changeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster?: IUniformBufferLocation,\n  ) {\n    // If there is an existing uniform cluster for this instance, then we can update the uniforms\n    if (uniformCluster) {\n      manager.updateInstance(manager.layer, instance, uniformCluster);\n    }\n\n    // If we don't have existing uniforms, then we must remove the instance\n    else {\n      manager.addInstance(manager, instance, EMPTY, uniformCluster);\n    }\n  }\n\n  /**\n   * This processes remove operations from changes in the instancing data\n   */\n  removeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster?: IUniformBufferLocation,\n  ) {\n    if (uniformCluster) {\n      // We deactivate the instance so it does not render anymore\n      instance.active = false;\n      // We do one last update on the instance to update to it's deactivated state\n      manager.updateInstance(manager.layer, instance, uniformCluster);\n      // Unlink the instance from the uniform cluster\n      manager.layer.bufferManager.remove(instance);\n    }\n  }\n\n  /**\n   * This performs the actual updating of buffers the instance needs to update\n   */\n  updateInstance(\n    layer: IInstanceDiffManagerTarget<T>,\n    instance: T,\n    uniformCluster: IUniformBufferLocation,\n  ) {\n    if (instance.active) {\n      const uniforms = uniformCluster.buffer;\n      const uniformRangeStart = uniformCluster.range[0];\n      const instanceData: Three.Vector4[] = uniforms.value;\n      let instanceUniform, value, block, start;\n      let k, endk;\n\n      // Loop through the instance attributes and update the uniform cluster with the valaues\n      // Calculated for the instance\n      for (let i = 0, end = layer.instanceAttributes.length; i < end; ++i) {\n        instanceUniform = layer.instanceAttributes[i];\n        value = instanceUniform.update(instance);\n        block = instanceData[uniformRangeStart + instanceUniform.block];\n        instanceUniform.atlas &&\n          layer.resource.setTargetAtlas(instanceUniform.atlas.key);\n        start = instanceUniform.blockIndex;\n\n        if (start === undefined) {\n          continue;\n        }\n\n        // Hyper optimized vector filling routine. It uses properties that are globally scoped\n        // To greatly reduce overhead\n        for (k = start, endk = value.length + start; k < endk; ++k) {\n          block[VECTOR_ACCESSORS[k]] = value[k - start];\n        }\n      }\n\n      uniforms.value = instanceData;\n    } else {\n      const uniforms: Three.IUniform = uniformCluster.buffer;\n      const uniformRangeStart = uniformCluster.range[0];\n      const instanceData: Three.Vector4[] = uniforms.value;\n      let instanceUniform, value, block, start;\n\n      // Only update the _active attribute to ensure it is false. When it is false, there is no\n      // Point to updating any other uniform\n      instanceUniform = layer.activeAttribute;\n      value = instanceUniform.update(instance);\n      block = instanceData[uniformRangeStart + instanceUniform.block];\n      instanceUniform.atlas &&\n        layer.resource.setTargetAtlas(instanceUniform.atlas.key);\n      start = instanceUniform.blockIndex;\n\n      if (start !== undefined) {\n        // Hyper optimized vector filling routine. It uses properties that are globally scoped\n        // To greatly reduce overhead\n        for (let k = start, endk = value.length + start; k < endk; ++k) {\n          block[VECTOR_ACCESSORS[k]] = value[k - start];\n        }\n      }\n\n      uniforms.value = instanceData;\n    }\n  }\n\n  /**\n   * Right now there is no operations for committing for the uniform manager.\n   */\n  commit() {\n    /** no-op */\n  }\n\n  /**\n   * There are no optimizations available for this processor yet.\n   */\n  incomingChangeList(_changes: InstanceDiff<T>[]) {\n    /** no-op */\n  }\n}\n","import * as Three from 'three';\n\nexport enum ViewCameraType {\n  /**\n   * Indicates a camera that is forced by the system to follow:\n   * - Match width and height of the view port\n   * - +y axis points downward\n   * - gl origin is at the top left of the screen\n   */\n  CONTROLLED,\n  /**\n   * This allows a custom view camera to be applied to the scene.\n   */\n  CUSTOM,\n}\n\n/**\n * This is a camera that controls the view projection matrix. This is a much more\n * complicated way to handle views that is better suited for handling 3D applications\n * and is very overkill for most 2D charting systems. If you are working purely with\n * 2D components, it's recommended to leave this as a CONTROLLED camera and utilize\n * the ChartCamera for most of your needs.\n */\nexport class ViewCamera {\n  type: ViewCameraType = ViewCameraType.CONTROLLED;\n  baseCamera: Three.Camera;\n}\n","export interface IShaderTemplateResults {\n  /** This is the resulting shader string generated from the templating */\n  shader: string;\n  /** This is the template options provided by the shader. {option: num occurrences} */\n  shaderProvidedOptions: Map<string, number>;\n  /**\n   * This is the template options provided by the shader that were not resolved by the options parameter\n   * {option: num occurrences}\n   */\n  unresolvedShaderOptions: Map<string, number>;\n  /** This is the options provided to the template that did not get resolved by the shader {option: 1} */\n  unresolvedProvidedOptions: Map<string, number>;\n  /** This is the list of options that DID get resolved by the options provided {option: num occurrences} */\n  resolvedShaderOptions: Map<string, number>;\n}\n\nexport interface IShaderTemplateRequirements {\n  /** A string identifier to make it easier to identify which shader template failed requirements */\n  name: string;\n  /** The options that must be present within both provided options AND within the template */\n  values: string[];\n}\n\nexport function shaderTemplate(\n  shader: string,\n  options: { [key: string]: string },\n  required?: IShaderTemplateRequirements,\n): IShaderTemplateResults {\n  const matched = new Map<string, number>();\n  const noValueProvided = new Map<string, number>();\n  const notFound = new Map<string, number>();\n  const shaderOptions = new Map<string, number>();\n\n  const shaderResults = shader.replace(\n    /\\$\\{(\\w+)\\}/g,\n    (x: string, match: string) => {\n      shaderOptions.set(match, (shaderOptions.get(match) || 0) + 1);\n\n      if (match in options) {\n        matched.set(match, (matched.get(match) || 0) + 1);\n        return options[match];\n      }\n\n      noValueProvided.set(match, (noValueProvided.get(match) || 0) + 1);\n      return '';\n    },\n  );\n\n  Object.keys(options).forEach(option => {\n    if (!matched.get(option)) {\n      notFound.set(option, (notFound.get(option) || 0) + 1);\n    }\n  });\n\n  // Provide metrics\n  const results = {\n    resolvedShaderOptions: matched,\n    shader: shaderResults,\n    shaderProvidedOptions: shaderOptions,\n    unresolvedProvidedOptions: notFound,\n    unresolvedShaderOptions: noValueProvided,\n  };\n\n  if (required) {\n    // This will ensure that BOTH the parameter input AND the shader provided the required options.\n    required.values.forEach(require => {\n      if (results.unresolvedProvidedOptions.get(require)) {\n        console.error(\n          `${required.name}: Could not resolve all the required inputs. Input:`,\n          require,\n        );\n      } else if (results.unresolvedShaderOptions.get(require)) {\n        console.error(\n          `${\n            required.name\n          }: A required option was not provided in the options parameter. Option:`,\n          require,\n        );\n      } else if (!results.resolvedShaderOptions.get(require)) {\n        console.error(\n          `${\n            required.name\n          }: A required option was not provided in the options parameter. Option:`,\n          require,\n        );\n      }\n    });\n  }\n\n  return results;\n}\n","let chartCameraUID = 0;\n\nexport interface IChartCameraOptions {\n  /** The world space offset of elements in the chart */\n  offset?: [number] | [number, number] | [number, number, number];\n  /** The world space scaling present in the chart */\n  scale?: [number] | [number, number] | [number, number, number];\n}\n\n/**\n * Quick method for applying a source array to a target array. This\n * ensures the arrays both are valid and applies the values without just making\n * a copy of the source.\n */\nfunction applyArray(target?: number[], source?: number[]) {\n  target && source && target.splice(0, source.length, ...source);\n}\n\nexport class ChartCamera {\n  /** Internally set id */\n  _id: number = chartCameraUID++;\n  /** Represents how much an element should be offset in world space */\n  offset: [number, number, number] = [0, 0, 0];\n  /** Represents how scaled each axis should be in world space */\n  scale: [number, number, number] = [1, 1, 1];\n\n  constructor(options?: IChartCameraOptions) {\n    if (options) {\n      applyArray(this.offset, options.offset);\n      applyArray(this.scale, options.scale);\n    }\n  }\n\n  /** Keep id as readonly */\n  get id() {\n    return this._id;\n  }\n\n  /**\n   * Sets the location of the camera by adjusting the offsets to match.\n   */\n  position(location: [number, number, number]) {\n    this.offset = location.slice(0) as [number, number, number];\n  }\n}\n","const { sqrt } = Math;\n\n/** Explicit Vec1 */\nexport interface IVec1 extends Array<number> {\n  0: number;\n  length: 1;\n}\n\n/** Explicit Vec2 */\nexport interface IVec2 extends Array<number> {\n  0: number;\n  1: number;\n  length: 2;\n}\n\n/** Explicit Vec3 */\nexport interface IVec3 extends Array<number> {\n  0: number;\n  1: number;\n  2: number;\n  length: 3;\n}\n\n/** Explicit Vec4 */\nexport interface IVec4 extends Array<number> {\n  0: number;\n  1: number;\n  2: number;\n  3: number;\n  length: 4;\n}\n\n/** Vector of 1 components */\nexport type Vec1 = [number];\n/** Vector of 2 components */\nexport type Vec2 = [number, number];\n/** Vector of 3 components */\nexport type Vec3 = [number, number, number];\n/** Vector of 4 components */\nexport type Vec4 = [number, number, number, number];\n\n/** This type defines any possible explicit vector */\nexport type IVec = IVec1 | IVec2 | IVec3 | IVec4;\n/** This type defines any possible vector */\nexport type Vec = Vec1 | Vec2 | Vec3 | Vec4;\n\nexport function add1(left: Vec1, right: Vec1): Vec1 {\n  return [left[0] + right[0]];\n}\n\nexport function scale1(vec: Vec1, scale: number): Vec1 {\n  return [vec[0] * scale];\n}\n\nexport function subtract1(left: Vec1, right: Vec1): Vec1 {\n  return [left[0] - right[0]];\n}\n\nexport function multiply1(left: Vec1, right: Vec1): Vec1 {\n  return [left[0] * right[0]];\n}\n\nexport function dot1(left: Vec1, right: Vec1): number {\n  return left[0] * right[0];\n}\n\nexport function linear1(start: Vec1, end: Vec1, t: number): Vec1 {\n  return scale1(add1(subtract1(end, start), start), t);\n}\n\nexport function length1(start: Vec1): number {\n  return sqrt(dot1(start, start));\n}\n\nexport function add2(left: Vec2, right: Vec2): Vec2 {\n  return [left[0] + right[0], left[1] + right[1]];\n}\n\nexport function scale2(left: Vec2, scale: number): Vec2 {\n  return [left[0] * scale, left[1] * scale];\n}\n\nexport function subtract2(left: Vec2, right: Vec2): Vec2 {\n  return [left[0] - right[0], left[1] - right[1]];\n}\n\nexport function multiply2(left: Vec2, right: Vec2): Vec2 {\n  return [left[0] * right[0], left[1] * right[1]];\n}\n\nexport function dot2(left: Vec2, right: Vec2): number {\n  return left[0] * right[0] + left[1] * right[1];\n}\n\nexport function linear2(start: Vec2, end: Vec2, t: number): Vec2 {\n  return scale2(add2(subtract2(end, start), start), t);\n}\n\nexport function length2(start: Vec2): number {\n  return sqrt(dot2(start, start));\n}\n\nexport function add3(left: Vec3, right: Vec3): Vec3 {\n  return [left[0] + right[0], left[1] + right[1], left[2] + right[2]];\n}\n\nexport function scale3(left: Vec3, scale: number): Vec3 {\n  return [left[0] * scale, left[1] * scale, left[2] * scale];\n}\n\nexport function subtract3(left: Vec3, right: Vec3): Vec3 {\n  return [left[0] - right[0], left[1] - right[1], left[2] - right[2]];\n}\n\nexport function multiply3(left: Vec3, right: Vec3): Vec3 {\n  return [left[0] * right[0], left[1] * right[1], left[2] * right[2]];\n}\n\nexport function linear3(start: Vec3, end: Vec3, t: number): Vec3 {\n  return scale3(add3(subtract3(end, start), start), t);\n}\n\nexport function length3(start: Vec3): number {\n  return sqrt(dot3(start, start));\n}\n\nexport function dot3(left: Vec3, right: Vec3): number {\n  return left[0] * right[0] + left[1] * right[1] + left[2] * right[2];\n}\n\nexport function add4(left: Vec4, right: Vec4): Vec4 {\n  return [\n    left[0] + right[0],\n    left[1] + right[1],\n    left[2] + right[2],\n    left[3] + right[3],\n  ];\n}\n\nexport function scale4(left: Vec4, scale: number): Vec4 {\n  return [left[0] * scale, left[1] * scale, left[2] * scale, left[3] * scale];\n}\n\nexport function subtract4(left: Vec4, right: Vec4): Vec4 {\n  return [\n    left[0] - right[0],\n    left[1] - right[1],\n    left[2] - right[2],\n    left[3] - right[3],\n  ];\n}\n\nexport function multiply4(left: Vec4, right: Vec4): Vec4 {\n  return [\n    left[0] * right[0],\n    left[1] * right[1],\n    left[2] * right[2],\n    left[3] * right[3],\n  ];\n}\n\nexport function dot4(left: Vec4, right: Vec4): number {\n  return (\n    left[0] * right[0] +\n    left[1] * right[1] +\n    left[2] * right[2] +\n    left[3] * right[3]\n  );\n}\n\nexport function linear4(start: Vec4, end: Vec4, t: number): Vec4 {\n  return scale4(add4(subtract4(end, start), start), t);\n}\n\nexport function length4(start: Vec4): number {\n  return sqrt(dot4(start, start));\n}\n\nexport type VecMethods<T extends Vec> = {\n  add(left: T, right: T): T;\n  scale(vec: T, scale: number): T;\n  subtract(left: T, right: T): T;\n  multiply(left: T, right: T): T;\n  dot(left: T, right: T): number;\n  linear(start: T, end: T, t: number): T;\n  length(vec: T): number;\n};\n\nexport const vec1Methods: VecMethods<Vec1> = {\n  add: add1,\n  dot: dot1,\n  length: length1,\n  linear: linear1,\n  multiply: multiply1,\n  scale: scale1,\n  subtract: subtract1,\n};\n\nexport const vec2Methods: VecMethods<Vec2> = {\n  add: add2,\n  dot: dot2,\n  length: length2,\n  linear: linear2,\n  multiply: multiply2,\n  scale: scale2,\n  subtract: subtract2,\n};\n\nexport const vec3Methods: VecMethods<Vec3> = {\n  add: add3,\n  dot: dot3,\n  length: length3,\n  linear: linear3,\n  multiply: multiply3,\n  scale: scale3,\n  subtract: subtract3,\n};\n\nexport const vec4Methods: VecMethods<Vec4> = {\n  add: add4,\n  dot: dot4,\n  length: length4,\n  linear: linear4,\n  multiply: multiply4,\n  scale: scale4,\n  subtract: subtract4,\n};\n\nexport function VecMath<T extends IVec>(vec: T): VecMethods<T> {\n  let methods: VecMethods<T>;\n\n  if (vec.length === 1) {\n    methods = vec1Methods as VecMethods<T>;\n    return methods;\n  } else if (vec.length === 2) {\n    methods = vec2Methods as VecMethods<T>;\n    return methods;\n  } else if (vec.length === 3) {\n    methods = vec3Methods as VecMethods<T>;\n    return methods;\n  }\n\n  methods = vec4Methods as VecMethods<T>;\n\n  return methods;\n}\n","import { InstanceIOValue } from '../types';\nimport { Vec, VecMath } from './vector';\n\nconst { min, max, pow, round, sin, PI } = Math;\nconst GPU_PI = round(PI * 1000) / 1000;\n\nfunction clamp(x: number, minVal: number, maxVal: number) {\n  return min(max(x, minVal), maxVal);\n}\n\nexport enum AutoEasingLoopStyle {\n  /** Time will go from 0 -> 1 then stop at 1 */\n  NONE = 1,\n  /** Time will go from 0 -> infinity */\n  CONTINUOUS = 4,\n  /** Time will continuously go 0 -> 1 then 0 -> 1 then 0 -> 1 etc etc */\n  REPEAT = 2,\n  /** Time will continously go 0 -> 1 then 1 -> 0 then 0 -> 1 then 1 -> 0 etc etc */\n  REFLECT = 3,\n}\n\n/**\n * This defines a GPU enabled easing method that will be executed on the GPU to maneuver\n *\n */\nexport interface IAutoEasingMethod<T extends InstanceIOValue> {\n  /** An easing method that should produce IDENTICAL values to the values of the gpu easing method using the exact same parameters */\n  cpu(start: T, end: T, t: number): T;\n  /** This adds a delay to the starting time of an easing change */\n  delay: number;\n  /** This is how long the easing method should last */\n  duration: number;\n  /**\n   * An easing method written in shader language that should produce IDENTICAL\n   * values to the values of the cpu easing method using the exact same parameters.\n   */\n  gpu: string;\n  /**\n   * This defines the looping style of the easing.\n   */\n  loop: AutoEasingLoopStyle;\n  /**\n   * This shall be the name of the easing method as it appears in the spu shader.\n   * BE WARNED: This name is used to dedup the methods created on the shader. So,\n   * if you use the same name as another ease method used on a single layer, you run\n   * the risk of one overriding the other with an undefined chance of who wins.\n   */\n  methodName: string;\n\n  /**\n   * This lets you modify some auto easing validation rules.\n   */\n  validation?: {\n    ignoreEndValueCheck?: boolean;\n    ignoreOverTimeCheck?: boolean;\n  }\n}\n\n// GPU easing methods! Written here because it's cleaner to write `` style strings\n// Against the left side of the editor\n\nconst immediateGPU = `\n$\\{easingMethod} {\n  return end;\n}\n`;\n\nconst linearGPU = `\n$\\{easingMethod} {\n  return (end - start) * t + start;\n}\n`;\n\nconst easeInQuadGPU = `\n$\\{easingMethod} {\n  float time = t * t;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeOutQuadGPU = `\n$\\{easingMethod} {\n  float time = t * (2.0 - t);\n  return (end - start) * time + start;\n}\n`;\nconst easeInOutQuadGPU = `\n$\\{easingMethod} {\n  float time = t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;\n  return (end - start) * time + start;\n}\n`;\nconst easeInCubicGPU = `\n$\\{easingMethod} {\n  float time = t * t * t;\n  return (end - start) * time + start;\n}\n`;\nconst easeOutCubicGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = t1 * t1 * t1 + 1.0;\n  return (end - start) * time + start;\n}\n`;\nconst easeInOutCubicGPU = `\n$\\{easingMethod} {\n  float time = t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0;\n  return (end - start) * time + start;\n}\n`;\nconst easeInQuartGPU = `\n$\\{easingMethod} {\n  float time = t * t * t * t;\n  return (end - start) * time + start;\n}\n`;\nconst easeOutQuartGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = 1.0 - t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n`;\nconst easeInOutQuartGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = t < 0.5 ? 8.0 * t * t * t * t : 1.0 - 8.0 * t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n`;\nconst easeInQuintGPU = `\n$\\{easingMethod} {\n  float time = t * t * t * t * t;\n  return (end - start) * time + start;\n}\n`;\nconst easeOutQuintGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = 1.0 + t1 * t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n`;\nconst easeInOutQuintGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = t < 0.5 ? 16.0 * t * t * t * t * t : 1.0 + 16.0 * t1 * t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeOutElasticGPU = `\n$\\{easingMethod} {\n  float p = 0.3;\n  float time = pow(2.0, -10.0 * t) * sin((t - p / 4.0) * (2.0 * ${GPU_PI}) / p) + 1.0;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeBackInGPU = `\n$\\{easingMethod} {\n  float time = t * t * t - t * 1.05 * sin(t * ${GPU_PI});\n  return (end - start) * time + start;\n}\n`;\n\nconst easeBackOutGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float a = 1.7;\n  float time = (t1 * t1 * ((a + 1.0) * t1 + a) + 1.0);\n  return (end - start) * time + start;\n}\n`;\n\nconst easeBackInOutGPU = `\n$\\{easingMethod} {\n  float a = 1.4;\n  float a1 = a * 1.525;\n  float t1 = t / 0.5;\n  float t2 = t1 - 2.0;\n  float time =\n    (t1 < 1.0) ? 0.5 * (t1 * t1 * (a1 + 1.0) * t1 - a1) :\n    0.5 * (t2 * t2 * ((a1 + 1.0) * t2 + a1) + 2.0)\n  ;\n\n  return (end - start) * time + start;\n}\n`;\n\nconst continuousSinusoidalGPU = `\n$\\{easingMethod} {\n  $\\{T} direction = end - start;\n  float amplitude = length(direction) * 2.0;\n  return start + direction * sin(t * ${GPU_PI} * 2.0) * amplitude;\n}\n`;\n\n/**\n * Class of base AutoEasingMethods as well as helper constructs for making the methods.\n */\nexport class AutoEasingMethod<T extends InstanceIOValue>\n  implements IAutoEasingMethod<T> {\n  /**\n   * Autoeasing methods for linear easing\n   */\n  static immediate<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => end,\n      delay,\n      duration,\n      gpu: immediateGPU,\n      loop,\n      methodName: 'immediate',\n    };\n  }\n\n  /**\n   * Autoeasing methods for linear easing\n   */\n  static linear<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => {\n        const { add, scale, subtract } = VecMath(start);\n        t = clamp(t, 0, 1);\n        return add(scale(subtract(end, start), t), start);\n      },\n      delay,\n      duration,\n      gpu: linearGPU,\n      loop,\n      methodName: 'linear',\n    };\n  }\n\n  /**\n   * Auto easing for Accelerating to end\n   */\n  static easeInQuad<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeInQuadGPU,\n      loop,\n      methodName: 'easeInQuad',\n    };\n  }\n\n  /**\n   * Auto easing for decelerating to end\n   */\n  static easeOutQuad<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = t * (2 - t);\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeOutQuadGPU,\n      loop,\n      methodName: 'easeOutQuad',\n    };\n  }\n\n  /**\n   * Auto easing for Accelerate to mid, then decelerate to end\n   */\n  static easeInOutQuad<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeInOutQuadGPU,\n      loop,\n      methodName: 'easeInOutQuad',\n    };\n  }\n\n  /**\n   * Auto easing for Slower acceleration\n   */\n  static easeInCubic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeInCubicGPU,\n      loop,\n      methodName: 'easeInCubic',\n    };\n  }\n\n  /**\n   * Auto easing for Slower deceleration\n   */\n  static easeOutCubic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = --t * t * t + 1;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeOutCubicGPU,\n      loop,\n      methodName: 'easeOutCubic',\n    };\n  }\n\n  /**\n   * Auto easing for Slower acceleration to mid, and slower deceleration to end\n   */\n  static easeInOutCubic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time =\n          t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeInOutCubicGPU,\n      loop,\n      methodName: 'easeInOutCubic',\n    };\n  }\n\n  /**\n   * Auto easing for even Slower acceleration to end\n   */\n  static easeInQuart<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeInQuartGPU,\n      loop,\n      methodName: 'easeInQuart',\n    };\n  }\n\n  /**\n   * Auto easing for even Slower deceleration to end\n   */\n  static easeOutQuart<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = 1 - --t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeOutQuartGPU,\n      loop,\n      methodName: 'easeOutQuart',\n    };\n  }\n\n  /**\n   * Auto easing for even Slower acceleration to mid, and even slower deceleration to end\n   */\n  static easeInOutQuart<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeInOutQuartGPU,\n      loop,\n      methodName: 'easeInOutQuart',\n    };\n  }\n\n  /**\n   * Auto easing for super slow accelerating to the end\n   */\n  static easeInQuint<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = t * t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeInQuintGPU,\n      loop,\n      methodName: 'easeInQuint',\n    };\n  }\n\n  /**\n   * Auto easing for super slow decelerating to the end\n   */\n  static easeOutQuint<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = 1 + --t * t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeOutQuintGPU,\n      loop,\n      methodName: 'easeOutQuint',\n    };\n  }\n\n  /**\n   * Auto easing for super slow accelerating to mid and super slow decelerating to the end\n   */\n  static easeInOutQuint<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time =\n          t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeInOutQuintGPU,\n      loop,\n      methodName: 'easeInOutQuint',\n    };\n  }\n\n  /**\n   * Auto easing for elastic effect\n   */\n  static easeOutElastic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const p = 0.3;\n        const time = pow(2, -10 * t) * sin((t - p / 4) * (2 * PI) / p) + 1;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeOutElasticGPU,\n      loop,\n      methodName: 'easeOutElastic',\n    };\n  }\n\n  /**\n   * Auto easing for retracting first then shooting to the end\n   */\n  static easeBackIn<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const a = 1.05;\n        const time = t * t * t - t * a * sin(t * PI);\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeBackInGPU,\n      loop,\n      methodName: 'easeBackIn',\n    };\n  }\n\n  /**\n   * Auto easing for overshooting at the end\n   */\n  static easeBackOut<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const a = 1.7;\n        const t1 = t - 1;\n        const time = t1 * t1 * ((a + 1) * t1 + a) + 1;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeBackOutGPU,\n      loop,\n      methodName: 'easeBackOut',\n    };\n  }\n\n  /**\n   * Auto easing for overshooting at the end\n   */\n  static easeBackInOut<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const a = 1.7;\n        const a1 = a * 1.525;\n        const t1 = t / 0.5;\n        const t2 = t1 - 2;\n        const time =\n          t1 < 1\n            ? 0.5 * (t1 * t1 * (a1 + 1) * t1 - a1)\n            : 0.5 * (t2 * t2 * ((a1 + 1) * t2 + a1) + 2);\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeBackInOutGPU,\n      loop,\n      methodName: 'easeBackInOut',\n    };\n  }\n\n  /**\n   * This is an easing method that performs a sinusoidal wave where the amplitude is\n   * (start - end) * 2 and the wave starts at the start value.\n   *\n   * This is intended to work best with the CONTINUOUS loop style.\n   */\n  static continuousSinusoidal<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.CONTINUOUS,\n  ): IAutoEasingMethod<T> {\n    return {\n      cpu: (start: T, end: T, t: number) => {\n        const { add, length, scale, subtract } = VecMath(start);\n        t = clamp(t, 0, 1);\n        const direction = subtract(end, start);\n        const amplitude = length(direction) * 2.0;\n        return add(start, scale(direction, sin(t * PI * 2) * amplitude));\n      },\n      delay,\n      duration,\n      gpu: continuousSinusoidalGPU,\n      loop,\n      methodName: 'repeatingSinusoidal',\n\n      // Since this is sinusoidial and operates off of a continuous time structure\n      validation: {\n        // When time = 1 our value will = start and NOT end\n        ignoreEndValueCheck: true,\n        // When the time is > 1 our value will not clamp to the value at 1.\n        ignoreOverTimeCheck: true,\n      },\n    };\n  }\n\n  /** The easing method for the cpu */\n  cpu: IAutoEasingMethod<T>['cpu'];\n  /** Time before a delay  */\n  delay: number = 0;\n  /** The time in ms is takes to complete the animation */\n  duration: number = 500;\n  /** The easing method on the GPU */\n  gpu: IAutoEasingMethod<T>['gpu'];\n  /** The looping style of the animation */\n  loop = AutoEasingLoopStyle.NONE;\n  /** Method name of the ease function on the gpu */\n  methodName: string;\n\n  constructor(\n    cpu: IAutoEasingMethod<T>['cpu'],\n    gpu: IAutoEasingMethod<T>['gpu'],\n    duration?: number,\n    method?: string,\n  ) {\n    this.cpu = cpu;\n    this.gpu = gpu;\n    this.duration = duration || 500;\n    this.methodName = method || 'easingMethod';\n  }\n}\n","import { Bounds } from '../primitives';\nimport { IProjection } from '../types';\nimport {\n  IDragMetrics,\n  IMouseInteraction,\n  IWheelMetrics,\n  MouseEventManager,\n} from './mouse-event-manager';\nimport { View } from './view';\n\n/**\n * Classes can extend this and override the methods to respond to events.\n */\nexport abstract class EventManager {\n  private mouseManager: MouseEventManager;\n\n  abstract handleMouseDown(e: IMouseInteraction, button: number): void;\n  abstract handleMouseUp(e: IMouseInteraction, button: number): void;\n  abstract handleMouseOver(e: IMouseInteraction): void;\n  abstract handleMouseOut(e: IMouseInteraction): void;\n  abstract handleMouseMove(e: IMouseInteraction): void;\n  abstract handleClick(e: IMouseInteraction, button: number): void;\n  abstract handleDrag(e: IMouseInteraction, drag: IDragMetrics): void;\n  abstract handleWheel(e: IMouseInteraction, wheel: IWheelMetrics): void;\n\n  /**\n   * This retrieves the projections for the view specified by the provided viewId.\n   */\n  getProjection(viewId: string): IProjection | null {\n    return this.mouseManager.getView(viewId);\n  }\n\n  /**\n   * This retrieves the actual view for the view specified by the provided viewId.\n   */\n  getView(viewId: string): View | null {\n    return (this.mouseManager && this.mouseManager.getView(viewId)) || null;\n  }\n\n  /**\n   * This retrieves the screen bounds for the view specified by the provided viewId.\n   */\n  getViewScreenBounds(viewId: string): Bounds | null {\n    const view = this.mouseManager.getView(viewId);\n\n    if (view) {\n      return view.screenBounds;\n    }\n\n    return null;\n  }\n\n  /**\n   * This is used internally which provides the parent MouseEventManager via the param mouseManager for this\n   * EventManager.\n   */\n  setMouseManager(mouseManager: MouseEventManager) {\n    this.mouseManager = mouseManager;\n  }\n}\n","import { IPoint } from '../primitives/point';\nimport { DataBounds } from '../util/data-bounds';\nimport { eventElementPosition, normalizeWheel } from '../util/mouse';\nimport { QuadTree } from '../util/quad-tree';\nimport { EventManager } from './event-manager';\nimport { Scene } from './scene';\nimport { View } from './view';\n\n// If a mouse up after a mouse down happens before this many milliseconds, a click gesture will happen\nconst VALID_CLICK_DELAY = 1e3;\n\n/**\n * Theorectically we can have a view be applied to multiple scenes. So to properly qualify a view\n * it must be paired with the scene it is rendering for.\n */\nexport type SceneView = {\n  /** This specifies the order the view is rendered in so we can pick the top most item when needed */\n  depth: number;\n  /** This is the scene the view is rendering for */\n  scene: Scene;\n  /** This is the view itself that our mouse will interact with */\n  view: View;\n  /** Gets the bounds of this view for this particular scene */\n  bounds?: DataBounds<SceneView>;\n};\n\n/**\n * This represents an interaction with the Layer Surface. It provides mouse metrics with how the mouse\n * interacts with the views below it.\n */\nexport interface IMouseInteraction {\n  /** When present indicates any relevant button codes used during a click event */\n  button?: number;\n  /** Metrics of the interaction in screen space */\n  screen: {\n    mouse: IPoint;\n  };\n  /** The View the mouse was 'down' on */\n  start?: {\n    mouse: IPoint;\n    view: View;\n  };\n  /** The View Immediately underneath the mouse */\n  target: {\n    mouse: IPoint;\n    view: View;\n  };\n  /** This is populated with ALL of the views underneath the mouse */\n  viewsUnderMouse: {\n    /** The mouse's location in the views coordinate space */\n    mouse: IPoint;\n    /** The view that is interacted with */\n    view: View;\n  }[];\n}\n\nexport interface IDragMetrics {\n  /** Drag metrics in screen space */\n  screen: {\n    /** The start position of the drag where the mouse down first occurred */\n    start: IPoint;\n    /** The previous position of the mouse last frame */\n    previous: IPoint;\n    /** The current position the mouse is located for this frame */\n    current: IPoint;\n    /** The change in position from last frame to this frame */\n    delta: IPoint;\n  };\n}\n\nexport interface IWheelMetrics {\n  wheel: [number, number];\n}\n\n/**\n * This is metrics measured between two touches\n */\nexport interface ITouchRelation {\n  /** The direction to the other touch */\n  direction: IPoint;\n  /** The current distance to the other touch */\n  distance: number;\n  /** The id of the other touch */\n  id: number;\n}\n\n/**\n * This is the information of a touch for a given frame.\n */\nexport interface ITouchFrame {\n  /** This is the location or delta location of the touch for this frame */\n  location: IPoint;\n  /** This is the direction from the start touch frame */\n  direction: IPoint;\n  /** This is the metrics or delta metrics of the touch relative to the other touches for the frame */\n  relations: Map<number, ITouchRelation>;\n}\n\nexport interface ITouchMetrics {\n  /** The starting metrics of the touch */\n  start: ITouchFrame;\n  /** The delta changes from previous event to the current event */\n  delta: ITouchFrame;\n  /** The current metrics of the touch event */\n  current: ITouchFrame;\n}\n\nfunction sortByDepth(a: DataBounds<SceneView>, b: DataBounds<SceneView>) {\n  return b.data.depth - a.data.depth;\n}\n\nfunction isDefined<T>(val: T | null | undefined): val is T {\n  return Boolean(val);\n}\n\n/**\n * This manages mouse events on the provided canvas and provides some higher level\n * interactions with the surface.\n */\nexport class MouseEventManager {\n  /** This is the canvas context we are rendering to */\n  context: HTMLCanvasElement;\n  /** This is list of Event Managers that receive the events and gestures which perform the nexessary actions */\n  controllers: EventManager[];\n  /** This is the quad tree for finding intersections with the mouse */\n  quadTree: QuadTree<DataBounds<SceneView>>;\n  /** This is the current list of views being managed */\n  views: SceneView[];\n\n  eventCleanup: [string, EventListenerOrEventListenerObject][] = [];\n\n  /**\n   * This flag is set when the system is waiting to render the elements to establish bounds.\n   * No Mouse interations will happen while this is set to true.\n   */\n  private _waitingForRender: boolean = true;\n\n  get waitingForRender() {\n    return this._waitingForRender;\n  }\n\n  set waitingForRender(val: boolean) {\n    this._waitingForRender = val;\n\n    // When we're no longer waiting for render to occur we update all of our views in the quad tree\n    if (!val) {\n      this.quadTree = new QuadTree(0, 0, 0, 0);\n      this.quadTree.addAll(this.views.map(v => v.bounds).filter(isDefined));\n    }\n  }\n\n  constructor(\n    canvas: HTMLCanvasElement,\n    views: SceneView[],\n    controllers: EventManager[],\n    handlesWheelEvents?: boolean,\n  ) {\n    this.context = canvas;\n    this.setViews(views);\n    this.setControllers(controllers);\n    this.addContextListeners(handlesWheelEvents);\n  }\n\n  /**\n   * This sets up the DOM events to listen to the events that are broadcasted by the canvas.\n   * These events are set up in such a way as to continue some events when the user\n   * drags the mouse off of the browser or off the canvas without releasing.\n   */\n  addContextListeners(handlesWheelEvents?: boolean) {\n    const element = this.context;\n    let startView: SceneView | undefined;\n    let startPosition: IPoint | undefined;\n\n    if (handlesWheelEvents) {\n      const wheelHandler = (event: MouseWheelEvent) => {\n        const mouse = eventElementPosition(event, element);\n        const interaction = this.makeInteraction(\n          mouse,\n          startPosition,\n          startView,\n        );\n        const wheel = this.makeWheel(event);\n\n        this.controllers.forEach(controller => {\n          controller.handleWheel(interaction, wheel);\n        });\n\n        event.stopPropagation();\n        event.preventDefault();\n      };\n\n      if ('onwheel' in element) {\n        element.onwheel = wheelHandler;\n      }\n\n      if ('addEventListener' in element) {\n        element.addEventListener('DOMMouseScroll', wheelHandler);\n        this.eventCleanup.push(['DOMMouseScroll', wheelHandler]);\n      }\n    }\n\n    element.onmouseleave = event => {\n      // No interactions while waiting for the render to update\n      if (this.waitingForRender) return;\n\n      const mouse = eventElementPosition(event, element);\n      const interaction = this.makeInteraction(mouse, startPosition, startView);\n\n      this.controllers.forEach(controller => {\n        controller.handleMouseOut(interaction);\n      });\n    };\n\n    element.onmousemove = event => {\n      // No interactions while waiting for the render to update\n      if (this.waitingForRender) return;\n\n      const mouse = eventElementPosition(event, element);\n      const interaction = this.makeInteraction(mouse, startPosition, startView);\n\n      this.controllers.forEach(controller => {\n        controller.handleMouseMove(interaction);\n      });\n    };\n\n    element.onmousedown = (event: MouseEvent) => {\n      // No interactions while waiting for the render to update\n      if (this.waitingForRender) return;\n\n      startPosition = eventElementPosition(event, element);\n      const downViews = this.getViewsUnderMouse(startPosition);\n      // While this is true, when mouse up happens, the click gesture will execute\n      let canClick = true;\n      const clickStartTime = Date.now();\n\n      // If no views under this view, then we just quick exit with no interactions\n      if (downViews.length <= 0) {\n        return;\n      }\n\n      startView = downViews[0].data;\n      const interaction = this.makeInteraction(\n        startPosition,\n        startPosition,\n        startView,\n      );\n      let currentPosition = startPosition;\n\n      this.controllers.forEach(controller => {\n        controller.handleMouseDown(interaction, event.button);\n      });\n\n      event.stopPropagation();\n\n      document.onmousemove = (event: MouseEvent) => {\n        const mouse = eventElementPosition(event, element);\n        const interaction = this.makeInteraction(\n          mouse,\n          startPosition,\n          startView,\n        );\n        const delta = {\n          x: mouse.x - currentPosition.x,\n          y: mouse.y - currentPosition.y,\n        };\n\n        const drag = this.makeDrag(\n          mouse,\n          startPosition || { x: 0, y: 0 },\n          currentPosition,\n          delta,\n        );\n        currentPosition = mouse;\n\n        this.controllers.forEach(controller => {\n          controller.handleDrag(interaction, drag);\n        });\n\n        // If we move after a mouse down, it's no longer a click\n        canClick = false;\n      };\n\n      document.onmouseup = (event: MouseEvent) => {\n        document.onmousemove = null;\n        document.onmouseup = null;\n        document.onmouseover = null;\n      };\n\n      document.onmouseover = (event: MouseEvent) => {\n        const mouse = eventElementPosition(event, element);\n        const interaction = this.makeInteraction(\n          mouse,\n          startPosition,\n          startView,\n        );\n\n        this.controllers.forEach(controller => {\n          controller.handleMouseOver(interaction);\n        });\n\n        event.stopPropagation();\n      };\n\n      element.onmouseup = (event: MouseEvent) => {\n        const mouse = eventElementPosition(event, element);\n        const interaction = this.makeInteraction(\n          mouse,\n          startPosition,\n          startView,\n        );\n\n        this.controllers.forEach(controller => {\n          controller.handleMouseUp(interaction, event.button);\n        });\n\n        // If we release the mouse before the valid click delay\n        if (canClick && Date.now() - clickStartTime < VALID_CLICK_DELAY) {\n          this.controllers.forEach(controller => {\n            controller.handleClick(interaction, event.button);\n          });\n        }\n      };\n\n      // Text will not be selected when it is being dragged\n      element.onselectstart = function() {\n        return false;\n      };\n    };\n\n    // Enable touch support\n    this.addTouchContextListeners();\n  }\n\n  addTouchContextListeners() {\n    const element = this.context;\n\n    element.ontouchstart = event => {\n      // TODO: This is the start work for the touch events. And this retains sentimental value.\n      // For (let i = 0, end = event.changedTouches.length; i < end; ++i) {\n      // TODO\n      // Const touch = event.changedTouches.item(i);\n      // CurrentTouches.set(touch.identifier, to);\n      // }\n    };\n\n    element.ontouchend = event => {\n      // TODO\n    };\n\n    element.ontouchmove = event => {\n      // TODO\n    };\n\n    element.ontouchcancel = event => {\n      // TODO\n    };\n  }\n\n  /**\n   * Retrieves the view for the provided id\n   */\n  getView(viewId: string): View | null {\n    for (const view of this.views) {\n      if (view.view.id === viewId) {\n        return view.view;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Retrieves the views underneath the mouse with the top most view as\n   * the first view in the list.\n   */\n  getViewsUnderMouse = (mouse: IPoint) => {\n    // Find the views the mouse has interacted with\n    const hitViews = this.quadTree.query(mouse);\n    // Sort them by depth\n    hitViews.sort(sortByDepth);\n\n    return hitViews;\n  }\n\n  /**\n   * This generates the metrics for a drag gesture.\n   */\n  makeDrag(\n    mouse: IPoint,\n    start: IPoint,\n    previous: IPoint,\n    delta: IPoint,\n  ): IDragMetrics {\n    return {\n      screen: {\n        current: mouse,\n        delta,\n        previous,\n        start,\n      },\n    };\n  }\n\n  /**\n   * This makes the metrics for interactions with the views.\n   */\n  makeInteraction(\n    mouse: IPoint,\n    start?: IPoint,\n    startView?: SceneView,\n  ): IMouseInteraction {\n    // Find the views the mouse has interacted with\n    const hitViews = this.getViewsUnderMouse(mouse);\n\n    return {\n      screen: {\n        mouse,\n      },\n      start: start &&\n        startView && {\n          mouse: startView.view.screenToView(mouse),\n          view: startView.view,\n        },\n      target: {\n        mouse: hitViews[0] && hitViews[0].data.view.screenToView(mouse),\n        view: hitViews[0] && hitViews[0].data.view,\n      },\n      viewsUnderMouse: hitViews.map(v => ({\n        mouse: v.data.view.screenToView(mouse),\n        view: v.data.view,\n      })),\n    };\n  }\n\n  makeWheel(event: MouseWheelEvent): IWheelMetrics {\n    const wheel = normalizeWheel(event);\n\n    return {\n      wheel: [wheel.x, wheel.y],\n    };\n  }\n\n  /**\n   * When the renderer is resized, we must reform our quad tree\n   */\n  resize = () => {\n    this._waitingForRender = true;\n  }\n\n  /**\n   * Sets the controllers to receive events from this manager.\n   */\n  setControllers(controllers: EventManager[]) {\n    this.controllers = controllers;\n\n    for (const controller of this.controllers) {\n      controller.setMouseManager(this);\n    }\n  }\n\n  /**\n   * Sets the views that gets queried for interactions.\n   */\n  setViews(views: SceneView[]) {\n    this.views = views;\n  }\n\n  destroy() {\n    delete this.quadTree;\n    this.context.onmousedown = null;\n    this.context.onmousemove = null;\n    this.context.onmouseleave = null;\n    this.context.onmousewheel = null;\n\n    this.eventCleanup.forEach(event => {\n      this.context.removeEventListener(event[0], event[1]);\n    });\n  }\n}\n","/**\n * This file is dedicted to the all important step of processing desired inputs from the layer\n * and coming up with automated generated uniforms and attributes that the shader's will need\n * in order to operate with the conveniences the library offers. This includes things such as\n * injecting camera projection uniforms, resource uniforms, animation adjustments etc etc.\n */\nimport * as Three from 'three';\nimport { Instance } from '../../instance-provider/instance';\nimport {\n  IAtlasInstanceAttribute,\n  IEasingInstanceAttribute,\n  IEasingProps,\n  IInstanceAttribute,\n  InstanceAttributeSize,\n  InstanceBlockIndex,\n  IUniform,\n  IUniformInternal,\n  IValueInstanceAttribute,\n  IVertexAttribute,\n  IVertexAttributeInternal,\n  PickType,\n  ShaderInjectionTarget,\n  UniformSize,\n  VertexAttributeSize,\n} from '../../types';\nimport { uid, Vec } from '../../util';\nimport { AutoEasingLoopStyle } from '../../util/auto-easing-method';\nimport { ILayerProps, IShaderInitialization, Layer } from '../layer';\nimport { getLayerBufferType, LayerBufferType } from './layer-buffer-type';\n\nconst { abs } = Math;\n\n/**\n * This is a lookup for a test vector for the provided size\n */\nconst testStartVector: { [key: number]: Vec } = {\n  [InstanceAttributeSize.ONE]: [1],\n  [InstanceAttributeSize.TWO]: [1, 2],\n  [InstanceAttributeSize.THREE]: [1, 2, 3],\n  [InstanceAttributeSize.FOUR]: [1, 2, 3, 4],\n};\n\n/**\n * This is a lookup for a test vector for the provided size\n */\nconst testEndVector: { [key: number]: Vec } = {\n  [InstanceAttributeSize.ONE]: [4],\n  [InstanceAttributeSize.TWO]: [4, 3],\n  [InstanceAttributeSize.THREE]: [4, 3, 2],\n  [InstanceAttributeSize.FOUR]: [4, 3, 2, 1],\n};\n\nconst emptyTexture = new Three.Texture();\n\nfunction isAtlasAttribute<T extends Instance>(\n  attr: any,\n): attr is IAtlasInstanceAttribute<T> {\n  return Boolean(attr) && attr.atlas;\n}\n\nfunction isEasingAttribute<T extends Instance>(\n  attr: any,\n): attr is IEasingInstanceAttribute<T> {\n  return Boolean(attr) && attr.easing && attr.size !== undefined;\n}\n\nfunction isInstanceAttribute<T extends Instance>(\n  attr: any,\n): attr is IInstanceAttribute<T> {\n  return Boolean(attr);\n}\n\nfunction isVertexAttribute(attr: any): attr is IVertexAttribute {\n  return Boolean(attr);\n}\n\nfunction isUniform(attr: any): attr is IUniform {\n  return Boolean(attr);\n}\n\nfunction toVertexAttributeInternal(\n  attribute: IVertexAttribute,\n): IVertexAttributeInternal {\n  return Object.assign({}, attribute, { materialAttribute: null });\n}\n\nfunction toUniformInternal(uniform: IUniform): IUniformInternal {\n  return Object.assign({}, uniform, { materialUniforms: [] });\n}\n\n/**\n * This finds a block and an index that can accomodate a provided size\n * @param attributes\n * @param seekingSize\n */\nfunction findEmptyBlock(\n  attributes: IInstanceAttribute<any>[],\n  seekingSize?: InstanceAttributeSize,\n): [number, InstanceBlockIndex] {\n  const usedBlocks: any[] = [];\n  let maxBlock = 0;\n  if (seekingSize === undefined) {\n    seekingSize = 1;\n  }\n\n  attributes.forEach(instanceAttribute => {\n    const block = instanceAttribute.block;\n    const index: number =\n      instanceAttribute.blockIndex === undefined\n        ? 0\n        : instanceAttribute.blockIndex;\n    const size: number =\n      instanceAttribute.size === undefined ? 0 : instanceAttribute.size;\n\n    maxBlock = Math.max(block, maxBlock);\n\n    while (usedBlocks.length - 1 < block) {\n      usedBlocks.push([false, false, false, false]);\n    }\n\n    for (let i = index - 1, end = index - 1 + size; i < end; ++i) {\n      usedBlocks[block][i] = true;\n    }\n  });\n\n  for (let x = 0; x < usedBlocks.length; x++) {\n    for (let ind = 0; ind < 4; ind++) {\n      if (usedBlocks[x][ind]) {\n        continue;\n      } else {\n        for (let breadth = ind; breadth < 4; breadth++) {\n          if (!usedBlocks[x][breadth]) {\n            if (breadth - ind + 1 === seekingSize) {\n              return [x, ind + 1];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // If no block was ever found, then we take the max block detected and make\n  // A new block after it\n  return [maxBlock + 1, InstanceBlockIndex.ONE];\n}\n\n/**\n * This sorts the attributes such that the attributes that MUST be updated first are put to the top.\n * This is necessary for complex attributes like atlas and easing attributes who have other attributes\n * that have dependent behaviors based on their source attribute.\n */\nfunction sortNeedsUpdateFirstToTop<T extends Instance>(\n  a: IInstanceAttribute<T>,\n  b: IInstanceAttribute<T>,\n) {\n  if (a.atlas && !b.atlas) return -1;\n  if (a.easing && !b.easing) return -1;\n  return 1;\n}\n\n/**\n * This generates any uniforms needed for when a layer is requesting\n */\nfunction generateAtlasResourceUniforms<\n  T extends Instance,\n  U extends ILayerProps<T>\n>(layer: Layer<T, U>, instanceAttributes: IInstanceAttribute<T>[]) {\n  // Retrieve all of the instance attributes that are atlas references\n  const atlasInstanceAttributes: IAtlasInstanceAttribute<T>[] = [];\n  // Key: The atlas uniform name requested\n  const requestedAtlasInjections = new Map<string, [boolean, boolean]>();\n\n  // Get the atlas requests that have unique names. We only need one uniform\n  // For a single unique provided name. We also must merge the requests for\n  // Vertex and fragment injections\n  instanceAttributes.forEach(\n    (attribute: IValueInstanceAttribute<T> | IAtlasInstanceAttribute<T>) => {\n      if (isAtlasAttribute(attribute)) {\n        // Auto set the size of the attribute. Attribute's that are a resource automatically\n        // Consume a size of four\n        attribute.size = InstanceAttributeSize.FOUR;\n        attribute.blockIndex = InstanceBlockIndex.ONE;\n        // Get the atlas resource uniform (sampler2D) injection targets. We default to only the\n        // Fragment shader as it's the most commonly used location for sampler2Ds\n        const injection: number =\n          attribute.atlas.shaderInjection || ShaderInjectionTarget.FRAGMENT;\n        // See if we already have an injection for the given injected uniform name for an atlas resource.\n        const injections = requestedAtlasInjections.get(attribute.atlas.name);\n\n        if (injections) {\n          requestedAtlasInjections.set(attribute.atlas.name, [\n            injections[0] ||\n              injection === ShaderInjectionTarget.VERTEX ||\n              injection === ShaderInjectionTarget.ALL,\n            injections[1] ||\n              injection === ShaderInjectionTarget.FRAGMENT ||\n              injection === ShaderInjectionTarget.ALL,\n          ]);\n        } else {\n          atlasInstanceAttributes.push(attribute);\n          requestedAtlasInjections.set(attribute.atlas.name, [\n            injection === ShaderInjectionTarget.VERTEX ||\n              injection === ShaderInjectionTarget.ALL,\n            injection === ShaderInjectionTarget.FRAGMENT ||\n              injection === ShaderInjectionTarget.ALL,\n          ]);\n        }\n      }\n    },\n  );\n\n  // Make uniforms for all of the unique atlas requests.\n  return atlasInstanceAttributes.map(instanceAttribute => {\n    let injection: ShaderInjectionTarget = ShaderInjectionTarget.FRAGMENT;\n\n    if (instanceAttribute.atlas) {\n      const injections = requestedAtlasInjections.get(\n        instanceAttribute.atlas.name,\n      );\n\n      if (injections) {\n        injection =\n          (injections[0] && injections[1] && ShaderInjectionTarget.ALL) ||\n          (injections[0] && !injections[1] && ShaderInjectionTarget.VERTEX) ||\n          (!injections[0] && injections[1] && ShaderInjectionTarget.FRAGMENT) ||\n          injection;\n      }\n    }\n\n    return {\n      name: instanceAttribute.atlas.name,\n      shaderInjection: injection,\n      size: UniformSize.ATLAS,\n      update: () =>\n        layer.resource.getAtlasTexture(instanceAttribute.atlas.key) ||\n        emptyTexture,\n    };\n  });\n}\n\n/**\n * This modifies the instance attributes in a way that produces enough attributes to handle the easing equations\n * being performed on the gpu.\n */\nfunction generateEasingAttributes<T extends Instance, U extends ILayerProps<T>>(\n  layer: Layer<T, U>,\n  instanceAttributes: IInstanceAttribute<T>[],\n) {\n  const easingAttributes: IEasingInstanceAttribute<T>[] = [];\n\n  // We gather all of the easing attributes first so we can modify the attribute array\n  // On next pass\n  for (const attribute of instanceAttributes) {\n    if (isEasingAttribute(attribute)) {\n      easingAttributes.push(attribute);\n    }\n  }\n\n  // Now loop through each easing attribute and generate attributes needed for the easing method\n  for (const attribute of easingAttributes) {\n    const { cpu: easing, loop } = attribute.easing;\n    const { name, size, update } = attribute;\n    const easingUID = uid();\n\n    // We keep this in a scope above the update as we utilize the fact that the attributes will update\n    // In order for a single instance to our advantage.\n    let easingValues: IEasingProps;\n\n    // Hijack the update from the attribute to a new update method which will\n    // Be able to interact with the values for the easing methodology\n    attribute.update = o => {\n      // We retrieve properties that we want to be dynamic from the easing equation\n      const { delay, duration } = attribute.easing;\n      // First get the value that is to be our new destination\n      const end = update(o);\n      const currentTime = layer.surface.frameMetrics.currentTime;\n\n      // Get the easing values specific to an instance\n      easingValues = o.easing.get(easingUID) || {\n        duration,\n        end,\n        start: end,\n        startTime: currentTime,\n      };\n\n      // Previous position time value\n      let timeValue = 1;\n\n      switch (loop) {\n        // Continuous means we start at 0 and let the time go to infinity\n        case AutoEasingLoopStyle.CONTINUOUS:\n          timeValue = (currentTime - easingValues.startTime) / duration;\n          break;\n\n        // Repeat means going from 0 to 1 then 0 to 1 etc etc\n        case AutoEasingLoopStyle.REPEAT:\n          timeValue = ((currentTime - easingValues.startTime) / duration) % 1;\n          break;\n\n        // Reflect means going from 0 to 1 then 1 to 0 then 0 to 1 etc etc\n        case AutoEasingLoopStyle.REFLECT:\n          const timePassed = (currentTime - easingValues.startTime) / duration;\n          // This is a triangle wave for an input\n          timeValue = abs((timePassed / 2.0) % 1 - 0.5) * 2.0;\n          break;\n\n        // No loop means just linear time\n        case AutoEasingLoopStyle.NONE:\n        default:\n          timeValue = (currentTime - easingValues.startTime) / duration;\n          break;\n      }\n\n      // Now get the value of where our instance currently is located this frame\n      easingValues.start = easing(\n        easingValues.start,\n        easingValues.end,\n        timeValue,\n      );\n      // Set the current time as the start time of our animation\n      easingValues.startTime = currentTime + delay;\n      // Set the provided value as our destination\n      easingValues.end = end;\n      // Make sure the instance contains the current easing values\n      o.easing.set(easingUID, easingValues);\n\n      return end;\n    };\n\n    // The attribute is going to generate some child attributes\n    attribute.childAttributes = [];\n\n    // Find a slot available for our new start value\n    let slot = findEmptyBlock(instanceAttributes, size);\n    const startAttr: IInstanceAttribute<T> = {\n      block: slot[0],\n      blockIndex: slot[1],\n      name: `_${name}_start`,\n      parentAttribute: attribute,\n      size,\n      update: o => easingValues.start,\n    };\n\n    attribute.childAttributes.push(startAttr);\n    instanceAttributes.push(startAttr);\n\n    // Find a slot available for our new start time\n    slot = findEmptyBlock(instanceAttributes, InstanceAttributeSize.ONE);\n    const startTimeAttr: IInstanceAttribute<T> = {\n      block: slot[0],\n      blockIndex: slot[1],\n      name: `_${name}_start_time`,\n      parentAttribute: attribute,\n      size: InstanceAttributeSize.ONE,\n      update: o => [easingValues.startTime],\n    };\n\n    attribute.childAttributes.push(startTimeAttr);\n    instanceAttributes.push(startTimeAttr);\n\n    // Find a slot available for our duration\n    slot = findEmptyBlock(instanceAttributes, InstanceAttributeSize.ONE);\n    const durationAttr: IInstanceAttribute<T> = {\n      block: slot[0],\n      blockIndex: slot[1],\n      name: `_${name}_duration`,\n      parentAttribute: attribute,\n      size: InstanceAttributeSize.ONE,\n      update: o => [easingValues.duration],\n    };\n\n    attribute.childAttributes.push(durationAttr);\n    instanceAttributes.push(durationAttr);\n  }\n}\n\nfunction generatePickingUniforms<T extends Instance, U extends ILayerProps<T>>(\n  layer: Layer<T, U>,\n): IUniform[] {\n  if (layer.picking.type === PickType.SINGLE) {\n    return [\n      {\n        name: 'pickingActive',\n        shaderInjection: ShaderInjectionTarget.ALL,\n        size: UniformSize.ONE,\n        update: () => [\n          layer.picking.currentPickMode === PickType.SINGLE ? 1.0 : 0.0,\n        ],\n      },\n    ];\n  }\n\n  return [];\n}\n\nfunction generatePickingAttributes<\n  T extends Instance,\n  U extends ILayerProps<T>\n>(\n  layer: Layer<T, U>,\n  instanceAttributes: IInstanceAttribute<T>[],\n): IInstanceAttribute<T>[] {\n  if (layer.picking.type === PickType.SINGLE) {\n    // Find a compltely empty block within all instance attributes provided and injected\n    const emptyFillBlock = findEmptyBlock(\n      instanceAttributes,\n      InstanceAttributeSize.FOUR,\n    );\n\n    return [\n      {\n        block: emptyFillBlock[0],\n        blockIndex: emptyFillBlock[1],\n        name: '_pickingColor',\n        size: InstanceAttributeSize.FOUR,\n        update: o => {\n          // We start from white and move down so the colors are more visible\n          // For debugging\n          const color = 0xffffff - o.uid;\n\n          // Do bit maths do get float components out of the int color\n          return [\n            (color >> 16) / 255.0,\n            ((color & 0x00ff00) >> 8) / 255.0,\n            (color & 0x0000ff) / 255.0,\n            1,\n          ];\n        },\n      },\n    ];\n  }\n\n  return [];\n}\n\nfunction generateBaseUniforms<T extends Instance, U extends ILayerProps<T>>(\n  layer: Layer<T, U>,\n): IUniform[] {\n  return [\n    // This injects the projection matrix from the view camera\n    {\n      name: 'projection',\n      size: UniformSize.MATRIX4,\n      update: () => layer.view.viewCamera.baseCamera.projectionMatrix.elements,\n    },\n    // This injects the model view matrix from the view camera\n    {\n      name: 'modelView',\n      size: UniformSize.MATRIX4,\n      update: () => layer.view.viewCamera.baseCamera.matrix.elements,\n    },\n    // This injects the camera offset uniforms that need to be present for projecting in a more\n    // Chart centric style\n    {\n      name: 'cameraOffset',\n      size: UniformSize.THREE,\n      update: () => layer.view.camera.offset,\n    },\n    // This injects the camera scaling uniforms that need to be present for projecting in a more\n    // Chart centric style\n    {\n      name: 'cameraScale',\n      size: UniformSize.THREE,\n      update: () => layer.view.camera.scale,\n    },\n    // This injects the camera scaling uniforms that need to be present for projecting in a more\n    // Chart centric style\n    {\n      name: 'viewSize',\n      size: UniformSize.TWO,\n      update: () => [layer.view.viewBounds.width, layer.view.viewBounds.height],\n    },\n    // This injects the current layer's pixel ratio so pixel ratio dependent items can react to it\n    // Things like gl_PointSize will need this metric if not working in clip space\n    {\n      name: 'pixelRatio',\n      size: UniformSize.ONE,\n      update: () => [layer.view.pixelRatio],\n    },\n    // This will be the current frame's current time which is updated in the layer's surface draw call\n    {\n      name: 'currentTime',\n      size: UniformSize.ONE,\n      update: () => [layer.surface.frameMetrics.currentTime],\n    },\n  ];\n}\n\n/**\n * This creates the base instance attributes that are ALWAYS present\n */\nfunction generateBaseInstanceAttributes<T extends Instance>(\n  layer: Layer<T, any>,\n  instanceAttributes: IInstanceAttribute<T>[],\n): IInstanceAttribute<T>[] {\n  const fillBlock = findEmptyBlock(\n    instanceAttributes,\n    InstanceAttributeSize.ONE,\n  );\n\n  // This is injected so the system can control when an instance should not be rendered.\n  // This allows for holes to be in the buffer without having to correct them immediately\n  const activeAttribute: IInstanceAttribute<T> = {\n    block: fillBlock[0],\n    blockIndex: fillBlock[1],\n    name: '_active',\n    size: InstanceAttributeSize.ONE,\n    update: o => [o.active ? 1 : 0],\n  };\n\n  // Set the active attribute to the layer for quick reference\n  layer.activeAttribute = activeAttribute;\n\n  return [activeAttribute];\n}\n\n/**\n * This creates the base vertex attributes that are ALWAYS present\n */\nfunction generateBaseVertexAttributes<T extends Instance>(\n  layer: Layer<T, any>,\n): IVertexAttribute[] {\n  // Only the uniform buffering strategy requires instance information in it's vertex attributes\n  if (layer.bufferType === LayerBufferType.UNIFORM) {\n    return [\n      // We add an inherent instance attribute to our vertices so they can determine the instancing\n      // Data to retrieve.\n      {\n        name: 'instance',\n        size: VertexAttributeSize.ONE,\n        // We no op this as our geomtry generating routine will establish the values needed here\n        update: () => [0],\n      },\n    ];\n  }\n\n  return [];\n}\n\nfunction compareVec(a: Vec, b: Vec) {\n  if (a.length !== b.length) return false;\n\n  for (let i = 0, end = a.length; i < end; ++i) {\n    if (Math.round(a[i] * 100) / 100 !== Math.round(b[i] * 100) / 100) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction validateInstanceAttributes<T extends Instance>(\n  layer: Layer<T, any>,\n  instanceAttributes: IInstanceAttribute<T>[],\n  vertexAttributes: IVertexAttribute[],\n) {\n  instanceAttributes.forEach(attribute => {\n    if (attribute.name === undefined) {\n      console.warn(\n        'All instance attributes MUST have a name on Layer:',\n        layer.id,\n      );\n    }\n\n    if (\n      instanceAttributes.find(\n        attr => attr !== attribute && attr.name === attribute.name,\n      )\n    ) {\n      console.warn(\n        'An instance attribute can not have the same name used more than once:',\n        attribute.name,\n      );\n    }\n\n    if (vertexAttributes.find(attr => attr.name === attribute.name)) {\n      console.warn(\n        'An instance attribute and a vertex attribute in a layer can not share the same name:',\n        attribute.name,\n      );\n    }\n\n    if (attribute.easing && attribute.atlas) {\n      console.warn(\n        'An instance attribute can not have both easing and atlas properties. Undefined behavior will occur.',\n      );\n      console.warn(attribute);\n    }\n\n    if (!attribute.atlas) {\n      if (attribute.size === undefined) {\n        console.warn('An instance attribute requires the size to be defined.');\n        console.warn(attribute);\n      }\n    }\n\n    if (attribute.easing) {\n      if (attribute.size !== undefined) {\n        const testStart = testStartVector[attribute.size];\n        const testEnd = testEndVector[attribute.size];\n        const validationRules = attribute.easing.validation || {};\n\n        let test = attribute.easing.cpu(testStart, testEnd, 0);\n        if (!compareVec(test, testStart)) {\n          console.warn(\n            'Auto Easing Validation Failed: using a time of 0 does not produce the start value',\n          );\n          console.warn('Start:', testStart, 'End:', testEnd, 'Result:', test);\n          console.warn(attribute);\n        }\n\n        test = attribute.easing.cpu(testStart, testEnd, 1);\n        if (!validationRules.ignoreEndValueCheck && !compareVec(test, testEnd)) {\n          console.warn(\n            'Auto Easing Validation Failed: using a time of 1 does not produce the end value',\n          );\n          console.warn('Start:', testStart, 'End:', testEnd, 'Result:', test);\n          console.warn(attribute);\n        }\n\n        test = attribute.easing.cpu(testStart, testEnd, -1);\n        if (!compareVec(test, testStart)) {\n          console.warn(\n            'Auto Easing Validation Failed: using a time of -1 does not produce the start value',\n          );\n          console.warn('Start:', testStart, 'End:', testEnd, 'Result:', test);\n          console.warn(attribute);\n        }\n\n        test = attribute.easing.cpu(testStart, testEnd, 2);\n        if (!validationRules.ignoreOverTimeCheck && !compareVec(test, testEnd)) {\n          console.warn(\n            'Auto Easing Validation Failed: using a time of 2 does not produce the end value',\n          );\n          console.warn('Start:', testStart, 'End:', testEnd, 'Result:', test);\n          console.warn(attribute);\n        }\n      } else {\n        console.warn(\n          'An Instance Attribute with easing MUST have a size declared',\n        );\n      }\n    }\n  });\n}\n\n/**\n * This is the primary method that analyzes all shader IO and determines which elements needs to be automatically injected\n * into the shader.\n */\nexport function injectShaderIO<T extends Instance, U extends ILayerProps<T>>(\n  gl: WebGLRenderingContext,\n  layer: Layer<T, U>,\n  shaderIO: IShaderInitialization<T>,\n) {\n  // All of the instance attributes with nulls filtered out\n  const instanceAttributes = (shaderIO.instanceAttributes || []).filter(\n    isInstanceAttribute,\n  );\n  // All of the vertex attributes with nulls filtered out\n  const vertexAttributes = (shaderIO.vertexAttributes || []).filter(\n    isVertexAttribute,\n  );\n  // All of the uniforms with nulls filtered out\n  const uniforms = (shaderIO.uniforms || []).filter(isUniform);\n  // Do a validation pass of the attributes injected so we can provide feedback as to why things behave odd\n  validateInstanceAttributes(layer, instanceAttributes, vertexAttributes);\n  // Generates all of the attributes needed to make attributes automagically be eased when changed\n  generateEasingAttributes(layer, instanceAttributes);\n  // Get the uniforms needed to facilitate atlas resource requests if any exists\n  let addedUniforms: IUniform[] = uniforms.concat(\n    generateAtlasResourceUniforms(layer, instanceAttributes),\n  );\n  // These are the uniforms that should be present in the shader for basic operation\n  addedUniforms = addedUniforms.concat(generateBaseUniforms(layer));\n  // Add in uniforms for picking\n  addedUniforms = addedUniforms.concat(generatePickingUniforms(layer));\n  // Create the base instance attributes that must be present\n  let addedInstanceAttributes: IInstanceAttribute<\n    T\n  >[] = instanceAttributes.concat(\n    generateBaseInstanceAttributes(layer, instanceAttributes),\n  );\n  // Add in attributes for picking\n  addedInstanceAttributes = addedInstanceAttributes.concat(\n    generatePickingAttributes(layer, addedInstanceAttributes),\n  );\n\n  const allUniforms = addedUniforms.map(toUniformInternal);\n\n  const allInstanceAttributes = addedInstanceAttributes.sort(\n    sortNeedsUpdateFirstToTop,\n  );\n\n  // Before we make the vertex attributes, we must determine the buffering strategy our layer will utilize\n  getLayerBufferType(gl, layer, vertexAttributes, allInstanceAttributes);\n\n  // Create the base vertex attributes that must be present\n  const addedVertexAttributes: IVertexAttribute[] = generateBaseVertexAttributes(\n    layer,\n  );\n\n  // Aggregate all of the injected shaderIO with the layer's shaderIO\n  const allVertexAttributes: IVertexAttributeInternal[] = addedVertexAttributes\n    .concat(vertexAttributes || [])\n    .map(toVertexAttributeInternal);\n\n  return {\n    instanceAttributes: allInstanceAttributes,\n    uniforms: allUniforms,\n    vertexAttributes: allVertexAttributes,\n  };\n}\n","import * as Three from 'three';\nimport { IInstancingUniform, IUniform, UniformSize } from '../../types';\nimport { Instance } from '../../util';\nimport { ILayerProps, Layer } from '../layer';\n\nconst UNIFORM_SIZE_TO_MATERIAL_TYPE: { [key: number]: string } = {\n  [UniformSize.ONE]: 'f',\n  [UniformSize.TWO]: 'v2',\n  [UniformSize.THREE]: 'v3',\n  [UniformSize.FOUR]: 'v4',\n  [UniformSize.MATRIX3]: 'Matrix3fv',\n  [UniformSize.MATRIX4]: 'Matrix4fv',\n};\n\nconst DEFAULT_UNIFORM_VALUE: { [key: number]: number[] } = {\n  [UniformSize.ONE]: [0],\n  [UniformSize.TWO]: [0, 0],\n  [UniformSize.THREE]: [0, 0, 0],\n  [UniformSize.FOUR]: [0, 0, 0, 0],\n  [UniformSize.MATRIX3]: [0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [UniformSize.MATRIX4]: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n};\n\nfunction toMaterialUniform(uniform: IUniform) {\n  return {\n    type: UNIFORM_SIZE_TO_MATERIAL_TYPE[uniform.size],\n    value: DEFAULT_UNIFORM_VALUE[uniform.size],\n  };\n}\n\nexport function generateLayerMaterial<\n  T extends Instance,\n  U extends ILayerProps<T>\n>(\n  layer: Layer<T, U>,\n  vs: string,\n  fs: string,\n  layerUniforms: IUniform[],\n  instancingUniforms: IInstancingUniform[],\n): Three.RawShaderMaterial {\n  // We now need to establish the material for the layer\n  const materialParams: Three.ShaderMaterialParameters = layer.getMaterialOptions();\n  materialParams.vertexShader = vs;\n  materialParams.fragmentShader = fs;\n\n  // We must convert all of the uniforms to actual Three material initialization uniforms\n  materialParams.uniforms = {};\n\n  // Convert our non-instancing uniforms to our material uniforms\n  for (let i = 0, end = layerUniforms.length; i < end; ++i) {\n    const uniform = layerUniforms[i];\n    const materialUniform = toMaterialUniform(uniform);\n    materialParams.uniforms[uniform.name] = materialUniform;\n  }\n\n  // Add in the generated instancing uniforms\n  for (let i = 0, end = instancingUniforms.length; i < end; ++i) {\n    const generatedUniform = instancingUniforms[i];\n    materialParams.uniforms[generatedUniform.name] = {\n      type: generatedUniform.type,\n      value: generatedUniform.value,\n    };\n  }\n\n  return new Three.RawShaderMaterial(materialParams);\n}\n","import * as Three from 'three';\nimport { Instance } from '../../instance-provider/instance';\nimport {\n  IVertexAttribute,\n  IVertexAttributeInternal,\n  ShaderIOValue,\n} from '../../types';\nimport { Layer } from '../layer';\nimport { LayerBufferType } from './layer-buffer-type';\n\nfunction isNumberCluster(\n  val: ShaderIOValue,\n): val is\n  | [number]\n  | [number, number]\n  | [number, number, number]\n  | [number, number, number, number] {\n  return !Array.isArray(val[0]);\n}\n\nexport function generateLayerGeometry<T extends Instance>(\n  layer: Layer<T, any>,\n  maxInstancesPerBuffer: number,\n  vertexAttributes: IVertexAttributeInternal[],\n  vertexCount: number,\n): Three.BufferGeometry {\n  // Make the new buffers to be updated\n  const vertexBuffers = [];\n\n  if (layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE) {\n    maxInstancesPerBuffer = 1;\n  }\n\n  for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n    const attribute = vertexAttributes[i];\n    vertexBuffers.push(\n      new Float32Array(attribute.size * vertexCount * maxInstancesPerBuffer),\n    );\n  }\n\n  // Let's now fill in the baseline geometry with the instances we will be generating\n  // First we ask the layer for a single instance's buffer setup\n  const endk = vertexAttributes.length;\n  let buffer: Float32Array;\n  let attribute: IVertexAttribute;\n  let value: ShaderIOValue;\n  let formatError: boolean = false;\n\n  for (let i = 0, end = vertexCount; i < end; ++i) {\n    for (let k = 0; k < endk; ++k) {\n      attribute = vertexAttributes[k];\n      buffer = vertexBuffers[k];\n      value = attribute.update(i);\n\n      if (isNumberCluster(value)) {\n        for (\n          let j = i * attribute.size, endj = j + attribute.size, index = 0;\n          j < endj;\n          ++j, ++index\n        ) {\n          buffer[j] = value[index];\n        }\n      } else {\n        formatError = true;\n      }\n    }\n  }\n\n  if (formatError) {\n    console.warn(\n      'A vertex buffer updating method should not use arrays of arrays of numbers.',\n    );\n  }\n\n  // After getting the geometry for a single instance, we can now copy paste\n  // For subsequent instances using very fast FLoat32 methods\n  // NOTE: This is ONLY for certain buffering strategies. This is essentially a noop when the\n  // maxInstances is set to one.\n  for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n    const attribute = vertexAttributes[i];\n    const instanceSize = attribute.size * vertexCount;\n\n    // Copy the first buffer set into the rest of the buffer\n    for (let k = 1, endk = maxInstancesPerBuffer; k < endk; ++k) {\n      vertexBuffers[i].copyWithin(instanceSize * k, 0, instanceSize);\n    }\n  }\n\n  // Lastly, we make the instance attribute reflect correctly so each instance\n  // Can have varied information. This is only appropriate for the uniform buffer strategy\n  if (layer.bufferType === LayerBufferType.UNIFORM) {\n    const instancingBuffer = vertexBuffers[0];\n\n    for (let i = 0, end = maxInstancesPerBuffer; i < end; ++i) {\n      const instanceStartIndex = i * vertexCount;\n\n      for (let k = 0; k < vertexCount; ++k) {\n        instancingBuffer[k + instanceStartIndex] = i;\n      }\n    }\n  }\n\n  // Now we can generate the attributes and apply them to a geometry object\n  const geometry = new Three.BufferGeometry();\n\n  for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n    const attribute = vertexAttributes[i];\n    const materialAttribute = new Three.BufferAttribute(\n      vertexBuffers[i],\n      attribute.size,\n    );\n    attribute.materialAttribute = materialAttribute;\n    geometry.addAttribute(attribute.name, materialAttribute);\n  }\n\n  return geometry;\n}\n","import * as Three from 'three';\nimport { AbsolutePosition } from '../../primitives/absolute-position';\nimport { ChartCamera } from '../../util/chart-camera';\nimport { ViewCamera } from '../../util/view-camera';\nimport { Scene } from '../scene';\nimport { View } from '../view';\n\nexport interface IDefaultSceneElements {\n  /** Default chartting camera */\n  camera: ChartCamera;\n  /** Default scene for elements to be added into */\n  scene: Scene;\n  /** Default view scenes are rendered with when no other views are specified by the layer or the surface */\n  view: View;\n  /**\n   * The default view projection. Defaults to being an orthographic rendering with the origin at the\n   * top left of the canvas and the y-axis as +y going downward.\n   */\n  viewCamera: ViewCamera;\n  /** The default viewport that encompasses the entire canvas */\n  viewport: AbsolutePosition;\n}\n\n/**\n * This generates all of the cameras/views/scenes necessary for default viewing of elements.\n *\n * These defaults are required to ensure the following:\n *\n * - Orthographic view\n * - top left corner of the canvas is 0,0\n * - y axis is +y downward\n * - entire canvas is the viewport.\n */\nexport function generateDefaultScene(\n  context: WebGLRenderingContext,\n): IDefaultSceneElements {\n  // Generate a default view camera that is\n  // - Orthographic\n  // - (0, 0) is the top left of the canvas\n  // - the y axis is +y going downward\n  const height = context.canvas.height;\n  const width = context.canvas.width;\n  const aspectRatio = width / height;\n\n  const viewport = {\n    aspectRatio: aspectRatio,\n    bottom: -height / 2,\n    far: 10000000,\n    left: -width / 2,\n    near: -100,\n    right: width / 2,\n    top: height / 2,\n    viewSize: height,\n  };\n\n  const defaultCamera: ViewCamera = new ViewCamera();\n  defaultCamera.baseCamera = new Three.OrthographicCamera(\n    viewport.left,\n    viewport.right,\n    viewport.top,\n    viewport.bottom,\n    viewport.near,\n    viewport.far,\n  );\n\n  defaultCamera.baseCamera.scale.set(1.0, -1.0, 1.0);\n  defaultCamera.baseCamera.position.set(0.0, 0.0, -300.0);\n  defaultCamera.baseCamera.updateMatrixWorld(true);\n  defaultCamera.baseCamera.updateMatrix();\n\n  if (defaultCamera.baseCamera instanceof Three.OrthographicCamera) {\n    defaultCamera.baseCamera.updateProjectionMatrix();\n  }\n\n  // Generate a charting camera with all scales set to 1 and no offsets in any direction\n  const defaultChartCamera: ChartCamera = new ChartCamera();\n\n  // This is a viewport that covers the entire context\n  const defaultViewport = {\n    bottom: 0,\n    left: 0,\n    right: 0,\n    top: 0,\n  };\n\n  // Make a view using our defaults\n  const defaultView = new View({\n    camera: defaultChartCamera,\n    key: View.DEFAULT_VIEW_ID,\n    viewCamera: defaultCamera,\n    viewport: defaultViewport,\n  });\n\n  // Make a scene with our defaults\n  const defaultScene = new Scene({\n    key: Scene.DEFAULT_SCENE_ID,\n    views: [],\n  });\n\n  // Make sure the default view is a part of the default scene\n  defaultScene.addView(defaultView);\n\n  return {\n    camera: defaultChartCamera,\n    scene: defaultScene,\n    view: defaultView,\n    viewCamera: defaultCamera,\n    viewport: defaultViewport,\n  };\n}\n","import { Bounds } from '../primitives/bounds';\n\nexport class DataBounds<T> extends Bounds {\n  data: T;\n\n  static emptyBounds<T>() {\n    return new DataBounds<T>({\n      height: 0,\n      width: 0,\n      x: 0,\n      y: 0,\n    });\n  }\n}\n","export const templateVars = {\n  attributeFragments: 'attributeFragments',\n  attributes: 'attributes',\n  blocksPerInstance: 'blocksPerInstance',\n  easingMethod: 'easingMethod',\n  easingMethods: 'easingMethods',\n  instanceBlockCount: 'instanceBlockCount',\n  instanceDataBinaryTree: 'instanceDataBinaryTree',\n  instanceDataRetrieval: 'instanceDataRetrieval',\n  instanceDestructuring: 'instanceDestructuring',\n  instanceFragments: 'instanceFragments',\n  instanceUniformDeclarations: 'instanceUniformDeclarations',\n  layerUniforms: 'layerUniforms',\n  picking: 'picking',\n  projectionMethods: 'projectionMethods',\n  shader: 'shader',\n  shaderInput: 'shaderInput',\n  T: 'T',\n  vertexAttributes: 'vertexAttributes',\n};\n","export * from './label-layer';\nexport * from './label-instance';\n","import { Label } from '../../primitives/label';\nimport { LabelAtlasResource } from './label-atlas-resource';\n\nlet canvas: CanvasRenderingContext2D;\nconst MAX_FONT_SIZE = 50;\nconst { floor, max, min } = Math;\n\nexport interface ILabelRasterizedMetrics {\n  canvas: HTMLCanvasElement;\n  height: number;\n  width: number;\n}\n\nexport class LabelRasterizer {\n  /**\n   * This loops until our canvas context is available\n   */\n  static async awaitContext() {\n    // Iterate till the browser provides a valid canvas to render elements into\n    while (!canvas) {\n      this.getContext();\n      await new Promise(resolve => setTimeout(resolve, 10));\n    }\n  }\n\n  /**\n   * This renders our label to a sizeable canvas where we loop over the pixel data to determine\n   * the bounds of the label.\n   *\n   * @param {boolean} calculateWorld This is used within the method. It switches from calculating\n   *                                 the size to be rendered to the texture to the size the label\n   *                                 should be within world space.\n   * @param {number} sampleScale     INTERNAL: Do not use this parameter manually.\n   */\n  static calculateLabelSize(\n    resource: LabelAtlasResource,\n    sampleScale?: number,\n    calculateTexture?: boolean,\n  ) {\n    // If a max width is specified, then we must render and determine the potentially truncated text of the\n    // Label. We can do a binary search for the correct truncated label size.\n    if (calculateTexture) {\n      this.calculateTrucatedText(resource);\n    }\n\n    /** Get the label properties for rasterizing */\n    const label = resource.label;\n    // Get the scaling of the sample base\n    const sampleScaling = sampleScale || resource.sampleScale || 1.0;\n    // Draw our label to a canvas\n    this.drawLabel(label, resource.truncatedText, canvas, sampleScaling);\n    // Measure the contents of the canvas\n    const { minX, minY, maxX, maxY } = this.measureContents(canvas);\n\n    // Make sure the rasterization object is initialized\n    resource.rasterization = resource.rasterization || {\n      texture: { height: 0, width: 0 },\n      world: { height: 0, width: 0 },\n    };\n\n    // When a forced sampling is present, it calculates that as the world space\n    if (!calculateTexture) {\n      // Update the calculated texture size.\n      resource.rasterization.world = {\n        height: maxY - minY,\n        width: maxX - minX,\n      };\n    }\n\n    // Otherwise we first calculate the texture rasterization for the label\n    else {\n      // Update the calculated texture size.\n      resource.rasterization.texture = {\n        height: maxY - minY,\n        width: maxX - minX,\n      };\n\n      resource.rasterization.canvas = this.createCroppedCanvas(\n        resource,\n        minY,\n        minX,\n      );\n      this.calculateLabelSize(resource, 1.0, false);\n    }\n  }\n\n  /**\n   * This determines what the truncated text of the label will be. If there is no truncation\n   * then the truncated text === the label's text\n   */\n  static calculateTrucatedText(resource: LabelAtlasResource) {\n    const label = resource.label;\n    const maxWidth = label.maxWidth;\n\n    // If the label has no max width, then there will be no truncation\n    if (!maxWidth) {\n      resource.truncatedText = label.text;\n      return;\n    }\n\n    // We now do an initial rendering of the label as it will appear in world space\n    this.drawLabel(label, label.text, canvas, 1);\n    // We measure the contents of the rendered item to see if it violates the maxWidth\n    const firstTest = this.measureContents(canvas);\n\n    // If we're within spec, we do not need to truncate\n    if (firstTest.maxX - firstTest.minX <= maxWidth) {\n      resource.truncatedText = label.text;\n      return;\n    }\n\n    // At this point we need to binary search through chopping off letters to find a string\n    // That will fit within max width\n    const text = label.text;\n    let left = 0;\n    let right = text.length;\n    let cursor = floor((right - left) / 2.0);\n    let safety = 0;\n    const safetyMax = 50;\n\n    // Loop to perform the binary search\n    while (right > left && cursor !== 0 && safety++ < safetyMax) {\n      // Draw and measure\n      this.drawLabel(label, `${text.substr(0, cursor)}...`, canvas, 1);\n      const { minX, maxX } = this.measureContents(canvas);\n\n      // If we pass then we move left to cursor to make the test string longer\n      if (maxX - minX <= maxWidth) {\n        left = cursor;\n      }\n\n      // If we fail, we move right to cursor to make the test string shorter\n      else {\n        right = cursor;\n      }\n\n      // Get our next cursor position\n      const nextCursor = floor((right - left) / 2.0) + left;\n\n      // If the next cursor is the same as cursor, then we're done searching\n      if (nextCursor === cursor) {\n        break;\n      }\n\n      // Move our cursor\n      cursor = nextCursor;\n    }\n\n    // If cursor is zero, nothing passed and our truncation is just ellipses\n    if (cursor === 0) {\n      resource.truncatedText = '...';\n    }\n\n    // Otherwise we get the string that passes and use that as our truncated text\n    else {\n      resource.truncatedText = `${text.substr(0, cursor)}...`;\n    }\n  }\n\n  /**\n   * This generates a canvas that has the cropped version of the label where the label\n   * fits neatly in the canvas object.\n   */\n  static createCroppedCanvas(\n    resource: LabelAtlasResource,\n    top: number,\n    left: number,\n  ) {\n    const cropped = document.createElement('canvas');\n    const context = cropped.getContext('2d');\n\n    if (context) {\n      const texture = resource.rasterization.texture;\n      cropped.width = texture.width;\n      cropped.height = texture.height;\n      context.imageSmoothingEnabled = false;\n\n      // Draw just the region the label appears into the canvas\n      context.drawImage(\n        canvas.canvas,\n        left,\n        top,\n        texture.width,\n        texture.height,\n        0,\n        0,\n        texture.width,\n        texture.height,\n      );\n    } else {\n      console.warn(\n        'Could not create a canvas 2d context to generate a label\\'s cropped image.',\n      );\n    }\n\n    return cropped;\n  }\n\n  /**\n   * This actually renders a string to a canvas context using a label's settings\n   */\n  static drawLabel(\n    label: Label,\n    text: string,\n    canvas: CanvasRenderingContext2D,\n    sampleScaling: number,\n  ) {\n    // Get the font size we will rasterize with\n    const fontSize = this.getLabelRasterizationFontSize(label, sampleScaling);\n    // Set the color of the label to white so we know what color to look for\n    canvas.fillStyle = 'white';\n    // Set the font to the canvas\n    canvas.font = this.makeCSSFont(label, sampleScaling);\n    // We will use the canvas measuring tool to give us a baseline for how wide\n    // The label will be. We add the font size to the width for the padding needed to ensure\n    // The entirety of the text is placed on the canvas.\n    canvas.canvas.width = canvas.measureText(label.text).width + fontSize;\n    // Make our test area the font size with one extra level of the font size\n    // For padding.\n    canvas.canvas.height = fontSize * 2.0;\n    // After adjusting the canvas dimensions we must re-set the font metrics\n    // Set the color of the label to white so we know what color to look for\n    canvas.fillStyle = 'white';\n    // Set the font to the canvas\n    canvas.font = this.makeCSSFont(label, sampleScaling);\n    // Render the text into our canvas for calculating\n    canvas.fillText(text, fontSize / 2.0, fontSize / 4.0 + fontSize);\n  }\n\n  /**\n   * Attempts to populate the 'canvas' context for rendering labels offscreen.\n   */\n  static getContext() {\n    if (!canvas) {\n      const potentialCanvas = document.createElement('canvas').getContext('2d');\n\n      if (potentialCanvas) {\n        canvas = potentialCanvas;\n      }\n\n      return potentialCanvas;\n    }\n\n    return canvas;\n  }\n\n  /**\n   * This retrieves the font size that will be used when rasterizing the label. This takes into\n   * account whether the label is requesting super sampling be present for the rendering.\n   */\n  static getLabelRasterizationFontSize(label: Label, sampleScale: number) {\n    return label.fontSize * sampleScale;\n  }\n\n  /**\n   * Generates the CSS font string based on the label's values\n   */\n  static makeCSSFont(label: Label, sampleScale: number) {\n    return `${label.fontWeight} ${this.getLabelRasterizationFontSize(\n      label,\n      sampleScale,\n    )}px ${label.fontFamily}`;\n  }\n\n  /**\n   * This measures the contents of what is inside the canvas assumming the rendered values are only white\n   */\n  static measureContents(canvas: CanvasRenderingContext2D) {\n    const { width, height } = canvas.canvas;\n    const imageData = canvas.getImageData(0, 0, width, height).data;\n    let r;\n\n    let minY = Number.MAX_SAFE_INTEGER;\n    let minX = Number.MAX_SAFE_INTEGER;\n    let maxX = Number.MIN_SAFE_INTEGER;\n    let maxY = Number.MIN_SAFE_INTEGER;\n\n    for (let i = 0; i < width; ++i) {\n      for (let k = 0; k < height; ++k) {\n        const redIndex = k * (width * 4) + i * 4;\n        r = imageData[redIndex];\n\n        if (r > 0.0) {\n          minY = min(minY, k);\n          minX = min(minX, i);\n          maxX = max(maxX, i);\n          maxY = max(maxY, k);\n        }\n      }\n    }\n\n    // The identified pixel needs to be encased and not a direct target\n    minY -= 1;\n    maxY += 2;\n    maxX += 2;\n    minX -= 1;\n\n    minY = max(minY, 0);\n    minX = max(minX, 0);\n\n    return { minX, minY, maxX, maxY };\n  }\n\n  /**\n   * Performs the rendering of the label\n   */\n  static async render(\n    resource: LabelAtlasResource,\n  ): Promise<LabelAtlasResource> {\n    // Make sure our canvas object is ready for rendering\n    await this.awaitContext();\n\n    // Validate the label's input\n    if (resource.label.fontSize > MAX_FONT_SIZE) {\n      console.warn('Labels only support font sizes up to 50');\n      return resource;\n    }\n\n    // Calculate all of the label metrics and generate a canvas on the label that can\n    // Be rendered to the canvas.\n    this.calculateLabelSize(resource, resource.sampleScale, true);\n\n    return resource;\n  }\n\n  /**\n   * Performs the rendering of the label\n   */\n  static renderSync(resource: LabelAtlasResource): LabelAtlasResource {\n    // Ensure our offscreen canvas is prepped\n    this.getContext();\n\n    if (!canvas) {\n      console.warn(\n        'Can not render a label synchronously without the canvas context being ready.',\n      );\n      return resource;\n    }\n\n    // Validate the label's input\n    if (resource.label.fontSize > MAX_FONT_SIZE) {\n      console.warn('Labels only support font sizes up to 50');\n      return resource;\n    }\n\n    // Calculate all of the label metrics and generate a canvas on the label that can\n    // Be rendered to the canvas.\n    this.calculateLabelSize(resource, resource.sampleScale, true);\n\n    return resource;\n  }\n}\n","import { Image } from '../../primitives/image';\nimport { BaseAtlasResource } from './base-atlas-resource';\n\nexport class ImageAtlasResource extends BaseAtlasResource {\n  /** This is the image to be loaded into the atlas */\n  image: Image;\n\n  constructor(image: Image) {\n    super();\n    this.image = image;\n  }\n}\n","import { Color } from '../../primitives/color';\nimport { ColorAtlasResource } from './color-atlas-resource';\n\n// When ratserized to the image, this determines the size of the square rendered to the atlas.\nconst COLOR_RASTERIZATION_SIZE = 2;\n\n/**\n * Static class for rasterizing a color to a canvas object\n */\nexport class ColorRasterizer {\n  /**\n   * This loops until our canvas context is available\n   */\n  static async awaitContext(canvas: HTMLCanvasElement) {\n    // Iterate till the browser provides a valid canvas to render elements into\n    for (\n      let c = canvas.getContext('2d'), limit = 0;\n      !Boolean(c) && limit < 100;\n      c = canvas.getContext('2d'), ++limit\n    ) {\n      await new Promise(resolve => setTimeout(resolve, 10));\n    }\n  }\n\n  /**\n   * Generates the CSS string version of the color\n   */\n  static makeCSS(color: Color) {\n    return `rgba(${Math.floor(color.r * 256)}, ${Math.floor(\n      color.g * 256,\n    )}, ${Math.floor(color.b * 256)}, ${color.opacity})`;\n  }\n\n  static async render(resource: ColorAtlasResource) {\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n\n    await this.awaitContext(canvas);\n\n    if (context) {\n      canvas.width = COLOR_RASTERIZATION_SIZE;\n      canvas.height = COLOR_RASTERIZATION_SIZE;\n      context.imageSmoothingEnabled = false;\n      context.fillStyle = this.makeCSS(resource.color);\n\n      // Draw the color to the fill space\n      context.fillRect(\n        0,\n        0,\n        COLOR_RASTERIZATION_SIZE,\n        COLOR_RASTERIZATION_SIZE,\n      );\n      // Update the resource with the rasterization\n      resource.rasterization.canvas = canvas;\n    } else {\n      console.warn(\n        'Could not create a canvas 2d context to generate a color for rasterization.',\n      );\n    }\n\n    return resource;\n  }\n}\n","import { Color } from '../../primitives/color';\nimport { BaseAtlasResource } from './base-atlas-resource';\n\nexport class ColorAtlasResource extends BaseAtlasResource {\n  /** This is the color to be loaded into the atlas */\n  color: Color;\n\n  constructor(color: Color) {\n    super();\n    this.color = color;\n  }\n}\n","import * as Three from 'three';\nimport { IPoint } from '../../primitives/point';\n\n/**\n * Defines a texture that is located on an atlas\n */\nexport class SubTexture {\n  /** Stores the aspect ratio of the image for quick reference */\n  aspectRatio: number = 1.0;\n  /** The id of the atlas this texture is located on */\n  atlasReferenceID: string = '';\n  /** This is the actual texture of the atlas this resource is located on */\n  atlasTexture: Three.Texture | null = null;\n  /** This is the top left UV coordinate of the sub texture on the atlas */\n  atlasTL: IPoint = { x: 0, y: 0 };\n  /** This is the top right UV coordinate of the sub texture on the atlas */\n  atlasTR: IPoint = { x: 0, y: 0 };\n  /** This is the bottom left UV coordinate of the sub texture on the atlas */\n  atlasBL: IPoint = { x: 0, y: 0 };\n  /** This is the bottom right UV coordinate of the sub texture on the atlas */\n  atlasBR: IPoint = { x: 0, y: 0 };\n  /** This is the normalized width of the sub texture on the atlas */\n  widthOnAtlas: number = 0;\n  /** This is the normalized height of the sub texture on the atlas */\n  heightOnAtlas: number = 0;\n  /** This flag is set to false when the underlying texture is no longer valid */\n  isValid: boolean = false;\n  /** Width in pixels of the image on the atlas */\n  pixelWidth: number = 0;\n  /** Height in pixels of the image on the atlas */\n  pixelHeight: number = 0;\n}\n","import * as Three from 'three';\nimport {\n  IdentifyByKey,\n  IdentifyByKeyOptions,\n} from '../../util/identify-by-key';\nimport { AtlasManager, AtlasResource } from './atlas-manager';\nimport { PackNode } from './pack-node';\nimport { SubTexture } from './sub-texture';\n\n/**\n * These are valid atlas sizes available. We force a power of 2 to be utilized.\n * We do not allow crazy large sizes as browsers have very real caps on resources.\n * This helps implementations be a little smarter about what they are using. Future\n * versions may increase this number as GPUs improve and standards allow greater\n * flexibility.\n */\nexport enum AtlasSize {\n  _2 = 0x01 << 1,\n  _4 = 0x01 << 2,\n  _8 = 0x01 << 3,\n  _16 = 0x01 << 4,\n  _32 = 0x01 << 5,\n  _64 = 0x01 << 6,\n  _128 = 0x01 << 7,\n  _256 = 0x01 << 8,\n  _512 = 0x01 << 9,\n  _1024 = 0x01 << 10,\n  _2048 = 0x01 << 11,\n  _4096 = 0x01 << 12,\n}\n\nexport interface IAtlasOptions extends IdentifyByKeyOptions {\n  /** This is the height of the texture */\n  height: AtlasSize;\n  /** This is the width of the atlas */\n  width: AtlasSize;\n  /**\n   * This applies any desired settings to the Threejs texture as desired.\n   * Some noteable defaults this system sets:\n   *  - generateMipMaps is false and\n   *  - premultiply alpha is true.\n   */\n  textureSettings?: Partial<Three.Texture>;\n}\n\n/**\n * This represents a single Texture on the gpu that is composed of several smaller textures\n * as a 'look up'.\n */\nexport class Atlas extends IdentifyByKey {\n  /** Stores the size of the atlas texture */\n  height: AtlasSize;\n  /** This is the parent manager of the atlas */\n  manager: AtlasManager;\n  /** This is the packing of the  */\n  packing: PackNode;\n  /** This is the actual texture object that represents the atlas on the GPU */\n  texture: Three.Texture;\n  /** These are the applied settings to our texture */\n  textureSettings?: Partial<Three.Texture>;\n  /**\n   * This is all of the resources associated with this atlas. The boolean flag indicates if the resource\n   * is flagged for removal. When set to false, the resource is no longer valid and can be removed from\n   * the atlas at any given moment.\n   */\n  validResources = new Map<AtlasResource, boolean>();\n  /** Stores the size of the atlas texture */\n  width: AtlasSize;\n\n  constructor(options: IAtlasOptions) {\n    super(options);\n    const canvas = document.createElement('canvas');\n    this.width = canvas.width = options.width;\n    this.height = canvas.height = options.height;\n    this.textureSettings = options.textureSettings;\n\n    // Set up the packing for this atlas\n    this.packing = new PackNode(0, 0, options.width, options.height);\n    // Make sure the texture is started and updated\n    this.updateTexture(canvas);\n  }\n\n  /**\n   * This invalidates the SubTexture of an atlas resource.\n   */\n  private invalidateResource(resource: AtlasResource) {\n    const zero = { x: 0, y: 0 };\n    resource.texture.aspectRatio = 1;\n    resource.texture.atlasBL = zero;\n    resource.texture.atlasBR = zero;\n    resource.texture.atlasTL = zero;\n    resource.texture.atlasTR = zero;\n    resource.texture.atlasReferenceID = '';\n    resource.texture.pixelWidth = 0;\n    resource.texture.pixelHeight = 0;\n    resource.texture.isValid = false;\n  }\n\n  /**\n   * Sets the parent manager of this atlas\n   */\n  setManager(manager: AtlasManager) {\n    this.manager = manager;\n  }\n\n  /**\n   * Adds a resource to this atlas AND ensures the resource is flagged valid for use.\n   *\n   * @return {boolean} True if the resource successfully registered\n   */\n  registerResource(resource: AtlasResource) {\n    if (this.validResources.get(resource) === undefined) {\n      if (!resource.texture || !resource.texture.isValid) {\n        if (!resource.texture) {\n          resource.texture = new SubTexture();\n        }\n\n        resource.texture.isValid = true;\n        this.validResources.set(resource, true);\n\n        return true;\n      } else {\n        console.warn(\n          'Atlas Error:',\n          this.id,\n          'Attempted to add a resource to an Atlas that is already a valid resource on another atlas.',\n          'Consider Creating a new resource to be loaded into this particular atlas.',\n          'Resource:',\n          resource,\n        );\n      }\n    } else {\n      console.warn(\n        'Atlas Error:',\n        this.id,\n        'A resource was trying to be added to the atlas that has already been added before.',\n        'Consider creating a new resource to indicate what you want loaded to the atlas',\n        'Resource:',\n        resource,\n      );\n    }\n\n    return false;\n  }\n\n  /**\n   * This flags a resource from removal from an atlas.\n   *\n   * NOTE: This does not immediately clear the resource fromt he atlas, nor does it even guarantee\n   * the resource will be cleared from the atlas for a while. It merely suggests the resource be removed\n   * and makes the SubTexture invalid. It could be a long while before the atlas gets regnerated and repacked\n   * to actually reflect the resource not existing on the atlas.\n   */\n  removeResource(resource: AtlasResource) {\n    if (this.validResources.get(resource)) {\n      this.validResources.set(resource, false);\n      this.invalidateResource(resource);\n    } else {\n      console.warn(\n        'Atlas Error:',\n        this.id,\n        'Attempted to remove a resource that does not exist on this atlas.',\n        'or the resource was already considered invalidated on this atlas.',\n        'Resource:',\n        resource,\n      );\n    }\n  }\n\n  /**\n   * TODO:\n   * This performs the currently best known way to update a texture.\n   *\n   * This is the current best attempt at updating the atlas which is junk as it destroys the old texture\n   * And makes a new one. We REALLY should be just subTexture2D updating the texture, but Three makes that really\n   * Difficult\n   */\n  updateTexture(canvas?: HTMLCanvasElement) {\n    if (this.texture) {\n      const redoneCanvas: HTMLCanvasElement = this.texture.image;\n      this.texture.dispose();\n      this.texture = new Three.Texture(redoneCanvas);\n    } else {\n      this.texture = new Three.Texture(canvas);\n    }\n\n    // Apply any relevant options to the texture desired to be set\n    this.texture.generateMipmaps = true;\n    this.texture.premultiplyAlpha = true;\n    this.textureSettings && Object.assign(this.texture, this.textureSettings);\n    this.texture.needsUpdate = true;\n  }\n\n  /**\n   * This frees up all the resources down to the GPU related to this atlas. It also\n   * loops through every resource and invalidates the texturing information within\n   * them so subsequent accidental renders will appear as a single color rather than\n   * an artifacted element.\n   */\n  destroy() {\n    this.texture.dispose();\n    this.validResources.forEach((isValid, resource) => {\n      this.invalidateResource(resource);\n    });\n  }\n}\n","export * from './image-layer';\nexport * from './image-instance';\n","import { Instance, InstanceDiff } from '../../../instance-provider';\nimport {\n  BufferManagerBase,\n  IBufferLocation,\n  IBufferLocationGroup,\n} from '../buffer-manager-base';\nimport { IInstanceDiffManagerTarget } from '../instance-diff-manager';\n\n/**\n * Base requirements for handling diffs from a layer.\n */\nexport abstract class BaseDiffProcessor<T extends Instance> {\n  layer: IInstanceDiffManagerTarget<T>;\n  bufferManager: BufferManagerBase<T, IBufferLocation>;\n\n  constructor(\n    layer: IInstanceDiffManagerTarget<T>,\n    bufferManager: BufferManagerBase<T, IBufferLocation>,\n  ) {\n    this.layer = layer;\n    this.bufferManager = bufferManager;\n  }\n\n  /** Perform an 'add' operation for the instance's buffer */\n  abstract addInstance(\n    manager: this,\n    instance: T,\n    propIds: number[],\n    bufferLocation?: IBufferLocation | IBufferLocationGroup<IBufferLocation>,\n  ): void;\n  /** Perform a 'change' operation for the instance's buffer */\n  abstract changeInstance(\n    manager: this,\n    instance: T,\n    propIds: number[],\n    bufferLocation?: IBufferLocation | IBufferLocationGroup<IBufferLocation>,\n  ): void;\n  /** Perform a 'remove' operation for the instance's buffer */\n  abstract removeInstance(\n    manager: this,\n    instance: T,\n    propIds: number[],\n    bufferLocation?: IBufferLocation | IBufferLocationGroup<IBufferLocation>,\n  ): void;\n\n  /**\n   * This indicates all changes have been applied, this allows the processor to finalize buffer updates\n   */\n  abstract commit(): void;\n  /**\n   * This will be called with the changes that WILL be processed. This allows this processor to make extra judgement calls on\n   * how it will process the changes and let's it optimize itself before changes are actually processed. An example optimization:\n   *\n   * Buffers have an update range we can adjust so only a piece of the buffer is updated. However, calculating that range causes\n   * overhead to calculate the affected range. So, if we have mass changes happening for major sections of the buffer (number of\n   * changes approaches some large percentage of the instances supported by the buffer), then it would be more efficient just to\n   * update the entire buffer rather than discover the portion needing updating.\n   */\n  abstract incomingChangeList(changes: InstanceDiff<T>[]): void;\n}\n","const INSTANCE_UNIFORM_ATTRIBUTE_PREFIX = 'u';\n\nexport function makeInstanceUniformNameArray() {\n  return `instanceData`;\n}\n\nexport function makeInstanceUniformNameTree(index: number) {\n  return `${INSTANCE_UNIFORM_ATTRIBUTE_PREFIX}${index.toString(31)}`;\n}\n","import { IInstanceAttribute } from '../../types';\nimport { Instance } from '../../util';\n\nexport function instanceAttributeShaderName<T extends Instance>(\n  attribute: IInstanceAttribute<T>,\n) {\n  if (attribute.easing) {\n    return `_${attribute.name}_end`;\n  } else {\n    return attribute.name;\n  }\n}\n","export function getProgramInfo(gl: WebGLRenderingContext, program: any) {\n  const result = {\n      attributeCount: 0,\n      attributes: new Array(),\n      uniformCount: 0,\n      uniforms: new Array(),\n    },\n    activeUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS),\n    activeAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\n  // Taken from the WebGl spec:\n  // Http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14\n  const enums: { [key: number]: string } = {\n    0x8b50: 'FLOAT_VEC2',\n    0x8b51: 'FLOAT_VEC3',\n    0x8b52: 'FLOAT_VEC4',\n    0x8b53: 'INT_VEC2',\n    0x8b54: 'INT_VEC3',\n    0x8b55: 'INT_VEC4',\n    0x8b56: 'BOOL',\n    0x8b57: 'BOOL_VEC2',\n    0x8b58: 'BOOL_VEC3',\n    0x8b59: 'BOOL_VEC4',\n    0x8b5a: 'FLOAT_MAT2',\n    0x8b5b: 'FLOAT_MAT3',\n    0x8b5c: 'FLOAT_MAT4',\n    0x8b5e: 'SAMPLER_2D',\n    0x8b60: 'SAMPLER_CUBE',\n    0x1400: 'BYTE',\n    0x1401: 'UNSIGNED_BYTE',\n    0x1402: 'SHORT',\n    0x1403: 'UNSIGNED_SHORT',\n    0x1404: 'INT',\n    0x1405: 'UNSIGNED_INT',\n    0x1406: 'FLOAT',\n  };\n\n  const blocks: { [key: number]: number } = {\n    0x8b50: 1,\n    0x8b51: 1,\n    0x8b52: 1,\n    0x8b53: 1,\n    0x8b54: 1,\n    0x8b55: 1,\n    0x8b56: 1,\n    0x8b57: 1,\n    0x8b58: 1,\n    0x8b59: 1,\n    0x8b5a: 1,\n    0x8b5b: 3,\n    0x8b5c: 4,\n    0x8b5e: 1,\n    0x8b60: 1,\n    0x1400: 1,\n    0x1401: 1,\n    0x1402: 1,\n    0x1403: 1,\n    0x1404: 1,\n    0x1405: 1,\n    0x1406: 1,\n  };\n\n  // Loop through active uniforms\n  for (let i = 0; i < activeUniforms; ++i) {\n    const uniform: any = gl.getActiveUniform(program, i);\n    uniform.typeName = enums[uniform.type];\n    result.uniforms.push(uniform);\n    result.uniformCount += uniform.size;\n    uniform.size = uniform.size * blocks[uniform.type];\n  }\n\n  // Loop through active attributes\n  for (let i = 0; i < activeAttributes; i++) {\n    const attribute: any = gl.getActiveAttrib(program, i);\n    attribute.typeName = enums[attribute.type];\n    result.attributes.push(attribute);\n    result.attributeCount += attribute.size;\n  }\n\n  return result;\n}\n\nexport class WebGLStat {\n  static MAX_VERTEX_UNIFORMS = 0;\n  static MAX_FRAGMENT_UNIFORMS = 0;\n  static MAX_VERTEX_ATTRIBUTES = 0;\n  static WEBGL_SUPPORTED: boolean = false;\n  static MAX_TEXTURE_SIZE = 0;\n  static HARDWARE_INSTANCING = false;\n  static HARDWARE_INSTANCING_ANGLE = false;\n}\n\nfunction initStats() {\n  // Let's perform some immediate operations to do some gl querying for useful information\n  function getAContext() {\n    try {\n      const canvas = document.createElement('canvas');\n      return (\n        (window as any).WebGLRenderingContext &&\n        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))\n      );\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Attempt to retrieve a context for webgl\n  const gl = getAContext();\n\n  // If the context exists, then we know gl is supported and we can fill in some metrics\n  if (gl) {\n    WebGLStat.WEBGL_SUPPORTED = true;\n    WebGLStat.MAX_VERTEX_UNIFORMS = gl.getParameter(\n      gl.MAX_VERTEX_UNIFORM_VECTORS,\n    );\n    WebGLStat.MAX_FRAGMENT_UNIFORMS = gl.getParameter(\n      gl.MAX_FRAGMENT_UNIFORM_VECTORS,\n    );\n    WebGLStat.MAX_VERTEX_ATTRIBUTES = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n    WebGLStat.MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    WebGLStat.HARDWARE_INSTANCING_ANGLE = Boolean(\n      gl.getExtension('ANGLE_instanced_arrays'),\n    );\n    WebGLStat.HARDWARE_INSTANCING = WebGLStat.HARDWARE_INSTANCING_ANGLE;\n  }\n}\n\ninitStats();\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","import * as browser from 'bowser';\nimport { Vector2 } from 'three';\nconst debug = require('debug')('CommunicationsView:Mouse');\n\n/** Used to adjust the base whee delta for IE browsers */\nconst IE_ADJUSTMENT = 1 / 30;\n/** Used to adjust the rates for IE 11 */\nconst OLD_IE_ADJUSTMENT = -0.25;\n// This determines how large the delta can grow to in firefox\nconst MAX_FIREFOX_WHEELDELTA = 100;\n/**\n * Create a low pass filter memory bank so we can slow down rapid accelerations and let normal slower accelerations pass\n * Common use case for this is the discrepancy in firefox from mousewheels to trackpad scroll speeds\n */\nconst lowPassY: number[] = [0, 0, 0, 0];\n// These coefficients represent the coefficients of a FIR filter.\n// This FIR filter uses the lowPassY as the memory for the filter and is created for\n// The reasons specified for the lowPassY memory. To edit the coefficients, you simply\n// Ensure the coefficients added together === 1.0. If they do not, you may get an unstable\n// Result that goes to infinity rather quickly. Changing the distribution of these coefficients\n// Alters the rate at which the delta can approach MAX_FIREFOX_WHEELDELTA. Explaining exactly\n// How it affects the rate requires an understanding of FIR filters, so unless this is already\n// Known knowledge, it would be faster to just tweak the coefficients until a desired effect is\n// Attained.\nconst LOW_PASS_U0 = 0.02;\nconst LOW_PASS_U1 = 0.1;\nconst LOW_PASS_U2 = 0.18;\nconst LOW_PASS_U3 = 0.7;\n\nfunction normalizeFirefoxWheel(e: MouseWheelEvent) {\n  const wheel: WheelEvent = e;\n  let deltaX = 0;\n  let deltaY = 0;\n\n  // Reset the filter if the direction changes to prevent lag in directional change\n  if (Math.sign(lowPassY[0]) !== Math.sign(deltaY)) {\n    lowPassY.splice(0, lowPassY.length, 0, 0, 0, 0);\n  }\n\n  deltaX = wheel.deltaX * MAX_FIREFOX_WHEELDELTA;\n\n  // Calculate the next value output from the FIR filter\n  deltaY =\n    wheel.deltaY * MAX_FIREFOX_WHEELDELTA * LOW_PASS_U0 +\n    lowPassY[0] * LOW_PASS_U1 +\n    lowPassY[1] * LOW_PASS_U2 +\n    lowPassY[2] * LOW_PASS_U3;\n  // Store the value of the filter in the FIR memory bank\n  lowPassY.unshift(deltaY);\n  // Keep our FIR memory clean and only the size of the number of coefficients\n  lowPassY.pop();\n\n  return new Vector2(-deltaX, -deltaY);\n}\n\nfunction normalizeChromeWheel(e: MouseWheelEvent) {\n  const wheel: WheelEvent = e;\n\n  return new Vector2(wheel.deltaX, -wheel.deltaY);\n}\n\nfunction normalizeIE11Wheel(e: MouseWheelEvent) {\n  const wheel: WheelEvent = e;\n  let deltaX = wheel.deltaX;\n\n  if (deltaX === undefined) {\n    deltaX =\n      wheel.wheelDeltaX !== undefined ? wheel.wheelDeltaX * IE_ADJUSTMENT : 0;\n  }\n\n  let deltaY = wheel.deltaY;\n\n  if (deltaY === undefined) {\n    if (wheel.wheelDeltaY !== undefined) {\n      deltaY = wheel.wheelDeltaY * IE_ADJUSTMENT;\n    } else {\n      deltaY = (wheel.wheelDelta || -wheel.detail) * OLD_IE_ADJUSTMENT;\n    }\n  }\n\n  return new Vector2(-deltaX, -deltaY);\n}\n\nfunction normalizeIE12Wheel(e: MouseWheelEvent) {\n  const wheel: WheelEvent = e;\n  let { deltaX, deltaY } = wheel;\n\n  if (deltaX === undefined) {\n    deltaX =\n      wheel.wheelDeltaX !== undefined ? wheel.wheelDeltaX * IE_ADJUSTMENT : 0;\n  }\n\n  if (deltaY === undefined) {\n    if (wheel.wheelDeltaY !== undefined) {\n      deltaY = wheel.wheelDeltaY * IE_ADJUSTMENT;\n    } else {\n      deltaY = wheel.wheelDelta || -wheel.detail;\n    }\n  }\n\n  const v = new Vector2(deltaX, -deltaY);\n  v.multiplyScalar(0.25);\n\n  return v;\n}\n\n// Determine this browsers version of wheel normalization and apply it\nlet normalizeWheel: (e: MouseWheelEvent) => Vector2;\n\nif (browser.firefox) {\n  debug('Using mouse wheel for firefox');\n  normalizeWheel = normalizeFirefoxWheel;\n} else if (browser.msie && +browser.version >= 11) {\n  debug('Using mouse wheel for IE 11');\n  normalizeWheel = normalizeIE11Wheel;\n} else if (browser.msedge) {\n  debug('Using mouse wheel for MS EDGE');\n  normalizeWheel = normalizeIE12Wheel;\n} else {\n  debug('Using mouse wheel for Chrome');\n  normalizeWheel = normalizeChromeWheel;\n}\n\n/**\n * Analyzes a MouseEvent and calculates the mouse coordinates (relative to the element).\n */\nfunction eventElementPosition(\n  e: any,\n  relative?: HTMLElement,\n): { x: number; y: number } {\n  let mouseX: number = 0,\n    mouseY: number = 0,\n    eventX: number = 0,\n    eventY: number = 0,\n    object: any =\n      relative || (e.nativeEvent && e.nativeEvent.target) || e.target;\n\n  // Get mouse position on document crossbrowser\n  if (!e) {\n    e = window.event;\n  }\n\n  if (e.pageX || e.pageY) {\n    mouseX = e.pageX;\n    mouseY = e.pageY;\n  } else if (e.clientX || e.clientY) {\n    mouseX =\n      e.clientX +\n      document.body.scrollLeft +\n      document.documentElement.scrollLeft;\n    mouseY =\n      e.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n  }\n\n  // Get parent element position in document\n  if (object.offsetParent) {\n    do {\n      eventX += object.offsetLeft;\n      eventY += object.offsetTop;\n      object = object.offsetParent;\n    } while (object);\n  }\n\n  // Mouse position minus elm position is mouseposition relative to element:\n  return { x: mouseX - eventX, y: mouseY - eventY };\n}\n\nexport { eventElementPosition, normalizeWheel };\n","let UID = 0;\n\n/**\n * Provides a 64 bit UID.\n *\n * Note: all uids generated with uid() are unique amongst uid() calls and NOT unique amongst\n * other types of uid calls.\n */\nexport function uid() {\n  return ++UID;\n}\n\nlet CUID = 0;\n\n/**\n * Provides a 24 bit UID (keeps the UID within non-alpha color ranges)\n *\n * Note: all uids generated with colorUID() are unique amongst colorUID() calls and NOT unique amongst\n * other types of uid calls.\n */\nexport function colorUID() {\n  return ++CUID % 0xffffff;\n}\n","import { uid } from '../util/uid';\nimport { Instance } from './instance';\n\nexport class ObservableMonitoring {\n  static gatherIds: boolean = false;\n  static observableIds: number[] = [];\n  static observableNamesToUID = new Map<string, number>();\n\n  /**\n   * This activates all observables to gather their UIDs when they are retrieved via their getter.\n   * All of the ID's gathered can be accessed via getObservableMonitorIds. It is REQUIRED that this\n   * is disabled again to prevent a MASSIVE memory leak.\n   */\n  static setObservableMonitor(enabled: boolean) {\n    ObservableMonitoring.gatherIds = enabled;\n    ObservableMonitoring.observableIds = [];\n  }\n\n  /**\n   * This retrieves the observables montiored IDs that were gathered when setObservableMonitor was\n   * enabled.\n   */\n  static getObservableMonitorIds(clear?: boolean) {\n    const values = ObservableMonitoring.observableIds.slice(0);\n    if (clear) ObservableMonitoring.observableIds = [];\n\n    return values;\n  }\n}\n\n/**\n * This is a custom decorator intended for single properties on Instances only! It will\n * facilitate automatic updates and stream the updates through an InstanceProvider to properly\n * update the Instances values in the appropriate and corresponding buffers that will get committed\n * to the GPU.\n */\nexport function observable<T extends Instance>(target: T, key: string) {\n  // Here we store the name of the observable to a UID. This mapping allows us to have a UID\n  // per NAME of an observable. A UID for a name can produce MUCH faster lookups than the name itself.\n  // Matching against the name allows us to have instances with their own property sets but have matching\n  // name mappings to improve compatibility of Instances with varying Layers.\n  let propertyUID: number =\n    ObservableMonitoring.observableNamesToUID.get(key) || 0;\n\n  if (!propertyUID) {\n    propertyUID = uid();\n    ObservableMonitoring.observableNamesToUID.set(key, propertyUID);\n  }\n\n  /**\n   * New property getter to get the property's alternative storage since we overrode\n   * the initial storage with a custom getter and setter.\n   */\n  function getter(this: T) {\n    if (ObservableMonitoring.gatherIds) {\n      ObservableMonitoring.observableIds.push(propertyUID);\n    }\n    return this.observableStorage[propertyUID];\n  }\n\n  /**\n   * New property setter to replace the property marked as observable. This allows\n   * us to broadcast a change to our current observer.\n   */\n  function setter(this: T, newVal: any) {\n    // Update the privatized value\n    this.observableStorage[propertyUID] = newVal;\n    // Broadcast change\n    const observer = this.observer;\n    observer && observer.instanceUpdated(this, propertyUID);\n  }\n\n  /**\n   * Make sure the desired property is declared on the class with our custom getter and\n   * setter.\n   */\n  Object.defineProperty(target, key, {\n    configurable: true,\n    enumerable: true,\n    get: getter,\n    set: setter,\n  });\n}\n","import * as Three from 'three';\nimport { Instance } from '../../instance-provider/instance';\nimport { InstanceIOValue } from '../../types';\nimport { ILayerProps, Layer } from '../layer';\nimport { AtlasManager, AtlasResource } from './atlas-manager';\nimport { LabelAtlasResource } from './label-atlas-resource';\nimport { SubTexture } from './sub-texture';\n\nexport interface IAtlasResourceManagerOptions {\n  /** This is the atlas manager that handles operations with our atlas' */\n  atlasManager: AtlasManager;\n}\n\nfunction toInstanceIOValue(texture?: SubTexture): InstanceIOValue {\n  // If the texture is not defined we just output an empty reference\n  if (!texture) {\n    return [0, 0, 0, 0];\n  }\n\n  // Otherwise, we return the atlas information of the texture\n  return [\n    texture.atlasTL.x,\n    texture.atlasTL.y,\n    texture.atlasBR.x,\n    texture.atlasBR.y,\n  ];\n}\n\n/**\n * This class is responsible for tracking resources requested to be placed on an Atlas.\n * This makes sure the resource is uploaded and then properly cached so similar requests\n * return already existing resources. This also manages instances waiting for the resource\n * to be made available.\n */\nexport class AtlasResourceManager {\n  /** This is the atlas manager that handles operations with our atlas' */\n  atlasManager: AtlasManager;\n  /** This is the atlas currently targetted by requests */\n  targetAtlas: string = '';\n  /** This stores all of the requests awaiting dequeueing */\n  private requestQueue = new Map<string, AtlasResource[]>();\n  /**\n   * This tracks if a resource is already in the request queue. This also stores ALL instances awaiting the resource.\n   */\n  private requestLookup = new Map<\n    string,\n    Map<AtlasResource, [Layer<any, any>, Instance][]>\n  >();\n\n  constructor(options: IAtlasResourceManagerOptions) {\n    this.atlasManager = options.atlasManager;\n  }\n\n  /**\n   * This dequeues all instance requests for a resource and processes the request which will\n   * inevitably make the instance active\n   */\n  async dequeueRequests() {\n    // This flag will be modified to reflect if a dequeue operation has occurred\n    let didDequeue = false;\n\n    for (const [targetAtlas, resources] of Array.from(\n      this.requestQueue.entries(),\n    )) {\n      if (resources.length > 0) {\n        // We did dequeue\n        didDequeue = true;\n        // Pull out all of the requests into a new array and empty the existing queue to allow the queue to register\n        // New requests while this dequeue is being processed\n        const requests = resources.slice(0);\n        // Empty the queue to begin taking in new requests as needed\n        resources.length = 0;\n\n        // Tell the atlas manager to update with all of the requested resources\n        await this.atlasManager.updateAtlas(targetAtlas, requests);\n        // Get the requests for the given atlas\n        const atlasRequests = this.requestLookup.get(targetAtlas);\n\n        if (atlasRequests) {\n          // Once the manager has been updated, we can now flag all of the instances waiting for the resources\n          // As active, which should thus trigger an update to the layers to perform a diff for each instance\n          requests.forEach(resource => {\n            const request = atlasRequests.get(resource);\n            atlasRequests.delete(resource);\n\n            if (request) {\n              for (const [layer, instance] of request) {\n                // If the instance is still associated with buffer locations, then the instance can be activated. Having\n                // A buffer location is indicative the instance has not been deleted.\n                if (layer.bufferManager.getBufferLocations(instance)) {\n                  // Make sure the instance is active\n                  instance.active = true;\n                  // Trigger the resource attributes to update\n                  instance.resourceTrigger();\n                }\n              }\n            }\n          });\n        }\n      }\n    }\n\n    return didDequeue;\n  }\n\n  /**\n   * Free ALL resources managed under this resource manager\n   */\n  destroy() {\n    this.atlasManager.destroy();\n  }\n\n  /**\n   * This retrieves the actual atlas texture that should be applied to a uniform's\n   * value.\n   */\n  getAtlasTexture(key: string): Three.Texture | null {\n    const atlas = this.atlasManager.getAtlasTexture(key);\n\n    if (atlas) {\n      return atlas.texture;\n    }\n\n    return null;\n  }\n\n  /**\n   * This is a request for atlas texture resources. It will produce either the coordinates needed to\n   * make valid texture lookups, or it will trigger a loading of resources to an atlas and cause an\n   * automated deactivation and reactivation of the instance.\n   */\n  request<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>,\n    instance: Instance,\n    resource: AtlasResource,\n  ): InstanceIOValue {\n    const texture: SubTexture = resource.texture;\n\n    // If the texture is ready and available, then we simply return the IO values\n    if (texture) {\n      return toInstanceIOValue(texture);\n    }\n\n    if (resource instanceof LabelAtlasResource) {\n      if (!resource.label.text) {\n        return toInstanceIOValue(texture);\n      }\n    }\n\n    // If a request is already made, then we must save the instance making the request for deactivation and\n    // Reactivation but without any additional atlas loading\n    let atlasRequests = this.requestLookup.get(this.targetAtlas);\n\n    if (atlasRequests) {\n      const existingRequests = atlasRequests.get(resource);\n\n      if (existingRequests) {\n        existingRequests.push([layer, instance]);\n        instance.active = false;\n\n        return toInstanceIOValue(texture);\n      }\n    } else {\n      atlasRequests = new Map();\n      this.requestLookup.set(this.targetAtlas, atlasRequests);\n    }\n\n    // If the texture is not available, then we must load the resource, deactivate the instance\n    // And wait for the resource to become available. Once the resource is available, the system\n    // Must activate the instance to render the resource.\n    instance.active = false;\n    let requests = this.requestQueue.get(this.targetAtlas);\n\n    if (!requests) {\n      requests = [];\n      this.requestQueue.set(this.targetAtlas, requests);\n    }\n\n    requests.push(resource);\n    atlasRequests.set(resource, [[layer, instance]]);\n\n    // This returns essentially returns blank values for the resource lookup\n    return toInstanceIOValue(texture);\n  }\n\n  /**\n   * This is used by the system to target the correct atlas for subsequent requests to a resource.\n   */\n  setTargetAtlas(target: string) {\n    this.targetAtlas = target;\n  }\n}\n","import { Bounds } from '../primitives/bounds';\nimport { IPoint } from '../primitives/point';\n\n// A configuration that controls how readily a quadtree will split to another level\n// Adjusting this number can improve or degrade your performance significantly and\n// Must be tested for specific use cases\nconst maxPopulation: number = 5;\nconst maxDepth: number = 10;\n\nexport interface IQuadItem {\n  area: number;\n  bottom: number;\n  height: number;\n  left: number;\n  mid: IPoint;\n  right: number;\n  top: number;\n  width: number;\n  x: number;\n  y: number;\n\n  containsPoint(point: IPoint): boolean;\n  encapsulate(item: IQuadItem): boolean;\n  fits(item: IQuadItem): 0 | 1 | 2;\n  hitBounds(item: IQuadItem): boolean;\n  isInside(item: IQuadItem): boolean;\n}\n\n/**\n * This filters a quad tree query by type\n *\n * @export\n * @template T\n */\nexport function filterQuery<T extends IQuadItem>(\n  type: Function[],\n  queryValues: IQuadItem[],\n): T[] {\n  const filtered: T[] = [];\n\n  queryValues.forEach((obj: IQuadItem) => {\n    if (type.find(t => obj instanceof t)) {\n      filtered.push(obj as T);\n    }\n  });\n\n  return filtered;\n}\n\n/**\n * Allows typing of a callback argument\n */\nexport interface IVisitFunction<T extends IQuadItem> {\n  /**\n   * A callback to use during add or query\n   *\n   * Called do provide aggregation or filtering like Array.reduce or\n   * Array.filter, but in a QuadTree instead.\n   *\n   * @param node  The node to effect the function upon\n   * @param child The child to add to the node\n   */\n  (node: Node<T>, child?: IQuadItem): void;\n}\n\n/**\n * This is a class used specifically by the quad tree nodes to indicate split space\n * within the quad tree.\n *\n * @class Quadrants\n */\nexport class Quadrants<T extends IQuadItem> {\n  TL: Node<T>;\n  TR: Node<T>;\n  BL: Node<T>;\n  BR: Node<T>;\n\n  /**\n   * Ensures all memory is released for all nodes and all references are removed\n   * to potentially high memory consumption items\n   *\n   * @memberOf Quadrants\n   */\n  destroy() {\n    this.TL.destroy();\n    this.TR.destroy();\n    this.BL.destroy();\n    this.BR.destroy();\n    delete this.TL;\n    delete this.TR;\n    delete this.BL;\n    delete this.BR;\n  }\n\n  /**\n   * Creates an instance of Quadrants.\n   *\n   * @param bounds The bounds this will create quandrants for\n   * @param depth  The child depth of this element\n   *\n   * @memberOf Quadrants\n   */\n  constructor(bounds: IQuadItem, depth: number) {\n    const mid = bounds.mid;\n    this.TL = new Node<T>(bounds.x, mid.x, bounds.y, mid.y, depth);\n    this.TR = new Node<T>(mid.x, bounds.right, bounds.y, mid.y, depth);\n    this.BL = new Node<T>(bounds.x, mid.x, mid.y, bounds.bottom, depth);\n    this.BR = new Node<T>(mid.x, bounds.right, mid.y, bounds.bottom, depth);\n  }\n}\n\n/**\n * The quad tree node. This Node will take in a certain population before dividing itself into\n * 4 quadrants which it will attempt to inject it's population into. If a member of the population\n * does not completely get injected into one of the quadrants it remains as a member of this node.\n *\n * @export\n * @class Node\n */\nexport class Node<T extends IQuadItem> {\n  bounds: Bounds;\n  children: T[] = [];\n  depth: number = 0;\n  nodes: Quadrants<T>;\n\n  /**\n   * Destroys this node and ensures all child nodes are destroyed as well.\n   *\n   * @memberOf Node\n   */\n  destroy() {\n    delete this.children;\n    delete this.bounds;\n\n    if (this.nodes) {\n      this.nodes.destroy();\n      delete this.nodes;\n    }\n  }\n\n  /**\n   * Creates an instance of Node.\n   *\n   * @param l     The bounding left wall of the space this node covers\n   * @param r     The bounding right wall of the space this node covers\n   * @param t     The bounding top wall of the space this node covers\n   * @param b     The bounding bottom wall of the space this node covers\n   * @param depth The depth within the quad tree this node resides\n   *\n   * @memberOf Node\n   */\n  constructor(\n    left: number,\n    right: number,\n    top: number,\n    bottom: number,\n    depth?: number,\n  ) {\n    // If params insertted\n    if (arguments.length >= 4) {\n      this.bounds = new Bounds({\n        height: top - bottom,\n        width: right - left,\n        x: left,\n        y: top,\n      });\n    }\n\n    // Otherwise, make tiny start area\n    else {\n      this.bounds = new Bounds({\n        height: 1,\n        width: 1,\n        x: 0,\n        y: 0,\n      });\n    }\n\n    // Ensure the depth is set\n    this.depth = depth || 0;\n  }\n\n  /**\n   * Adds an object that extends Bounds (or is Bounds) and properly injects it into this node\n   * or into a sub quadrant if this node is split already. If the child is outside the boundaries\n   * this quad tree spans (and this is the root node), the quad tree will expand to include\n   * the new child.\n   *\n   * @param child The Bounds type object to inject\n   * @param props Properties that can be retrieved with the child object if applicable\n   *\n   * @returns True if the insertion was successful\n   *\n   * @memberOf Node\n   */\n  add(child: T, props: any): boolean {\n    // This is the entry function for adding children, so we must first expand our top node\n    // To cover the area that the child is located.\n    // If we're in bounds, then let's just add the child\n    if (child.isInside(this.bounds)) {\n      return this.doAdd(child);\n    }\n\n    // Otherwise, we need to expand first\n    else {\n      this.cover(child);\n      return this.add(child, props);\n    }\n  }\n\n  /**\n   * Adds a list of new children to this quad tree. It performs the same operations as\n   * addChild for each child in the list, however, it more efficiently recalculates the\n   * bounds necessary to cover the area the children cover.\n   *\n   * @param children      List of Bounds objects to inject\n   * @param childrenProps List of props to associate with each element\n   *\n   * @memberOf Node\n   */\n  addAll(children: T[], childrenProps?: any[]) {\n    // Ensure the properties are at least defined\n    childrenProps = childrenProps || [];\n\n    // Make sure we cover the entire area of all the children.\n    // We can speed this up a lot if we first calculate the total bounds the new children covers\n    let minX = Number.MAX_VALUE;\n    let minY = Number.MAX_VALUE;\n    let maxX = -Number.MAX_VALUE;\n    let maxY = -Number.MAX_VALUE;\n\n    // Get the dimensions of the new bounds\n    children.forEach(child => {\n      if (child.x < minX) {\n        minX = child.x;\n      }\n      if (child.right > maxX) {\n        maxX = child.right;\n      }\n      if (child.bottom > maxY) {\n        maxY = child.bottom;\n      }\n      if (child.y < minY) {\n        minY = child.y;\n      }\n    });\n\n    // Make sure our bounds includes the specified bounds\n    this.cover(\n      new Bounds({\n        height: maxY - minY,\n        width: maxX - minX,\n        x: minX,\n        y: minY,\n      }),\n    );\n\n    // Add all of the children into the tree\n    children.forEach((child, index) => this.doAdd(child));\n  }\n\n  /**\n   * Ensures this quad tree includes the bounds specified in it's spatial coverage.\n   * This will cause all children to be re-injected into the tree.\n   *\n   * @param bounds The bounds to include in the tree's coverage\n   *\n   * @memberOf Node\n   */\n  cover(bounds: IQuadItem) {\n    // If we are already covering the area: abort\n    if (bounds.isInside(this.bounds)) {\n      return;\n    }\n\n    // Make our bounds cover the new area\n    this.bounds.encapsulate(bounds);\n    this.bounds.x -= 1;\n    this.bounds.y -= 1;\n    this.bounds.width += 2;\n    this.bounds.height += 4;\n    // Get all of the children underneath this node\n    const allChildren = this.gatherChildren([]);\n\n    // Destroy the split nodes\n    if (this.nodes) {\n      // Completely...destroy...\n      this.nodes.destroy();\n      delete this.nodes;\n    }\n\n    // Reinsert all children with the new dimensions in place\n    allChildren.forEach((child, index) => this.doAdd(child));\n  }\n\n  /**\n   * When adding children, this performs the actual action of injecting the child into the tree\n   * without the process of seeing if the tree needs a spatial adjustment to account for the child.\n   *\n   * @param child The Bounds item to inject into the tree\n   * @param props The props to remain associated with the child\n   *\n   * @returns True if the injection was successful\n   *\n   * @memberOf Node\n   */\n  doAdd(child: T): boolean {\n    // If nodes are present, then we have already exceeded the population of this node\n    if (this.nodes) {\n      if (child.isInside(this.nodes.TL.bounds)) {\n        return this.nodes.TL.doAdd(child);\n      }\n\n      if (child.isInside(this.nodes.TR.bounds)) {\n        return this.nodes.TR.doAdd(child);\n      }\n\n      if (child.isInside(this.nodes.BL.bounds)) {\n        return this.nodes.BL.doAdd(child);\n      }\n\n      if (child.isInside(this.nodes.BR.bounds)) {\n        return this.nodes.BR.doAdd(child);\n      }\n\n      // Otherwise, this is a child overlapping this border\n      this.children.push(child);\n\n      return true;\n    }\n\n    // Otherwise, we have not had a split due to population limits being exceeded\n    else if (child.isInside(this.bounds)) {\n      this.children.push(child);\n\n      // If we exceeded our population for this quadrant, it is time to split up\n      if (this.children.length > maxPopulation && this.depth < maxDepth) {\n        this.split();\n      }\n\n      return true;\n    }\n\n    // This is when there is something wrong with the insertted child. The bounds\n    // For the quad should have grown without issue, but in this case the bounds\n    // Could not grow to accomodate the child.\n    if (isNaN(child.width + child.height + child.x + child.y)) {\n      console.error(\n        'Child did not fit into bounds because a dimension is NaN',\n        child,\n      );\n    } else if (child.area === 0) {\n      console.error(\n        'Child did not fit into bounds because the area is zero',\n        child,\n      );\n    }\n\n    // Don't insert the child and continue\n    return true;\n  }\n\n  /**\n   * Collects all children of all the current and sub nodes into a single list.\n   *\n   * @param list The list we must aggregate children into\n   *\n   * @return The list specified as the list parameter\n   */\n  gatherChildren(list: T[]): T[] {\n    list = list.concat(this.children);\n\n    if (this.nodes) {\n      this.nodes.TL.gatherChildren(list);\n      this.nodes.TR.gatherChildren(list);\n      this.nodes.BL.gatherChildren(list);\n      this.nodes.BR.gatherChildren(list);\n    }\n\n    return list;\n  }\n\n  /**\n   * Entry query for determining query type based on input object\n   *\n   * @param bounds Can be a Bounds or a Point object\n   * @param visit  A callback function that will receive the Node as it is analyzed. This gives\n   *               information on a spatial scale, how a query reaches it's target intersections.\n   *\n   * @return An array of children that intersects with the query\n   */\n  query(bounds: IQuadItem | IPoint, visit?: IVisitFunction<T>): T[] {\n    // Query a rectangle\n    if (bounds instanceof Bounds) {\n      if (bounds.hitBounds(this.bounds)) {\n        return this.queryBounds(bounds, [], visit);\n      }\n\n      // Return an empty array when nothing is collided with\n      return [];\n    }\n\n    // Query a point\n    if (this.bounds.containsPoint(bounds)) {\n      return this.queryPoint(bounds, [], visit);\n    }\n\n    // Return an empty array when nothing is collided with\n    return [];\n  }\n\n  /**\n   * Queries children for intersection with a bounds object\n   *\n   * @param b     The Bounds to test children against\n   * @param list  The list of children to aggregate into the query\n   * @param visit A callback function that will receive the Node as it is analyzed. This gives\n   *              information on a spatial scale, how a query reaches it's target intersections.\n   *\n   * @return     Returns the exact same list that was input as the list param\n   */\n  queryBounds(b: IQuadItem, list: T[], visit?: IVisitFunction<T>): T[] {\n    this.children.forEach((c, index) => {\n      if (c.hitBounds(b)) {\n        list.push(c);\n      }\n    });\n\n    if (visit) {\n      visit(this);\n    }\n\n    if (this.nodes) {\n      if (b.hitBounds(this.nodes.TL.bounds)) {\n        this.nodes.TL.queryBounds(b, list, visit);\n      }\n\n      if (b.hitBounds(this.nodes.TR.bounds)) {\n        this.nodes.TR.queryBounds(b, list, visit);\n      }\n\n      if (b.hitBounds(this.nodes.BL.bounds)) {\n        this.nodes.BL.queryBounds(b, list, visit);\n      }\n\n      if (b.hitBounds(this.nodes.BR.bounds)) {\n        this.nodes.BR.queryBounds(b, list, visit);\n      }\n    }\n\n    return list;\n  }\n\n  /**\n   * Queries children for intersection with a point\n   *\n   * @param p     The Point to test children against\n   * @param list  The list of children to aggregate into the query\n   * @param visit A callback function that will receive the Node as it is analyzed. This gives\n   *              information on a spatial scale, how a query reaches it's target intersections.\n   *\n   * @return      Returns the exact same list that was input as the list param\n   */\n  queryPoint(p: any, list: T[], visit?: IVisitFunction<T>): T[] {\n    this.children.forEach((c, index) => {\n      if (c.containsPoint(p)) {\n        list.push(c);\n      }\n    });\n\n    if (visit) {\n      visit(this);\n    }\n\n    if (this.nodes) {\n      if (this.nodes.TL.bounds.containsPoint(p)) {\n        this.nodes.TL.queryPoint(p, list, visit);\n      }\n\n      if (this.nodes.TR.bounds.containsPoint(p)) {\n        this.nodes.TR.queryPoint(p, list, visit);\n      }\n\n      if (this.nodes.BL.bounds.containsPoint(p)) {\n        this.nodes.BL.queryPoint(p, list, visit);\n      }\n\n      if (this.nodes.BR.bounds.containsPoint(p)) {\n        this.nodes.BR.queryPoint(p, list, visit);\n      }\n    }\n\n    return list;\n  }\n\n  /**\n   * Creates four sub quadrants for this node.\n   */\n  split() {\n    // Gather all items to be handed down\n    const allChildren = this.gatherChildren([]);\n    // Gather all props for the children to be handed down as well\n    this.nodes = new Quadrants<T>(this.bounds, this.depth + 1);\n\n    this.children = [];\n\n    while (allChildren.length > 0) {\n      const child = allChildren.pop();\n      if (child) this.doAdd(child);\n    }\n  }\n\n  /**\n   * Traverses the quad tree returning every quadrant encountered\n   *\n   * @param cb A callback that has the parameter (node) which is a quadrant in the tree\n   */\n  visit(cb: IVisitFunction<T>): void {\n    const finished = Boolean(cb(this));\n\n    if (this.nodes && !finished) {\n      this.nodes.TL.visit(cb);\n      this.nodes.TR.visit(cb);\n      this.nodes.BL.visit(cb);\n      this.nodes.BR.visit(cb);\n    }\n  }\n}\n\nexport class QuadTree<T extends IQuadItem> extends Node<T> {}\n","import { DataBounds } from '../util/data-bounds';\nimport { Bounds } from './bounds';\n\n/**\n * Anytime this is used to express bounds of an object, it is expected\n * to behave like CSS styling with absolute positioning.\n *\n * Setting a left and a right will auto calculate width (setting width takes precedence)\n *\n * You can set numbers to a %. If no % is present all other characters will be ignored\n * (px, em, and other dimensions will not be supported...just px by default unless %)\n */\nexport type AbsolutePosition = {\n  bottom?: number | string;\n  height?: number | string;\n  left?: number | string;\n  right?: number | string;\n  top?: number | string;\n  width?: number | string;\n};\n\nfunction value(val: number | string, ref: number, scaleRatio: number) {\n  const parse = `${val}`;\n  const num = parseFloat(parse);\n\n  if (isNaN(num)) {\n    return 0;\n  }\n\n  // If this is a percentage use the reference as the num to multiply against\n  if (parse.indexOf('%') > -1) {\n    return num / 100.0 * ref;\n  }\n\n  return num * scaleRatio;\n}\n\n/**\n * This evaluates an absolute position with a reference to produce meaningful bounds.\n *\n * The scaleRatio provided should be available in or for percents to have the same weighting\n * as whole number values.\n */\nexport function getAbsolutePositionBounds<T>(\n  item: AbsolutePosition,\n  reference: Bounds,\n  scaleRatio: number,\n): DataBounds<T> {\n  if (reference.width === 0 || reference.height === 0) {\n    console.warn(\n      'An AbsolutePosition evaluated to invalid dimensions.',\n      'Please ensure that the object provided and the reference has valid dimensions',\n      'to produce dimensions with width and height that are non-zero.',\n      'item:',\n      item,\n      'reference:',\n      reference.toString(),\n    );\n  }\n\n  const bounds = DataBounds.emptyBounds<T>();\n  let width;\n  let height;\n\n  // Calculate the horizontal values\n  if (item.width) {\n    bounds.width = value(item.width, reference.width, scaleRatio);\n\n    if (item.left !== undefined) {\n      bounds.x = value(item.left, reference.width, scaleRatio);\n    } else if (item.right !== undefined) {\n      bounds.x =\n        reference.width -\n        value(item.right, reference.width, scaleRatio) -\n        bounds.width;\n    }\n  } else {\n    const left = value(item.left || 0, reference.width, scaleRatio);\n    const right =\n      reference.width - value(item.right || 0, reference.width, scaleRatio);\n    width = right - left;\n\n    if (width < 0) {\n      console.warn(\n        'An AbsolutePosition evaluated to invalid dimensions.',\n        'Please ensure that the object provided and the reference has valid dimensions',\n        'to produce dimensions with width and height that are greater than zero.',\n        'item:',\n        item,\n        'reference:',\n        reference.toString(),\n      );\n    }\n\n    bounds.x = left;\n    bounds.width = width;\n  }\n\n  // Calculate the vertical values\n  if (item.height) {\n    bounds.height = value(item.height, reference.height, scaleRatio);\n\n    if (item.top !== undefined) {\n      bounds.y = value(item.top, reference.height, scaleRatio);\n    } else if (item.bottom !== undefined) {\n      bounds.y =\n        reference.height -\n        value(item.bottom, reference.height, scaleRatio) -\n        bounds.height;\n    }\n  } else {\n    const top = value(item.top || 0, reference.height, scaleRatio);\n    const bottom =\n      reference.height - value(item.bottom || 0, reference.height, scaleRatio);\n    height = bottom - top;\n\n    if (height === undefined || height < 0) {\n      console.warn(\n        'An AbsolutePosition evaluated to invalid dimensions.',\n        'Please ensure that the object provided and the reference has valid dimensions',\n        'to produce dimensions with width and height that are greater than zero.',\n        'item:',\n        item,\n        'reference:',\n        reference.toString(),\n      );\n    }\n\n    bounds.y = top;\n    bounds.height = height;\n  }\n\n  if (\n    bounds.width === 0 ||\n    bounds.height === 0 ||\n    isNaN(bounds.x + bounds.y + bounds.width + bounds.height)\n  ) {\n    bounds.x = 0;\n    bounds.y = 0;\n    bounds.width = reference.width;\n    bounds.height = reference.height;\n  }\n\n  return bounds;\n}\n","import { IPoint } from '../../primitives/point';\nimport { IProjection, PickType } from '../../types';\nimport { EventManager } from '../event-manager';\nimport { Layer } from '../layer';\nimport { LayerSurface } from '../layer-surface';\nimport {\n  IDragMetrics,\n  IMouseInteraction,\n  SceneView,\n} from '../mouse-event-manager';\n\nfunction isDefined<T>(val: T | null | undefined): val is T {\n  return Boolean(val);\n}\n\n/**\n * This class is an injected event manager for the surface, it specifically handles taking in mouse events intended for view interactions\n * and broadcasts them to the layers that have picking enabled, thus allowing the layers to respond to\n * mouse view locations and broadcast Instance interactions based on the interaction with the View the layer is a part of\n *\n * In Summary: This is an adapter that takes in interactions to the views and injects those events into the layers associated with\n * the views so that the layers can translate the events to gestures.\n */\nexport class LayerMouseEvents extends EventManager {\n  /** This tracks which views have the mouse over them so we can properly broadcast view is out events */\n  isOver = new Map<SceneView, boolean>();\n  /** This is the surface this manager is aiding with broadcasting events to layers */\n  sceneViews: SceneView[];\n  /**\n   * This is the surface this LayerMouseEvent Controller is operating on behalf of. We use this to trigger,\n   * pre-layer processing items, such as color pick narrowing prior to the Layers receiving the event.\n   */\n  surface: LayerSurface;\n\n  constructor(surface: LayerSurface) {\n    super();\n    this.surface = surface;\n    this.sceneViews = surface.sceneViews;\n  }\n\n  getSceneViewsUnderMouse(e: IMouseInteraction) {\n    const sceneViewByViewId = new Map<string, SceneView>();\n\n    // Map the scene views by the view's identifiers\n    for (const sceneView of this.sceneViews) {\n      sceneViewByViewId.set(sceneView.view.id, sceneView);\n    }\n\n    // Now retrieve and convert each view under the mouse to the scene view it coincides with\n    return e.viewsUnderMouse\n      .map(viewItem => sceneViewByViewId.get(viewItem.view.id))\n      .filter(isDefined);\n  }\n\n  getMouseByViewId(e: IMouseInteraction) {\n    // This is the mouse position for the provided view in view space\n    const viewMouseByViewId = new Map<string, IPoint>();\n\n    for (const viewItem of e.viewsUnderMouse) {\n      viewMouseByViewId.set(viewItem.view.id, viewItem.mouse);\n    }\n\n    return viewMouseByViewId;\n  }\n\n  handleClick(e: IMouseInteraction, button: number) {\n    this.handleInteraction(e, (layer, view, mouse) =>\n      layer.interactions.handleMouseClick(view, mouse, button),\n    );\n  }\n\n  handleDrag(e: IMouseInteraction, drag: IDragMetrics) {\n    this.handleInteraction(e, (layer, view, mouse) =>\n      layer.interactions.handleMouseDrag(view, mouse),\n    );\n  }\n\n  handleInteraction(\n    e: IMouseInteraction,\n    callback: (layer: Layer<any, any>, view: IProjection, mouse: IPoint) => void,\n  ) {\n    // Get all of the scenes under the mouse\n    const sceneViews = this.getSceneViewsUnderMouse(e);\n    // Get a lookup of a view id to the mouse position in the view\n    const viewMouseByViewId = this.getMouseByViewId(e);\n\n    // For every view of every scene, we must tell it's layers it's world space is receiving mouse interactions\n    for (const sceneView of sceneViews) {\n      this.handleSceneView(sceneView, viewMouseByViewId, callback);\n    }\n\n    return sceneViews;\n  }\n\n  handleMouseDown(e: IMouseInteraction, button: number) {\n    this.handleInteraction(e, (layer, view, mouse) =>\n      layer.interactions.handleMouseDown(view, mouse, button),\n    );\n  }\n\n  handleMouseUp(e: IMouseInteraction, button: number) {\n    this.handleInteraction(e, (layer, view, mouse) =>\n      layer.interactions.handleMouseUp(view, mouse, button),\n    );\n  }\n\n  handleMouseOver(e: IMouseInteraction) {\n    // We let the mouse move event handle the registration of moused over views\n  }\n\n  handleMouseOut(e: IMouseInteraction) {\n    // Get a lookup of a view id to the mouse position in the view\n    const viewMouseByViewId = this.getMouseByViewId(e);\n    const screen = e.screen.mouse;\n\n    // All views that are moused over should no longer be considered over and broadcast a mouse out\n    this.isOver.forEach((flag, sceneView) => {\n      // Since we are leaving the view we must make the view relative cooridinates fromt he screen space coords\n      viewMouseByViewId.set(\n        sceneView.view.id,\n        sceneView.view.screenToView(screen),\n      );\n\n      this.handleSceneView(sceneView, viewMouseByViewId, (layer, view, mouse) =>\n        layer.interactions.handleMouseOut(view, mouse),\n      );\n    });\n\n    // Nothing is over anymore\n    this.isOver.clear();\n  }\n\n  handleMouseMove(e: IMouseInteraction) {\n    if (this.surface) {\n      this.surface.updateColorPickRange(\n        [e.screen.mouse.x, e.screen.mouse.y],\n        e.viewsUnderMouse.map(v => v.view),\n      );\n    }\n\n    // Get all of the scenes we have interacted with, and broadcast a move event for each\n    const allSceneViews = this.handleInteraction(e, (layer, view, mouse) =>\n      layer.interactions.handleMouseMove(view, mouse),\n    );\n    // Get a lookup of a view id to the mouse position in the view\n    const viewMouseByViewId = this.getMouseByViewId(e);\n    // Get the position of the mouse on the screen\n    const screen = e.screen.mouse;\n\n    // For quick lookups map all of the current SceneViews that are over\n    const currentSceneViews = new Map<SceneView, boolean>();\n    allSceneViews.forEach(v => currentSceneViews.set(v, true));\n\n    // Detect which of the views are newly over\n    currentSceneViews.forEach((flag, sceneView) => {\n      if (!this.isOver.get(sceneView)) {\n        this.handleSceneView(\n          sceneView,\n          viewMouseByViewId,\n          (layer, view, mouse) =>\n            layer.interactions.handleMouseOver(view, mouse),\n        );\n      }\n    });\n\n    // Detect which of the views are no longer over\n    this.isOver.forEach((flag, sceneView) => {\n      if (!currentSceneViews.get(sceneView)) {\n        // Since these views were not interacted with, we must create the mouse interaction position\n        viewMouseByViewId.set(\n          sceneView.view.id,\n          sceneView.view.screenToView(screen),\n        );\n\n        this.handleSceneView(\n          sceneView,\n          viewMouseByViewId,\n          (layer, view, mouse) => layer.interactions.handleMouseOut(view, mouse),\n        );\n      }\n    });\n\n    // Update the current views that are over to the currently over views for next event\n    this.isOver = currentSceneViews;\n  }\n\n  handleSceneView(\n    sceneView: SceneView,\n    viewMouseByViewId: Map<string, IPoint>,\n    callback: (layer: Layer<any, any>, view: IProjection, mouse: IPoint) => void,\n  ) {\n    const view = sceneView.view;\n    const mouse = viewMouseByViewId.get(view.id);\n\n    if (mouse) {\n      for (const layer of sceneView.scene.layers) {\n        if (layer.picking && layer.picking.type !== PickType.NONE) {\n          callback(layer, view, mouse);\n        }\n      }\n    }\n  }\n\n  handleWheel(e: IMouseInteraction) {\n    // TODO: This may need to be implemented. As of right now, there is no particular benefit\n  }\n}\n","import { IColorPickingData } from '../types';\nimport { Vec2 } from './vector';\n\n/**\n * This analyzes the rendered data for color picking and outputs the metrics and data needed\n * for the operation.\n */\nexport function analyzeColorPickingRendering(\n  mouse: Vec2,\n  data: Uint8Array,\n  width: number,\n  height: number,\n) {\n  const pickingData: IColorPickingData = {\n    allColors: [],\n    colorData: data,\n    dataHeight: height,\n    dataWidth: width,\n    mouse,\n    nearestColor: 0,\n  };\n\n  const uniqueColors = new Map<number, boolean>();\n  let pixelIndex = 0;\n  const colors: number[][] = [];\n  const mouseX: number = width / 2;\n  const mouseY: number = height / 2;\n\n  let nearestColor = 0x000000;\n  let distance = Number.MAX_SAFE_INTEGER;\n\n  for (let i = 0; i < height; ++i) {\n    const row: number[] = [];\n    colors.push(row);\n\n    for (let k = 0; k < width; ++k) {\n      const r = data[pixelIndex];\n      const g = data[pixelIndex + 1];\n      const b = data[pixelIndex + 2];\n      pixelIndex += 4;\n\n      const color = (r << 16) | (g << 8) | b;\n      uniqueColors.set(color, true);\n      row.push(color);\n\n      // If the color is not black, let's test the distance against currnet nearest color\n      if (color !== 0x000000) {\n        const dx = k - mouseX;\n        const dy = i - mouseY;\n        const testDistance = dx * dx + dy * dy;\n\n        if (testDistance < distance) {\n          distance = testDistance;\n          nearestColor = color;\n        }\n      }\n    }\n  }\n\n  // Apply all o fthe unique colors that were discovered within the rendering\n  pickingData.allColors = Array.from(uniqueColors.keys());\n  // The nearest color will be the element in the middle of the array of colors\n  pickingData.nearestColor = nearestColor;\n\n  return pickingData;\n}\n","module.exports = \"// This portion is where the shader assigns the picking color that gets passed to the fragment shader\\n  _picking_color_pass_ = _pickingColor;\\n\"","module.exports = \"lowp vec4 setColor(vec4 color) {\\n  gl_FragColor = color;\\n  return gl_FragColor;\\n}\\n\"","module.exports = \"precision lowp float;\\n\\n// This contains the method required to be used on a fragment shader when a layer desires to use\\n// PickType.SINGLE (color picking).\\nvarying vec4 _picking_color_pass_;\\n\\nvec4 setColor(vec4 color) {\\n  gl_FragColor = mix(color, _picking_color_pass_, pickingActive);\\n\\n  if (color.a == 0.0) {\\n    discard;\\n  }\\n\\n  return gl_FragColor;\\n}\\n\"","module.exports = \"// This is the varying auto generated for the fragment shader that is needed in the vertex shader to pass the\\n// color for the instance through to the fragment shader\\nvarying vec4 _picking_color_pass_;\\n\"","module.exports = \"// These are projection methods utilizing the simpler camera breakdown approach\\n\\nvec3 cameraSpace(vec3 world) {\\n  return (world + cameraOffset) * cameraScale;\\n}\\n\\nvec3 cameraSpaceSize(vec3 worldSize) {\\n  return worldSize * cameraScale;\\n}\\n\\nvec4 clipSpace(vec3 world) {\\n  return vec4(((projection * modelView) * vec4(cameraSpace(world), 1.0)).xyz, 1.0);\\n}\\n\\nvec4 clipSpaceSize(vec3 worldSize) {\\n  return vec4(((projection * modelView) * vec4(cameraSpaceSize(worldSize), 0.0)).xyz, 1.0);\\n}\\n\"","module.exports = \"// When instancing is enabled, it causes a major list of uniforms to be generated\\n// it also generates a massive search tree to retrieve the correct unforms in question.\\n${instanceUniformDeclarations}\\n\\n// This is the uniforms provided by the system along with the uniforms created by the layer\\n${layerUniforms}\\n\\n// This is the attributes generated for vertex attributes\\n${vertexAttributes}\\n\\n// This is the methods and set up needed to retrieve a block of data for an instance\\n${instanceDataRetrieval}\\n\\n// This is the methods generated for the automated easing of attributes\\n${easingMethods}\\n\"","module.exports = \"// This is the injected dereferencing of the instance attributes\\n  ${instanceDestructuring}\\n\\n  // This is a special injected instance attribute. It lets the system\\n  // control specific instances ability to draw, which allows the backend\\n  // system greater control on how it optimizes draw calls and it's buffers.\\n  if (_active == 0.0) {\\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n\\n    // Quick exit to prevent any geometry from arising from the instance\\n    return;\\n  }\\n\\n  ${picking}\\n\"","module.exports = \"precision highp float;\\n\\n// This is the fragment shader generated by the system\\n${layerUniforms}\\n\\n${picking}\\n\\n// --------------- The fragment shader provided by the layer ------------------\\n${shader}\\n\"","module.exports = \"// This is the vertex shader generated by the system\\n${shaderInput}\\n${projectionMethods}\\n${picking}\\n// --------------- Vertex shader provided by the layer -----------------\\n${shader}\\n\"","module.exports = \"int instanceSize = ${instanceBlockCount};\\n\\nvec4 getBlock(int index, int instanceIndex) {\\n  return instanceData[(instanceSize * instanceIndex) + index];\\n}\\n\"","import * as Three from 'three';\nimport { Layer } from '../../surface/layer';\nimport { LayerBufferType } from '../../surface/layer-processing/layer-buffer-type';\nimport {\n  IInstanceAttribute,\n  IInstancingUniform,\n  InstanceAttributeSize,\n} from '../../types';\nimport { Instance } from '../../util';\nimport { AutoEasingLoopStyle } from '../../util/auto-easing-method';\nimport { shaderTemplate } from '../../util/shader-templating';\nimport { templateVars } from '../fragments/template-vars';\nimport { makeInstanceUniformNameArray } from './make-instance-uniform-name';\n\nconst instanceRetrievalArrayFragment = require('../fragments/instance-retrieval-array.vs');\n\n/** Defines the elements for destructuring out of a vector */\nconst VECTOR_COMPONENTS = ['x', 'y', 'z', 'w'];\n\n/** Converts a size to a shader type */\nconst sizeToType: { [key: number]: string } = {\n  1: 'float',\n  2: 'vec2',\n  3: 'vec3',\n  4: 'vec4',\n  9: 'mat3',\n  16: 'mat4',\n  /** This is the special case for instance attributes that want an atlas resource */\n  99: 'vec4',\n};\n\n/**\n * This sorts attributes specific to how they need to be destructured. For example:\n * easing attributes MUST appear AFTER all of the specially integrated attributes that were generated\n * such as start times and durations.\n */\nfunction orderByPriority(\n  a: IInstanceAttribute<any>,\n  b: IInstanceAttribute<any>,\n) {\n  if (a.easing && !b.easing) return 1;\n  return -1;\n}\n\nexport function makeUniformArrayDeclaration(totalBlocks: number) {\n  return {\n    fragment: `uniform vec4 ${makeInstanceUniformNameArray()}[${totalBlocks}];`,\n    materialUniforms: [\n      {\n        name: makeInstanceUniformNameArray(),\n        type: '4fv',\n        value: new Array(totalBlocks)\n          .fill(0)\n          .map(() => new Three.Vector4(0, 0, 0, 0)),\n      },\n    ] as IInstancingUniform[],\n  };\n}\n\nexport function makeInstanceRetrievalArray(blocksPerInstance: number) {\n  const templateOptions: { [key: string]: string } = {};\n  templateOptions[templateVars.instanceBlockCount] = `${blocksPerInstance}`;\n\n  const required = {\n    name: 'makeInstanceRetrievalArray',\n    values: [templateVars.instanceBlockCount],\n  };\n\n  const results = shaderTemplate(\n    instanceRetrievalArrayFragment,\n    templateOptions,\n    required,\n  );\n\n  return results.shader;\n}\n\nexport function makeInstanceDestructuringArray<T extends Instance>(\n  layer: Layer<T, any>,\n  instanceAttributes: IInstanceAttribute<T>[],\n  blocksPerInstance: number,\n) {\n  let out = '';\n\n  const orderedAttributes = instanceAttributes.slice(0).sort(orderByPriority);\n\n  if (layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE) {\n    out = instanceAttributeDestructuring(orderedAttributes);\n  } else {\n    out = uniformInstancingDestructuring(orderedAttributes, blocksPerInstance);\n  }\n\n  return out;\n}\n\nfunction instanceAttributeDestructuring<T extends Instance>(\n  orderedAttributes: IInstanceAttribute<T>[],\n) {\n  let out = '';\n\n  orderedAttributes.forEach(attribute => {\n    // If this is the source easing attribute, we must add it in as an eased method along with a calculation for the\n    // Easing interpolation time value based on the current time and the injected start time of the change.\n    if (attribute.easing && attribute.size) {\n      // Make the time calculation for the easing equation\n      out += makeAutoEasingTiming(attribute);\n\n      out += `  ${sizeToType[attribute.size]} ${attribute.name} = ${\n        attribute.easing.methodName\n      }(_${attribute.name}_start, _${attribute.name}_end, _${\n        attribute.name\n      }_time);\\n`;\n    }\n  });\n\n  return out;\n}\n\nfunction uniformInstancingDestructuring<T extends Instance>(\n  orderedAttributes: IInstanceAttribute<T>[],\n  blocksPerInstance: number,\n) {\n  let out = 'int instanceIndex = int(instance);';\n\n  // Generate the blocks\n  for (let i = 0; i < blocksPerInstance; ++i) {\n    out += `  vec4 block${i} = getBlock(${i}, instanceIndex);\\n`;\n  }\n\n  orderedAttributes.forEach(attribute => {\n    const block = attribute.block;\n\n    // If this is the source easing attribute, we must add it in as an eased method along with a calculation for the\n    // Easing interpolation time value based on the current time and the injected start time of the change.\n    if (attribute.easing && attribute.size) {\n      if (attribute.size === InstanceAttributeSize.FOUR) {\n        out += `  ${sizeToType[attribute.size]} _${\n          attribute.name\n        }_end = block${block};\\n`;\n      } else {\n        out += `  ${sizeToType[attribute.size || 1]} _${\n          attribute.name\n        }_end = block${block}.${makeVectorSwizzle(\n          attribute.blockIndex || 0,\n          attribute.size || 1,\n        )};\\n`;\n      }\n\n      // Generate the proper timing calculation for the easing involved\n      out += makeAutoEasingTiming(attribute);\n\n      out += `  ${sizeToType[attribute.size]} ${attribute.name} = ${\n        attribute.easing.methodName\n      }(_${attribute.name}_start, _${attribute.name}_end, _${\n        attribute.name\n      }_time);\\n`;\n    }\n\n    // If we have a size the size of a block, then don't swizzle the vector\n    else if (attribute.size === InstanceAttributeSize.FOUR) {\n      out += `  ${sizeToType[attribute.size]} ${\n        attribute.name\n      } = block${block};\\n`;\n    }\n\n    // If the attribute is an atlas, then we use the special ATLAS size and don't swizzle the vector\n    else if (attribute.atlas) {\n      out += `  ${sizeToType[InstanceAttributeSize.ATLAS]} ${\n        attribute.name\n      } = block${block};\\n`;\n    }\n\n    // Do normal destructuring with any other size and type\n    else {\n      out += `  ${sizeToType[attribute.size || 1]} ${\n        attribute.name\n      } = block${block}.${makeVectorSwizzle(\n        attribute.blockIndex || 0,\n        attribute.size || 1,\n      )};\\n`;\n    }\n  });\n\n  return out;\n}\n\nfunction makeAutoEasingTiming<T extends Instance>(attribute: IInstanceAttribute<T>) {\n  if (!attribute.easing) {\n    return;\n  }\n\n  let out = '';\n\n  switch (attribute.easing.loop) {\n    // Continuous means letting the time go from 0 to infinity\n    case AutoEasingLoopStyle.CONTINUOUS: {\n      out += `  float _${\n        attribute.name\n      }_time = (currentTime - _${\n        attribute.name\n      }_start_time) / _${attribute.name}_duration;\\n`;\n      break;\n    }\n\n    // Repeat means going from 0 to 1 then 0 to 1 etc etc\n    case AutoEasingLoopStyle.REPEAT: {\n      out += `  float _${\n        attribute.name\n      }_time = clamp(fract((currentTime - _${\n        attribute.name\n      }_start_time) / _${attribute.name}_duration), 0.0, 1.0);\\n`;\n      break;\n    }\n\n    // Reflect means going from 0 to 1 then 1 to 0 then 0 to 1 etc etc\n    case AutoEasingLoopStyle.REFLECT: {\n      // Get the time passed in a linear fashion\n      out += `  float _${attribute.name}_timePassed = (currentTime - _${\n        attribute.name\n      }_start_time) / _${attribute.name}_duration;\\n`;\n      // Make a triangle wave from the time passed to ping pong the value\n      out += `  float _${attribute.name}_pingPong = abs((fract(_${\n        attribute.name\n      }_timePassed / 2.0)) - 0.5) * 2.0;\\n`;\n      // Ensure we're clamped to the right values\n      out += `  float _${attribute.name}_time = clamp(_${\n        attribute.name\n      }_pingPong, 0.0, 1.0);\\n`;\n      break;\n    }\n\n    // No loop means just linear time\n    case AutoEasingLoopStyle.NONE:\n    default: {\n      out += `  float _${attribute.name}_time = clamp((currentTime - _${\n        attribute.name\n      }_start_time) / _${attribute.name}_duration, 0.0, 1.0);\\n`;\n      break;\n    }\n  }\n\n  return out;\n}\n\nfunction makeVectorSwizzle(start: number, size: number) {\n  return VECTOR_COMPONENTS.slice(start, start + size).join('');\n}\n","/**\n * The goal of this file is to take in model attributes and instance attributes specified\n * and inject the proper attributes into the shaders so the implementor of the shader does\n * not worry about syncing attribute and uniform names between the JS\n */\nimport { ILayerProps, Layer } from '../../surface/layer';\nimport { LayerBufferType } from '../../surface/layer-processing/layer-buffer-type';\nimport {\n  IInstanceAttribute,\n  IInstancingUniform,\n  InstanceAttributeSize,\n  IShaders,\n  IUniform,\n  IVertexAttribute,\n  PickType,\n  ShaderInjectionTarget,\n} from '../../types';\nimport { Instance } from '../../util';\nimport {\n  IShaderTemplateRequirements,\n  shaderTemplate,\n} from '../../util/shader-templating';\nimport { WebGLStat } from '../../util/webgl-stat';\nimport { templateVars } from '../fragments/template-vars';\nimport { instanceAttributeShaderName } from './instance-attribute-shader-name';\nimport {\n  makeInstanceDestructuringArray,\n  makeInstanceRetrievalArray,\n  makeUniformArrayDeclaration,\n} from './uniform-instance-block-array';\n\n// These are all of the necessary fragments that will comprise our shader that is generated\nconst vertexShaderComposition = require('../fragments/vertex-shader-composition.vs');\nconst fragmentShaderComposition = require('../fragments/fragment-shader-composition.fs');\nconst instanceDestructuringArray = require('../fragments/instance-destructuring-array.vs');\nconst shaderInput = require('../fragments/shader-input.vs');\nconst projectionMethods = require('../fragments/projection-methods.vs');\n\n// Constants\n\n/**\n * Defines how many floats are available in a uniform block\n * What is a uniform block you ask? Why let me tell you! It is how opengl stores and communicates uniforms\n * to the GPU. Whenever you declare a uniform, it will use a hunk of memory. You can see how many uniforms\n * a GPU can have via the paramter MAX_VERTEX_UNIFORM_VECTORS. The number returned is the number of blocks\n * we can use for uniforms in the vertex shader. A BLOCK is an entire vec4.\n *\n * When you declare a uniform in your shader, it will use an entire BLOCK at the MINIMUM.\n *\n * A uniform float uses 1 block. vec2 uses 1 block. vec3 uses one block. vec4 uses one block.\n * mat4 uses 4 blocks. mat3 uses 3 blocks.\n *\n * etc etc.\n */\nconst MAX_USE_PER_BLOCK = 4;\n\n/** Converts a size to a shader type */\nconst sizeToType: { [key: number]: string } = {\n  1: 'float',\n  2: 'vec2',\n  3: 'vec3',\n  4: 'vec4',\n  9: 'mat3',\n  16: 'mat4',\n  99: 'sampler2D',\n};\n\nfunction calculateUniformBlockUseage(uniforms: IUniform[]) {\n  let count = 0;\n\n  for (let i = 0, end = uniforms.length; i < end; ++i) {\n    count += Math.ceil(uniforms[i].size / 4);\n  }\n\n  return count;\n}\n\nexport interface IInjectionDetails {\n  fs: string;\n  materialUniforms: IInstancingUniform[];\n  maxInstancesPerBuffer: number;\n  vs: string;\n}\n\n/**\n * This method is the main algorithm for piecing together all of the attributes necessary\n * and injecting them into the shaders.\n *\n * @param shaders\n * @param vertexAttributes\n * @param instanceAttributes\n */\nexport function injectFragments<T extends Instance, U extends ILayerProps<T>>(\n  layer: Layer<T, U>,\n  shaders: IShaders,\n  vertexAttributes: IVertexAttribute[],\n  instanceAttributes: IInstanceAttribute<any>[],\n  uniforms: IUniform[],\n): IInjectionDetails {\n  const shaderInputMetrics = generateShaderInputs(\n    layer,\n    vertexAttributes,\n    instanceAttributes,\n    uniforms,\n  );\n\n  let templateOptions: { [key: string]: string } = {\n    [templateVars.projectionMethods]: generateProjectionMethods(),\n    [templateVars.picking]: generateVertexPicking(layer),\n    [templateVars.shaderInput]: shaderInputMetrics.fragment,\n    [templateVars.shader]: generateVertexShader(\n      layer,\n      shaders,\n      instanceAttributes,\n      shaderInputMetrics.metrics.maxInstancesPerBuffer,\n      shaderInputMetrics.metrics.blocksPerInstance,\n    ),\n  };\n\n  let required = {\n    name: 'vertex shader composition',\n    values: [\n      templateVars.projectionMethods,\n      templateVars.shaderInput,\n      templateVars.shader,\n    ],\n  };\n\n  // If our layer is using color picking, then we must require the shader to include the ${picking} annotation\n  // To receive the fragment picking method\n  if (layer.picking.type === PickType.SINGLE) {\n    required.values.push(templateVars.picking);\n  }\n\n  const vertexShaderResults = shaderTemplate(\n    vertexShaderComposition,\n    templateOptions,\n    required,\n  );\n\n  templateOptions = {\n    [templateVars.layerUniforms]: generateUniforms(\n      uniforms,\n      ShaderInjectionTarget.FRAGMENT,\n    ),\n    [templateVars.shader]: generateFragmentShader(shaders),\n    [templateVars.picking]: generateFragmentPickingMethod(layer),\n  };\n\n  required = {\n    name: 'fragment shader composition',\n    values: [templateVars.layerUniforms, templateVars.shader],\n  };\n\n  // If our layer is using color picking, then we must require the shader to include the ${picking} annotation\n  // To receive the fragment picking method\n  if (layer.picking.type === PickType.SINGLE) {\n    required.values.push(templateVars.picking);\n  }\n\n  const fragmentShaderResults = shaderTemplate(\n    fragmentShaderComposition,\n    templateOptions,\n    required,\n  );\n\n  return {\n    fs: fragmentShaderResults.shader,\n    materialUniforms: shaderInputMetrics.materialUniforms,\n    maxInstancesPerBuffer: shaderInputMetrics.metrics.maxInstancesPerBuffer,\n    vs: vertexShaderResults.shader,\n  };\n}\n\n/**\n * Creates the projection method fragment\n */\nfunction generateProjectionMethods() {\n  const templateOptions: { [key: string]: string } = {};\n  const required: IShaderTemplateRequirements = {\n    name: 'projection methods',\n    values: [],\n  };\n\n  const results = shaderTemplate(projectionMethods, templateOptions, required);\n\n  return results.shader;\n}\n\n/**\n * Generates the fragments for shader IO such as vertex and instance attributes\n */\nfunction generateShaderInputs<T extends Instance, U extends ILayerProps<T>>(\n  layer: Layer<T, U>,\n  vertexAttributes: IVertexAttribute[],\n  instanceAttributes: IInstanceAttribute<T>[],\n  uniforms: IUniform[],\n) {\n  const templateOptions: { [key: string]: string } = {};\n\n  let instancingInfo;\n\n  if (layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE) {\n    instancingInfo = {\n      materialUniforms: [],\n      metrics: {\n        blocksPerInstance: 0,\n        maxInstancesPerBuffer: 0,\n      },\n    };\n\n    templateOptions.instanceDataRetrieval = '';\n    templateOptions.instanceUniformDeclarations = '';\n  } else {\n    instancingInfo = generateInstanceDataLookupOptions(\n      layer,\n      templateOptions,\n      instanceAttributes,\n      uniforms,\n    );\n  }\n\n  const additionalOptions: { [key: string]: string } = {\n    [templateVars.layerUniforms]: generateUniforms(\n      uniforms,\n      ShaderInjectionTarget.VERTEX,\n    ),\n    [templateVars.vertexAttributes]: generateVertexAttributes(\n      layer,\n      vertexAttributes,\n      instanceAttributes,\n    ),\n    [templateVars.easingMethods]: generateEasingMethods(instanceAttributes),\n  };\n\n  Object.assign(templateOptions, additionalOptions);\n\n  const required: IShaderTemplateRequirements = {\n    name: 'shader input',\n    values: [\n      templateVars.instanceDataRetrieval,\n      templateVars.instanceUniformDeclarations,\n      templateVars.layerUniforms,\n      templateVars.vertexAttributes,\n      templateVars.easingMethods,\n    ],\n  };\n\n  const results = shaderTemplate(shaderInput, templateOptions, required);\n\n  return {\n    fragment: results.shader,\n    materialUniforms: instancingInfo.materialUniforms,\n    metrics: instancingInfo.metrics,\n  };\n}\n\n/**\n * Generates the easing methods for the Shader specified by each attribute\n */\nfunction generateEasingMethods<T extends Instance>(\n  instanceAttributes: IInstanceAttribute<T>[],\n) {\n  const methods = new Map<string, Map<InstanceAttributeSize, string>>();\n  let out = '';\n\n  // First dedupe the methods needed by their method name\n  instanceAttributes.forEach(attribute => {\n    if (attribute.easing && attribute.size) {\n      let methodSizes = methods.get(attribute.easing.methodName);\n\n      if (!methodSizes) {\n        methodSizes = new Map<InstanceAttributeSize, string>();\n        methods.set(attribute.easing.methodName, methodSizes);\n      }\n\n      methodSizes.set(attribute.size, attribute.easing.gpu);\n    }\n  });\n\n  const required: IShaderTemplateRequirements = {\n    name: 'Easing Method Generation',\n    values: [templateVars.easingMethod],\n  };\n\n  // Now generate the full blown method for each element. We create overloaded methods for\n  // Each method name for each vector size required\n  methods.forEach(\n    (methodSizes: Map<InstanceAttributeSize, string>, methodName: string) => {\n      methodSizes.forEach((method, size) => {\n        const sizeType = sizeToType[size];\n\n        const templateOptions: { [key: string]: string } = {\n          [templateVars.easingMethod]: `${sizeType} ${methodName}(${sizeType} start, ${sizeType} end, float t)`,\n          [templateVars.T]: `${sizeType}`,\n        };\n\n        const results = shaderTemplate(method, templateOptions, required);\n\n        out += `${results.shader}\\n`;\n      });\n    },\n  );\n\n  return out;\n}\n\n/**\n * Generates all of the uniforms that are provided by the shader IO.\n */\nfunction generateUniforms(\n  uniforms: IUniform[],\n  injectionType: ShaderInjectionTarget,\n) {\n  let out = '';\n  const injection = injectionType || ShaderInjectionTarget.VERTEX;\n\n  uniforms.forEach(uniform => {\n    uniform.shaderInjection =\n      uniform.shaderInjection || ShaderInjectionTarget.VERTEX;\n\n    if (\n      uniform.shaderInjection === injection ||\n      uniform.shaderInjection === ShaderInjectionTarget.ALL\n    ) {\n      out += `uniform ${uniform.qualifier || ''}${\n        uniform.qualifier ? ' ' : ''\n      }${sizeToType[uniform.size]} ${uniform.name};\\n`;\n    }\n  });\n\n  return out;\n}\n\n/**\n * This takes in the layer's vertex shader and transforms any required templating within the\n * shader.\n */\nfunction generateVertexShader<T extends Instance, U extends ILayerProps<T>>(\n  layer: Layer<T, U>,\n  shaders: IShaders,\n  instanceAttributes: IInstanceAttribute<T>[],\n  maxInstancesPerBuffer: number,\n  blocksPerInstance: number,\n) {\n  const templateOptions: { [key: string]: string } = {\n    [templateVars.attributes]: makeInstanceAttributeReferences(\n      layer,\n      instanceAttributes,\n      blocksPerInstance,\n    ),\n  };\n\n  const required = {\n    name: 'layer vertex shader',\n    values: [templateVars.attributes],\n  };\n\n  const results = shaderTemplate(shaders.vs, templateOptions, required);\n\n  return results.shader;\n}\n\n/**\n * This generates the header portion required for vertex picking to work\n */\nfunction generateVertexPicking(layer: Layer<any, any>) {\n  if (layer.picking.type === PickType.SINGLE) {\n    return require('../fragments/color-picking-vertex-header.vs');\n  }\n\n  return '';\n}\n\n/**\n * This generates the fragment that defines the picking methods\n */\nfunction generateFragmentPickingMethod(layer: Layer<any, any>) {\n  if (layer.picking.type === PickType.SINGLE) {\n    return require('../fragments/color-picking-method.fs');\n  }\n\n  return require('../fragments/color-picking-disabled.fs');\n}\n\nfunction generateFragmentShader(shaders: IShaders) {\n  const templateOptions: { [key: string]: string } = {};\n\n  const required: IShaderTemplateRequirements = {\n    name: 'layer fragment shader',\n    values: [],\n  };\n\n  const results = shaderTemplate(shaders.fs, templateOptions, required);\n\n  return results.shader;\n}\n\n/**\n * This generates the inline attribute references needed to be able to reference instance attribute\n * vars.\n */\nfunction makeInstanceAttributeReferences<\n  T extends Instance,\n  U extends ILayerProps<T>\n>(\n  layer: Layer<T, U>,\n  instanceAttributes: IInstanceAttribute<T>[],\n  blocksPerInstance: number,\n) {\n  const templateOptions: { [key: string]: string } = {};\n  templateOptions[templateVars.blocksPerInstance] = `${blocksPerInstance}`;\n  templateOptions[\n    templateVars.instanceDestructuring\n  ] = makeInstanceDestructuringArray(\n    layer,\n    instanceAttributes,\n    blocksPerInstance,\n  );\n  templateOptions[templateVars.picking] = makePickingDestructuring(layer);\n\n  const required = {\n    name: 'instance attributes fragment',\n    values: [templateVars.instanceDestructuring],\n  };\n\n  // If picking is enabled, then we require the picking set up that we inject into the destructuring portion\n  // Of the shader\n  if (layer.picking.type === PickType.SINGLE) {\n    required.values.push(templateVars.picking);\n  }\n\n  const results = shaderTemplate(\n    instanceDestructuringArray,\n    templateOptions,\n    required,\n  );\n\n  return results.shader;\n}\n\n/**\n * This generates the portion of picking logic that is injected into the destructuring portion of the shader\n */\nfunction makePickingDestructuring(layer: Layer<any, any>) {\n  if (layer.picking.type === PickType.SINGLE) {\n    return require('../fragments/color-picking-assignment.vs');\n  }\n\n  return '';\n}\n\n/**\n * This generates the model attribute declarations\n */\nfunction generateVertexAttributes(\n  layer: Layer<any, any>,\n  vertexAttributes: IVertexAttribute[],\n  instanceAttributes: IInstanceAttribute<any>[],\n) {\n  let out = '';\n\n  vertexAttributes.forEach(attribute => {\n    out += `attribute ${sizeToType[attribute.size]} ${attribute.qualifier ||\n      ''}${(attribute.qualifier && ' ') || ''} ${attribute.name};\\n`;\n  });\n\n  if (layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE) {\n    out += '\\n// Instance Attributes\\n';\n    instanceAttributes.forEach(attribute => {\n      out += `attribute ${\n        sizeToType[attribute.size || 1]\n      } ${attribute.qualifier || ''}${(attribute.qualifier && ' ') ||\n        ''} ${instanceAttributeShaderName(attribute)};\\n`;\n    });\n  }\n\n  return out;\n}\n\n/**\n * This method generates the chunk of shader that is responsible for providing\n */\nfunction generateInstanceDataLookupOptions<\n  T extends Instance,\n  U extends ILayerProps<T>\n>(\n  layer: Layer<T, U>,\n  templateOptions: { [key: string]: string },\n  instanceAttributes: IInstanceAttribute<T>[],\n  uniforms: IUniform[],\n) {\n  // This is how many uniform blocks the current device can utilize in a shader\n  const maxUniforms = WebGLStat.MAX_VERTEX_UNIFORMS;\n  // This reflects how many uniform blocks are available for instancing\n  const instanceUniformBlockCount =\n    maxUniforms - calculateUniformBlockUseage(uniforms);\n\n  // Go through the attributes provided and calculate the number of blocks requested\n  // Also sort the attributes by block and pack the block useage down.\n  const sortedInstanceAttributes = instanceAttributes\n    .slice(0)\n    .sort((a, b) => a.block - b.block);\n\n  let currentBlock = sortedInstanceAttributes[0].block;\n  let trueBlockIndex = 0;\n\n  // This tracks how much a block is used\n  const blockUseage = new Map<number, number>();\n  const innerBlockUseage = new Map<number, Map<number, boolean>>();\n\n  sortedInstanceAttributes.forEach(attribute => {\n    if (attribute.block !== currentBlock) {\n      currentBlock = attribute.block;\n      trueBlockIndex++;\n    }\n\n    const attributeSize = attribute.size || 1;\n    const oldUseage = blockUseage.get(trueBlockIndex) || 0;\n    const newUseage = oldUseage + attributeSize;\n\n    // Make sure the block isn't over used thus losing attribute information\n    if (newUseage > MAX_USE_PER_BLOCK) {\n      console.error(\n        `An instance attribute was specified that over fills the maximum allowed useage for a block.`,\n        `\\nSource Layer: ${layer.id}`,\n        `\\nMax Allowed per block ${MAX_USE_PER_BLOCK}`,\n        `\\nAttribute: ${attribute.name} Block Specified: ${attribute.block}`,\n        `\\nTotal blocks used with this attribute: ${newUseage}`,\n      );\n      return;\n    }\n\n    // Store how much of the block is utilized\n    blockUseage.set(trueBlockIndex, newUseage);\n    // We can now auto specify the inner index of where the attribute lines up within the block\n    attribute.blockIndex = oldUseage;\n\n    // Now we examine the attributes request of use inside the block and make sure there is no\n    // Overlap\n    const innerUseage =\n      innerBlockUseage.get(trueBlockIndex) || new Map<number, boolean>();\n\n    if (attribute.blockIndex + attributeSize > MAX_USE_PER_BLOCK) {\n      console.error(\n        `An instance attribute was specified that would fill indices greater than the block allows.`,\n        `\\nMax index per block ${MAX_USE_PER_BLOCK}`,\n        `\\nAttribute: ${attribute.name} Block Index: ${\n          attribute.blockIndex\n        } Size: ${attribute.size} Block Index + Size: ${attribute.blockIndex +\n          (attribute.size || 1)}`,\n      );\n\n      return;\n    }\n\n    for (\n      let i = attribute.blockIndex;\n      i < attribute.blockIndex + attributeSize;\n      ++i\n    ) {\n      if (innerUseage.get(i)) {\n        console.error(\n          `An instance attribute was specified who's block index overaps another attributes useage`,\n          `\\nMax index per block ${MAX_USE_PER_BLOCK}`,\n          `\\nAttribute: ${attribute.name} Block Index: ${\n            attribute.blockIndex\n          } Size: ${attribute.size} Block Index + Size: ${attribute.blockIndex +\n            (attribute.size || 1)}`,\n        );\n\n        return;\n      }\n    }\n\n    // Adjust the attribute to reflect the actual bock it is using\n    attribute.block = trueBlockIndex;\n  });\n\n  const blocksPerInstance = trueBlockIndex + 1;\n  // This determines how many instances our allowed uniforms will allow for a single draw call\n  const maxInstancesPerBuffer = Math.floor(\n    instanceUniformBlockCount / blocksPerInstance,\n  );\n\n  // Generate the decision tree and uniform declarations\n  const instancingMetrics = makeUniformInstanceDataOptions(\n    templateOptions,\n    maxInstancesPerBuffer,\n    blocksPerInstance,\n    sortedInstanceAttributes,\n  );\n\n  return {\n    materialUniforms: instancingMetrics.materialUniforms,\n    metrics: {\n      blocksPerInstance,\n      maxInstancesPerBuffer,\n    },\n  };\n}\n\n/**\n * This generates all of the necessary templating information from uniform-instance-data\n * in order to provide an instance data getter for the application.\n */\nfunction makeUniformInstanceDataOptions<T extends Instance>(\n  templateOptions: { [key: string]: string },\n  maxInstancesPerBuffer: number,\n  blocksPerInstance: number,\n  instanceAttributes: IInstanceAttribute<T>[],\n) {\n  // Make a list containing all instance indicies that will be utilized and will be split\n  // Out into the decision tree\n  const instances = [];\n\n  for (let i = 0; i < maxInstancesPerBuffer; ++i) {\n    instances.push(i);\n  }\n\n  // Make the uniform declaration. Uniform declaration simultaneously gives us the material uniforms necessary\n  // To apply to our three material.\n  const uniformMetrics = makeInstanceUniformDeclaration(\n    maxInstancesPerBuffer * blocksPerInstance,\n    instanceAttributes,\n  );\n\n  templateOptions[templateVars.instanceUniformDeclarations] =\n    uniformMetrics.fragment;\n  templateOptions[templateVars.instanceBlockCount] = `${blocksPerInstance}`;\n\n  // This method produces the data retrieval method for array instancing\n  templateOptions[\n    templateVars.instanceDataRetrieval\n  ] = makeInstanceRetrievalArray(blocksPerInstance);\n\n  return {\n    materialUniforms: uniformMetrics.materialUniforms,\n  };\n}\n\n/**\n * This generates the declaration of all of the individual uniform registers for instancing.\n */\nfunction makeInstanceUniformDeclaration<T extends Instance>(\n  instanceUniformBlockCount: number,\n  attributes: IInstanceAttribute<T>[],\n) {\n  let out = '';\n  const blockQualifierDedup = new Map<number, Map<string, boolean>>();\n  let maxBlock = 0;\n\n  // Dedup the attributes specified for the\n  attributes.forEach(attribute => {\n    const qualifiers =\n      blockQualifierDedup.get(attribute.block) || new Map<string, boolean>();\n    // Make sure the qualifier is added for the block!\n    if (attribute.qualifier) {\n      qualifiers.set(attribute.qualifier, true);\n    }\n\n    // Get the max block in use\n    maxBlock = Math.max(maxBlock, attribute.block);\n  });\n\n  // Generate the full string for the specified qualifiers\n  const blockQualifiers = new Map<number, string>();\n\n  blockQualifierDedup.forEach((qualifierList, block) => {\n    const allQualifiers = Array.from(qualifierList.keys());\n    blockQualifiers.set(block, `${allQualifiers.join(' ')} `);\n  });\n\n  // Generate our uniform declarations\n  // Const blockCount = maxBlock + 1;\n\n  // This method produces the instancing declaration for a search tree.\n  // *out += makeUniformDecisionTreeDeclarations(instanceUniformBlockCount, blockCount, blockQualifiers, materialUniforms);\n  // This method produces the instancing declaration for an instancing array\n  const declaration = makeUniformArrayDeclaration(instanceUniformBlockCount);\n  out += declaration.fragment;\n\n  out += `\\n`;\n\n  return {\n    fragment: out,\n    materialUniforms: declaration.materialUniforms,\n  };\n}\n","import * as Three from 'three';\nimport { WebGLRenderTarget } from 'three';\nimport { ImageInstance } from '../base-layers/images';\nimport { LabelInstance } from '../base-layers/labels';\nimport { Instance } from '../instance-provider/instance';\nimport { Bounds } from '../primitives/bounds';\nimport { Box } from '../primitives/box';\nimport { injectFragments } from '../shaders/util/attribute-generation';\nimport { PickType } from '../types';\nimport { FrameMetrics } from '../types';\nimport { analyzeColorPickingRendering } from '../util/color-picking-analysis';\nimport { DataBounds } from '../util/data-bounds';\nimport { Vec2 } from '../util/vector';\nimport { EventManager } from './event-manager';\nimport { LayerMouseEvents } from './event-managers/layer-mouse-events';\nimport { ILayerProps, Layer } from './layer';\nimport {\n  generateDefaultScene,\n  IDefaultSceneElements,\n} from './layer-processing/generate-default-scene';\nimport { generateLayerGeometry } from './layer-processing/generate-layer-geometry';\nimport { generateLayerMaterial } from './layer-processing/generate-layer-material';\nimport { generateLayerModel } from './layer-processing/generate-layer-model';\nimport { injectShaderIO } from './layer-processing/inject-shader-io';\nimport {\n  getLayerBufferType,\n  makeLayerBufferManager,\n} from './layer-processing/layer-buffer-type';\nimport { MouseEventManager, SceneView } from './mouse-event-manager';\nimport { ISceneOptions, Scene } from './scene';\nimport { AtlasManager } from './texture';\nimport { IAtlasOptions } from './texture/atlas';\nimport { AtlasResourceManager } from './texture/atlas-resource-manager';\nimport { ClearFlags, View } from './view';\n\nexport interface ILayerSurfaceOptions {\n  /**\n   * These are the atlas resources we want available that our layers can be provided to utilize\n   * for their internal processes.\n   */\n  atlasResources?: IAtlasOptions[];\n  /**\n   * This is the color the canvas will be set to.\n   */\n  background: [number, number, number, number];\n  /**\n   * If this is provided, it will use this context for rendering. If a string is provided\n   * it will search for the canvas context by id.\n   */\n  context?: WebGLRenderingContext | HTMLCanvasElement | string;\n  /**\n   * This is the event managers to respond to the mouse events.\n   */\n  eventManagers?: EventManager[];\n  /**\n   * Set to true to allow this surface to absorb and handle wheel events from the mouse.\n   */\n  handlesWheelEvents?: boolean;\n  /**\n   * This specifies the density of rendering in the surface. The default value is window.devicePixelRatio to match the\n   * monitor for optimal clarity. Using a value of 1 will be acceptable, will not get high density renders, but will\n   * have better performance if needed.\n   */\n  pixelRatio?: number;\n  /**\n   * This sets up the available scenes the surface will have to work with. Layers then can\n   * reference the scene by it's scene property. The order of the scenes here is the drawing\n   * order of the scenes.\n   */\n  scenes?: ISceneOptions[];\n}\n\nconst DEFAULT_BACKGROUND_COLOR = new Three.Color(1.0, 1.0, 1.0);\n\nfunction isCanvas(val: any): val is HTMLCanvasElement {\n  return Boolean(val.getContext);\n}\n\nfunction isString(val: any): val is String {\n  return Boolean(val.substr);\n}\n\nfunction isWebGLContext(val: any): val is WebGLRenderingContext {\n  return Boolean(val.canvas);\n}\n\nexport interface ILayerConstructable<T extends Instance> {\n  new (props: ILayerProps<T>): Layer<any, any>;\n}\n\n/**\n * This is a pair of a Class Type and the props to be applied to that class type.\n */\nexport type LayerInitializer = [\n  ILayerConstructable<Instance> & { defaultProps: ILayerProps<Instance> },\n  ILayerProps<Instance>\n];\n\n/**\n * Used for reactive layer generation and updates.\n */\nexport function createLayer<T extends Instance, U extends ILayerProps<T>>(\n  layerClass: ILayerConstructable<T> & { defaultProps: U },\n  props: U,\n): LayerInitializer {\n  return [layerClass, props];\n}\n\n/**\n * This is a manager for layers. It will use voidgl layers to intelligently render resources\n * as efficiently as possible. Layers will be rendered in the order they are provided and this\n * surface will provide some basic camera controls by default.\n */\nexport class LayerSurface {\n  /** This is the atlas manager that will help with modifying and tracking atlas' generated for the layers */\n  private atlasManager: AtlasManager = new AtlasManager();\n  /** This is the gl context this surface is rendering to */\n  private context: WebGLRenderingContext;\n  /** This is the current viewport the renderer state is in */\n  currentViewport = new Map<Three.WebGLRenderer, Box>();\n  /**\n   * This is the default scene that layers get added to if they do not specify a valid Scene.\n   * This scene by default only has a single default view.\n   */\n  defaultSceneElements: IDefaultSceneElements;\n  /**\n   * This is the metrics of the current running frame\n   */\n  frameMetrics: FrameMetrics = {\n    currentFrame: 0,\n    currentTime: Date.now() | 0,\n    previousTime: Date.now() | 0,\n  };\n  /**\n   * This is used to help resolve concurrent draws. There are some very async operations that should\n   * not overlap in draw calls.\n   */\n  private isBufferingAtlas = false;\n  /** This is all of the layers in this manager by their id */\n  layers = new Map<string, Layer<any, any>>();\n  /** This manages the mouse events for the current canvas context */\n  private mouseManager: MouseEventManager;\n  /**\n   * This is the renderer that is meant for rendering the picking pass. We have a separate renderer so we can disable\n   * over complicated features like antialiasing which would ruin the picking pass.\n   */\n  pickingRenderer: Three.WebGLRenderer;\n  /** This is a target used to perform rendering our picking pass */\n  pickingTarget: Three.WebGLRenderTarget;\n  /** This is the density the rendering renders for the surface */\n  pixelRatio: number = window.devicePixelRatio;\n  /** This is the THREE render system we use to render scenes with views */\n  renderer: Three.WebGLRenderer;\n  /** This is the resource manager that handles resource requests for instances */\n  resourceManager: AtlasResourceManager;\n  /**\n   * This is all of the available scenes and their views for this surface. Layers reference the IDs\n   * of the scenes and the views to be a part of their rendering state.\n   */\n  scenes = new Map<string, Scene>();\n  /**\n   * This is all of the views currently generated for this surface paired with the scene they render.\n   */\n  sceneViews: SceneView[] = [];\n  /** When set to true, the next render will make sure color picking is updated for layer interactions */\n  updateColorPick?: {\n    mouse: Vec2;\n    views: View[];\n  };\n  /**\n   * This flags all layers by id for disposal at the end of every render. A Layer must be recreated\n   * after each render in order to clear it's disposal flag. This is the trick to making this a\n   * reactive system.\n   */\n  willDisposeLayer = new Map<string, boolean>();\n\n  /** Read only getter for the gl context */\n  get gl() {\n    return this.context;\n  }\n\n  /**\n   * This adds a layer to the manager which will manage all of the resource lifecycles of the layer\n   * as well as additional helper injections to aid in instancing and shader i/o.\n   */\n  private addLayer<T extends Instance, U extends ILayerProps<T>, V>(\n    layer: Layer<T, U>,\n  ): Layer<T, U> {\n    if (!layer.id) {\n      console.warn('All layers must have an id');\n      return layer;\n    }\n\n    if (this.layers.get(layer.id)) {\n      console.warn('All layer\\'s ids must be unique per layer manager');\n      return layer;\n    }\n\n    // We add the layer to our management\n    this.layers.set(layer.id, layer);\n    // Now we initialize the layer's gl components\n    this.initLayer(layer);\n\n    return layer;\n  }\n\n  /**\n   * The performs all of the needed updates that layers need to commit to the scene and buffers\n   * to be ready for a draw pass. This is callable outside of the draw loop to allow for specialized\n   * procedures or optimizations to take place, where incremental updates to the buffers would make\n   * the most sense.\n   *\n   * @param time The start time of the given frame\n   * @param frameIncrement When true, the frame count for the frame metrics will increment\n   * @param onViewReady Callback for when all of the layers of a scene view have been committed\n   *                    and are thus potentially ready to be rendered.\n   */\n  async commit(\n    time?: number,\n    frameIncrement?: boolean,\n    onViewReady?: (\n      scene: Scene,\n      view: View,\n      pickingPass: Layer<any, any>[],\n    ) => void,\n  ) {\n    if (!this.gl) return;\n\n    // We are rendering a new frame so increment our frame count\n    if (frameIncrement) this.frameMetrics.currentFrame++;\n    this.frameMetrics.previousTime = this.frameMetrics.currentTime;\n\n    // If no manual time was provided, we shall use Date.now in 32 bit format\n    if (time === undefined) {\n      this.frameMetrics.currentTime = Date.now() | 0;\n    } else {\n      // If this is our first frame and we have a manual time entry, then we first need to sync up\n      // The manual time as our previous timing.\n      if (this.frameMetrics.previousTime === this.frameMetrics.currentTime) {\n        this.frameMetrics.previousTime = time;\n      }\n\n      this.frameMetrics.currentTime = time;\n    }\n\n    // Get the scenes in their added order\n    const scenes = Array.from(this.scenes.values());\n    const validLayers: { [key: string]: Layer<any, any> } = {};\n    const erroredLayers: { [key: string]: [Layer<any, any>, Error] } = {};\n\n    // Loop through scenes\n    for (let i = 0, end = scenes.length; i < end; ++i) {\n      const scene = scenes[i];\n      const views = Array.from(scene.viewById.values());\n      const layers = scene.layers;\n\n      // Make sure the layers are depth sorted\n      scene.sortLayers();\n\n      // Loop through the views\n      for (let k = 0, endk = views.length; k < endk; ++k) {\n        const view = views[k];\n        // When this flags true, a picking pass will be rendered for the provided scene / view\n        const pickingPass: Layer<any, any>[] = [];\n\n        // We must perform any operations necessary to make the view camera fit the viewport\n        // Correctly\n        view.fitViewtoViewport(\n          new Bounds({\n            height: this.context.canvas.height,\n            width: this.context.canvas.width,\n            x: 0,\n            y: 0,\n          }),\n        );\n\n        // Let the layers update their uniforms before the draw\n        for (let j = 0, endj = layers.length; j < endj; ++j) {\n          // Get the layer to be rendered in the scene\n          const layer = layers[j];\n          // Update the layer with the view it is about to be rendered with\n          layer.view = view;\n          // Make sure the layer is given the opportunity to update all of it's uniforms\n          // To match the view state and update any unresolved diffs internally\n          try {\n            layer.draw();\n            validLayers[layer.id] = layer;\n          } catch (err) {\n            if (!erroredLayers[layer.id]) {\n              erroredLayers[layer.id] = [layer, err];\n            }\n          }\n\n          // If this layer specifies a picking draw pass, then we shall store it in the current draw order\n          // For that next step\n          if (layer.picking.type === PickType.SINGLE) {\n            pickingPass.push(layer);\n          }\n        }\n\n        if (onViewReady) {\n          onViewReady(scene, view, pickingPass);\n        }\n      }\n    }\n\n    // get the layers with errors flagged for them\n    const errors = Object.values(erroredLayers);\n\n    if (errors.length > 0) {\n      const passed = Object.values(validLayers);\n\n      console.warn(\n        'Some layers errored during their draw update. These layers will be removed. They can be re-added if render() is called again:',\n        errors.map(err => err[0].id),\n      );\n\n      // Output each layer and why it errored\n      errors.forEach(err => {\n        console.warn(`Layer ${err[0].id} removed for the following error:`);\n        if (err[1]) console.error(err[1].stack || err[1].message);\n      });\n\n      // Re-render but only include non-errored layers\n      this.render(passed.map(layer => layer.initializer));\n    }\n  }\n\n  /**\n   * Free all resources consumed by this surface that gets applied to the GPU.\n   */\n  destroy() {\n    this.layers.forEach(layer => layer.destroy());\n    this.resourceManager.destroy();\n    this.mouseManager.destroy();\n    this.sceneViews.forEach(sceneView => sceneView.scene.destroy());\n    this.renderer.dispose();\n    this.pickingRenderer.dispose();\n    this.currentViewport.clear();\n\n    // TODO: Instances should be implementing destroy for these clean ups.\n    LabelInstance.destroy();\n    ImageInstance.destroy();\n  }\n\n  /**\n   * This is the draw loop that must be called per frame for updates to take effect and display.\n   *\n   * @param time This is an optional time flag so one can manually control the time flag for the frame.\n   *             This will affect animations and other automated gpu processes.\n   */\n  async draw(time?: number) {\n    if (!this.gl) return;\n\n    // Make the layers commit their changes to the buffers then draw each scene view on\n    // Completion.\n    this.commit(time, true, (scene, view, pickingPass) => {\n      // Now perform the rendering\n      this.drawSceneView(scene.container, view);\n\n      // If a layer needs a picking pass, then perform a picking draw pass only\n      // if a request for the color pick has been made, then we query the pixels rendered to our picking target\n      if (pickingPass.length > 0 && this.updateColorPick) {\n        // Get the requested metrics\n        const mouse = this.updateColorPick.mouse;\n        const views = this.updateColorPick.views;\n\n        // Only if the view is interacted with should we both with rendering\n        if (\n          view.id !== this.defaultSceneElements.view.id &&\n          views.indexOf(view) > -1\n        ) {\n          // Picking uses a pixel ratio of 1\n          view.pixelRatio = 1.0;\n          // Get the current flags for the view\n          const flags = view.clearFlags.slice(0);\n          // Set color rendering flasg\n          view.clearFlags = [ClearFlags.COLOR, ClearFlags.DEPTH];\n\n          // We must perform any operations necessary to make the view camera fit the viewport\n          // Correctly with the possibly adjusted pixel ratio\n          view.fitViewtoViewport(\n            new Bounds({\n              height: this.context.canvas.height / this.pixelRatio,\n              width: this.context.canvas.width / this.pixelRatio,\n              x: 0,\n              y: 0,\n            }),\n          );\n\n          // We must redraw the layers so they will update their uniforms to adapt to a picking pass\n          for (let j = 0, endj = pickingPass.length; j < endj; ++j) {\n            const layer = pickingPass[j];\n            layer.picking.currentPickMode = PickType.SINGLE;\n            try {\n              layer.draw();\n            } catch (err) {\n              /** No-op, the first draw should have output an error for bad draw calls */\n            }\n            layer.picking.currentPickMode = PickType.NONE;\n          }\n\n          // Draw the picking container for the scene with our view long with our specialized picking renderer\n          // NOTE: Neat trick, just remove 'this.pickingTarget' from the argument and add\n          // canvas.parentNode.appendChild(this.pickingRenderer.getContext().canvas);\n          // below where the picking Target is created and you will see what is being rendered to the color picking buffer\n          this.drawSceneView(\n            scene.pickingContainer,\n            view,\n            this.pickingRenderer,\n            this.pickingTarget,\n          );\n\n          // Make our metrics for how much of the image we wish to analyze\n          const pickWidth = 5;\n          const pickHeight = 5;\n          const numBytesPerColor = 4;\n          const out = new Uint8Array(pickWidth * pickHeight * numBytesPerColor);\n\n          // Read the pixels out\n          // TODO: We need to defer this reading to next frame as the rendering MUST be completed before a readPixels\n          // operation can complete. Thus in complex rendering situations that pushes the GPU, this could be a MAJOR bottleneck.\n          this.pickingRenderer.readRenderTargetPixels(\n            this.pickingTarget,\n            mouse[0] - view.screenBounds.x - pickWidth / 2,\n            view.screenBounds.height -\n              (mouse[1] - view.screenBounds.y) -\n              pickHeight / 2,\n            pickWidth,\n            pickHeight,\n            out,\n          );\n\n          // Analyze the rendered color data for the picking routine\n          const pickingData = analyzeColorPickingRendering(\n            mouse,\n            out,\n            pickWidth,\n            pickHeight,\n          );\n\n          // We must redraw the layers so they will update their uniforms to adapt to a picking pass\n          for (let j = 0, endj = pickingPass.length; j < endj; ++j) {\n            const layer = pickingPass[j];\n\n            if (layer.picking.type === PickType.SINGLE) {\n              layer.interactions.colorPicking = pickingData;\n            }\n          }\n\n          // Return the pixel ratio back to the rendered ratio\n          view.pixelRatio = this.pixelRatio;\n          // Return the view's clear flags\n          view.clearFlags = flags;\n\n          // After reverting the pixel ratio, we must return to the state we came from so that mouse interactions\n          // will work properly\n          view.fitViewtoViewport(\n            new Bounds({\n              height: this.context.canvas.height,\n              width: this.context.canvas.width,\n              x: 0,\n              y: 0,\n            }),\n          );\n        }\n      }\n    });\n\n    // After we have drawn our views of our scenes, we can now ensure all of the bounds\n    // Are updated in the interactions and flag our interactions ready for mouse input\n    if (this.mouseManager.waitingForRender) {\n      this.sceneViews.forEach(sceneView => {\n        sceneView.bounds = new DataBounds(sceneView.view.screenBounds);\n        sceneView.bounds.data = sceneView;\n      });\n\n      this.mouseManager.waitingForRender = false;\n    }\n\n    // Now that all of our layers have performed updates to everything, we can now dequeue\n    // All resource requests\n    // We create this gate in case multiple draw calls flow through before a buffer opertion is completed\n    if (!this.isBufferingAtlas) {\n      this.isBufferingAtlas = true;\n      const didBuffer = await this.resourceManager.dequeueRequests();\n      this.isBufferingAtlas = false;\n\n      // If buffering did occur and completed, then we should be performing a draw to ensure all of the\n      // Changes are committed and pushed out.\n      if (didBuffer) this.draw();\n    }\n\n    // Clear out the flag requesting a pick pass so we don't perform a pick render pass unless we have\n    // another requested from mouse interactions\n    delete this.updateColorPick;\n  }\n\n  /**\n   * This finalizes everything and sets up viewports and clears colors and performs the actual render step\n   */\n  private drawSceneView(\n    scene: Three.Scene,\n    view: View,\n    renderer?: Three.WebGLRenderer,\n    target?: Three.WebGLRenderTarget,\n  ) {\n    renderer = renderer || this.renderer;\n\n    const offset = { x: view.viewBounds.left, y: view.viewBounds.top };\n    const size = view.viewBounds;\n    const rendererSize = renderer.getSize();\n    const pixelRatio = renderer.getPixelRatio();\n    rendererSize.width *= pixelRatio;\n    rendererSize.height *= pixelRatio;\n    const background = view.background;\n    const context = renderer.getContext();\n\n    // Something is up with threejs that does not allow us to set viewport x and y values. So for targets\n    // We simply size the target to the view size and render. Thus scissoring is not required\n    if (!target) {\n      // Set the scissor rectangle.\n      context.enable(context.SCISSOR_TEST);\n      context.scissor(\n        offset.x,\n        rendererSize.height - offset.y - size.height,\n        size.width,\n        size.height,\n      );\n      // If a background is established, we should clear the background color\n      // Specified for this context\n      if (view.background) {\n        // Clear the rect of color and depth so the region is totally it's own\n        context.clearColor(\n          background[0],\n          background[1],\n          background[2],\n          background[3],\n        );\n      }\n    }\n\n    // Get the view's clearing preferences\n    if (view.clearFlags) {\n      // For targets, we must also perform clear operations\n      if (target) {\n        // TODO: This is frustrating. Right now we can't specify and set the viewport for a render target\n        // Possibly with Threejs going away we can actually be more explcit for the render area to a render target\n        // and not cause this overhead of resizing the render target for every picking pass\n        target.setSize(size.width, size.height);\n        renderer.setRenderTarget(target);\n        renderer.clear(\n          view.clearFlags.indexOf(ClearFlags.COLOR) > -1,\n          view.clearFlags.indexOf(ClearFlags.DEPTH) > -1,\n          view.clearFlags.indexOf(ClearFlags.STENCIL) > -1,\n        );\n      } else {\n        renderer\n          .getContext()\n          .clear(\n            (view.clearFlags.indexOf(ClearFlags.COLOR) > -1\n              ? context.COLOR_BUFFER_BIT\n              : 0x0) |\n              (view.clearFlags.indexOf(ClearFlags.DEPTH) > -1\n                ? context.DEPTH_BUFFER_BIT\n                : 0x0) |\n              (view.clearFlags.indexOf(ClearFlags.STENCIL) > -1\n                ? context.STENCIL_BUFFER_BIT\n                : 0x0),\n          );\n      }\n    }\n\n    // Default clearing is depth and color\n    else {\n      // For targets, we must also perform clear operations\n      if (target) {\n        // TODO: This is frustrating. Right now we can't specify and set the viewport for a render target\n        // Possibly with Threejs going away we can actually be more explcit for the render area to a render target\n        // and not cause this overhead of resizing the render target for every picking pass\n        target.setSize(size.width, size.height);\n        renderer.setRenderTarget(target);\n        renderer.clear(true, true);\n      } else {\n        context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);\n      }\n    }\n\n    // Make sure the viewport is set properly for the next render\n    renderer.setViewport(\n      offset.x / pixelRatio,\n      offset.y / pixelRatio,\n      size.width,\n      size.height,\n    );\n    // Render the scene with the provided view metrics\n    renderer.render(scene, view.viewCamera.baseCamera, target);\n  }\n\n  /**\n   * This allows for querying a view's screen bounds. Null is returned if the view id\n   * specified does not exist.\n   */\n  getViewSize(viewId: string): Bounds | null {\n    for (const sceneView of this.sceneViews) {\n      if (sceneView.view.id === viewId) {\n        return sceneView.view.screenBounds;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * This queries a view's window into a world's space.\n   */\n  getViewWorldBounds(viewId: string): Bounds | null {\n    for (const sceneView of this.sceneViews) {\n      if (sceneView.view.id === viewId) {\n        const view = sceneView.view;\n\n        if (view.screenBounds) {\n          const topLeft = view.viewToWorld({ x: 0, y: 0 });\n          const bottomRight = view.screenToWorld({\n            x: view.screenBounds.right,\n            y: view.screenBounds.bottom,\n          });\n\n          return new Bounds({\n            bottom: bottomRight.y,\n            left: topLeft.x,\n            right: bottomRight.x,\n            top: topLeft.y,\n          });\n        } else {\n          return null;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * This is the beginning of the system. This should be called immediately after the surface is constructed.\n   * We make this mandatory outside of the constructor so we can make it follow an async pattern.\n   */\n  async init(options: ILayerSurfaceOptions) {\n    // Make sure our desired pixel ratio is set up\n    this.pixelRatio = options.pixelRatio || this.pixelRatio;\n    // Make sure we have a gl context to work with\n    this.setContext(options.context);\n\n    if (this.gl) {\n      // Initialize our GL needs that set the basis for rendering\n      this.initGL(options);\n      // Initialize our event manager that handles mouse interactions/gestures with the canvas\n      this.initMouseManager(options);\n      // Initialize any resources requested or needed, such as textures or rendering surfaces\n      await this.initResources(options);\n    } else {\n      console.warn(\n        'Could not establish a GL context. Layer Surface will be unable to render',\n      );\n    }\n\n    return this;\n  }\n\n  /**\n   * This initializes the Canvas GL contexts needed for rendering.\n   */\n  private initGL(options: ILayerSurfaceOptions) {\n    if (!this.context) {\n      console.error(\n        'Can not initialize Layer Surface as a valid GL context was not established.',\n      );\n      return;\n    }\n\n    // Get the canvas of our context to set up our Three settings\n    const canvas = this.context.canvas;\n    // Get the starting width and height so adjustments don't affect it\n    const width = canvas.width;\n    const height = canvas.height;\n\n    // Generate the renderer along with it's properties\n    this.renderer = new Three.WebGLRenderer({\n      // Context supports rendering to an alpha canvas only if the background color has a transparent\n      // Alpha value.\n      alpha: options.background && options.background[3] < 1.0,\n      // Yes to antialias! Make it preeeeetty!\n      antialias: true,\n      // Make three use an existing canvas rather than generate another\n      canvas,\n      // TODO: This should be toggleable. If it's true it allows us to snapshot the rendering in the canvas\n      //       But we dont' always want it as it makes performance drop a bit.\n      preserveDrawingBuffer: true,\n    });\n\n    // Generate a renderer for the picking pass\n    this.pickingRenderer = new Three.WebGLRenderer({\n      // Context supports rendering to an alpha canvas only if the background color has a transparent\n      // Alpha value.\n      alpha: false,\n      // Picking shall not\n      antialias: false,\n      // Do not need this for picking\n      preserveDrawingBuffer: true,\n    });\n\n    // NOTE: Uncomment this plus remove this.pickingTarget from the drawSceneView of the color picking pass\n    // to view the colors rendered to the color picking buffer. This disables the interactions but helps\n    // debug what's going on with shaders etc\n    // canvas.parentNode.appendChild(this.pickingRenderer.getContext().canvas);\n\n    // We want clearing to be controlled via the layer\n    this.renderer.autoClear = false;\n    // This sets the pixel ratio to handle differing pixel densities in screens\n    this.setRendererSize(width, height);\n    // Set the pixel ratio to match the pixel density of the monitor in use\n    this.renderer.setPixelRatio(this.pixelRatio);\n\n    // Applies the background color and establishes whether or not the context supports\n    // Alpha or not\n    if (options.background) {\n      this.renderer.setClearColor(\n        new Three.Color(\n          options.background[0],\n          options.background[1],\n          options.background[2],\n        ),\n        options.background[3],\n      );\n    }\n\n    // If a background color was not established, then we set a default background color\n    else {\n      this.renderer.setClearColor(DEFAULT_BACKGROUND_COLOR);\n    }\n\n    // We want clearing to be controlled via the layer\n    this.pickingRenderer.autoClear = false;\n    // Picking does not need retina style precision\n    this.pickingRenderer.setPixelRatio(1.0);\n    // Applies the background color and establishes whether or not the context supports\n    // Alpha or not\n    this.pickingRenderer.setClearColor(new Three.Color(0, 0, 0), 1);\n\n    // Once we have made our renderer we now make us a default scene to which we can add objects\n    this.defaultSceneElements = generateDefaultScene(this.context);\n    this.defaultSceneElements.view.background = options.background;\n    // Set the default scene\n    this.scenes.set(\n      this.defaultSceneElements.scene.id,\n      this.defaultSceneElements.scene,\n    );\n    // Make a scene view depth tracker so we can track the order each scene view combo is drawn\n    let sceneViewDepth = 0;\n\n    // Make a SceneView for the default scene and view for mouse interactions\n    this.sceneViews.push({\n      depth: ++sceneViewDepth,\n      scene: this.defaultSceneElements.scene,\n      view: this.defaultSceneElements.view,\n    });\n\n    // Turn on the scissor test to keep the rendering clipped within the\n    // Render region of the context\n    this.context.enable(this.context.SCISSOR_TEST);\n\n    // Add the requested scenes to the surface and apply the necessary defaults\n    if (options.scenes) {\n      options.scenes.forEach(sceneOptions => {\n        // Make us a new scene based on the requested options\n        const newScene = new Scene(sceneOptions);\n\n        // Make sure the default view is available for each scene\n        // IFF no view is provided for the scene\n        if (sceneOptions.views.length === 0) {\n          newScene.addView(this.defaultSceneElements.view);\n\n          this.sceneViews.push({\n            depth: ++sceneViewDepth,\n            scene: newScene,\n            view: this.defaultSceneElements.view,\n          });\n        }\n\n        // Generate the views requested for the scene\n        sceneOptions.views.forEach(viewOptions => {\n          const newView = new View(viewOptions);\n          newView.camera = newView.camera || this.defaultSceneElements.camera;\n          newView.viewCamera =\n            newView.viewCamera || this.defaultSceneElements.viewCamera;\n          newView.viewport =\n            newView.viewport || this.defaultSceneElements.viewport;\n          newView.pixelRatio = this.pixelRatio;\n          newScene.addView(newView);\n\n          for (const sceneView of this.sceneViews) {\n            if (sceneView.view.id === newView.id) {\n              console.warn(\n                'You can NOT have two views with the same id. Please use unique identifiers for every view generated.',\n              );\n            }\n          }\n\n          this.sceneViews.push({\n            depth: ++sceneViewDepth,\n            scene: newScene,\n            view: newView,\n          });\n        });\n\n        this.scenes.set(sceneOptions.key, newScene);\n      });\n    }\n  }\n\n  /**\n   * This does special initialization by gathering the layers shader IO, generates a material\n   * and injects special automated uniforms and attributes to make instancing work for the\n   * shader.\n   */\n  private initLayer<T extends Instance, U extends ILayerProps<T>, V>(\n    layer: Layer<T, U>,\n  ): Layer<T, U> {\n    // Set the layer's parent surface here\n    layer.surface = this;\n    // Set the resource manager this surface utilizes to the layer\n    layer.resource = this.resourceManager;\n    // For the sake of initializing uniforms to the correct values, we must first add the layer to it's appropriate\n    // Scene so that the necessary values will be in place for the sahder IO\n    const scene = this.addLayerToScene(layer);\n    // Get the shader metrics the layer desires\n    const shaderIO = layer.initShader();\n    // Clean out nulls provided as a convenience to the layer\n    shaderIO.instanceAttributes = (shaderIO.instanceAttributes || []).filter(\n      Boolean,\n    );\n    shaderIO.vertexAttributes = (shaderIO.vertexAttributes || []).filter(\n      Boolean,\n    );\n    shaderIO.uniforms = (shaderIO.uniforms || []).filter(Boolean);\n    // Get the injected shader IO attributes and uniforms\n    const { vertexAttributes, instanceAttributes, uniforms } = injectShaderIO(\n      this.gl,\n      layer,\n      shaderIO,\n    );\n    // After all of the shader IO is established, let's calculate the appropriate buffering strategy\n    // For the layer.\n    getLayerBufferType(this.gl, layer, vertexAttributes, instanceAttributes);\n    // Generate the actual shaders to be used by injecting all of the necessary fragments and injecting\n    // Instancing fragments\n    const shaderMetrics = injectFragments(\n      layer,\n      shaderIO,\n      vertexAttributes,\n      instanceAttributes,\n      uniforms,\n    );\n    // Generate the geometry this layer will be utilizing\n    const geometry = generateLayerGeometry(\n      layer,\n      shaderMetrics.maxInstancesPerBuffer,\n      vertexAttributes,\n      shaderIO.vertexCount,\n    );\n    // This is the material that is generated for the layer that utilizes all of the generated and\n    // Injected shader IO and shader fragments\n    const material = generateLayerMaterial(\n      layer,\n      shaderMetrics.vs,\n      shaderMetrics.fs,\n      uniforms,\n      shaderMetrics.materialUniforms,\n    );\n    // And now we can now generate the mesh that will be added to the scene\n    const model = generateLayerModel(layer, geometry, material);\n\n    // Now that all of the elements of the layer are complete, let us apply them to the layer\n    layer.geometry = geometry;\n    layer.instanceAttributes = instanceAttributes;\n    layer.instanceVertexCount = shaderIO.vertexCount;\n    layer.material = material;\n    layer.maxInstancesPerBuffer = shaderMetrics.maxInstancesPerBuffer;\n    layer.model = model;\n    layer.uniforms = uniforms;\n    layer.vertexAttributes = vertexAttributes;\n\n    // Generate the correct buffering strategy for the layer\n    makeLayerBufferManager(this.gl, layer, scene);\n\n    return layer;\n  }\n\n  /**\n   * Initializes elements for handling mouse interactions with the canvas.\n   */\n  private initMouseManager(options: ILayerSurfaceOptions) {\n    // We must inject an event manager to broadcast events through the layers themselves\n    const eventManagers: EventManager[] = ([\n      new LayerMouseEvents(this),\n    ] as EventManager[]).concat(options.eventManagers || []);\n\n    // Generate the mouse manager for the layer\n    this.mouseManager = new MouseEventManager(\n      this.context.canvas,\n      this.sceneViews,\n      eventManagers,\n      options.handlesWheelEvents,\n    );\n  }\n\n  /**\n   * This initializes resources needed or requested such as textures or render surfaces.\n   */\n  private async initResources(options: ILayerSurfaceOptions) {\n    // Tell our manager to generate all of the atlas' requested for surface\n    if (options.atlasResources) {\n      for (const resource of options.atlasResources) {\n        await this.atlasManager.createAtlas(resource);\n      }\n    }\n\n    // Initialize our resource manager with the atlas manager\n    this.resourceManager = new AtlasResourceManager({\n      atlasManager: this.atlasManager,\n    });\n  }\n\n  /**\n   * This finds the scene and view the layer belongs to based on the layer's props. For invalid or not provided\n   * props, the layer gets added to default scenes and views.\n   */\n  private addLayerToScene<T extends Instance, U extends ILayerProps<T>, V>(\n    layer: Layer<T, U>,\n  ): Scene {\n    // Get the scene the layer will add itself to\n    let scene = this.scenes.get(layer.props.scene || '');\n\n    if (!scene) {\n      // If no scene is specified by the layer, or the scene identifier is invalid, then we add the layer\n      // To the default scene.\n      scene = this.defaultSceneElements.scene;\n\n      if (layer.props.scene) {\n        console.warn(\n          'Layer specified a scene that is not within the layer surface manager. Layer will be added to the default scene.',\n        );\n      }\n    }\n\n    // Add the layer to the scene for rendering\n    scene.addLayer(layer);\n\n    return scene;\n  }\n\n  /**\n   * Discontinues a layer's management by this surface. This will invalidate any resources\n   * the layer was using in association with the context. If the layer is re-insertted, it will\n   * be revaluated as though it were a new layer.\n   */\n  private removeLayer<T extends Instance, U extends ILayerProps<T>, V>(\n    layer: Layer<T, U> | null,\n  ): Layer<T, U> | null {\n    // Make sure we are removing a layer that exists in the system\n    if (!layer) {\n      return null;\n    }\n    if (!this.layers.get(layer && layer.id)) {\n      console.warn(\n        'Tried to remove a layer that is not in the manager.',\n        layer,\n      );\n      return layer;\n    }\n\n    layer.destroy();\n    this.layers.delete(layer.id);\n\n    return layer;\n  }\n\n  /**\n   * Used for reactive rendering and diffs out the layers for changed layers.\n   */\n  render(layerInitializers: LayerInitializer[]) {\n    if (!this.gl) return;\n\n    // Loop through all of the initializers and properly add and remove layers as needed\n    if (layerInitializers && layerInitializers.length > 0) {\n      layerInitializers.forEach(init => {\n        const layerClass = init[0];\n        const props = init[1];\n        const existingLayer = this.layers.get(props.key);\n\n        if (existingLayer) {\n          existingLayer.willUpdateProps(props);\n          Object.assign(existingLayer.props, props);\n          existingLayer.initializer[1] = existingLayer.props;\n          existingLayer.didUpdateProps();\n        } else {\n          const layer = new layerClass(\n            Object.assign({}, layerClass.defaultProps, props),\n          );\n          layer.initializer = init;\n          this.addLayer(layer);\n        }\n\n        this.willDisposeLayer.set(props.key, false);\n      });\n    }\n\n    // Take any layer that retained it's disposal flag and trash it\n    this.willDisposeLayer.forEach((dispose, layerId) => {\n      if (dispose) {\n        const layer = this.layers.get(layerId);\n        if (layer) {\n          this.removeLayer(layer);\n        } else {\n          console.warn(\n            'this.willDisposeLayer applied to a layer that does not exist in the existing layer check.',\n          );\n        }\n      }\n    });\n\n    // Resolve that all disposals occurred\n    this.willDisposeLayer.clear();\n\n    // Reflag every layer for removal again so creation of layers will determine\n    // Which layers remain for a reactive pattern\n    this.layers.forEach((layer, id) => {\n      this.willDisposeLayer.set(id, true);\n    });\n  }\n\n  /**\n   * This must be executed when the canvas changes size so that we can re-calculate the scenes and views\n   * dimensions for handling all of our rendered elements.\n   */\n  fitContainer(pixelRatio?: number) {\n    const container = this.context.canvas.parentElement;\n\n    if (container) {\n      const canvas = this.context.canvas;\n      canvas.className = '';\n      canvas.setAttribute('style', '');\n      container.style.position = 'relative';\n      canvas.style.position = 'absolute';\n      canvas.style.left = '0xp';\n      canvas.style.top = '0xp';\n      canvas.style.width = '100%';\n      canvas.style.height = '100%';\n      canvas.setAttribute('width', '');\n      canvas.setAttribute('height', '');\n      const containerBox = container.getBoundingClientRect();\n      const box = canvas.getBoundingClientRect();\n\n      this.resize(box.width || 100, containerBox.height || 100);\n    }\n  }\n\n  /**\n   * This resizes the canvas and retains pixel ratios amongst all of the resources involved.\n   */\n  resize(width: number, height: number, pixelRatio?: number) {\n    this.pixelRatio = pixelRatio || this.pixelRatio;\n    this.sceneViews.forEach(\n      sceneView => (sceneView.view.pixelRatio = this.pixelRatio),\n    );\n    this.setRendererSize(width, height);\n    this.renderer.setPixelRatio(this.pixelRatio);\n    this.pickingRenderer.setPixelRatio(1.0);\n    this.mouseManager.resize();\n  }\n\n  /**\n   * This establishes the rendering canvas context for the surface.\n   */\n  private setContext(\n    context?: WebGLRenderingContext | HTMLCanvasElement | string,\n  ) {\n    if (!context) {\n      return;\n    }\n\n    if (isWebGLContext(context)) {\n      this.context = context;\n    } else if (isCanvas(context)) {\n      const canvasContext =\n        context.getContext('webgl') || context.getContext('experimental-webgl');\n\n      if (!canvasContext) {\n        console.warn(\n          'A valid GL context was not found for the context provided to the surface. This surface will not be able to operate.',\n        );\n      } else {\n        this.context = canvasContext;\n      }\n    } else if (isString(context)) {\n      const element = document.getElementById(context);\n\n      if (isCanvas(element)) {\n        this.setContext(element);\n      }\n    }\n  }\n\n  /**\n   * This applies a new size to the renderer and resizes any additional resources that requires being\n   * sized along with the renderer.\n   */\n  private setRendererSize(width: number, height: number) {\n    width = width || 100;\n    height = height || 100;\n\n    this.renderer.setSize(width, height);\n    this.pickingRenderer.setSize(width, height);\n\n    if (!this.pickingTarget) {\n      this.pickingTarget = new WebGLRenderTarget(width, height, {\n        magFilter: Three.LinearFilter,\n        minFilter: Three.LinearFilter,\n        stencilBuffer: false,\n      });\n    }\n\n    this.pickingTarget.setSize(width, height);\n  }\n\n  /**\n   * This triggers an update to all of the layers that perform picking, the pixel data\n   * within the specified mouse range.\n   */\n  updateColorPickRange(mouse: Vec2, views: View[]) {\n    // We will flag the color range as needing an update\n    this.updateColorPick = {\n      mouse,\n      views,\n    };\n  }\n}\n","export * from './layer-surface';\nexport * from './event-manager';\nexport * from './layer-processing/generate-default-scene';\nexport * from './layer-processing/generate-layer-geometry';\nexport * from './layer-processing/generate-layer-material';\nexport * from './layer-processing/generate-layer-model';\nexport * from './layer-processing/inject-shader-io';\nexport * from './layer';\nexport * from './mouse-event-manager';\nexport * from './scene';\nexport * from './texture';\nexport * from './view';\n","module.exports = \"precision highp float;\\n\\nvarying vec4 vertexColor;\\nvarying float edgeSharpness;\\nvarying float borderSize;\\nvarying vec2 pointCoord;\\n\\nvoid main() {\\n  ${attributes}\\n\\n  vertexColor = color * color.a;\\n  float size = radius * scaleFactor;\\n  borderSize = mix(\\n    (thickness + 1.5) / size,\\n    ((thickness * pixelRatio) / size),\\n    float(pixelRatio > 1.0)\\n  );\\n  edgeSharpness = mix(0.8, 0.01, min((size * 3.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));\\n  pointCoord = (position.xy + vec2(1.0, 1.0)) / 2.0;\\n\\n  // Center within clip space\\n  vec4 clipCenter = clipSpace(vec3(center, depth));\\n  // Center in screen space\\n  vec2 screenCenter = (clipCenter.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\n  // Position in screen space\\n  vec2 vertex = (position.xy * size) + screenCenter;\\n  // Position back to clip space\\n  gl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), clipCenter.zw);\\n}\\n\"","module.exports = \"precision highp float;\\n\\n${picking}\\n\\n/** This is the color of the ring */\\nvarying vec4 vertexColor;\\n/**\\n * This is how sharp the ring renders. For tiny rings, it's best to have\\n * less sharpness to better convey the shape of a circle. A good starter setting:\\n * edgeSharpness = mix(0.8, 0.01, min(gl_PointSize / 45.0, 1.0));\\n */\\nvarying float edgeSharpness;\\n/**\\n * This should be a value that sets the thickness of the ring in normal space\\n * relative to the PointSize\\n */\\nvarying float borderSize;\\n/**\\n * Since this is now a quad instead of a point sprite, this provides what gl_PointCoord\\n * used to provide.\\n */\\nvarying vec2 pointCoord;\\n\\nfloat circle(vec2 coord, float radius){\\n  vec2 dist = coord - vec2(0.5);\\n\\n  return 1.0 - smoothstep(\\n    radius - (radius * edgeSharpness),\\n    radius + (radius * 0.01),\\n    dot(dist, dist) * 4.0\\n  );\\n}\\n\\nvoid main() {\\n  float outer_step_factor = circle(pointCoord, 1.0);\\n  float inner_step_factor = circle(pointCoord, 1.0 - borderSize);\\n\\n  setColor(mix(\\n    mix(                        // Select the outer color outside of the inner radius\\n      vec4(0.0, 0.0, 0.0, 0.0),    // Select invisible outside of inner and outer radius\\n      vertexColor,                  // Select outer color outside of inner, but inside outer\\n      outer_step_factor\\n    ),\\n    vec4(0.0, 0.0, 0.0, 0.0),                 // Select inner color inside inner\\n    inner_step_factor\\n  ));\\n}\\n\"","import * as Three from 'three';\nimport { Bounds, IPoint } from '../../primitives';\nimport {\n  ILayerProps,\n  IModelType,\n  IShaderInitialization,\n  Layer,\n} from '../../surface/layer';\nimport {\n  IMaterialOptions,\n  InstanceAttributeSize,\n  InstanceBlockIndex,\n  IProjection,\n  IUniform,\n  UniformSize,\n  VertexAttributeSize,\n} from '../../types';\nimport { CommonMaterialOptions } from '../../util';\nimport { RingInstance } from './ring-instance';\nconst { max } = Math;\n\nexport interface IRingLayerProps extends ILayerProps<RingInstance> {\n  /** This sets a scaling factor for the circle's radius */\n  scaleFactor?(): number;\n}\n\n/**\n * This layer displays circles and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class RingLayer extends Layer<RingInstance, IRingLayerProps> {\n  /**\n   * We provide bounds and hit test information for the instances for this layer to allow for mouse picking\n   * of elements\n   */\n  getInstancePickingMethods() {\n    return {\n      // Provide the calculated AABB world bounds for a given circle\n      boundsAccessor: (ring: RingInstance) =>\n        new Bounds({\n          height: ring.radius * 2,\n          width: ring.radius * 2,\n          x: ring.x - ring.radius,\n          y: ring.y - ring.radius,\n        }),\n\n      // Provide a precise hit test for the ring\n      hitTest: (ring: RingInstance, point: IPoint, view: IProjection) => {\n        const r = ring.radius / max(...view.camera.scale);\n        const delta = [point.x - ring.x, point.y - ring.y];\n\n        return delta[0] * delta[0] + delta[1] * delta[1] < r * r;\n      },\n    };\n  }\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<RingInstance> {\n    const scaleFactor = this.props.scaleFactor || (() => 1);\n\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1,\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: -1,\n      1: -1,\n      2: -1,\n      3: 1,\n      4: 1,\n      5: 1,\n    };\n\n    return {\n      fs: require('./ring-layer.fs'),\n      instanceAttributes: [\n        {\n          block: 0,\n          blockIndex: InstanceBlockIndex.ONE,\n          name: 'center',\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.x, o.y],\n        },\n        {\n          block: 0,\n          blockIndex: InstanceBlockIndex.THREE,\n          name: 'radius',\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.radius],\n        },\n        {\n          block: 0,\n          blockIndex: InstanceBlockIndex.FOUR,\n          name: 'depth',\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth],\n        },\n        {\n          block: 1,\n          blockIndex: InstanceBlockIndex.ONE,\n          name: 'color',\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.color,\n        },\n        {\n          block: 2,\n          blockIndex: InstanceBlockIndex.ONE,\n          name: 'thickness',\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.thickness],\n        },\n      ],\n      uniforms: [\n        {\n          name: 'scaleFactor',\n          size: UniformSize.ONE,\n          update: (_: IUniform) => [scaleFactor()],\n        },\n      ],\n      vertexAttributes: [\n        // TODO: This is from the heinous evils of THREEJS and their inability to fix a bug within our lifetimes.\n        // Right now position is REQUIRED in order for rendering to occur, otherwise the draw range gets updated to\n        // Zero against your wishes.\n        {\n          name: 'position',\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexToSide[vertex],\n            0,\n          ],\n        },\n      ],\n      vertexCount: 6,\n      vs: require('./ring-layer.vs'),\n    };\n  }\n\n  getModelType(): IModelType {\n    return {\n      drawMode: Three.TriangleStripDrawMode,\n      modelType: Three.Mesh,\n    };\n  }\n\n  getMaterialOptions(): IMaterialOptions {\n    return CommonMaterialOptions.transparentShape;\n  }\n}\n","import { observable } from '../../instance-provider';\nimport { Circle } from '../../primitives';\nimport { IInstanceOptions, Instance } from '../../util';\n\nexport interface IRingInstanceOptions extends IInstanceOptions, Circle {\n  /** The color of this ring */\n  color?: [number, number, number, number];\n  /** The z depth of the ring (for draw ordering) */\n  depth?: number;\n  /** The thickness of the ring */\n  thickness?: number;\n}\n\nexport class RingInstance extends Instance implements Circle {\n  @observable color: [number, number, number, number] = [1.0, 1.0, 1.0, 1.0];\n  @observable depth: number = 0;\n  @observable radius: number = 0;\n  @observable thickness: number = 1;\n  @observable x: number = 0;\n  @observable y: number = 0;\n\n  constructor(options: IRingInstanceOptions) {\n    super(options);\n\n    this.color = options.color || [1, 1, 1, 1];\n    this.depth = options.depth || 0;\n    this.radius = options.radius;\n    this.thickness = options.thickness || this.thickness;\n    this.x = options.x;\n    this.y = options.y;\n  }\n\n  get width() {\n    return this.radius * 2;\n  }\n\n  get height() {\n    return this.radius * 2;\n  }\n\n  get innerRadius() {\n    return this.radius - this.thickness;\n  }\n}\n","export * from './ring-instance';\nexport * from './ring-layer';\n","import {\n  IInstanceOptions,\n  Instance,\n  observable,\n} from '../../instance-provider';\nimport { Anchor, AnchorType, ScaleType } from '../types';\n\nexport interface IRectangleInstanceOptions extends IInstanceOptions {\n  /**\n   * The point on the rectangle which will be placed in world space via the x, y coords. This is also the point\n   * which the rectangle will be scaled around.\n   */\n  anchor?: Anchor;\n  /** Depth sorting of the rectangle (or the z value of the lable) */\n  depth?: number;\n  /** The height of the rectangle as it is to be rendered in world space */\n  height?: number;\n  /** Sets the way the rectangle scales with the world */\n  scaling?: ScaleType;\n  /** The color the rectangle should render as */\n  color: [number, number, number, number];\n  /** The width of the rectangle as it is to be rendered in world space */\n  width?: number;\n  /** The x coordinate where the rectangle will be anchored to in world space */\n  x?: number;\n  /** The y coordinate where the rectangle will be anchored to in world space */\n  y?: number;\n}\n\n/**\n * This is a lookup to quickly find the proper calculation for setting the correct anchor\n * position based on the anchor type.\n */\nconst anchorCalculator: {\n  [key: number]: (anchor: Anchor, rectangle: RectangleInstance) => void;\n} = {\n  [AnchorType.TopLeft]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopMiddle]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.width / 2.0;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopRight]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.width + anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.MiddleLeft]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = rectangle.height / 2;\n  },\n  [AnchorType.Middle]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.width / 2.0;\n    anchor.y = rectangle.height / 2.0;\n  },\n  [AnchorType.MiddleRight]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.width + anchor.padding;\n    anchor.y = rectangle.height / 2.0;\n  },\n  [AnchorType.BottomLeft]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = rectangle.height + anchor.padding;\n  },\n  [AnchorType.BottomMiddle]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.width / 2.0;\n    anchor.y = rectangle.height + anchor.padding;\n  },\n  [AnchorType.BottomRight]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.width + anchor.padding;\n    anchor.y = rectangle.height + anchor.padding;\n  },\n  [AnchorType.Custom]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = anchor.x || 0;\n    anchor.y = anchor.y || 0;\n  },\n};\n\n/**\n * This generates a new rectangle instance which will render a single line of text for a given layer.\n * There are restrictions surrounding rectangles due to texture sizes and rendering limitations.\n *\n * Currently, we only support rendering a rectangle via canvas, then rendering it to an Atlas texture\n * which is used to render to cards in the world for rendering. This is highly performant, but means:\n *\n * - Rectangles should only be so long.\n * - Multiline is not supported inherently\n * - Once a rectangle is constructed, only SOME properties can be altered thereafter\n *\n * A rectangle that is constructed can only have some properties set upon creating the rectangle and are locked\n * thereafter. The only way to modify them would be to destroy the rectangle, then construct a new rectangle\n * with the modifications. This has to deal with performance regarding rasterizing the rectangle\n */\nexport class RectangleInstance extends Instance {\n  /** This is the rendered color of the rectangle */\n  @observable color: [number, number, number, number] = [0, 0, 0, 1];\n  /** Depth sorting of the rectangle (or the z value of the lable) */\n  @observable depth: number = 0;\n  /** The height of the rectangle as it is to be rendered in world space */\n  @observable height: number = 1;\n  /** Sets the way the rectangle scales with the world */\n  @observable scaling: ScaleType = ScaleType.BOUND_MAX;\n  /** The width of the rectangle as it is to be rendered in world space */\n  @observable width: number = 1;\n  /** The x coordinate where the rectangle will be anchored to in world space */\n  @observable x: number = 0;\n  /** The y coordinate where the rectangle will be anchored to in world space */\n  @observable y: number = 0;\n\n  // These are properties that can be altered, but have side effects from being changed\n\n  /** This is the anchor location on the  */\n  @observable\n  private _anchor: Anchor = {\n    padding: 0,\n    type: AnchorType.TopLeft,\n    x: 0,\n    y: 0,\n  };\n\n  constructor(options: IRectangleInstanceOptions) {\n    super(options);\n\n    this.depth = options.depth || this.depth;\n    this.color = options.color || this.color;\n    this.scaling = options.scaling || this.scaling;\n    this.x = options.x || this.x;\n    this.y = options.y || this.y;\n    this.width = options.width || 1;\n    this.height = options.height || 1;\n\n    // Make sure the anchor is set to the appropriate location\n    options.anchor && this.setAnchor(options.anchor);\n  }\n\n  get anchor() {\n    return this._anchor;\n  }\n\n  /**\n   * This applies a new anchor to this rectangle and properly determines it's anchor position on the rectangle\n   */\n  setAnchor(anchor: Anchor) {\n    const newAnchor = {\n      padding: anchor.padding || 0,\n      type: anchor.type,\n      x: anchor.x || 0,\n      y: anchor.y || 0,\n    };\n\n    // Calculate the new anchors position values\n    anchorCalculator[newAnchor.type](newAnchor, this);\n    // Apply the anchor\n    this._anchor = newAnchor;\n  }\n}\n","module.exports = \"precision highp float;\\n\\nvarying vec4 vertexColor;\\n\\nvoid main() {\\n  ${attributes}\\n\\n  // Figure out the size of the image as it'd show on the screen\\n  vec3 screenSize = cameraSpaceSize(vec3(size, 1.0));\\n  // Do the test for when the image is larger on the screen than the font size\\n  bool largerOnScreen = screenSize.y > size.y;\\n  // Determines if a scale mode should be used or not for the vertex\\n  float useScaleMode = float(\\n    (\\n      scaling == 3.0 ||                  // NEVER mode - keep the image the same size always\\n      (largerOnScreen && scaling == 2.0) // BOUND_MAX mode - only if we're larger than the font size do we scale down\\n    ) &&\\n    scaling != 1.0                       // ALWAYS mode - the image stays completely in world space allowing it to scale freely\\n  );\\n  // If zooms are unequal, assume one is filtered to be 1.0\\n  float unequalZooms = float((cameraScale.x > cameraScale.y || cameraScale.y > cameraScale.x) && useScaleMode != 0.0);\\n  // Destructure threejs's bug with the position requirement\\n  float normal = position.x;\\n  float side = position.y;\\n  // Get the location of the anchor in world space\\n  vec2 worldAnchor = location + anchor;\\n  // Apply the image's tint as a tint to the image\\n  vertexColor = color * color.a;\\n\\n  // Correct aspect ratio.\\n  vec2 adjustedSize = mix(\\n    size,\\n    (size * cameraScale.yx),\\n    unequalZooms\\n  );\\n\\n  vec2 adjustedAnchor = mix(\\n    anchor,\\n    (anchor * cameraScale.yx),\\n    unequalZooms\\n  );\\n\\n  vec2 vertex = vec2(side, float(normal == 1.0)) * size + location - adjustedAnchor;\\n\\n  // See how scaled the size on screen will be from the actual height of the image\\n  float imageScreenScale = mix(\\n    screenSize.y / adjustedSize.y,\\n    screenSize.x / adjustedSize.x,\\n    float((cameraScale.x < 1.0) || (cameraScale.x > 1.0))\\n  );\\n\\n  // If our screen rendering is larger than the size the image is supposed to be, then we automagically\\n  // scale down our image to stay the correct size, centered on the anchor point\\n  vec2 anchorToVertex = vertex - location;\\n\\n  // We now choose between keeping the same image size or keeping it in world space\\n  vertex = mix(\\n    // This option keeps the image size in world space\\n    vertex,\\n    // This option counters the scaling of the image on the screen keeping it a static size\\n    (anchorToVertex / imageScreenScale) + location,\\n    // This is the flag determining if a scale mode should be applied to the vertex\\n    useScaleMode\\n  );\\n\\n  gl_Position = clipSpace(vec3(vertex, depth));\\n}\\n\"","module.exports = \"precision highp float;\\n\\n${picking}\\nvarying vec4 vertexColor;\\n\\nvoid main() {\\n  setColor(vertexColor);\\n}\\n\"","import * as Three from 'three';\nimport { Bounds, IPoint } from '../../primitives';\nimport {\n  ILayerProps,\n  IModelType,\n  IShaderInitialization,\n  Layer,\n} from '../../surface/layer';\nimport {\n  IMaterialOptions,\n  InstanceAttributeSize,\n  InstanceBlockIndex,\n  IProjection,\n  IUniform,\n  UniformSize,\n  VertexAttributeSize,\n} from '../../types';\nimport { CommonMaterialOptions } from '../../util';\nimport { ScaleType } from '../types';\nimport { RectangleInstance } from './rectangle-instance';\n\nconst { min, max } = Math;\n\nexport interface IRectangleLayerProps extends ILayerProps<RectangleInstance> {\n  atlas?: string;\n}\n\n/**\n * This layer displays Rectangles and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class RectangleLayer extends Layer<\n  RectangleInstance,\n  IRectangleLayerProps\n> {\n  /**\n   * We provide bounds and hit test information for the instances for this layer to allow for mouse picking\n   * of elements\n   */\n  getInstancePickingMethods() {\n    return {\n      // Provide the calculated AABB world bounds for a given rectangle\n      boundsAccessor: (rectangle: RectangleInstance) => {\n        const anchorEffect = [0, 0];\n\n        if (rectangle.anchor) {\n          anchorEffect[0] = rectangle.anchor.x || 0;\n          anchorEffect[1] = rectangle.anchor.y || 0;\n        }\n        const topLeft = [\n          rectangle.x - anchorEffect[0],\n          rectangle.y - anchorEffect[1],\n        ];\n\n        return new Bounds({\n          height: rectangle.height,\n          width: rectangle.width,\n          x: topLeft[0],\n          y: topLeft[1],\n        });\n      },\n\n      // Provide a precise hit test for the circle\n      hitTest: (\n        rectangle: RectangleInstance,\n        point: IPoint,\n        projection: IProjection,\n      ) => {\n        // The bounds of the rectangle is in world space, but it does not account for the scale mode of the rectangle.\n        // Here, we will apply the scale mode testing to the rectangle\n        const maxScale = max(...projection.camera.scale);\n        const minScale = min(...projection.camera.scale);\n\n        // If we scale always then the rectangle stays within it's initial world bounds at all times\n        if (rectangle.scaling === ScaleType.ALWAYS) {\n          return true;\n        }\n\n        // If we scale with bound max, then when the camera zooms in, the bounds will shrink to keep the\n        // Rectangle the same size. If the camera zooms out then the bounds === the world bounds.\n        else if (rectangle.scaling === ScaleType.BOUND_MAX) {\n          // We are zooming out. the bounds will stay within the world bounds\n          if (minScale <= 1 && maxScale <= 1) {\n            return true;\n          }\n\n          // We are zooming in. The bounds will shrink to keep the rectangle at max font size\n          else {\n            // The location is within the world, but we reverse project the anchor spread\n            const anchorEffect = [0, 0];\n\n            if (rectangle.anchor) {\n              anchorEffect[0] = rectangle.anchor.x || 0;\n              anchorEffect[1] = rectangle.anchor.y || 0;\n            }\n\n            const topLeft = [\n              rectangle.x - anchorEffect[0] / maxScale,\n              rectangle.y - anchorEffect[1] / maxScale,\n            ];\n\n            // Reverse project the size and we should be within the distorted world coordinates\n            return new Bounds({\n              height: rectangle.height / maxScale,\n              width: rectangle.width / maxScale,\n              x: topLeft[0],\n              y: topLeft[1],\n            }).containsPoint(point);\n          }\n        }\n\n        // If we never allow the rectangle to scale, then the bounds will grow and shrink to counter the effects\n        // Of the camera zoom\n        else if (rectangle.scaling === ScaleType.NEVER) {\n          // The location is within the world, but we reverse project the anchor spread\n          const anchorEffect = [0, 0];\n\n          if (rectangle.anchor) {\n            anchorEffect[0] = rectangle.anchor.x || 0;\n            anchorEffect[1] = rectangle.anchor.y || 0;\n          }\n\n          const topLeft = projection.worldToScreen({\n            x: rectangle.x - anchorEffect[0] / projection.camera.scale[0],\n            y: rectangle.y - anchorEffect[1] / projection.camera.scale[1],\n          });\n\n          const screenPoint = projection.worldToScreen(point);\n\n          // Reverse project the size and we should be within the distorted world coordinates\n          return new Bounds({\n            height: rectangle.height,\n            width: rectangle.width,\n            x: topLeft.x,\n            y: topLeft.y,\n          }).containsPoint(screenPoint);\n        }\n\n        return true;\n      },\n    };\n  }\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<RectangleInstance> {\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1,\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: 0,\n      1: 0,\n      2: 0,\n      3: 1,\n      4: 1,\n      5: 1,\n    };\n\n    return {\n      fs: require('./rectangle-layer.fs'),\n      instanceAttributes: [\n        {\n          block: 0,\n          blockIndex: InstanceBlockIndex.ONE,\n          name: 'location',\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.x, o.y],\n        },\n        {\n          block: 0,\n          blockIndex: InstanceBlockIndex.THREE,\n          name: 'anchor',\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.anchor.x || 0, o.anchor.y || 0],\n        },\n        {\n          block: 1,\n          blockIndex: InstanceBlockIndex.ONE,\n          name: 'size',\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.width, o.height],\n        },\n        {\n          block: 1,\n          blockIndex: InstanceBlockIndex.THREE,\n          name: 'depth',\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth],\n        },\n        {\n          block: 1,\n          blockIndex: InstanceBlockIndex.FOUR,\n          name: 'scaling',\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scaling],\n        },\n        {\n          block: 3,\n          blockIndex: InstanceBlockIndex.ONE,\n          name: 'color',\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.color,\n        },\n      ],\n      uniforms: [\n        {\n          name: 'scaleFactor',\n          size: UniformSize.ONE,\n          update: (u: IUniform) => [1],\n        },\n      ],\n      vertexAttributes: [\n        // TODO: This is from the heinous evils of THREEJS and their inability to fix a bug within our lifetimes.\n        // Right now position is REQUIRED in order for rendering to occur, otherwise the draw range gets updated to\n        // Zero against your wishes.\n        {\n          name: 'position',\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexToSide[vertex],\n            0,\n          ],\n        },\n      ],\n      vertexCount: 6,\n      vs: require('./rectangle-layer.vs'),\n    };\n  }\n\n  getModelType(): IModelType {\n    return {\n      drawMode: Three.TriangleStripDrawMode,\n      modelType: Three.Mesh,\n    };\n  }\n\n  getMaterialOptions(): IMaterialOptions {\n    return CommonMaterialOptions.transparentShape;\n  }\n}\n","export * from './rectangle-layer';\nexport * from './rectangle-instance';\n","import { observable } from '../../instance-provider';\nimport { IInstanceOptions, Instance } from '../../instance-provider/instance';\nimport { Label } from '../../primitives/label';\nimport { LabelAtlasResource, LabelRasterizer } from '../../surface/texture';\nimport { Anchor, AnchorType, ScaleType } from '../types';\n\nexport interface ILabelInstanceOptions\n  extends IInstanceOptions,\n    Partial<Label> {\n  /**\n   * The point on the label which will be placed in world space via the x, y coords. This is also the point\n   * which the label will be scaled around.\n   */\n  anchor?: Anchor;\n  /** The color the label should render as */\n  color: [number, number, number, number];\n  /** Depth sorting of the label (or the z value of the label) */\n  depth?: number;\n  /** The font of the label */\n  fontFamily?: string;\n  /** The font size of the label in px */\n  fontSize?: number;\n  /** Stylization of the font */\n  fontStyle?: Label['fontStyle'];\n  /** The weight of the font */\n  fontWeight?: Label['fontWeight'];\n  /** When this is set labels will only draw the label up to this size. If below, the label will automatically truncate with ellipses */\n  maxWidth?: number;\n  /** When in BOUND_MAX mode, this allows the label to scale up beyond it's max size */\n  maxScale?: number;\n  /** This allows for control over rasterization to the atlas */\n  rasterization?: {\n    /**\n     * This is the scale of the rasterization on the atlas. Higher numbers increase atlas usage, but can provide\n     * higher quality render outputs to the surface.\n     */\n    scale: number;\n  };\n  /** Sets the way the label scales with the world */\n  scaling?: ScaleType;\n  /** Scales the label uniformly */\n  scale?: number;\n  /** This will be the text that should render with  */\n  text: string;\n  /** The x coordinate where the label will be anchored to in world space */\n  x?: number;\n  /** The y coordinate where the label will be anchored to in world space */\n  y?: number;\n}\n\n/** This is to make a clear type that references label text values */\ntype TextValue = string;\n/** This is to make a clear type that references label css font values */\ntype CSSFont = string;\n/**\n * This is a reference for a rasterization that has reference counting. When the references go to zero,\n * the rasterization should be invalidated and resources freed for the rasterization.\n */\ntype RasterizationReference = {\n  resource: LabelAtlasResource;\n  references: number;\n};\n\n/**\n * This is a lookup to find existing rasterizations for a particularly created label so that every\n * new label does not have to go through the rasterization process.\n */\nconst rasterizationLookUp = new Map<\n  TextValue,\n  Map<CSSFont, RasterizationReference>\n>();\n\n/**\n * This is a lookup to quickly find the proper calculation for setting the correct anchor\n * position based on the anchor type.\n */\nconst anchorCalculator: {\n  [key: number]: (anchor: Anchor, label: LabelInstance) => void;\n} = {\n  [AnchorType.TopLeft]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopMiddle]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.width / 2.0;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopRight]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.width + anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.MiddleLeft]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = label.height / 2;\n  },\n  [AnchorType.Middle]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.width / 2.0;\n    anchor.y = label.height / 2.0;\n  },\n  [AnchorType.MiddleRight]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.width + anchor.padding;\n    anchor.y = label.height / 2.0;\n  },\n  [AnchorType.BottomLeft]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = label.height + anchor.padding;\n  },\n  [AnchorType.BottomMiddle]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.width / 2.0;\n    anchor.y = label.height + anchor.padding;\n  },\n  [AnchorType.BottomRight]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.width + anchor.padding;\n    anchor.y = label.height + anchor.padding;\n  },\n  [AnchorType.Custom]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = anchor.x || 0;\n    anchor.y = anchor.y || 0;\n  },\n};\n\n/**\n * This generates a new label instance which will render a single line of text for a given layer.\n * There are restrictions surrounding labels due to texture sizes and rendering limitations.\n *\n * Currently, we only support rendering a label via canvas, then rendering it to an Atlas texture\n * which is used to render to cards in the world for rendering. This is highly performant, but means:\n *\n * - Labels should only be so long.\n * - Multiline is not supported inherently\n * - Once a label is constructed, only SOME properties can be altered thereafter\n *\n * A label that is constructed can only have some properties set upon creating the label and are locked\n * thereafter. The only way to modify them would be to destroy the label, then construct a new label\n * with the modifications. This has to deal with performance regarding rasterizing the label\n */\nexport class LabelInstance extends Instance implements Label {\n  /**\n   * TODO: We should be implementing the destroy on LabelInstances to clean this up\n   * Frees up module scoped data.\n   */\n  static destroy() {\n    rasterizationLookUp.clear();\n  }\n\n  /** This is the rendered color of the label */\n  @observable color: [number, number, number, number] = [0, 0, 0, 1];\n  /** Depth sorting of the label (or the z value of the label) */\n  @observable depth: number = 0;\n  /** When in BOUND_MAX mode, this allows the label to scale up beyond it's max size */\n  @observable maxScale: number = 1;\n  /** Sets the way the label scales with the world */\n  @observable scaling: ScaleType = ScaleType.BOUND_MAX;\n  /** Scales the label uniformly */\n  @observable scale: number = 1.0;\n  /** The x coordinate where the label will be anchored to in world space */\n  @observable x: number = 0;\n  /** The y coordinate where the label will be anchored to in world space */\n  @observable y: number = 0;\n\n  // The following properties are properties that are locked in after creating this label\n  // As the properties are completely locked into how the label was rasterized and can not\n  // Nor should not be easily adjusted for performance concerns\n\n  private _cssFont: string = '';\n  private _fontFamily: string = 'Arial';\n  private _fontSize: number = 12;\n  private _fontStyle: Label['fontStyle'] = 'normal';\n  private _fontWeight: Label['fontWeight'] = 400;\n  private _maxWidth: number = 0;\n  private _text: string = '';\n\n  @observable\n  private _width: number = 0;\n\n  @observable\n  private _height: number = 0;\n\n  private _isDestroyed: boolean = false;\n\n  @observable\n  private _rasterization: RasterizationReference;\n\n  // The following are the getters for the locked in parameters of the label so we can read\n  // The properties but not set any of them.\n\n  /**\n   * This is the full css string that represents this label. This + the text of the label is essentially\n   * a unique identifier for the rendering of the label and is used to key the rasterization of the label\n   * so that label rasterization can be shared for similar labels.\n   */\n  get cssFont() {\n    return this._cssFont;\n  }\n  /** This flag indicates if this label is valid anymore */\n  get isDestroyed() {\n    return this._isDestroyed;\n  }\n  /** This is the font family of the label */\n  get fontFamily() {\n    return this._fontFamily;\n  }\n  /**\n   * This is the size of the label in pixels. For Labels, this correlates to the rendering font size.\n   * The true pixel height of the label is calculated and placed into the height property for the label.\n   */\n  get fontSize() {\n    return this._fontSize;\n  }\n  /** This is the style of the font (italic, oblique, etc) */\n  get fontStyle() {\n    return this._fontStyle;\n  }\n  /** This is the font weight specified for the label (bold, normal, etc). */\n  get fontWeight() {\n    return this._fontWeight;\n  }\n  /** This is the max width in pixels this label can fill */\n  get maxWidth() {\n    return this._maxWidth;\n  }\n  /** This gets the atlas resource that is uniquely identified for this label */\n  get resource() {\n    return this._rasterization.resource;\n  }\n  /** This is the label's text. */\n  get text() {\n    return this._text;\n  }\n  /**\n   * If a maxWidth is specified, there is a chance the text will be truncated.\n   * This provides the calculated truncated text.\n   */\n  get truncatedText() {\n    return this._rasterization.resource.truncatedText || this.text;\n  }\n\n  /**\n   * This is the width in world space of the label. If there is no camera distortion,\n   * this would be the width of the label in pixels on the screen.\n   */\n  get width() {\n    return this._width;\n  }\n\n  /**\n   * This is the height in world space of the label. If there is no camera distortion,\n   * this would be the height of the label in pixels on the screen.\n   */\n  get height() {\n    return this._height;\n  }\n\n  // These are properties that can be altered, but have side effects from being changed\n\n  /** This is the anchor location on the  */\n  @observable\n  private _anchor: Anchor = {\n    padding: 0,\n    type: AnchorType.TopLeft,\n    x: 0,\n    y: 0,\n  };\n\n  constructor(options: ILabelInstanceOptions) {\n    super(options);\n\n    this.depth = options.depth || this.depth;\n    this.color = options.color || this.color;\n    this.maxScale = options.maxScale || this.maxScale;\n    this.scaling = options.scaling || this.scaling;\n    this.scale = options.scale || this.scale;\n\n    this.x = options.x || this.x;\n    this.y = options.y || this.y;\n\n    this._fontFamily = options.fontFamily || this._fontFamily;\n    this._fontSize = options.fontSize || this._fontSize;\n    this._fontStyle = options.fontStyle || this._fontStyle;\n    this._fontWeight = options.fontWeight || this._fontWeight;\n    this._maxWidth = options.maxWidth || 0;\n    this._text = options.text || this._text;\n\n    // We get the CSS font string for this label so we can uniquely identify the rasterization\n    // Easily.\n    this._cssFont = LabelRasterizer.makeCSSFont(this, 1);\n    // This is css font used to look up rasterizations. This lookup includes the max width of the label\n    // Which the css font does not account for\n    const cssFontLookup = `${this._cssFont}_${this._maxWidth}`;\n    // Look for other same texts that have been rasterized\n    let rasterizations = rasterizationLookUp.get(this._text);\n    let rasterization: RasterizationReference | null | undefined;\n\n    if (rasterizations) {\n      // Look for those texts that have been rasterized in the same fashion that this label is requesting\n      rasterization = rasterizations.get(cssFontLookup);\n\n      // If a rasterization exists, we must increment the use reference\n      if (rasterization) {\n        rasterization.references++;\n      }\n    } else {\n      rasterizations = new Map<CSSFont, RasterizationReference>();\n    }\n\n    // If we have not found an existing rasterization\n    if (!rasterization) {\n      rasterization = {\n        references: 1,\n        resource: new LabelAtlasResource(this),\n      };\n\n      // Look to see if any rasterization options were specified\n      if (options.rasterization) {\n        rasterization.resource.sampleScale = options.rasterization.scale || 1.0;\n      }\n\n      // Ensure the sample scale is set. Defaults to 1.0\n      rasterization.resource.sampleScale =\n        rasterization.resource.sampleScale || 1.0;\n      // Rasterize the resource generated for this label. We need it immediately rasterized so\n      // That we can utilize the dimensions for calculations.\n      LabelRasterizer.renderSync(rasterization.resource);\n      // Now that we have an official rasterization for this text / label combo, we shall store it\n      // For others to look up\n      rasterizationLookUp.set(this._text, rasterizations);\n      rasterizations.set(cssFontLookup, rasterization);\n    }\n\n    this._rasterization = rasterization;\n    this._width = rasterization.resource.rasterization.world.width;\n    this._height = rasterization.resource.rasterization.world.height;\n\n    // Make sure the anchor is set to the appropriate location\n    options.anchor && this.setAnchor(options.anchor);\n  }\n\n  get anchor() {\n    return this._anchor;\n  }\n\n  /**\n   * Labels are a sort of unique case where the use of a label should be destroyed as rasterization\n   * resources are in a way kept alive through reference counting.\n   */\n  destroy() {\n    if (!this._isDestroyed) {\n      this._isDestroyed = true;\n      this._rasterization.references--;\n\n      // If all references are cleared, then the rasterization needs to be eradicated\n      if (this._rasterization.references === 0) {\n        this._rasterization.resource;\n      }\n    }\n  }\n\n  /**\n   * Triggers any attributes waiting on resources\n   */\n  resourceTrigger() {\n    // Trigger the accessed element that the layer utilizes for resource fetching.\n    this._rasterization = this._rasterization;\n    this._width = this._width;\n  }\n\n  /**\n   * This applies a new anchor to this label and properly determines it's anchor position on the label\n   */\n  setAnchor(anchor: Anchor) {\n    const newAnchor = {\n      padding: anchor.padding || 0,\n      type: anchor.type,\n      x: anchor.x || 0,\n      y: anchor.y || 0,\n    };\n\n    // Calculate the new anchors position values\n    anchorCalculator[newAnchor.type](newAnchor, this);\n    // Apply the anchor\n    this._anchor = newAnchor;\n  }\n}\n","module.exports = \"precision highp float;\\n\\nvarying vec4 vertexColor;\\nvarying vec2 texCoord;\\n\\nvoid main() {\\n  ${attributes}\\n\\n  // Determine final screen size of label\\n  vec3 screenSize = cameraSpaceSize(vec3(size * scale / maxScale, 1.0));\\n\\n  // Test whether the label is larger on the screen than the font size\\n  bool largerOnScreen = screenSize.y > size.y || screenSize.x > size.x;\\n\\n  // Determines if a scale mode should be used or not for the vertex\\n  float useScaleMode = float(\\n    (\\n      scaling == 3.0 ||                  // NEVER mode - keep the image the same size always\\n      (largerOnScreen && scaling == 2.0) // BOUND_MAX mode - only if we're larger than the font size do we scale down\\n    ) &&\\n    scaling != 1.0                       // ALWAYS mode - the image stays completely in world space allowing it to scale freely\\n  );\\n\\n  // Correct aspect ratio.  Sufficient fix for most applications.\\n  // Will need another solution in the case of:\\n  //  (cameraScale y != cameraScale.x) && (cameraScale.x != 1 && cameraScale.y != 1)\\n\\n  // If zooms are unequal, assume one is filtered to be 1.0\\n  float unequalZooms = float(cameraScale.x != cameraScale.y);\\n\\n  vec2 adjustedSize = mix(\\n    size,\\n    (size * cameraScale.yx),\\n    unequalZooms\\n  );\\n\\n  // Destructure threejs's bug with the position requirement\\n  float normal = position.x;\\n  float side = position.y;\\n\\n  vec2 scaledAnchor = anchor * scale;\\n\\n  // Get the location of the anchor in world space\\n  vec2 worldAnchor = location + scaledAnchor;\\n\\n  vec2 adjustedAnchor = mix(\\n    scaledAnchor,\\n    (scaledAnchor * cameraScale.yx),\\n    unequalZooms\\n  );\\n\\n  // Get the position of the current vertex\\n  vec2 vertex = vec2(side, float(normal == 1.0)) * scale * size + location - adjustedAnchor;\\n\\n  // See how scaled the size on screen will be from the actual height of the label\\n  float labelScreenScale = mix(\\n    screenSize.y / adjustedSize.y,\\n    screenSize.x / adjustedSize.x,\\n    float((cameraScale.x != 1.0))\\n  );\\n\\n  float currentScale = labelScreenScale * scale;\\n\\n  // If our screen rendering is larger than the size the label is supposed to be, then we automagically\\n  // scale down our label to stay the correct size, centered on the anchor point\\n  vec2 anchorToVertex = vertex - location;\\n\\n  // We now choose between keeping the same image size or keeping it in world space\\n  vertex = mix(\\n    // This option keeps the image size in world space\\n    vertex,\\n    // This option counters the scaling of the image on the screen keeping it a static size\\n    (anchorToVertex / labelScreenScale) + location,\\n    // This is the flag determining if a scale mode should be applied to the vertex\\n    useScaleMode\\n  );\\n\\n  // --Texture and Color\\n  // Get the tex coord from our inject texture info\\n  texCoord = texture.xy + ((texture.zw - texture.xy) * vec2(side, float(normal == -1.0)));\\n  // Apply the label's color as a tint to the label (all labels are rendered white to the base texture)\\n  vertexColor = color;\\n\\n  gl_Position = clipSpace(vec3(vertex, depth));\\n}\\n\"","module.exports = \"precision highp float;\\n\\n${picking}\\nvarying vec4 vertexColor;\\nvarying vec2 texCoord;\\n\\nvoid main() {\\n  gl_FragColor = texture2D(labelAtlas, texCoord) * vertexColor;\\n  setColor(gl_FragColor * gl_FragColor.a);\\n}\\n\"","import * as Three from 'three';\nimport { Bounds, IPoint } from '../../primitives';\nimport {\n  ILayerProps,\n  IModelType,\n  IShaderInitialization,\n  Layer,\n} from '../../surface/layer';\nimport {\n  IMaterialOptions,\n  InstanceAttributeSize,\n  InstanceBlockIndex,\n  IProjection,\n  IUniform,\n  UniformSize,\n  VertexAttributeSize,\n} from '../../types';\nimport { CommonMaterialOptions, Vec2 } from '../../util';\nimport { ScaleType } from '../types';\nimport { LabelInstance } from './label-instance';\n\nexport interface ILabelLayerProps extends ILayerProps<LabelInstance> {\n  atlas?: string;\n}\n\nconst { max, min } = Math;\n\n/**\n * This layer displays Labels and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class LabelLayer extends Layer<LabelInstance, ILabelLayerProps> {\n  /**\n   * We provide bounds and hit test information for the instances for this layer to allow for mouse picking\n   * of elements\n   */\n  getInstancePickingMethods() {\n    return {\n      // Provide the calculated AABB world bounds for a given label\n      boundsAccessor: (label: LabelInstance) => {\n        const anchor: Vec2 = [label.anchor.x || 0, label.anchor.y || 0];\n\n        const topLeft = [label.x - anchor[0], label.y - anchor[1]];\n\n        return new Bounds({\n          height: label.height,\n          width: label.width,\n          x: topLeft[0],\n          y: topLeft[1],\n        });\n      },\n\n      // Provide a precise hit test for the circle\n      hitTest: (label: LabelInstance, point: IPoint, view: IProjection) => {\n        // The bounds of the label is in world space, but it does not account for the scale mode of the label.\n        // Here, we will apply the scale mode testing to the label\n        const maxScale = max(...view.camera.scale);\n        const minScale = min(...view.camera.scale);\n\n        // If we scale always then the label stays within it's initial world bounds at all times\n        if (label.scaling === ScaleType.ALWAYS) {\n          return true;\n        }\n\n        // If we scale with bound max, then when the camera zooms in, the bounds will shrink to keep the\n        // Label the same size. If the camera zooms out then the bounds === the world bounds.\n        else if (label.scaling === ScaleType.BOUND_MAX) {\n          // We are zooming out. the bounds will stay within the world bounds\n          if (minScale <= 1 && maxScale <= 1) {\n            return true;\n          }\n\n          // We are zooming in. The bounds will shrink to keep the label at max font size\n          else {\n            const anchor: Vec2 = [label.anchor.x || 0, label.anchor.y || 0];\n\n            // The location is within the world, but we reverse project the anchor spread\n            const topLeft = view.worldToScreen({\n              x: label.x - anchor[0] / view.camera.scale[0],\n              y: label.y - anchor[1] / view.camera.scale[1],\n            });\n\n            const screenPoint = view.worldToScreen(point);\n\n            // Reverse project the size and we should be within the distorted world coordinates\n            return new Bounds({\n              height: label.height,\n              width: label.width,\n              x: topLeft.x,\n              y: topLeft.y,\n            }).containsPoint(screenPoint);\n          }\n        }\n\n        // If we never allow the label to scale, then the bounds will grow and shrink to counter the effects\n        // Of the camera zoom\n        else if (label.scaling === ScaleType.NEVER) {\n          const anchor: Vec2 = [label.anchor.x || 0, label.anchor.y || 0];\n\n          // The location is within the world, but we reverse project the anchor spread\n          const topLeft = view.worldToScreen({\n            x: label.x - anchor[0] / view.camera.scale[0],\n            y: label.y - anchor[1] / view.camera.scale[1],\n          });\n\n          const screenPoint = view.worldToScreen(point);\n\n          // Reverse project the size and we should be within the distorted world coordinates\n          return new Bounds({\n            height: label.height,\n            width: label.width,\n            x: topLeft.x,\n            y: topLeft.y,\n          }).containsPoint(screenPoint);\n        }\n\n        return true;\n      },\n    };\n  }\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<LabelInstance> {\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1,\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: 0,\n      1: 0,\n      2: 0,\n      3: 1,\n      4: 1,\n      5: 1,\n    };\n\n    return {\n      fs: require('./label-layer.fs'),\n      instanceAttributes: [\n        {\n          block: 0,\n          blockIndex: InstanceBlockIndex.ONE,\n          name: 'location',\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.x, o.y],\n        },\n        {\n          block: 0,\n          blockIndex: InstanceBlockIndex.THREE,\n          name: 'anchor',\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.anchor.x || 0, o.anchor.y || 0],\n        },\n        {\n          block: 1,\n          blockIndex: InstanceBlockIndex.ONE,\n          name: 'size',\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.width, o.height],\n        },\n        {\n          block: 1,\n          blockIndex: InstanceBlockIndex.THREE,\n          name: 'depth',\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth],\n        },\n        {\n          block: 1,\n          blockIndex: InstanceBlockIndex.FOUR,\n          name: 'scaling',\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scaling],\n        },\n        {\n          atlas: {\n            key: this.props.atlas || '',\n            name: 'labelAtlas',\n          },\n          block: 2,\n          name: 'texture',\n          update: o => this.resource.request(this, o, o.resource),\n        },\n        {\n          block: 3,\n          blockIndex: InstanceBlockIndex.ONE,\n          name: 'color',\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.color,\n        },\n        {\n          block: 4,\n          blockIndex: InstanceBlockIndex.ONE,\n          name: 'scale',\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scale],\n        },\n        {\n          block: 4,\n          blockIndex: InstanceBlockIndex.TWO,\n          name: 'maxScale',\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.maxScale],\n        },\n      ],\n      uniforms: [\n        {\n          name: 'scaleFactor',\n          size: UniformSize.ONE,\n          update: (u: IUniform) => [1],\n        },\n      ],\n      vertexAttributes: [\n        // TODO: This is from the heinous evils of THREEJS and their inability to fix a bug within our lifetimes.\n        // Right now position is REQUIRED in order for rendering to occur, otherwise the draw range gets updated to\n        // Zero against your wishes.\n        {\n          name: 'position',\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexToSide[vertex],\n            0,\n          ],\n        },\n      ],\n      vertexCount: 6,\n      vs: require('./label-layer.vs'),\n    };\n  }\n\n  getModelType(): IModelType {\n    return {\n      drawMode: Three.TriangleStripDrawMode,\n      modelType: Three.Mesh,\n    };\n  }\n\n  getMaterialOptions(): IMaterialOptions {\n    return CommonMaterialOptions.transparentImage;\n  }\n}\n","import { ImageAtlasResource } from './image-atlas-resource';\n\nlet canvas: CanvasRenderingContext2D | null;\n\nexport interface IImageRasterizedMetrics {\n  canvas: HTMLCanvasElement;\n  height: number;\n  width: number;\n}\n\nexport class ImageRasterizer {\n  /**\n   * This loops until our canvas context is available\n   */\n  static async awaitContext() {\n    // Iterate till the browser provides a valid canvas to render elements into\n    while (!canvas) {\n      this.getContext();\n      await new Promise(resolve => setTimeout(resolve, 10));\n    }\n  }\n\n  /**\n   * Attempts to populate the 'canvas' context for rendering images offscreen.\n   */\n  static getContext() {\n    if (!canvas) {\n      canvas = document.createElement('canvas').getContext('2d');\n    }\n\n    return canvas;\n  }\n\n  /**\n   * This renders our image to a sizeable canvas where we loop over the pixel data to determine\n   * the bounds of the image.\n   *\n   * @param {boolean} calculateWorld This is used within the method. It switches from calculating\n   *                                 the size to be rendered to the texture to the size the image\n   *                                 should be within world space.\n   * @param {number} sampleScale     INTERNAL: Do not use this parameter manually.\n   */\n  static calculateImageSize(\n    resource: ImageAtlasResource,\n    sampleScale?: number,\n  ) {\n    /** Get the image properties for rasterizing */\n    const image = resource.image.element;\n\n    if (!image) {\n      console.warn(\n        'Image does not exist! Please ensure the resource contains a valid image.',\n      );\n      return;\n    }\n\n    if (!canvas) {\n      console.warn(\n        'The Image rasterizer was unable to establish a valid canvas context. Please ensure the system supports contexts and ensure the document is ready first.',\n      );\n      return;\n    }\n\n    if (image.width === 0 || image.height === 0) {\n      console.warn(\n        'Images provided shoud have valid dimensions! Please ensure the image is loaded first.',\n      );\n      return;\n    }\n\n    // Just make sure th canvas is available\n    canvas.canvas.width = 100;\n    canvas.canvas.height = 100;\n    // Render the image into our canvas merely to ensure the image can be rendered\n    // This action often 'warms up' images such as images that have a data URL instead of a path\n    canvas.drawImage(image, 0, 0);\n\n    // Make sure the rasterization object is initialized\n    resource.rasterization = resource.rasterization || {\n      texture: { height: 0, width: 0 },\n      world: { height: 0, width: 0 },\n    };\n\n    // Update the calculated texture size.\n    resource.rasterization.texture = {\n      height: image.height * resource.sampleScale,\n      width: image.width * resource.sampleScale,\n    };\n\n    resource.rasterization.world = {\n      height: image.height,\n      width: image.width,\n    };\n\n    resource.rasterization.image = image;\n  }\n\n  /**\n   * Performs the rendering of the image\n   */\n  static async render(\n    resource: ImageAtlasResource,\n  ): Promise<ImageAtlasResource> {\n    // Make sure our canvas object is ready for rendering\n    await this.awaitContext();\n\n    // Calculate all of the image metrics and ensure the image can be drawn\n    this.calculateImageSize(resource, resource.sampleScale);\n\n    return resource;\n  }\n\n  /**\n   * Performs the rendering of the image\n   */\n  static renderSync(resource: ImageAtlasResource): ImageAtlasResource {\n    // Ensure our offscreen canvas is prepped\n    this.getContext();\n\n    if (!canvas) {\n      console.warn(\n        'Can not render a image synchronously without the canvas context being ready.',\n      );\n      return resource;\n    }\n\n    // Calculate all of the image metrics and generate a canvas on the image that can\n    // Be rendered to the canvas.\n    this.calculateImageSize(resource, resource.sampleScale);\n\n    return resource;\n  }\n}\n","import { Bounds } from '../../primitives/bounds';\nimport { Atlas, IAtlasOptions } from './atlas';\nimport { ColorAtlasResource } from './color-atlas-resource';\nimport { ColorRasterizer } from './color-rasterizer';\nimport { ImageAtlasResource } from './image-atlas-resource';\nimport { LabelAtlasResource } from './label-atlas-resource';\nimport { LabelRasterizer } from './label-rasterizer';\nimport { ImageDimensions, PackNode } from './pack-node';\nimport { SubTexture } from './sub-texture';\n\nconst debug = require('debug')('webgl-surface:Atlas');\n\nconst ZERO_IMAGE: SubTexture = {\n  aspectRatio: 0,\n  atlasBL: { x: 0, y: 0 },\n  atlasBR: { x: 0, y: 0 },\n  atlasReferenceID: '',\n  atlasTexture: null,\n  atlasTL: { x: 0, y: 0 },\n  atlasTR: { x: 0, y: 0 },\n  heightOnAtlas: 0,\n  isValid: false,\n  pixelHeight: 0,\n  pixelWidth: 0,\n  widthOnAtlas: 0,\n};\n\nexport type AtlasResource =\n  | ColorAtlasResource\n  | LabelAtlasResource\n  | ImageAtlasResource;\n\n/**\n * Determines if a SubTexture is a valid SubTexture for rendering\n */\nfunction isValidImage(image: SubTexture) {\n  let isValid = false;\n\n  if (image && image.isValid) {\n    if (image.pixelWidth && image.pixelHeight) {\n      isValid = true;\n    }\n  }\n\n  return isValid;\n}\n\n/**\n * Defines a manager of atlas', which includes generating the atlas and producing\n * textures defining those pieces of atlas.\n */\nexport class AtlasManager {\n  /** Stores all of the generated atlas' in a lookup by name */\n  allAtlas = new Map<string, Atlas>();\n\n  /**\n   * Atlas' must be created from scratch to update them. In order to properly\n   * update an existing one, you must destroy it then recreate it again.\n   * This is from not knowing how to update a texture via three js.\n   *\n   * @param resources The images with their image path set to be loaded into the atlas.\n   *               Images that keep an atlas ID of null indicates the image did not load\n   *               correctly\n   *\n   * @return {Texture} The Threejs texture that is created as our atlas. The images injected\n   *                   into the texture will be populated with the atlas'\n   */\n  async createAtlas(options: IAtlasOptions, resources?: AtlasResource[]) {\n    // Create the new Atlas object that tracks all of our atlas' metrics\n    const atlas = new Atlas(options);\n    // Set the manager to the atlas\n    atlas.setManager(this);\n    // Make the atlas identifiable by it's name\n    this.allAtlas.set(atlas.id, atlas);\n\n    // Now we load, pack in, and draw each requested resource\n    if (resources) {\n      await this.updateAtlas(atlas.id, resources);\n    }\n\n    debug('Atlas Created-> %o', atlas);\n\n    return atlas;\n  }\n\n  /**\n   * Free ALL resources under this manager\n   */\n  destroy() {\n    this.allAtlas.forEach(value => value.destroy());\n  }\n\n  /**\n   * Disposes of the resources the atlas held and makes the atlas invalid for use\n   *\n   * @param atlasName\n   */\n  destroyAtlas(atlasName: string) {\n    const atlas = this.allAtlas.get(atlasName);\n\n    if (atlas) {\n      atlas.destroy();\n    }\n  }\n\n  private setDefaultImage(image: SubTexture, atlasName: string) {\n    image = Object.assign(image, ZERO_IMAGE, { atlasReferenceID: atlasName });\n    return image;\n  }\n\n  /**\n   * This loads, packs, and draws the indicated image into the specified canvas\n   * using the metrics that exists for the specified atlas.\n   *\n   * @param resource The image who should have it's image path loaded\n   * @param atlasName The name of the atlas to make the packing work\n   * @param canvas The canvas we will be drawing into to generate the complete image\n   *\n   * @return {Promise<boolean>} Promise that resolves to if the image successfully was drawn or not\n   */\n  private async draw(atlas: Atlas, resource: AtlasResource): Promise<boolean> {\n    const canvas = atlas.texture.image;\n    const atlasName = atlas.id;\n\n    // Register the resource with the atlas\n    if (!atlas.registerResource(resource)) {\n      console.warn(\n        'Could not draw resource to the atlas as the resource was not properly registered to the atlas first',\n        atlas,\n        resource,\n      );\n      return Promise.resolve(false);\n    }\n\n    // First we must load the image\n    // Make a buffer to hold our new image\n    // Load the image into memory, default to keeping the alpha channel\n    const loadedImage: HTMLImageElement | null = await this.loadImage(resource);\n\n    // Only a non-null image means the image loaded correctly\n    if (loadedImage && isValidImage(resource.texture)) {\n      // Get the sub texture that is going to be applied to the atlas\n      const rasterization = resource.rasterization;\n      const texture = resource.texture;\n      // Now we create a Rectangle to store the image dimensions\n      const rect: Bounds = new Bounds({\n        bottom: rasterization.texture.height,\n        left: 0,\n        right: rasterization.texture.width,\n        top: 0,\n      });\n      // Create ImageDimension to insert into our atlas mapper\n      const dimensions: ImageDimensions = {\n        first: texture,\n        second: rect,\n      };\n\n      // Auto add a buffer in\n      dimensions.second.width += 1;\n      dimensions.second.height += 1;\n      // Get the atlas map node\n      const packing: PackNode = atlas.packing;\n      // Store the node resulting from the insert operation\n      const insertedNode: PackNode | null = packing.insert(dimensions);\n\n      // If the result was NULL we did not successfully insert the image into any map\n      if (insertedNode) {\n        debug('Atlas location determined: %o', insertedNode);\n\n        // Apply the image to the node\n        insertedNode.nodeImage = texture;\n\n        // Set our image's atlas properties\n        const ux = insertedNode.nodeDimensions.x / atlas.width;\n        const uy = insertedNode.nodeDimensions.y / atlas.height;\n        const uw = insertedNode.nodeDimensions.width / atlas.width;\n        const uh = insertedNode.nodeDimensions.height / atlas.height;\n        const onePixelX = 1 / atlas.width;\n\n        const atlasDimensions: Bounds = new Bounds({\n          bottom: 1.0 - uy,\n          left: ux,\n          right: ux + uw,\n          top: 1.0 - (uy + uh),\n        });\n\n        const bottom = atlasDimensions.bottom;\n        const top = atlasDimensions.y;\n        const left = atlasDimensions.x;\n        const right = atlasDimensions.x + atlasDimensions.width - onePixelX;\n\n        texture.atlasReferenceID = atlasName;\n        texture.atlasTL = { x: left, y: top };\n        texture.atlasBR = { x: right, y: bottom };\n        texture.atlasBL = { x: left, y: bottom };\n        texture.atlasTR = { x: right, y: top };\n        texture.widthOnAtlas = Math.abs(texture.atlasTR.x - texture.atlasTL.x);\n        texture.heightOnAtlas = Math.abs(texture.atlasTR.y - texture.atlasBR.y);\n        texture.pixelWidth = rasterization.texture.width;\n        texture.pixelHeight = rasterization.texture.height;\n\n        // Now draw the image to the indicated canvas\n        canvas\n          .getContext('2d')\n          .drawImage(\n            loadedImage,\n            insertedNode.nodeDimensions.x,\n            insertedNode.nodeDimensions.y,\n          );\n\n        // We have finished inserting\n        return true;\n      } else {\n        // Log an error\n        console.error(`Could not fit resource into atlas`, resource);\n        resource.texture = this.setDefaultImage(resource.texture, atlasName);\n        return false;\n      }\n    } else {\n      // Log an error and load a default sub texture\n      console.error(`Could not load resource:`, resource);\n      resource.texture = this.setDefaultImage(resource.texture, atlasName);\n      return false;\n    }\n  }\n\n  /**\n   * Retrieves the threejs texture for the atlas\n   *\n   * @param atlasName The identifier of the atlas\n   */\n  getAtlasTexture(atlasName: string): Atlas | undefined {\n    return this.allAtlas.get(atlasName);\n  }\n\n  /**\n   * This takes in any atlas resource and rasterizes it.\n   *\n   * @param {SubTexture} resource This is any atlas resource which will have it's image rasterized\n   *\n   * @return {Promise<HTMLImageElement>} A promise to resolve to the loaded image\n   *                                     or null if there was an error\n   */\n  private async loadImage(\n    resource: AtlasResource,\n  ): Promise<HTMLImageElement | null> {\n    let imageSrc: string = '';\n\n    const subTexture = resource.texture || new SubTexture();\n    resource.texture = subTexture;\n\n    if (resource instanceof ImageAtlasResource) {\n      // If the texture was provided an image then we ensure the image is loaded\n      // Then hand it back\n      if (resource.image.element) {\n        if (\n          resource.image.element.width !== 0 &&\n          resource.image.element.height !== 0\n        ) {\n          const image = resource.image.element;\n          subTexture.pixelWidth = image.width;\n          subTexture.pixelHeight = image.height;\n          subTexture.aspectRatio = image.width / image.height;\n\n          return image;\n        }\n\n        const image = await new Promise<HTMLImageElement | null>(\n          (resolve, reject) => {\n            const image: HTMLImageElement | undefined = resource.image.element;\n\n            if (image) {\n              image.onload = function() {\n                subTexture.pixelWidth = image.width;\n                subTexture.pixelHeight = image.height;\n                subTexture.aspectRatio = image.width / image.height;\n                resolve(image);\n              };\n\n              image.onerror = function() {\n                resolve(null);\n              };\n            } else {\n              resolve(null);\n            }\n          },\n        );\n\n        return image;\n      }\n\n      // If a string was returned, we must load the image then return the image\n      else if (resource.image.path) {\n        imageSrc = resource.image.path;\n      }\n    } else if (resource instanceof LabelAtlasResource) {\n      // Ensure the label has been rasterized to a canvas element\n      if (!resource.rasterization.canvas) {\n        await LabelRasterizer.render(resource);\n      }\n\n      // Make sure the rasterization properly executed\n      if (resource.rasterization.canvas) {\n        debug('Rasterized label %o', resource.rasterization);\n        imageSrc = resource.rasterization.canvas.toDataURL('image/png');\n      } else {\n        console.warn('The label was not able to be rasterized');\n      }\n    } else if (resource instanceof ColorAtlasResource) {\n      // Ensure the color has been rasterized to a canvas element\n      if (!resource.rasterization.canvas) {\n        await ColorRasterizer.render(resource);\n      }\n\n      // Make sure the rasterization properly executed\n      if (resource.rasterization.canvas) {\n        debug('Rasterized color %o', resource.rasterization);\n        imageSrc = resource.rasterization.canvas.toDataURL('image/png');\n      } else {\n        console.warn('The color was not able to be rasterized');\n      }\n    }\n\n    if (imageSrc) {\n      const image = await new Promise<HTMLImageElement | null>(\n        (resolve, reject) => {\n          const image: HTMLImageElement = new Image();\n\n          image.onload = function() {\n            subTexture.pixelWidth = image.width;\n            subTexture.pixelHeight = image.height;\n            subTexture.aspectRatio = image.width / image.height;\n            resolve(image);\n          };\n\n          image.onerror = function() {\n            resolve(null);\n          };\n\n          image.src = imageSrc;\n        },\n      );\n\n      return image;\n    }\n\n    return null;\n  }\n\n  /**\n   * This targets an existing atlas and attempts to update it with the provided atlas resources.\n   *\n   * @param atlasName\n   * @param resources\n   */\n  async updateAtlas(atlasName: string, resources: AtlasResource[]) {\n    const atlas = this.allAtlas.get(atlasName);\n\n    if (atlas) {\n      for (const resource of resources) {\n        await this.draw(atlas, resource);\n      }\n\n      // Perform the best method for updating the underlying texture of the atlas to the latest changes\n      atlas.updateTexture();\n    } else {\n      console.warn(\n        'Can not update non-existing atlas:',\n        atlasName,\n        'These resources will not be loaded:',\n        resources,\n      );\n    }\n  }\n}\n","import { Bounds } from '../../primitives/bounds';\nimport { SubTexture } from './sub-texture';\n\n/**\n * Helps us track the bounds of the image being loaded in tied in with the\n * texture it represents\n */\nexport interface ImageDimensions {\n  first: SubTexture;\n  second: Bounds;\n}\n\n/**\n * This is used specifically by the atlas manager to aid in packing\n * in textures within an area. This will guarantee boundaries of textures are\n * not violated and provide proper feedback for where to draw a given image\n */\nexport class PackNode {\n  child: [PackNode | null, PackNode | null] = [null, null];\n  isLeaf: boolean = true;\n  nodeDimensions: Bounds;\n  nodeImage: SubTexture | null = null;\n\n  constructor(x: number, y: number, width: number, height: number) {\n    this.nodeDimensions = new Bounds({\n      height,\n      width,\n      x,\n      y,\n    });\n  }\n\n  /**\n   * Deletes all of the sub nodes in this Mapping, thus clearing up memory usage\n   */\n  destroy() {\n    const child0 = this.child[0];\n    const child1 = this.child[1];\n    this.nodeImage = null;\n    if (child0) {\n      child0.destroy();\n    }\n    if (child1) {\n      child1.destroy();\n    }\n    this.child[0] = null;\n    this.child[1] = null;\n  }\n\n  /**\n   * Indicates if there is a child\n   */\n  hasChild(): boolean {\n    const child0 = this.child[0];\n    const child1 = this.child[1];\n    if (child0 && !child0.nodeImage) {\n      return !child0.isLeaf;\n    }\n    if (child1 && !child1.nodeImage) {\n      return !child1.isLeaf;\n    }\n    return false;\n  }\n\n  /**\n   * Inserts images into our mapping, fitting them appropriately\n   */\n  insert(image: ImageDimensions): PackNode | null {\n    let child0 = this.child[0];\n    let child1 = this.child[1];\n\n    if (!this.isLeaf && child0 && child1) {\n      // Try inserting into first child\n      const newNode: PackNode | null = child0.insert(image);\n      if (newNode !== null) {\n        return newNode;\n      }\n      // No room in first so insert into second\n      return child1.insert(image);\n    } else {\n      // If there's already an image here, return\n      if (this.nodeImage) {\n        return null;\n      }\n      // Check the fit status of the image in this nodes rectangle space\n      const fitFlag: number = this.nodeDimensions.fits(image.second);\n      // If we're too small, return null indicating can not fit\n      if (fitFlag === 0) {\n        return null;\n      }\n      // If we're just right, accept\n      if (fitFlag === 1) {\n        return this;\n      }\n\n      // Otherwise, gotta split this node and create some leaves\n      this.isLeaf = false;\n      // Get the image width\n      const imgWidth: number = image.second.width;\n      const imgHeight: number = image.second.height;\n      // Decide which way to split\n      const dWidth: number = this.nodeDimensions.width - imgWidth;\n      const dHeight: number = this.nodeDimensions.height - image.second.height;\n\n      if (dWidth > dHeight) {\n        child0 = this.child[0] = new PackNode(\n          this.nodeDimensions.x,\n          this.nodeDimensions.y,\n          imgWidth,\n          this.nodeDimensions.height,\n        );\n        child1 = this.child[1] = new PackNode(\n          this.nodeDimensions.x + imgWidth,\n          this.nodeDimensions.y,\n          dWidth,\n          this.nodeDimensions.height,\n        );\n      } else {\n        child0 = this.child[0] = new PackNode(\n          this.nodeDimensions.x,\n          this.nodeDimensions.y,\n          this.nodeDimensions.width,\n          imgHeight,\n        );\n        child1 = this.child[1] = new PackNode(\n          this.nodeDimensions.x,\n          this.nodeDimensions.y + imgHeight,\n          this.nodeDimensions.width,\n          dHeight,\n        );\n      }\n    }\n\n    // Insert into first child we created\n    return child0.insert(image);\n  }\n\n  /**\n   * Removes the image from the mapping and tries to open up as much space as possible.\n   *\n   * @param {AtlasTexture} image The image to insert into the\n   */\n  remove(image: SubTexture): boolean {\n    const child0 = this.child[0];\n    const child1 = this.child[1];\n\n    if (child1 && child0 && !this.isLeaf) {\n      // Try removing from first child\n      let removed: boolean = child0.remove(image);\n      if (removed) {\n        return true;\n      }\n      // Try remove from second\n      removed = child1.remove(image);\n\n      if (!child0.hasChild()) {\n        if (!child1.hasChild()) {\n          this.child[0] = null;\n          this.child[1] = null;\n        }\n      }\n\n      return removed;\n    } else {\n      if (this.nodeImage === image) {\n        this.nodeImage = null;\n        delete image.atlasReferenceID;\n        image.pixelWidth = 0;\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }\n}\n","import { observable } from '../../instance-provider';\nimport { IInstanceOptions, Instance } from '../../instance-provider/instance';\nimport { Image } from '../../primitives/image';\nimport { ImageAtlasResource, ImageRasterizer } from '../../surface/texture';\nimport { Anchor, AnchorType, ScaleType } from '../types';\n\nconst { max } = Math;\n\nexport interface IImageInstanceOptions extends IInstanceOptions {\n  /**\n   * The point on the image which will be placed in world space via the x, y coords. This is also the point\n   * which the image will be scaled around.\n   */\n  anchor?: Anchor;\n  /** Depth sorting of the image (or the z value of the lable) */\n  depth?: number;\n  /** This is the HTMLImageElement that the image is to render. This element MUST be loaded completely before this instance is created. */\n  element: HTMLImageElement;\n  /** The height of the image as it is to be rendered in world space */\n  height?: number;\n  /** Sets the way the image scales with the world */\n  scaling?: ScaleType;\n  /** The color the image should render as */\n  tint: [number, number, number, number];\n  /** The width of the image as it is to be rendered in world space */\n  width?: number;\n  /** The x coordinate where the image will be anchored to in world space */\n  x?: number;\n  /** The y coordinate where the image will be anchored to in world space */\n  y?: number;\n}\n\n/**\n * This is a reference for a rasterization that has reference counting. When the references go to zero,\n * the rasterization should be invalidated and resources freed for the rasterization.\n */\ntype RasterizationReference = {\n  resource: ImageAtlasResource;\n  references: number;\n};\n\n/**\n * This is a lookup to find existing rasterizations for a particularly created image so that every\n * new image does not have to go through the rasterization process.\n */\nconst rasterizationLookUp = new Map<\n  string | HTMLImageElement,\n  RasterizationReference\n>();\n\n/**\n * This is a lookup to quickly find the proper calculation for setting the correct anchor\n * position based on the anchor type.\n */\nconst anchorCalculator: {\n  [key: number]: (anchor: Anchor, image: ImageInstance) => void;\n} = {\n  [AnchorType.TopLeft]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopMiddle]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width / 2.0;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopRight]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width + anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.MiddleLeft]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = image.height / 2;\n  },\n  [AnchorType.Middle]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width / 2.0;\n    anchor.y = image.height / 2.0;\n  },\n  [AnchorType.MiddleRight]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width + anchor.padding;\n    anchor.y = image.height / 2.0;\n  },\n  [AnchorType.BottomLeft]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = image.height + anchor.padding;\n  },\n  [AnchorType.BottomMiddle]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width / 2.0;\n    anchor.y = image.height + anchor.padding;\n  },\n  [AnchorType.BottomRight]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width + anchor.padding;\n    anchor.y = image.height + anchor.padding;\n  },\n  [AnchorType.Custom]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = anchor.x || 0;\n    anchor.y = anchor.y || 0;\n  },\n};\n\n/**\n * This generates a new image instance.\n * There are restrictions surrounding images due to texture sizes and rendering limitations.\n *\n * Currently, we only support rendering a image via canvas, then rendering it to an Atlas texture\n * which is used to render to cards in the world for rendering. This is highly performant, but means:\n *\n * - Images should only be so large.\n * - Once a image is constructed, only SOME properties can be altered thereafter\n *\n * An image that is constructed can only have some properties set upon creating the image and are locked\n * thereafter. The only way to modify them would be to destroy the image, then construct a new image\n * with the modifications. This has to deal with performance regarding rasterizing the image.\n */\nexport class ImageInstance extends Instance implements Image {\n  /**\n   * TODO: We should be implementing the destroy on ImageInstances to clean this up\n   * Frees up module scoped data.\n   */\n  static destroy() {\n    rasterizationLookUp.clear();\n  }\n\n  /** This is the rendered color of the image */\n  @observable tint: [number, number, number, number] = [0, 0, 0, 1];\n  /** Depth sorting of the image (or the z value of the lable) */\n  @observable depth: number = 0;\n  /** The height of the image as it is to be rendered in world space */\n  @observable height: number = 1;\n  /** Sets the way the image scales with the world */\n  @observable scaling: ScaleType = ScaleType.BOUND_MAX;\n  /** The width of the image as it is to be rendered in world space */\n  @observable width: number = 1;\n  /** The x coordinate where the image will be anchored to in world space */\n  @observable x: number = 0;\n  /** The y coordinate where the image will be anchored to in world space */\n  @observable y: number = 0;\n\n  get size() {\n    return max(this.width, this.height);\n  }\n  set size(value: number) {\n    const aspect = this.width / this.height;\n    this.width = value * aspect;\n    this.height = value;\n  }\n\n  // The following properties are properties that are locked in after creating this image\n  // As the properties are completely locked into how the image was rasterized and can not\n  // Nor should not be easily adjusted for performance concerns\n\n  private _sourceWidth: number = 0;\n  private _sourceHeight: number = 0;\n  private _isDestroyed: boolean = false;\n  @observable private _rasterization: RasterizationReference;\n  private _path: string;\n  private _element: HTMLImageElement;\n\n  // The following are the getters for the locked in parameters of the image so we can read\n  // The properties but not set any of them.\n\n  /** This is the provided element this image will be rendering */\n  get element() {\n    return this._element;\n  }\n  /** This flag indicates if this image is valid anymore */\n  get isDestroyed() {\n    return this._isDestroyed;\n  }\n  /** This is the path to the image's resource if it's available */\n  get path() {\n    return this._path;\n  }\n  /** This gets the atlas resource that is uniquely idenfied for this image */\n  get resource() {\n    return this._rasterization.resource;\n  }\n\n  /**\n   * This is the width in world space of the image. If there is no camera distortion,\n   * this would be the width of the image in pixels on the screen.\n   */\n  get sourceWidth() {\n    return this._sourceWidth;\n  }\n\n  /**\n   * This is the height in world space of the image. If there is no camera distortion,\n   * this would be the height of the image in pixels on the screen.\n   */\n  get sourceHeight() {\n    return this._sourceHeight;\n  }\n\n  // These are properties that can be altered, but have side effects from being changed\n\n  /** This is the anchor location on the  */\n  @observable\n  private _anchor: Anchor = {\n    padding: 0,\n    type: AnchorType.TopLeft,\n    x: 0,\n    y: 0,\n  };\n\n  constructor(options: IImageInstanceOptions) {\n    super(options);\n\n    this.depth = options.depth || this.depth;\n    this.tint = options.tint || this.tint;\n    this.scaling = options.scaling || this.scaling;\n    this.x = options.x || this.x;\n    this.y = options.y || this.y;\n\n    // This is the image that is to be rendered\n    this._element = options.element;\n    // Look for other same texts that have been rasterized\n    let rasterization = rasterizationLookUp.get(this._path || this._element);\n\n    // If a rasterization exists, we must increment the use reference\n    if (rasterization) {\n      rasterization.references++;\n    }\n\n    // If we have not found an existing rasterization\n    if (!rasterization) {\n      rasterization = {\n        references: 1,\n        resource: new ImageAtlasResource(this),\n      };\n\n      // Ensure the sample scale is set. Defaults to 1.0\n      rasterization.resource.sampleScale =\n        rasterization.resource.sampleScale || 1.0;\n      // Rasterize the resource generated for this image. We need it immediately rasterized so\n      // That we can utilize the dimensions for calculations.\n      ImageRasterizer.renderSync(rasterization.resource);\n      // Now that we have an official rasterization for this image, we shall store it\n      // For others to look up\n      rasterizationLookUp.set(this._path || this._element, rasterization);\n    }\n\n    this._rasterization = rasterization;\n    this._sourceWidth = rasterization.resource.rasterization.world.width;\n    this._sourceHeight = rasterization.resource.rasterization.world.height;\n\n    this.width = options.width || this._sourceWidth || 1;\n    this.height = options.height || this._sourceHeight || 1;\n\n    // Make sure the anchor is set to the appropriate location\n    options.anchor && this.setAnchor(options.anchor);\n  }\n\n  get anchor() {\n    return this._anchor;\n  }\n\n  /**\n   * Images are a sort of unique case where the use of a image should be destroyed as rasterization\n   * resources are in a way kept alive through reference counting.\n   */\n  destroy() {\n    if (!this._isDestroyed) {\n      this._isDestroyed = true;\n      this._rasterization.references--;\n\n      // If all references are cleared, then the rasterization needs to be eradicated\n      if (this._rasterization.references === 0) {\n        this._rasterization.resource;\n        console.warn('The destroy method still needs completion');\n      }\n    }\n  }\n\n  resourceTrigger() {\n    // Trigger the accessed element that the layer utilizes for resource fetching.\n    this._rasterization = this._rasterization;\n  }\n\n  /**\n   * This applies a new anchor to this image and properly determines it's anchor position on the image\n   */\n  setAnchor(anchor: Anchor) {\n    const newAnchor = {\n      padding: anchor.padding || 0,\n      type: anchor.type,\n      x: anchor.x || 0,\n      y: anchor.y || 0,\n    };\n\n    // Calculate the new anchors position values\n    anchorCalculator[newAnchor.type](newAnchor, this);\n    // Apply the anchor\n    this._anchor = newAnchor;\n  }\n}\n","module.exports = \"precision highp float;\\n\\nvarying vec4 vertexColor;\\nvarying vec2 texCoord;\\n\\nvoid main() {\\n  ${attributes}\\n\\n  // Figure out the size of the image as it'd show on the screen\\n  vec3 screenSize = cameraSpaceSize(vec3(size, 1.0));\\n  // Do the test for when the image is larger on the screen than the font size\\n  bool largerOnScreen = screenSize.y > size.y;\\n\\n  // Determines if a scale mode should be used or not for the vertex\\n  float useScaleMode = float(\\n    (\\n      scaling == 3.0 ||                  // NEVER mode - keep the image the same size always\\n      (largerOnScreen && scaling == 2.0) // BOUND_MAX mode - only if we're larger than the font size do we scale down\\n    ) &&\\n    scaling != 1.0                       // ALWAYS mode - the image stays completely in world space allowing it to scale freely\\n  );\\n  // If zooms are unequal, assume one is filtered to be 1.0\\n  float unequalZooms = float(cameraScale.x != cameraScale.y);\\n\\n  // Destructure threejs's bug with the position requirement\\n  float normal = position.x;\\n  float side = position.y;\\n\\n  // Get the location of the anchor in world space\\n  vec2 worldAnchor = location + anchor;\\n\\n  // Get the tex coord from our inject texture info\\n  texCoord = texture.xy + ((texture.zw - texture.xy) * vec2(side, float(normal == -1.0)));\\n  // Apply the image's tint as a tint to the image\\n  vertexColor = tint;\\n\\n  // Correct aspect ratio.\\n  vec2 adjustedSize = mix(\\n    size,\\n    (size * cameraScale.yx),\\n    unequalZooms\\n  );\\n\\n  vec2 adjustedAnchor = mix(\\n    anchor,\\n    (anchor * cameraScale.yx),\\n    unequalZooms\\n  );\\n\\n  vec2 vertex = vec2(side, float(normal == 1.0)) * adjustedSize + location - adjustedAnchor;\\n\\n  // See how scaled the size on screen will be from the actual height of the image\\n  float imageScreenScale = mix(\\n    screenSize.y / adjustedSize.y,\\n    screenSize.x / adjustedSize.x,\\n    float((cameraScale.x < 1.0) || (cameraScale.x > 1.0))\\n  );\\n\\n  // If our screen rendering is larger than the size the image is supposed to be, then we automagically\\n  // scale down our image to stay the correct size, centered on the anchor point\\n  vec2 anchorToVertex = vertex - location;\\n\\n  // We now choose between keeping the same image size or keeping it in world space\\n  vertex = mix(\\n    // This option keeps the image size in world space\\n    vertex,\\n    // This option counters the scaling of the image on the screen keeping it a static size\\n    (anchorToVertex / imageScreenScale) + location,\\n    // This is the flag determining if a scale mode should be applied to the vertex\\n    useScaleMode\\n  );\\n\\n  gl_Position = clipSpace(vec3(vertex, depth));\\n}\\n\"","module.exports = \"precision highp float;\\n\\n${picking}\\nvarying vec4 vertexColor;\\nvarying vec2 texCoord;\\n\\nvoid main() {\\n  gl_FragColor = texture2D(imageAtlas, texCoord) * vertexColor;\\n  setColor(gl_FragColor * gl_FragColor.a);\\n}\\n\"","import * as Three from 'three';\nimport { Bounds, IPoint } from '../../primitives';\nimport {\n  ILayerProps,\n  IModelType,\n  IShaderInitialization,\n  Layer,\n} from '../../surface/layer';\nimport {\n  IMaterialOptions,\n  InstanceAttributeSize,\n  InstanceBlockIndex,\n  IProjection,\n  IUniform,\n  UniformSize,\n  VertexAttributeSize,\n} from '../../types';\nimport { CommonMaterialOptions } from '../../util';\nimport { ScaleType } from '../types';\nimport { ImageInstance } from './image-instance';\n\nconst { min, max } = Math;\n\nexport interface IImageLayerProps extends ILayerProps<ImageInstance> {\n  atlas?: string;\n}\n\n/**\n * This layer displays Images and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class ImageLayer extends Layer<ImageInstance, IImageLayerProps> {\n  /**\n   * We provide bounds and hit test information for the instances for this layer to allow for mouse picking\n   * of elements\n   */\n  getInstancePickingMethods() {\n    return {\n      // Provide the calculated AABB world bounds for a given image\n      boundsAccessor: (image: ImageInstance) => {\n        const anchorEffect = [0, 0];\n\n        if (image.anchor) {\n          anchorEffect[0] = image.anchor.x || 0;\n          anchorEffect[1] = image.anchor.y || 0;\n        }\n\n        const topLeft = [image.x - anchorEffect[0], image.y - anchorEffect[1]];\n\n        return new Bounds({\n          height: image.height,\n          width: image.width,\n          x: topLeft[0],\n          y: topLeft[1],\n        });\n      },\n\n      // Provide a precise hit test for the circle\n      hitTest: (image: ImageInstance, point: IPoint, view: IProjection) => {\n        // The bounds of the image is in world space, but it does not account for the scale mode of the image.\n        // Here, we will apply the scale mode testing to the image\n        const maxScale = max(...view.camera.scale);\n        const minScale = min(...view.camera.scale);\n\n        // If we scale always then the image stays within it's initial world bounds at all times\n        if (image.scaling === ScaleType.ALWAYS) {\n          return true;\n        }\n\n        // If we scale with bound max, then when the camera zooms in, the bounds will shrink to keep the\n        // Image the same size. If the camera zooms out then the bounds === the world bounds.\n        else if (image.scaling === ScaleType.BOUND_MAX) {\n          // We are zooming out. the bounds will stay within the world bounds\n          if (minScale <= 1 && maxScale <= 1) {\n            return true;\n          }\n\n          // We are zooming in. The bounds will shrink to keep the image at max font size\n          else {\n            // The location is within the world, but we reverse project the anchor spread\n            const anchorEffect = [0, 0];\n\n            if (image.anchor) {\n              anchorEffect[0] = image.anchor.x || 0;\n              anchorEffect[1] = image.anchor.y || 0;\n            }\n\n            const topLeft = view.worldToScreen({\n              x: image.x - anchorEffect[0] / view.camera.scale[0],\n              y: image.y - anchorEffect[1] / view.camera.scale[1],\n            });\n\n            const screenPoint = view.worldToScreen(point);\n\n            // Reverse project the size and we should be within the distorted world coordinates\n            return new Bounds({\n              height: image.height,\n              width: image.width,\n              x: topLeft.x,\n              y: topLeft.y,\n            }).containsPoint(screenPoint);\n          }\n        }\n\n        // If we never allow the image to scale, then the bounds will grow and shrink to counter the effects\n        // Of the camera zoom\n        else if (image.scaling === ScaleType.NEVER) {\n          // The location is within the world, but we reverse project the anchor spread\n          const anchorEffect = [0, 0];\n\n          if (image.anchor) {\n            anchorEffect[0] = image.anchor.x || 0;\n            anchorEffect[1] = image.anchor.y || 0;\n          }\n\n          const topLeft = view.worldToScreen({\n            x: image.x - anchorEffect[0] / view.camera.scale[0],\n            y: image.y - anchorEffect[1] / view.camera.scale[1],\n          });\n\n          const screenPoint = view.worldToScreen(point);\n\n          // Reverse project the size and we should be within the distorted world coordinates\n          return new Bounds({\n            height: image.height,\n            width: image.width,\n            x: topLeft.x,\n            y: topLeft.y,\n          }).containsPoint(screenPoint);\n        }\n\n        return true;\n      },\n    };\n  }\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<ImageInstance> {\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1,\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: 0,\n      1: 0,\n      2: 0,\n      3: 1,\n      4: 1,\n      5: 1,\n    };\n\n    return {\n      fs: require('./image-layer.fs'),\n      instanceAttributes: [\n        {\n          block: 0,\n          blockIndex: InstanceBlockIndex.ONE,\n          name: 'location',\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.x, o.y],\n        },\n        {\n          block: 0,\n          blockIndex: InstanceBlockIndex.THREE,\n          name: 'anchor',\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.anchor.x || 0, o.anchor.y || 0],\n        },\n        {\n          block: 1,\n          blockIndex: InstanceBlockIndex.ONE,\n          name: 'size',\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.width, o.height],\n        },\n        {\n          block: 1,\n          blockIndex: InstanceBlockIndex.THREE,\n          name: 'depth',\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth],\n        },\n        {\n          block: 1,\n          blockIndex: InstanceBlockIndex.FOUR,\n          name: 'scaling',\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scaling],\n        },\n        {\n          atlas: {\n            key: this.props.atlas || '',\n            name: 'imageAtlas',\n          },\n          block: 2,\n          name: 'texture',\n          update: o => this.resource.request(this, o, o.resource),\n        },\n        {\n          block: 3,\n          blockIndex: InstanceBlockIndex.ONE,\n          name: 'tint',\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.tint,\n        },\n      ],\n      uniforms: [\n        {\n          name: 'scaleFactor',\n          size: UniformSize.ONE,\n          update: (u: IUniform) => [1],\n        },\n      ],\n      vertexAttributes: [\n        // TODO: This is from the heinous evils of THREEJS and their inability to fix a bug within our lifetimes.\n        // Right now position is REQUIRED in order for rendering to occur, otherwise the draw range gets updated to\n        // Zero against your wishes.\n        {\n          name: 'position',\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexToSide[vertex],\n            0,\n          ],\n        },\n      ],\n      vertexCount: 6,\n      vs: require('./image-layer.vs'),\n    };\n  }\n\n  getModelType(): IModelType {\n    return {\n      drawMode: Three.TriangleStripDrawMode,\n      modelType: Three.Mesh,\n    };\n  }\n\n  getMaterialOptions(): IMaterialOptions {\n    return CommonMaterialOptions.transparentImage;\n  }\n}\n","import {\n  IInstanceOptions,\n  Instance,\n  observable,\n} from '../../instance-provider';\n\nexport interface IEdgeInstanceOptions extends IInstanceOptions {\n  /** The color of this edge at the start point. */\n  colorStart?: [number, number, number, number];\n  /** The color of this edge at the end point. */\n  colorEnd?: [number, number, number, number];\n  /** This is the list of control points  */\n  control?: [number, number][];\n  /** The z depth of the edge (for draw ordering) */\n  depth?: number;\n  /** End point of the edge. */\n  end: [number, number];\n  /** Beginning point of the edge. */\n  start: [number, number];\n  /** Start width of the edge. */\n  widthStart?: number;\n  /** End width of the edge */\n  widthEnd?: number;\n}\n\nexport type EdgeColor = [number, number, number, number];\n\nexport class EdgeInstance extends Instance {\n  @observable colorStart: EdgeColor = [1.0, 1.0, 1.0, 1.0];\n  @observable colorEnd: EdgeColor = [1.0, 1.0, 1.0, 1.0];\n  @observable control: [number, number][] = [[0, 0], [0, 0]];\n  @observable depth: number = 0;\n  @observable end: [number, number] = [0, 0];\n  @observable start: [number, number] = [0, 0];\n  @observable widthStart: number = 1.0;\n  @observable widthEnd: number = 1.0;\n\n  get length() {\n    const delta = [this.end[0] - this.start[0], this.end[1] - this.start[1]];\n\n    return Math.sqrt(delta[0] * delta[0] + delta[1] * delta[1]);\n  }\n\n  /**\n   * Calculates the midpoint of the edge\n   */\n  get midpoint() {\n    return 0;\n  }\n\n  /**\n   * Calculates a perpendicular direction vector to the edge\n   */\n  get perpendicular(): [number, number] {\n    const length = this.length;\n\n    return [\n      (this.end[1] - this.start[1]) / length,\n      -(this.end[0] - this.start[0]) / length,\n    ];\n  }\n\n  /**\n   * Applies the edge width to the start and end\n   */\n  setEdgeWidth(width: number) {\n    if (width) {\n      this.widthEnd = width;\n      this.widthStart = width;\n    }\n  }\n\n  /**\n   * Applies the color to the start and end\n   */\n  setColor(color: EdgeColor) {\n    this.colorStart = color;\n    this.colorEnd = color;\n  }\n\n  constructor(options: IEdgeInstanceOptions) {\n    super(options);\n    this.colorStart = options.colorStart || this.colorStart;\n    this.colorEnd = options.colorEnd || this.colorEnd;\n    this.control = options.control || this.control;\n    this.depth = options.depth || this.depth;\n    this.end = options.end || this.end;\n    this.widthStart = options.widthStart || this.widthStart;\n    this.widthEnd = options.widthEnd || this.widthEnd;\n    this.start = options.start || this.start;\n  }\n}\n","module.exports = \"precision highp float;\\n\\n${picking}\\nvarying vec4 vertexColor;\\n\\nvoid main() {\\n  setColor(vertexColor);\\n}\\n\"","module.exports = \"/**\\n  This vertex shader calculates edges based in world space to make an edge based on\\n  bezier curves with 0, 1, and 2 control points.\\n**/\\nprecision highp float;\\n\\nvarying vec4 vertexColor;\\n\\n// Interpolation type injection\\n${interpolation}\\n\\nvoid main() {\\n  ${attributes}\\n\\n  // Destructure threejs's bug with the position requirement\\n  float normal = position.x;\\n  float interpolationTime = position.y;\\n  float interpolationIncrement = 1.0 / position.z;\\n\\n  // Convert our world points to screen space\\n  vec4 startClip = clipSpace(vec3(start, depth));\\n  vec4 endClip = clipSpace(vec3(end, depth));\\n  vec2 startScreen = (startClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\n  vec2 endScreen = (endClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\n  // Controls for this mode are screen space deltas from the end points\\n  vec2 control1 = startScreen + vec2(control.x, -control.y) * scaleFactor;\\n  vec2 control2 = endScreen + vec2(control.z, -control.w) * scaleFactor;\\n\\n  // Get the position of the current vertex\\n  vec2 currentPosition = interpolation(interpolationTime, startScreen, endScreen, control1, control2);\\n  // Calculate the next and previous segment's location on the line\\n  vec2 prePosition = interpolation(interpolationTime - interpolationIncrement, startScreen, endScreen, control1, control2);\\n  vec2 nextPosition = interpolation(interpolationTime + interpolationIncrement, startScreen, endScreen, control1, control2);\\n\\n  vec2 preLine = prePosition - currentPosition;\\n  vec2 nextLine = nextPosition - currentPosition;\\n\\n  // Get a spliced nromal at the joining of two segments to make a crisper curve\\n  vec2 currentNormal = mix(\\n    // Pick this value if we're at the beginning of the line\\n    normalize(vec2(preLine.y, -preLine.x)),\\n    mix(\\n      // Pick this value when we're between the ends\\n      normalize(vec2(preLine.y, -preLine.x) + vec2(-nextLine.y, nextLine.x)),\\n      // Pick this value if we're at the end of the line\\n      normalize(vec2(-nextLine.y, nextLine.x)),\\n      float(position.x >= 1.0)\\n    ),\\n    float(position.x > 0.0)\\n  );\\n\\n  // Get the thickness based on the side we're on\\n  float lineThickness = mix(widthStart, widthEnd, interpolationTime) / 2.0;\\n  // Start on the calculated line and push out by the normal's value\\n  vec2 vertex = currentPosition + currentNormal * (-normal * lineThickness * scaleFactor);\\n  // Get the color based on where we are on the line\\n  vertexColor = mix(colorStart, colorEnd, interpolationTime);\\n  vertexColor *= vertexColor.a;\\n\\n  gl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), startClip.zw);\\n  gl_PointSize = 5.0;\\n}\\n\"","module.exports = \"precision highp float;\\n\\n/**\\n  This vertex shader calculates edges whose curve and width is in screen space where the curve is\\n  bezier curves with 0, 1, and 2 control points.\\n**/\\nvarying vec4 vertexColor;\\n\\n// Interpolation type injection\\n${interpolation}\\n\\nvoid main() {\\n  ${attributes}\\n\\n  // Destructure threejs's bug with the position requirement\\n  float normal = position.x;\\n  float interpolationTime = position.y;\\n  float interpolationIncrement = 1.0 / position.z;\\n  // Get the position of the current vertex\\n  vec2 currentPosition = interpolation(interpolationTime, start, end, control.xy, control.zw);\\n  // Calculate the next and previous segment's location on the line\\n  vec2 prePosition = interpolation(interpolationTime - interpolationIncrement, start, end, control.xy, control.zw);\\n  vec2 nextPosition = interpolation(interpolationTime + interpolationIncrement, start, end, control.xy, control.zw);\\n\\n  vec2 preLine = prePosition - currentPosition;\\n  vec2 nextLine = nextPosition - currentPosition;\\n\\n  // Get a spliced nromal at the joining of two segments to make a crisper curve\\n  vec2 currentNormal = mix(\\n    // Pick this value if we're at the beginning of the line\\n    normalize(vec2(preLine.y, -preLine.x)),\\n    mix(\\n      // Pick this value when we're between the ends\\n      normalize(vec2(preLine.y, -preLine.x) + vec2(-nextLine.y, nextLine.x)),\\n      // Pick this value if we're at the end of the line\\n      normalize(vec2(-nextLine.y, nextLine.x)),\\n      float(position.x >= 1.0)\\n    ),\\n    float(position.x > 0.0)\\n  );\\n\\n  // Get the thickness based on the side we're on\\n  float lineThickness = mix(widthStart, widthEnd, interpolationTime) / 2.0;\\n  // Start on the calculated line and push out by the normal's value\\n  vec2 vertex = currentPosition + currentNormal * (normal * lineThickness);\\n  // Get the color based on where we are on the line\\n  vertexColor = mix(colorStart, colorEnd, interpolationTime);\\n  vertexColor *= vertexColor.a;\\n\\n  gl_Position = clipSpace(vec3(vertex, depth));\\n  gl_PointSize = 5.0;\\n}\\n\"","module.exports = \"/**\\n * Makes a linear interpolation between two points\\n *\\n * @param {vec2} s The start point\\n * @param {vec2} e The end point\\n * @param {vec2} c The bezier control point\\n * @param {float} t The interpolation value [0, 1]\\n *\\n * @returns {vec2} A point interpolated between the two provided points\\n */\\nvec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {\\n  float t1 = 1.0 - t;\\n  return pow(t1, 3.0) * p1 + 3.0 * t * pow(t1, 2.0) * c1 + 3.0 * pow(t, 2.0) * t1 * c2 + pow(t, 3.0) * p2;\\n}\\n\"","module.exports = \"/**\\n * Makes a linear interpolation between two points\\n *\\n * @param {vec2} s The start point\\n * @param {vec2} e The end point\\n * @param {vec2} c The bezier control point\\n * @param {float} t The interpolation value [0, 1]\\n *\\n * @returns {vec2} A point interpolated between the two provided points\\n */\\nvec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {\\n  return (1.0 - t) * (1.0 - t) * p1 + 2.0 * t * (1.0 - t) * c1 + t * t * p2;\\n}\\n\"","module.exports = \"/**\\n * Makes a linear interpolation between two points\\n *\\n * @param {vec2} s The start point\\n * @param {vec2} e The end point\\n * @param {vec2} c The bezier control point\\n * @param {float} t The interpolation value [0, 1]\\n *\\n * @returns {vec2} A point interpolated between the two provided points\\n */\\nvec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {\\n  return p1 + (p2 - p1) * t;\\n}\\n\"","/**\n * This file contains the logic for handling edge picking via quad tree and hit tests.\n * The methods involved are fairly robust and would clutter the layer's code file.\n */\nimport { IPoint } from '../../primitives';\nimport { Bounds } from '../../primitives/bounds';\nimport { IPickingMethods } from '../../surface/layer';\nimport { IProjection } from '../../types';\nimport {\n  add2,\n  dot2,\n  length2,\n  scale2,\n  subtract2,\n  Vec2,\n} from '../../util/vector';\nimport { EdgeInstance } from './edge-instance';\nimport { IEdgeLayerProps } from './edge-layer';\nimport { EdgeBroadphase, EdgeScaleType, EdgeType } from './types';\nconst { pow } = Math;\n\ntype InterpolationMethod = (\n  t: number,\n  p1: Vec2,\n  p2: Vec2,\n  c1: Vec2,\n  c2: Vec2,\n) => Vec2;\n\n/** This is an interpolation across a line */\nfunction linear(t: number, p1: Vec2, p2: Vec2, c1: Vec2, c2: Vec2): Vec2 {\n  return add2(scale2(subtract2(p2, p1), t), p1);\n}\n\n/** This is an interpolation across a bezier curve, single control */\nfunction bezier(t: number, p1: Vec2, p2: Vec2, c1: Vec2, c2: Vec2): Vec2 {\n  return [\n    (1.0 - t) * (1.0 - t) * p1[0] + 2.0 * t * (1.0 - t) * c1[0] + t * t * p2[0],\n    (1.0 - t) * (1.0 - t) * p1[1] + 2.0 * t * (1.0 - t) * c1[1] + t * t * p2[1],\n  ];\n}\n\n/** This is an interpolation across a bezier curve, double control */\nfunction bezier2(t: number, p1: Vec2, p2: Vec2, c1: Vec2, c2: Vec2): Vec2 {\n  const t1 = 1.0 - t;\n\n  return [\n    pow(t1, 3.0) * p1[0] +\n      3.0 * t * pow(t1, 2.0) * c1[0] +\n      3.0 * pow(t, 2.0) * t1 * c2[0] +\n      pow(t, 3.0) * p2[0],\n    pow(t1, 3.0) * p1[1] +\n      3.0 * t * pow(t1, 2.0) * c1[1] +\n      3.0 * pow(t, 2.0) * t1 * c2[1] +\n      pow(t, 3.0) * p2[1],\n  ];\n}\n\n/** A quick lookup for an interpolation method based on Edge Type */\nconst interpolation: { [key: number]: InterpolationMethod } = {\n  [EdgeType.LINE]: linear,\n  [EdgeType.BEZIER]: bezier,\n  [EdgeType.BEZIER2]: bezier2,\n};\n\n/** Converts a point array to a point object */\nfunction toPointObject(point: Vec2): IPoint {\n  return {\n    x: point[0],\n    y: point[1],\n  };\n}\n\n/** Converts a point object to a point array */\nfunction toPointArray(point: IPoint): Vec2 {\n  return [point.x, point.y];\n}\n\n/** Takes two points that forms a line then calculates the nearest distance from that line to the third point */\nfunction distanceTo(start: Vec2, end: Vec2, p: Vec2) {\n  // Make a vector from a line point to the indicated point\n  const vector: Vec2 = subtract2(start, p);\n  const lineDirection: Vec2 = subtract2(end, start);\n  const lineNormal: Vec2 = [lineDirection[1], -lineDirection[0]];\n  const distance: number =\n    Math.abs(dot2(vector, lineNormal)) / length2(lineDirection);\n\n  // The distance is d = |v . r| where v is a unit perpendicular vector to the Line\n  return distance;\n}\n\n// This sets the number of iterations along a curve we sample to test collisions with\nconst TEST_RESOLUTION = 50;\n\n/**\n * This generates the picking methods needed for managing PickType.ALL for the edge layer.\n */\nexport function edgePicking(\n  props: IEdgeLayerProps,\n): IPickingMethods<EdgeInstance> {\n  const { broadphase, minPickDistance = 0, scaleType, type } = props;\n  const interpolate = interpolation[props.type];\n\n  const boundsAccessor = (edge: EdgeInstance) => {\n    const edgeWidthStart = edge.widthStart / 2 + minPickDistance;\n    const edgeWidthEnd = edge.widthEnd / 2 + minPickDistance;\n    // Encapsulate the endpoints as they are guaranteed to be included in the shape\n    // Each endpoint will be a box that includes the endpoint thickness\n    const bounds = new Bounds({\n      height: edge.widthStart,\n      width: edge.widthStart,\n      x: edge.start[0] - edgeWidthStart,\n      y: edge.start[1] - edgeWidthStart,\n    });\n\n    bounds.encapsulate(\n      new Bounds({\n        height: edge.widthEnd,\n        width: edge.widthEnd,\n        x: edge.end[0] - edgeWidthEnd,\n        y: edge.end[1] - edgeWidthEnd,\n      }),\n    );\n\n    // Encapsulating the bezier control points is enough of a broadphase for beziers\n    if (props.type === EdgeType.BEZIER) {\n      bounds.encapsulate({\n        x: edge.control[0][0],\n        y: edge.control[0][1],\n      });\n    }\n\n    // Encapsulating the bezier control points is enough of a broadphase for beziers\n    else if (props.type === EdgeType.BEZIER2) {\n      bounds.encapsulate({\n        x: edge.control[0][0],\n        y: edge.control[0][1],\n      });\n\n      bounds.encapsulate({\n        x: edge.control[1][0],\n        y: edge.control[1][1],\n      });\n    }\n\n    if (broadphase === EdgeBroadphase.PASS_X) {\n      bounds.x = Number.MIN_SAFE_INTEGER / 2;\n      bounds.width = Number.MAX_SAFE_INTEGER;\n    }\n\n    if (broadphase === EdgeBroadphase.PASS_Y) {\n      bounds.y = Number.MIN_SAFE_INTEGER / 2;\n      bounds.height = Number.MAX_SAFE_INTEGER;\n    }\n\n    return bounds;\n  };\n\n  if (scaleType === EdgeScaleType.SCREEN_CURVE) {\n    return {\n      // Provide the calculated AABB world bounds for a given circle\n      boundsAccessor,\n\n      // Provide a precise hit test for the edge. This method performs all of the rendering\n      // And hit tests within screen space as opposed to world space.\n      hitTest: (edge: EdgeInstance, point: IPoint, view: IProjection) => {\n        point = view.worldToScreen(point);\n        const mouse: Vec2 = [point.x, point.y];\n        let closestIndex = 0;\n        let closestDistance = Number.MAX_VALUE;\n        let secondClosestIndex = 0;\n        let secondClosestDistance = Number.MAX_VALUE;\n\n        const start = view.worldToScreen(toPointObject(edge.start));\n        const end = view.worldToScreen(toPointObject(edge.end));\n        let control1: Vec2 = [0, 0];\n        let control2: Vec2 = [0, 0];\n\n        if (type === EdgeType.BEZIER) {\n          control1 = add2(toPointArray(start), edge.control[0]);\n        } else if (type === EdgeType.BEZIER2) {\n          control1 = add2(toPointArray(start), edge.control[0]);\n          control2 = add2(toPointArray(end), edge.control[1]);\n        }\n\n        const startPoint = toPointArray(start);\n        const endPoint = toPointArray(end);\n\n        control1 = edge.control.length > 0 ? control1 : [0, 0];\n        control2 = edge.control.length > 1 ? control2 : [0, 0];\n\n        // Loop through sample points on the line and find one that is closest to the mouse point as possible\n        for (let i = 0; i < TEST_RESOLUTION; ++i) {\n          const linePoint = interpolate(\n            i / TEST_RESOLUTION,\n            startPoint,\n            endPoint,\n            control1,\n            control2,\n          );\n          const distance = length2(subtract2(mouse, linePoint));\n\n          if (distance < closestDistance) {\n            secondClosestIndex = closestIndex;\n            secondClosestDistance = closestDistance;\n            closestIndex = i;\n            closestDistance = distance;\n          } else if (distance < secondClosestDistance) {\n            secondClosestIndex = i;\n            closestDistance = distance;\n          }\n        }\n\n        const t = closestIndex / TEST_RESOLUTION;\n        const lineWidth =\n          (edge.widthEnd - edge.widthStart) * t + edge.widthStart;\n\n        if (closestIndex === secondClosestIndex) {\n          return false;\n        }\n\n        const startSegment = interpolate(\n          closestIndex / TEST_RESOLUTION,\n          startPoint,\n          endPoint,\n          control1,\n          control2,\n        );\n\n        const endSegment = interpolate(\n          secondClosestIndex / TEST_RESOLUTION,\n          startPoint,\n          endPoint,\n          control1,\n          control2,\n        );\n\n        // See how close the mouse is to the line between the two closest points for a more accurate\n        // Test\n        closestDistance = distanceTo(startSegment, endSegment, mouse);\n\n        // This helps determine if the mouse is beyond the end point\n        if (\n          dot2(\n            subtract2(endSegment, startSegment),\n            subtract2(mouse, startSegment),\n          ) < 0\n        ) {\n          return false;\n        }\n\n        return closestDistance < lineWidth / 2.0 + minPickDistance;\n      },\n    };\n  }\n\n  return {\n    // Provide the calculated AABB world bounds for a given circle\n    boundsAccessor,\n\n    // Provide a precise hit test for the edge\n    hitTest: (edge: EdgeInstance, point: IPoint, view: IProjection) => {\n      const mouse: [number, number] = [point.x, point.y];\n      let closestIndex = 0;\n      let closestDistance = Number.MAX_VALUE;\n\n      // Loop through sample points on the line and find one that is closest to the mouse point as possible\n      for (let i = 0; i < TEST_RESOLUTION; ++i) {\n        const linePoint = interpolate(\n          i / TEST_RESOLUTION,\n          edge.start,\n          edge.end,\n          edge.control.length > 0 ? edge.control[0] : [0, 0],\n          edge.control.length > 1 ? edge.control[1] : [0, 0],\n        );\n        const distance = length2(subtract2(mouse, linePoint));\n\n        if (distance < closestDistance) {\n          closestIndex = i;\n          closestDistance = distance;\n        }\n      }\n\n      const t = closestIndex / TEST_RESOLUTION;\n      const lineWidth = (edge.widthEnd - edge.widthStart) * t + edge.widthStart;\n\n      return closestDistance < lineWidth / 2.0;\n    },\n  };\n}\n","import * as Three from 'three';\nimport { InstanceProvider } from '../../instance-provider';\nimport {\n  ILayerProps,\n  IModelType,\n  IPickingMethods,\n  IShaderInitialization,\n  Layer,\n} from '../../surface/layer';\nimport {\n  IMaterialOptions,\n  InstanceAttributeSize,\n  InstanceBlockIndex,\n  InstanceIOValue,\n  IUniform,\n  UniformSize,\n  VertexAttributeSize,\n} from '../../types';\nimport { CommonMaterialOptions, IAutoEasingMethod, shaderTemplate, Vec } from '../../util';\nimport { EdgeInstance } from './edge-instance';\nimport { edgePicking } from './edge-picking';\nimport { EdgeBroadphase, EdgeScaleType, EdgeType } from './types';\n\nexport interface IEdgeLayerProps extends ILayerProps<EdgeInstance> {\n  /** Specifies which properties to make GPU easing happen and how they should be animated */\n  animate?: {\n    end?: IAutoEasingMethod<Vec>,\n    start?: IAutoEasingMethod<Vec>,\n    colorStart?: IAutoEasingMethod<Vec>,\n    colorEnd?: IAutoEasingMethod<Vec>,\n    control?: IAutoEasingMethod<Vec>,\n  };\n  /** Allows adjustments for broadphase interactions for an edge */\n  broadphase?: EdgeBroadphase;\n  /** Any distance to the mouse from an edge that is less than this distance will be picked */\n  minPickDistance?: number;\n  /** This sets a scaling factor for the edge's line width and curve  */\n  scaleFactor?(): number;\n  /**\n   * If this is set, then the thickness of the line and the curvature of the line exists in screen space\n   * rather than world space.\n   */\n  scaleType?: EdgeScaleType;\n  /** Specifies how the edge is formed */\n  type: EdgeType;\n}\n\nexport interface IEdgeLayerState {}\n\n/** Converts a control list to an IO value */\nfunction toInstanceIOValue(value: [number, number][]): InstanceIOValue {\n  return [value[0][0], value[0][1], value[1][0], value[1][1]];\n}\n\n/** This picks the appropriate shader for the edge type desired */\nconst pickVS = {\n  [EdgeType.LINE]: require('./shader/edge-layer-line.vs'),\n  [EdgeType.BEZIER]: require('./shader/edge-layer-bezier.vs'),\n  [EdgeType.BEZIER2]: require('./shader/edge-layer-bezier2.vs'),\n};\n\n/** This is the base edge layer which is a template that can be filled with the needed specifics for a given line type */\nconst baseVS = require('./shader/edge-layer.vs');\nconst screenVS = require('./shader/edge-layer-screen-curve.vs');\nconst edgeFS = require('./shader/edge-layer.fs');\n\n/**\n * This layer displays edges and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class EdgeLayer extends Layer<EdgeInstance, IEdgeLayerProps> {\n  // Set default props for the layer\n  static defaultProps: IEdgeLayerProps = {\n    broadphase: EdgeBroadphase.ALL,\n    data: new InstanceProvider<EdgeInstance>(),\n    key: 'none',\n    scaleType: EdgeScaleType.NONE,\n    type: EdgeType.LINE,\n  };\n\n  /**\n   * We provide bounds and hit test information for the instances for this layer to allow for mouse picking\n   * of elements\n   */\n  getInstancePickingMethods(): IPickingMethods<EdgeInstance> {\n    return edgePicking(this.props);\n  }\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<EdgeInstance> {\n    const {\n      animate = {},\n      scaleFactor = () => 1,\n      type,\n      scaleType = EdgeScaleType.NONE,\n    } = this.props;\n\n    const {\n      end: animateEnd,\n      start: animateStart,\n      colorStart: animateColorStart,\n      colorEnd: animateColorEnd,\n      control: animateControl,\n    } = animate;\n\n    const MAX_SEGMENTS = type === EdgeType.LINE ? 2 : 50;\n\n    // Calculate the normals and interpolations for our vertices\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      [MAX_SEGMENTS * 2 + 2]: -1,\n    };\n\n    const vertexInterpolation: { [key: number]: number } = {\n      0: 0,\n      [MAX_SEGMENTS * 2 + 2]: 1,\n    };\n\n    let sign = 1;\n    for (let i = 0; i < MAX_SEGMENTS * 2; ++i) {\n      vertexToNormal[i + 1] = sign;\n      vertexInterpolation[i + 1] = Math.floor(i / 2) / (MAX_SEGMENTS - 1);\n      sign *= -1;\n    }\n\n    const vs = shaderTemplate(\n      scaleType === EdgeScaleType.NONE ? baseVS : screenVS,\n      {\n        // Retain the attributes injection\n        attributes: '${attributes}',\n        // Inject the proper interpolation method\n        interpolation: pickVS[type],\n      },\n      {\n        name: 'Edge Layer',\n        values: ['interpolation'],\n      },\n    );\n\n    return {\n      fs: edgeFS,\n      instanceAttributes: [\n        {\n          block: 0,\n          blockIndex: InstanceBlockIndex.ONE,\n          easing: animateStart,\n          name: 'start',\n          size: InstanceAttributeSize.TWO,\n          update: o => o.start,\n        },\n        {\n          block: 0,\n          blockIndex: InstanceBlockIndex.THREE,\n          easing: animateEnd,\n          name: 'end',\n          size: InstanceAttributeSize.TWO,\n          update: o => o.end,\n        },\n        {\n          block: 1,\n          blockIndex: InstanceBlockIndex.ONE,\n          name: 'widthStart',\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.widthStart],\n        },\n        {\n          block: 1,\n          blockIndex: InstanceBlockIndex.TWO,\n          name: 'widthEnd',\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.widthEnd],\n        },\n        {\n          block: 1,\n          blockIndex: InstanceBlockIndex.THREE,\n          name: 'depth',\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth],\n        },\n        {\n          block: 2,\n          blockIndex: InstanceBlockIndex.ONE,\n          easing: animateColorStart,\n          name: 'colorStart',\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.colorStart,\n        },\n        {\n          block: 3,\n          blockIndex: InstanceBlockIndex.ONE,\n          easing: animateColorEnd,\n          name: 'colorEnd',\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.colorEnd,\n        },\n        type === EdgeType.LINE\n          ? {\n              block: 4,\n              blockIndex: InstanceBlockIndex.ONE,\n              easing: animateControl,\n              name: 'control',\n              size: InstanceAttributeSize.FOUR,\n              update: o => [0, 0, 0, 0],\n            }\n          : null,\n        type === EdgeType.BEZIER\n          ? {\n              block: 4,\n              blockIndex: InstanceBlockIndex.ONE,\n              easing: animateControl,\n              name: 'control',\n              size: InstanceAttributeSize.FOUR,\n              update: o => [o.control[0][0], o.control[0][1], 0, 0],\n            }\n          : null,\n        type === EdgeType.BEZIER2\n          ? {\n              block: 4,\n              blockIndex: InstanceBlockIndex.ONE,\n              easing: animateControl,\n              name: 'control',\n              size: InstanceAttributeSize.FOUR,\n              update: o => toInstanceIOValue(o.control),\n            }\n          : null,\n      ],\n      uniforms: [\n        {\n          name: 'scaleFactor',\n          size: UniformSize.ONE,\n          update: (uniform: IUniform) => [scaleFactor()],\n        },\n      ],\n      vertexAttributes: [\n        // TODO: This is from the heinous evils of THREEJS and their inability to fix a bug within our lifetimes.\n        // Right now position is REQUIRED in order for rendering to occur, otherwise the draw range gets updated to\n        // Zero against your wishes.\n        {\n          name: 'position',\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexInterpolation[vertex],\n            // The number of vertices\n            MAX_SEGMENTS * 2,\n          ],\n        },\n      ],\n      vertexCount: MAX_SEGMENTS * 2 + 2,\n      vs: vs.shader,\n    };\n  }\n\n  getModelType(): IModelType {\n    return {\n      drawMode: Three.TriangleStripDrawMode,\n      modelType: Three.Mesh,\n    };\n  }\n\n  getMaterialOptions(): IMaterialOptions {\n    return CommonMaterialOptions.transparentShape;\n  }\n}\n","export * from './edge-layer';\nexport * from './edge-instance';\nexport * from './types';\n","import {\n  IInstanceOptions,\n  Instance,\n  observable,\n} from '../../instance-provider';\nimport { Circle } from '../../primitives/circle';\n\nexport interface ICircleInstanceOptions extends IInstanceOptions, Circle {\n  /** The color of this circle */\n  color?: [number, number, number, number];\n  /** The z depth of the circle (for draw ordering) */\n  depth?: number;\n}\n\nexport class CircleInstance extends Instance implements Circle {\n  @observable color: [number, number, number, number] = [1.0, 1.0, 1.0, 1.0];\n  @observable depth: number = 0;\n  @observable radius: number = 0;\n  @observable x: number = 0;\n  @observable y: number = 0;\n\n  constructor(options: ICircleInstanceOptions) {\n    super(options);\n\n    this.color = options.color || this.color;\n    this.radius = options.radius || this.radius;\n    this.x = options.x || this.x;\n    this.y = options.y || this.y;\n    this.depth = options.depth || this.depth;\n  }\n\n  get width() {\n    return this.radius * 2;\n  }\n\n  get height() {\n    return this.radius * 2;\n  }\n}\n","module.exports = \"precision highp float;\\n\\nvarying vec4 vertexColor;\\nvarying float edgeSharpness;\\nvarying float edgeSharpnessBase;\\nvarying vec2 pointCoord;\\n\\nvoid main() {\\n  ${attributes}\\n\\n  vertexColor = color * color.a;\\n  float size = radius * scaleFactor;\\n  edgeSharpness = mix(0.8, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));\\n  edgeSharpnessBase = mix(0.1, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));\\n  pointCoord = (position.xy + vec2(1.0, 1.0)) / 2.0;\\n\\n  // Center within clip space\\n  vec4 clipCenter = clipSpace(vec3(center, depth));\\n  // Center in screen space\\n  vec2 screenCenter = (clipCenter.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\n  // Position in screen space\\n  vec2 vertex = (position.xy * size) + screenCenter;\\n  // Position back to clip space\\n  gl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), clipCenter.zw);\\n}\\n\"","module.exports = \"precision highp float;\\n\\n${picking}\\n\\nvarying vec4 vertexColor;\\nvarying float edgeSharpness;\\nvarying float edgeSharpnessBase;\\nvarying vec2 pointCoord;\\n\\nfloat circle(vec2 coord, float radius){\\n  vec2 dist = coord - vec2(0.5);\\n\\n  return 1.0 - smoothstep(\\n    radius - (radius * edgeSharpness),\\n    radius + (radius * edgeSharpnessBase),\\n    dot(dist, dist) * 4.0\\n  );\\n}\\n\\nvoid main() {\\n  float step_factor = circle(pointCoord.xy, 1.0);\\n\\n  setColor(mix(\\n    vec4(0.0, 0.0, 0.0, 0.0),\\n    vertexColor,\\n    step_factor\\n  ));\\n}\\n\"","module.exports = \"void main() {\\n  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n}\"","module.exports = \"\"","import { Bounds } from '../primitives';\nimport { IPoint } from '../primitives/point';\nimport {\n  IColorPickingData,\n  InstanceHitTest,\n  IPickInfo,\n  IProjection,\n  PickType,\n} from '../types';\nimport { Instance, TrackedQuadTree } from '../util';\nimport { UniformColorDiffProcessor } from './buffer-management/diff-processors/uniform-color-diff-processor';\nimport { ILayerProps, Layer } from './layer';\n\nfunction isColorProcessor<T extends Instance>(\n  val: any,\n): val is UniformColorDiffProcessor<T> {\n  return val && val.colorPicking;\n}\n\n/**\n * This manages mouse gestures broadcast to the layer and handles appropriate actions such as determining\n * how to make the interaction translate to picking events for the layer's instances.\n *\n * This class, in summary, takes in the gestures to the view and converts them to gestures to the instances.\n */\nexport class LayerInteractionHandler<\n  T extends Instance,\n  U extends ILayerProps<T>\n> {\n  /** This is the color picking information most recently rendered */\n  colorPicking?: IColorPickingData;\n  /** This tracks the elements that have the mouse currently over them */\n  isMouseOver = new Map<T, boolean>();\n  /** This tracks the elements the mouse was down on */\n  isMouseDown = new Map<T, boolean>();\n  /** This is the layer the interaction handler manages events for */\n  layer: Layer<T, U>;\n\n  constructor(layer: Layer<T, U>) {\n    this.layer = layer;\n  }\n\n  /**\n   * Retrieves the color picking instance determined for the procedure.\n   */\n  getColorPickInstance() {\n    if (\n      this.colorPicking &&\n      isColorProcessor<T>(this.layer.diffManager.processor)\n    ) {\n      return this.layer.diffManager.processor.colorPicking.uidToInstance.get(\n        0xffffff - this.colorPicking.nearestColor,\n      );\n    }\n\n    return null;\n  }\n\n  /**\n   * Handles mouse down gestures for a layer within a view\n   */\n  handleMouseOver(view: IProjection, mouse: IPoint) {\n    // This is the mouse over for the view itself. We should probably just let the mouse move events handle the interactions\n    // With the instances\n  }\n\n  /**\n   * Handles mouse down gestures for a layer within a view\n   */\n  handleMouseDown(view: IProjection, mouse: IPoint, button: number) {\n    // This handles interactions for PickType ALL layers\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      const { onMouseDown } = this.layer.props;\n\n      // If we have a listener for either event we should continue to process the event in more detail\n      if (onMouseDown) {\n        const world = view.viewToWorld(mouse);\n        let hitTest: InstanceHitTest<T>;\n        let query: TrackedQuadTree<T>['query'];\n        let querySpace;\n        let instances: T[] = [];\n\n        if (this.layer.picking.type === PickType.ALL) {\n          hitTest = this.layer.picking.hitTest;\n          query = this.layer.picking.quadTree.query.bind(\n            this.layer.picking.quadTree,\n          );\n          querySpace = (check: Bounds | IPoint) =>\n            query(check).filter(o => hitTest(o, world, view));\n          instances = query(world).filter(o => hitTest(o, world, view));\n        } else if (this.layer.picking.type === PickType.SINGLE) {\n          // Get the instance for the nearest color\n          const instanceForColor = this.getColorPickInstance();\n\n          if (instanceForColor) {\n            instances.push(instanceForColor);\n          }\n        }\n\n        const info: IPickInfo<T> = {\n          button,\n          instances,\n          layer: this.layer.id,\n          projection: view,\n          querySpace,\n          screen: [mouse.x, mouse.y],\n          world: [world.x, world.y],\n        };\n\n        onMouseDown(info);\n\n        // We track all the elements the mouse is currently down on\n        this.isMouseDown.clear();\n        instances.forEach(o => this.isMouseDown.set(o, true));\n      }\n    }\n  }\n\n  /**\n   * Handles mouse out events for a layer within the view\n   */\n  handleMouseOut(view: IProjection, mouse: IPoint) {\n    // This will fire an instance mouse out for any over instances in the queue since we left the view\n    // Thus no instances shall be considered 'over'\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      const { onMouseOut } = this.layer.props;\n\n      if (onMouseOut) {\n        const world = view.viewToWorld(mouse);\n        let hitTest: InstanceHitTest<T>;\n        let query: TrackedQuadTree<T>['query'];\n        let querySpace;\n\n        if (this.layer.picking.type === PickType.ALL) {\n          hitTest = this.layer.picking.hitTest;\n          query = this.layer.picking.quadTree.query.bind(\n            this.layer.picking.quadTree,\n          );\n          querySpace = (check: Bounds | IPoint) =>\n            query(check).filter(o => hitTest(o, world, view));\n        }\n\n        const info: IPickInfo<T> = {\n          instances: Array.from(this.isMouseOver.keys()),\n          layer: this.layer.id,\n          projection: view,\n          querySpace,\n          screen: [mouse.x, mouse.y],\n          world: [world.x, world.y],\n        };\n\n        onMouseOut(info);\n      }\n    }\n\n    // We clear as no instances are over anymore\n    this.isMouseOver.clear();\n    // We also clear all down elements as the mouse is no longer in proper context for the instances\n    // But since the mouse was never actually released, we do not fire an up\n    this.isMouseDown.clear();\n  }\n\n  /**\n   * Handles mouse up gestures for the layer within the provided view\n   */\n  handleMouseUp(view: IProjection, mouse: IPoint, button: number) {\n    // This handles interactions for PickType ALL layers\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      const { onMouseUp } = this.layer.props;\n\n      // If we have a listener for either event we should continue to process the event in more detail\n      if (onMouseUp) {\n        const world = view.viewToWorld(mouse);\n        let hitTest: InstanceHitTest<T>;\n        let query: TrackedQuadTree<T>['query'];\n        let querySpace;\n        let instances: T[] = [];\n\n        if (this.layer.picking.type === PickType.ALL) {\n          hitTest = this.layer.picking.hitTest;\n          query = this.layer.picking.quadTree.query.bind(\n            this.layer.picking.quadTree,\n          );\n          querySpace = (check: Bounds | IPoint) =>\n            query(check).filter(o => hitTest(o, world, view));\n          instances = query(world).filter(o => hitTest(o, world, view));\n        } else if (this.layer.picking.type === PickType.SINGLE) {\n          // Get the instance for the nearest color\n          const instanceForColor = this.getColorPickInstance();\n\n          if (instanceForColor) {\n            instances.push(instanceForColor);\n          }\n        }\n\n        const info: IPickInfo<T> = {\n          button,\n          instances,\n          layer: this.layer.id,\n          projection: view,\n          querySpace,\n          screen: [mouse.x, mouse.y],\n          world: [world.x, world.y],\n        };\n\n        onMouseUp(info);\n      }\n    }\n  }\n\n  /**\n   * Mouse move events on the layer will detect when instances have their item newly over or just moved on\n   */\n  handleMouseMove(view: IProjection, mouse: IPoint) {\n    // This handles interactions for PickType ALL layers\n    const { onMouseOver, onMouseMove, onMouseOut } = this.layer.props;\n\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      // If we have a listener for either event we should continue to process the event in more detail\n      if (onMouseOver || onMouseMove || onMouseOut) {\n        let info: IPickInfo<T>;\n        const world = view.viewToWorld(mouse);\n        let hitTest: InstanceHitTest<T>;\n        let query: TrackedQuadTree<T>['query'];\n        let querySpace;\n        let instances: T[] = [];\n\n        if (this.layer.picking.type === PickType.ALL) {\n          hitTest = this.layer.picking.hitTest;\n          query = this.layer.picking.quadTree.query.bind(\n            this.layer.picking.quadTree,\n          );\n          querySpace = (check: Bounds | IPoint) =>\n            query(check).filter(o => hitTest(o, world, view));\n          instances = query(world).filter(o => hitTest(o, world, view));\n        } else if (this.layer.picking.type === PickType.SINGLE) {\n          // Get the instance for the nearest color\n          const instanceForColor = this.getColorPickInstance();\n\n          if (instanceForColor) {\n            instances.push(instanceForColor);\n          }\n        }\n\n        // Broadcast the picking info for newly over instances to any of the layers listeners if needed\n        if (onMouseOver) {\n          const notOverInstances = instances.filter(\n            o => !this.isMouseOver.get(o),\n          );\n          info = {\n            instances: notOverInstances,\n            layer: this.layer.id,\n            projection: view,\n            querySpace,\n            screen: [mouse.x, mouse.y],\n            world: [world.x, world.y],\n          };\n\n          if (notOverInstances.length > 0) onMouseOver(info);\n        }\n\n        // Broadcast the the picking info for all instances that the mouse moved on\n        if (onMouseMove) {\n          // This is the pick info object we will broadcast from the layer\n          info = {\n            instances,\n            layer: this.layer.id,\n            projection: view,\n            querySpace,\n            screen: [mouse.x, mouse.y],\n            world: [world.x, world.y],\n          };\n\n          onMouseMove(info);\n        }\n\n        // We take the hovered instances\n        const isCurrentlyOver = new Map<T, boolean>();\n        instances.forEach(o => isCurrentlyOver.set(o, true));\n\n        // Broadcast the the picking info for all instances that the mouse moved off of\n        if (onMouseOut) {\n          const noLongerOver = Array.from(this.isMouseOver.keys()).filter(\n            o => !isCurrentlyOver.get(o),\n          );\n\n          // This is the pick info object we will broadcast from the layer\n          info = {\n            instances: noLongerOver,\n            layer: this.layer.id,\n            projection: view,\n            querySpace,\n            screen: [mouse.x, mouse.y],\n            world: [world.x, world.y],\n          };\n\n          if (noLongerOver.length > 0) onMouseOut(info);\n        }\n\n        // We store the current hovered over items as our over item list for next interaction\n        this.isMouseOver = isCurrentlyOver;\n      }\n    }\n  }\n\n  /**\n   * Handles click gestures on the layer within a view\n   */\n  handleMouseClick(view: IProjection, mouse: IPoint, button: number) {\n    // This handles interactions for PickType ALL layers\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      const { onMouseClick } = this.layer.props;\n\n      // If we have a listener for either event we should continue to process the event in more detail\n      if (onMouseClick) {\n        const world = view.viewToWorld(mouse);\n        let hitTest: InstanceHitTest<T>;\n        let query: TrackedQuadTree<T>['query'];\n        let querySpace;\n        let instances: T[] = [];\n\n        if (this.layer.picking.type === PickType.ALL) {\n          hitTest = this.layer.picking.hitTest;\n          query = this.layer.picking.quadTree.query.bind(\n            this.layer.picking.quadTree,\n          );\n          querySpace = (check: Bounds | IPoint) =>\n            query(check).filter(o => hitTest(o, world, view));\n          instances = query(world).filter(o => hitTest(o, world, view));\n        } else if (this.layer.picking.type === PickType.SINGLE) {\n          // Get the instance for the nearest color\n          const instanceForColor = this.getColorPickInstance();\n\n          if (instanceForColor) {\n            instances.push(instanceForColor);\n          }\n        }\n\n        const info: IPickInfo<T> = {\n          button,\n          instances,\n          layer: this.layer.id,\n          projection: view,\n          querySpace,\n          screen: [mouse.x, mouse.y],\n          world: [world.x, world.y],\n        };\n\n        onMouseClick(info);\n      }\n    }\n  }\n\n  /**\n   * Handles drag gestures for the layer within the view\n   */\n  handleMouseDrag(view: IProjection, mouse: IPoint) {\n    // We probably should not broadcast drag events for the sake of instances. Instance dragging should be handled on\n    // An instance by instance basis rather than coming from the view's gestures\n  }\n}\n","import { Instance } from '../../../instance-provider';\nimport { IQuadTreePickingMetrics, PickType } from '../../../types';\nimport {\n  BufferManagerBase,\n  IBufferLocation,\n  isBufferLocation,\n} from '../buffer-manager-base';\nimport { IInstanceDiffManagerTarget } from '../instance-diff-manager';\nimport { IUniformBufferLocation } from '../uniform-buffer-manager';\nimport { UniformDiffProcessor } from './uniform-diff-processor';\n\nconst EMPTY: number[] = [];\n\n/**\n * Manages diffs for layers that are utilizing the base uniform instancing buffer strategy.\n */\nexport class UniformQuadDiffProcessor<\n  T extends Instance\n> extends UniformDiffProcessor<T> {\n  quadPicking: IQuadTreePickingMetrics<T>;\n\n  constructor(\n    layer: IInstanceDiffManagerTarget<T>,\n    bufferManager: BufferManagerBase<T, IBufferLocation>,\n  ) {\n    super(layer, bufferManager);\n\n    if (layer.picking.type === PickType.ALL) {\n      this.quadPicking = layer.picking;\n    } else {\n      console.warn(\n        'Diff Processing Error: A layer has a diff processor requesting Quad Processing but the picking type is not valid.',\n      );\n    }\n  }\n\n  /**\n   * This processes add operations from changes in the instancing data and manages the layer's quad tree\n   * with the instance as well.\n   */\n  addInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster?: IUniformBufferLocation,\n  ) {\n    // If the uniform cluster already exists, then we swap over to a change update\n    if (uniformCluster) {\n      manager.changeInstance(manager, instance, EMPTY, uniformCluster);\n    }\n\n    // Otherwise, we DO need to perform an add and we link a Uniform cluster to our instance\n    else {\n      const uniforms = manager.layer.bufferManager.add(instance);\n\n      if (isBufferLocation(uniforms)) {\n        instance.active = true;\n        manager.updateInstance(manager.layer, instance, uniforms);\n\n        // Ensure the instance has an updated injection in the quad tree\n        manager.quadPicking.quadTree.remove(instance);\n        manager.quadPicking.quadTree.add(instance);\n      }\n    }\n  }\n\n  /**\n   * This processes change operations from changes in the instancing data\n   */\n  changeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster?: IUniformBufferLocation,\n  ) {\n    // If there is an existing uniform cluster for this instance, then we can update the uniforms\n    if (uniformCluster) {\n      manager.updateInstance(manager.layer, instance, uniformCluster);\n\n      // Ensure the instance has an updated injection in the quad tree\n      manager.quadPicking.quadTree.remove(instance);\n      manager.quadPicking.quadTree.add(instance);\n    }\n\n    // If we don't have existing uniforms, then we must remove the instance\n    else {\n      manager.addInstance(manager, instance, EMPTY, uniformCluster);\n    }\n  }\n\n  /**\n   * This processes remove operations from changes in the instancing data\n   */\n  removeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster?: IUniformBufferLocation,\n  ) {\n    if (uniformCluster) {\n      // We deactivate the instance so it does not render anymore\n      instance.active = false;\n      // We do one last update on the instance to update to it's deactivated state\n      manager.updateInstance(manager.layer, instance, uniformCluster);\n      // Unlink the instance from the uniform cluster\n      manager.layer.bufferManager.remove(instance);\n      // Remove the instance from our quad tree\n      manager.quadPicking.quadTree.remove(instance);\n    }\n  }\n}\n","import { Instance } from '../../../instance-provider';\nimport { ISinglePickingMetrics, PickType } from '../../../types';\nimport {\n  BufferManagerBase,\n  IBufferLocation,\n  isBufferLocation,\n} from '../buffer-manager-base';\nimport { IInstanceDiffManagerTarget } from '../instance-diff-manager';\nimport { IUniformBufferLocation } from '../uniform-buffer-manager';\nimport { UniformDiffProcessor } from './uniform-diff-processor';\n\nconst EMPTY: number[] = [];\n\n/**\n * Manages diffs for layers that are utilizing the base uniform instancing buffer strategy.\n */\nexport class UniformColorDiffProcessor<\n  T extends Instance\n> extends UniformDiffProcessor<T> {\n  colorPicking: ISinglePickingMetrics<T>;\n\n  constructor(\n    layer: IInstanceDiffManagerTarget<T>,\n    bufferManager: BufferManagerBase<T, IBufferLocation>,\n  ) {\n    super(layer, bufferManager);\n\n    if (layer.picking.type === PickType.SINGLE) {\n      this.colorPicking = layer.picking;\n      this.colorPicking.uidToInstance = new Map<number, T>();\n    } else {\n      console.warn(\n        'Diff Processing Error: A layer has a diff processor requesting Color Processing but the picking type is not valid.',\n      );\n    }\n  }\n\n  /**\n   * This processes add operations from changes in the instancing data and manages the layer's matching of\n   * color / UID to Instance\n   */\n  addInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster: IUniformBufferLocation,\n  ) {\n    // If the uniform cluster already exists, then we swap over to a change update\n    if (uniformCluster) {\n      manager.changeInstance(manager, instance, EMPTY, uniformCluster);\n    }\n\n    // Otherwise, we DO need to perform an add and we link a Uniform cluster to our instance\n    else {\n      const uniforms = manager.layer.bufferManager.add(instance);\n\n      if (isBufferLocation(uniforms)) {\n        instance.active = true;\n        manager.updateInstance(manager.layer, instance, uniforms);\n\n        // Make sure the instance is mapped to it's UID\n        manager.colorPicking.uidToInstance.set(instance.uid, instance);\n      } else {\n        console.warn(\n          'A data cluster was not provided by the manager to associate an instance with.',\n        );\n      }\n    }\n  }\n\n  /**\n   * This processes change operations from changes in the instancing data\n   */\n  changeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster: IUniformBufferLocation,\n  ) {\n    // If there is an existing uniform cluster for this instance, then we can update the uniforms\n    if (uniformCluster) {\n      manager.updateInstance(manager.layer, instance, uniformCluster);\n    }\n\n    // If we don't have existing uniforms, then we must remove the instance\n    else {\n      manager.addInstance(manager, instance, EMPTY, uniformCluster);\n    }\n  }\n\n  /**\n   * This processes remove operations from changes in the instancing data\n   */\n  removeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster: IUniformBufferLocation,\n  ) {\n    if (uniformCluster) {\n      // We deactivate the instance so it does not render anymore\n      instance.active = false;\n      // We do one last update on the instance to update to it's deactivated state\n      manager.updateInstance(manager.layer, instance, uniformCluster);\n      // Unlink the instance from the uniform cluster\n      manager.layer.bufferManager.remove(instance);\n      // Remove the instance from our quad tree\n      manager.colorPicking.uidToInstance.delete(instance.uid);\n    }\n  }\n}\n","import { Instance } from '../../../instance-provider/instance';\nimport { InstanceDiff } from '../../../instance-provider/instance-provider';\nimport { IInstanceAttributeInternal } from '../../../types';\nimport { Vec } from '../../../util';\nimport {\n  IBufferLocation,\n  IBufferLocationGroup,\n  isBufferLocationGroup,\n} from '../buffer-manager-base';\nimport { IInstanceAttributeBufferLocationGroup } from '../instance-attribute-buffer-manager';\nimport { IInstanceDiffManagerTarget } from '../instance-diff-manager';\nimport { BaseDiffProcessor } from './base-diff-processor';\n\nconst EMPTY: number[] = [];\nconst { min, max } = Math;\n\nenum DiffMode {\n  /** This mode will analyze incoming buffer location changes and only update the range of changed buffer */\n  PARTIAL,\n  /** This mode will not spend time figuring out what has changed for a buffer, rather the whole buffer will get an update */\n  FULL,\n}\n\n/**\n * Manages diffs for layers that are utilizing the base uniform instancing buffer strategy.\n */\nexport class InstanceAttributeDiffProcessor<\n  T extends Instance\n> extends BaseDiffProcessor<T> {\n  /** This is the processor's current diff mode for consuming instance updates. */\n  private diffMode: DiffMode = DiffMode.PARTIAL;\n\n  /** This tracks a buffer attribute's uid to the range of data that it should update */\n  bufferAttributeUpdateRange: {\n    [key: number]: [IInstanceAttributeInternal<T>, number, number];\n  } = {};\n\n  /** This tracks a buffer attribute's uid that will perform a complete update */\n  bufferAttributeWillUpdate: {\n    [key: number]: IInstanceAttributeInternal<T>,\n  } = {};\n\n  /**\n   * The instance updating is a property instead of a method as we will want to be able to gear shift it for varying levels\n   * of adjustments.\n   */\n  updateInstance: (\n    layer: IInstanceDiffManagerTarget<T>,\n    instance: T,\n    propIds: number[],\n    bufferLocations: IBufferLocationGroup<IBufferLocation>,\n  ) => void = this.updateInstancePartial;\n\n  /**\n   * This processes add operations from changes in the instancing data\n   */\n  addInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    bufferLocations?: IInstanceAttributeBufferLocationGroup,\n  ) {\n    // If the uniform cluster already exists, then we swap over to a change update\n    if (bufferLocations) {\n      manager.changeInstance(manager, instance, EMPTY, bufferLocations);\n    }\n\n    // Otherwise, we DO need to perform an add and we link a Uniform cluster to our instance\n    else {\n      const newBufferLocations = manager.layer.bufferManager.add(instance);\n\n      if (isBufferLocationGroup(newBufferLocations)) {\n        instance.active = true;\n        manager.updateInstance(\n          manager.layer,\n          instance,\n          EMPTY,\n          newBufferLocations,\n        );\n      }\n    }\n  }\n\n  /**\n   * This processes change operations from changes in the instancing data\n   */\n  changeInstance(\n    manager: this,\n    instance: T,\n    propIds: number[],\n    bufferLocations?: IInstanceAttributeBufferLocationGroup,\n  ) {\n    // If there is an existing uniform cluster for this instance, then we can update the bufferLocations\n    if (bufferLocations) {\n      manager.updateInstance(manager.layer, instance, propIds, bufferLocations);\n    }\n\n    // If we don't have existing bufferLocations, then we must remove the instance\n    else {\n      manager.addInstance(manager, instance, EMPTY, bufferLocations);\n    }\n  }\n\n  /**\n   * This processes remove operations from changes in the instancing data\n   */\n  removeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    bufferLocations?: IInstanceAttributeBufferLocationGroup,\n  ) {\n    if (bufferLocations) {\n      // We deactivate the instance so it does not render anymore\n      instance.active = false;\n      // We do one last update on the instance to update to it's deactivated state\n      manager.updateInstance(manager.layer, instance, EMPTY, bufferLocations);\n      // Unlink the instance from the uniform cluster\n      manager.layer.bufferManager.remove(instance);\n    }\n  }\n\n  /**\n   * This performs the actual updating of buffers the instance needs to update\n   */\n  updateInstancePartial(\n    layer: IInstanceDiffManagerTarget<T>,\n    instance: T,\n    propIds: number[],\n    bufferLocations: IBufferLocationGroup<IBufferLocation>,\n  ) {\n    const propertyToLocation = bufferLocations.propertyToBufferLocation;\n    const bufferAttributeUpdateRange = this.bufferAttributeUpdateRange;\n    let location: IBufferLocation;\n    let updateValue: Vec;\n    let updateRange;\n    let childLocations: IBufferLocation[];\n    let attribute: IInstanceAttributeInternal<T>;\n\n    if (instance.active) {\n      // If no prop ids provided, then we perform a complete instance property update\n      if (propIds.length === 0) {\n        propIds = this.bufferManager.getUpdateAllPropertyIdList();\n      }\n\n      for (let i = 0, end = propIds.length; i < end; ++i) {\n        // First update for the instance attribute itself\n        location = propertyToLocation[propIds[i]];\n        attribute = location.attribute;\n        attribute.atlas && layer.resource.setTargetAtlas(attribute.atlas.key);\n        updateValue = attribute.update(instance);\n        location.buffer.value.set(updateValue, location.range[0]);\n        updateRange = bufferAttributeUpdateRange[attribute.uid] || [\n          null,\n          Number.MAX_SAFE_INTEGER,\n          Number.MIN_SAFE_INTEGER,\n        ];\n        updateRange[0] = attribute;\n        updateRange[1] = min(location.range[0], updateRange[1]);\n        updateRange[2] = max(location.range[1], updateRange[2]);\n        bufferAttributeUpdateRange[attribute.uid] = updateRange;\n\n        // Now update any child attributes that would need updating based on the parent attribute changing\n        if (location.childLocations) {\n          childLocations = location.childLocations;\n\n          for (let k = 0, endk = childLocations.length; k < endk; ++k) {\n            location = childLocations[k];\n            updateValue = location.attribute.update(instance);\n            location.buffer.value.set(updateValue, location.range[0]);\n            updateRange = bufferAttributeUpdateRange[\n              location.attribute.uid\n            ] || [null, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER];\n            updateRange[0] = location.attribute;\n            updateRange[1] = min(location.range[0], updateRange[1]);\n            updateRange[2] = max(location.range[1], updateRange[2]);\n            bufferAttributeUpdateRange[location.attribute.uid] = updateRange;\n          }\n        }\n      }\n    }\n\n    // When the instance is inactive all we update is the active attribute to false\n    else {\n      location =\n        propertyToLocation[this.bufferManager.getActiveAttributePropertyId()];\n      attribute = location.attribute;\n      updateValue = attribute.update(instance);\n      location.buffer.value.set(updateValue, location.range[0]);\n      updateRange = bufferAttributeUpdateRange[attribute.uid] || [\n        null,\n        Number.MAX_SAFE_INTEGER,\n        Number.MIN_SAFE_INTEGER,\n      ];\n      updateRange[0] = attribute;\n      updateRange[1] = min(location.range[0], updateRange[1]);\n      updateRange[2] = max(location.range[1], updateRange[2]);\n      bufferAttributeUpdateRange[attribute.uid] = updateRange;\n    }\n  }\n\n  /**\n   * This performs an update on the buffers with the intent the entire buffer is going to update\n   * rather than a chunk of it.\n   */\n  updateInstanceFull(\n    layer: IInstanceDiffManagerTarget<T>,\n    instance: T,\n    propIds: number[],\n    bufferLocations: IBufferLocationGroup<IBufferLocation>,\n  ) {\n    const propertyToLocation = bufferLocations.propertyToBufferLocation;\n    const bufferAttributeWillUpdate = this.bufferAttributeWillUpdate;\n    let location: IBufferLocation;\n    let updateValue: Vec;\n    let childLocations: IBufferLocation[];\n    let attribute: IInstanceAttributeInternal<T>;\n\n    if (instance.active) {\n      // If no prop ids provided, then we perform a complete instance property update\n      if (propIds.length === 0) {\n        propIds = this.bufferManager.getUpdateAllPropertyIdList();\n      }\n\n      for (let i = 0, end = propIds.length; i < end; ++i) {\n        // First update for the instance attribute itself\n        location = propertyToLocation[propIds[i]];\n        attribute = location.attribute;\n        attribute.atlas && layer.resource.setTargetAtlas(attribute.atlas.key);\n        updateValue = attribute.update(instance);\n        location.buffer.value.set(updateValue, location.range[0]);\n        bufferAttributeWillUpdate[attribute.uid] = attribute;\n\n        // Now update any child attributes that would need updating based on the parent attribute changing\n        if (location.childLocations) {\n          childLocations = location.childLocations;\n\n          for (let k = 0, endk = childLocations.length; k < endk; ++k) {\n            location = childLocations[k];\n            attribute = location.attribute;\n            updateValue = attribute.update(instance);\n            location.buffer.value.set(updateValue, location.range[0]);\n            bufferAttributeWillUpdate[attribute.uid] = attribute;\n          }\n        }\n      }\n    }\n\n    // When the instance is inactive all we update is the active attribute to false\n    else {\n      location =\n        propertyToLocation[this.bufferManager.getActiveAttributePropertyId()];\n      attribute = location.attribute;\n      attribute.atlas && layer.resource.setTargetAtlas(attribute.atlas.key);\n      updateValue = attribute.update(instance);\n      location.buffer.value.set(updateValue, location.range[0]);\n      bufferAttributeWillUpdate[attribute.uid] = attribute;\n    }\n  }\n\n  /**\n   * Finalize all of the buffer changes and apply the correct update ranges\n   */\n  commit() {\n    // If we're in a partial mode: just update the portion of the buffer that needs updating.\n    if (this.diffMode === DiffMode.PARTIAL) {\n      // We now grab all of the attributes and set their update ranges\n      const updates = Object.values(this.bufferAttributeUpdateRange);\n\n      for (let i = 0, end = updates.length; i < end; ++i) {\n        const update = updates[i];\n        const attribute = update[0].bufferAttribute;\n        attribute.needsUpdate = true;\n        attribute.updateRange = {\n          count: update[2] - update[1],\n          offset: update[1],\n        };\n      }\n    }\n\n    // Otherwise just update the full buffer\n    else {\n      // We now grab all of the attributes and set their update ranges\n      const updates = Object.values(this.bufferAttributeWillUpdate);\n\n      for (let i = 0, end = updates.length; i < end; ++i) {\n        const attribute = updates[i].bufferAttribute;\n        attribute.needsUpdate = true;\n        attribute.updateRange = {\n          count: -1,\n          offset: 0,\n        };\n      }\n    }\n\n    // Clear the attribute update metrics\n    this.bufferAttributeUpdateRange = {};\n  }\n\n  /**\n   * This will optimize the update method used. If there are enough instances being updated, we will\n   * cause the entire attribute buffer to update. If there are not enough, then we will update with\n   * additional steps to\n   */\n  incomingChangeList(changes: InstanceDiff<T>[]) {\n    if (changes.length === 0) {\n      this.diffMode = DiffMode.PARTIAL;\n    }\n\n    else if (changes.length > this.bufferManager.getInstanceCount() * 0.7) {\n      this.diffMode = DiffMode.FULL;\n    }\n\n    else {\n      this.diffMode = DiffMode.PARTIAL;\n    }\n\n    if (this.diffMode === DiffMode.PARTIAL) {\n      this.updateInstance = this.updateInstancePartial;\n    }\n\n    else {\n      this.updateInstance = this.updateInstanceFull;\n    }\n  }\n}\n","import * as Three from 'three';\nimport { Instance } from '../../instance-provider';\nimport { makeInstanceUniformNameArray } from '../../shaders/util/make-instance-uniform-name';\nimport { IInstanceAttribute, PickType } from '../../types';\nimport { uid, Vec2 } from '../../util';\nimport { Layer } from '../layer';\nimport { generateLayerModel } from '../layer-processing/generate-layer-model';\nimport { Scene } from '../scene';\nimport { BufferManagerBase, IBufferLocation } from './buffer-manager-base';\n\nexport interface IUniformBufferLocation extends IBufferLocation {\n  /** This is the index of the instance as it appears in the buffer */\n  instanceIndex: number;\n  /** This is the instance data uniform */\n  buffer: Three.IUniform;\n  /** This is the instance data range within the instanceData uniform */\n  range: Vec2;\n}\n\nexport interface InstanceUniformBuffer {\n  /** This tracks which instances are active. Helps optimize draw range */\n  activeInstances: boolean[];\n  /** This is all of the clusters within this buffer */\n  clusters: IUniformBufferLocation[];\n  /** The first instance in the draw range */\n  firstInstance: number;\n  /** The unique geometry object for the buffer: Used to set draw range */\n  geometry: Three.BufferGeometry;\n  /** The last instance in the draw range */\n  lastInstance: number;\n  /** The unique material for the buffer: Used to provide a new set of uniforms */\n  material: Three.ShaderMaterial;\n  /** The unique model generated for the buffer: Used to allow the buffer to be rendered by adding to a scene */\n  model: Three.Object3D;\n  /** Threejs can not have duplicate objects across Scenes */\n  pickModel?: Three.Object3D;\n}\n\n/**\n * This is a Buffer Management system that performs instancing via the uniforms available to the hardware.\n * This improves compatibility with instancing for systems DRAMATICALLY as ALL systems WILL support uniforms.\n * This will NOT perform the best against true hardware instancing support, but it will have edge cases where it\n * is needed.\n *\n * When a layer has too many instance + vertex attributes for the hardware, the system will defer to this buffer methodology.\n *\n * This class does a whoooooole lot of making the magical instancing optimization controls possible.\n *\n * Our instancing hackyness comes from the idea that uniforms are fast, and you don't have to commit\n * ALL of them when you touch just a little piece, and you don't have worry about drivers not supporting\n * partial vertex buffer updates.\n *\n * This also is WebGL 1.0 compatible without any extensions that are poorly implemented. And again: does\n * NOT require entire attribute buffer commits.\n *\n * Uniforms are limited for any given draw call. So we have to create multiple materials to support\n * chunks of the instances that need to be drawn. We then have to associate an instance with the set\n * of uniforms that is related to the instance and keep them paired together. If we have too many instances\n * we must generate more buffers to accomodate them.\n *\n * If we remove instances, we must free up the uniform set so that others can use the uniforms. While the uniforms\n * are not in use, the instance should not be rendering.\n */\nexport class UniformBufferManager<T extends Instance> extends BufferManagerBase<\n  T,\n  IUniformBufferLocation\n> {\n  /** The number of uniform blocks an instance requires */\n  private uniformBlocksPerInstance: number;\n  /** The generated buffers by this manager */\n  private buffers: InstanceUniformBuffer[] = [];\n  /** The uniform clusters that are free and can be used by an instance */\n  private availableClusters: IUniformBufferLocation[] = [];\n  /** A lookup of an instance to a cluster of uniforms associated with it */\n  private instanceToCluster: { [key: number]: IUniformBufferLocation } = {};\n  /** A map of a cluster of uniforms to the buffer it comes from */\n  private clusterToBuffer = new Map<\n    IUniformBufferLocation,\n    InstanceUniformBuffer\n  >();\n\n  constructor(layer: Layer<T, any>, scene: Scene) {\n    super(layer, scene);\n\n    let maxUniformBlock: number = 0;\n    layer.instanceAttributes.forEach((attributes: IInstanceAttribute<T>) => {\n      maxUniformBlock = Math.max(attributes.block, maxUniformBlock);\n    });\n\n    this.uniformBlocksPerInstance = maxUniformBlock + 1;\n  }\n\n  /**\n   * This adds an instance to the manager and gives the instance an associative\n   * block of uniforms to work with.\n   */\n  add = function(instance: T) {\n    // If there are no available buffers, we must add a buffer\n    if (this.availableClusters.length <= 0) {\n      this.makeNewBuffer();\n    }\n\n    const cluster = this.availableClusters.pop();\n\n    if (cluster) {\n      this.instanceToCluster[instance.uid] = cluster;\n    } else {\n      console.warn(\n        'No valid cluster available for instance added to uniform manager.',\n      );\n    }\n\n    return cluster;\n  };\n\n  /**\n   * Free all resources this manager may be holding onto\n   */\n  destroy() {\n    this.buffers.forEach(buffer => {\n      buffer.geometry.dispose();\n      buffer.material.dispose();\n    });\n  }\n\n  /**\n   * This retireves the uniforms associated with an instance, or returns nothing\n   * if the instance has not been associated yet.\n   */\n  getBufferLocations(instance: T) {\n    return this.instanceToCluster[instance.uid];\n  }\n\n  /**\n   * TODO: The uniform buffer does not need to utilize this yet. it will be more necessary\n   * when this manager updates only changed properties.\n   */\n  getActiveAttributePropertyId() {\n    return -1;\n  }\n\n  /**\n   * TODO: This is irrelevant tot his manager for now.\n   * Number of instances this buffer manages.\n   */\n  getInstanceCount() {\n    return -1;\n  }\n\n  /**\n   * TODO: The uniform buffer updates ALL attributes every change for any property so far.\n   * This should be fixed for performance improvements on the compatibility mode.\n   */\n  getUpdateAllPropertyIdList() {\n    return [];\n  }\n\n  /**\n   * Disassociates an instance with it's group of uniforms and makes the instance\n   * in the buffer no longer drawable.\n   */\n  remove = function(instance: T) {\n    const cluster = this.instanceToCluster[instance.uid];\n\n    // If the instance is associated with a cluster, we can add the cluster back to being available\n    // For another instance.\n    if (cluster) {\n      delete this.instanceToCluster[instance.uid];\n      this.availableClusters.push(cluster);\n    }\n\n    return instance;\n  };\n\n  /**\n   * Clears all elements of this manager from the current scene it was in.\n   */\n  removeFromScene() {\n    this.buffers.forEach((buffer, index) => {\n      this.scene.container.remove(buffer.model);\n      buffer.pickModel && this.scene.pickingContainer.remove(buffer.pickModel);\n    });\n\n    delete this.scene;\n  }\n\n  /**\n   * Applies the buffers to the provided scene for rendering.\n   */\n  setScene(scene: Scene) {\n    this.buffers.forEach((buffer, index) => {\n      this.scene.container.add(buffer.model);\n      buffer.pickModel && this.scene.pickingContainer.add(buffer.pickModel);\n    });\n\n    this.scene = scene;\n  }\n\n  /**\n   * This generates a new buffer of uniforms to associate instances with.\n   */\n  makeNewBuffer() {\n    // We generate a new geometry object for the buffer as the geometry\n    // Needs to have it's own unique draw range per buffer for optimal\n    // Performance\n    const newGeometry = new Three.BufferGeometry();\n    this.layer.vertexAttributes.forEach(attribute => {\n      if (attribute.materialAttribute) {\n        newGeometry.addAttribute(attribute.name, attribute.materialAttribute);\n      }\n    });\n\n    // Ensure the draw range covers every instance in the geometry.\n    newGeometry.drawRange.start = 0;\n    newGeometry.drawRange.count =\n      this.layer.maxInstancesPerBuffer * this.layer.instanceVertexCount;\n\n    // This is the material that is generated for the layer that utilizes all of the generated and\n    // Injected shader IO and shader fragments\n    const newMaterial = this.layer.material.clone();\n    // Now make a Model for the buffer so it can be rendered withn the scene\n    const newModel = generateLayerModel(this.layer, newGeometry, newMaterial);\n    // We render junkloads of instances in a buffer. Culling will have to happen\n    // On an instance level.\n    newModel.frustumCulled = false;\n\n    // Make our new buffer which will manage the geometry and everything necessary\n    const buffer: InstanceUniformBuffer = {\n      activeInstances: [],\n      clusters: [],\n      firstInstance: 0,\n      geometry: newGeometry,\n      lastInstance: 0,\n      material: newMaterial,\n      model: newModel,\n      pickModel:\n        this.layer.picking.type === PickType.SINGLE\n          ? newModel.clone()\n          : undefined,\n    };\n\n    this.buffers.push(buffer);\n\n    // Now that we have created a new buffer, we have all of it's uniforms\n    // To use to render more instances. We must take the instancing uniforms\n    // And divvy them up into clusters for our available buffer.\n    let uniformIndex = 0;\n    const uniformName = makeInstanceUniformNameArray();\n    const instanceData = newMaterial.uniforms[uniformName];\n\n    // We must ensure the vector objects are TOTALLY unique otherwise they'll get shared across buffers\n    instanceData.value = instanceData.value.map(\n      () => new Three.Vector4(0.0, 0.0, 0.0, 0.0),\n    );\n\n    // TODO: This will go away! To satisfy the changing buffer manager interfaces, we make a\n    // fake internal attribute for now\n    const fakeAttribute = Object.assign({}, this.layer.instanceAttributes[0], {\n      bufferAttribute: new Three.InstancedBufferAttribute(\n        new Float32Array(1),\n        1,\n      ),\n      uid: uid(),\n    });\n\n    for (let i = 0, end = this.layer.maxInstancesPerBuffer; i < end; ++i) {\n      const cluster: IUniformBufferLocation = {\n        attribute: fakeAttribute, // TODO: This is not needed for the uniform method yet. When we break down\n        // the uniform updates into attributes, this will be utilized.\n        buffer: instanceData,\n        instanceIndex: i,\n        range: [uniformIndex, 0],\n      };\n\n      uniformIndex += this.uniformBlocksPerInstance;\n      cluster.range[1] = uniformIndex;\n\n      buffer.clusters.push(cluster);\n      this.availableClusters.push(cluster);\n      this.clusterToBuffer.set(cluster, buffer);\n    }\n\n    // Grab the global uniforms from the material and add it to the uniform's materialUniform list so that\n    // We can keep uniforms consistent across all Instances\n    for (let i = 0, end = this.layer.uniforms.length; i < end; ++i) {\n      const uniform = this.layer.uniforms[i];\n      uniform.materialUniforms.push(newMaterial.uniforms[uniform.name]);\n    }\n\n    // Now that we are ready to utilize the buffer, let's add it to the scene so it may be rendered.\n    // Each new buffer equates to one draw call.\n    if (this.scene) {\n      this.scene.container.add(buffer.model);\n      buffer.pickModel && this.scene.pickingContainer.add(buffer.pickModel);\n    }\n  }\n}\n","let toEmit: { [key: string]: [Function, number, number] } = {};\n\nexport function emitOnce(\n  id: string,\n  callback: (calledCountBeforeEmit: number, id: string) => void,\n) {\n  const emit = toEmit[id] || [callback, -1, 0];\n  toEmit[id] = emit;\n  emit[2]++;\n\n  clearTimeout(emit[1]);\n  emit[1] = window.setTimeout(() => {\n    callback(emit[2], id);\n    delete toEmit[id];\n  }, 1);\n}\n\nexport function flushEmitOnce() {\n  for (const id in toEmit) {\n    const emit = toEmit[id];\n    clearTimeout(emit[1]);\n    emit[0](emit[2], id);\n  }\n\n  toEmit = {};\n}\n","import * as Three from 'three';\nimport { Instance, ObservableMonitoring } from '../../instance-provider';\nimport { instanceAttributeShaderName } from '../../shaders/util/instance-attribute-shader-name';\nimport {\n  IInstanceAttribute,\n  IInstanceAttributeInternal,\n  PickType,\n} from '../../types';\nimport { uid } from '../../util';\nimport { emitOnce, flushEmitOnce } from '../../util/emit-once';\nimport { IModelConstructable, Layer } from '../layer';\nimport { generateLayerModel } from '../layer-processing/generate-layer-model';\nimport { Scene } from '../scene';\nimport {\n  BufferManagerBase,\n  IBufferLocation,\n  IBufferLocationGroup,\n} from './buffer-manager-base';\n\nconst { max } = Math;\n\n/**\n * This represents the location of data for an instance's property to the piece of attribute buffer\n * it will update when it changes.\n */\nexport interface IInstanceAttributeBufferLocation extends IBufferLocation {}\n\n/** Represents the Location Groupings for Instance attribute Buffer locations */\nexport type IInstanceAttributeBufferLocationGroup = IBufferLocationGroup<\n  IInstanceAttributeBufferLocation\n>;\n\n/**\n * This manages instances in how they associate with buffer data for an instanced attribute strategy.\n */\nexport class InstanceAttributeBufferManager<\n  T extends Instance\n> extends BufferManagerBase<T, IInstanceAttributeBufferLocation> {\n  /** This stores an attribute's name to the buffer locations generated for it */\n  private allBufferLocations: { [key: string]: IBufferLocation[] } = {};\n  /** This contains the buffer locations the system will have available to the  */\n  private availableLocations: IInstanceAttributeBufferLocationGroup[] = [];\n  /** This is the number of instances the buffer draws currently */\n  currentInstancedCount = 0;\n  /** This is the mapped buffer location to the provided Instance */\n  private instanceToBufferLocation: {\n    [key: number]: IInstanceAttributeBufferLocationGroup;\n  } = {};\n  /**\n   * This is the number of times the buffer has grown. This is used to determine how much the buffer will grow\n   * for next growth pass.\n   */\n  private growthCount: number = 0;\n  /** This is the number of instances the buffer currently supports */\n  private maxInstancedCount: number = 1000;\n\n  // These are the only Three objects that must be monitored for disposal\n  private geometry: Three.InstancedBufferGeometry;\n  private material: Three.ShaderMaterial;\n  private model: IModelConstructable & Three.Object3D;\n  private pickModel: IModelConstructable & Three.Object3D | undefined;\n  private attributes: IInstanceAttributeInternal<T>[];\n\n  /** This is a mapping of all attributes to their associated property ids that, when the property changes, the attribute will be updated */\n  private attributeToPropertyIds = new Map<IInstanceAttribute<T>, number[]>();\n  /**\n   * This is a trimmed listing of minimum property ids needed to trigger an update on all properties.\n   * This is used by the diffing process mostly to handle adding a new instance.\n   */\n  private updateAllPropertyIdList: number[] = [];\n  /**\n   * This is the discovered property id of the active attribute for the instance type this manager manages.\n   * This is used by the diffing process to target updates related to deactivating an instance.\n   */\n  private activePropertyId: number = -1;\n\n  constructor(layer: Layer<T, any>, scene: Scene) {\n    super(layer, scene);\n    // Start our add method as a registration step.\n    this.add = this.doAddWithRegistration;\n  }\n\n  /**\n   * First instance to be added to this manager will be heavily analyzed for used observables per attribute.\n   */\n  private doAddWithRegistration(instance: T) {\n    // We need to find out how an instance interacts with the attributes, so we will\n    // loop through the instances, call their updates and get feedback\n    this.layer.instanceAttributes.forEach(attribute => {\n      // We don't need to register child attributes as they get updated as a consequence to parent attributes\n      if (attribute.parentAttribute) return;\n      // Activate monitoring of ids, this also resets the monitor's list\n      ObservableMonitoring.setObservableMonitor(true);\n      // Access the update which accesses an instances properties (usually)\n      attribute.update(instance);\n      // We now have all of the ids of the properties that were used in updating the attributes\n      const propertyIdsForAttribute = ObservableMonitoring.getObservableMonitorIds(\n        true,\n      );\n      // Store the mapping of the property ids\n      this.attributeToPropertyIds.set(attribute, propertyIdsForAttribute);\n\n      // If this is the active attribute, then we track the property id that modifies it\n      // for handling internal instance management.\n      if (attribute === this.layer.activeAttribute) {\n        this.activePropertyId = propertyIdsForAttribute[0];\n      }\n    });\n\n    // SUPER IMPORTANT to deactivate this here. Leaving this turned on causes memory to be chewed up\n    // for every property getter.\n    ObservableMonitoring.setObservableMonitor(false);\n    // This analyzes the properties and how they affect the attributes. It determines the smallest\n    // list possible of property ids needed to trigger an update on all of the attributes.\n    this.makeUpdateAllPropertyIdList();\n    // Do the first resize which creates the buffer and makes all of the initial buffer locations\n    const locationInfo = this.resizeBuffer();\n    // After all of the property id to attribute associations are made, we must break down the buffers\n    // into locations and then group those locations which will become our instance to buffer location\n    // slots\n    this.gatherLocationsIntoGroups(\n      locationInfo.newLocations,\n      locationInfo.growth,\n    );\n    // After the first registration add, we gear shift to a more efficient add method.\n    this.add = this.doAdd;\n\n    // Perform the add after all of the registration process is complete\n    return this.doAdd(instance);\n  }\n\n  /**\n   * After the registration add happens, we gear shift over to this add method which will only pair instances\n   * with their appropriate buffer location.\n   */\n  private doAdd(instance: T) {\n    // Ensure we have buffer locations available\n    if (this.availableLocations.length <= 0) {\n      // Resice the buffer to accommodate more instances\n      const locationInfo = this.resizeBuffer();\n      // Break down the newly generated buffers into property groupings for the instances\n      this.gatherLocationsIntoGroups(\n        locationInfo.newLocations,\n        locationInfo.growth,\n      );\n    }\n\n    // Get the next available location\n    const bufferLocations = this.availableLocations.shift();\n\n    // Pair up the instance with it's buffer location\n    if (bufferLocations) {\n      this.instanceToBufferLocation[instance.uid] = bufferLocations;\n      this.currentInstancedCount = this.geometry.maxInstancedCount = max(\n        this.currentInstancedCount,\n        // Instance index + 1 because the indices are zero indexed and the maxInstancedCount is a count value\n        bufferLocations.instanceIndex + 1,\n      );\n    } else {\n      console.error(\n        'Add Error: Instance Attribute Buffer Manager failed to pair an instance with a buffer location',\n      );\n    }\n\n    return bufferLocations;\n  }\n\n  destroy() {\n    this.geometry.dispose();\n    this.material.dispose();\n    if (this.scene && this.scene.container) {\n      this.scene.container.remove(this.model);\n    }\n  }\n\n  /**\n   * This retireves the buffer locations associated with an instance, or returns nothing\n   * if the instance has not been associated yet.\n   */\n  getBufferLocations(instance: T) {\n    return this.instanceToBufferLocation[instance.uid];\n  }\n\n  /**\n   * This is the property id of the active attribute.\n   */\n  getActiveAttributePropertyId() {\n    return this.activePropertyId;\n  }\n\n  /**\n   * This is the bare minimum property ids that, when triggered for update, will update ALL of the attribute buffers\n   * for the managed layer.\n   */\n  getUpdateAllPropertyIdList() {\n    return this.updateAllPropertyIdList;\n  }\n\n  /**\n   * Analyzes the list of attributes to the property ids that affects them. This populates the list\n   * of minimal property ids needed to trigger updates on all of the attributes.\n   */\n  private makeUpdateAllPropertyIdList() {\n    // Make a deduping list of ids\n    const updateAllPropertyIdList: { [key: number]: number } = {};\n\n    // Get unique ids that will target all attributes\n    this.attributeToPropertyIds.forEach(ids => {\n      updateAllPropertyIdList[ids[0]] = ids[0];\n    });\n\n    // Store the list for the diffing process to utilize\n    this.updateAllPropertyIdList = Object.values(\n      updateAllPropertyIdList,\n    ).filter(Boolean);\n  }\n\n  /**\n   * Disassociates an instance with a buffer\n   */\n  remove = (instance: T) => {\n    const location = this.instanceToBufferLocation[instance.uid];\n\n    if (location) {\n      delete this.instanceToBufferLocation[instance.uid];\n      this.availableLocations.push(location);\n    }\n\n    return instance;\n  }\n\n  /**\n   * Clears all elements of this manager from the current scene it was in.\n   */\n  removeFromScene() {\n    if (this.scene && this.scene.container) {\n      this.scene.container.remove(this.model);\n    }\n    this.pickModel && this.scene.pickingContainer.remove(this.pickModel);\n    delete this.scene;\n  }\n\n  /**\n   * This generates a new buffer of uniforms to associate instances with.\n   */\n  private resizeBuffer() {\n    let growth = 0;\n    // Each attribute will generate lists of new buffer locations after being created or expanded\n    const attributeToNewBufferLocations = new Map<\n      string,\n      IInstanceAttributeBufferLocation[]\n    >();\n\n    // If our geometry is not created yet, then it need be made\n    if (!this.geometry) {\n      // The buffer grows from 0 to our initial instance count\n      growth = this.maxInstancedCount;\n      // We generate a new geometry object for the buffer as the geometry\n      // Needs to have it's own unique draw range per buffer for optimal\n      // Performance.\n      this.geometry = new Three.InstancedBufferGeometry();\n\n      // The geometry needs the vertex information (which should be shared amongst all instances of the layer)\n      this.layer.vertexAttributes.forEach(attribute => {\n        if (attribute.materialAttribute) {\n          this.geometry.addAttribute(\n            attribute.name,\n            attribute.materialAttribute,\n          );\n        }\n      });\n\n      // We now take the instance attributes and add them as Instanced Attributes to our geometry\n      this.attributes = this.layer.instanceAttributes.map(attribute => {\n        // We start with enough data in the buffer to accommodate 1024 instances\n        const size: number = attribute.size || 0;\n        const buffer = new Float32Array(size * this.maxInstancedCount);\n        const bufferAttribute = new Three.InstancedBufferAttribute(\n          buffer,\n          size,\n        );\n        bufferAttribute.setDynamic(true);\n        this.geometry.addAttribute(\n          instanceAttributeShaderName(attribute),\n          bufferAttribute,\n        );\n        let newBufferLocations = attributeToNewBufferLocations.get(\n          attribute.name,\n        );\n\n        if (!newBufferLocations) {\n          newBufferLocations = [];\n          attributeToNewBufferLocations.set(attribute.name, newBufferLocations);\n        }\n\n        const allLocations = this.allBufferLocations[attribute.name] || [];\n        this.allBufferLocations[attribute.name] = allLocations;\n\n        const internalAttribute: IInstanceAttributeInternal<T> = Object.assign(\n          {},\n          attribute,\n          { uid: uid(), bufferAttribute: bufferAttribute },\n        );\n\n        for (let i = 0; i < this.maxInstancedCount; ++i) {\n          const newLocation: IBufferLocation = {\n            attribute: internalAttribute,\n            buffer: {\n              value: buffer,\n            },\n            instanceIndex: i,\n            range: [i * size, i * size + size],\n          };\n\n          newBufferLocations.push(newLocation);\n          allLocations.push(newLocation);\n        }\n\n        // Make an internal instance attribute for tracking\n        return internalAttribute;\n      });\n\n      // Ensure the draw range covers every instance in the geometry.\n      this.geometry.maxInstancedCount = 0;\n      // This is the material that is generated for the layer that utilizes all of the generated and\n      // Injected shader IO and shader fragments\n      this.material = this.layer.material.clone();\n\n      // Grab the global uniforms from the material and add it to the uniform's materialUniform list so that\n      // We can keep uniforms consistent across all Instances\n      for (let i = 0, end = this.layer.uniforms.length; i < end; ++i) {\n        const uniform = this.layer.uniforms[i];\n        uniform.materialUniforms.push(this.material.uniforms[uniform.name]);\n      }\n    }\n\n    // If the geometry is already created, then we will expand each instanced attribute to the next growth\n    // level and generate the new buffer locations based on the expansion\n    else {\n      // Since were are resizing the buffer, let's destroy the old buffer and make one anew\n      this.geometry.dispose();\n      this.geometry = new Three.InstancedBufferGeometry();\n      const previousInstanceAmount = this.maxInstancedCount;\n\n      // The geometry needs the vertex information (which should be shared amongst all instances of the layer)\n      this.layer.vertexAttributes.forEach(attribute => {\n        if (attribute.materialAttribute) {\n          this.geometry.addAttribute(\n            attribute.name,\n            attribute.materialAttribute,\n          );\n        }\n      });\n\n      // We grow our buffer by magnitudes of 10 * 1024\n      // First growth: 1000\n      // Next: 10000\n      // Next: 10000\n      // Next: 10000\n      // Next: 10000\n      // We cap at growth of 1 million to prevent a mass unused RAM void.\n      this.growthCount = Math.min(1, this.growthCount + 1);\n      growth = Math.pow(10, this.growthCount) * 1000;\n      this.maxInstancedCount += growth;\n\n      this.attributes.forEach(attribute => {\n        const bufferAttribute = attribute.bufferAttribute;\n        const size: number = attribute.size || 0;\n\n        if (bufferAttribute.array instanceof Float32Array) {\n          // Make a new buffer that is the proper size\n          const buffer: Float32Array = new Float32Array(\n            this.maxInstancedCount * size,\n          );\n          // Retain all of the information in the previous buffer\n          buffer.set(bufferAttribute.array, 0);\n          // Make our new attribute based on the grown buffer\n          const newAttribute = new Three.InstancedBufferAttribute(buffer, size);\n          // Set the attribute to dynamic so we can update ranges within it\n          newAttribute.setDynamic(true);\n          // Make sure our attribute is updated with the newly made attribute\n          attribute.bufferAttribute = newAttribute;\n          // Add the new attribute to our new geometry object\n          this.geometry.addAttribute(\n            instanceAttributeShaderName(attribute),\n            newAttribute,\n          );\n          // Get the temp storage for new buffer locations\n          let newBufferLocations = attributeToNewBufferLocations.get(\n            attribute.name,\n          );\n\n          // Since we have a new buffer object we are working with, we must update all of the existing buffer\n          // locations to utilize this new buffer. The locations keep everything else the same, but the buffer\n          // object itself should be updated\n          const allLocations = this.allBufferLocations[attribute.name] || [];\n          this.allBufferLocations[attribute.name] = allLocations;\n\n          for (let k = 0, endk = allLocations.length; k < endk; ++k) {\n            allLocations[k].buffer.value = buffer;\n          }\n\n          if (!newBufferLocations) {\n            newBufferLocations = [];\n            attributeToNewBufferLocations.set(\n              attribute.name,\n              newBufferLocations,\n            );\n          }\n\n          for (\n            let i = previousInstanceAmount, end = this.maxInstancedCount;\n            i < end;\n            ++i\n          ) {\n            const newLocation: IBufferLocation = {\n              attribute,\n              buffer: {\n                value: buffer,\n              },\n              instanceIndex: i,\n              range: [i * size, i * size + size],\n            };\n\n            newBufferLocations.push(newLocation);\n            allLocations.push(newLocation);\n          }\n        }\n      });\n\n      this.scene.container.remove(this.model);\n    }\n\n    if (this.scene && this.model) {\n      this.scene.container.remove(this.model);\n    }\n\n    // Remake the model with the generated geometry\n    this.model = generateLayerModel(this.layer, this.geometry, this.material);\n    // We render junkloads of instances for a given buffer. Culling will have to happen\n    // On an instance level.\n    this.model.frustumCulled = false;\n    // Make a picking model if we need it so we can render the model with a different uniform set\n    // for the picking procedure.\n    this.pickModel =\n      this.layer.picking.type === PickType.SINGLE\n        ? this.model.clone()\n        : undefined;\n\n    // Now that we are ready to utilize the buffer, let's add it to the scene so it may be rendered.\n    // Each new buffer equates to one draw call.\n    if (this.scene) {\n      this.scene.container.add(this.model);\n\n      if (this.pickModel) {\n        this.scene.pickingContainer.add(this.pickModel);\n      }\n    }\n\n    return {\n      growth,\n      newLocations: attributeToNewBufferLocations,\n    };\n  }\n\n  /**\n   * This takes newly created buffer locations and groups them by the property ids identified by the\n   * registration phase.\n   */\n  private gatherLocationsIntoGroups(\n    attributeToNewBufferLocations: Map<\n      string,\n      IInstanceAttributeBufferLocation[]\n    >,\n    totalNewInstances: number,\n  ) {\n    if (this.attributeToPropertyIds.size === 0) return;\n\n    // Optimize inner loops by pre-fetching lookups by names\n    const attributesBufferLocations: {\n      attribute: IInstanceAttribute<T>;\n      bufferLocationsForAttribute: IInstanceAttributeBufferLocation[];\n      childBufferLocations: IInstanceAttributeBufferLocation[][];\n      ids: number[];\n    }[] = [];\n\n    this.attributeToPropertyIds.forEach((ids, attribute) => {\n      attributesBufferLocations.push({\n        attribute,\n        bufferLocationsForAttribute:\n          attributeToNewBufferLocations.get(attribute.name) || [],\n        childBufferLocations: (attribute.childAttributes || []).map(\n          attr => attributeToNewBufferLocations.get(attr.name) || [],\n        ),\n        ids,\n      });\n    });\n\n    // Loop through all of the new instances available and gather all of the buffer locations\n    for (let i = 0; i < totalNewInstances; ++i) {\n      const group: IInstanceAttributeBufferLocationGroup = {\n        instanceIndex: -1,\n        propertyToBufferLocation: {},\n      };\n\n      // Loop through all of the property ids that affect specific attributes. Each of these ids\n      // needs an association with the buffer location they modify.\n      for (let j = 0, endj = attributesBufferLocations.length; j < endj; ++j) {\n        const allLocations = attributesBufferLocations[j];\n        const attribute = allLocations.attribute;\n        const ids = allLocations.ids;\n        const bufferLocationsForAttribute =\n          allLocations.bufferLocationsForAttribute;\n\n        if (!bufferLocationsForAttribute) {\n          emitOnce(\n            'Instance Attribute Buffer Error',\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: There is an error in forming buffer location groups in InstanceAttributeBufferManager. Error count: ${count}`,\n              );\n            },\n          );\n          continue;\n        }\n\n        const bufferLocation = bufferLocationsForAttribute.shift();\n\n        if (!bufferLocation) {\n          emitOnce(\n            'Instance Attribute Buffer Error',\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: There is an error in forming buffer location groups in InstanceAttributeBufferManager. Error count: ${count}`,\n              );\n            },\n          );\n          continue;\n        }\n\n        if (group.instanceIndex === -1) {\n          group.instanceIndex = bufferLocation.instanceIndex;\n        } else if (bufferLocation.instanceIndex !== group.instanceIndex) {\n          emitOnce(\n            'Instance Attribute Parallelism Error',\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: A buffer location does not have a matching instance index which means the buffer locations are not in parallel with each other somehow. Error count: ${count}`,\n              );\n              console.warn(attribute.name, bufferLocation);\n            },\n          );\n          continue;\n        }\n\n        // If the attribute has children attributes. Then when the attribute is updated, the child attributes should\n        // be updated as well. Thus the buffer location needs the child attribute buffer locations.\n        if (attribute.childAttributes) {\n          const childLocations = [];\n\n          for (\n            let k = 0, endk = attribute.childAttributes.length;\n            k < endk;\n            ++k\n          ) {\n            const childAttribute = attribute.childAttributes[k];\n            const bufferLocationsForChildAttribute =\n              allLocations.childBufferLocations[k];\n\n            if (bufferLocationsForChildAttribute) {\n              const childBufferLocation = bufferLocationsForChildAttribute.shift();\n              if (childBufferLocation) {\n                childLocations.push(childBufferLocation);\n              } else {\n                emitOnce(\n                  'Instance Attribute Child Attribute Error',\n                  (count: number, id: string) => {\n                    console.warn(\n                      `${id}: A child attribute does not have a buffer location available. Error count: ${count}`,\n                    );\n                    console.warn(\n                      `Parent Attribute: ${attribute.name} Child Attribute: ${\n                        childAttribute.name\n                      }`,\n                    );\n                  },\n                );\n              }\n            }\n          }\n\n          bufferLocation.childLocations = childLocations;\n        }\n\n        // In the group, associate the property ids that affect a buffer location WITH the buffer location they affect\n        for (let k = 0, endk = ids.length; k < endk; ++k) {\n          const id = ids[k];\n          group.propertyToBufferLocation[id] = bufferLocation;\n        }\n      }\n\n      // Store this group as a group that is ready to be associated with an instance\n      this.availableLocations.push(group);\n    }\n\n    // This helps ensure errors get reported in a timely fashion in case this triggers some massive looping\n    flushEmitOnce();\n  }\n\n  /**\n   * Returns the total instances this buffer manages.\n   */\n  getInstanceCount() {\n    return this.maxInstancedCount;\n  }\n}\n","export * from './buffer-manager-base';\nexport * from './instance-attribute-buffer-manager';\nexport * from './uniform-buffer-manager';\n","import { Instance } from '../../instance-provider/instance';\nimport {\n  IInstanceAttribute,\n  INonePickingMetrics,\n  IQuadTreePickingMetrics,\n  ISinglePickingMetrics,\n  PickType,\n} from '../../types';\nimport { LayerBufferType } from '../layer-processing/layer-buffer-type';\nimport { AtlasResourceManager } from '../texture/atlas-resource-manager';\nimport { BufferManagerBase, IBufferLocation } from './buffer-manager-base';\nimport { IBufferLocationGroup } from './buffer-manager-base';\nimport { BaseDiffProcessor } from './diff-processors/base-diff-processor';\nimport { InstanceAttributeDiffProcessor } from './diff-processors/instance-attribute-diff-processor';\nimport { UniformColorDiffProcessor } from './diff-processors/uniform-color-diff-processor';\nimport { UniformDiffProcessor } from './diff-processors/uniform-diff-processor';\nimport { UniformQuadDiffProcessor } from './diff-processors/uniform-quad-diff-processor';\n\n/** Signature of a method that handles a diff */\nexport type DiffHandler<T extends Instance> = (\n  manager: BaseDiffProcessor<T>,\n  instance: T,\n  propIds: number[],\n  bufferLocations?: IBufferLocation | IBufferLocationGroup<IBufferLocation>,\n) => void;\n/** A set of diff handling methods in this order [change, add, remove] */\nexport type DiffLookup<T extends Instance> = DiffHandler<T>[];\n\n/**\n * This interface is the bare minimum properties needed for this diff manager to map instance updates to\n * uniform changes. We don't use a Layer as a target explicitly to avoid circular/hard dependencies\n */\nexport interface IInstanceDiffManagerTarget<T extends Instance> {\n  /** This is the attribute for the target that represents the _active injected value */\n  activeAttribute: IInstanceAttribute<T>;\n  /** This is all of the instance attributes applied to the target */\n  instanceAttributes: IInstanceAttribute<T>[];\n  /** This is the picking metrics for how Instances are picked with the mouse */\n  picking:\n    | IQuadTreePickingMetrics<T>\n    | ISinglePickingMetrics<T>\n    | INonePickingMetrics;\n  /** This is the resource manager for the target which let's us fetch information from an atlas for an instance */\n  resource: AtlasResourceManager;\n  /** This is the manager that links an instance to it's uniform cluster for populating the uniform buffer */\n  bufferManager: BufferManagerBase<T, IBufferLocation>;\n  /** This is the buffering strategy being used */\n  bufferType: LayerBufferType;\n}\n\n/**\n * This class manages the process of taking the diffs of a layer and executing methods on those diffs to perform\n * updates to the uniforms that control those instances.\n */\nexport class InstanceDiffManager<T extends Instance> {\n  bufferManager: BufferManagerBase<T, IBufferLocation>;\n  processor: BaseDiffProcessor<T>;\n  processing: DiffLookup<T>;\n  layer: IInstanceDiffManagerTarget<T>;\n\n  constructor(\n    layer: IInstanceDiffManagerTarget<T>,\n    bufferManager: BufferManagerBase<T, IBufferLocation>,\n  ) {\n    this.layer = layer;\n    this.bufferManager = bufferManager;\n  }\n\n  /**\n   * This returns the proper diff processor for handling diffs\n   */\n  makeProcessor(): DiffLookup<T> {\n    // If this manager has already figured out which processor to use. Just return that processor.\n    if (this.processing) return this.processing;\n\n    if (this.layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE) {\n      this.processor = new InstanceAttributeDiffProcessor(\n        this.layer,\n        this.bufferManager,\n      );\n    } else {\n      // Now we look at the state of the layer to determine the best diff processor strategy\n      if (this.layer.picking) {\n        if (this.layer.picking.type === PickType.ALL) {\n          this.processor = new UniformQuadDiffProcessor(\n            this.layer,\n            this.bufferManager,\n          );\n        } else if (this.layer.picking.type === PickType.SINGLE) {\n          this.processor = new UniformColorDiffProcessor(\n            this.layer,\n            this.bufferManager,\n          );\n        }\n      }\n\n      if (!this.processor) {\n        this.processor = new UniformDiffProcessor(\n          this.layer,\n          this.bufferManager,\n        );\n      }\n    }\n\n    this.processing = [\n      this.processor.changeInstance,\n      this.processor.addInstance,\n      this.processor.removeInstance,\n    ];\n\n    return this.processing;\n  }\n}\n","/**\n * Defines a 2d point within a coordinate plane\n */\nexport interface IPoint {\n  x: number;\n  y: number;\n}\n\n/**\n * Calculates the distance between two points, but keeps the distance in dquared form\n * thus performing Math.sqrt() on the output of this distance would provide the true\n * distance between the points.\n *\n * It is often faster and all that is needed to compare squared distances vs real distances\n * thus eliminating multiple Math.sqrt operations\n *\n * NOTE: For vectors this is the same as (pseudo code):\n * let vector3 = vector2.subtract(vector1)\n * return vector3.dot(vector3)\n *\n * @param p1 The point to find the distance from the second point\n * @param p2 The point to find the distance from the first point\n *\n * @return {number} The distance * distance between the two points\n */\nfunction squareDistance(p1: IPoint, p2: IPoint): number {\n  const dx = p1.x - p2.x;\n  const dy = p1.y - p2.y;\n\n  return dx * dx + dy * dy;\n}\n\n/**\n * Contains methods for managing or manipulating points\n *\n * @export\n * @class Point\n */\nexport class Point {\n  /**\n   * Adds two points together\n   *\n   * @static\n   * @param {IPoint} p1\n   * @param {IPoint} p2\n   * @param {IPoint} out If this is specified, the results will be placed into this rather than allocate a new object\n   *\n   * @return {IPoint} The two points added together\n   */\n  static add(p1: IPoint, p2: IPoint, out?: IPoint): IPoint {\n    if (out) {\n      out.x = p1.x + p2.x;\n      out.y = p1.y + p2.y;\n      return out;\n    }\n\n    return {\n      x: p1.x + p2.x,\n      y: p1.y + p2.y,\n    };\n  }\n\n  /**\n   * @static\n   * This analyzes a test point against a list of points and determines which of the points is\n   * the closest to the test point. If there are equi-distant points in the list, this will return\n   * the first found in the list.\n   *\n   * @param {IPoint} testPoint The point to compare against other points\n   * @param {IPoint[]} points The list of points to be compared against\n   *\n   * @return {IPoint} The closest point to the test point\n   */\n  static getClosest(testPoint: IPoint, points: IPoint[]): IPoint {\n    let closestDistance = Number.MAX_VALUE;\n    let closestPoint: IPoint = testPoint;\n    let distance: number;\n\n    const findClosest = function(point: IPoint) {\n      distance = squareDistance(point, testPoint);\n\n      if (distance < closestDistance) {\n        closestDistance = distance;\n        closestPoint = point;\n      }\n    };\n\n    points.forEach(findClosest);\n\n    return closestPoint;\n  }\n\n  /**\n   * @static\n   * This analyzes a test point against a list of points and determines which of the points is\n   * the closest to the test point. If there are equi-distant points in the list, this will return\n   * the first found in the list.\n   *\n   * This just returns the index of the found point and not the point itself\n   *\n   * @param {IPoint} testPoint The point to compare against other points\n   * @param {IPoint[]} points The list of points to be compared against\n   *\n   * @return {number} The index of the closest point to the test point\n   */\n  static getClosestIndex(testPoint: IPoint, points: IPoint[]): number {\n    let closestDistance = Number.MAX_VALUE;\n    let closestPoint: number = 0;\n    let distance: number;\n\n    const findClosest = function(point: IPoint, i: number) {\n      distance = squareDistance(point, testPoint);\n\n      if (distance < closestDistance) {\n        closestDistance = distance;\n        closestPoint = i;\n      }\n    };\n\n    points.forEach(findClosest);\n\n    return closestPoint;\n  }\n\n  /**\n   * @static\n   * This will calculate a direction vector between two points that points toward p2\n   *\n   * @param {IPoint} amount The start of the direction\n   * @param {IPoint} from The direction to point the vector towards\n   * @param {boolean} normalize If true, this will make the vector have a magnitude of 1\n   *\n   * @returns {number}\n   */\n  static subtract(\n    amount: IPoint,\n    from: IPoint,\n    normalize: boolean = false,\n  ): IPoint {\n    let dx = from.x - amount.x;\n    let dy = from.y - amount.y;\n\n    if (normalize) {\n      const magnitude = Math.sqrt(dx * dx + dy * dy);\n      dx /= magnitude;\n      dy /= magnitude;\n    }\n\n    return {\n      x: dx,\n      y: dy,\n    };\n  }\n\n  /**\n   * @static\n   * Gets the distance between two points\n   *\n   * @param {IPoint} p1\n   * @param {IPoint} p2\n   * @param {boolean} squared If set to true, returns the distance * distance (performs faster)\n   *\n   * @returns {number} The real distance between two points\n   */\n  static getDistance(p1: IPoint, p2: IPoint, squared: boolean = false): number {\n    if (squared) {\n      return squareDistance(p1, p2);\n    }\n\n    return Math.sqrt(squareDistance(p1, p2));\n  }\n\n  /**\n   * @static\n   * Gets a point perfectly between two points\n   *\n   * @param {IPoint} p1\n   * @param {IPoint} p2\n   *\n   * @returns {IPoint} The point between the two provided points\n   */\n  static getMidpoint(p1: IPoint, p2: IPoint) {\n    const direction = Point.subtract(p1, p2);\n\n    return {\n      x: direction.x / 2 + p1.x,\n      y: direction.y / 2 + p1.y,\n    };\n  }\n\n  static make(x: number, y: number) {\n    return { x, y };\n  }\n\n  /**\n   * Scales a point by a given amount\n   *\n   * @static\n   * @param {IPoint} p1\n   * @param {number} s The amount to scale the point by\n   * @param {IPoint} out If this is specified, the results will be placed into this rather than allocate a new object\n   *\n   * @memberof Point\n   */\n  static scale(p1: IPoint, s: number, out?: IPoint): IPoint {\n    if (out) {\n      out.x = p1.x * s;\n      out.y = p1.y * s;\n      return out;\n    }\n\n    return {\n      x: p1.x * s,\n      y: p1.y * s,\n    };\n  }\n\n  /**\n   * Makes a new point initialized to {0,0}\n   *\n   * @static\n   * @returns {IPoint} A new point object at {0,0}\n   */\n  static zero(): IPoint {\n    return {\n      x: 0,\n      y: 0,\n    };\n  }\n}\n","import { InstanceDiffType } from '../types';\nimport { Instance } from './instance';\n\n/**\n * This is an entry within the change list of the provider. It represents the type of change\n * and stores the property id's of the properties on the instance that have changed.\n */\nexport type InstanceDiff<T extends Instance> = [\n  T,\n  InstanceDiffType,\n  { [key: number]: number }\n];\n\n/**\n * This is an optimized provider, that can provide instances that use the internal observable system\n * to deliver updates to the framework.\n */\nexport class InstanceProvider<T extends Instance> {\n  /** Stores the disposers that are called when the instance is no longer listened to */\n  private cleanObservation: { [key: number]: [T, Function] } = {};\n  /** This stores the changes to the instances themselves */\n  private instanceChanges: { [key: number]: InstanceDiff<T> } = {};\n  /** This flag is true when resolving changes when the change list is retrieved. it blocks changes until the current list is resolved */\n  private allowChanges = true;\n\n  /**\n   * Retrieve all of the changes applied to instances\n   */\n  get changeList(): InstanceDiff<T>[] {\n    this.allowChanges = false;\n    const changes = Object.values(this.instanceChanges);\n\n    return changes;\n  }\n\n  /**\n   * Adds an instance to the provider which will stream observable changes of the instance to\n   * the framework.\n   */\n  add(instance: T) {\n    // No need to duplicate the addition\n    if (this.cleanObservation[instance.uid]) {\n      return instance;\n    }\n\n    if (this.allowChanges) {\n      instance.observer = this;\n      const disposer: Function = instance.observableDisposer;\n      // Store the disposers so we can clean up the observable properties\n      this.cleanObservation[instance.uid] = [instance, disposer];\n      // Indicate we have a new instance\n      this.instanceChanges[instance.uid] = [\n        instance,\n        InstanceDiffType.INSERT,\n        {},\n      ];\n    }\n\n    return instance;\n  }\n\n  /**\n   * Removes all instances from this provider\n   */\n  clear() {\n    const values = Object.values(this.cleanObservation);\n\n    for (let i = 0, end = values.length; i < end; ++i) {\n      this.remove(values[i][0]);\n    }\n  }\n\n  /**\n   * Clear all resources held by this provider. It IS valid to lose reference to all instances\n   * and to this object, which would effectively cause this object to get GC'ed. But if you\n   * desire to hang onto the instance objects, then this should be called.\n   */\n  destroy() {\n    const values = Object.values(this.cleanObservation);\n\n    for (let i = 0, end = values.length; i < end; ++i) {\n      values[i][1]();\n    }\n\n    this.cleanObservation = {};\n    this.instanceChanges = {};\n  }\n\n  /**\n   * This is called from observables to indicate it's parent has been updated\n   */\n  instanceUpdated(instance: T, property: number) {\n    if (this.allowChanges) {\n      // Flag the instance as having a property changed\n      const change = this.instanceChanges[instance.uid] || [\n        instance,\n        InstanceDiffType.CHANGE,\n        {},\n      ];\n      this.instanceChanges[instance.uid] = change;\n      change[1] = InstanceDiffType.CHANGE;\n      change[2][property] = property;\n    }\n  }\n\n  /**\n   * Removes the instance from being advertised changes and from providing the changes\n   * for the instance.\n   */\n  remove(instance: T) {\n    if (this.allowChanges) {\n      const disposer = this.cleanObservation[instance.uid];\n\n      if (disposer) {\n        disposer[1]();\n        delete this.cleanObservation[instance.uid];\n        this.instanceChanges[instance.uid] = [\n          instance,\n          InstanceDiffType.REMOVE,\n          {},\n        ];\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Flagged all changes as dealt with\n   */\n  resolve() {\n    this.allowChanges = true;\n    this.instanceChanges = {};\n  }\n}\n","import * as Three from 'three';\nimport { InstanceProvider } from '../../instance-provider';\nimport { Bounds, IPoint } from '../../primitives';\nimport {\n  ILayerProps,\n  IModelType,\n  IShaderInitialization,\n  Layer,\n} from '../../surface/layer';\nimport {\n  IMaterialOptions,\n  InstanceAttributeSize,\n  InstanceBlockIndex,\n  IProjection,\n  IUniform,\n  UniformSize,\n  VertexAttributeSize,\n} from '../../types';\nimport { CommonMaterialOptions, Vec } from '../../util';\nimport { IAutoEasingMethod } from '../../util/auto-easing-method';\nimport { CircleInstance } from './circle-instance';\n\nexport interface ICircleLayerProps extends ILayerProps<CircleInstance> {\n  /** This sets the  */\n  fadeOutOversized?: number;\n  /** This sets a scaling factor for the circle's radius */\n  scaleFactor?(): number;\n  /** Flags this layer to draw  */\n  disableDepthTest?: boolean;\n  /**\n   * This is the properties that can toggle on animations.\n   *\n   * NOTE: The more properties declared as animated will reduce the performance of the layer.\n   * if animated properties are created, it can be beneficial to have other layers with no\n   * animations be available for the Instances to 'rest' in when not moving.\n   */\n  animate?: {\n    center?: IAutoEasingMethod<Vec>;\n    radius?: IAutoEasingMethod<Vec>;\n    color?: IAutoEasingMethod<Vec>;\n  };\n}\n\n/**\n * This layer displays circles and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class CircleLayer extends Layer<CircleInstance, ICircleLayerProps> {\n  static defaultProps: ICircleLayerProps = {\n    data: new InstanceProvider<CircleInstance>(),\n    fadeOutOversized: -1,\n    key: '',\n    scaleFactor: () => 1,\n  };\n\n  /**\n   * We provide bounds and hit test information for the instances for this layer to allow for mouse picking\n   * of elements\n   */\n  getInstancePickingMethods() {\n    const noScaleFactor = () => 1;\n\n    return {\n      // Provide the calculated AABB world bounds for a given circle\n      boundsAccessor: (circle: CircleInstance) =>\n        new Bounds({\n          height: circle.radius * 2,\n          width: circle.radius * 2,\n          x: circle.x - circle.radius,\n          y: circle.y - circle.radius,\n        }),\n\n      // Provide a precise hit test for the circle\n      hitTest: (circle: CircleInstance, point: IPoint, view: IProjection) => {\n        const circleScreenCenter = view.worldToScreen(circle);\n        const mouseScreen = view.worldToScreen(point);\n        const r = circle.radius * (this.props.scaleFactor || noScaleFactor)();\n\n        const delta = [\n          mouseScreen.x - circleScreenCenter.x,\n          mouseScreen.y - circleScreenCenter.y,\n        ];\n\n        return delta[0] * delta[0] + delta[1] * delta[1] < r * r;\n      },\n    };\n  }\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<CircleInstance> {\n    const scaleFactor = this.props.scaleFactor || (() => 1);\n    const animations = this.props.animate || {};\n    const {\n      center: animateCenter,\n      radius: animateRadius,\n      color: animateColor,\n    } = animations;\n\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1,\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: -1,\n      1: -1,\n      2: -1,\n      3: 1,\n      4: 1,\n      5: 1,\n    };\n\n    return {\n      fs: require('./circle-layer.fs'),\n      instanceAttributes: [\n        {\n          block: 0,\n          blockIndex: InstanceBlockIndex.ONE,\n          easing: animateCenter,\n          name: 'center',\n          size: InstanceAttributeSize.TWO,\n          update: circle => [circle.x, circle.y],\n        },\n        {\n          block: 0,\n          blockIndex: InstanceBlockIndex.THREE,\n          easing: animateRadius,\n          name: 'radius',\n          size: InstanceAttributeSize.ONE,\n          update: circle => [circle.radius],\n        },\n        {\n          block: 0,\n          blockIndex: InstanceBlockIndex.FOUR,\n          name: 'depth',\n          size: InstanceAttributeSize.ONE,\n          update: circle => [circle.depth],\n        },\n        {\n          block: 1,\n          blockIndex: InstanceBlockIndex.ONE,\n          easing: animateColor,\n          name: 'color',\n          size: InstanceAttributeSize.FOUR,\n          update: circle => circle.color,\n        },\n      ],\n      uniforms: [\n        {\n          name: 'scaleFactor',\n          size: UniformSize.ONE,\n          update: (uniform: IUniform) => [scaleFactor()],\n        },\n      ],\n      vertexAttributes: [\n        // TODO: This is from the heinous evils of THREEJS and their inability to fix a bug within our lifetimes.\n        // Right now position is REQUIRED in order for rendering to occur, otherwise the draw range gets updated to\n        // Zero against your wishes.\n        {\n          name: 'position',\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexToSide[vertex],\n            0,\n          ],\n        },\n      ],\n      vertexCount: 6,\n      vs: require('./circle-layer.vs'),\n    };\n  }\n\n  getModelType(): IModelType {\n    return {\n      drawMode: Three.TriangleStripDrawMode,\n      modelType: Three.Mesh,\n    };\n  }\n\n  getMaterialOptions(): IMaterialOptions {\n    return CommonMaterialOptions.transparentShape;\n  }\n}\n","export * from './circle-layer';\nexport * from './circle-instance';\n","export * from './circles';\nexport * from './edges';\nexport * from './images';\nexport * from './labels';\nexport * from './rectangle';\nexport * from './rings';\nexport * from './types';\n","import * as Three from 'three';\nimport { IMaterialOptions } from '../types';\n\nexport class CommonMaterialOptions {\n  static transparentShape: IMaterialOptions = {\n    premultipliedAlpha: true,\n    transparent: true,\n  };\n\n  static transparentImage: IMaterialOptions = {\n    blending: Three.CustomBlending,\n    blendSrc: Three.OneFactor,\n    premultipliedAlpha: true,\n    transparent: true,\n  };\n}\n","import { Instance } from '../instance-provider/instance';\nimport { Bounds } from '../primitives/bounds';\nimport { IPoint } from '../primitives/point';\n\n// A configuration that controls how readily a quadtree will split to another level\n// Adjusting this number can improve or degrade your performance significantly and\n// Must be tested for specific use cases\nconst maxPopulation: number = 5;\nconst maxDepth: number = 10;\n\nexport type BoundsAccessor<T extends Instance> = (o: T) => Bounds | null;\n\n/**\n * Allows typing of a callback argument\n */\nexport interface IVisitFunction<T extends Instance> {\n  /**\n   * A callback to use during add or query\n   *\n   * Called do provide aggregation or filtering like Array.reduce or\n   * Array.filter, but in a QuadTree instead.\n   *\n   * @param node  The node to effect the function upon\n   * @param child The child to add to the node\n   */\n  (node: Node<T>, child?: Bounds): void;\n}\n\n/**\n * This is a class used specifically by the quad tree nodes to indicate split space\n * within the quad tree.\n */\nexport class Quadrants<T extends Instance> {\n  TL: Node<T>;\n  TR: Node<T>;\n  BL: Node<T>;\n  BR: Node<T>;\n\n  /**\n   * Ensures all memory is released for all nodes and all references are removed\n   * to potentially high memory consumption items\n   */\n  destroy() {\n    this.TL.destroy();\n    this.TR.destroy();\n    this.BL.destroy();\n    this.BR.destroy();\n    delete this.TL;\n    delete this.TR;\n    delete this.BL;\n    delete this.BR;\n  }\n\n  /**\n   * Creates an instance of Quadrants.\n   *\n   * @param bounds The bounds this will create quandrants for\n   * @param depth  The child depth of this element\n   */\n  constructor(\n    bounds: Bounds,\n    depth: number,\n    getBounds: BoundsAccessor<T>,\n    childToNode: Map<T, Node<T>>,\n    childToBounds: Map<T, Bounds | null>,\n  ) {\n    const mid = bounds.mid;\n    this.TL = new Node<T>(bounds.x, mid.x, bounds.y, mid.y, getBounds, depth);\n    this.TR = new Node<T>(\n      mid.x,\n      bounds.right,\n      bounds.y,\n      mid.y,\n      getBounds,\n      depth,\n    );\n    this.BL = new Node<T>(\n      bounds.x,\n      mid.x,\n      mid.y,\n      bounds.bottom,\n      getBounds,\n      depth,\n    );\n    this.BR = new Node<T>(\n      mid.x,\n      bounds.right,\n      mid.y,\n      bounds.bottom,\n      getBounds,\n      depth,\n    );\n    this.TL.childToNode = childToNode;\n    this.TR.childToNode = childToNode;\n    this.BL.childToNode = childToNode;\n    this.BR.childToNode = childToNode;\n    this.TL.childToBounds = childToBounds;\n    this.TR.childToBounds = childToBounds;\n    this.BL.childToBounds = childToBounds;\n    this.BR.childToBounds = childToBounds;\n  }\n}\n\n/**\n * The quad tree node. This Node will take in a certain population before dividing itself into\n * 4 quadrants which it will attempt to inject it's population into. If a member of the population\n * does not completely get injected into one of the quadrants it remains as a member of this node.\n */\nexport class Node<T extends Instance> {\n  /** This is the amount of space this node covers */\n  bounds: Bounds;\n  /** These are the child Instances of the node. */\n  children: T[] = [];\n  /**\n   * This tracks a quick lookup of a child to it's parent node. This is used so the child can\n   * be removed with ease and not require a traversal of the tree.\n   */\n  childToNode: Map<T, Node<T>>;\n  /** This tracks the bounds calcuated for the given instance */\n  childToBounds: Map<T, Bounds | null>;\n  /** This is how deep the node is within the tree */\n  depth: number = 0;\n  /** This is the accessor method that retrieves the bounds for an injected instance */\n  getBounds: BoundsAccessor<T>;\n  /** These are the child nodes of this quad node when this node is split. It is null if the node is not split yet */\n  nodes: Quadrants<T> | null = null;\n  /**\n   * These are children with null bounds that do not affect the splitting and ALWAYS get checked every query.\n   * They should only reside on the top node.\n   */\n  nullBounded: T[];\n\n  /**\n   * Destroys this node and ensures all child nodes are destroyed as well.\n   */\n  destroy() {\n    delete this.children;\n    delete this.bounds;\n\n    if (this.nodes) {\n      this.nodes.destroy();\n      this.nodes = null;\n    }\n  }\n\n  /**\n   * Creates an instance of Node.\n   */\n  constructor(\n    left: number,\n    right: number,\n    top: number,\n    bottom: number,\n    getBounds: BoundsAccessor<T>,\n    depth: number = 0,\n  ) {\n    // If params insertted\n    if (arguments.length >= 4) {\n      this.bounds = new Bounds({ left, right, top, bottom });\n    } else {\n      // Otherwise, make tiny start area\n      this.bounds = new Bounds({ left: 0, right: 1, top: 1, bottom: 0 });\n    }\n\n    // Ensure the depth is set\n    this.depth = depth;\n    // Apply the bounds accessor method for instances\n    this.getBounds = getBounds;\n\n    // If this is the top level node, we need to instantiate the lookup that will be used\n    // Across all nodes.\n    if (this.depth === 0) {\n      this.nullBounded = [];\n      this.childToNode = new Map<T, Node<T>>();\n      this.childToBounds = new Map<T, Bounds>();\n    }\n  }\n\n  /**\n   * Adds an object that extends Bounds (or is Bounds) and properly injects it into this node\n   * or into a sub quadrant if this node is split already. If the child is outside the boundaries\n   * this quad tree spans (and this is the root node), the quad tree will expand to include\n   * the new child.\n   *\n   * @param child The Bounds type object to inject\n   * @param props Properties that can be retrieved with the child object if applicable\n   *\n   * @returns True if the insertion was successful\n   */\n  add(child: T): boolean {\n    let bounds = this.childToBounds.get(child);\n\n    if (!bounds) {\n      // First we access the bounds of the child and store it\n      bounds = this.getBounds(child);\n      this.childToBounds.set(child, bounds);\n    }\n\n    // This is the entry function for adding children, so we must first expand our top node\n    // To cover the area that the child is located.\n    // If we're in bounds, then let's just add the child\n    if (!bounds || bounds.isInside(this.bounds)) {\n      return this.doAdd(child, bounds);\n    } else {\n      // Otherwise, we need to expand first\n      this.cover(bounds);\n      return this.add(child);\n    }\n  }\n\n  /**\n   * Adds a list of new children to this quad tree. It performs the same operations as\n   * addChild for each child in the list, however, it more efficiently recalculates the\n   * bounds necessary to cover the area the children cover.\n   *\n   * @param children      List of Bounds objects to inject\n   */\n  addAll(children: T[]) {\n    // Make sure we cover the entire area of all the children.\n    // We can speed this up a lot if we first calculate the total bounds the new children covers\n    let minX = Number.MAX_VALUE;\n    let minY = Number.MAX_VALUE;\n    let maxX = -Number.MAX_VALUE;\n    let maxY = -Number.MAX_VALUE;\n\n    // Get the dimensions of the new bounds\n    children.forEach(child => {\n      const bounds = this.getBounds(child);\n      this.childToBounds.set(child, bounds);\n      if (!bounds) return;\n\n      if (bounds.x < minX) {\n        minX = bounds.x;\n      }\n      if (bounds.right > maxX) {\n        maxX = bounds.right;\n      }\n      if (bounds.bottom > maxY) {\n        maxY = bounds.bottom;\n      }\n      if (bounds.y < minY) {\n        minY = bounds.y;\n      }\n    });\n\n    // Ensure a valid cover dimension was established. If no valid dimension is established\n    // Then we don't cover, but we can still add the children as that have null Bounds which\n    // Means injecting at the top level.\n    if (\n      minX !== Number.MAX_VALUE &&\n      minY !== Number.MAX_VALUE &&\n      maxX !== -Number.MAX_VALUE &&\n      maxY !== -Number.MAX_VALUE\n    ) {\n      // Make sure our bounds includes the specified bounds\n      this.cover(\n        new Bounds({ left: minX, right: maxX, bottom: maxY, top: minY }),\n      );\n    }\n\n    // Add all of the children into the tree.\n    children.forEach((child, index) =>\n      this.doAdd(child, this.childToBounds.get(child) || null, true),\n    );\n  }\n\n  /**\n   * Ensures this quad tree includes the bounds specified in it's spatial coverage.\n   * This will cause all children to be re-injected into the tree.\n   *\n   * @param bounds The bounds to include in the tree's coverage\n   */\n  cover(bounds: Bounds) {\n    // If we are already covering the area: abort\n    if (bounds.isInside(this.bounds)) {\n      return;\n    }\n\n    // Make our bounds cover the new area\n    this.bounds.encapsulate(bounds);\n    this.bounds.x -= 1;\n    this.bounds.y -= 1;\n    this.bounds.width += 2;\n    this.bounds.height += 2;\n    // Get all of the children underneath this node\n    const allChildren = this.gatherChildren([]);\n    this.children = [];\n\n    // Destroy the split nodes\n    if (this.nodes) {\n      // Completely...destroy...\n      this.nodes.destroy();\n      this.nodes = null;\n    }\n\n    // Clear out the child to node relations\n    this.childToNode.clear();\n    // Reinsert all children with the new dimensions in place\n    allChildren.forEach((child, index) =>\n      this.doAdd(child, this.childToBounds.get(child) || null),\n    );\n  }\n\n  /**\n   * When adding children, this performs the actual action of injecting the child into the tree\n   * without the process of seeing if the tree needs a spatial adjustment to account for the child.\n   *\n   * @param child The Bounds item to inject into the tree\n   * @param props The props to remain associated with the child\n   *\n   * @returns True if the injection was successful\n   */\n  private doAdd(child: T, bounds: Bounds | null, fromSplit?: boolean): boolean {\n    // If this is the top level node and the bounds are null, then we add to the null list\n    if (!bounds && this.depth === 0) {\n      this.nullBounded.push(child);\n      this.childToNode.set(child, this);\n\n      return true;\n    }\n\n    // If no bounds is available at this point, something went terribly wrong\n    if (!bounds) {\n      console.warn(\n        'A null bounds was added to a Quad Tree node below the top node, which is invalid.',\n      );\n      return false;\n    }\n\n    // If bounds are null, then just immediately add\n    // If nodes are present, then we have already exceeded the population of this node\n    if (this.nodes) {\n      if (bounds.isInside(this.nodes.TL.bounds)) {\n        return this.nodes.TL.doAdd(child, bounds, fromSplit);\n      }\n\n      if (bounds.isInside(this.nodes.TR.bounds)) {\n        return this.nodes.TR.doAdd(child, bounds, fromSplit);\n      }\n\n      if (bounds.isInside(this.nodes.BL.bounds)) {\n        return this.nodes.BL.doAdd(child, bounds, fromSplit);\n      }\n\n      if (bounds.isInside(this.nodes.BR.bounds)) {\n        return this.nodes.BR.doAdd(child, bounds, fromSplit);\n      }\n\n      // Otherwise, this is a child overlapping this border\n      this.children.push(child);\n      this.childToNode.set(child, this);\n\n      return true;\n    } else if (bounds.isInside(this.bounds)) {\n      // Otherwise, we have not had a split due to population limits being exceeded\n      this.children.push(child);\n      this.childToNode.set(child, this);\n\n      // If we exceeded our population for this quadrant, it is time to split up\n      if (this.children.length > maxPopulation && this.depth < maxDepth) {\n        this.split();\n      }\n\n      return true;\n    }\n\n    // This is when there is something wrong with the insertted child. The bounds\n    // For the quad should have grown without issue, but in this case the bounds\n    // Could not grow to accomodate the child.\n    if (isNaN(bounds.width + bounds.height + bounds.x + bounds.y)) {\n      console.error(\n        'Child did not fit into bounds because a dimension is NaN',\n        child,\n        bounds,\n      );\n    } else if (bounds.area === 0) {\n      console.error(\n        'Child did not fit into bounds because the area is zero',\n        child,\n        bounds,\n      );\n    } else {\n      console.error(\n        'Child did not get insertted.',\n        'Parent:',\n        this.bounds.toString(),\n        'Child:',\n        bounds.toString(),\n        'Inside Checks:',\n        bounds.x >= this.bounds.x,\n        bounds.right <= this.bounds.right,\n        bounds.y >= this.bounds.y,\n        bounds.bottom <= this.bounds.bottom,\n      );\n    }\n\n    // Don't insert the child and continue\n    return true;\n  }\n\n  private doRemove(child: T) {\n    const index = this.children.indexOf(child);\n\n    if (index > -1) {\n      this.children.splice(index, 1);\n      this.childToNode.delete(child);\n      this.childToBounds.delete(child);\n    }\n  }\n\n  /**\n   * Collects all children of all the current and sub nodes into a single list.\n   *\n   * @param list The list we must aggregate children into\n   *\n   * @return The list specified as the list parameter\n   */\n  gatherChildren(list: T[]): T[] {\n    this.children.forEach(child => list.push(child));\n\n    if (this.nodes) {\n      this.nodes.TL.gatherChildren(list);\n      this.nodes.TR.gatherChildren(list);\n      this.nodes.BL.gatherChildren(list);\n      this.nodes.BR.gatherChildren(list);\n    }\n\n    return list;\n  }\n\n  /**\n   * Entry query for determining query type based on input object\n   *\n   * @param bounds Can be a Bounds or a Point object\n   * @param visit  A callback function that will receive the Node as it is analyzed. This gives\n   *               information on a spatial scale, how a query reaches it's target intersections.\n   *\n   * @return An array of children that intersects with the query\n   */\n  query(bounds: Bounds | IPoint, visit?: IVisitFunction<T>): T[] {\n    // This stores all of the found Instances when querying by bounds or point\n    let found: T[] = [];\n\n    // If this is the top level node then add in the null bunded items as the start\n    if (this.depth === 0) {\n      found = this.nullBounded.slice(0);\n    }\n\n    // Query a rectangle\n    if (bounds instanceof Bounds) {\n      if (bounds.hitBounds(this.bounds)) {\n        return this.queryBounds(bounds, found, visit);\n      }\n    }\n\n    // Query a point\n    if (this.bounds.containsPoint(bounds)) {\n      return this.queryPoint(bounds, found, visit);\n    }\n\n    // Return an empty array when nothing is collided with\n    return found;\n  }\n\n  /**\n   * Queries children for intersection with a bounds object\n   *\n   * @param b     The Bounds to test children against\n   * @param list  The list of children to aggregate into the query\n   * @param visit A callback function that will receive the Node as it is analyzed. This gives\n   *              information on a spatial scale, how a query reaches it's target intersections.\n   *\n   * @return     Returns the exact same list that was input as the list param\n   */\n  queryBounds(b: Bounds, list: T[], visit?: IVisitFunction<T>): T[] {\n    this.children.forEach(c => {\n      const bounds = this.childToBounds.get(c);\n\n      if (bounds && bounds.hitBounds(b)) {\n        list.push(c);\n      }\n    });\n\n    if (visit) {\n      visit(this);\n    }\n\n    if (this.nodes) {\n      if (b.hitBounds(this.nodes.TL.bounds)) {\n        this.nodes.TL.queryBounds(b, list, visit);\n      }\n\n      if (b.hitBounds(this.nodes.TR.bounds)) {\n        this.nodes.TR.queryBounds(b, list, visit);\n      }\n\n      if (b.hitBounds(this.nodes.BL.bounds)) {\n        this.nodes.BL.queryBounds(b, list, visit);\n      }\n\n      if (b.hitBounds(this.nodes.BR.bounds)) {\n        this.nodes.BR.queryBounds(b, list, visit);\n      }\n    }\n\n    return list;\n  }\n\n  /**\n   * Queries children for intersection with a point\n   *\n   * @param p     The Point to test children against\n   * @param list  The list of children to aggregate into the query\n   * @param visit A callback function that will receive the Node as it is analyzed. This gives\n   *              information on a spatial scale, how a query reaches it's target intersections.\n   *\n   * @return      Returns the exact same list that was input as the list param\n   */\n  queryPoint(p: any, list: T[], visit?: IVisitFunction<T>): T[] {\n    this.children.forEach(c => {\n      const bounds = this.childToBounds.get(c);\n\n      if (bounds && bounds.containsPoint(p)) {\n        list.push(c);\n      }\n    });\n\n    if (visit) {\n      visit(this);\n    }\n\n    if (this.nodes) {\n      if (this.nodes.TL.bounds.containsPoint(p)) {\n        this.nodes.TL.queryPoint(p, list, visit);\n      }\n\n      if (this.nodes.TR.bounds.containsPoint(p)) {\n        this.nodes.TR.queryPoint(p, list, visit);\n      }\n\n      if (this.nodes.BL.bounds.containsPoint(p)) {\n        this.nodes.BL.queryPoint(p, list, visit);\n      }\n\n      if (this.nodes.BR.bounds.containsPoint(p)) {\n        this.nodes.BR.queryPoint(p, list, visit);\n      }\n    }\n\n    return list;\n  }\n\n  /**\n   * Remove the provided item from the tree.\n   */\n  remove(child: T) {\n    if (this.childToNode) {\n      const node = this.childToNode.get(child);\n\n      // If the node is getting removed from the top level node, then it MAY be a null bounded item\n      // Which gets removed from the list\n      if (node && node.depth === 0) {\n        const index = node.nullBounded.indexOf(child);\n\n        if (index > -1) {\n          node.nullBounded.splice(index);\n          this.childToNode.delete(child);\n          this.childToBounds.delete(child);\n\n          return;\n        }\n      }\n\n      // Otherwise, just remove the node normally\n      if (node) {\n        node.doRemove(child);\n      }\n    }\n  }\n\n  /**\n   * Creates four sub quadrants for this node.\n   */\n  split() {\n    // Gather all items to be handed down\n    const allChildren = this.gatherChildren([]);\n    // Gather all props for the children to be handed down as well\n    this.nodes = new Quadrants<T>(\n      this.bounds,\n      this.depth + 1,\n      this.getBounds,\n      this.childToNode,\n      this.childToBounds,\n    );\n    // Empty out the children as they are being re-injected\n    this.children = [];\n\n    for (let i = 0, end = allChildren.length; i < end; ++i) {\n      const child = allChildren[i];\n      this.doAdd(child, this.childToBounds.get(child) || null, true);\n    }\n  }\n\n  /**\n   * Traverses the quad tree returning every quadrant encountered\n   *\n   * @param cb A callback that has the parameter (node) which is a quadrant in the tree\n   */\n  visit(cb: IVisitFunction<T>): void {\n    const finished = Boolean(cb(this));\n\n    if (this.nodes && !finished) {\n      this.nodes.TL.visit(cb);\n      this.nodes.TR.visit(cb);\n      this.nodes.BL.visit(cb);\n      this.nodes.BR.visit(cb);\n    }\n  }\n}\n\nexport class TrackedQuadTree<T extends Instance> extends Node<T> {}\n","import { ChartCamera } from './chart-camera';\n\nexport interface IReferenceCameraOptions {\n  /** This is the base camera to monitor */\n  base: ChartCamera;\n  /**\n   * This is a filter applied to the offset that comes from the chart camera.\n   */\n  offsetFilter?(offset: [number, number, number]): [number, number, number];\n  /**\n   * This is a filter applied to the scale that comes from the chart camera.\n   */\n  scaleFilter?(scale: [number, number, number]): [number, number, number];\n}\n\n/**\n * This is a camera that is based on another camera. This can apply filters\n * to the information provided from the base camera.\n *\n * Useful for situations such as a chart having a chart area and a list on the\n * left. This can use the same camera the chart area uses, but filter the response\n * to only track the y offset of the base camera.\n *\n * That would allow easy tracking of the left list to track with elements in the\n * chart and only manipulate a single camera instead of managing many cameras and\n * tie them together with lots of events.\n */\nexport class ReferenceCamera extends ChartCamera {\n  private base: ChartCamera;\n  private offsetFilter = (offset: [number, number, number]) => offset;\n  private scaleFilter = (scale: [number, number, number]) => scale;\n\n  set offset(val: any) {\n    /** no-op */\n  }\n\n  get offset() {\n    return this.offsetFilter(this.base.offset);\n  }\n\n  set scale(val: any) {\n    /** no-op */\n  }\n\n  get scale() {\n    return this.scaleFilter(this.base.scale);\n  }\n\n  constructor(options: IReferenceCameraOptions) {\n    super();\n    Object.assign(this, options);\n  }\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","module.exports = __WEBPACK_EXTERNAL_MODULE__124__;","import { LayerSurface } from '../surface';\nimport { IAutoEasingMethod } from './auto-easing-method';\nimport { Vec } from './vector';\n\nexport type AnimationDelayAccessor = (\n  groupIndex: number,\n  currentDelay: number,\n) => number;\nexport type AnimationInstanceModificationCallback = (\n  groupIndex: number,\n) => void;\n\nfunction isNumber(val: any): val is number {\n  return !isNaN(val);\n}\n\n/**\n * This provides some methods that aids in more complicated animation tasks, such as\n * adjusting gpu animated properties with differing time delay values for each change.\n */\nexport class AnimationHelper {\n  surface: LayerSurface;\n\n  constructor(surface: LayerSurface) {\n    this.surface = surface;\n  }\n\n  /**\n   * When you want to animate properties of instances but you want them to start at differing times,\n   * use this method to ensure the timings starting between the elements is correct.\n   *\n   * @param easingMethod This is the easing method used for the layer's property to animate\n   * @param groupCount This is the number of animations desired for a given delay level\n   * @param delayGap This is the amount of delay between each group. This can be a static value or\n   *                 can be a dynamic callback\n   */\n  groupAnimation(\n    easingMethod: IAutoEasingMethod<Vec>,\n    groupCount: number,\n    baseDelay: number,\n    delayGap: number | AnimationDelayAccessor,\n    modifyInstances: AnimationInstanceModificationCallback,\n  ) {\n    // Get the time of the current frame as our timing basis\n    const startFrameTime = this.surface.frameMetrics.currentTime;\n    // Do an initial commit to ensure all previous animated properties are committed based on the\n    // Delay specified for them\n    this.surface.commit(startFrameTime);\n\n    // Loop through the the number of grouped animations to work with\n    for (let i = 0; i < groupCount; ++i) {\n      // Determine how much extra delay is applied for the provided group\n      const gap = isNumber(delayGap)\n        ? delayGap\n        : delayGap(i, easingMethod.delay);\n      // Apply the delay\n      easingMethod.delay = baseDelay + gap * i;\n      // Make the instance modifications\n      modifyInstances(i);\n      // Commit the instance modifications based on the current delay settings\n      this.surface.commit(startFrameTime);\n    }\n  }\n}\n","import { Bounds } from '../primitives/bounds';\nimport { EventManager } from '../surface/event-manager';\nimport {\n  IDragMetrics,\n  IMouseInteraction,\n  IWheelMetrics,\n} from '../surface/mouse-event-manager';\nimport { View } from '../surface/view';\nimport { add3, subtract3, Vec3 } from '../util';\nimport { ChartCamera } from '../util/chart-camera';\nexport enum CameraBoundsAnchor {\n  TOP_LEFT,\n  TOP_MIDDLE,\n  TOP_RIGHT,\n  MIDDLE_LEFT,\n  MIDDLE,\n  MIDDLE_RIGHT,\n  BOTTOM_LEFT,\n  BOTTOM_MIDDLE,\n  BOTTOM_RIGHT,\n}\n\nconst { max, min } = Math;\n\n/**\n * This represents how the camera should be bounded in the world space. This gives enough information\n * to handle all cases of bounding, including screen padding and anchoring for cases where the viewed space\n * is smaller than the view.\n */\nexport interface ICameraBoundsOptions {\n  /** How the bounded world space should anchor itself within the view when the projected world space to the screen is smaller than the view */\n  anchor: CameraBoundsAnchor;\n  /** Minimum settings the camera can scale to */\n  scaleMin?: Vec3;\n  /** Maximum settings the camera can scale to */\n  scaleMax?: Vec3;\n  /** The actual screen pixels the bounds can exceed when the camera's view has reached the bounds of the world */\n  screenPadding: { left: number; right: number; top: number; bottom: number };\n  /** This is the view for which the bounds applies towards */\n  view: string;\n  /** The area the camera is bound inside */\n  worldBounds: Bounds;\n}\n\nexport interface IBasicCameraControllerOptions {\n  /** Takes in the options to be used for creating a new ViewBounds object on this controller. */\n  bounds?: ICameraBoundsOptions;\n  /** This is the camera this controller will manipulate */\n  camera: ChartCamera;\n  /** When this is set to true, the start view can be targetted even when behind other views */\n  ignoreCoverViews?: boolean;\n  /**\n   * This provides a control to filter panning that will be applied to the camera. The input and\n   * output of this will be the delta value to be applied.\n   */\n  panFilter?(\n    offset: [number, number, number],\n    view: View,\n    allViews: View[],\n  ): [number, number, number];\n  /**\n   * This adjusts how fast scaling is applied from the mouse wheel\n   */\n  scaleFactor?: number;\n  /**\n   * This provides a control to filter scaling that will be applied to the camera. The input and\n   * output of this will be the delta value to be applied.\n   */\n  scaleFilter?(\n    scale: [number, number, number],\n    view: View,\n    allViews: View[],\n  ): [number, number, number];\n  /**\n   * This is the view that MUST be the start view from the events.\n   * If not provided, then dragging anywhere will adjust the camera\n   */\n  startView?: string | string[];\n\n  /**\n   * This is a handler for when the camera has applied changes to the visible range of what is seen.\n   * Which most likely means offset or scale has been altered.\n   */\n  onRangeChanged?(camera: ChartCamera, targetView: View): void;\n}\n\n/**\n * This provides some very basic common needs for a camera control system. This is not a total solution\n * very every scenario. This should just often handle most basic needs.\n */\nexport class BasicCameraController extends EventManager {\n  /**\n   * If total bounds of worldbounds + screenpadding is smaller\n   * than width or height of view, anchor dictates placement.\n   */\n  bounds?: ICameraBoundsOptions;\n  /** This is the camera that this controller will manipulate */\n  camera: ChartCamera;\n  /** When this is set to true, the start view can be targetted even when behind other views */\n  ignoreCoverViews?: boolean;\n  /** Informative property indicating the controller is panning the chart or not */\n  isPanning: boolean = false;\n  /** This is the filter applied to panning operations */\n  private panFilter = (\n    offset: [number, number, number],\n    view: View,\n    allViews: View[],\n  ) => offset\n  /** The rate scale is adjusted with the mouse wheel */\n  scaleFactor: number;\n  /** THis is the filter applied to tscaling operations */\n  private scaleFilter = (\n    scale: [number, number, number],\n    view: View,\n    allViews: View[],\n  ) => scale\n  /** The view that must be the start or focus of the interactions in order for the interactions to occur */\n  startViews: string[] = [];\n\n  /**\n   * If an unconvered start view is not available, this is the next available covered view, if present\n   */\n  private coveredStartView: View;\n  /**\n   * Callback for when the range has changed for the camera in a view\n   */\n  private onRangeChanged = (camera: ChartCamera, targetView: View) => {\n    /* no-op */\n  }\n  /**\n   * This flag is set to true when a start view is targetted on mouse down even if it is not\n   * the top most view.\n   */\n  private startViewDidStart: boolean = false;\n\n  constructor(options: IBasicCameraControllerOptions) {\n    super();\n    if (options.bounds) {\n      this.setBounds(options.bounds);\n    }\n    this.camera = options.camera;\n    this.scaleFactor = options.scaleFactor || 1000.0;\n    this.ignoreCoverViews = options.ignoreCoverViews || false;\n\n    if (options.startView) {\n      this.startViews = Array.isArray(options.startView)\n        ? options.startView\n        : [options.startView];\n    }\n\n    this.panFilter = options.panFilter || this.panFilter;\n    this.scaleFilter = options.scaleFilter || this.scaleFilter;\n    this.onRangeChanged = options.onRangeChanged || this.onRangeChanged;\n  }\n\n  /**\n   * Corrects camera offset to respect current bounds and anchor.\n   */\n  applyBounds = () => {\n    if (this.bounds && this.camera) {\n      const targetView = this.getView(this.bounds.view);\n      this.applyScaleBounds();\n\n      // Next bound the positioning\n      if (targetView) {\n        this.camera.offset[0] = this.boundsHorizontalOffset(\n          targetView,\n          this.bounds,\n        );\n        this.camera.offset[1] = this.boundsVerticalOffset(\n          targetView,\n          this.bounds,\n        );\n      }\n    }\n  }\n\n  applyScaleBounds = () => {\n    if (this.camera && this.bounds) {\n      // First bound the scaling\n      if (this.bounds.scaleMin) {\n        this.camera.scale = [\n          max(this.camera.scale[0], this.bounds.scaleMin[0]),\n          max(this.camera.scale[1], this.bounds.scaleMin[1]),\n          max(this.camera.scale[2], this.bounds.scaleMin[2]),\n        ];\n      }\n\n      if (this.bounds.scaleMax) {\n        this.camera.scale = [\n          min(this.camera.scale[0], this.bounds.scaleMax[0]),\n          min(this.camera.scale[1], this.bounds.scaleMax[1]),\n          min(this.camera.scale[2], this.bounds.scaleMax[2]),\n        ];\n      }\n    }\n  }\n\n  /**\n   * Calculation for adhering to an anchor - x-axis offset only.\n   */\n  anchoredByBoundsHorizontal(targetView: View, bounds: ICameraBoundsOptions) {\n    switch (bounds.anchor) {\n      case CameraBoundsAnchor.TOP_LEFT:\n      case CameraBoundsAnchor.MIDDLE_LEFT:\n      case CameraBoundsAnchor.BOTTOM_LEFT:\n        return -(\n          bounds.worldBounds.left -\n          bounds.screenPadding.left / this.camera.scale[0]\n        );\n\n      case CameraBoundsAnchor.TOP_MIDDLE:\n      case CameraBoundsAnchor.MIDDLE:\n      case CameraBoundsAnchor.BOTTOM_MIDDLE:\n        return -(\n          bounds.worldBounds.right -\n          bounds.worldBounds.width / 2 -\n          0.5 *\n            ((targetView.screenBounds.width + bounds.screenPadding.right) /\n              this.camera.scale[0])\n        );\n\n      case CameraBoundsAnchor.TOP_RIGHT:\n      case CameraBoundsAnchor.MIDDLE_RIGHT:\n      case CameraBoundsAnchor.BOTTOM_RIGHT:\n        return -(\n          bounds.worldBounds.right -\n          (targetView.screenBounds.width - bounds.screenPadding.right) /\n            this.camera.scale[0]\n        );\n    }\n  }\n\n  /**\n   * Calculation for adhering to an anchor - y-axis offset only.\n   */\n  anchoredByBoundsVertical(targetView: View, bounds: ICameraBoundsOptions) {\n    switch (bounds.anchor) {\n      case CameraBoundsAnchor.TOP_LEFT:\n      case CameraBoundsAnchor.TOP_MIDDLE:\n      case CameraBoundsAnchor.TOP_RIGHT:\n        return (\n          -bounds.worldBounds.top - -bounds.screenPadding.top / this.scale[1]\n        );\n\n      case CameraBoundsAnchor.MIDDLE_LEFT:\n      case CameraBoundsAnchor.MIDDLE:\n      case CameraBoundsAnchor.MIDDLE_RIGHT:\n        return (\n          -(bounds.worldBounds.bottom - bounds.worldBounds.height / 2) +\n          0.5 *\n            (targetView.screenBounds.height - bounds.screenPadding.bottom) /\n            this.scale[1]\n        );\n\n      case CameraBoundsAnchor.BOTTOM_LEFT:\n      case CameraBoundsAnchor.BOTTOM_MIDDLE:\n      case CameraBoundsAnchor.BOTTOM_RIGHT:\n        return -(\n          bounds.worldBounds.bottom -\n          (targetView.screenBounds.height - bounds.screenPadding.bottom) /\n            this.scale[1]\n        );\n    }\n  }\n\n  /**\n   * Returns offset on x-axis due to current bounds and anchor.\n   */\n  boundsHorizontalOffset(targetView: View, bounds: ICameraBoundsOptions) {\n    const worldTLinScreenSpace = targetView.worldToScreen({\n      x: bounds.worldBounds.left,\n      y: bounds.worldBounds.top,\n    });\n    const worldBRinScreenSpace = targetView.worldToScreen({\n      x: bounds.worldBounds.right,\n      y: bounds.worldBounds.bottom,\n    });\n\n    const widthDifference =\n      worldBRinScreenSpace.x -\n      worldTLinScreenSpace.x +\n      bounds.screenPadding.left +\n      bounds.screenPadding.right -\n      targetView.screenBounds.width;\n\n    // If the worldBounds are smaller than the screenBounds,\n    // We offset according to the anchoring\n    if (widthDifference < 0) {\n      return this.anchoredByBoundsHorizontal(targetView, bounds);\n    }\n\n    if (\n      worldBRinScreenSpace.x <\n      targetView.screenBounds.right - bounds.screenPadding.right\n    ) {\n      return (\n        -bounds.worldBounds.right +\n        (targetView.screenBounds.width - bounds.screenPadding.right) /\n          this.camera.scale[0]\n      );\n    }\n\n    if (\n      worldTLinScreenSpace.x >\n      targetView.screenBounds.left + bounds.screenPadding.left\n    ) {\n      return (\n        -bounds.worldBounds.left +\n        bounds.screenPadding.left / this.camera.scale[0]\n      );\n    }\n\n    return this.camera.offset[0];\n  }\n\n  /**\n   * Returns offset on y-axis due to current bounds and anchor.\n   */\n  boundsVerticalOffset(targetView: View, bounds: ICameraBoundsOptions) {\n    const worldTLinScreenSpace = targetView.worldToScreen({\n      x: bounds.worldBounds.left,\n      y: bounds.worldBounds.top,\n    });\n    const worldBRinScreenSpace = targetView.worldToScreen({\n      x: bounds.worldBounds.right,\n      y: bounds.worldBounds.bottom,\n    });\n\n    const heightDifference =\n      worldBRinScreenSpace.y -\n      worldTLinScreenSpace.y +\n      bounds.screenPadding.top +\n      bounds.screenPadding.bottom -\n      targetView.screenBounds.height;\n\n    // If the viewBounds are larger than the screenBounds,\n    // We offset according to the anchoring\n    if (heightDifference < 0) {\n      return this.anchoredByBoundsVertical(targetView, bounds);\n    }\n\n    if (\n      worldTLinScreenSpace.y >\n      targetView.screenBounds.top - bounds.screenPadding.top\n    ) {\n      return -(\n        bounds.worldBounds.top -\n        bounds.screenPadding.top / this.camera.scale[1]\n      );\n    }\n\n    if (\n      worldBRinScreenSpace.y <\n      targetView.screenBounds.bottom + bounds.screenPadding.bottom\n    ) {\n      return -(\n        bounds.worldBounds.bottom +\n        (-targetView.screenBounds.height + bounds.screenPadding.bottom) /\n          this.camera.scale[1]\n      );\n    }\n\n    return this.camera.offset[1];\n  }\n\n  private canStart(viewId: string) {\n    return (\n      this.startViews.length === 0 ||\n      (this.startViews && this.startViews.indexOf(viewId) > -1) ||\n      (this.startViewDidStart && this.ignoreCoverViews)\n    );\n  }\n\n  private findCoveredStartView(e: IMouseInteraction) {\n    const found = e.viewsUnderMouse.find(\n      under => this.startViews.indexOf(under.view.id) > -1,\n    );\n    this.startViewDidStart = Boolean(found);\n\n    if (found) {\n      this.coveredStartView = found.view;\n    }\n  }\n\n  private getTargetView(e: IMouseInteraction) {\n    // If we have a start view and we do not ignore covering views,\n    // Then our target view is the view we started with\n    if (this.startViews && !this.ignoreCoverViews) {\n      return e.target.view;\n    }\n\n    // Otherwise, we use the covered start view\n    else {\n      return this.coveredStartView;\n    }\n  }\n\n  /**\n   * Used to aid in handling the pan effect and determine the contextual view targetted.\n   */\n  handleMouseDown(e: IMouseInteraction, button: number) {\n    if (this.startViews) {\n      // We look for valid covered views on mouse down so dragging will work\n      this.findCoveredStartView(e);\n      // If this is a valid start view, then we enter a panning state with the mouse down\n      if (e.start) {\n        this.isPanning = this.canStart(e.start.view.id) || this.isPanning;\n      }\n    }\n  }\n\n  /**\n   * Used to aid in handling the pan effect\n   */\n  handleMouseUp(e: IMouseInteraction) {\n    this.startViewDidStart = false;\n    this.isPanning = false;\n  }\n\n  /**\n   * Applies a panning effect by adjusting the camera's offset.\n   */\n  handleDrag(e: IMouseInteraction, drag: IDragMetrics) {\n    if (e.start) {\n      if (this.canStart(e.start.view.id)) {\n        let pan: [number, number, number] = [\n          drag.screen.delta.x / this.camera.scale[0],\n          drag.screen.delta.y / this.camera.scale[1],\n          0,\n        ];\n\n        if (this.panFilter) {\n          pan = this.panFilter(\n            pan,\n            e.start.view,\n            e.viewsUnderMouse.map(v => v.view),\n          );\n        }\n\n        this.camera.offset[0] += pan[0];\n        this.camera.offset[1] += pan[1];\n\n        // Add additional correction for bounds\n        this.applyBounds();\n        // Broadcast the change occurred\n        this.onRangeChanged(this.camera, e.start.view);\n        // Add additional correction for bounds\n        this.applyBounds();\n      }\n    }\n  }\n\n  /**\n   * Applies a scaling effect to the camera for mouse wheel events\n   */\n  handleWheel(e: IMouseInteraction, wheelMetrics: IWheelMetrics) {\n    // Every mouse wheel event must look to see if it's over a valid covered start view\n    this.findCoveredStartView(e);\n\n    if (this.canStart(e.target.view.id)) {\n      const targetView = this.getTargetView(e);\n      const beforeZoom = targetView.screenToWorld(e.screen.mouse);\n\n      const currentZoomX = this.camera.scale[0] || 1.0;\n      const currentZoomY = this.camera.scale[1] || 1.0;\n\n      let scale: [number, number, number] = [\n        wheelMetrics.wheel[1] / this.scaleFactor * currentZoomX,\n        wheelMetrics.wheel[1] / this.scaleFactor * currentZoomY,\n        1,\n      ];\n\n      if (this.scaleFilter) {\n        scale = this.scaleFilter(\n          scale,\n          targetView,\n          e.viewsUnderMouse.map(v => v.view),\n        );\n      }\n\n      this.camera.scale[0] = currentZoomX + scale[0];\n      this.camera.scale[1] = currentZoomY + scale[1];\n\n      // Ensure the new scale values are within bounds before attempting to correct offsets\n      this.applyScaleBounds();\n\n      const afterZoom = targetView.screenToWorld(e.screen.mouse);\n      this.camera.offset[0] -= beforeZoom.x - afterZoom.x;\n      this.camera.offset[1] -= beforeZoom.y - afterZoom.y;\n\n      // Add additional correction for bounds\n      this.applyBounds();\n      // Broadcast the change occurred\n      this.onRangeChanged(this.camera, targetView);\n      // Add additional correction for bounds\n      this.applyBounds();\n    }\n  }\n\n  // These are the currently Unused responses for this controller\n  handleMouseOut(e: IMouseInteraction) {\n    /*no-op*/\n  }\n  handleClick(e: IMouseInteraction) {\n    /*no-op*/\n  }\n  handleMouseMove(e: IMouseInteraction) {\n    /*no-op*/\n  }\n  handleMouseOver(e: IMouseInteraction) {\n    /*no-op*/\n  }\n\n  /**\n   * Evaluates the world bounds the specified view is observing\n   *\n   * @param viewId The id of the view when the view was generated when the surface was made\n   */\n  getRange(viewId: string): Bounds {\n    /** Get the projections for the provided view */\n    const projection = this.getProjection(viewId);\n    /** Get the bounds on the screen for the indicated view */\n    const screenBounds = this.getViewScreenBounds(viewId);\n\n    // Make sure we have a valid projection and screen bounds to make the adjustment\n    if (projection && screenBounds) {\n      /** Get the current viewed world bounds of the view */\n      const topLeft = projection.screenToWorld(screenBounds);\n      const bottomRight = projection.screenToWorld({\n        x: screenBounds.right,\n        y: screenBounds.bottom,\n      });\n\n      return new Bounds({\n        height: bottomRight.y - topLeft.y,\n        width: bottomRight.x - topLeft.x,\n        x: topLeft.x,\n        y: topLeft.y,\n      });\n    }\n\n    return new Bounds({ x: 0, y: 0, width: 1, height: 1 });\n  }\n\n  /**\n   * Retrieves the current pan of the controlled camera\n   */\n  get pan(): Vec3 {\n    return this.camera.offset;\n  }\n\n  /**\n   * Sets bounds applicable to the supplied view.\n   * If no view is supplied, it uses the first in the startViews array\n   */\n  setBounds(bounds: ICameraBoundsOptions) {\n    this.bounds = bounds;\n    this.applyBounds();\n  }\n\n  /**\n   * Retrieves the current scale of the camera\n   */\n  get scale(): Vec3 {\n    return this.camera.scale;\n  }\n\n  /**\n   * This lets you set the visible range of a view based on the view's camera. This will probably not work\n   * as expected if the view indicated and this controller do not share the same camera.\n   *\n   * @param viewId The id of the view when the view was generated when the surface was made\n   */\n  setRange(newWorld: Bounds, viewId: string) {\n    /** Get the projections for the provided view */\n    const projection = this.getProjection(viewId);\n    /** Get the bounds on the screen for the indicated view */\n    const screenBounds = this.getViewScreenBounds(viewId);\n    /** Get the view the range is being applied towards */\n    const view = this.getView(viewId);\n\n    // Make sure we have a valid projection and screen bounds to make the adjustment\n    if (projection && screenBounds && view) {\n      const deltaScale = subtract3(\n        [\n          screenBounds.width / newWorld.width,\n          screenBounds.height / newWorld.height,\n          1,\n        ],\n        this.camera.scale,\n      );\n\n      this.camera.scale = add3(\n        this.camera.scale,\n        this.scaleFilter(deltaScale, view, [view]),\n      );\n\n      const deltaPan = subtract3(\n        [-newWorld.x, -newWorld.y, 0],\n        this.camera.offset,\n      );\n\n      this.camera.offset = add3(\n        this.camera.offset,\n        this.scaleFilter(deltaPan, view, [view]),\n      );\n\n      // Bound the camera to the specified bounding range\n      this.applyBounds();\n      // Broadcast the change occurred\n      this.onRangeChanged(this.camera, view);\n      // Bound the camera to the specified bounding range\n      this.applyBounds();\n    }\n  }\n}\n","export * from './basic-camera-controller';\n","export * from './base-event-managers';\nexport * from './base-layers';\nexport * from './instance-provider';\nexport * from './primitives';\nexport * from './surface';\nexport * from './types';\nexport * from './util';\n","export * from './voidgl';\n"],"sourceRoot":""}