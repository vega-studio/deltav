{"version":3,"sources":["webpack://network-bubble-chart/webpack/universalModuleDefinition","webpack://network-bubble-chart/webpack/bootstrap","webpack://network-bubble-chart/./src/types.ts","webpack://network-bubble-chart/./src/instance-provider/index.ts","webpack://network-bubble-chart/./src/math/vector.ts","webpack://network-bubble-chart/./src/util/index.ts","webpack://network-bubble-chart/./src/gl/index.ts","webpack://network-bubble-chart/./node_modules/debug/src/browser.js","webpack://network-bubble-chart/./src/2d/view/layer-2d.ts","webpack://network-bubble-chart/./src/math/primitives/bounds.ts","webpack://network-bubble-chart/./src/util/uid.ts","webpack://network-bubble-chart/./src/shaders/processing/index.ts","webpack://network-bubble-chart/./src/gl/gl-settings.ts","webpack://network-bubble-chart/./src/instance-provider/instance.ts","webpack://network-bubble-chart/./src/math/index.ts","webpack://network-bubble-chart/./src/surface/index.ts","webpack://network-bubble-chart/./src/gl/webgl-stat.ts","webpack://network-bubble-chart/./src/gl/texture.ts","webpack://network-bubble-chart/./src/util/camera.ts","webpack://network-bubble-chart/./src/util/identify-by-key.ts","webpack://network-bubble-chart/./src/util/create-layer.ts","webpack://network-bubble-chart/./src/2d/types.ts","webpack://network-bubble-chart/./src/instance-provider/observable.ts","webpack://network-bubble-chart/./src/resources/base-resource-manager.ts","webpack://network-bubble-chart/./src/2d/index.ts","webpack://network-bubble-chart/./src/resources/index.ts","webpack://network-bubble-chart/./src/resources/texture/sub-texture.ts","webpack://network-bubble-chart/./src/processing/post-process.ts","webpack://network-bubble-chart/./src/gl/types.ts","webpack://network-bubble-chart/./src/surface/view.ts","webpack://network-bubble-chart/./src/util/frame.ts","webpack://network-bubble-chart/./src/util/promise-resolver.ts","webpack://network-bubble-chart/./src/surface/buffer-management/buffer-manager-base.ts","webpack://network-bubble-chart/./src/surface/layer-processing/base-io-expansion.ts","webpack://network-bubble-chart/./src/resources/texture/pack-node.ts","webpack://network-bubble-chart/./src/shaders/index.ts","webpack://network-bubble-chart/./src/event-management/event-manager.ts","webpack://network-bubble-chart/./src/instance-provider/instance-provider.ts","webpack://network-bubble-chart/./src/math/matrix.ts","webpack://network-bubble-chart/./src/surface/layer.ts","webpack://network-bubble-chart/./src/util/shader-templating.ts","webpack://network-bubble-chart/./src/surface/layer-processing/generate-layer-model.ts","webpack://network-bubble-chart/./src/2d/view/camera-2d.ts","webpack://network-bubble-chart/./src/2d/view/control-2d.ts","webpack://network-bubble-chart/./src/resources/texture/texture-io-expansion.ts","webpack://network-bubble-chart/./src/event-management/simple-event-handler.ts","webpack://network-bubble-chart/./src/gl/gl-decode.ts","webpack://network-bubble-chart/./src/gl/render-target.ts","webpack://network-bubble-chart/./src/math/primitives/index.ts","webpack://network-bubble-chart/./src/math/base-projection.ts","webpack://network-bubble-chart/./src/resources/color-buffer/index.ts","webpack://network-bubble-chart/./src/resources/texture/render-texture.ts","webpack://network-bubble-chart/./src/resources/texture/render-texture-resource-request.ts","webpack://network-bubble-chart/./src/3d/scene-graph/transform.ts","webpack://network-bubble-chart/./src/math/auto-easing-method.ts","webpack://network-bubble-chart/./src/3d/scene-graph/transform-base.ts","webpack://network-bubble-chart/./src/3d/scene-graph/tree-node.ts","webpack://network-bubble-chart/./src/util/common-filters.ts","webpack://network-bubble-chart/./src/util/common-operations.ts","webpack://network-bubble-chart/./src/util/create-attribute.ts","webpack://network-bubble-chart/./src/surface/layer-processing/index.ts","webpack://network-bubble-chart/./src/constants.ts","webpack://network-bubble-chart/./src/surface/layer-scene.ts","webpack://network-bubble-chart/./src/util/reactive-diff.ts","webpack://network-bubble-chart/./src/util/common-options.ts","webpack://network-bubble-chart/./src/resources/text/font-resource-request.ts","webpack://network-bubble-chart/./src/resources/texture/atlas.ts","webpack://network-bubble-chart/./src/2d/layers/labels/label-instance.ts","webpack://network-bubble-chart/./src/processing/base-effects/box-sample/box-sample.ts","webpack://network-bubble-chart/./src/event-management/user-input-event-manager.ts","webpack://network-bubble-chart/./src/gl/gl-proxy.ts","webpack://network-bubble-chart/./src/gl/color-buffer.ts","webpack://network-bubble-chart/./node_modules/process/browser.js","webpack://network-bubble-chart/./src/gl/gl-state.ts","webpack://network-bubble-chart/./src/gl/scene.ts","webpack://network-bubble-chart/./src/gl/webgl-renderer.ts","webpack://network-bubble-chart/./src/math/primitives/absolute-position.ts","webpack://network-bubble-chart/./src/util/easing-props.ts","webpack://network-bubble-chart/./src/resources/color-buffer/color-buffer-resource.ts","webpack://network-bubble-chart/./src/math/quaternion.ts","webpack://network-bubble-chart/./src/math/ray.ts","webpack://network-bubble-chart/./src/util/shallow-compare.ts","webpack://network-bubble-chart/./src/util/remove-comments.ts","webpack://network-bubble-chart/./src/shaders/processing/inject-shader-io.ts","webpack://network-bubble-chart/./src/shaders/processing/pack-attributes.ts","webpack://network-bubble-chart/./src/shaders/processing/shader-module.ts","webpack://network-bubble-chart/./src/shaders/processing/shader-module-unit.ts","webpack://network-bubble-chart/./src/surface/buffer-management/index.ts","webpack://network-bubble-chart/./src/surface/layer-processing/generate-default-scene.ts","webpack://network-bubble-chart/./src/shaders/processing/base-shader-io-injection.ts","webpack://network-bubble-chart/./src/surface/layer-processing/base-io-expanders/easing-io-expansion.ts","webpack://network-bubble-chart/./src/surface/layer-processing/base-io-expanders/basic-io-expansion.ts","webpack://network-bubble-chart/./src/surface/layer-processing/base-io-expanders/active-io-expansion.ts","webpack://network-bubble-chart/./src/util/emit-once.ts","webpack://network-bubble-chart/./src/surface/buffer-management/uniform-buffering/uniform-buffer-manager.ts","webpack://network-bubble-chart/./src/surface/buffer-management/base-diff-processor.ts","webpack://network-bubble-chart/./src/surface/layer-interaction-handler.ts","webpack://network-bubble-chart/./src/util/mouse.ts","webpack://network-bubble-chart/./src/util/quad-tree.ts","webpack://network-bubble-chart/./src/event-management/queued-event-handler.ts","webpack://network-bubble-chart/./src/shaders/processing/base-io-sorting.ts","webpack://network-bubble-chart/./src/resources/text/index.ts","webpack://network-bubble-chart/./src/resources/text/font-manager.ts","webpack://network-bubble-chart/./src/util/wait-for-valid-dimensions.ts","webpack://network-bubble-chart/./src/util/create-uniform.ts","webpack://network-bubble-chart/./src/util/create-vertex.ts","webpack://network-bubble-chart/./src/resources/text/font-map.ts","webpack://network-bubble-chart/./src/resources/text/font-renderer.ts","webpack://network-bubble-chart/./src/resources/text/glyph-renderer.ts","webpack://network-bubble-chart/./src/resources/texture/index.ts","webpack://network-bubble-chart/./src/resources/texture/atlas-manager.ts","webpack://network-bubble-chart/./src/resources/texture/image-rasterizer.ts","webpack://network-bubble-chart/./src/resources/texture/atlas-resource-manager.ts","webpack://network-bubble-chart/./src/resources/texture/render-texture-resource-manager.ts","webpack://network-bubble-chart/./src/surface/event-managers/layer-mouse-events.ts","webpack://network-bubble-chart/./src/2d/shader-modules/shader-fragments/world-2d-projection.vs","webpack://network-bubble-chart/./src/2d/view/index.ts","webpack://network-bubble-chart/./src/2d/layers/edges/types.ts","webpack://network-bubble-chart/./src/2d/layers/labels/label-layer.ts","webpack://network-bubble-chart/./src/2d/layers/labels/glyph-instance.ts","webpack://network-bubble-chart/./src/2d/layers/labels/glyph-layer.ts","webpack://network-bubble-chart/./src/2d/layers/labels/glyph-layer-always.fs","webpack://network-bubble-chart/./src/2d/layers/labels/glyph-layer-always.vs","webpack://network-bubble-chart/./src/2d/layers/labels/text-area-instance.ts","webpack://network-bubble-chart/./src/2d/layers/rectangle/rectangle-instance.ts","webpack://network-bubble-chart/./src/3d/view/view-3d.ts","webpack://network-bubble-chart/./src/3d/view/projection-3d.ts","webpack://network-bubble-chart/./src/3d/scene-graph/index.ts","webpack://network-bubble-chart/./src/3d/scene-graph/scene-graph-layer.ts","webpack://network-bubble-chart/./src/3d/scene-graph/instance-3d.ts","webpack://network-bubble-chart/./src/processing/view/projection-screen.ts","webpack://network-bubble-chart/./src/processing/base-effects/gauss-horizontal-blur/gauss-horizontal-blur.ts","webpack://network-bubble-chart/./src/processing/base-effects/gauss-vertical-blur/gauss-vertical-blur.ts","webpack://network-bubble-chart/./src/processing/base-effects/bloom/bloom.ts","webpack://network-bubble-chart/./src/processing/base-effects/draw/draw.ts","webpack://network-bubble-chart/./src/index.ts","webpack://network-bubble-chart/./src/util/webgl2-type-shim.ts","webpack://network-bubble-chart/./src/event-management/index.ts","webpack://network-bubble-chart/./src/event-management/types.ts","webpack://network-bubble-chart/./src/gl/attribute.ts","webpack://network-bubble-chart/./src/gl/geometry.ts","webpack://network-bubble-chart/./node_modules/debug/src/debug.js","webpack://network-bubble-chart/./node_modules/ms/index.js","webpack://network-bubble-chart/./src/gl/material.ts","webpack://network-bubble-chart/./src/gl/model.ts","webpack://network-bubble-chart/./src/instance-provider/basic-instance.ts","webpack://network-bubble-chart/./src/resources/color-buffer/color-buffer-resource-manager.ts","webpack://network-bubble-chart/./src/resources/color-buffer/color-buffer-resource-request.ts","webpack://network-bubble-chart/./src/shaders/processing/shader-processor.ts","webpack://network-bubble-chart/./src/shaders/template-vars.ts","webpack://network-bubble-chart/./src/shaders/processing/metrics-processing.ts","webpack://network-bubble-chart/./src/surface/layer-processing/generate-layer-material.ts","webpack://network-bubble-chart/./src/surface/layer-processing/generate-layer-geometry.ts","webpack://network-bubble-chart/./src/surface/layer-processing/base-io-expanders/index.ts","webpack://network-bubble-chart/./src/surface/layer-processing/base-io-expanders/fragments/active-attribute-handler.vs","webpack://network-bubble-chart/./src/surface/buffer-management/instance-attribute-buffering/instance-attribute-buffer-manager.ts","webpack://network-bubble-chart/./src/surface/buffer-management/instance-attribute-packed-buffering/instance-attribute-packing-buffer-manager.ts","webpack://network-bubble-chart/./src/surface/buffer-management/instance-diff-manager.ts","webpack://network-bubble-chart/./src/surface/buffer-management/instance-attribute-buffering/instance-attribute-diff-processor.ts","webpack://network-bubble-chart/./src/surface/buffer-management/uniform-buffering/uniform-diff-processor.ts","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/picking.fs","webpack://network-bubble-chart/./src/util/normalize-wheel/index.ts","webpack://network-bubble-chart/./src/util/normalize-wheel/normalizeWheel.ts","webpack://network-bubble-chart/./src/util/normalize-wheel/UserAgent_DEPRECATED.js","webpack://network-bubble-chart/./src/util/normalize-wheel/isEventSupported.js","webpack://network-bubble-chart/./src/util/normalize-wheel/ExecutionEnvironment.js","webpack://network-bubble-chart/./src/2d/shader-modules/index.ts","webpack://network-bubble-chart/./src/2d/shader-modules/world-2d.shader.ts","webpack://network-bubble-chart/./src/surface/surface.ts","webpack://network-bubble-chart/./src/resources/text/cpu-sdf.ts","webpack://network-bubble-chart/./src/util/easing-util.ts","webpack://network-bubble-chart/./src/util/wait.ts","webpack://network-bubble-chart/./src/util/create.ts","webpack://network-bubble-chart/./src/resources/text/svg-to-data.ts","webpack://network-bubble-chart/./src/resources/text/font-resource-manager.ts","webpack://network-bubble-chart/./src/resources/texture/video-texture-monitor.ts","webpack://network-bubble-chart/./src/resources/texture/atlas-resource-request.ts","webpack://network-bubble-chart/./src/resources/resource-router.ts","webpack://network-bubble-chart/./src/surface/layer-processing/base-shader-transforms/shaders-30-compatibility-transform.ts","webpack://network-bubble-chart/./src/shaders/processing/base-shader-transform.ts","webpack://network-bubble-chart/./src/surface/surface-commands.ts","webpack://network-bubble-chart/./src/surface/event-managers/index.ts","webpack://network-bubble-chart/./src/surface/command-layer.ts","webpack://network-bubble-chart/./src/2d/view/basic-camera-2d-controller.ts","webpack://network-bubble-chart/./src/2d/view/reference-camera-2d.ts","webpack://network-bubble-chart/./src/2d/view/view-2d.ts","webpack://network-bubble-chart/./src/2d/view/projection-2d.ts","webpack://network-bubble-chart/./src/2d/layers/index.ts","webpack://network-bubble-chart/./src/2d/layers/arcs/index.ts","webpack://network-bubble-chart/./src/2d/layers/arcs/arc-layer.ts","webpack://network-bubble-chart/./src/2d/layers/arcs/arc-layer.vs","webpack://network-bubble-chart/./src/2d/layers/arcs/arc-layer-screen-space.vs","webpack://network-bubble-chart/./src/2d/layers/arcs/arc-layer.fs","webpack://network-bubble-chart/./src/2d/layers/arcs/arc-instance.ts","webpack://network-bubble-chart/./src/2d/layers/circles/index.ts","webpack://network-bubble-chart/./src/2d/layers/circles/circle-layer.ts","webpack://network-bubble-chart/./src/2d/layers/circles/circle-layer-points.fs","webpack://network-bubble-chart/./src/2d/layers/circles/circle-layer.fs","webpack://network-bubble-chart/./src/2d/layers/circles/circle-layer-points.vs","webpack://network-bubble-chart/./src/2d/layers/circles/circle-layer.vs","webpack://network-bubble-chart/./src/2d/layers/circles/circle-instance.ts","webpack://network-bubble-chart/./src/2d/layers/edges/index.ts","webpack://network-bubble-chart/./src/2d/layers/edges/edge-layer.ts","webpack://network-bubble-chart/./src/2d/layers/edges/shader/edge-layer-line.vs","webpack://network-bubble-chart/./src/2d/layers/edges/shader/edge-layer-bezier.vs","webpack://network-bubble-chart/./src/2d/layers/edges/shader/edge-layer-bezier2.vs","webpack://network-bubble-chart/./src/2d/layers/edges/shader/edge-layer.vs","webpack://network-bubble-chart/./src/2d/layers/edges/shader/edge-layer-screen-curve.vs","webpack://network-bubble-chart/./src/2d/layers/edges/shader/edge-layer.fs","webpack://network-bubble-chart/./src/2d/layers/edges/edge-instance.ts","webpack://network-bubble-chart/./src/2d/layers/images/index.ts","webpack://network-bubble-chart/./src/2d/layers/images/image-layer.ts","webpack://network-bubble-chart/./src/2d/layers/images/debug-video.ts","webpack://network-bubble-chart/./src/2d/layers/images/image-render-layer.ts","webpack://network-bubble-chart/./src/2d/layers/images/image-layer.fs","webpack://network-bubble-chart/./src/2d/layers/images/image-layer.vs","webpack://network-bubble-chart/./src/2d/layers/images/image-instance.ts","webpack://network-bubble-chart/./src/2d/layers/labels/index.ts","webpack://network-bubble-chart/./src/2d/layers/labels/text-area-layer-bound-max.fs","webpack://network-bubble-chart/./src/2d/layers/labels/glyph-layer-bound-max.fs","webpack://network-bubble-chart/./src/2d/layers/labels/text-area-layer-bound-max.vs","webpack://network-bubble-chart/./src/2d/layers/labels/glyph-layer-bound-max.vs","webpack://network-bubble-chart/./src/2d/layers/labels/glyph-layer-never.fs","webpack://network-bubble-chart/./src/2d/layers/labels/text-area-layer-never.fs","webpack://network-bubble-chart/./src/2d/layers/labels/text-area-layer-never.vs","webpack://network-bubble-chart/./src/2d/layers/labels/glyph-layer-never.vs","webpack://network-bubble-chart/./src/2d/layers/labels/text-area-layer-always.fs","webpack://network-bubble-chart/./src/2d/layers/labels/text-area-layer-always.vs","webpack://network-bubble-chart/./src/2d/layers/labels/text-area-layer.ts","webpack://network-bubble-chart/./src/2d/layers/labels/border-instance.ts","webpack://network-bubble-chart/./src/2d/layers/labels/border-layer.ts","webpack://network-bubble-chart/./src/2d/layers/labels/border-layer.fs","webpack://network-bubble-chart/./src/2d/layers/labels/border-layer.vs","webpack://network-bubble-chart/./src/2d/layers/rectangle/index.ts","webpack://network-bubble-chart/./src/2d/layers/rectangle/rectangle-layer.ts","webpack://network-bubble-chart/./src/2d/layers/rectangle/rectangle-layer.fs","webpack://network-bubble-chart/./src/2d/layers/rectangle/rectangle-layer.vs","webpack://network-bubble-chart/./src/2d/layers/rings/index.ts","webpack://network-bubble-chart/./src/2d/layers/rings/ring-instance.ts","webpack://network-bubble-chart/./src/2d/layers/rings/ring-layer.ts","webpack://network-bubble-chart/./src/2d/layers/rings/ring-layer.fs","webpack://network-bubble-chart/./src/2d/layers/rings/ring-layer.vs","webpack://network-bubble-chart/./src/3d/index.ts","webpack://network-bubble-chart/./src/3d/shader-modules/index.ts","webpack://network-bubble-chart/./src/3d/shader-modules/world-2d-xy.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/index.ts","webpack://network-bubble-chart/./src/shaders/base-modules/camera-metrics.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/projection.vs","webpack://network-bubble-chart/./src/shaders/base-modules/frame-metrics.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/hsv.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/hsv.vs","webpack://network-bubble-chart/./src/shaders/base-modules/instancing.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/math.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/constants/pi_inv.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/constants/pi2_inv.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/constants/pi_2.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/constants/pi_4.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/constants/pi.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/constants/pi2.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/constants/to-degrees.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/constants/to-radians.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/bezier1.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/bezier2.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/arc.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/fmod.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/wrap.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/fcos.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/fsin.vs","webpack://network-bubble-chart/./src/shaders/base-modules/matrix.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/matrix/translation.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/matrix/rotation.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/matrix/scale.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/matrix/transform.vs","webpack://network-bubble-chart/./src/shaders/base-modules/pack-float.ts","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/pack-float.vs","webpack://network-bubble-chart/./src/shaders/base-modules/picking.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/picking.vs","webpack://network-bubble-chart/./src/shaders/base-modules/util.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/no-op.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/no-op.fs","webpack://network-bubble-chart/./src/3d/shader-modules/world-2d-xz.shader.ts","webpack://network-bubble-chart/./src/3d/shader-modules/shader-fragments/world-2d-xz-projection.vs","webpack://network-bubble-chart/./src/3d/shader-modules/world-2d-yz.shader.ts","webpack://network-bubble-chart/./src/3d/shader-modules/shader-fragments/world-2d-yz-projection.vs","webpack://network-bubble-chart/./src/3d/view/index.ts","webpack://network-bubble-chart/./src/3d/view/layer-2d-in-3d.ts","webpack://network-bubble-chart/./src/3d/scene-graph/parent-transform.shader.ts","webpack://network-bubble-chart/./src/3d/scene-graph/transform-2d.ts","webpack://network-bubble-chart/./src/3d/layers/index.ts","webpack://network-bubble-chart/./src/3d/layers/cube/index.ts","webpack://network-bubble-chart/./src/3d/layers/cube/cube-layer.ts","webpack://network-bubble-chart/./src/3d/layers/cube/cube-layer.fs","webpack://network-bubble-chart/./src/3d/layers/cube/cube-layer.vs","webpack://network-bubble-chart/./src/3d/layers/cube/cube-instance.ts","webpack://network-bubble-chart/./src/base-surfaces/index.ts","webpack://network-bubble-chart/./src/base-surfaces/basic-surface.ts","webpack://network-bubble-chart/./node_modules/node-libs-browser/node_modules/util/util.js","webpack://network-bubble-chart/./node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js","webpack://network-bubble-chart/./node_modules/node-libs-browser/node_modules/util/node_modules/inherits/inherits_browser.js","webpack://network-bubble-chart/./src/util-layers/index.ts","webpack://network-bubble-chart/./src/util-layers/log-changes-layer.ts","webpack://network-bubble-chart/./src/processing/index.ts","webpack://network-bubble-chart/./src/processing/layer/post-process-layer.ts","webpack://network-bubble-chart/./src/util/array.ts","webpack://network-bubble-chart/./src/processing/layer/post-process-layer.vs","webpack://network-bubble-chart/./src/processing/view/view-screen.ts","webpack://network-bubble-chart/./src/processing/base-effects/index.ts","webpack://network-bubble-chart/./src/processing/base-effects/gauss-horizontal-blur/gauss-horizontal-blur.fs","webpack://network-bubble-chart/./src/processing/base-effects/gauss-vertical-blur/gauss-vertical-blur.fs","webpack://network-bubble-chart/./src/processing/base-effects/box-sample/box-sample.fs","webpack://network-bubble-chart/./src/processing/base-effects/bloom/bloom.fs","webpack://network-bubble-chart/./src/processing/commands.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","sqrt","max","min","floor","ceil","abs","acos","sin","load","storage","debug","e","process","env","DEBUG","log","console","Function","apply","arguments","formatArgs","args","useColors","this","namespace","humanize","diff","color","splice","index","lastC","replace","match","save","namespaces","removeItem","type","navigator","userAgent","toLowerCase","document","documentElement","style","WebkitAppearance","firebug","exception","table","parseInt","RegExp","$1","chrome","local","localStorage","localstorage","colors","formatters","j","v","JSON","stringify","err","message","enable","Layer2D","x","y","Bounds","Texture","Instance","WebGLStat","Camera","IdentifyByKey","IdentifiableData","ObservableMonitoring","BaseResourceManager","InvalidResourceManager","SubTexture","output","target","View","NoView","commandFn","command","interval","intervalStartTime","duration","durationStartTime","startTime","PromiseResolver","BufferManagerBase","BaseIOExpansion","PackNode","EventManager","instance","InstanceProvider","cos","tan","u","z","a","b","f","g","h","mapOutput","Boolean","streamChanges","stream","streamIndex","Layer","shader","options","required","onError","onToken","onMain","Camera2D","Control2D","list","TextureIOExpansion","SimpleEventHandler","width","height","RenderTarget","BaseProjection","SimpleProjection","RenderTexture","Transform","pow","round","PI","delay","loop","add","scale","subtract","slerpQuat","vec","AutoEasingMethod","TreeNode","touch","LayerScene","ReactiveDiff","CommonMaterialOptions","Atlas","LabelInstance","input","UserInputEventManager","vsId","programId","ext","stat","GLProxy","ColorBuffer","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","Array","push","title","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","uniform","GLState","Scene","bufferType","canvas","pixelRatio","WebGLRenderer","EasingProps","ColorBufferResource","exp","atan2","roll","pitch","yaw","ShaderModule","ShaderModuleUnit","BaseShaderIOInjection","size","update","EasingIOExpansion","BasicIOExpansion","instanceAttributes","ActiveIOExpansion","UniformBufferManager","BaseDiffProcessor","onMouseDown","onTouchDown","onTouchOver","onMouseOut","onTouchOut","onMouseUp","onMouseUpOutside","onTouchUp","onTouchUpOutside","onTouchAllEnd","onMouseOver","onMouseMove","onTouchMove","onMouseClick","onTap","LayerInteractionHandler","normalizeWheel","eventElementPosition","QuadTreeQuadrants","QuadTreeNode","QuadTree","preserveEvents","QueuedEventHandler","BaseIOSorting","FontManager","FontMap","FontRenderer","AtlasManager","ImageRasterizer","layer","AtlasResourceManager","RenderTextureResourceManager","LayerMouseEvents","diffType","changed","LabelLayer","GlyphInstance","GlyphLayer","TextAreaInstance","RectangleInstance","View3D","projectionOptions","fov","near","Projection3D","SceneGraphLayer","Instance3D","ProjectionScreen","compose","resources","channel","grayScale","isDynamic","isInstanced","Attribute","Geometry","createDebug","prevTime","enabled","self","curr","Date","ms","prev","coerce","unshift","format","formatter","val","logFn","hash","charCodeAt","Math","selectColor","destroy","init","instances","indexOf","stack","disable","names","skips","split","substr","test","plural","str","String","exec","parseFloat","parse","isNaN","long","fmtShort","Material","Model","BasicInstance","ColorBufferResourceManager","ShaderProcessor","MetricsProcessing","InstanceAttributeBufferManager","attributes","InstanceAttributePackingBufferManager","InstanceDiffManager","InstanceAttributeDiffProcessor","UniformDiffProcessor","_ie","_firefox","_opera","_webkit","_chrome","_ie_real_version","_osx","_windows","_linux","_android","_win64","_iphone","_ipad","_native","_mobile","_populated","_populate","uas","agent","os","NaN","documentMode","trident","ver","UserAgent_DEPRECATED","ie","ieCompatibilityMode","ie64","firefox","opera","webkit","safari","windows","osx","linux","iphone","mobile","nativeApp","android","ipad","useHasFeature","ExecutionEnvironment","canUseDOM","implementation","hasFeature","eventNameSuffix","capture","eventName","isSupported","element","createElement","setAttribute","canUseWorkers","Worker","canUseEventListeners","addEventListener","attachEvent","canUseViewport","screen","isInWorker","Surface","log2","negate","mapMethod","EasingUtil","FontResourceManager","VideoTextureMonitor","ResourceRouter","Shaders30CompatibilityTransform","BaseShaderTransform","SurfaceCommands","CommandLayer","BasicCamera2DController","ReferenceCamera2D","View2D","Projection2D","scaleType","ArcLayer","ArcInstance","animate","usePoints","opacity","CircleLayer","CircleInstance","scaleFactor","EdgeLayer","EdgeInstance","ImageLayer","ImageRenderLayer","ImageInstance","TextAreaLayer","BorderInstance","BorderLayer","RectangleLayer","RingInstance","RingLayer","Transform2D","CubeLayer","CubeInstance","BasicSurface","getOwnPropertyDescriptors","obj","keys","descriptors","getOwnPropertyDescriptor","formatRegExp","isString","objects","inspect","join","Number","_","isNull","isObject","deprecate","fn","msg","noDeprecation","warned","throwDeprecation","traceDeprecation","trace","error","debugEnviron","debugs","opts","ctx","seen","stylize","stylizeNoColor","depth","isBoolean","showHidden","_extend","isUndefined","customInspect","stylizeWithColor","formatValue","styleType","styles","recurseTimes","isFunction","constructor","ret","primitive","simple","isNumber","formatPrimitive","visibleKeys","forEach","idx","arrayToHash","getOwnPropertyNames","isError","formatError","isRegExp","toString","isDate","base","braces","isArray","toUTCString","formatProperty","formatArray","map","pop","reduce","cur","numLinesEst","reduceToSingleString","desc","set","line","ar","arg","re","objectToString","pad","debuglog","NODE_DEBUG","toUpperCase","pid","isNullOrUndefined","isSymbol","isPrimitive","isBuffer","months","timestamp","time","getHours","getMinutes","getSeconds","getDate","getMonth","prop","inherits","origin","kCustomPromisifiedSymbol","undefined","callbackifyOnRejected","reason","cb","newReason","promisify","original","TypeError","writable","configurable","promiseResolve","promiseReject","promise","Promise","resolve","reject","setPrototypeOf","getPrototypeOf","defineProperties","custom","callbackify","callbackified","maybeCb","then","rej","copy","fill","readUInt8","ctor","superCtor","super_","TempCtor","messageHeader","buffers","fs","PostProcessLayer","ViewScreen"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"network-bubble-chart\"] = factory();\n\telse\n\t\troot[\"network-bubble-chart\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 133);\n","import {\n  IMouseInteraction,\n  ISingleTouchInteraction,\n  ITouchInteraction\n} from \"./event-management\";\nimport {\n  Attribute,\n  GLSettings,\n  IMaterialUniform,\n  MaterialOptions,\n  MaterialUniformType,\n  Texture\n} from \"./gl\";\nimport { Instance } from \"./instance-provider/instance\";\nimport { BaseProjection } from \"./math\";\nimport {\n  Mat3x3,\n  Mat4x4,\n  Vec,\n  Vec1,\n  Vec2,\n  Vec2Compat,\n  Vec3,\n  Vec4\n} from \"./math\";\nimport { IAutoEasingMethod } from \"./math/auto-easing-method\";\nimport { BaseResourceOptions } from \"./resources/base-resource-manager\";\nimport { ISceneOptions } from \"./surface/layer-scene\";\nimport { IViewProps, View } from \"./surface/view\";\n\nexport type Diff<T extends string, U extends string> = ({ [P in T]: P } &\n  { [P in U]: never } & { [x: string]: never })[T];\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\nexport type ShaderIOValue = Vec1 | Vec2 | Vec3 | Vec4 | Vec4[] | Float32Array;\nexport type InstanceIOValue = Vec1 | Vec2 | Vec3 | Vec4 | Mat4x4;\nexport type InstanceIOVectorValue = Vec1 | Vec2 | Vec3 | Vec4;\nexport type UniformIOValue =\n  | number\n  | InstanceIOValue\n  | Mat3x3\n  | Mat4x4\n  | Float32Array\n  | Texture\n  | number[];\n\nexport enum InstanceBlockIndex {\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4\n}\n\nexport enum InstanceAttributeSize {\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4,\n  MAT4X4 = 16,\n  /** Special case for making instance attributes that can target Atlas resources */\n  ATLAS = 99\n}\n\nexport const instanceAttributeSizeFloatCount: { [key: number]: number } = {\n  [InstanceAttributeSize.ONE]: 1,\n  [InstanceAttributeSize.TWO]: 2,\n  [InstanceAttributeSize.THREE]: 3,\n  [InstanceAttributeSize.FOUR]: 4,\n  [InstanceAttributeSize.MAT4X4]: 16,\n  [InstanceAttributeSize.ATLAS]: 4\n};\n\nexport enum UniformSize {\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4,\n  MATRIX3 = 9,\n  MATRIX4 = 16,\n  FLOAT_ARRAY = 97,\n  VEC4_ARRAY = 98,\n  TEXTURE = 99\n}\n\nexport enum VertexAttributeSize {\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4\n}\n\n/**\n * These are valid texture sizes available. We force a power of 2 to be utilized.\n * We do not allow crazy large sizes as browsers have very real caps on\n * resources. This helps implementations be a little smarter about what they are\n * using. Future versions may increase this number as GPUs improve and standards\n * allow greater flexibility.\n */\nexport enum TextureSize {\n  /**\n   * Specialized sizing that makes the texture stick with a 256th the size of the\n   * canvas/screen being rendered to. This sizing is only valid for managers\n   * that properly watch the screen such as the render texture resource manager.\n   */\n  SCREEN_256TH = -256,\n  /**\n   * Specialized sizing that makes the texture stick with a 128th the size of the\n   * canvas/screen being rendered to. This sizing is only valid for managers\n   * that properly watch the screen such as the render texture resource manager.\n   */\n  SCREEN_128TH = -128,\n  /**\n   * Specialized sizing that makes the texture stick with a 64th the size of the\n   * canvas/screen being rendered to. This sizing is only valid for managers\n   * that properly watch the screen such as the render texture resource manager.\n   */\n  SCREEN_64TH = -64,\n  /**\n   * Specialized sizing that makes the texture stick with a 32nd the size of the\n   * canvas/screen being rendered to. This sizing is only valid for managers\n   * that properly watch the screen such as the render texture resource manager.\n   */\n  SCREEN_32ND = -32,\n  /**\n   * Specialized sizing that makes the texture stick with a sixteenth the size of the\n   * canvas/screen being rendered to. This sizing is only valid for managers\n   * that properly watch the screen such as the render texture resource manager.\n   */\n  SCREEN_16TH = -16,\n  /**\n   * Specialized sizing that makes the texture stick with an eigth the size of the\n   * canvas/screen being rendered to. This sizing is only valid for managers\n   * that properly watch the screen such as the render texture resource manager.\n   */\n  SCREEN_8TH = -8,\n  /**\n   * Specialized sizing that makes the texture stick with a quarter the size of the\n   * canvas/screen being rendered to. This sizing is only valid for managers\n   * that properly watch the screen such as the render texture resource manager.\n   */\n  SCREEN_QUARTER = -4,\n  /**\n   * Specialized sizing that makes the texture stick with half the size of the\n   * canvas/screen being rendered to. This sizing is only valid for managers\n   * that properly watch the screen such as the render texture resource manager.\n   */\n  SCREEN_HALF = -2,\n  /**\n   * Specialized sizing that makes the texture stick with the size of the\n   * canvas/screen being rendered to. This sizing is only valid for managers\n   * that properly watch the screen such as the render texture resource manager.\n   */\n  SCREEN = -1,\n  _2 = 0x01 << 1,\n  _4 = 0x01 << 2,\n  _8 = 0x01 << 3,\n  _16 = 0x01 << 4,\n  _32 = 0x01 << 5,\n  _64 = 0x01 << 6,\n  _128 = 0x01 << 7,\n  _256 = 0x01 << 8,\n  _512 = 0x01 << 9,\n  _1024 = 0x01 << 10,\n  _2048 = 0x01 << 11,\n  _4096 = 0x01 << 12\n}\n\n/**\n * Types of reesources that can be generated and provided via the resource\n * manager\n */\nexport enum ResourceType {\n  ATLAS = 0,\n  FONT = 1,\n  TEXTURE = 2,\n  COLOR_BUFFER = 3\n}\n\n/**\n * Base options needed for a resource to be considered a viable resource\n */\nexport interface IResourceType {\n  type: number;\n}\n\n/**\n * This represents a color in the VoidGL system. Ranges are\n * [0 - 1, 0 - 1, 0 - 1, 0 - 1]\n */\nexport type Color = Vec4;\n\n/**\n * This represents a rotation in Euler angles [X axis, Y axis, Z axis]\n */\nexport type EulerRotation = Vec3;\n\n/**\n * Order description of the way a euler angle is supposed to be applied\n */\nexport enum EulerOrder {\n  zyx,\n  zyz,\n  zxy,\n  zxz,\n  yxz,\n  yxy,\n  yzx,\n  yzy,\n  xyz,\n  xyx,\n  xzy,\n  xzx\n}\n\n/**\n * Represents something with a unique id\n */\nexport interface IdentifiableById {\n  /** A unique identifier */\n  id: string | number;\n}\n\n/**\n * Represents something with a unique key\n */\nexport interface IdentifiableByKey {\n  /** A unique identifier */\n  key: string | number;\n}\n\n/**\n * Information provided in user interaction events interacting with instances\n * and layers.\n */\nexport interface IPickInfo<T extends Instance> {\n  /** The interaction that created this picking information */\n  readonly interaction?: IMouseInteraction | ITouchInteraction;\n  /** This is the parent layer id of the instances interacted with */\n  readonly layer: string;\n  /** This is the list of instances that were detected in the interaction */\n  readonly instances: T[];\n  /**\n   * This is the screen coordinates of the interaction point that interacted\n   * with the instances\n   */\n  readonly screen: Vec2;\n  /**\n   * This is the world coordinates of the ineraction point that interacted with\n   * the instances\n   */\n  readonly world: Vec2Compat;\n  /** Projection methods to easily go between coordinate spaces */\n  readonly projection: BaseProjection<any>;\n}\n\n/**\n * Picking info associated with mouse events\n */\nexport interface IMousePickInfo<T extends Instance> extends IPickInfo<T> {\n  /** The mouse interaction that created this picking information */\n  readonly interaction: IMouseInteraction;\n}\n\n/**\n * Picking info associated with touch events\n */\nexport interface ITouchPickInfo<T extends Instance> extends IPickInfo<T> {\n  /**\n   * The touch interaction that created this picking information. Contains all\n   * touch interactive information for the event\n   */\n  readonly interaction: ITouchInteraction;\n  /** The specific touch that caused the event to occur */\n  readonly touch: ISingleTouchInteraction;\n}\n\nexport interface IVertexAttribute {\n  /**\n   * When initWithBuffer and customFill are not specified, this is was the\n   * system will initially load each vertex attribute with.\n   */\n  defaults?: number[];\n  /**\n   * When this is specified it will initialize the model's attribute with the\n   * data in this buffer.\n   */\n  initWithBuffer?: Float32Array;\n  /**\n   * When generating this attribute in the shader this will be the prefix to the\n   * attribute: For instance, if you specify 'highp' as the modifier, then the\n   * attribute that appears in the shader will be: attribute highp vec3\n   * position;\n   */\n  qualifier?: string;\n  /**\n   * This is the name the attribute will be for the model.\n   */\n  name: string;\n  /**\n   * This is the number of floats the attribute will consume. For now, we only\n   * allow for up to four floats per attribute.\n   */\n  size: VertexAttributeSize;\n  /**\n   * This lets you populate the buffer with an automatically called method. This\n   * will fire when necessary updates are detected or on initialization.\n   */\n  update(vertex: number): ShaderIOValue;\n}\n\nexport interface IVertexAttributeInternal extends IVertexAttribute {\n  /**\n   * This is the actual attribute generated internally for the GL interfacing\n   */\n  materialAttribute: Attribute | null;\n}\n\nexport interface IInstanceAttribute<T extends Instance> {\n  /**\n   * If this is specified, this attribute becomes a size of 4 and will have a\n   * block index of 0. This makes this attribute and layer become compatible\n   * with reading atlas resources. The value provided for this property should\n   * be the name of the atlas that is created.\n   */\n  resource?: {\n    /**\n     * This is a method that should return the string key identifier of the\n     * resource to be used\n     */\n    key(): string;\n    /**\n     * Specify the name that will be injected that will be the sampler2D in the\n     * shader\n     */\n    name: string;\n    /**\n     * This specifies which of the shaders the sampler2D will be injected into.\n     * Defaults to the Fragment shader only.\n     */\n    shaderInjection?: ShaderInjectionTarget;\n  };\n  /**\n   * This is a block index helping describe the instancing process. It can be\n   * any number as the system will sort and organize them for you. This only\n   * helps the system detect when you cram too much info into a single block.\n   * The tighter you pack your blocks the better your program will perform.\n   *\n   * Note: It's best to leave this blank as the system now packs your attributes\n   * for you and will determine this number for you.\n   */\n  block?: number;\n  /**\n   * This is the index within the block this attribute will be available.\n   */\n  blockIndex?: InstanceBlockIndex;\n  /**\n   * Child attributes are attributes that are guaranteed to update when the\n   * parent attribute is updated. This is useful for attributes with special\n   * properties that get expanded to other types of attributes such as easing\n   * attributes which gain start, duration, and other values to make the\n   * attribute work.\n   *\n   * If the settings on this attrubute spawns additional attributes, those\n   * attributes shall be populated here. Otherwise this remains undefined.\n   */\n  childAttributes?: IInstanceAttribute<T>[];\n  /**\n   * When this is set, the system will automatically inject necessary Shader IO\n   * to facilitate performing the easing on the GPU, which saves enormous\n   * amounts of CPU processing time trying to calcuate animations and tweens for\n   * properties.\n   *\n   * NOTE: Setting this increases the amount of data per instance by: size * 2 +\n   * ; as it injects in a start value, start time, and duration\n   */\n  easing?: IAutoEasingMethod<Vec>;\n  /**\n   * This is the name that will be available in your shader for use. This will\n   * only be available after the ${attributes} declaration.\n   */\n  name: string;\n  /**\n   * If this attribute is created automatically by the system based on the\n   * settings of another attribute, that parent attribute will be set here.\n   * Otherwise this remains undefined.\n   */\n  parentAttribute?: IInstanceAttribute<T>;\n  /**\n   * When generating this attribute in the shader this will be the prefix to the\n   * attribute: For instance, if you specify 'highp' as the modifier, then the\n   * attribute that appears in the shader will be: attribute highp vec3\n   * position;\n   */\n  qualifier?: string;\n  /**\n   * This is how many floats the instance attribute takes up. Due to how\n   * instancing is implemented, we can only take up to 4 floats per variable\n   * right now.\n   */\n  size?: InstanceAttributeSize;\n  /**\n   * This is the accessor that executes when the instance needs updating. Simply\n   * return the value that should be populated for this attribute.\n   */\n  update(instance: T): InstanceIOValue;\n}\n\n/**\n * Internal Instance Attributes are ones that actually map to an attribute in\n * the shader and use hardware instancing.\n */\nexport interface IInstanceAttributeInternal<T extends Instance>\n  extends IInstanceAttribute<T> {\n  /** We will keep an internal uid for the  */\n  uid: number;\n  /**\n   * Sometimes an attribute is actually a sub attribute to another attribute,\n   * such as in the cases of attribute packing (in uniforms or in attribute\n   * packing). This UID indicates the parental attribute UID. This parent\n   * identifier may be an actual InstanceAttribute or not. It could just\n   * indicate this attribute is packed into SOMETHING.\n   */\n  packUID?: number;\n  /** This is the actual attribute mapped to a buffer */\n  bufferAttribute: Attribute;\n}\n\n/**\n * This is specifically a deduced type of instance attribute that is specially\n * dealing with Vec1-4 values. These types of vectors can be dealt with in\n * special ways, thus they get this special case.\n */\nexport interface IInstanceAttributeVector<T extends Instance>\n  extends IInstanceAttribute<T> {\n  update(instance: T): InstanceIOVectorValue;\n}\n\n/**\n * Typeguard to determine if an instance attribute provides vectors or something\n * larger\n */\nexport function isInstanceAttributeVector<T extends Instance>(\n  val: IInstanceAttribute<T>\n): val is IInstanceAttributeVector<T> {\n  return val.size !== undefined && val.size <= 4;\n}\n\n/**\n * This is an attribute where the resource is definitely declared.\n */\nexport interface IResourceInstanceAttribute<T extends Instance>\n  extends IInstanceAttribute<T> {\n  /**\n   * If this is specified, this attribute becomes a size of 4 and will have a\n   * block index of 0. This makes this attribute and layer become compatible\n   * with reading resources. The value provided for this property should be the\n   * name of the resource that is created.\n   */\n  resource: {\n    /**\n     * This retrieves the key of the resource that is to be used by the\n     * attribute\n     */\n    key(): string;\n    /**\n     * Specify the name that will be injected that will be the sampler2D in the\n     * shader\n     */\n    name: string;\n    /**\n     * This specifies which of the shaders the sampler2D will be injected into.\n     * Defaults to the Fragment shader only.\n     */\n    shaderInjection?: ShaderInjectionTarget;\n  };\n}\n\n/**\n * This represents the minimum information to target a specific resource.\n */\nexport interface IResourceContext {\n  /** Indicates a resource is specified */\n  resource: {\n    /**\n     * The resource type. This is the type a manager is registered with when\n     * setting up a surface.\n     */\n    type: number;\n    /** This is the identifier of the specific resource within the manager */\n    key: string;\n  };\n}\n\n/**\n * Type guard for resource instance attributes\n */\nexport function isResourceAttribute<T extends Instance>(\n  val: IInstanceAttribute<T>\n): val is IResourceInstanceAttribute<T> {\n  return Boolean(val && val.resource);\n}\n\n/**\n * This is an attribute that is simply a value\n */\nexport interface IEasingInstanceAttribute<T extends Instance>\n  extends IInstanceAttribute<T> {\n  /**\n   * This MUST be defined to be an Easing attribute\n   */\n  easing: IAutoEasingMethod<Vec> & { uid?: number };\n  /**\n   * Easing attributes requires size to be present\n   */\n  size: InstanceAttributeSize;\n  /**\n   * If this is an easing attribute, then the instance will only provide Vec1-4\n   * values\n   */\n  update(o: T): InstanceIOVectorValue;\n}\n\n/**\n * This is an attribute that is simply a value\n */\nexport interface IValueInstanceAttribute<T extends Instance>\n  extends IInstanceAttribute<T> {\n  /**\n   * If this is specified, this attribute becomes a size of 4 and will have a\n   * block index of\n   * 0. This makes this attribute and layer become compatible with reading atlas\n   *    resources. The value provided for this property should be the name of\n   *    the atlas that is created.\n   */\n  atlas: undefined;\n}\n\n/**\n * These are flags for indicating which shaders receive certain injection\n * elements\n */\nexport enum ShaderInjectionTarget {\n  /** ONLY the vertex shader will receive the injection */\n  VERTEX = 1,\n  /** ONLY the fragment shader will receive the injection */\n  FRAGMENT = 2,\n  /** Both the fragment and vertex shader will receive the injection */\n  ALL = 3\n}\n\nexport interface IUniform {\n  /**\n   * This lets you specify which of the shaders will receive this uniform as\n   * available. This defaults to only injecting into the vertex shader.\n   */\n  shaderInjection?: ShaderInjectionTarget;\n  /** Name of the uniform as will be available in the shaders */\n  name: string;\n  /** How many floats the uniform shall encompass */\n  size: UniformSize;\n  /**\n   * When generating this uniform in the shader this will be the prefix to the\n   * uniform: For instance, if you specify 'highp' as the modifier, then the\n   * uniform that appears in the shader will be: uniform highp vec3 position;\n   */\n  qualifier?: string;\n  /**\n   * This is the accessor that executes every frame before this layer is drawn.\n   * It gives opportunity to update the uniform's value before every draw.\n   */\n  update(uniform: IUniform): UniformIOValue;\n}\n\nexport interface IUniformInternal extends IUniform {\n  /**\n   * All layers will have many many ShaderMaterials generated per each instance\n   * buffer as a single buffer can only render so many instances. This tracks\n   * across all generated ShaderMaterials for each buffer the material uniforms\n   * that need to be updated as a Uniform for a layer is dictated as uniform\n   * across all instances.\n   */\n  materialUniforms: IMaterialUniform<MaterialUniformType>[];\n}\n\n/**\n * This is the structure of a uniform generated for the sake of instancing\n */\nexport interface IInstancingUniform {\n  name: string;\n  type:\n    | MaterialUniformType.FLOAT\n    | MaterialUniformType.VEC2\n    | MaterialUniformType.VEC3\n    | MaterialUniformType.VEC4\n    | MaterialUniformType.VEC4_ARRAY;\n  value: ShaderIOValue;\n}\n\n/**\n * This represents a target resource that expects a given information type.\n * OutputFragmentShaderSource's can be associated to these target types via\n * matching on the outputType.\n *\n * While outputType is mostly arbitrary to the implementation, the outputType of\n * \"0\" is defaulted to the concept of COLOR. COLOR is a default type of output\n * that is used extensively in the system to default an output to a target in\n * simplified cases.\n *\n * A target of type \"string\" will have an inferred default outputType of COLOR\n * or \"0\".\n */\nexport type OutputFragmentShaderTarget =\n  | BaseResourceOptions\n  | {\n      /**\n       * The form of information this output will provide. This is mostly an\n       * arbitrary number to help make associations between an output target and the\n       * type of information a layer can provide.\n       */\n      outputType: number;\n      /** The resource key that the output will target */\n      resource: BaseResourceOptions;\n    }[];\n\n/**\n * This represents a fragment shader that has been processed to include all of\n * it's potential outputs.\n *\n * While outputType is mostly arbitrary to the implementation, the outputType of\n * \"0\" is defaulted to the concept of COLOR. COLOR is a default type of output\n * that is used extensively in the system to default an output to a target in\n * simplified cases which includes the SCREEN.\n */\nexport type OutputFragmentShader = Map<\n  View<IViewProps>,\n  {\n    source: string;\n    outputTypes: number[];\n    outputNames: string[];\n  }\n>;\n\n/** Provides the value type of a Map */\nexport type MapValueType<A> = A extends Map<any, infer V> ? V : never;\n\n/**\n * Defines a fragment shader source declaration that indicates fragment shader\n * renderings that can output for various information types.\n *\n * While outputType is mostly arbitrary to the implementation, the outputType of\n * \"0\" is defaulted to the concept of COLOR. COLOR is a default type of output\n * that is used extensively in the system to default an output to a target in\n * simplified cases.\n *\n * An output of type \"string\" will have an inferred default outputType of COLOR\n * or \"0\".\n */\nexport type OutputFragmentShaderSource =\n  | string\n  | { source: string; outputType: number }[];\n\n/**\n * Represents a complete shader object set with raw source information. The\n * fragment shaders here can provide hints to what output targets they are\n * compatible with.\n */\nexport interface IShadersSource {\n  /**\n   * This provides the fragment rendering outputs this layer will perform. If\n   * specify a single output source this will assume you are providing a COLOR\n   * output type.\n   *\n   * If multiple sources are included, this will map each output type to an\n   * available matching output. If a matching output is not available, this will\n   * render the marked COLOR output. If no COLOR output is available, then this\n   * will assume the full processing of all outputs will be utilized and the\n   * FINAL output in the list will output as the COLOR regardless of what it is\n   * flagged as.\n   *\n   * IMPORTANT: Each source is a dependent of the sources before it. So if you\n   * have operations in the main() method of a preceding action, ALL values\n   * declared in that source is available in the next source. So, it is an error\n   * to declare any same properties in the next source. The program outside of\n   * the main() of each output is aggregated together, so if you have external\n   * methods, you only need to declare the methods in the top most shader.\n   *\n   * Each source can have it's own set of imports as imports get resolved all at\n   * once anyways.\n   *\n   * Be mindful how you set up your sources. If you do this wisely, you can have\n   * this layer have a higher or smaller performance footprint based on how the\n   * layer is being used. A well written layer for your application can adapt to\n   * several scenarios AND provide maximum performance.\n   */\n  fs: OutputFragmentShaderSource;\n  /** This is the shader source for your vertex shader. */\n  vs: string;\n}\n\n/**\n * Represents a complete shader object set with analyzed fragment shaders that\n * are compatible with target outputs.\n */\nexport interface IShaders {\n  /**\n   * This provides the fragment rendering outputs this layer will perform. If\n   * specify a single output source this will assume you are providing a COLOR\n   * output type.\n   *\n   * If multiple sources are included, this will map each output type to an\n   * available matching output. If a matching output is not available, this will\n   * render the marked COLOR output. If no COLOR output is available, then this\n   * will assume the full processing of all outputs will be utilized and the\n   * FINAL output in the list will output as the COLOR regardless of what it is\n   * flagged as.\n   *\n   * IMPORTANT: Each source is a dependent of the sources before it. So if you\n   * have operations in the main() method of a preceding action, ALL values\n   * declared in that source is available in the next source. So, it is an error\n   * to declare any same properties in the next source. The program outside of\n   * the main() of each output is aggregated together, so if you have external\n   * methods, you only need to declare the methods in the top most shader.\n   *\n   * Each source can have it's own set of imports as imports get resolved all at\n   * once anyways.\n   *\n   * Be mindful how you set up your sources. If you do this wisely, you can have\n   * this layer have a higher or smaller performance footprint based on how the\n   * layer is being used. A well written layer for your application can adapt to\n   * several scenarios AND provide maximum performance.\n   */\n  fs: OutputFragmentShader;\n  /** This is the shader source for your vertex shader. */\n  vs: string;\n}\n\n/**\n * Represents an element that has a full list of projection methods\n */\nexport interface IProjection {\n  /**\n   * Since projections are the views (just interface stripping functionality) we\n   * should provide the id for added flexibility to events\n   */\n  id: string;\n  /** This is the chart camera utilized in the projection of elements */\n  props: IViewProps;\n  /** Converts from the pixel density layer to the screen space */\n  pixelSpaceToScreen(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n  /** Converts from the screen coordinates to the pixel density layer */\n  screenToPixelSpace(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n  /** Converts from screen space to the view's relative coordinates */\n  screenToView(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n  /** Converts from screen space to the world space of a scene */\n  screenToWorld(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n  /** Converts from a view's space to the screen */\n  viewToScreen(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n  /** Converts from a views space to the world coordinates */\n  viewToWorld(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n  /** Converts from world coordinate space of a scene to the screen */\n  worldToScreen(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n  /** Converts from world coordinate space of a scene to the view's space */\n  worldToView(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n}\n\n/**\n * The empty, do-nothing, method we devs find ourselves using too much.\n */\nexport function NOOP() {\n  /** No-op */\n}\n\n/**\n * White space character test\n */\nexport const whiteSpaceRegEx = /\\s/g;\nexport const whiteSpaceCharRegEx = /\\s/;\nexport const isWhiteSpace = whiteSpaceCharRegEx.test.bind(whiteSpaceCharRegEx);\n\n/**\n * Newline character test\n */\nexport const newLineRegEx = /\\n\\r|\\n|\\r/g;\nexport const newLineCharRegEx = /\\n\\r|\\n|\\r/;\nexport const isNewline = newLineCharRegEx.test.bind(newLineCharRegEx);\n\n/**\n * Options a layer can provide for a material\n */\nexport type ILayerMaterialOptions = Partial<\n  Omit<MaterialOptions, \"uniforms\" | \"vertexShader\" | \"fragmentShader\">\n>;\n\n/**\n * A wrapper to make declaring layer material options easier and clearer\n */\nexport function createMaterialOptions(options: ILayerMaterialOptions) {\n  return options;\n}\n\n/**\n * This is the type of picking assigned to a layer. Each mode has performance\n * and functionality tradeoffs.\n */\nexport enum PickType {\n  /** Disable any picking methodology */\n  NONE,\n  /**\n   * Uses highly useable color rendering method to detect an instance on a\n   * pixel by pixel check. Since it is based on rendering, it will only select\n   * the 'visually' top most rendered instance. This means instances can be\n   * occluded by other instances if an instance renders behind another.\n   */\n  SINGLE\n}\n\n/**\n * This represents the settings and objects used to facilitate picking in a\n * layer.\n */\nexport interface IPickingMetrics {\n  /**\n   * This is the current pick mode that is active during the draw pass of the\n   * layer\n   */\n  currentPickMode: PickType;\n  /** This is the picking style to be used */\n  type: PickType;\n}\n\n/**\n * This is the picking settings and objects to facilitate PickType.SINGLE so we\n * can get a single instance underneath the mouse.\n */\nexport interface ISinglePickingMetrics<T extends Instance>\n  extends IPickingMetrics {\n  /** Set the enum for the type */\n  type: PickType.SINGLE;\n  /**\n   * This is a lookup of the instance by it's UID which is all that is needed to\n   * decode a color to an instance The color UINT8 components composited into a\n   * single UINT32 IS the UID of the instance\n   */\n  uidToInstance: Map<number, T>;\n}\n\n/**\n * This is the picking settings and objects to facilitate PickType.NONE where no\n * information is retrieved for mouse interactions.\n */\nexport interface INonePickingMetrics extends IPickingMetrics {\n  // Single Picking does not require any special helper information\n  type: PickType.NONE;\n}\n\nexport interface IColorPickingData {\n  /** The view this color picking information is associated with */\n  view: View<IViewProps>;\n  /** The mouse target position where the data is rendered */\n  mouse: Vec2;\n  /** The color data loaded for last picking rendering */\n  colorData: Uint8Array;\n  /** The height of the data array */\n  dataHeight: number;\n  /** The width of the data array */\n  dataWidth: number;\n  /** The nearest found color */\n  nearestColor: number;\n  /** The nearest found color in byte form */\n  nearestColorBytes: Vec4;\n  /** All colors in the data */\n  allColors: number[];\n}\n\n/**\n * Diff types that an instance can go through. Used to help the system consume\n * the diff and apply it to the GL framework.\n */\nexport enum InstanceDiffType {\n  CHANGE = 0,\n  INSERT = 1,\n  REMOVE = 2\n}\n\n/**\n * This is the metrics associated with a frame. Mostly dealing with timing\n * values.\n */\nexport type FrameMetrics = {\n  /** The frame number rendered. Increases by 1 every surface draw */\n  currentFrame: number;\n  /** The start time of the current frame */\n  currentTime: number;\n  /** This is the duration of the previous frame */\n  frameDuration: number;\n  /** The start time of the previous frame */\n  previousTime: number;\n};\n\n/**\n * This represents controls that can be utilized when adjustig easing\n */\nexport interface IEasingControl {\n  /**\n   * A value in ms that expresses how long the system should wait before\n   * beginning the animation\n   */\n  readonly delay?: number;\n  /** Indicates how long the easing should take to complete in ms */\n  readonly duration: number;\n  /** The end value the easing should approach */\n  readonly end: Vec;\n  /** The starting value of the easing object */\n  readonly start: Vec;\n  /** The start time in ms the easing object utilizes */\n  readonly startTime: number;\n\n  /**\n   * If you manually set values for the easing properties, then you use this to\n   * return the easing object back to an automated state which is where the\n   * start value is the calculated current position of the output and the delay\n   * and duration is determined by the easing set to the layer's\n   * IAutomatedEasingMethod value set to the layer.\n   */\n  setAutomatic(): void;\n\n  /**\n   * This controls the start value of the easing. This should be used to force a\n   * starting value of the animation.\n   *\n   * Use setAutomatic() to return to default easing behavior.\n   */\n  setStart(start?: Vec): void;\n\n  /**\n   * This controls of the timing of the easing equation. This should be used to\n   * adjust when a value is to be adjusted\n   *\n   * Use setAutomatic() to return to default easing behavior.\n   */\n  setTiming(delay?: number, duration?: number): void;\n}\n\n/**\n * This is the minimum properties required to make all easing functions operate.\n */\nexport interface IEasingProps {\n  /**\n   * A value in ms that expresses how long the system should wait before\n   * beginning the animation\n   */\n  delay?: number;\n  /** Indicates how long the easing should take to complete in ms */\n  duration: number;\n  /** The end value the easing should approach */\n  end: Vec;\n  /**\n   * A flag indicating if the easing start value is manually set, thus\n   * prioritizing the values already set in this object\n   */\n  isManualStart?: boolean;\n  /**\n   * A flag indicating if the easing timing is manually set, thus prioritizing\n   * the values already set in this object\n   */\n  isTimeSet?: boolean;\n  /** The starting value of the easing object */\n  start: Vec;\n  /** The start time in ms the easing object utilizes */\n  startTime: number;\n}\n\n/**\n * This is the Shader IO information a layer will provide.\n */\nexport interface IShaderInputs<T extends Instance> {\n  /**\n   * Specifies how the vertices are laid out in the model. This defaults to\n   * Triangle Strip if not specified\n   */\n  drawMode?: GLSettings.Model.DrawMode;\n  /**\n   * These are very frequently changing attributes and are uniform across all\n   * vertices in the model\n   */\n  instanceAttributes?: (IInstanceAttribute<T> | null)[];\n  /**\n   * These are attributes that should be static on a vertex. These are\n   * considered unique per vertex.\n   */\n  vertexAttributes?: (IVertexAttribute | null)[];\n  /**\n   * Specify how many vertices there are per instance. If vertex count is 0,\n   * then the layer will render without instancing and draw the buffers\n   * straight.\n   */\n  vertexCount: number;\n  /**\n   * These are uniforms in the shader. These are uniform across all vertices and\n   * all instances for this layer.\n   */\n  uniforms?: (IUniform | null)[];\n}\n\n/**\n * This is the initialization of the shader.\n */\nexport type IShaderInitialization<T extends Instance> = IShaderInputs<T> &\n  IShadersSource;\n\nexport interface IShaderExtension {\n  header?: string;\n  main?: {\n    pre?: string;\n    post?: string;\n  };\n}\n\nexport type IShaderIOExtension<T extends Instance> = Partial<\n  IShaderInputs<T>\n> & {\n  vs?: IShaderExtension;\n  fs?: IShaderExtension;\n};\n\n/**\n * A convenience for making short lists of items that are of the same type, such\n * as the common scenario of [boolean, boolean, boolean, boolean]\n */\nexport type TypeVec<T> = [T] | [T, T] | [T, T, T] | [T, T, T, T];\n\n/**\n * Depicts a two or three dimensional size:\n * [width, height, depth]\n */\nexport type Size = Vec2 | Vec3;\n\n/**\n * When creating a surface you must make it declare a pipeline. This makes a\n * centralized easy entry point for expressively declaring how the application\n * will utilize resources to render to various scenes and contexts.\n *\n * This is also used in a reactive diff manner so elements can be easily\n * updated/added/removed by providing all of the initializer elements. Thus to\n * add an item call the method including the element you wish to create. To\n * remove an element, simply exclude the element next time you call the method.\n */\nexport interface IPipeline {\n  /**\n   * These are the resources we want available that our layers can be provided\n   * to utilize for their internal processes.\n   */\n  resources?: BaseResourceOptions[];\n  /**\n   * This sets up the available scenes the surface will have to work with.\n   * Layers then can reference the scene by it's scene property. The order of\n   * the scenes here is the drawing order of the scenes.\n   */\n  scenes?: ISceneOptions[];\n}\n\n/**\n * Errors emitted by the surface\n */\nexport enum SurfaceErrorType {\n  /**\n   * Error is thrown when no web gl context can be established for the canvas\n   */\n  NO_WEBGL_CONTEXT\n}\n\n/**\n * Errors emitted by the surface\n */\nexport type SurfaceError = {\n  error: SurfaceErrorType;\n  message: string;\n};\n\n/**\n * A numerical or string identifier. Use this type to make your intent a little\n * clearer when you want a resource identified.\n */\nexport type SimpleId = string | number;\n\n/**\n * An alias for a string. Use this type to make your intent a little clearer\n * when you want a string specifically for identifying a resource.\n */\nexport type StringId = string;\n\n/**\n * An alias for a number. Use this type to make your intent a little clearer\n * when you want a number specifically for identifying a resource.\n */\nexport type NumberId = number;\n\n/**\n * This is a massively useful type to express an object that can have numeric or\n * string identifiers in recursive amounts to define an object with many\n * pathways to various items of the same type (that can be varied by generic)\n *\n * ```\n * const o: Lookup<InstanceProvider<Instance>> = {\n *  circles: new InstanceProvider<CircleInstance>(),\n *  category: {\n *    special: new InstanceProvider<LabelInstance>(),\n *  }\n * }\n * ```\n */\nexport type Lookup<T> = { [key: string]: T | Lookup<T> };\n\n/**\n * This expresses determined buffer types that already exists within the\n * framework.\n */\nexport enum LayerBufferType {\n  /**\n   * This is a compatibility mode for instance attributes. This is used when:\n   * 1. It would perform better\n   * 2. When instance attributes are not available for the gl context (ANGLE\n   *    draw instanced arrays)\n   * 3. When the instance attributes + vertex attributes exceeds the max Vertex\n   *    Attributes for the hardware and Attribute packing still can not fit all\n   *    of the attributes for the item.\n   */\n  UNIFORM = 0,\n  /**\n   * This is a fast and zippy buffering strategy used when the hardware supports\n   * it for a provided layer!\n   */\n  INSTANCE_ATTRIBUTE = 1,\n  /**\n   * This is a slight degradation from the normal INSTANCE_ATTRIBUTE buffering\n   * strategy. If provided attributes do not fit the limited amount of vertex\n   * attributes supported by the hardware, then we have one last strategy to\n   * utilize the highly optimized hardware instancing, which is to cram multiple\n   * attributes within single attribute blocks. An attribute block is considered\n   * to be 4 32 bit floats. These packed attributes will then get dereferenced\n   * in the shader.\n   */\n  INSTANCE_ATTRIBUTE_PACKING = 2\n}\n\n/**\n * This is an entry within the change list of the provider. It represents the\n * type of change and stores the property id's of the properties on the instance\n * that have changed.\n */\nexport type InstanceDiff<T extends Instance> = [\n  T,\n  InstanceDiffType,\n  { [key: number]: number }\n];\n\n/**\n * Bare minimum required features a provider must provide to be the data for the\n * layer.\n */\nexport interface IInstanceProvider<T extends Instance> {\n  /**\n   * This indicates the context this provider was handled within. Currently,\n   * only one context is allowed per provider, so we use this to detect when\n   * multiple contexts have attempted use of this provider.\n   */\n  resolveContext: string;\n  /** A unique number making it easier to identify this object */\n  uid: number;\n  /** A list of changes to instances */\n  changeList: InstanceDiff<T>[];\n  /** Removes an instance from the list */\n  remove(instance: T): void;\n  /** Resolves the changes as consumed */\n  resolve(context: string): void;\n  /**\n   * Forces the provider to make a change list that ensures all elements are\n   * added\n   */\n  sync(): void;\n}\n\n/**\n * This is the types of strategies available for streaming in changes to the\n * GPU.\n */\nexport enum StreamChangeStrategy {\n  /** This takes the changes as they are discovered  */\n  LINEAR\n  // TODO: There currently isn't a good solution to make the randomized\n  // streaming happen without some serious performance concerns. Some strategies\n  // are in mind but aren't great. So we'll leave this commented out while\n  // strategies are considered.\n\n  // RANDOM\n}\n\n/**\n * This is a reference to pass into a layer which will provide insight into the\n * layer's easing timing information so there can be better control and better\n * informed decisions on the rendering of elements that animate on the GPU.\n */\nexport interface ILayerEasingManager {\n  /**\n   * This is an async method that resolves when the current batch or stream has\n   * completed it's easing animation in full.\n   */\n  complete(): Promise<void>;\n}\n\n/**\n * This is a reference object that is populated with controllers and relevant\n * exposed information regarding a layer.\n */\nexport interface ILayerRef {\n  /**\n   * The easing controller for the layer. This can be used to get precise\n   * timings for completion of easing animations and other easing metrics.\n   */\n  easing: ILayerEasingManager | null;\n}\n\n/**\n * Type of transform prop that needs to track whether or not it has been\n * updated.\n */\nexport type UpdateProp<T> = {\n  didUpdate?: boolean;\n  value: T;\n};\n\n/**\n * Speedy check to see if a value is a string type or not\n */\nexport function isString(val?: any): val is string {\n  return val !== void 0 && val.charCodeAt !== void 0;\n}\n\n/**\n * Speedy check to see if a value is a number type or not\n */\nexport function isNumber(val?: any): val is number {\n  return val !== void 0 && val.toExponential !== void 0;\n}\n\n/**\n * Speedy check to see if the target object is a method or not. This avoids\n * string comparison with 'function'.\n */\nexport function isFunction<T extends Function>(val?: any): val is T {\n  return val !== void 0 && val.call !== void 0 && val.apply !== void 0;\n}\n\n/**\n * Checks if a value is strictly a boolean type. This avoids typeof and string\n * comparison.\n */\nexport function isBoolean(val?: any): val is Boolean {\n  return val === true || val === false;\n}\n\n/**\n * This is a listing of suggested Output information styles.\n *\n * NOTE: Information styles are merely suggestions of information types. It does\n * NOT guarantee any specific type of data. These are merely flags to aid in\n * wiring available layer outputs to output render targets.\n *\n * You could theoretically use arbitrary numbers to match the two together, it\n * is recommended to utilize labeled enums though for readability.\n */\nexport enum FragmentOutputType {\n  /**\n   * Indicates this does not have an output target. This is mostly used by the\n   * system to make sure our fragment outputs, drawBuffers, and frame buffer\n   * attachments stay aligned properly to not cause any GL errors or undefined\n   * outputs to occur.\n   */\n  NONE = 0,\n  /**\n   * This is generally specified when a layer has a fragment output that is a\n   * no-op to allow for quickest rendering possible when performing operations\n   * like rendering a shadow map.\n   */\n  BLANK,\n  /**\n   * This is the most common information output style. It provides a color per\n   * fragment\n   */\n  COLOR,\n  /**\n   * This indicates it will provide a depth value per fragment\n   */\n  DEPTH,\n  /**\n   * This indicates it will provide eye-space normal information per fragment\n   */\n  NORMAL,\n  /**\n   * Indicates it will provide color information that coincides with instance\n   * IDs used in the COLOR PICKING routines the system provides.\n   */\n  PICKING,\n  /**\n   * This indicates it will provide eye-space position information per fragment.\n   * Best used for a float texture when available.\n   */\n  POSITION,\n  /**\n   * Sometimes compatibility is a major need. Thus this is used when float\n   * textures are not available (which is often the case in Mobile). Instead of\n   * getting to use a float point texture, one can use MRT and output each\n   * positional component to separate textures.\n   */\n  POSITION_X,\n  /**\n   * Sometimes compatibility is a major need. Thus this is used when float\n   * textures are not available (which is often the case in Mobile). Instead of\n   * getting to use a float point texture, one can use MRT and output each\n   * positional component to separate textures.\n   */\n  POSITION_Y,\n  /**\n   * Sometimes compatibility is a major need. Thus this is used when float\n   * textures are not available (which is often the case in Mobile). Instead of\n   * getting to use a float point texture, one can use MRT and output each\n   * positional component to separate textures.\n   */\n  POSITION_Z,\n  /**\n   * This indicates it will provide Lighting information\n   */\n  LIGHTS,\n  /**\n   * This indicates it will provide Lighting information\n   */\n  LIGHTS2,\n  /**\n   * This indicates it will provide Lighting information\n   */\n  LIGHTS3,\n  /**\n   * This indicates it will provide Alpha information\n   */\n  ALPHA,\n  /**\n   * This indicates it will provide Beta information\n   */\n  BETA,\n  /**\n   * This indicates it will provide Gamma information\n   */\n  GAMMA,\n  /**\n   * This indicates it will provide Delta information\n   */\n  DELTA,\n  /**\n   * This indicates it will provide some form of accumulation information\n   */\n  ACCUMULATION1,\n  /**\n   * This indicates it will provide some form of accumulation information\n   */\n  ACCUMULATION2,\n  /**\n   * This indicates it will provide some form of accumulation information\n   */\n  ACCUMULATION3,\n  /**\n   * This indicates it will provide some form of accumulation information\n   */\n  ACCUMULATION4,\n  /**\n   * This indicates it will provide Coefficient information\n   */\n  COEFFICIENT1,\n  /**\n   * This indicates it will provide Coefficient information\n   */\n  COEFFICIENT2,\n  /**\n   * This indicates it will provide Coefficient information\n   */\n  COEFFICIENT3,\n  /**\n   * This indicates it will provide Coefficient information\n   */\n  COEFFICIENT4,\n  /**\n   * This indicates it will provide Angular information\n   */\n  ANGLE1,\n  /**\n   * This indicates it will provide Angular information\n   */\n  ANGLE2,\n  /**\n   * This indicates it will provide Angular information\n   */\n  ANGLE3,\n  /**\n   * This indicates it will provide Angular information\n   */\n  ANGLE4,\n  /**\n   * This is the most common information output style. It provides an\n   * alternative color per fragment\n   */\n  COLOR2,\n  /**\n   * This is the most common information output style. It provides an\n   * alternative color per fragment\n   */\n  COLOR3,\n  /**\n   * This is the most common information output style. It provides an\n   * alternative color per fragment\n   */\n  COLOR4,\n  /**\n   * This indicates this will output a fragment to a Glow filter target. Glow\n   * targets are used post processing to indicate which texels in the post\n   * operation should provide a bloom of a given color.\n   */\n  GLOW,\n  /**\n   * This indicates this will output a fragment to a Glow filter target. Blur\n   * targets are used post processing to indicate which texels in the post\n   * operation should be blurred.\n   */\n  BLUR\n}\n","export * from \"./observable\";\nexport * from \"./instance-provider\";\nexport * from \"./instance\";\nexport * from \"./basic-instance\";\n","const { sqrt, max, min, floor, ceil, abs, acos, sin } = Math;\n\n/** Explicit Vec1 */\nexport interface IVec1 extends Array<number> {\n  0: number;\n  length: 1;\n}\n\n/** Explicit Vec2 */\nexport interface IVec2 extends Array<number> {\n  0: number;\n  1: number;\n  length: 2;\n}\n\n/** Explicit Vec3 */\nexport interface IVec3 extends Array<number> {\n  0: number;\n  1: number;\n  2: number;\n  length: 3;\n}\n\n/** Explicit Vec4 */\nexport interface IVec4 extends Array<number> {\n  0: number;\n  1: number;\n  2: number;\n  3: number;\n  length: 4;\n}\n\n/** Vector of 1 components */\nexport type Vec1 = [number];\n/** Vector of 2 components */\nexport type Vec2 = [number, number];\n/** Vector of 3 components */\nexport type Vec3 = [number, number, number];\n/** Vector of 4 components */\nexport type Vec4 = [number, number, number, number];\n\n/** Compatible types with Vec1 for operations (just not iterating) */\nexport type Vec1Compat = Vec1 | Vec2 | Vec3 | Vec4;\n/** Compatible types with Vec2 for operations (just not iterating) */\nexport type Vec2Compat = Vec2 | Vec3 | Vec4;\n/** Compatible types with Vec3 for operations (just not iterating) */\nexport type Vec3Compat = Vec3 | Vec4;\n/** Compatible types with Vec4 for operations (just not iterating) */\nexport type Vec4Compat = Vec4;\n\n/** This type defines any possible explicit vector */\nexport type IVec = IVec1 | IVec2 | IVec3 | IVec4;\n/** This type defines any possible vector */\nexport type Vec = Vec1 | Vec2 | Vec3 | Vec4;\n\n/**\n * Temp Vec3 registers. Can be used for intermediate operations. These\n * are EXTREMELY temporary and volatile for use. Use with EXTREME caution and\n * don't expect them to retain any expected value.\n *\n * These are here more for\n * nesting operations and providing the nested operation something to use so it\n * doesn't need to allocate memory to operate.\n *\n * If you use too many registers, you can get weird behavior as some operations\n * may use some registers as well.\n *\n * Again, this is EXTREMELY advanced useage and should NOT be your first\n * inclination to utilize.\n */\nexport const V3R: Vec3[] = new Array(20).fill(0).map(_ => [0, 0, 0]);\n\n/**\n * Temp Vec4 registers. Can be used for intermediate operations. These\n * are EXTREMELY temporary and volatile for use. Use with EXTREME caution and\n * don't expect them to retain any expected value.\n *\n * These are here more for\n * nesting operations and providing the nested operation something to use so it\n * doesn't need to allocate memory to operate.\n *\n * If you use too many registers, you can get weird behavior as some operations\n * may use some registers as well.\n *\n * Again, this is EXTREMELY advanced useage and should NOT be your first\n * inclination to utilize.\n */\nexport const V4R: Vec4[] = new Array(20).fill(0).map(_ => [0, 0, 0, 0]);\n\n// Type guards for Vecs\n\nexport function isVec1(val: any): val is Vec1 {\n  return val && Array.isArray(val) && val.length === 1;\n}\n\nexport function isVec2(val: any): val is Vec2 {\n  return val && Array.isArray(val) && val.length === 2;\n}\n\nexport function isVec3(val: any): val is Vec3 {\n  return val && Array.isArray(val) && val.length === 3;\n}\n\nexport function isVec4(val: any): val is Vec4 {\n  return val && Array.isArray(val) && val.length === 4;\n}\n\n// Vec1 methods\n\nexport function apply1(v: Vec1Compat | undefined, v0: number): Vec1 {\n  v = v || (([] as any) as Vec1);\n  v[0] = v0;\n\n  return v as Vec1;\n}\n\nexport function add1(\n  left: Vec1Compat,\n  right: Vec1Compat,\n  out?: Vec1Compat\n): Vec1 {\n  return apply1(out, left[0] + right[0]);\n}\n\nexport function ceil1(vec: Vec1Compat, out?: Vec1Compat): Vec1 {\n  return apply1(out, ceil(vec[0]));\n}\n\nexport function compare1(left: Vec1Compat, right: Vec1Compat): boolean {\n  return left[0] === right[0];\n}\n\nexport function fuzzyCompare1(\n  left: Vec1Compat,\n  right: Vec1Compat,\n  epsilon: number\n): boolean {\n  return abs(left[0] - right[0]) <= epsilon;\n}\n\nexport function copy1(vec: Vec1Compat, out?: Vec1Compat): Vec1 {\n  return apply1(out, vec[0]);\n}\n\nexport function forward1(): Vec1 {\n  return [0];\n}\n\n/**\n * Cross product of 1 dimensional vectors could be easiest to visualize as two\n * parallel or anti-parallel vectors that are in the 2D plane. This would result in a vector that is of zero magnitude\n * going into the Z direction. Or essentially [0, 0, 0]. Thus for consistency of <vec method><vec component length>()\n * We will take the one dimension inference of this result and provide [0]\n */\nexport function cross1(\n  _left: Vec1Compat,\n  _right: Vec1Compat,\n  out?: Vec1Compat\n): Vec1 {\n  return apply1(out, 0);\n}\n\nexport function divide1(\n  top: Vec1Compat,\n  bottom: Vec1Compat,\n  out?: Vec1Compat\n): Vec1 {\n  return apply1(out, top[0] / bottom[0]);\n}\n\nexport function empty1(out?: Vec1) {\n  return apply1(out, 0);\n}\n\nexport function flatten1(list: Vec1Compat[], out?: number[]): number[] {\n  out = out || [];\n\n  for (let i = 0, iMax = list.length; i < iMax; ++i) {\n    out.push(list[i][0]);\n  }\n\n  return out;\n}\n\nexport function floor1(vec: Vec1Compat, out?: Vec1Compat): Vec1 {\n  return apply1(out, floor(vec[0]));\n}\n\nexport function inverse1(vec: Vec1Compat, out?: Vec1Compat): Vec1 {\n  return apply1(out, 1 / vec[0]);\n}\n\nexport function scale1(vec: Vec1Compat, scale: number, out?: Vec1Compat): Vec1 {\n  return apply1(out, vec[0] * scale);\n}\n\nexport function subtract1(\n  left: Vec1Compat,\n  right: Vec1Compat,\n  out?: Vec1Compat\n): Vec1 {\n  return apply1(out, left[0] - right[0]);\n}\n\nexport function max1(\n  left: Vec1Compat,\n  right: Vec1Compat,\n  out?: Vec1Compat\n): Vec1 {\n  return apply1(out, max(left[0], right[0]));\n}\n\nexport function min1(\n  left: Vec1Compat,\n  right: Vec1Compat,\n  out?: Vec1Compat\n): Vec1 {\n  return apply1(out, min(left[0], right[0]));\n}\n\nexport function multiply1(\n  left: Vec1Compat,\n  right: Vec1Compat,\n  out?: Vec1Compat\n): Vec1 {\n  return apply1(out, left[0] * right[0]);\n}\n\nexport function normalize1(_left: Vec1Compat, out?: Vec1Compat): Vec1 {\n  return apply1(out, 1);\n}\n\nexport function dot1(left: Vec1Compat, right: Vec1Compat): number {\n  return left[0] * right[0];\n}\n\nexport function linear1(\n  start: Vec1Compat,\n  end: Vec1Compat,\n  t: number,\n  out?: Vec1Compat\n): Vec1 {\n  return add1(scale1(subtract1(end, start), t), start, out);\n}\n\nexport function length1(start: Vec1Compat): number {\n  return start[0];\n}\n\nexport function length1Components(x: number): number {\n  return x;\n}\n\nexport function vec1(\n  values: number[] | number,\n  ...args: (number | number[])[]\n): Vec1 {\n  let out: number[];\n  args = args || [];\n\n  if (Array.isArray(values)) {\n    out = values.slice(0, 1) as Vec1;\n  } else {\n    out = [values];\n  }\n\n  if (out.length < 1) {\n    for (let i = 0, iMax = args.length; i < iMax && out.length < 1; ++i) {\n      const next = args[i];\n      if (Array.isArray(next)) {\n        out.push(...next.slice(0, 1 - out.length));\n      } else {\n        out.push(next);\n      }\n    }\n  }\n\n  while (out.length < 1) out.push(0);\n\n  return out as Vec1;\n}\n\n// Vec2 methods\n\nexport function apply2(\n  v: Vec2Compat | undefined,\n  v0: number,\n  v1: number\n): Vec2 {\n  v = v || ((new Array(2) as any) as Vec2);\n  v[0] = v0;\n  v[1] = v1;\n\n  return v as Vec2;\n}\n\nexport function add2(\n  left: Vec2Compat,\n  right: Vec2Compat,\n  out?: Vec2Compat\n): Vec2 {\n  return apply2(out, left[0] + right[0], left[1] + right[1]);\n}\n\nexport function ceil2(vec: Vec2Compat, out?: Vec2Compat): Vec2 {\n  return apply2(out, ceil(vec[0]), ceil(vec[1]));\n}\n\nexport function copy2(vec: Vec2Compat, out?: Vec2Compat): Vec2 {\n  return apply2(out, vec[0], vec[1]);\n}\n\nexport function forward2(out?: Vec2Compat) {\n  return apply2(out, 1, 0);\n}\n\n/**\n * Cross product of a 2D vector would result in [0, 0, <magnitude>] within the 2D plane. In keeping with the format of\n * vector methods in this document <method name><vector component length>() we return only the 2D result of the product\n * [0, 0].\n * In order to get the results of the actual 2D vectors in a 3D world, you must use cross3() to retrieve the Z result.\n */\nexport function cross2(\n  _left: Vec2Compat,\n  _right: Vec2Compat,\n  out?: Vec2Compat\n): Vec2 {\n  return apply2(out, 0, 0);\n}\n\nexport function compare2(left: Vec2Compat, right: Vec2Compat): boolean {\n  return left[0] === right[0] && left[1] === right[1];\n}\n\nexport function fuzzyCompare2(\n  left: Vec2Compat,\n  right: Vec2Compat,\n  epsilon: number\n): boolean {\n  return (\n    abs(left[0] - right[0]) <= epsilon && abs(left[1] - right[1]) <= epsilon\n  );\n}\n\nexport function divide2(\n  top: Vec2Compat,\n  bottom: Vec2Compat,\n  out?: Vec2Compat\n): Vec2 {\n  return apply2(out, top[0] / bottom[0], top[1] / bottom[1]);\n}\n\nexport function empty2(out?: Vec2) {\n  return apply2(out, 0, 0);\n}\n\nexport function flatten2(list: Vec2Compat[], out?: number[]): number[] {\n  out = out || new Array(list.length * 2);\n\n  for (let i = 0, index = 0, iMax = list.length; i < iMax; ++i, index += 2) {\n    const v = list[i];\n    out[index] = v[0];\n    out[index + 1] = v[1];\n  }\n\n  return out;\n}\n\nexport function floor2(vec: Vec2Compat, out?: Vec2Compat): Vec2 {\n  return apply2(out, floor(vec[0]), floor(vec[1]));\n}\n\nexport function inverse2(vec: Vec2Compat, out?: Vec2Compat): Vec2 {\n  return apply2(out, 1 / vec[0], 1 / vec[1]);\n}\n\nexport function max2(\n  left: Vec2Compat,\n  right: Vec2Compat,\n  out?: Vec2Compat\n): Vec2 {\n  return apply2(out, max(left[0], right[0]), max(left[1], right[1]));\n}\n\nexport function min2(\n  left: Vec2Compat,\n  right: Vec2Compat,\n  out?: Vec2Compat\n): Vec2 {\n  return apply2(out, min(left[0], right[0]), min(left[1], right[1]));\n}\n\nexport function scale2(\n  left: Vec2Compat,\n  scale: number,\n  out?: Vec2Compat\n): Vec2 {\n  return apply2(out, left[0] * scale, left[1] * scale);\n}\n\nexport function subtract2(\n  left: Vec2Compat,\n  right: Vec2Compat,\n  out?: Vec2Compat\n): Vec2 {\n  return apply2(out, left[0] - right[0], left[1] - right[1]);\n}\n\nexport function multiply2(\n  left: Vec2Compat,\n  right: Vec2Compat,\n  out?: Vec2Compat\n): Vec2 {\n  return apply2(out, left[0] * right[0], left[1] * right[1]);\n}\n\nexport function normalize2(left: Vec2Compat, out?: Vec2Compat): Vec2 {\n  const length = length2(left);\n  return apply2(out, left[0] / length, left[1] / length);\n}\n\nexport function dot2(left: Vec2Compat, right: Vec2Compat): number {\n  return left[0] * right[0] + left[1] * right[1];\n}\n\nexport function linear2(\n  start: Vec2Compat,\n  end: Vec2Compat,\n  t: number,\n  out?: Vec2Compat\n): Vec2 {\n  return add2(scale2(subtract2(end, start), t), start, out);\n}\n\nexport function length2(start: Vec2Compat): number {\n  return length2Components(start[0], start[1]);\n}\n\nexport function length2Components(x: number, y: number): number {\n  return sqrt(x * x + y * y);\n}\n\nexport function vec2(\n  values: number[] | number,\n  ...args: (number | number[])[]\n): Vec2 {\n  let out: number[];\n  args = args || [];\n\n  if (Array.isArray(values)) {\n    out = values.slice(0, 2) as Vec2;\n  } else {\n    out = [values];\n  }\n\n  if (out.length < 2) {\n    for (let i = 0, iMax = args.length; i < iMax && out.length < 2; ++i) {\n      const next = args[i];\n      if (Array.isArray(next)) {\n        out.push(...next.slice(0, 2 - out.length));\n      } else {\n        out.push(next);\n      }\n    }\n  }\n\n  while (out.length < 2) out.push(0);\n\n  return out as Vec2;\n}\n\n// Vec3 methods\n\nexport function apply3(\n  v: Vec3Compat | undefined,\n  v0: number,\n  v1: number,\n  v2: number\n): Vec3 {\n  v = v || ((new Array(3) as any) as Vec3);\n  v[0] = v0;\n  v[1] = v1;\n  v[2] = v2;\n\n  return v as Vec3;\n}\n\nexport function add3(\n  left: Vec3Compat,\n  right: Vec3Compat,\n  out?: Vec3Compat\n): Vec3 {\n  return apply3(\n    out,\n    left[0] + right[0],\n    left[1] + right[1],\n    left[2] + right[2]\n  );\n}\n\nexport function ceil3(vec: Vec3Compat, out?: Vec3Compat): Vec3 {\n  return apply3(out, ceil(vec[0]), ceil(vec[1]), ceil(vec[2]));\n}\n\nexport function copy3(vec: Vec3Compat, out?: Vec3Compat): Vec3 {\n  return apply3(out, vec[0], vec[1], vec[2]);\n}\n\nexport function compare3(left: Vec3Compat, right: Vec3Compat): boolean {\n  return left[0] === right[0] && left[1] === right[1] && left[2] === right[2];\n}\n\nexport function fuzzyCompare3(\n  left: Vec3Compat,\n  right: Vec3Compat,\n  epsilon: number\n): boolean {\n  return (\n    abs(left[0] - right[0]) <= epsilon &&\n    abs(left[1] - right[1]) <= epsilon &&\n    abs(left[2] - right[2]) <= epsilon\n  );\n}\n\nexport function forward3(out?: Vec3Compat): Vec3 {\n  return apply3(out, 0, 0, -1);\n}\n\nexport function cross3(\n  left: Vec3Compat,\n  right: Vec3Compat,\n  out?: Vec3Compat\n): Vec3 {\n  out = out || ((new Array(3) as any) as Vec3);\n  out[0] = left[1] * right[2] - left[2] * right[1];\n  out[1] = left[2] * right[0] - left[0] * right[2];\n  out[2] = left[0] * right[1] - left[1] * right[0];\n\n  return out as Vec3;\n}\n\nexport function divide3(\n  top: Vec3Compat,\n  bottom: Vec3Compat,\n  out?: Vec3Compat\n): Vec3 {\n  return apply3(\n    out,\n    top[0] / bottom[0],\n    top[1] / bottom[1],\n    top[2] / bottom[2]\n  );\n}\n\nexport function empty3(out?: Vec3) {\n  return apply3(out, 0, 0, 0);\n}\n\nexport function flatten3(list: Vec3Compat[], out?: number[]): number[] {\n  out = out || new Array(list.length * 3);\n\n  for (let i = 0, index = 0, iMax = list.length; i < iMax; ++i, index += 3) {\n    const v = list[i];\n    out[index] = v[0];\n    out[index + 1] = v[1];\n    out[index + 2] = v[2];\n  }\n\n  return out;\n}\n\nexport function floor3(vec: Vec3Compat, out?: Vec3Compat): Vec3 {\n  return apply3(out, floor(vec[0]), floor(vec[1]), floor(vec[2]));\n}\n\nexport function inverse3(vec: Vec3Compat, out?: Vec3Compat): Vec3 {\n  return apply3(out, 1 / vec[0], 1 / vec[1], 1 / vec[2]);\n}\n\nexport function scale3(\n  left: Vec3Compat,\n  scale: number,\n  out?: Vec3Compat\n): Vec3 {\n  return apply3(out, left[0] * scale, left[1] * scale, left[2] * scale);\n}\n\nexport function subtract3(\n  left: Vec3Compat,\n  right: Vec3Compat,\n  out?: Vec3Compat\n): Vec3 {\n  return apply3(\n    out,\n    left[0] - right[0],\n    left[1] - right[1],\n    left[2] - right[2]\n  );\n}\n\nexport function multiply3(\n  left: Vec3Compat,\n  right: Vec3Compat,\n  out?: Vec3Compat\n): Vec3 {\n  return apply3(\n    out,\n    left[0] * right[0],\n    left[1] * right[1],\n    left[2] * right[2]\n  );\n}\n\nexport function linear3(\n  start: Vec3Compat,\n  end: Vec3Compat,\n  t: number,\n  out?: Vec3Compat\n): Vec3 {\n  return add3(scale3(subtract3(end, start), t), start, out);\n}\n\nexport function length3(start: Vec3Compat): number {\n  return length3Components(start[0], start[1], start[2]);\n}\n\nexport function length3Components(x: number, y: number, z: number): number {\n  return sqrt(x * x + y * y + z * z);\n}\n\nexport function max3(\n  left: Vec3Compat,\n  right: Vec3Compat,\n  out?: Vec3Compat\n): Vec3 {\n  return apply3(\n    out,\n    max(left[0], right[0]),\n    max(left[1], right[1]),\n    max(left[2], right[2])\n  );\n}\n\nexport function min3(\n  left: Vec3Compat,\n  right: Vec3Compat,\n  out?: Vec3Compat\n): Vec3 {\n  return apply3(\n    out,\n    min(left[0], right[0]),\n    min(left[1], right[1]),\n    min(left[2], right[2])\n  );\n}\n\nexport function normalize3(left: Vec3Compat, out?: Vec3Compat): Vec3 {\n  out = out || ((new Array(3) as any) as Vec3);\n  const length = length3(left);\n  out[0] = left[0] / length;\n  out[1] = left[1] / length;\n  out[2] = left[2] / length;\n\n  return out as Vec3;\n}\n\nexport function dot3(left: Vec3Compat, right: Vec3Compat): number {\n  return left[0] * right[0] + left[1] * right[1] + left[2] * right[2];\n}\n\nexport function vec3(\n  values: number[] | number,\n  ...args: (number | number[])[]\n): Vec3 {\n  let out: number[];\n  args = args || [];\n\n  if (Array.isArray(values)) {\n    out = values.slice(0, 3) as Vec3;\n  } else {\n    out = [values];\n  }\n\n  if (out.length < 3) {\n    for (let i = 0, iMax = args.length; i < iMax && out.length < 3; ++i) {\n      const next = args[i];\n      if (Array.isArray(next)) {\n        out.push(...next.slice(0, 3 - out.length));\n      } else {\n        out.push(next);\n      }\n    }\n  }\n\n  while (out.length < 3) out.push(0);\n\n  return out as Vec3;\n}\n\n/**\n * Produces a directional vector that is straight up from the provided reference vectors (90 degress elevated from\n * the forward vector)\n */\nexport function up3(forward: Vec3Compat, up: Vec3Compat, out?: Vec3Compat) {\n  out = out || [0, 0, 0];\n  return normalize3(cross3(cross3(forward, up, out), forward, out), out);\n}\n\n/**\n * Produces a directional vector that is directly to the right of the reference vectors (90 degress rotated from the\n * forrward vector)\n */\nexport function right3(forward: Vec3Compat, up: Vec3Compat, out?: Vec3Compat) {\n  out = out || [0, 0, 0];\n  return normalize3(cross3(forward, up, out), out);\n}\n\n/**\n * Produces a directional vector that is directly to the left of the reference vectors (90 degress rotated from the\n * forrward vector)\n */\nexport function left3(forward: Vec3Compat, up: Vec3Compat, out?: Vec3Compat) {\n  out = out || [0, 0, 0];\n  return normalize3(cross3(up, forward, out), out);\n}\n\n/**\n * Produces a directional vector that is straight down from the provided reference vectors (90 degress declined from\n * the forward vector)\n */\nexport function down3(forward: Vec3Compat, up: Vec3Compat, out?: Vec3Compat) {\n  out = out || [0, 0, 0];\n  return normalize3(cross3(forward, cross3(forward, up, out), out), out);\n}\n\n// Vec4 methods\n\nexport function apply4(\n  v: Vec4Compat | undefined,\n  v0: number,\n  v1: number,\n  v2: number,\n  v3: number\n): Vec4 {\n  v = v || ((new Array(4) as any) as Vec4);\n  v[0] = v0;\n  v[1] = v1;\n  v[2] = v2;\n  v[3] = v3;\n\n  return v as Vec4;\n}\n\nexport function add4(left: Vec4, right: Vec4, out?: Vec4Compat): Vec4 {\n  return apply4(\n    out,\n    left[0] + right[0],\n    left[1] + right[1],\n    left[2] + right[2],\n    left[3] + right[3]\n  );\n}\n\nexport function add4by3(left: Vec4, right: Vec3Compat, out?: Vec4Compat): Vec4 {\n  return apply4(\n    out,\n    left[0] + right[0],\n    left[1] + right[1],\n    left[2] + right[2],\n    left[3]\n  );\n}\n\nexport function ceil4(vec: Vec4Compat, out?: Vec4Compat): Vec4 {\n  return apply4(out, ceil(vec[0]), ceil(vec[1]), ceil(vec[2]), ceil(vec[3]));\n}\n\nexport function copy4(vec: Vec4, out?: Vec4Compat): Vec4 {\n  return apply4(out, vec[0], vec[1], vec[2], vec[3]);\n}\n\nexport function compare4(left: Vec4Compat, right: Vec4Compat): boolean {\n  return (\n    left[0] === right[0] &&\n    left[1] === right[1] &&\n    left[2] === right[2] &&\n    left[3] === right[3]\n  );\n}\n\nexport function fuzzyCompare4(\n  left: Vec4Compat,\n  right: Vec4Compat,\n  epsilon: number\n): boolean {\n  return (\n    abs(left[0] - right[0]) <= epsilon &&\n    abs(left[1] - right[1]) <= epsilon &&\n    abs(left[2] - right[2]) <= epsilon &&\n    abs(left[3] - right[3]) <= epsilon\n  );\n}\n\nexport function forward4(out?: Vec4Compat): Vec4 {\n  return apply4(out, 0, 0, -1, 0);\n}\n\n/**\n * 4D cross product? Lots of issues here. If you need a proper cross product for 3D, please use cross3. What\n * this method should do is up for debate for now and will return a unit 4D vector.\n */\nexport function cross4(_left: Vec4, _right: Vec4, out?: Vec4Compat): Vec4 {\n  return apply4(out, 0, 0, 0, 1);\n}\n\nexport function divide4(\n  top: Vec4Compat,\n  bottom: Vec4Compat,\n  out?: Vec4Compat\n): Vec4 {\n  return apply4(\n    out,\n    top[0] / bottom[0],\n    top[1] / bottom[1],\n    top[2] / bottom[2],\n    top[3] / bottom[3]\n  );\n}\n\nexport function empty4(out?: Vec4) {\n  return apply4(out, 0, 0, 0, 0);\n}\n\nexport function flatten4(list: Vec4Compat[], out?: number[]): number[] {\n  out = out || new Array(4);\n\n  for (let i = 0, index = 0, iMax = list.length; i < iMax; ++i, index += 4) {\n    const v = list[i];\n    out[index] = v[0];\n    out[index + 1] = v[1];\n    out[index + 2] = v[2];\n    out[index + 3] = v[3];\n  }\n\n  return out;\n}\n\nexport function floor4(vec: Vec4Compat, out?: Vec4Compat): Vec4 {\n  return apply4(\n    out,\n    floor(vec[0]),\n    floor(vec[1]),\n    floor(vec[2]),\n    floor(vec[3])\n  );\n}\n\nexport function inverse4(vec: Vec4, out?: Vec4Compat): Vec4 {\n  return apply4(out, 1 / vec[0], 1 / vec[1], 1 / vec[2], 1 / vec[3]);\n}\n\nexport function scale4(left: Vec4, scale: number, out?: Vec4Compat): Vec4 {\n  return apply4(\n    out,\n    left[0] * scale,\n    left[1] * scale,\n    left[2] * scale,\n    left[3] * scale\n  );\n}\n\nexport function subtract4(left: Vec4, right: Vec4, out?: Vec4Compat): Vec4 {\n  return apply4(\n    out,\n    left[0] - right[0],\n    left[1] - right[1],\n    left[2] - right[2],\n    left[3] - right[3]\n  );\n}\n\nexport function multiply4(left: Vec4, right: Vec4, out?: Vec4Compat): Vec4 {\n  return apply4(\n    out,\n    left[0] * right[0],\n    left[1] * right[1],\n    left[2] * right[2],\n    left[3] * right[3]\n  );\n}\n\nexport function dot4(left: Vec4, right: Vec4): number {\n  return (\n    left[0] * right[0] +\n    left[1] * right[1] +\n    left[2] * right[2] +\n    left[3] * right[3]\n  );\n}\n\nexport function linear4(\n  start: Vec4,\n  end: Vec4,\n  t: number,\n  out?: Vec4Compat\n): Vec4 {\n  return add4(scale4(subtract4(end, start), t), start, out);\n}\n\nexport function length4(start: Vec4): number {\n  return length4Components(start[0], start[1], start[2], start[3]);\n}\n\nexport function length4Components(\n  x: number,\n  y: number,\n  z: number,\n  w: number\n): number {\n  return sqrt(x * x + y * y + z * z + w * w);\n}\n\nexport function max4(\n  left: Vec4Compat,\n  right: Vec4Compat,\n  out?: Vec4Compat\n): Vec4 {\n  return apply4(\n    out,\n    max(left[0], right[0]),\n    max(left[1], right[1]),\n    max(left[2], right[2]),\n    max(left[3], right[3])\n  );\n}\n\nexport function min4(\n  left: Vec4Compat,\n  right: Vec4Compat,\n  out?: Vec4Compat\n): Vec4 {\n  return apply4(\n    out,\n    min(left[0], right[0]),\n    min(left[1], right[1]),\n    min(left[2], right[2]),\n    min(left[3], right[3])\n  );\n}\n\nexport function normalize4(left: Vec4Compat, out?: Vec4Compat): Vec4 {\n  const length = length4(left);\n  return apply4(\n    out,\n    left[0] / length,\n    left[1] / length,\n    left[2] / length,\n    left[3] / length\n  );\n}\n\nexport function vec4(\n  values: number[] | number,\n  ...args: (number | number[])[]\n): Vec4 {\n  let out: number[];\n  args = args || [];\n\n  if (Array.isArray(values)) {\n    out = values.slice(0, 4) as Vec4;\n  } else {\n    out = [values];\n  }\n\n  if (out.length < 4) {\n    for (let i = 0, iMax = args.length; i < iMax && out.length < 4; ++i) {\n      const next = args[i];\n      if (Array.isArray(next)) {\n        out.push(...next.slice(0, 4 - out.length));\n      } else {\n        out.push(next);\n      }\n    }\n  }\n\n  while (out.length < 4) out.push(0);\n\n  return out as Vec4;\n}\n\nexport function color4FromHex3(hex: number, out?: Vec4) {\n  out = out || [0, 0, 0, 0];\n\n  return apply4(\n    out,\n    ((hex & 0xff0000) >> 16) / 255,\n    ((hex & 0xff00) >> 8) / 255,\n    (hex & 0xff) / 255,\n    1\n  );\n}\n\nexport function color4FromHex4(hex: number, out?: Vec4) {\n  out = out || [0, 0, 0, 0];\n\n  return apply4(\n    out,\n    ((hex & 0xff000000) >> 24) / 255,\n    ((hex & 0xff0000) >> 16) / 255,\n    ((hex & 0xff00) >> 8) / 255,\n    (hex & 0xff) / 255\n  );\n}\n\nexport function slerpQuat(from: Vec4, to: Vec4, t: number, out?: Vec4): Vec4 {\n  out = out || [0, 0, 0, 0];\n  const to1: Vec4 = [0, 0, 0, 0];\n  let omega, cosom, sinom, scale0, scale1;\n  cosom = from[1] * to[1] + from[2] * to[2] + from[3] * to[3] + from[0] * to[0];\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    to1[0] = -to[0];\n    to1[1] = -to[1];\n    to1[2] = -to[2];\n    to1[3] = -to[3];\n  } else {\n    to1[0] = to[0];\n    to1[1] = to[1];\n    to1[2] = to[2];\n    to1[3] = to[3];\n  }\n\n  // Calculate coefficients for final values. We use SLERP if the difference between the two angles isn't too big.\n  if (1.0 - cosom > 0.0000001) {\n    omega = acos(cosom);\n    sinom = sin(omega);\n    scale0 = sin((1.0 - t) * omega) / sinom;\n    scale1 = sin(t * omega) / sinom;\n  }\n\n  // We linear interpolate for quaternions that are very close together in angle.\n  else {\n    scale0 = 1.0 - t;\n    scale1 = t;\n  }\n\n  // calculate final values\n  out[1] = scale0 * from[1] + scale1 * to1[1];\n  out[2] = scale0 * from[2] + scale1 * to1[2];\n  out[3] = scale0 * from[3] + scale1 * to1[3];\n  out[0] = scale0 * from[0] + scale1 * to1[0];\n\n  return out;\n}\n\n// Vec method aggregations\nexport type VecMethods<T extends Vec> = {\n  add(left: T, right: T, out?: T): T;\n  ceil(vec: T, out?: T): T;\n  copy(vec: T, out?: T): T;\n  compare(left: T, right: T): boolean;\n  cross(left: T, right: T, out?: T): T;\n  divide(top: T, bottom: T, out?: T): T;\n  dot(left: T, right: T): number;\n  empty(out?: T): T;\n  flatten(list: T[], out?: number[]): number[];\n  floor(vec: T, out?: T): T;\n  forward(vec: T, out?: T): T;\n  inverse(vec: T, out?: T): T;\n  length(vec: T): number;\n  linear(start: T, end: T, t: number, out?: T): T;\n  max(left: T, right: T, out?: T): T;\n  min(left: T, right: T, out?: T): T;\n  multiply(left: T, right: T, out?: T): T;\n  normalize(vec: T, out?: T): T;\n  scale(vec: T, scale: number, out?: T): T;\n  subtract(left: T, right: T, out?: T): T;\n  vec(values: number[] | number, ...args: (number | number[])[]): T;\n  slerpQuat?(start: T, end: T, t: number, out?: T): T;\n};\n\nexport const vec1Methods: VecMethods<Vec1> = {\n  add: add1,\n  ceil: ceil1,\n  copy: copy1,\n  compare: compare1,\n  cross: cross1,\n  divide: divide1,\n  dot: dot1,\n  empty: empty1,\n  flatten: flatten1,\n  floor: floor1,\n  forward: forward1,\n  inverse: inverse1,\n  length: length1,\n  linear: linear1,\n  max: max1,\n  min: min1,\n  multiply: multiply1,\n  normalize: normalize1,\n  scale: scale1,\n  subtract: subtract1,\n  vec: vec1\n};\n\nexport const vec2Methods: VecMethods<Vec2> = {\n  add: add2,\n  ceil: ceil2,\n  copy: copy2,\n  compare: compare2,\n  cross: cross2,\n  divide: divide2,\n  dot: dot2,\n  empty: empty2,\n  flatten: flatten2,\n  floor: floor2,\n  forward: forward2,\n  inverse: inverse2,\n  length: length2,\n  linear: linear2,\n  max: max2,\n  min: min2,\n  multiply: multiply2,\n  normalize: normalize2,\n  scale: scale2,\n  subtract: subtract2,\n  vec: vec2\n};\n\nexport const vec3Methods: VecMethods<Vec3> = {\n  add: add3,\n  ceil: ceil3,\n  copy: copy3,\n  compare: compare3,\n  cross: cross3,\n  divide: divide3,\n  dot: dot3,\n  empty: empty3,\n  flatten: flatten3,\n  floor: floor3,\n  forward: forward3,\n  inverse: inverse3,\n  length: length3,\n  linear: linear3,\n  max: max3,\n  min: min3,\n  multiply: multiply3,\n  normalize: normalize3,\n  scale: scale3,\n  subtract: subtract3,\n  vec: vec3\n};\n\nexport const vec4Methods: VecMethods<Vec4> = {\n  add: add4,\n  ceil: ceil4,\n  copy: copy4,\n  compare: compare4,\n  cross: cross4,\n  divide: divide4,\n  dot: dot4,\n  empty: empty4,\n  flatten: flatten4,\n  floor: floor4,\n  forward: forward4,\n  inverse: inverse4,\n  length: length4,\n  linear: linear4,\n  max: max4,\n  min: min4,\n  multiply: multiply4,\n  normalize: normalize4,\n  scale: scale4,\n  subtract: subtract4,\n  vec: vec4,\n  slerpQuat: slerpQuat\n};\n\nexport function VecMath<T extends IVec>(vec: T): VecMethods<T> {\n  let methods: VecMethods<T>;\n\n  if (vec.length === 1) {\n    methods = vec1Methods as VecMethods<T>;\n    return methods;\n  } else if (vec.length === 2) {\n    methods = vec2Methods as VecMethods<T>;\n    return methods;\n  } else if (vec.length === 3) {\n    methods = vec3Methods as VecMethods<T>;\n    return methods;\n  }\n\n  methods = vec4Methods as VecMethods<T>;\n\n  return methods;\n}\n\nexport function toString1(v: Vec1Compat): string {\n  return `[${v[0]}]`;\n}\n\nexport function toString2(v: Vec2Compat): string {\n  return `[${v[0]}, ${v[1]}]`;\n}\n\nexport function toString3(v: Vec3Compat): string {\n  return `[${v[0]}, ${v[1]}, ${v[2]}]`;\n}\n\nexport function toString4(v: Vec4Compat): string {\n  return `[${v[0]}, ${v[1]}, ${v[2]}, ${v[3]}]`;\n}\n","export * from \"./camera\";\nexport * from \"./common-filters\";\nexport * from \"./common-operations\";\nexport * from \"./common-options\";\nexport * from \"./easing-util\";\nexport * from \"./frame\";\nexport * from \"./mouse\";\nexport * from \"./promise-resolver\";\nexport * from \"./quad-tree\";\nexport * from \"./reactive-diff\";\nexport * from \"./shader-templating\";\nexport * from \"./shallow-compare\";\nexport * from \"./uid\";\nexport * from \"./wait\";\nexport * from \"./wait-for-valid-dimensions\";\nexport * from \"./create\";\nexport * from \"./create-attribute\";\nexport * from \"./create-layer\";\nexport * from \"./create-uniform\";\nexport * from \"./create-vertex\";\n","export * from \"./attribute\";\nexport * from \"./geometry\";\nexport * from \"./gl-decode\";\nexport * from \"./gl-proxy\";\nexport * from \"./gl-settings\";\nexport * from \"./gl-state\";\nexport * from \"./material\";\nexport * from \"./model\";\nexport * from \"./render-target\";\nexport * from \"./scene\";\nexport * from \"./texture\";\nexport * from \"./types\";\nexport * from \"./webgl-renderer\";\nexport * from \"./webgl-stat\";\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","import { Instance } from \"../../instance-provider\";\nimport { ILayerProps, Layer } from \"../../surface\";\nimport { IShaderInitialization } from \"../../types\";\n\nexport interface ILayer2DProps<TInstance extends Instance>\n  extends ILayerProps<TInstance> {}\n\n/**\n * Base layer for the 2D world layering system. This essentially just requires the Camera2D to be an available\n * property of the Layer2D as well as provide the 2D projection methods to the layers.\n */\nexport class Layer2D<\n  TInstance extends Instance,\n  UProps extends ILayer2DProps<TInstance>\n> extends Layer<TInstance, UProps> {\n  /**\n   * Force the world2D methods as the base methods\n   */\n  baseShaderModules(shaderIO: IShaderInitialization<TInstance>) {\n    const modules = super.baseShaderModules(shaderIO);\n    modules.vs.push(\"world2D\");\n\n    return modules;\n  }\n}\n","import { Vec2 } from \"../vector\";\n\nconst { min, max } = Math;\n\nexport interface IBoundsOptions {\n  /** Top left x position */\n  x?: number;\n  /** Top left y position */\n  y?: number;\n  /** Width covered */\n  width?: number;\n  /** height covered */\n  height?: number;\n\n  /** Specify the left */\n  left?: number;\n  /** Specify the right */\n  right?: number;\n  /** Specify the top */\n  top?: number;\n  /** Specify the bottom */\n  bottom?: number;\n}\n\n/**\n * Class to manage the x, y, width, and height of an object\n *\n * @template T This specifies the data type associated with this shape and is accessible\n *             via the property 'd'\n */\nexport class Bounds<T> {\n  x: number = 0;\n  y: number = 0;\n  width: number = 0;\n  height: number = 0;\n  d?: T;\n\n  get area() {\n    return this.width * this.height;\n  }\n\n  get bottom() {\n    return this.y + this.height;\n  }\n\n  get left() {\n    return this.x;\n  }\n\n  get mid(): Vec2 {\n    return [this.x + this.width / 2.0, this.y + this.height / 2.0];\n  }\n\n  get right() {\n    return this.x + this.width;\n  }\n\n  get top() {\n    return this.y;\n  }\n\n  static emptyBounds<T>() {\n    return new Bounds<T>({\n      height: 0,\n      width: 0,\n      x: 0,\n      y: 0\n    });\n  }\n\n  /**\n   * Create a new instance\n   *\n   * @param left  The left side (x coordinate) of the instance\n   * @param right The right side of the instance\n   * @param top The top (y coordinate) of the instance\n   * @param bottom The bottom of the instance\n   */\n  constructor(options: IBoundsOptions) {\n    this.x = options.x || options.left || 0;\n    this.y = options.y || options.top || 0;\n    this.height = options.height || (options.bottom || 0) - this.y || 0;\n    this.width = options.width || (options.right || 0) - this.x || 0;\n  }\n\n  /**\n   * Checks to see if a point is within this bounds object.\n   *\n   * @param point\n   */\n  containsPoint(point: Vec2) {\n    return !(\n      point[0] < this.x ||\n      point[1] < this.y ||\n      point[0] > this.right ||\n      point[1] > this.bottom\n    );\n  }\n\n  /**\n   * Grows this bounds object to cover the space of the provided bounds object\n   *\n   * @param item\n   */\n  encapsulate(item: Bounds<any> | Vec2) {\n    if (item instanceof Bounds) {\n      if (item.x < this.x) {\n        this.width += Math.abs(item.x - this.x);\n        this.x = item.x;\n      }\n\n      if (item.y < this.y) {\n        this.height += Math.abs(item.y - this.y);\n        this.y = item.y;\n      }\n\n      if (this.right < item.right) {\n        this.width += item.right - this.right;\n      }\n\n      if (this.bottom < item.bottom) {\n        this.height += item.bottom - this.bottom;\n      }\n\n      return true;\n    } else {\n      if (item[0] < this.x) {\n        this.width += this.x - item[0];\n        this.x = item[0];\n      }\n\n      if (item[0] > this.right) {\n        this.width += item[0] - this.x;\n      }\n\n      if (item[1] < this.y) {\n        this.height += this.y - item[1];\n        this.y = item[1];\n      }\n\n      if (item[1] > this.bottom) {\n        this.height += item[1] - this.y;\n      }\n\n      return true;\n    }\n  }\n\n  /**\n   * Grows the bounds (if needed) to encompass all bounds or points provided. This\n   * performs much better than running encapsulate one by one.\n   */\n  encapsulateAll(all: Bounds<any>[] | Vec2[]) {\n    // Nothing provided, nothing to do\n    if (all.length <= 0) return;\n    // Stores max boundaries found\n    let minX = Number.MAX_SAFE_INTEGER,\n      maxX = Number.MIN_SAFE_INTEGER,\n      minY = Number.MAX_SAFE_INTEGER,\n      maxY = Number.MIN_SAFE_INTEGER;\n\n    // Handle list of bounds\n    if (all[0] instanceof Bounds) {\n      const boundsList = all as Bounds<T>[];\n\n      for (let i = 0, iMax = boundsList.length; i < iMax; ++i) {\n        const bounds = boundsList[i];\n        minX = min(minX, bounds.left);\n        maxX = max(maxX, bounds.right);\n        minY = min(minY, bounds.top);\n        maxY = max(maxY, bounds.bottom);\n      }\n    }\n\n    // Handle list of points\n    else {\n      const pointsList = all as Vec2[];\n\n      for (let i = 0, iMax = pointsList.length; i < iMax; ++i) {\n        const [x, y] = pointsList[i];\n        minX = min(minX, x);\n        maxX = max(maxX, x);\n        minY = min(minY, y);\n        maxY = max(maxY, y);\n      }\n    }\n\n    this.x = Math.min(this.x, minX);\n    this.y = Math.min(this.y, minY);\n    this.width = Math.max(this.width, maxX - minX);\n    this.height = Math.max(this.height, maxY - minY);\n  }\n\n  /**\n   * Checks to see if the provided bounds object could fit within the dimensions of this bounds object\n   * This ignores position and just checks width and height.\n   *\n   * @param bounds\n   *\n   * @return {number} 0 if it doesn't fit. 1 if it fits perfectly. 2 if it just fits.\n   */\n  fits(bounds: Bounds<T>): 0 | 1 | 2 {\n    // If the same, the bounds fits exactly into this bounds\n    if (this.width === bounds.width && this.height === bounds.height) {\n      return 1;\n    }\n\n    // The bounds can fit within this, then it just fits\n    if (this.width >= bounds.width && this.height >= bounds.height) {\n      return 2;\n    }\n\n    // Otherwise, the bounds does not fit within this bounds\n    return 0;\n  }\n\n  /**\n   * Checks if a bounds object intersects another bounds object.\n   *\n   * @param bounds\n   */\n  hitBounds(bounds: Bounds<any>) {\n    return !(\n      this.right < bounds.x ||\n      this.x > bounds.right ||\n      this.bottom < bounds.y ||\n      this.y > bounds.bottom\n    );\n  }\n\n  /**\n   * Sees if the provided bounds is completely within this bounds object. Unlike fits() this takes\n   * position into account.\n   *\n   * @param bounds\n   */\n  isInside(bounds: Bounds<any>): boolean {\n    return (\n      this.x >= bounds.x &&\n      this.right <= bounds.right &&\n      this.y >= bounds.y &&\n      this.bottom <= bounds.bottom\n    );\n  }\n\n  /**\n   * Top left position of the bounds\n   */\n  get location(): Vec2 {\n    return [this.x, this.y];\n  }\n\n  /**\n   * Easy readout of this Bounds object.\n   */\n  toString() {\n    return `{x: ${this.x} y:${this.y} w:${this.width} h:${this.height}}`;\n  }\n}\n","/** Important to start UIDs at 1 so that falsey evaluations do not pass when examining UIDs */\nlet UID = 1;\n\n/**\n * Provides a 64 bit UID.\n *\n * Note: all uids generated with uid() are unique amongst uid() calls and NOT unique amongst\n * other types of uid calls.\n */\nexport function uid() {\n  return ++UID;\n}\n\nlet CUID = 0;\n\n/**\n * Provides a 24 bit UID (keeps the UID within non-alpha color ranges)\n *\n * Note: all uids generated with colorUID() are unique amongst colorUID() calls and NOT unique amongst\n * other types of uid calls.\n */\nexport function colorUID() {\n  return ++CUID % 0xffffff;\n}\n","export * from \"./base-shader-io-injection\";\nexport * from \"./shader-module-unit\";\nexport * from \"./shader-module\";\nexport * from \"./inject-shader-io\";\nexport * from \"./pack-attributes\";\nexport * from \"./base-io-sorting\";\n","/**\n * These are all of the settings that can be used to configure the GL state of the system\n */\nexport namespace GLSettings {\n  /**\n   * Settings used when defining render target parameters\n   */\n  export namespace RenderTarget {\n    /**\n     * Specifies the internal format of the color buffer for a render target\n     * when not using a Texture. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/renderbufferStorage\n     */\n    export enum ColorBufferFormat {\n      RGBA4,\n      RGB565,\n      RGB5_A1,\n\n      /** WebGL 2 Format */\n      R8,\n      /** WebGL 2 Format */\n      R8UI,\n      /** WebGL 2 Format */\n      R8I,\n      /** WebGL 2 Format */\n      R16UI,\n      /** WebGL 2 Format */\n      R16I,\n      /** WebGL 2 Format */\n      R32UI,\n      /** WebGL 2 Format */\n      R32I,\n      /** WebGL 2 Format */\n      RG8,\n      /** WebGL 2 Format */\n      RG8UI,\n      /** WebGL 2 Format */\n      RG8I,\n      /** WebGL 2 Format */\n      RG16UI,\n      /** WebGL 2 Format */\n      RG16I,\n      /** WebGL 2 Format */\n      RG32UI,\n      /** WebGL 2 Format */\n      RG32I,\n      /** WebGL 2 Format */\n      RGB8,\n      /** WebGL 2 Format */\n      RGBA8,\n      /** WebGL 2 Format */\n      SRGB8_ALPHA8,\n      /** WebGL 2 Format */\n      RGB10_A2,\n      /** WebGL 2 Format */\n      RGBA8UI,\n      /** WebGL 2 Format */\n      RGBA8I,\n      /** WebGL 2 Format */\n      RGB10_A2UI,\n      /** WebGL 2 Format */\n      RGBA16UI,\n      /** WebGL 2 Format */\n      RGBA16I,\n      /** WebGL 2 Format */\n      RGBA32I,\n      /** WebGL 2 Format */\n      RGBA32UI\n    }\n\n    /**\n     * Specifies the internal format of the depth buffer for a render target\n     * when not using a Texture. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/renderbufferStorage\n     */\n    export enum DepthBufferFormat {\n      DEPTH_COMPONENT16,\n      DEPTH_STENCIL,\n\n      /** WebGL 2 Format */\n      DEPTH_COMPONENT24,\n      /** WebGL 2 Format */\n      DEPTH_COMPONENT32F,\n      /** WebGL 2 Format */\n      DEPTH24_STENCIL8,\n      /** WebGL 2 Format */\n      DEPTH32F_STENCIL8\n    }\n\n    /**\n     * Specifies the internal format of the stencil buffer for a render target\n     * when not using a Texture. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/renderbufferStorage\n     */\n    export enum StencilBufferFormat {\n      STENCIL_INDEX8\n    }\n  }\n\n  export namespace Material {\n    /**\n     * Sets the blending function to be either a preset blending function or enables the\n     * use of a Custom blending equation. WHen custom is set, the Dst, Src factors, and blending\n     * equation settings come into play\n     */\n    export enum Blending {\n      NoBlending = -1,\n      NormalBlending = 1,\n      AdditiveBlending = 2,\n      SubtractiveBlending = 3,\n      MultiplyBlending = 4\n    }\n\n    /**\n     * Specifies the Destination factor for the blending equation see:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendFunc\n     */\n    export enum BlendingDstFactor {\n      Zero = -1,\n      One = 1,\n      SrcColor = 2,\n      OneMinusSrcColor = 3,\n      SrcAlpha = 4,\n      OneMinusSrcAlpha = 5,\n      DstAlpha = 6,\n      OneMinusDstAlpha = 7,\n      DstColor = 8,\n      OneMinusDstColor = 9\n    }\n\n    /**\n     * Specifies the Source factor for the blending equation see:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendFunc\n     */\n    export enum BlendingSrcFactor {\n      Zero = -1,\n      One = 1,\n      SrcColor = 2,\n      OneMinusSrcColor = 3,\n      SrcAlpha = 4,\n      OneMinusSrcAlpha = 5,\n      DstAlpha = 6,\n      OneMinusDstAlpha = 7,\n      DstColor = 8,\n      OneMinusDstColor = 9,\n      SrcAlphaSaturate = 10\n    }\n\n    /**\n     * Specifies the blending equation see:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendEquation\n     */\n    export enum BlendingEquations {\n      Add = -1,\n      Subtract = 1,\n      ReverseSubtract = 2\n      /** Requires extension for Webgl 1.0 */\n      // Min = 3,\n      // Max = 4\n    }\n\n    /**\n     * Specifies the Depth comparison function for determining if a fragment should be drawn when it's\n     * depth is compared against the depth buffer see:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/depthFunc\n     */\n    export enum DepthFunctions {\n      NEVER = -1,\n      LESS = 1,\n      EQUAL = 2,\n      LESS_OR_EQUAL = 3,\n      GREATER = 4,\n      NOTEQUAL = 5,\n      GREATER_OR_EQUAL = 6,\n      ALWAYS = 7\n    }\n\n    /**\n     * Specifies which side of the polygon should be culled or not. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/cullFace\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/frontFace\n     */\n    export enum CullSide {\n      NONE = -1,\n      CW = 1,\n      CCW = 2,\n      BOTH = 3\n    }\n  }\n\n  /**\n   * These are settings applied to a model\n   */\n  export namespace Model {\n    export enum DrawMode {\n      LINE_LOOP,\n      LINE_STRIP,\n      LINES,\n      POINTS,\n      TRIANGLE_FAN,\n      TRIANGLE_STRIP,\n      TRIANGLES\n    }\n  }\n\n  /**\n   * Settings that are applied to textures\n   */\n  export namespace Texture {\n    /**\n     * Specifies which target to bind the texture to. 2D or a cubemap.\n     */\n    export enum TextureBindingTarget {\n      TEXTURE_2D,\n      CUBE_MAP\n    }\n\n    /**\n     * The wrap mode when reading values outside of 0 - 1 when sampling the texture. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n     */\n    export enum Wrapping {\n      REPEAT = -1,\n      CLAMP_TO_EDGE = 1,\n      MIRRORED_REPEAT = 2\n    }\n\n    /**\n     * The interpolation method to use when sampling between texels when the render space is smaller than the texture. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n     */\n    export enum TextureMinFilter {\n      Nearest = -1,\n      NearestMipMapNearest = 1,\n      NearestMipMapLinear = 2,\n      Linear = 3,\n      LinearMipMapNearest = 4,\n      LinearMipMapLinear = 5\n    }\n\n    /**\n     * The interpolation method to use when sampling between texels when the render space is larger than the texture. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n     */\n    export enum TextureMagFilter {\n      Nearest = -1,\n      Linear = 1\n    }\n\n    /**\n     * This is the format of the input texture. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n     */\n    export enum SourcePixelFormat {\n      /**\n       * Highly supported webgl 1\n       * Pairs with: TexelDataType.RGBA, RGB, LuminanceAlpha, Luminance, Alpha\n       */\n      UnsignedByte = -1,\n      /**\n       * Highly supported webgl 1\n       * Pairs with: TexelDataType.RGB\n       */\n      UnsignedShort_5_6_5 = 1,\n      /**\n       * Highly supported webgl 1\n       * Pairs with: TexelDataType.RGBA\n       */\n      UnsignedShort_4_4_4_4 = 2,\n      /**\n       * Highly supported webgl 1\n       * Pairs with: TexelDataType.RGBA\n       */\n      UnsignedShort_5_5_5_1 = 3,\n      /** Depth texture or Webgl 2 */\n      UnsignedShort = 4,\n      /** Depth texture or Webgl 2 */\n      UnsignedInt = 5,\n      /** Depth texture extension or Webgl 2 */\n      UnsignedInt_24_8 = 6,\n      /** Webgl 2 */\n      Byte = 7,\n      /** Webgl 2 */\n      Short = 8,\n      /** Webgl 2 */\n      Int = 9,\n      /** Webgl 2 */\n      Float = 10,\n      /** Webgl 2 */\n      HalfFloat = 11,\n      /** Webgl 2 */\n      UnsignedInt_2_10_10_10_REV = 12,\n      /** Webgl 2 */\n      UnsignedInt_10F_11F_11F_REV = 13,\n      /** Webgl 2 */\n      UnsignedInt_5_9_9_9_REV = 14,\n      /** Webgl 2 */\n      Float32UnsignedInt_24_8_REV = 15\n    }\n\n    /**\n     * This is the data format the texels in the texture will take on. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n     *\n     * For valid combinations in WebGL 2 visit:\n     * https://www.khronos.org/registry/webgl/specs/latest/2.0/\n     *\n     * Search for [throws] void texImage2D to reach the table that shows all\n     * cobinations.\n     */\n    export enum TexelDataType {\n      /**\n       * Discards the red, green and blue components and reads the alpha component.\n       * Pairs with: UNSIGNED_BYTE\n       */\n      Alpha = -1,\n      /**\n       * Requires Depth extension or webgl2\n       */\n      DepthComponent = 1,\n      /**\n       * Requires Depth extension or webgl2\n       */\n      DepthStencil = 2,\n      /**\n       * Each color component is a luminance component, alpha is 1.0.\n       * Pairs with:\n       */\n      Luminance = 3,\n      /**\n       * Each component is a luminance/alpha component.\n       */\n      LuminanceAlpha = 4,\n      /**\n       * Discards the alpha components and reads the red, green and blue components.\n       * Pairs with:\n       */\n      RGB = 5,\n      /**\n       * Red, green, blue and alpha components are read from the color buffer.\n       */\n      RGBA = 6,\n      RGBE = 7,\n\n      /** WebGL 2 texel format */\n      R8 = 8,\n      /** WebGL 2 texel format */\n      R16F = 9,\n      /** WebGL 2 texel format */\n      R32F = 10,\n      /** WebGL 2 texel format */\n      R8UI = 11,\n      /** WebGL 2 texel format */\n      RG8 = 12,\n      /** WebGL 2 texel format */\n      RG16F = 13,\n      /** WebGL 2 texel format */\n      RG32F = 14,\n      /** WebGL 2 texel format */\n      RG8UI = 15,\n      /** WebGL 2 texel format */\n      RG16UI = 16,\n      /** WebGL 2 texel format */\n      RG32UI = 17,\n      /** WebGL 2 texel format */\n      RGB8 = 18,\n      /** WebGL 2 texel format */\n      SRGB8 = 19,\n      /** WebGL 2 texel format */\n      RGB565 = 20,\n      /** WebGL 2 texel format */\n      R11F_G11F_B10F = 21,\n      /** WebGL 2 texel format */\n      RGB9_E5 = 22,\n      /** WebGL 2 texel format */\n      RGB16F = 23,\n      /** WebGL 2 texel format */\n      RGB32F = 24,\n      /** WebGL 2 texel format */\n      RGB8UI = 25,\n      /** WebGL 2 texel format */\n      RGBA8 = 26,\n      /** WebGL 2 texel format */\n      SRGB8_ALPHA8 = 27,\n      /** WebGL 2 texel format */\n      RGB5_A1 = 28,\n      /** WebGL 2 texel format */\n      RGB10_A2 = 29,\n      /** WebGL 2 texel format */\n      RGBA4 = 30,\n      /** WebGL 2 texel format */\n      RGBA16F = 31,\n      /** WebGL 2 texel format */\n      RGBA32F = 32,\n      /** WebGL 2 texel format */\n      RGBA8UI = 33,\n      /** WebGL 2 texel format */\n      DEPTH_COMPONENT16 = 34,\n      /** WebGL 2 texel format */\n      DEPTH_COMPONENT24 = 35,\n      /** WebGL 2 texel format */\n      DEPTH_COMPONENT32F = 36,\n      /** WebGL 2 texel format */\n      RGBA32UI = 37,\n      /** WebGL 2 texel format */\n      RGB32UI = 38,\n      /** WebGL 2 texel format */\n      RGBA16UI = 39,\n      /** WebGL 2 texel format */\n      RGB16UI = 40,\n      /** WebGL 2 texel format */\n      RGBA32I = 41,\n      /** WebGL 2 texel format */\n      RGB32I = 42,\n      /** WebGL 2 texel format */\n      RGBA16I = 43,\n      /** WebGL 2 texel format */\n      RGB16I = 44,\n      /** WebGL 2 texel format */\n      RGBA8I = 45,\n      /** WebGL 2 texel format */\n      RGB8I = 46,\n\n      /** WebGL 2 texel format */\n      RED_INTEGER = 47,\n      /** WebGL 2 texel format */\n      RG_INTEGER = 48,\n      /** WebGL 2 texel format */\n      RGB_INTEGER = 49,\n      /** WebGL 2 texel format */\n      RGBA_INTEGER = 50\n    }\n\n    /**\n     * This specifies hwo the texture data is unpacked when using gl.readPixels. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei\n     * https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glPixelStorei.xml\n     */\n    export enum PackAlignment {\n      /** Byte-alignment */\n      ONE = 1,\n      /** Rows aligned to even-numbered bytes */\n      TWO = 2,\n      /** Word-alignment */\n      FOUR = 4,\n      /** Rows start on double-word boundaries */\n      EIGHT = 8\n    }\n\n    /**\n     * This specifies how the texture data is packed into memory (for gl.texImage2D and gl.texSubImage2D) See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei\n     * https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glPixelStorei.xml\n     */\n    export enum UnpackAlignment {\n      /** Byte-alignment */\n      ONE = 1,\n      /** Rows aligned to even-numbered bytes */\n      TWO = 2,\n      /** Word-alignment */\n      FOUR = 4,\n      /** Rows start on double-word boundaries */\n      EIGHT = 8\n    }\n  }\n\n  /**\n   * Settings associated with the Renderer\n   */\n  export namespace Renderer {\n    /**\n     * This specifies what data is read out and how\n     */\n    export enum ReadFilter {\n      ALPHA,\n      RGB,\n      RGBA\n    }\n\n    /**\n     * Specifies the data format of the array buffer the data is read into\n     */\n    export enum ReadTargetArrayFormat {\n      UNSIGNED_BYTE,\n      UNSIGNED_SHORT_5_6_5,\n      UNSIGNED_SHORT_4_4_4_4,\n      UNSIGNED_SHORT_5_5_5_1,\n      FLOAT\n    }\n  }\n}\n","import { IEasingControl, IEasingProps } from \"../types\";\nimport { EasingProps } from \"../util/easing-props\";\nimport { InstanceProvider } from \"./instance-provider\";\nimport { observable } from \"./observable\";\n\nlet instanceUID = 0;\n\nexport interface IInstanceOptions {\n  /** The instance can be declared with an initial active state */\n  active?: boolean;\n  /** An instance must be declared with an identifier */\n  id?: string;\n}\n\nexport class Instance {\n  static get newUID() {\n    return (instanceUID = ++instanceUID % 0xffffff);\n  }\n\n  /** This indicates when the instance is active / rendering */\n  get active() {\n    return this._active;\n  }\n  set active(val: boolean) {\n    this._active = val;\n    this.reactivate = true;\n  }\n  @observable _active: boolean;\n  /** The property changes on the instance */\n  changes: { [key: number]: number } = {};\n  /**\n   * This is a lookup that provides a means to retrieve the id of an easing type\n   * currently available to the instance. This is populated when the instance\n   * becomes a part of a layer with easing attributes.\n   *\n   * This property is to NOT be mutated except by the system.\n   */\n  easingId: { [key: string]: number } | undefined;\n  /**\n   * This is an internal easing object to track properties for automated easing\n   */\n  easing?: Map<number, IEasingProps>;\n  /** This is the observer of the Instance's observable properties */\n  private _observer: InstanceProvider<this> | null;\n  /** This is where observables store their data for the instance */\n  observableStorage: any[] = [];\n  /**\n   * A numerical look up for the instance. Numerical identifiers run faster than\n   * objects or strings\n   */\n  @observable private _uid = Instance.newUID;\n  /**\n   * This is the flag indicating this instance was reactivated. When true, this\n   * performs a full update of all properties on the instance\n   */\n  reactivate: boolean = false;\n\n  /**\n   * Retrieves a method for disposing the link between observables and observer.\n   */\n  get observableDisposer(): () => void {\n    return () => delete this._observer;\n  }\n\n  /**\n   * Retrieves the observer of the observables.\n   */\n  get observer(): InstanceProvider<this> | null {\n    return this._observer || null;\n  }\n\n  /**\n   * Applies an observer for changes to the observables.\n   */\n  set observer(val: InstanceProvider<this> | null) {\n    // If an observer already is present, we should inform it, that it is being\n    // removed in favor of a new observer\n    const oldObserver = this._observer;\n\n    // If we're switching observers, then we have to dump out assumptions made\n    // within other observers\n    if (oldObserver && oldObserver !== val) {\n      if (this.easing) this.easing.clear();\n      oldObserver.remove(this);\n    }\n\n    // Apply the new observer as the current observer\n    this._observer = val;\n  }\n\n  /**\n   * This attempts to get the easing object for this instance for a given\n   * attribute that it MIGHT be associated with.\n   *\n   * When an instance is added to a layer and the layer has attributes with\n   * easing applied to them, the instance gains easing values for the attributes\n   * in the layer with applied easing.\n   *\n   * You can access the easing values by requesting the attribute's \"name\"\n   * property value using this method.\n   *\n   * There is NO WAY TO GUARANTEE this value is set or available, so this method\n   * WILL return undefined if you did not use the correct name, or no such value\n   * exists, or the layer decided to not make the attribute animateable.\n   *\n   * Thus ALWAYS check the returned value to ensure it is defined before\n   * attempting to use it's results.\n   *\n   * PERFORMANCE: You can probably get much better performance NOT using this to\n   * manipulate the easing object directly. The system is designed to\n   * automatically animate an item from it's current rendered location to the\n   * next location seamlessly thus accounting for most situations. This method\n   * is provided to commit much more complex start, duration, and delay\n   * animations within a given frame to prevent the need for complicated\n   * setTimeout patterns.\n   *\n   * This CAN be faster than the default behavior if it avoids causing\n   * complicated easing computations to determine where the rendering should be\n   * at the moment (complicated cpu methods within the IAutoEasingMethod used).\n   */\n  getEasing(attributeName: string): IEasingControl | undefined {\n    if (this.easingId) {\n      // If easing has been applied to an attribute, the attribute that will\n      // have it is the name mangled _{base name}_end format.\n      const easingId = this.easingId[`_${attributeName}_end`];\n\n      if (easingId && this.easing) {\n        const easing = this.easing.get(easingId);\n\n        if (easing instanceof EasingProps) {\n          return easing;\n        }\n      }\n    }\n\n    return;\n  }\n\n  /**\n   * Get the auto generated ID of this instance\n   */\n  get uid() {\n    return this._uid;\n  }\n\n  /**\n   * This method is utilized internally to indicate when requested resources are\n   * ready. If you have a property that will be requesting a resource, you\n   * should implement this method to cause a trigger for the property to\n   * activate such that the property will update it's buffer.\n   */\n  resourceTrigger() {\n    // No default behavior, subclasses must override and provide behavior.\n    console.warn(\n      \"resourceTrigger called on an instance that did not override resourceTrigger. resourceTrigger MUST be overridden for instances\",\n      \"that utilize a resource. The observable that is tied to committing the resource should be 'triggered' in this method.\"\n    );\n  }\n\n  constructor(options?: IInstanceOptions) {\n    if (options) {\n      this.active = options.active || this.active;\n    }\n  }\n}\n","export * from \"./auto-easing-method\";\nexport * from \"./base-projection\";\nexport * from \"./matrix\";\nexport * from \"./quaternion\";\nexport * from \"./vector\";\nexport * from \"./primitives\";\nexport * from \"./ray\";\n\nimport * as matrix from \"./matrix\";\nimport * as quaternion from \"./quaternion\";\nimport * as ray from \"./ray\";\nimport * as vector from \"./vector\";\n\n/**\n * This is a convenience lookup to see all of the math methods available for\n * manipulating matrices. All of the methods can be imported directly if you\n * know which method you are looking for. This Just helps you find a method you\n * may not know the name of.\n */\nexport const MatrixMath = matrix;\n/**\n * This is a convenience lookup to see all of the math methods available for\n * manipulating quaternions. All of the methods can be imported directly if you\n * know which method you are looking for. This Just helps you find a method you\n * may not know the name of.\n */\nexport const QuaternionMath = quaternion;\n/**\n * This is a convenience lookup to see all of the math methods available for\n * manipulating rays. All of the methods can be imported directly if you\n * know which method you are looking for. This Just helps you find a method you\n * may not know the name of.\n */\nexport const RayMath = ray;\n/**\n * This is a convenience lookup to see all of the math methods available for\n * manipulating vectors. All of the methods can be imported directly if you know\n * which method you are looking for. This Just helps you find a method you may\n * not know the name of.\n */\nexport const VectorMath = vector;\n","export * from \"./layer-interaction-handler\";\nexport * from \"./layer-scene\";\nexport * from \"./layer\";\nexport * from \"./surface\";\nexport * from \"./view\";\nexport * from \"./buffer-management\";\nexport * from \"./event-managers\";\nexport * from \"./layer-processing\";\nexport * from \"./command-layer\";\n","export function getProgramInfo(gl: WebGLRenderingContext, program: any) {\n  const result = {\n      attributeCount: 0,\n      attributes: new Array(),\n      uniformCount: 0,\n      uniforms: new Array()\n    },\n    activeUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS),\n    activeAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\n  // Taken from the WebGl spec:\n  // Http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14\n  const enums: { [key: number]: string } = {\n    0x8b50: \"FLOAT_VEC2\",\n    0x8b51: \"FLOAT_VEC3\",\n    0x8b52: \"FLOAT_VEC4\",\n    0x8b53: \"INT_VEC2\",\n    0x8b54: \"INT_VEC3\",\n    0x8b55: \"INT_VEC4\",\n    0x8b56: \"BOOL\",\n    0x8b57: \"BOOL_VEC2\",\n    0x8b58: \"BOOL_VEC3\",\n    0x8b59: \"BOOL_VEC4\",\n    0x8b5a: \"FLOAT_MAT2\",\n    0x8b5b: \"FLOAT_MAT3\",\n    0x8b5c: \"FLOAT_MAT4\",\n    0x8b5e: \"SAMPLER_2D\",\n    0x8b60: \"SAMPLER_CUBE\",\n    0x1400: \"BYTE\",\n    0x1401: \"UNSIGNED_BYTE\",\n    0x1402: \"SHORT\",\n    0x1403: \"UNSIGNED_SHORT\",\n    0x1404: \"INT\",\n    0x1405: \"UNSIGNED_INT\",\n    0x1406: \"FLOAT\"\n  };\n\n  const blocks: { [key: number]: number } = {\n    0x8b50: 1,\n    0x8b51: 1,\n    0x8b52: 1,\n    0x8b53: 1,\n    0x8b54: 1,\n    0x8b55: 1,\n    0x8b56: 1,\n    0x8b57: 1,\n    0x8b58: 1,\n    0x8b59: 1,\n    0x8b5a: 1,\n    0x8b5b: 3,\n    0x8b5c: 4,\n    0x8b5e: 1,\n    0x8b60: 1,\n    0x1400: 1,\n    0x1401: 1,\n    0x1402: 1,\n    0x1403: 1,\n    0x1404: 1,\n    0x1405: 1,\n    0x1406: 1\n  };\n\n  // Loop through active uniforms\n  for (let i = 0; i < activeUniforms; ++i) {\n    const uniform: any = gl.getActiveUniform(program, i);\n    uniform.typeName = enums[uniform.type];\n    result.uniforms.push(uniform);\n    result.uniformCount += uniform.size;\n    uniform.size = uniform.size * blocks[uniform.type];\n  }\n\n  // Loop through active attributes\n  for (let i = 0; i < activeAttributes; i++) {\n    const attribute: any = gl.getActiveAttrib(program, i);\n    attribute.typeName = enums[attribute.type];\n    result.attributes.push(attribute);\n    result.attributeCount += attribute.size;\n  }\n\n  return result;\n}\n\nexport class WebGLStat {\n  static VAO = false;\n  static DEPTH_TEXTURE = false;\n  static MAX_VERTEX_UNIFORMS = 0;\n  static MAX_FRAGMENT_UNIFORMS = 0;\n  static MAX_VERTEX_ATTRIBUTES = 0;\n  static WEBGL_SUPPORTED: boolean = false;\n  static MAX_TEXTURE_SIZE = 0;\n  static HARDWARE_INSTANCING = false;\n  static MRT_EXTENSION = false;\n  static MRT = false;\n  static MAX_COLOR_ATTACHMENTS = 0;\n  static SHADERS_3_0 = false;\n  static WEBGL_VERSION = \"none\";\n  static FLOAT_TEXTURE_READ = {\n    half: false,\n    full: false,\n    halfLinearFilter: false,\n    fullLinearFilter: false\n  };\n  static FLOAT_TEXTURE_WRITE = {\n    half: false,\n    full: false\n  };\n\n  static print() {\n    return Object.assign({}, WebGLStat);\n  }\n}\n\nfunction initStats() {\n  // Let's perform some immediate operations to do some gl querying for useful information\n  function getAContext():\n    | WebGLRenderingContext\n    | WebGL2RenderingContext\n    | null {\n    try {\n      const canvas = document.createElement(\"canvas\");\n      let out: any;\n      out = canvas.getContext(\"webgl2\");\n\n      if (out) {\n        WebGLStat.WEBGL_VERSION = \"webgl2\";\n        return out;\n      }\n\n      out = canvas.getContext(\"webgl\");\n\n      if (out) {\n        WebGLStat.WEBGL_VERSION = \"webgl\";\n        return out;\n      }\n\n      out = canvas.getContext(\"experimental-webgl\");\n\n      if (out) {\n        WebGLStat.WEBGL_VERSION = \"experimental-webgl\";\n        return out;\n      }\n\n      return null;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * There are several checks to perform to check for float texture support.\n   * There may be read support but not write support and there are full and half\n   * floats available.\n   */\n  function floatTextureSupport(\n    gl: WebGLRenderingContext | WebGL2RenderingContext\n  ) {\n    // Check for linear filtering on reads\n    WebGLStat.FLOAT_TEXTURE_READ.fullLinearFilter = Boolean(\n      gl.getExtension(\"OES_texture_float_linear\")\n    );\n    WebGLStat.FLOAT_TEXTURE_READ.halfLinearFilter = Boolean(\n      gl.getExtension(\"OES_texture_half_float_linear\")\n    );\n    // Generate a texture. Filtering for WebGL1 is basically disallowed, so we\n    // set the filters to nearest to disable it and prevent gl errors.\n    const textureFull = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, textureFull);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    if (gl.getError() !== gl.NO_ERROR) {\n      throw new Error(\"WebGLStat could not create a texture\");\n    }\n\n    // Having the extension enabled guarantees creating and reading float\n    // textures\n    const extensionEnabled =\n      gl.getExtension(\"OES_texture_float\") ||\n      gl.getExtension(\"EXT_color_buffer_float\");\n\n    // WebGL2 required extension\n    gl.getExtension(\"WEBGL_color_buffer_float\");\n\n    if (extensionEnabled) {\n      const width = 2;\n      const height = 2;\n\n      // If we get an error for allocating float texture style data then no gen\n      // or read from float textures\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        gl instanceof WebGL2RenderingContext ? gl.RGBA32F : gl.RGBA,\n        width,\n        height,\n        0,\n        gl.RGBA,\n        gl.FLOAT,\n        null\n      );\n\n      if (gl.getError() === gl.NO_ERROR) {\n        WebGLStat.FLOAT_TEXTURE_READ.full = true;\n      }\n\n      // Use this texture as a render target.\n      const fbo = gl.createFramebuffer();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n      gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.COLOR_ATTACHMENT0,\n        gl.TEXTURE_2D,\n        textureFull,\n        0\n      );\n      gl.bindTexture(gl.TEXTURE_2D, null);\n\n      // Frame buffer complete signal means writing to the float texture is more\n      // than likely supported\n      if (\n        gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE\n      ) {\n        WebGLStat.FLOAT_TEXTURE_WRITE.full = true;\n      }\n\n      // Clean up\n      gl.deleteFramebuffer(fbo);\n      gl.deleteTexture(textureFull);\n    }\n\n    // Repeat all the steps for a half float texture\n    const textureHalf = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, textureHalf);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    if (gl.getError() !== gl.NO_ERROR) {\n      throw new Error(\"WebGLStat could not create a texture\");\n    }\n\n    // Having the extension enabled guarantees creating and reading float\n    // textures\n    const halfExtension =\n      gl.getExtension(\"OES_texture_half_float\") ||\n      gl.getExtension(\"EXT_color_buffer_float\");\n\n    if (halfExtension) {\n      const width = 2;\n      const height = 2;\n\n      // If we get an error for allocating float texture style data then no gen\n      // or read from float textures\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        gl instanceof WebGL2RenderingContext ? gl.RGBA16F : gl.RGBA,\n        width,\n        height,\n        0,\n        gl.RGBA,\n        gl instanceof WebGL2RenderingContext\n          ? gl.HALF_FLOAT\n          : halfExtension.HALF_FLOAT_OES,\n        null\n      );\n\n      if (gl.getError() === gl.NO_ERROR) {\n        WebGLStat.FLOAT_TEXTURE_READ.full = true;\n      }\n\n      // Use this texture as a render target.\n      const fbo = gl.createFramebuffer();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n      gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.COLOR_ATTACHMENT0,\n        gl.TEXTURE_2D,\n        textureHalf,\n        0\n      );\n      gl.bindTexture(gl.TEXTURE_2D, null);\n      // Frame buffer complete signal means writing to the float texture is more\n      // than likely supported\n      if (\n        gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE\n      ) {\n        WebGLStat.FLOAT_TEXTURE_WRITE.full = true;\n      }\n\n      // Clean up\n      gl.deleteFramebuffer(fbo);\n      gl.deleteTexture(textureHalf);\n    }\n  }\n\n  // Attempt to retrieve a context for webgl\n  const gl = getAContext();\n\n  // If the context exists, then we know gl is supported and we can fill in some metrics\n  if (gl) {\n    // Perform universal checks\n    WebGLStat.WEBGL_SUPPORTED = true;\n    WebGLStat.MAX_VERTEX_UNIFORMS = gl.getParameter(\n      gl.MAX_VERTEX_UNIFORM_VECTORS\n    );\n    WebGLStat.MAX_FRAGMENT_UNIFORMS = gl.getParameter(\n      gl.MAX_FRAGMENT_UNIFORM_VECTORS\n    );\n    WebGLStat.MAX_VERTEX_ATTRIBUTES = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n    WebGLStat.MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    // Run texture float support checks\n    floatTextureSupport(gl);\n\n    // Make WebGL 2 assumptions and checks\n    if (gl instanceof WebGL2RenderingContext) {\n      WebGLStat.VAO = true;\n      WebGLStat.MRT = true;\n      WebGLStat.HARDWARE_INSTANCING = true;\n      WebGLStat.SHADERS_3_0 = true;\n      WebGLStat.HARDWARE_INSTANCING = true;\n      WebGLStat.DEPTH_TEXTURE = true;\n\n      WebGLStat.MAX_COLOR_ATTACHMENTS = gl.getParameter(\n        gl.MAX_COLOR_ATTACHMENTS\n      );\n    }\n\n    // Do WebGL1 specific checks\n    else {\n      WebGLStat.VAO = Boolean(gl.getExtension(\"OES_vertex_array_object\"));\n      WebGLStat.HARDWARE_INSTANCING = Boolean(\n        gl.getExtension(\"ANGLE_instanced_arrays\")\n      );\n      const MRT_EXT = gl.getExtension(\"WEBGL_draw_buffers\");\n      WebGLStat.MRT_EXTENSION = Boolean(MRT_EXT);\n      WebGLStat.MRT = Boolean(MRT_EXT);\n      WebGLStat.DEPTH_TEXTURE = Boolean(gl.getExtension(\"WEBGL_depth_texture\"));\n\n      if (MRT_EXT) {\n        WebGLStat.MAX_COLOR_ATTACHMENTS = gl.getParameter(\n          MRT_EXT.MAX_COLOR_ATTACHMENTS_WEBGL\n        );\n      }\n    }\n  }\n\n  // Make this globally available because it's super useful\n  (window as any).WebGLStat = WebGLStat;\n}\n\ninitStats();\n","import { Omit } from \"../types\";\nimport { uid } from \"../util/uid\";\nimport { GLProxy } from \"./gl-proxy\";\nimport { GLSettings } from \"./gl-settings\";\n\n/**\n * This is the options to apply to a texture\n */\nexport type TextureOptions = Omit<\n  Partial<Texture>,\n  \"destroy\" | \"update\" | \"updateRegions\"\n>;\n\n/**\n * This represents a texture that is loaded into the GPU.\n */\nexport class Texture {\n  /**\n   * Empty texture object to help resolve ambiguous texture values.\n   */\n  static get emptyTexture() {\n    return emptyTexture;\n  }\n\n  /** Unique identifier of the texture to aid in debugging and referencing */\n  get uid() {\n    return this._uid;\n  }\n  private _uid: number = uid();\n\n  /**\n   * Indicates this Texture has been disposed, meaning it is useless and invalid\n   * to use within the application.\n   */\n  public get destroyed(): boolean {\n    return this._destroyed;\n  }\n  private _destroyed: boolean = false;\n\n  /**\n   * Anisotropic filtering level. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n   * https://blog.tojicode.com/2012/03/anisotropic-filtering-in-webgl.html\n   */\n  get anisotropy() {\n    return this._anisotropy;\n  }\n  set anisotropy(val: Texture[\"_anisotropy\"]) {\n    this.needsSettingsUpdate = true;\n    this._anisotropy = val;\n  }\n  private _anisotropy: number;\n\n  /**\n   * The data to apply to the GPU for the image. If no data is to be uploaded to\n   * the texture, use width and height object. You would do this for render\n   * target textures such as depth textures or color buffer textures where the\n   * GPU writes the initial data into the texture. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n   */\n  get data() {\n    return this._data;\n  }\n  set data(val: Texture[\"_data\"]) {\n    this.needsDataUpload = true;\n    this._data = val;\n  }\n  private _data?:\n    | TexImageSource\n    | {\n        width: number;\n        height: number;\n        buffer: ArrayBufferView | null;\n      };\n\n  /**\n   * Indicates the data gets flipped vertically when uploaded to the GPU.\n   */\n  get flipY() {\n    return this._flipY;\n  }\n  set flipY(val: boolean) {\n    this.needsDataUpload = true;\n    this._flipY = val;\n  }\n  private _flipY: boolean = false;\n\n  /**\n   * Source format of the input data. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n   */\n  get format() {\n    return this._format;\n  }\n  set format(val: Texture[\"_format\"]) {\n    this.needsDataUpload = true;\n    this._format = val;\n  }\n  private _format: GLSettings.Texture.TexelDataType =\n    GLSettings.Texture.TexelDataType.RGBA;\n\n  /**\n   * Auto generates mipmaps. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/generateMipmap\n   */\n  get generateMipMaps() {\n    return this._generateMipmaps;\n  }\n  set generateMipMaps(val: Texture[\"_generateMipmaps\"]) {\n    this.needsSettingsUpdate = true;\n    this._generateMipmaps = val;\n  }\n  private _generateMipmaps: boolean = false;\n\n  /**\n   * This stores any gl state associated with this object. Modifying this object will cause the system to get out\n   * of sync with the GPU; however, the values inside this object can be read and used for custom WebGL calls as needed.\n   */\n  gl?: {\n    /** The identifier used by gl to target this texture. */\n    textureId: WebGLTexture | null;\n    /** The texture unit this texture is assocviated with. This is -1 if no unit is currently associated */\n    textureUnit: number;\n    /** This is the proxy communicator with the context that generates and destroys Textures */\n    proxy: GLProxy;\n  };\n\n  /**\n   * Source format of the input data. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n   */\n  get internalFormat() {\n    return this._internalFormat;\n  }\n  set internalFormat(val: Texture[\"_internalFormat\"]) {\n    this.needsDataUpload = true;\n    this._internalFormat = val;\n  }\n  private _internalFormat: GLSettings.Texture.TexelDataType =\n    GLSettings.Texture.TexelDataType.RGBA;\n\n  /**\n   * Filter used when sampling has to magnify the image see:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n   */\n  get magFilter() {\n    return this._magFilter;\n  }\n  set magFilter(val: Texture[\"_magFilter\"]) {\n    this.needsSettingsUpdate = true;\n    this._magFilter = val;\n  }\n  private _magFilter: GLSettings.Texture.TextureMagFilter =\n    GLSettings.Texture.TextureMagFilter.Linear;\n\n  /**\n   * Filter used when sampling has to shrink the image. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n   */\n  get minFilter() {\n    return this._minFilter;\n  }\n  set minFilter(val: Texture[\"_minFilter\"]) {\n    this.needsSettingsUpdate = true;\n    this._minFilter = val;\n  }\n  private _minFilter: GLSettings.Texture.TextureMinFilter =\n    GLSettings.Texture.TextureMinFilter.LinearMipMapLinear;\n\n  /** Flag indicates if the texture object needs to have it's data modified */\n  needsDataUpload: boolean = false;\n  /** Flag indicates if the texture object has sub texture updates needed to be applied to it */\n  needsPartialDataUpload: boolean = false;\n  /** Flag indicates if the texture object needs it's settings modified */\n  needsSettingsUpdate: boolean = false;\n\n  /**\n   * Sets the readPixels data alignment. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei\n   * https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glPixelStorei.xml\n   */\n  get packAlignment() {\n    return this._packAlignment;\n  }\n  set packAlignment(val: Texture[\"_packAlignment\"]) {\n    this.needsSettingsUpdate = true;\n    this._packAlignment = val;\n  }\n  private _packAlignment: GLSettings.Texture.PackAlignment =\n    GLSettings.Texture.PackAlignment.FOUR;\n\n  /**\n   * Tells the input packing to premultiply the alpha values with the other channels as the texture is generated. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei\n   */\n  get premultiplyAlpha() {\n    return this._premultiplyAlpha;\n  }\n  set premultiplyAlpha(val: Texture[\"_premultiplyAlpha\"]) {\n    this.needsSettingsUpdate = true;\n    this._premultiplyAlpha = val;\n  }\n  private _premultiplyAlpha: boolean = false;\n\n  /**\n   * The source pixel data type.\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n   */\n  get type() {\n    return this._type;\n  }\n  set type(val: Texture[\"_type\"]) {\n    this.needsDataUpload = true;\n    this._type = val;\n  }\n  private _type = GLSettings.Texture.SourcePixelFormat.UnsignedByte;\n\n  /**\n   * Sets the data alignment for packing the pixels. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei\n   * https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glPixelStorei.xml\n   */\n  get unpackAlignment() {\n    return this._unpackAlignment;\n  }\n  set unpackAlignment(val: Texture[\"_unpackAlignment\"]) {\n    this.needsSettingsUpdate = true;\n    this._unpackAlignment = val;\n  }\n  private _unpackAlignment: GLSettings.Texture.UnpackAlignment =\n    GLSettings.Texture.UnpackAlignment.FOUR;\n\n  /**\n   * These are the regions that have been requested to be applied to the Texture along\n   * with the data that should be buffered into that region.\n   */\n  get updateRegions() {\n    return this._updateRegions;\n  }\n  private _updateRegions: [\n    Texture[\"data\"],\n    { x: number; y: number; width: number; height: number }\n  ][] = [];\n\n  /**\n   * Specifies sample wrapping for when samples fall outside the 0 - 1 range See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n   */\n  get wrapHorizontal() {\n    return this._wrapHorizontal;\n  }\n  set wrapHorizontal(val: Texture[\"_wrapHorizontal\"]) {\n    this.needsSettingsUpdate = true;\n    this._wrapHorizontal = val;\n  }\n  private _wrapHorizontal: GLSettings.Texture.Wrapping =\n    GLSettings.Texture.Wrapping.CLAMP_TO_EDGE;\n\n  /**\n   * Specifies sample wrapping for when samples fall outside the 0 - 1 range. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n   */\n  get wrapVertical() {\n    return this._wrapVertical;\n  }\n  set wrapVertical(val: Texture[\"_wrapVertical\"]) {\n    this.needsSettingsUpdate = true;\n    this._wrapVertical = val;\n  }\n  private _wrapVertical: GLSettings.Texture.Wrapping =\n    GLSettings.Texture.Wrapping.CLAMP_TO_EDGE;\n\n  /**\n   * This checks if any formatting of this texture makes it a half float texture\n   * or not.\n   */\n  get isHalfFloatTexture() {\n    switch (this._internalFormat) {\n      case GLSettings.Texture.TexelDataType.R16F:\n      case GLSettings.Texture.TexelDataType.RG16F:\n      case GLSettings.Texture.TexelDataType.RGB16F:\n        return true;\n    }\n\n    switch (this._type) {\n      case GLSettings.Texture.SourcePixelFormat.HalfFloat:\n        return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * This checks if any formatting of this texture makes it a float texture\n   * or not.\n   */\n  get isFloatTexture() {\n    switch (this._internalFormat) {\n      case GLSettings.Texture.TexelDataType.R11F_G11F_B10F:\n      case GLSettings.Texture.TexelDataType.R16F:\n      case GLSettings.Texture.TexelDataType.RG16F:\n      case GLSettings.Texture.TexelDataType.R32F:\n      case GLSettings.Texture.TexelDataType.RG32F:\n      case GLSettings.Texture.TexelDataType.RGB16F:\n      case GLSettings.Texture.TexelDataType.RGB32F:\n        return true;\n    }\n\n    switch (this._type) {\n      case GLSettings.Texture.SourcePixelFormat.Float:\n      case GLSettings.Texture.SourcePixelFormat.HalfFloat:\n        return true;\n    }\n\n    return false;\n  }\n\n  constructor(options: TextureOptions) {\n    this.anisotropy = options.anisotropy || this.anisotropy;\n    this.data = options.data || this.data;\n    this.flipY = options.flipY || this.flipY;\n    this.format = options.format || this.format;\n    this.internalFormat = options.internalFormat || this.format;\n    this.generateMipMaps = options.generateMipMaps || this.generateMipMaps;\n    this.magFilter = options.magFilter || this.magFilter;\n    this.minFilter = options.minFilter || this.minFilter;\n    this.packAlignment = options.packAlignment || this.packAlignment;\n    this.premultiplyAlpha = options.premultiplyAlpha || this.premultiplyAlpha;\n    this.type = options.type || this.type;\n    this.unpackAlignment = options.unpackAlignment || this.unpackAlignment;\n    this.wrapHorizontal = options.wrapHorizontal || this.wrapHorizontal;\n    this.wrapVertical = options.wrapVertical || this.wrapVertical;\n  }\n\n  /**\n   * Frees resources associated with this texture.\n   */\n  destroy() {\n    // Clear the gl context\n    if (this.gl) {\n      this.gl.proxy.disposeTexture(this);\n    }\n\n    // Flag this texture as no longer useable.\n    this._destroyed = true;\n    // Ensure the large data object for the texture is cleared\n    delete this._data;\n  }\n\n  /**\n   * Clears all update flags and clears out requested updates to the texture object.\n   *\n   * NOTE: Calling this does not perform any actions, but instead prevents actions from\n   * being taken again. The system uses this to clear up any changes requested for the texture\n   * after the texture has been updated with the GPU.\n   */\n  resolve() {\n    this.needsDataUpload = false;\n    this.needsPartialDataUpload = false;\n    this.needsSettingsUpdate = false;\n    this._updateRegions = [];\n  }\n\n  /**\n   * This updates a portion of the texture object.\n   */\n  update(\n    data: Texture[\"data\"],\n    region: { x: number; y: number; width: number; height: number }\n  ) {\n    this.needsPartialDataUpload = true;\n    this._updateRegions.push([data, region]);\n  }\n}\n\n/** Empty texture that will default to the zero texture and unit */\nconst emptyTexture = new Texture({\n  data: {\n    width: 2,\n    height: 2,\n    buffer: new Uint8Array(16)\n  }\n});\n","import { Transform } from \"../3d/scene-graph/transform\";\nimport {\n  compare4x4,\n  copy4x4,\n  identity4,\n  Mat4x4,\n  multiply4x4,\n  orthographic4x4,\n  perspective4x4\n} from \"../math/matrix\";\nimport { compare3, Vec3 } from \"../math/vector\";\nimport { shallowCompare } from \"./shallow-compare\";\nimport { uid } from \"./uid\";\n\nexport enum CameraProjectionType {\n  PERSPECTIVE,\n  ORTHOGRAPHIC\n}\n\n/**\n * Options for generating a camera that has orthographic properties.\n */\nexport interface ICameraOrthographicOptions {\n  /** Forced type requirement, indicates orthographic projection */\n  type: CameraProjectionType.ORTHOGRAPHIC;\n\n  /** Left border of the view range */\n  left: number;\n  /** Right border of the view range */\n  right: number;\n  /** Top border of the view range */\n  top: number;\n  /** Bottom border of the view range */\n  bottom: number;\n  /** Near border of the view range */\n  near: number;\n  /** Far border of the view range */\n  far: number;\n}\n\n/**\n * Options for generating a camera that has perspective properties.\n */\nexport interface ICameraPerspectiveOptions {\n  /** Forced type requirement, indicates perspective projection */\n  type: CameraProjectionType.PERSPECTIVE;\n\n  /** Field of view in radians */\n  fov: number;\n  /** Width of the render space */\n  width: number;\n  /** Height of the render space */\n  height: number;\n  /** The near clipping plane */\n  near: number;\n  /** The far clipping plane */\n  far: number;\n}\n\n/**\n * Base options for camera construction\n */\nexport type ICameraOptions = (\n  | ICameraOrthographicOptions\n  | ICameraPerspectiveOptions\n) & {\n  onViewChange?(camera: Camera, viewId: string): void;\n};\n\nexport interface IOrthoGraphicCamera extends Camera {\n  projectionOptions: ICameraOrthographicOptions;\n}\n\nexport interface IPerspectiveCamera extends Camera {\n  projectionOptions: ICameraPerspectiveOptions;\n}\n\nexport function isOrthographic(camera: Camera): camera is IOrthoGraphicCamera {\n  return (\n    camera.projectionOptions.type === CameraProjectionType.ORTHOGRAPHIC &&\n    \"left\" in camera.projectionOptions\n  );\n}\n\nexport function isPerspective(camera: Camera): camera is IPerspectiveCamera {\n  return (\n    camera.projectionOptions.type === CameraProjectionType.PERSPECTIVE &&\n    \"fov\" in camera.projectionOptions\n  );\n}\n\n/**\n * This class is present to simplify the concepts of Matrix math down to simpler camera concepts. A camera is two things:\n * - An object that can be placed within the world and be a part of a scene graph\n * - A mathematical structure that defines the viewing\n */\nexport class Camera {\n  /** Provide an identifier for the camera to follow the pattern of most everything in this framework. */\n  get id() {\n    return this._id;\n  }\n  private _id: number = uid();\n\n  /** This is the calculated timestamp at which this camera is 'at rest' and will no longer trigger updates */\n  animationEndTime: number = 0;\n  /** Indicates the view's associated with this camera should be redrawn */\n  needsViewDrawn: boolean = true;\n  /** Flag indicating the camera needs to broadcast changes applied to it */\n  needsBroadcast: boolean = false;\n  /** The id of the view to be broadcasted for the sake of a change */\n  viewChangeViewId: string = \"\";\n  /** This is the transform that places the camera within world space */\n  transform: Transform = new Transform();\n\n  /** Handler  */\n  onChange?(camera: Camera, viewId: string): void;\n\n  /**\n   * Performs the broadcast of changes for the camera if the camera needed a broadcast.\n   */\n  broadcast(viewId: string) {\n    // Emit changes for the view indicated that this camera affects\n    if (this.onChange) this.onChange(this, viewId);\n  }\n\n  /**\n   * Quick generation of a camera with properties. None make any sense and should be set appropriately.\n   * ie - View2D handles setting these values correctly for you.\n   */\n  static makeOrthographic(options?: Partial<ICameraOrthographicOptions>) {\n    return new Camera(\n      Object.assign(\n        {\n          left: -100,\n          right: 100,\n          top: -100,\n          bottom: 100,\n          near: -100,\n          far: 100000,\n          type: CameraProjectionType.ORTHOGRAPHIC\n        },\n        options\n      )\n    );\n  }\n\n  /**\n   * Quick generation of a camera with perspective properties.\n   */\n  static makePerspective(options?: Partial<ICameraPerspectiveOptions>) {\n    return new Camera(\n      Object.assign(\n        {\n          type: CameraProjectionType.PERSPECTIVE,\n          far: 10000,\n          near: 1,\n          fov: (90 * Math.PI) / 180,\n          height: 1000,\n          width: 1000\n        },\n        options\n      )\n    );\n  }\n\n  /** The expected projection style of the Camera. */\n  get projectionType() {\n    return this._projectionOptions.type;\n  }\n\n  /** The computed projection of the camera. */\n  get projection() {\n    this.update(true);\n    return this._projection;\n  }\n  private _projection: Mat4x4 = identity4();\n\n  /** The computed view transform of the camera. */\n  get view() {\n    return this.transform.viewMatrix;\n  }\n\n  /** Flag indicating the transforms for this camera need updating. */\n  get needsUpdate() {\n    return this._needsUpdate;\n  }\n  private _needsUpdate = true;\n\n  /** This is the position of the camera within the world. */\n  get position() {\n    return this.transform.position;\n  }\n  set position(val: Vec3) {\n    this._needsUpdate =\n      this._needsUpdate || !compare3(val, this.transform.position);\n    this.transform.position = val;\n  }\n\n  /**\n   * The camera must always look at a position within the world. This in conjunction with 'roll' defines the orientation\n   * of the camera viewing the world.\n   */\n  lookAt(position: Vec3, up?: Vec3) {\n    const old: Mat4x4 = copy4x4(this.transform.matrix);\n    this.transform.lookAtLocal(position, up || [0, 1, 0]);\n    this._needsUpdate =\n      this._needsUpdate || !compare4x4(old, this.transform.matrix);\n  }\n\n  /**\n   * This is a scale distortion the camera views the world with. A scale of 2 along an axis, means the camera will view\n   * 2x the amount of the world along that axis (thus having a visual compression if the screen dimensions do\n   * not change).\n   *\n   * This also has the added benefit of quickly and easily swapping axis directions by simply making the scale -1 for\n   * any of the axis.\n   */\n  get scale() {\n    return this.transform.scale;\n  }\n  set scale(val: Vec3) {\n    this._needsUpdate =\n      this._needsUpdate || !compare3(val, this.transform.scale);\n    this.transform.scale = val;\n  }\n\n  /**\n   * Options used for making the projection of the camera. Set new options to update the projection.\n   * Getting the options returns a copy of the object and is not the internal object itself.\n   */\n  get projectionOptions() {\n    return this._projectionOptions;\n  }\n  set projectionOptions(val: ICameraOptions) {\n    this._needsUpdate =\n      this._needsUpdate || !shallowCompare(val, this._projectionOptions);\n    this._projectionOptions = val;\n  }\n  private _projectionOptions: ICameraOptions;\n\n  /**\n   * Provides the combined view projection matrices. Applies view first then the projection multiply(P, V).\n   */\n  get viewProjection() {\n    this.update(true);\n    return this._viewProjection;\n  }\n  private _viewProjection: Mat4x4 = identity4();\n\n  constructor(options: ICameraOptions) {\n    this._projectionOptions = options;\n    this._needsUpdate = true;\n    this.onChange = options.onViewChange;\n    this.update();\n  }\n\n  /**\n   * Sets projection options with the camera as an orthographic projection.\n   */\n  setOrthographic(options: Partial<ICameraOrthographicOptions>) {\n    this._projectionOptions = Object.assign(\n      {\n        left: -100,\n        right: 100,\n        top: -100,\n        bottom: 100,\n        near: -100,\n        far: 100000,\n        type: CameraProjectionType.ORTHOGRAPHIC\n      },\n      options\n    );\n  }\n\n  /**\n   * Sets projection options with the camera as a perspective projection.\n   */\n  setPerspective(options: Partial<ICameraPerspectiveOptions>) {\n    this._projectionOptions = Object.assign(\n      {\n        type: CameraProjectionType.PERSPECTIVE,\n        far: 10000,\n        near: 1,\n        fov: (90 * Math.PI) / 180,\n        height: 1000,\n        width: 1000\n      },\n      options\n    );\n  }\n\n  /**\n   * This marks the camera's changes as resolved and responded to.\n   */\n  resolve() {\n    this._needsUpdate = false;\n    this.needsViewDrawn = false;\n    this.needsBroadcast = false;\n  }\n\n  /**\n   * Updates the transform matrices associated with this camera.\n   */\n  update(force?: boolean) {\n    if (this._needsUpdate || force) {\n      this.updateProjection();\n      this._needsUpdate = false;\n      this.needsViewDrawn = true;\n    }\n  }\n\n  /**\n   * Takes the current projection options and produces the projection matrix needed to project elements to the screen.\n   */\n  updateProjection() {\n    if (isOrthographic(this)) {\n      orthographic4x4(\n        this.projectionOptions.left,\n        this.projectionOptions.right,\n        this.projectionOptions.bottom,\n        this.projectionOptions.top,\n        this.projectionOptions.near,\n        this.projectionOptions.far,\n        this._projection\n      );\n    } else if (isPerspective(this)) {\n      perspective4x4(\n        this.projectionOptions.fov,\n        this.projectionOptions.width,\n        this.projectionOptions.height,\n        this.projectionOptions.near,\n        this.projectionOptions.far,\n        this._projection\n      );\n    }\n\n    multiply4x4(\n      this._projection,\n      this.transform.viewMatrix,\n      this._viewProjection\n    );\n  }\n}\n","export interface IdentifyByKeyOptions {\n  /** The identifier of the object */\n  key: string;\n}\n\n/**\n * This is an object that specifically is generated with a 'key' option that can never\n * be modified on the object and is identified henceforth with the key applied as the\n * 'id' of the object.\n */\nexport class IdentifyByKey {\n  /** Internal key held by the object */\n  private _key: string;\n\n  /** READONLY id of the object. */\n  get id() {\n    return this._key;\n  }\n\n  /** READONLY key of the object */\n  get key() {\n    return this._key;\n  }\n\n  constructor(options: IdentifyByKeyOptions) {\n    this._key = options.key;\n  }\n}\n\nexport class IdentifiableData<T> extends IdentifyByKey {\n  data: T;\n\n  constructor(options: IdentifyByKeyOptions & { data: T }) {\n    super(options);\n    this.data = options.data;\n  }\n}\n","import { Instance } from \"../instance-provider/instance\";\nimport {\n  ILayerConstructable,\n  ILayerProps,\n  LayerInitializer\n} from \"../surface/layer\";\n\n/**\n * Used for reactive layer generation and updates.\n */\nexport function createLayer<T extends Instance, U extends ILayerProps<T>>(\n  layerClass: ILayerConstructable<T> & { defaultProps: U },\n  props: Omit<U, \"key\" | \"data\"> & Partial<Pick<U, \"key\" | \"data\">>\n): LayerInitializer {\n  const keyedProps = Object.assign(props, {\n    key: props.key || layerClass.defaultProps.key,\n    data: props.data || layerClass.defaultProps.data\n  });\n\n  return {\n    get key() {\n      return props.key || \"\";\n    },\n    init: [layerClass, keyedProps]\n  };\n}\n","import { Vec2 } from \"../math/vector\";\n\nexport enum AnchorType {\n  BottomLeft,\n  BottomMiddle,\n  BottomRight,\n  Custom,\n  Middle,\n  MiddleLeft,\n  MiddleRight,\n  TopLeft,\n  TopMiddle,\n  TopRight\n}\n\nexport type Anchor = {\n  /** When the anchor gets calculated on the image, this allows the anchor to go beyond the borders of the image by this amount */\n  padding: number;\n  /**\n   * A padding must contain dimensions for all axis involved. Padding as a scalar is too ambiguous. This holds the calculated\n   * direction the padding applies. The padding value you would provide is just a magnitude that is used to inevitably calculate\n   * this value.\n   */\n  paddingDirection?: Vec2;\n  /** This is the location of the anchor. If a custom anchor is specified, then the x and y are not automatically populated */\n  type: AnchorType;\n  /** This is populated with the anchor's location relative to the image's surface */\n  x?: number;\n  /** This is populated with the anchor's location relative to the image's surface */\n  y?: number;\n};\n\nexport enum ScaleMode {\n  /** The size of the image will be tied to world space */\n  ALWAYS = 1,\n  /** The image will scale to it's font size then stop growing */\n  BOUND_MAX = 2,\n  /** The image will alwyas retain it's font size on screen */\n  NEVER = 3\n}\n","import { uid } from \"../util/uid\";\nimport { Instance } from \"./instance\";\n\nexport class ObservableMonitoring {\n  /**\n   * Flag to help gathering Ids not gather Ids that arise from setting values\n   */\n  static setCycle: boolean = false;\n  /** When true, observables will gather their used IDs into a list */\n  static gatherIds: boolean = false;\n  /** The IDs gathered while gatherIds flag is true */\n  static observableIds: number[] = [];\n  /**\n   * A tracker to help keep similar names utilizing the same UID values to\n   * improve compatibility in inheritance and across layers\n   */\n  static observableNamesToUID = new Map<string, number>();\n\n  /**\n   * This activates all observables to gather their UIDs when they are retrieved\n   * via their getter. All of the ID's gathered can be accessed via\n   * getObservableMonitorIds. It is REQUIRED that this is disabled again to\n   * prevent a MASSIVE memory leak.\n   */\n  static setObservableMonitor(enabled: boolean) {\n    ObservableMonitoring.gatherIds = enabled;\n    ObservableMonitoring.observableIds = [];\n  }\n\n  /**\n   * This retrieves the observables monitored IDs that were gathered when\n   * setObservableMonitor was enabled.\n   */\n  static getObservableMonitorIds(clear?: boolean) {\n    const values = ObservableMonitoring.observableIds.slice(0);\n    if (clear) ObservableMonitoring.observableIds = [];\n\n    return values;\n  }\n}\n\n/**\n * Shorthand for the Observable Monitor as this has a hard time getting\n * compressed properly in minification.\n */\nconst m = ObservableMonitoring;\n\n/**\n * This is a custom decorator intended for single properties on Instances only!\n * It will facilitate automatic updates and stream the updates through an\n * InstanceProvider to properly update the Instances values in the appropriate\n * and corresponding buffers that will get committed to the GPU.\n */\nexport function observable<T extends Instance>(target: T, key: string) {\n  // Here we store the name of the observable to a UID. This mapping allows us\n  // to have a UID per NAME of an observable. A UID for a name can produce MUCH\n  // faster lookups than the name itself. Matching against the name allows us to\n  // have instances with their own property sets but have matching name mappings\n  // to improve compatibility of Instances with varying Layers.\n  let propertyUID: number =\n    ObservableMonitoring.observableNamesToUID.get(key) || 0;\n\n  if (propertyUID === 0) {\n    propertyUID = uid();\n    ObservableMonitoring.observableNamesToUID.set(key, propertyUID);\n  }\n\n  /**\n   * New property getter to get the property's alternative storage since we\n   * overrode the initial storage with a custom getter and setter.\n   */\n  function getter(this: T) {\n    if (m.gatherIds) {\n      if (!m.setCycle) m.observableIds.push(propertyUID);\n    }\n    return this.observableStorage[propertyUID];\n  }\n\n  /**\n   * New property setter to replace the property marked as observable. This\n   * allows us to broadcast a change to our current observer.\n   */\n  function setter(this: T, newVal: any) {\n    if (m.gatherIds) m.setCycle = true;\n    // Update the privatized value\n    this.observableStorage[propertyUID] = newVal;\n    // Broadcast change\n    this.changes[propertyUID] = propertyUID;\n    if (this.observer) this.observer.instanceUpdated(this);\n    if (m.gatherIds) m.setCycle = false;\n  }\n\n  /**\n   * Make sure the desired property is declared on the class with our custom\n   * getter and setter.\n   */\n  Object.defineProperty(target, key, {\n    configurable: true,\n    enumerable: true,\n    get: getter,\n    set: setter\n  });\n}\n","import { WebGLRenderer } from \"../gl\";\nimport { Instance } from \"../instance-provider/instance\";\nimport { ILayerProps, Layer } from \"../surface/layer\";\nimport { BaseIOExpansion } from \"../surface/layer-processing/base-io-expansion\";\nimport {\n  InstanceIOValue,\n  IResourceContext,\n  IResourceInstanceAttribute,\n  IResourceType\n} from \"../types\";\nimport { ResourceRouter } from \"./resource-router\";\n\n/**\n * The Base Options for initializing a resource.\n */\nexport type BaseResourceOptions = IResourceType & { key: string };\n\n/**\n * The base needs for making a resource request.\n */\nexport type BaseResourceRequest = IResourceType & { key: string };\n\n/**\n * This represents a manager that is capable of handling requests for resources\n * that come from Layers that needs the resaource for updating it's Shader IO.\n */\nexport abstract class BaseResourceManager<\n  T extends IResourceType,\n  S extends BaseResourceRequest\n> {\n  /**\n   * Every resource manager will have access to the parent ResourceManager\n   * system that pipes resources and requests to the proper location.\n   */\n  router: ResourceRouter;\n  /**\n   * Every resource manager will receive the utilized renderer so the manager\n   * can perform basic GL tasks if needed\n   */\n  webGLRenderer?: WebGLRenderer;\n\n  /**\n   * This is called by the system for the manager to dequeue it's requests in an\n   * asynchronous manner, thus allowing the system to have it's resources\n   * changed and dequeued without hanging up the system.\n   *\n   * The manager will return true when resources have been dequeued and will\n   * return false when nothing has been dequeued.\n   *\n   * If true was returned, this will trigger an additional draw operation to\n   * immediately have the dequeue triggers take place and render to the screen.\n   */\n  abstract async dequeueRequests(): Promise<boolean>;\n\n  /**\n   * This expects a resource manager to free all of it's resources it is hanging\n   * onto.\n   */\n  abstract destroy(): void;\n\n  /**\n   * Indicates a resource needs to be freed or destroyed.\n   */\n  abstract destroyResource(resource: BaseResourceOptions): void;\n\n  /**\n   * Allows a resource manager to provide it's own IO Expansion to handle\n   * special attributes the layer may have for handling.\n   */\n  getIOExpansion(): BaseIOExpansion[] {\n    return [];\n  }\n\n  /**\n   * The method to access a resource initialized by this resource manager.\n   */\n  abstract getResource(resourceKey: string): T | null;\n\n  /**\n   * This is called to initialize a resource that the system has determined\n   * needs to be constructed.\n   */\n  abstract async initResource(resource: BaseResourceOptions): Promise<void>;\n\n  /**\n   * This will trigger a request of a resource to be generated. It will\n   * immediately return either a value refelecting the resource is in a Pending\n   * state (such as [0, 0, 0, 0]) or it will return metrics indicative of\n   * expected resource's metrics, but will always be in InstanceIOValue format.\n   */\n  abstract request<U extends Instance, V extends ILayerProps<U>>(\n    layer: Layer<U, V>,\n    instance: Instance,\n    resourceRequest: S,\n    context?: IResourceContext\n  ): InstanceIOValue;\n\n  /** This will be called when the system detects the renderer has been resized\n   * */\n  resize() {\n    // Implemented by subclasses\n  }\n\n  /**\n   * This applies an attribute as the current context\n   */\n  setAttributeContext(_attribute: IResourceInstanceAttribute<Instance>) {\n    // Implemented by sub classes if needed\n  }\n\n  /**\n   * This indicates the resource should be updated.\n   */\n  abstract updateResource(resource: BaseResourceOptions): void;\n}\n\n/**\n * This is a resource manager that implements all of the functionality but\n * returns invalid empty results. This allows the system to have requests for a\n * manager but prevent returning null or undefined states.\n */\nexport class InvalidResourceManager extends BaseResourceManager<\n  IResourceType,\n  BaseResourceRequest\n> {\n  resources = new Map<string, BaseResourceOptions>();\n\n  async dequeueRequests() {\n    return false;\n  }\n\n  destroy() {\n    return;\n  }\n\n  destroyResource(resourceKey: BaseResourceOptions) {\n    this.resources.delete(resourceKey.key);\n  }\n\n  getResource(resourceKey: string) {\n    return this.resources.get(resourceKey) || { key: \"\", type: -1 };\n  }\n\n  async initResource(resource: BaseResourceOptions) {\n    this.resources.set(resource.key, resource);\n  }\n\n  request<U extends Instance, V extends ILayerProps<U>>(\n    _layer: Layer<U, V>,\n    _instance: Instance,\n    _resource: IResourceType\n  ): InstanceIOValue {\n    return [0, 0, 0, 0];\n  }\n\n  updateResource(_resource: BaseResourceOptions) {\n    // NO-OP\n  }\n}\n\nexport const INVALID_RESOURCE_MANAGER = new InvalidResourceManager();\n","// Shader mdoules have no exports and should simply be imported to execute\nimport \"./shader-modules\";\n\nexport * from \"./types\";\nexport * from \"./view\";\nexport * from \"./layers\";\n","import { colorBufferRequest, createColorBuffer } from \"./color-buffer\";\nimport { createFont, fontRequest } from \"./text\";\nimport {\n  atlasRequest,\n  createAtlas,\n  createTexture,\n  textureRequest\n} from \"./texture\";\n\nexport * from \"./base-resource-manager\";\nexport * from \"./resource-router\";\nexport * from \"./text\";\nexport * from \"./texture\";\n\nexport const RESOURCE = {\n  createFont,\n  createAtlas,\n  createTexture,\n  createColorBuffer\n};\n\nexport const REQUEST = {\n  textureRequest,\n  atlasRequest,\n  fontRequest,\n  colorBufferRequest\n};\n","import { Texture } from \"../../gl/texture\";\nimport { Bounds } from \"../../math/primitives/bounds\";\nimport { Vec2 } from \"../../math/vector\";\nimport { InstanceIOValue, Omit } from \"../../types\";\nimport { uid } from \"../../util\";\nimport { VideoTextureMonitor } from \"./video-texture-monitor\";\n\n/**\n * Converts a SubTexture reference to a valid Instance IO value where:\n * [top left x, top left y, bottom right x, bottom right y]\n *\n * This also handles falsey texture values where invalid is a zero vector\n */\nexport function subTextureIOValue(\n  texture?: SubTexture | null\n): InstanceIOValue {\n  // If the texture is not defined we just output an empty reference\n  if (!texture) {\n    return [0, 0, 0, 0];\n  }\n\n  // Otherwise, we return the atlas information of the texture\n  return [\n    texture.atlasTL[0],\n    texture.atlasTL[1],\n    texture.atlasBR[0],\n    texture.atlasBR[1]\n  ];\n}\n\n/**\n * Defines a texture that is located on an atlas\n */\nexport class SubTexture {\n  /** A unique identifier for the sub texture to aid in debugging issues */\n  get uid() {\n    return this._uid;\n  }\n  private _uid: number = uid();\n  /** Stores the aspect ratio of the image for quick reference */\n  aspectRatio: number = 1.0;\n  /** This is the top left UV coordinate of the sub texture on the atlas */\n  atlasTL: Vec2 = [0, 0];\n  /** This is the top right UV coordinate of the sub texture on the atlas */\n  atlasTR: Vec2 = [0, 0];\n  /** This is the bottom left UV coordinate of the sub texture on the atlas */\n  atlasBL: Vec2 = [0, 0];\n  /** This is the bottom right UV coordinate of the sub texture on the atlas */\n  atlasBR: Vec2 = [0, 0];\n  /** This is the normalized height of the sub texture on the atlas */\n  heightOnAtlas: number = 0;\n  /** This flag is set to false when the underlying texture is no longer valid */\n  isValid: boolean = false;\n  /** Width in pixels of the image on the atlas */\n  pixelWidth: number = 0;\n  /** Height in pixels of the image on the atlas */\n  pixelHeight: number = 0;\n  /** The region information of the subtexture on the atlas' texture. */\n  atlasRegion?: { x: number; y: number; width: number; height: number };\n  /** This is the source image/data that this sub texture applied to the atlas */\n  source?: TexImageSource;\n  /** This is the actual texture this resource is located within */\n  texture: Texture | null = null;\n  /**\n   * If this is a subtexture that references a video, this will be populated with it's monitor that ensures the portion\n   * of the texture is kept up to date with the latest from the video's playback.\n   */\n  video?: {\n    monitor: VideoTextureMonitor;\n  };\n  /** This is the normalized width of the sub texture on the atlas */\n  widthOnAtlas: number = 0;\n\n  constructor(options?: Omit<Partial<SubTexture>, \"update\">) {\n    Object.assign(this, options);\n  }\n\n  /**\n   * Generates a SubTexture object based on the texture and region provided.\n   */\n  static fromRegion(source: Texture, region: Bounds<any>) {\n    if (!source.data) return null;\n\n    const ux = region.x / source.data.width;\n    const uy = region.y / source.data.height;\n    const uw = region.width / source.data.width;\n    const uh = region.height / source.data.height;\n\n    const atlasDimensions: Bounds<never> = new Bounds({\n      bottom: uy + uh,\n      left: ux,\n      right: ux + uw,\n      top: uy\n    });\n\n    const bottom = atlasDimensions.bottom;\n    const top = atlasDimensions.y;\n    const left = atlasDimensions.x;\n    const right = atlasDimensions.x + atlasDimensions.width;\n\n    const sub = new SubTexture();\n    sub.atlasTL = [left, top];\n    sub.atlasBR = [right, bottom];\n    sub.atlasBL = [left, bottom];\n    sub.atlasTR = [right, top];\n\n    return sub;\n  }\n\n  /**\n   * Forces an update of this sub texture on the texture it is located.\n   *\n   * NOTE: Use this WISELY. This does NOT smartly determine if the update would do nothing. This WILL cause the source\n   * to be uploaded to the Atlas when this is called.\n   */\n  update() {\n    if (!this.texture || !this.source || !this.atlasRegion) return;\n    this.texture.update(this.source, this.atlasRegion);\n  }\n\n  toString(): string {\n    return JSON.stringify(\n      {\n        atlas: {\n          TL: this.atlasTL,\n          TR: this.atlasTR,\n          BL: this.atlasBL,\n          BR: this.atlasBR\n        },\n        width: this.pixelWidth,\n        height: this.pixelHeight\n      },\n      null,\n      2\n    );\n  }\n}\n","import { Camera2D, IView2DProps, View2D } from \"../2d\";\nimport { IRenderTextureResource } from \"../resources\";\nimport { createView } from \"../surface/view\";\nimport {\n  ILayerMaterialOptions,\n  IUniform,\n  ShaderInjectionTarget\n} from \"../types\";\nimport { createLayer } from \"../util/create-layer\";\nimport { PostProcessLayer } from \"./layer/post-process-layer\";\n\nexport interface IPostProcess {\n  /**\n   * This specifies the texture buffers the post processing shaders will\n   * utilize. The keys for this property will be the names of the textures\n   * available within your shaders.\n   *\n   * ie -\n   * buffers: { color: \"colorTextureKey\" }\n   *\n   * will make the uniform sampler \"color\" be available in your shader and will\n   * provide the resource with the key \"colorTextureKey\".\n   */\n  buffers: Record<string, IRenderTextureResource | undefined>;\n  /**\n   * Custom material options to apply to the layer to aid in controlling\n   * blending etc.\n   */\n  material?: ILayerMaterialOptions;\n  /** This is the shader program you will be using when you  */\n  shader: string;\n  /**\n   * Use this to specify some additional uniforms your shader may use.\n   * NOTE: Remember to use ShaderInjectionTarget Fragment only! You are not\n   * writing a vertex shader here!\n   */\n  uniforms?: IUniform[];\n  /**\n   * Use this to modify the View2D being used to produce this quad. You can use\n   * these options to redirect the output of this step to another resource if\n   * desired.\n   */\n  view?: Partial<IView2DProps>;\n  /**\n   * For debugging purposes only. Prints the shader generated to the console.\n   */\n  printShader?: boolean;\n}\n\n/**\n * This creates a scene, view, and layer configuration quickly. This will\n * perform the task of setting up a screen quad that will let you composite\n * several textures into a single output. This output can either be rendered to\n * the screen directly or target another texture to render to.\n */\nexport function postProcess(options: IPostProcess) {\n  if (options.uniforms) {\n    options.uniforms.forEach(uniform => {\n      uniform.shaderInjection = ShaderInjectionTarget.FRAGMENT;\n    });\n  }\n\n  return {\n    views: {\n      screen: createView(View2D, {\n        camera: new Camera2D(),\n        viewport: { left: 0, top: 0, width: \"100%\", height: \"100%\" },\n        ...options.view\n      })\n    },\n    layers: {\n      screen: createLayer(PostProcessLayer, {\n        printShader: options.printShader,\n        baseShaderModules: () => ({ fs: [], vs: [] }),\n        buffers: options.buffers,\n        fs: options.shader,\n        uniforms: options.uniforms,\n        materialOptions: options.material\n      })\n    }\n  };\n}\n","import { Mat3x3, Mat4x4, Vec2, Vec3, Vec4 } from \"../math\";\nimport { NOOP } from \"../types\";\nimport { Texture } from \"./texture\";\n\nexport enum MaterialUniformType {\n  /** A single float */\n  FLOAT,\n  /** A single vec2 */\n  VEC2,\n  /** A single vec3 */\n  VEC3,\n  /** A single vec4 */\n  VEC4,\n  /** An array of vec4s (uniform vec4 name[count] in the shader) */\n  VEC4_ARRAY,\n  /** An array of floats */\n  FLOAT_ARRAY,\n  /** A single 3x3 matrix of floats */\n  MATRIX3x3,\n  /** A single 4x4 matrix of floats */\n  MATRIX4x4,\n  /** The uniform refers to a texture that should be bound to an active texture unit */\n  TEXTURE\n}\n\n// Uniform type guards\n\nexport function isUniformVec2(\n  val: IMaterialUniform<MaterialUniformType>\n): val is IMaterialUniform<MaterialUniformType.VEC2> {\n  return val.type === MaterialUniformType.VEC2;\n}\n\nexport function isUniformVec3(\n  val: IMaterialUniform<MaterialUniformType>\n): val is IMaterialUniform<MaterialUniformType.VEC3> {\n  return val.type === MaterialUniformType.VEC3;\n}\n\nexport function isUniformVec4(\n  val: IMaterialUniform<MaterialUniformType>\n): val is IMaterialUniform<MaterialUniformType.VEC4> {\n  return val.type === MaterialUniformType.VEC4;\n}\n\nexport function isUniformVec4Array(\n  val: IMaterialUniform<MaterialUniformType>\n): val is IMaterialUniform<MaterialUniformType.VEC4_ARRAY> {\n  return val.type === MaterialUniformType.VEC4_ARRAY;\n}\n\nexport function isUniformMat3(\n  val: IMaterialUniform<MaterialUniformType>\n): val is IMaterialUniform<MaterialUniformType.MATRIX3x3> {\n  return val.type === MaterialUniformType.MATRIX3x3;\n}\n\nexport function isUniformMat4(\n  val: IMaterialUniform<MaterialUniformType>\n): val is IMaterialUniform<MaterialUniformType.MATRIX4x4> {\n  return val.type === MaterialUniformType.MATRIX4x4;\n}\n\nexport function isUniformTexture(\n  val: IMaterialUniform<MaterialUniformType>\n): val is IMaterialUniform<MaterialUniformType.TEXTURE> {\n  return val.type === MaterialUniformType.TEXTURE;\n}\n\nexport function isUniformFloat(\n  val: IMaterialUniform<MaterialUniformType>\n): val is IMaterialUniform<MaterialUniformType.FLOAT> {\n  return val.type === MaterialUniformType.FLOAT;\n}\n\n/**\n * Special enum analyzing material uniforms\n */\nexport type MaterialUniformValue<T> = T extends MaterialUniformType.FLOAT\n  ? number\n  : T extends MaterialUniformType.VEC2\n  ? Vec2\n  : T extends MaterialUniformType.VEC3\n  ? Vec3\n  : T extends MaterialUniformType.VEC4\n  ? Vec4\n  : T extends MaterialUniformType.VEC4_ARRAY\n  ? Vec4[]\n  : T extends MaterialUniformType.MATRIX3x3\n  ? Mat3x3\n  : T extends MaterialUniformType.MATRIX4x4\n  ? Mat4x4\n  : T extends MaterialUniformType.TEXTURE\n  ? Texture\n  : T extends MaterialUniformType.FLOAT_ARRAY\n  ? number[] | Float32Array\n  : number;\n\n/**\n * Defines a uniform applied to a material\n */\nexport interface IMaterialUniform<T extends MaterialUniformType> {\n  /** Indictaes which uniform to utilize */\n  type: T;\n  /** Indicates the value to upload  */\n  value: MaterialUniformValue<T>;\n\n  /**\n   * State stored in the uniform defining gl specific state.\n   * Modifying this outside of the framework is bound to break something.\n   */\n  gl?: Map<\n    WebGLProgram,\n    {\n      /**\n       * If this value is set to undefined, then no valid uniform was located\n       * to bind to. This is fine, we just need to appropriately react to this\n       * to prevent attempts to upload or analyze uneeded data.\n       */\n      location: WebGLUniformLocation | undefined;\n    }\n  >;\n}\n\n/** The GL Context which will be either WebGL1 or WebGL2 */\nexport type GLContext = WebGLRenderingContext | WebGL2RenderingContext;\n/**\n * There are now two types of Canvas Element that should be considered. So we harmonize those two into a single type\n * for whenever a canvas of any sort is needed.\n */\nexport type CanvasElement = HTMLCanvasElement | OffscreenCanvas;\n\n/**\n * There is no strong support for OffscreenCanvas in browsers yet, so we must warily utilize the feature and ensure we\n * don't have an undefined variable get used.\n */\nconst OffscreenCanvas = window.OffscreenCanvas || NOOP;\n\n/**\n * Typeguards to see if the canvas is specifically an offscreen canvas or not.\n */\nexport function isOffscreenCanvas(\n  canvas: CanvasElement\n): canvas is OffscreenCanvas {\n  return canvas instanceof OffscreenCanvas;\n}\n\n/**\n * This defines the extensions the framework works with\n */\nexport interface IExtensions {\n  /** Extension for anisotropic filtering */\n  anisotropicFiltering?: {\n    ext: EXT_texture_filter_anisotropic;\n    stat: {\n      maxAnistropicFilter: number;\n    };\n  };\n  /** Extension for MRT (Multiple render targets) */\n  drawBuffers?: WebGL2RenderingContext | WEBGL_draw_buffers;\n  /** Extension for hardware instancing */\n  instancing?: WebGL2RenderingContext | ANGLE_instanced_arrays;\n  /** Extension for float texture as a color buffer */\n  renderFloatTexture?: WEBGL_color_buffer_float;\n  /** Extension for float textures */\n  floatTex?: WebGL2RenderingContext | OES_texture_float;\n  /** Extension for float textures linear filtering */\n  floatTexFilterLinear?: WebGL2RenderingContext | OES_texture_float_linear;\n  /** Extension for half float textures */\n  halfFloatTex?: WebGL2RenderingContext | OES_texture_half_float;\n  /** Extension for half float textures linear filtering */\n  halfFloatTexFilterLinear?:\n    | WebGL2RenderingContext\n    | OES_texture_half_float_linear;\n  /** Extension support for Vertex Array Objects */\n  vao?: WebGL2RenderingContext | OES_vertex_array_object;\n}\n\n/**\n * These are the state responses for using a material\n */\nexport enum UseMaterialStatus {\n  /** The material had an error when being used */\n  INVALID = 0,\n  /** The material is now in use and ready for draws */\n  VALID = 1,\n  /**\n   * The current render target and the material specified have no matching\n   * output types, thus drawing with the provided material will result in\n   */\n  NO_RENDER_TARGET_MATCHES\n}\n","import {\n  GLSettings,\n  RenderBufferOutputTarget,\n  RenderTarget,\n  Texture,\n  WebGLStat\n} from \"../gl\";\nimport { ColorBuffer } from \"../gl/color-buffer\";\nimport { Instance, InstanceProvider } from \"../instance-provider\";\nimport { Vec2 } from \"../math\";\nimport { BaseProjection, SimpleProjection } from \"../math/base-projection\";\nimport { AbsolutePosition } from \"../math/primitives/absolute-position\";\nimport { Bounds } from \"../math/primitives/bounds\";\nimport { BaseResourceOptions } from \"../resources/base-resource-manager\";\nimport {\n  colorBufferRequest,\n  IColorBufferResource,\n  isColorBufferResource\n} from \"../resources/color-buffer\";\nimport { ResourceRouter } from \"../resources/resource-router\";\nimport {\n  IRenderTextureResource,\n  isRenderTextureResource\n} from \"../resources/texture/render-texture\";\nimport { textureRequest } from \"../resources/texture/render-texture-resource-request\";\nimport { Color, FragmentOutputType, Omit } from \"../types\";\nimport { Camera } from \"../util/camera\";\nimport { IdentifyByKey, IdentifyByKeyOptions } from \"../util/identify-by-key\";\nimport { Layer } from \"./layer\";\nimport { LayerScene } from \"./layer-scene\";\n\nexport enum ClearFlags {\n  COLOR = 0b0001,\n  DEPTH = 0b0010,\n  STENCIL = 0b0100\n}\n\n/**\n * A type to describe the constructor of a View class.\n */\nexport interface IViewConstructable<TViewProps extends IViewProps> {\n  new (scene: LayerScene, props: TViewProps): View<TViewProps>;\n}\n\n/**\n * This specifies a class type that can be used in creating a view with\n * createView\n */\nexport type IViewConstructionClass<\n  TViewProps extends IViewProps\n> = IViewConstructable<TViewProps> & { defaultProps: TViewProps };\n\n/**\n * This is a pair of a Class Type and the props to be applied to that class\n * type.\n */\nexport type ViewInitializer<TViewProps extends IViewProps> = {\n  key: string;\n  init: [IViewConstructionClass<TViewProps>, IViewProps];\n};\n\n/**\n * This describes a target resource for the view to output into.\n */\nexport type ViewOutputTarget = {\n  /**\n   * The form of information this output will provide. This is mostly an\n   * arbitrary number to help make associations between an output target and the\n   * type of information a layer can provide.\n   */\n  outputType: FragmentOutputType | number;\n  /** The resource key that the output will target */\n  resource: BaseResourceOptions;\n};\n\n/**\n * Used for reactive view generation and updates.\n */\nexport function createView<TViewProps extends IViewProps>(\n  viewClass: IViewConstructable<TViewProps> & { defaultProps: TViewProps },\n  props: Omit<TViewProps, \"key\" | \"viewport\"> &\n    Partial<Pick<TViewProps, \"key\" | \"viewport\">>\n): ViewInitializer<TViewProps> {\n  const keyedProps = Object.assign(props, {\n    key: props.key || \"\",\n    viewport: props.viewport || {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }\n  });\n\n  return {\n    get key() {\n      return props.key || \"\";\n    },\n    init: [viewClass, keyedProps]\n  };\n}\n\n/**\n * Defines the input metrics of a view for a scene.\n */\nexport interface IViewProps extends IdentifyByKeyOptions {\n  /**\n   * The background color that gets cleared out for this view. Performance is\n   * better if this is left clear. Probably better to draw a colored quad\n   * instead. This is just convenient.\n   */\n  background?: Color;\n  /**\n   * This is the 3D camera used to create a vantage point in the 3D world and\n   * project it's viewpoint to the 2d screen.\n   */\n  camera: Camera;\n  /**\n   * This sets what buffers get cleared by webgl before the view is drawn in\n   * it's space.\n   */\n  clearFlags?: ClearFlags[];\n  /**\n   * Helps assert a guaranteed rendering order if needed. Lower numbers render\n   * first.\n   */\n  order?: number;\n  /**\n   * Excluding this property means the view will render to the screen. Only\n   * include this if you have a targetted resource to take in what you want to\n   * render.\n   *\n   * This lets you target resources based on their key for where you want to\n   * render the output of the view to. If you just specify a key, it will assume\n   * it is rendering to the target with COLOR information as a default.\n   *\n   * If you specify multiple targets with outputType definitions, then the\n   * system will look for those information types in the layer renderings and\n   * match those render targets to the outputs of the layer. If the layer has\n   * nothing to provide for the outputTypes defined, then the layer won't render\n   * anything at all to any of the outputs.\n   */\n  output?: {\n    /**\n     * Specify output targets for the color buffers this view wants to write to.\n     * These should be targets specifying resource keys and provide outputTypes\n     * to match information potentially provided by the layers.\n     */\n    buffers: Record<\n      number,\n      IRenderTextureResource | IColorBufferResource | undefined\n    >;\n    /**\n     * Set to true to include a depth buffer the system will generate for you.\n     * Set to a resource id to target an output texture to store the depth\n     * buffer. Set to false to not have the depth buffer used or calculated.\n     */\n    depth: IRenderTextureResource | IColorBufferResource | boolean;\n  };\n  /**\n   * This specifies the bounds on the canvas this camera will render to. This\n   * let's you render say a little square in the bottom right showing a minimap.\n   *\n   * If this is not specified, the entire canvas will be the viewport.\n   */\n  viewport: AbsolutePosition;\n  /**\n   * This helps resolve scaling differences between a View rendering to an\n   * offscreen target, which is then rendered the screen. This is commonly\n   * associated with the render target being a scaled version of the screen,\n   * then rendered to the screen.\n   */\n  screenScale?: Vec2;\n  /**\n   * If provided, this will manually set the pixel ratio of the view. THis is\n   * used to help adjust for differing render targets that may not directly\n   * render to the screen but rather in scaled modes.\n   */\n  pixelRatio?: number;\n}\n\n/**\n * A View renders a perspective of a scene to a given surface or surfaces.\n */\nexport abstract class View<\n  TViewProps extends IViewProps\n> extends IdentifyByKey {\n  static defaultProps: IViewProps = {\n    key: \"\",\n    camera: Camera.makeOrthographic(),\n    viewport: { left: 0, right: 0, top: 0, bottom: 0 }\n  };\n\n  /** End time of animation */\n  animationEndTime: number = 0;\n  /**\n   * This is the depth of the view. The higher the depth represents which layer\n   * is on top. Zero always represents the default view.\n   */\n  depth: number = 0;\n  /** Last frame time this view was rendered under */\n  lastFrameTime: number = 0;\n  /** This is the flag to see if a view needs draw */\n  needsDraw: boolean = false;\n  /**\n   * This is a flag for various processes to indicate the view is demanding\n   * optimal rendering performance over other processes. This is merely a\n   * hinting device and does not guarantee better performance at any given\n   * moment.\n   */\n  optimizeRendering: boolean = false;\n  /**\n   * This is set to ensure the projections that happen properly translates the\n   * pixel ratio to normal Web coordinates\n   */\n  get pixelRatio() {\n    return this.props.pixelRatio ?? this._pixelRatio;\n  }\n\n  set pixelRatio(val: number) {\n    this._pixelRatio = val;\n  }\n\n  private _pixelRatio: number = 1;\n  /**\n   * This establishes the projection methods that can be used to project\n   * geometry between the screen and the world\n   */\n  projection: BaseProjection<View<TViewProps>>;\n  /** The props applied to this view */\n  props: TViewProps;\n  /**\n   * This is the router that makes it possible to request resources. Our view\n   * needs this to be available to aid in creating render targets to output\n   * into.\n   */\n  resource: ResourceRouter;\n  /**\n   * If this is set, then this view is outputting its rendering somewhere that\n   * is not the direct screen buffer.\n   */\n  renderTarget?: RenderTarget;\n  /** The scene this view is displaying */\n  scene: LayerScene;\n\n  get screenBounds() {\n    return this.projection.screenBounds;\n  }\n\n  set screenBounds(val: Bounds<View<TViewProps>>) {\n    this.projection.screenBounds = val;\n  }\n\n  get viewBounds() {\n    return this.projection.viewBounds;\n  }\n\n  set viewBounds(val: Bounds<View<TViewProps>>) {\n    this.projection.viewBounds = val;\n  }\n\n  /** Retrieves the clearflag prop assigned to the view and provides a default */\n  get clearFlags() {\n    return this.props.clearFlags || [];\n  }\n\n  /** Retrieves the order prop assigned to the view and provides a default */\n  get order() {\n    return this.props.order || 0;\n  }\n\n  constructor(scene: LayerScene, props: TViewProps) {\n    super(props);\n    this.scene = scene;\n    // Keep our props within the view\n    this.props = Object.assign({}, View.defaultProps || {}, props);\n  }\n\n  /**\n   * retrieves this view's targets for outputting fragment information. This\n   * provides a simple list of the target's keys with their output type.\n   */\n  getOutputTargets() {\n    const { output } = this.props;\n    let bufferTargets: ViewOutputTarget[] = [];\n    if (!output) return null;\n\n    // A string simply matches the output to the default COLOR information type.\n    if (\n      isRenderTextureResource(output.buffers) ||\n      isColorBufferResource(output.buffers)\n    ) {\n      bufferTargets = [\n        {\n          outputType: FragmentOutputType.COLOR,\n          resource: output.buffers\n        }\n      ];\n    }\n\n    // A Record causes us to pull out the necessary pieces of the outputs and\n    // resource keys or strings as the keys.\n    else {\n      Object.keys(output.buffers).forEach(outputTypeKey => {\n        const outputType = Number.parseFloat(outputTypeKey);\n        const resource = output.buffers[outputType];\n        if (!resource) return;\n\n        bufferTargets.push({\n          outputType,\n          resource\n        });\n      });\n    }\n\n    return bufferTargets;\n  }\n\n  /**\n   * The view can have one or multiple render targets. This helps by always\n   * returning a list containing all of the render targets. Returns an empty\n   * list if there is no render target associated with the view.\n   */\n  getRenderTargets() {\n    if (!this.renderTarget) return [];\n\n    return [this.renderTarget];\n  }\n\n  /**\n   * This generates the render target needed to handle the output configuration\n   * specified by the props and the layer configuration.\n   *\n   * This is called by the system and should never need to be called externally.\n   */\n  createRenderTarget() {\n    // TODO: We should NOT blow away our previous render target without first\n    // seeing if the existing render target is sufficient to handle our\n    // potentially new configuration.\n    // Clear out the previous target\n    if (this.renderTarget) {\n      if (Array.isArray(this.renderTarget)) {\n        this.renderTarget.forEach(t => t.dispose());\n      } else {\n        this.renderTarget.dispose();\n      }\n    }\n\n    const { output } = this.props;\n    const surface = this.scene.surface;\n\n    // No output specified means we're just rendering to the screen so all of\n    // the outputType hullabaloo is moot.\n    if (!output || !surface) return;\n\n    // We analyze the fragment shaders the layers have determined can provide\n    // for this view for the indicated output types. Essentially, we use this\n    // information to determine if all the layers provided can NOT provide for\n    // specific outputTypes. We only create our RenderTarget based on what our\n    // layers are capable of handling.\n    const supportedOutputTypes = new Set<number>();\n\n    for (let i = 0, iMax = this.scene.layers.length; i < iMax; ++i) {\n      const layer = this.scene.layers[i];\n      const fragmentOutputs = layer.shaderIOInfo.fs.get(this);\n\n      if (!fragmentOutputs) {\n        continue;\n      }\n\n      fragmentOutputs.outputTypes.forEach(type =>\n        supportedOutputTypes.add(type)\n      );\n    }\n\n    // Retrieve the RenderTextures for each buffer target we have specified\n    const renderBuffers = new Map<number, Texture | ColorBuffer>();\n    const dummyLayer = new Layer(surface, this.scene, {\n      key: \"\",\n      data: new InstanceProvider()\n    });\n    const dummyInstance = new Instance({});\n    const bufferTargets = this.getOutputTargets() || [];\n\n    for (let i = 0, iMax = bufferTargets.length; i < iMax; ++i) {\n      const bufferTarget = bufferTargets[i];\n      const resource = bufferTarget.resource;\n\n      if (supportedOutputTypes.has(bufferTarget.outputType)) {\n        if (isRenderTextureResource(resource)) {\n          // Submit our request for the specified resource\n          const request = textureRequest({\n            key: bufferTarget.resource.key\n          });\n\n          this.resource.request(dummyLayer, dummyInstance, request);\n\n          if (!request.texture) {\n            console.warn(\n              \"A view has a RenderTexture output target with key:\",\n              bufferTarget.resource.key,\n              \"however, no RenderTexture was found for the key.\",\n              \"Please ensure you have a 'resource' specified for the Surface with the proper key\",\n              \"Also ensure the resource is made via createTexture()\"\n            );\n            throw new Error(\n              `Output target unable to be constructed for view ${this.id}`\n            );\n          }\n\n          renderBuffers.set(bufferTarget.outputType, request.texture);\n        } else {\n          const request = colorBufferRequest({\n            key: bufferTarget.resource.key\n          });\n\n          this.resource.request(dummyLayer, dummyInstance, request);\n\n          if (!request.colorBuffer) {\n            console.warn(\n              \"A view has a ColorBuffer output target with key:\",\n              bufferTarget.resource.key,\n              \"however, no ColorBuffer was found for the key.\",\n              \"Please ensure you have a 'resource' specified for the Surface with the proper key\",\n              \"Also ensure the resource is made via createColorBuffer()\"\n            );\n            throw new Error(\n              `Output target unable to be constructed for view ${this.id}`\n            );\n          }\n\n          renderBuffers.set(bufferTarget.outputType, request.colorBuffer);\n        }\n      }\n    }\n\n    let checkW: number, checkH: number;\n    renderBuffers.forEach(resource => {\n      if (resource instanceof Texture) {\n        if (checkW === void 0 || checkH === void 0) {\n          checkW = resource.data?.width || 0;\n          checkH = resource.data?.height || 0;\n        }\n\n        if (checkW === 0 || checkH === 0) {\n          throw new Error(\n            \"RenderTexture for View can NOT have a width or height of zero.\"\n          );\n        }\n\n        if (\n          resource.data?.width !== checkW ||\n          resource.data.height !== checkH\n        ) {\n          throw new Error(\n            \"When a view has multiple output targets: ALL RenderTextures and ColorBuffers that a view references MUST have the same dimensions\"\n          );\n        }\n      } else {\n        if (checkW === void 0 || checkH === void 0) {\n          checkW = resource.size[0] || 0;\n          checkH = resource.size[1] || 0;\n        }\n\n        if (checkW === 0 || checkH === 0) {\n          throw new Error(\n            \"RenderTexture for View can NOT have a width or height of zero.\"\n          );\n        }\n\n        if (resource.size[0] !== checkW || resource.size[1] !== checkH) {\n          throw new Error(\n            \"When a view has multiple output targets: ALL RenderTextures and ColorBuffers that a view references MUST have the same dimensions\"\n          );\n        }\n      }\n    });\n\n    let depthBuffer;\n\n    if (output.depth) {\n      // Find the render target resource specified that is intended to store the\n      // depth buffer\n      if (isRenderTextureResource(output.depth)) {\n        // Generate our request to retrieve the depth buffer from the manager\n        // handling the indicated texture.\n        const request = textureRequest({\n          key: output.depth.key\n        });\n\n        this.resource.request(dummyLayer, dummyInstance, request);\n\n        if (!request.texture) {\n          console.warn(\n            \"A view has a depth buffer output target with key:\",\n            output.depth,\n            \"however, no RenderTexture was found for the key.\",\n            \"Please ensure you have a 'resource' specified for the Surface with the proper key\",\n            \"Also ensure the resource is made via createTexture()\"\n          );\n          throw new Error(\n            `Output target unable to be constructed for view ${this.id}`\n          );\n        }\n\n        depthBuffer = request.texture;\n      } else if (isColorBufferResource(output.depth)) {\n        // Generate our request to retrieve the depth buffer from the manager\n        // handling the indicated texture.\n        const request = colorBufferRequest({\n          key: output.depth.key\n        });\n\n        this.resource.request(dummyLayer, dummyInstance, request);\n\n        if (!request.colorBuffer) {\n          console.warn(\n            \"A view has a depth buffer output target with key:\",\n            output.depth.key,\n            \"however, no ColorBuffer was found for the key.\",\n            \"Please ensure you have a 'resource' specified for the Surface with the proper key\",\n            \"Also ensure the resource is made via createColorBuffer()\"\n          );\n          throw new Error(\n            `Output target unable to be constructed for view ${this.id}`\n          );\n        }\n\n        depthBuffer = request.colorBuffer;\n      }\n\n      // Otherwise, just create a buffer format for the buffer\n      else {\n        depthBuffer =\n          GLSettings.RenderTarget.DepthBufferFormat.DEPTH_COMPONENT16;\n      }\n    }\n\n    // Now with our listing of supported types, we create an appropriate\n    // RenderTarget or RenderTarget's based on system capabilities. MRT enabled\n    // systems can have a single render target that handles multiple targets\n    // while non MRT systems will have multiple render targets\n    if (WebGLStat.MRT) {\n      const colorBuffers: RenderBufferOutputTarget[] = [];\n      renderBuffers.forEach((tex, type) =>\n        colorBuffers.push({\n          buffer: tex,\n          outputType: type\n        })\n      );\n\n      this.renderTarget = new RenderTarget({\n        buffers: {\n          color: colorBuffers,\n          depth: depthBuffer\n        },\n        // Render target texture retention is governed by the resource set up\n        // on the surface\n        retainTextureTargets: true\n      });\n    }\n\n    // Non-MRT makes multiple render targets. One for each output type.\n    else {\n      throw new Error(\"MRT for non-MRT systems not supported yet.\");\n    }\n  }\n\n  /**\n   * This let's the view do anything it needs to be ready for next render. Some\n   * tasks this may include is checking if it's render target is still valid.\n   * It's buffer outputs can get invalidated for any number of reasons.\n   */\n  willUseView() {\n    const targets = this.getRenderTargets();\n\n    if (this.props.screenScale) {\n      this.projection.screenScale = this.props.screenScale;\n    }\n\n    const invalid = targets.some(target =>\n      target.getBuffers().some(buffer => {\n        if (buffer.buffer.destroyed) return true;\n        return false;\n      })\n    );\n\n    if (invalid) {\n      this.createRenderTarget();\n    }\n  }\n\n  /**\n   * This operation makes sure we have the view camera adjusted to the new\n   * viewport's needs. For default behavior this ensures that the coordinate\n   * system has no distortion, orthographic, top left as 0,0 with +y axis\n   * pointing down.\n   */\n  abstract fitViewtoViewport(\n    _surfaceDimensions: Bounds<never>,\n    viewBounds: Bounds<View<IViewProps>>\n  ): void;\n\n  /*\n   * This method returns a flag indicating whether or not the view should\n   * trigger a redraw. By default, a redraw is triggered (this returns true)\n   * when a shallow comparison of the current props and the incoming props are\n   * different. This method can be overridden to place custom logic at this\n   * point to indicate when redraws should happen.\n   *\n   * NOTE: This should be considered for redraw logic centered around changes in\n   * the view itself. There ARE additional triggers in the system that causes\n   * redraws. This method just aids in ensuring necessary redraws take place for\n   * view level logic and props.\n   */\n  shouldDrawView(oldProps: TViewProps, newProps: TViewProps) {\n    for (const key in newProps) {\n      if (newProps[key] !== oldProps[key]) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Lifecycle: Fires before the props object is updated with the newProps.\n   * Allows view to respond to diff changes.\n   */\n  willUpdateProps(_newProps: IViewProps) {\n    // No-op for the base behavior\n  }\n\n  /**\n   * Lifecycle: Executes after props have been updated with new contents\n   */\n  didUpdateProps() {\n    // No-op for the base behavior\n  }\n}\n\n/**\n * A view that does not view anything.\n * Useful as a placeholder view to not cause null or undefined values.\n */\nexport class NoView extends View<IViewProps> {\n  projection = new SimpleProjection();\n\n  screenToWorld(_point: Vec2, _out?: Vec2): Vec2 {\n    return [0, 0];\n  }\n\n  worldToScreen(_point: Vec2, _out?: Vec2): Vec2 {\n    return [0, 0];\n  }\n\n  viewToWorld(_point: Vec2, _out?: Vec2): Vec2 {\n    return [0, 0];\n  }\n\n  worldToView(_point: Vec2, _out?: Vec2): Vec2 {\n    return [0, 0];\n  }\n\n  fitViewtoViewport(\n    screenBounds: Bounds<never>,\n    _viewBounds: Bounds<View<IViewProps>>\n  ) {\n    /** noop */\n    this.screenBounds = screenBounds;\n  }\n\n  constructor() {\n    super(new LayerScene(undefined, { key: \"error\", layers: [], views: [] }), {\n      key: \"error\",\n      viewport: {},\n      camera: Camera.makeOrthographic()\n    });\n\n    this.screenBounds = new Bounds<never>({\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 100\n    });\n  }\n}\n","import { PromiseResolver } from \"./promise-resolver\";\n\n/**\n * The structure of a command that can be injected into the queue. The time\n * provided is the time the command was executed. endTime is a time that can be\n * used\n */\ntype Command = (t: number, endTime?: number) => void;\n\n/**\n * This identifier is the base requestAnimationFrame id that is used to later\n * stop the command queues completely\n */\nlet animationFrameId = -1;\n/** This is the current time last frame executed. */\nlet currentTime = 0;\n\n/**\n * Contains the commands to be executed after the next animation cycle (ie- not\n * this frame, but next frame)\n */\nlet nextQueuedCommands: Command[] = [];\n/** Contains the commands to be executed immediately on next animation cycle */\nlet immediateQueuedCommands: [Command, number, number][] = [];\n/**\n * After a frame has passed, the next queued commands filter into this queue to\n * be executed next frame\n */\nlet nextFrameCommands: Command[] = [];\n/**\n * Commands that are going to be executed repeatedly on the animation loop.\n * [Command, interval, intervalStartTime, duration, durationStartTime]\n */\nconst animationLoopCommands = new Map<\n  Promise<number>,\n  [Command, number, number, number, number]\n>();\n\n/**\n * Frame loop that executes queued commands\n */\nconst loop = (time: number) => {\n  currentTime = time;\n  let keepLooping = false;\n  const stopAnimationLoops: Promise<number>[] = [];\n\n  // Execute all of the animation loop commands\n  animationLoopCommands.forEach((command, id) => {\n    keepLooping = true;\n    let [\n      commandFn,\n      interval,\n      intervalStartTime,\n      duration,\n      durationStartTime\n    ] = command;\n\n    // Check to see if the command has a specified duration\n    if (duration !== -1) {\n      if (durationStartTime === -1) {\n        durationStartTime = time;\n        command[4] = time;\n      }\n\n      // If we've exceeded the duration, we fire the command one last guaranteed\n      // time and flag it for removal from the loop\n      if (time - durationStartTime >= duration) {\n        stopAnimationLoops.push(id);\n        commandFn(time, durationStartTime + duration);\n        return;\n      }\n    }\n\n    // Check to see if the command has interval assertions\n    if (interval !== -1) {\n      // Initialize interval time start\n      if (intervalStartTime === -1) {\n        command[2] = time;\n        intervalStartTime = time;\n      }\n\n      // If we are greater than our interval we execute our command\n      if (time - intervalStartTime >= interval) {\n        commandFn(time);\n\n        while (time - intervalStartTime >= interval) {\n          command[2] += interval;\n          intervalStartTime += interval;\n        }\n      }\n    } else {\n      commandFn(time);\n    }\n  });\n\n  // Remove any commands that have exceeded their duration\n  for (let i = 0, iMax = stopAnimationLoops.length; i < iMax; ++i) {\n    const id = stopAnimationLoops[i];\n    animationLoopCommands.delete(id);\n  }\n\n  // Instant dump the commands into a separate list in case the commands have\n  // more onFrame commands called within\n  const immediate = immediateQueuedCommands.slice();\n  immediateQueuedCommands = [];\n\n  // Execute all imeediately queued commands\n  for (let i = 0, iMax = immediate.length; i < iMax; ++i) {\n    const [command, interval, startTime] = immediate[i];\n\n    // If an interval is not specified, then we simply execute the command\n    // immediately\n    if (interval <= 0) {\n      if (command) {\n        command(time);\n      }\n    }\n\n    // If we have a specified interval, then we need to see if a certain amount\n    // of time has lapsed to satisfy the interval. If the interval is not\n    // satisfied, then the command is requeued to be checked next execution\n    // loop.\n    else {\n      if (time - startTime > interval) {\n        command(time);\n      } else {\n        keepLooping = true;\n        immediateQueuedCommands.push(immediate[i]);\n      }\n    }\n  }\n\n  // Empty and execute all next frame commands\n  for (let i = 0, iMax = nextFrameCommands.length; i < iMax; ++i) {\n    const command = nextFrameCommands[i];\n\n    if (command) {\n      keepLooping = true;\n      command(time);\n    }\n  }\n\n  // Currently queued commands get put into the nextFrameCommand buffer to be\n  // executed next animation frame instead of the current frame.\n  nextFrameCommands = nextQueuedCommands.slice(0);\n  nextQueuedCommands = [];\n\n  if (nextFrameCommands.length > 0) {\n    keepLooping = true;\n  }\n\n  if (keepLooping) animationFrameId = requestAnimationFrame(loop);\n  else animationFrameId = -1;\n};\n\n// Start the command loop\nanimationFrameId = requestAnimationFrame(loop);\n\n/**\n * Method that queues up a command to be executed not on this animation frame,\n * but the next one\n */\nexport function nextFrame(command?: Command) {\n  const resolver = new PromiseResolver<number>();\n\n  nextQueuedCommands.push((t: number) => {\n    if (command) command(t);\n    resolver.resolve(t);\n  });\n\n  if (animationFrameId === -1) {\n    animationFrameId = requestAnimationFrame(loop);\n  }\n\n  return resolver.promise;\n}\n\n/**\n * Method that queues up a command to be executed on the upcoming animation\n * frame.\n *\n * If a time interval is specified, the command will not execute until AT LEAST\n * the specified amount of time has lapsed.\n */\nexport function onFrame(command?: Command, interval?: number) {\n  const resolver = new PromiseResolver<number>();\n  const wrappedCommand: Command = (t: number) => {\n    if (command) command(t);\n    resolver.resolve(t);\n  };\n\n  immediateQueuedCommands.push([wrappedCommand, interval || -1, currentTime]);\n\n  if (animationFrameId === -1) {\n    animationFrameId = requestAnimationFrame(loop);\n  }\n\n  return resolver.promise;\n}\n\n/**\n * Method that queues a command to fire every animation loop. Does not stop\n * until the returned id for the command is called with stopAnimationLoop(id).\n *\n * You can specify an interval to make the loop execute on the animation frame\n * but after a given lapse of time. For example: an interval of 1000 will make\n * the loop execute on the animation frame but only after 1 second has lapsed\n * since last time this command executed.\n *\n * You can also specify a duration so the commands will only execute so long as\n * the duration specified has not been exceeeded. Once the duration is met or\n * exceeded, the command will be removed from the loop queue and no longer fire.\n * There will ALWAYS be a final frame that is executed for the command that will\n * provide the time the command SHOULD HAVE finished (not necessarily the actual\n * current time).\n *\n * This method returns a promise which allows for some insight into timings on\n * the animation loop. If NO duration is specified, then the promise resolves\n * the first time the command is executed. If a duration IS specified, then the\n * promise resolves after the duration has completed.\n */\nexport function onAnimationLoop(\n  command: Command,\n  interval?: number,\n  duration?: number\n) {\n  const id = new PromiseResolver<number>();\n\n  const wrappedCommand: Command = (t: number, endTime?: number) => {\n    command(t);\n\n    if (duration !== void 0 && duration > 0) {\n      if (endTime !== void 0) {\n        id.resolve(endTime);\n      }\n    } else {\n      id.resolve(t);\n    }\n  };\n\n  animationLoopCommands.set(id.promise, [\n    wrappedCommand,\n    interval || -1,\n    -1,\n    duration || -1,\n    -1\n  ]);\n\n  if (animationFrameId === -1) {\n    animationFrameId = requestAnimationFrame(loop);\n  }\n\n  return id.promise;\n}\n\n/**\n * Halts the animation loop for a command associated with an id.\n */\nexport function stopAnimationLoop(id: Promise<number>) {\n  animationLoopCommands.delete(id);\n\n  if (animationFrameId === -1) {\n    animationFrameId = requestAnimationFrame(loop);\n  }\n}\n\n/**\n * This method provides an ensured way to clear ALL commands queued up to fire\n * for a frame. This includes halting all: animation loops, nextFrame, and\n * onFrame commands.\n */\nexport function stopAllFrameCommands() {\n  animationLoopCommands.forEach(cmd => cmd[0](currentTime, currentTime));\n  animationLoopCommands.clear();\n  immediateQueuedCommands = [];\n  nextQueuedCommands = [];\n  nextFrameCommands = [];\n}\n","/**\n * This is a convenience object for creating a promise and retrieving it's resolve method for\n * later use in resolving a situation. Very handy for making a method asynchronous.\n */\nexport class PromiseResolver<T> {\n  resolver: (val: T | undefined) => void;\n  rejector: Function;\n  promise: Promise<T>;\n\n  constructor() {\n    this.promise = new Promise(\n      (resolve, reject) => ((this.resolver = resolve), (this.rejector = reject))\n    );\n  }\n\n  resolve(val?: T) {\n    this.resolver(val);\n  }\n\n  reject<U>(reason: U) {\n    this.rejector(reason);\n  }\n}\n","import { Material } from \"../../gl\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport { Vec2, Vec4 } from \"../../math\";\nimport { IInstanceAttributeInternal, InstanceDiff } from \"../../types\";\nimport { Layer } from \"../layer\";\nimport { generateLayerMaterial } from \"../layer-processing\";\nimport { LayerScene } from \"../layer-scene\";\n\nexport function isBufferLocation(val: any): val is IBufferLocation {\n  return val && val.buffer && val.buffer.value;\n}\n\nexport function isBufferLocationGroup(\n  val: any\n): val is IBufferLocationGroup<IBufferLocation> {\n  return val && val.propertyToBufferLocation;\n}\n\n/**\n * This defines a base information object that explains where in a buffer a value\n * is represented.\n */\nexport interface IBufferLocation {\n  /** This is the parent attribute of this location */\n  attribute: IInstanceAttributeInternal<Instance>;\n  /** For some buffer strategies, there is a concept of block that is used to tightly pack attributes together. */\n  block?: number;\n  /**\n   * This is the generic buffer object interface for accessing the actual buffer.\n   */\n  buffer: {\n    value: Float32Array | Uint8Array | Vec4[];\n  };\n  /**\n   * If the attribute has child attributes (attributes auto generated as a consequence of the attributes settings)\n   * then the children's buffer locations can be found here.\n   */\n  childLocations?: IBufferLocation[];\n  /**\n   * This is the instance index indicative of the instance positioning within the buffer.\n   * Keep in mind: This does NOT correlate to a lookup for an Instance object but rather for\n   * the instancing concept designed for GL Buffers.\n   */\n  instanceIndex: number;\n  /**\n   * This is the range within the buffer values should be injected for this location.\n   */\n  range: Vec2;\n}\n\n/**\n * Each instance that comes in can be associated with a group of buffer locations. A buffer location for each\n * instance attribute used in updates. So a grouping is several buffer locations that are keyed by\n * the instance's property's UIDs.\n */\nexport interface IBufferLocationGroup<T extends IBufferLocation> {\n  /** This is the instance index WITHIN THE BUFFERS. This does NOT have relevance to Instance type objects */\n  instanceIndex: number;\n  /** This is a map of property UIDs to an associated buffer location */\n  propertyToBufferLocation: { [key: number]: T };\n}\n\n/**\n * Layers manage instances and those instances require a form of binding to their associated buffers.\n * The buffers have to be intelligently created and managed in this tieing to maximize performance.\n * One can not have a buffer for every instance in most cases, so the buffer manager has to get instances\n * to cooperate sharing a buffer in whatever strategy possible that best suits the hardware and it's limitations.\n *\n * This provides a uniform interface between instances and their corresponding buffer.\n */\nexport abstract class BufferManagerBase<\n  T extends Instance,\n  U extends IBufferLocation\n> {\n  /** This is the list of changes in effect while this manager is processing requests */\n  changeListContext: InstanceDiff<T>[];\n  /** The layer this manager glues Instances to Buffers */\n  layer: Layer<T, any>;\n  /** The scene the layer is injecting elements into */\n  scene: LayerScene;\n\n  /**\n   * Base constructor. A manager always needs to be associated with it's layer and it's scene.\n   */\n  constructor(layer: Layer<T, any>, scene: LayerScene) {\n    this.layer = layer;\n    this.scene = scene;\n  }\n\n  /**\n   * This adds an instance to the manager and thus ties the instance to an IBuffer location\n   */\n  add: (instance: T) => U | IBufferLocationGroup<U> | undefined;\n\n  /**\n   * This allows a manager to clean up any contextual information it may have stored while processing changes.\n   */\n  changesProcessed() {\n    delete this.changeListContext;\n  }\n\n  /**\n   * Destroy all elements that consume GPU resources or consumes otherwise unreleaseable resources.\n   */\n  abstract destroy(): void;\n\n  /**\n   * Retrieves the buffer locations for the instance provided\n   */\n  abstract getBufferLocations(\n    instance: T\n  ): U | IBufferLocationGroup<U> | undefined;\n\n  /**\n   * This retrieves the property ID for the active attribute. This is necessary to prevent\n   * the need for lookups to find the active attribute.\n   */\n  abstract getActiveAttributePropertyId(): number;\n\n  /**\n   * This returns how many instances this buffer manager has grown to accommodate.\n   */\n  abstract getInstanceCount(): number;\n\n  /**\n   * This should provide a minimum property id list that represents a set of properties that if triggered\n   * for update, would cause all of the attributes to be updated for the layer.\n   */\n  abstract getUpdateAllPropertyIdList(): number[];\n\n  /**\n   * This will be called with the changes that WILL be processed. This allows this manager to make extra judgement calls on\n   * how it will process the changes and let's it optimize itself before changes are actually processed. An example optimization:\n   *\n   * The manager is receiving add requests. The manager receives an add request that triggers a resize of the buffer. Ideally,\n   * the buffer should perform a single resize operation to accommodate ALL add requests getting ready to stream in plus the\n   * current size of of the buffer. With this method, the changes will be available to the manager and let the manager make this\n   * important decision instead of reflexively grow the buffer as requests stream in, which can cause a large number of costly\n   * resize operations.\n   */\n  incomingChangeList(changes: InstanceDiff<T>[]) {\n    this.changeListContext = changes;\n  }\n\n  /**\n   * Default way to create the layer's material. This properly generates the\n   * material, mapping the fragment shaders over to the layer's view's render\n   * targetting system.\n   */\n  makeLayerMaterial(): Material {\n    const shaderInfo = this.layer.shaderIOInfo;\n\n    return generateLayerMaterial(\n      this.layer,\n      shaderInfo.vs,\n      shaderInfo.fs,\n      shaderInfo.uniforms,\n      shaderInfo.materialUniforms\n    );\n  }\n\n  /**\n   * This method checks to see if this buffer manager has linked an instance to a buffer\n   * location managed by this object.\n   */\n  abstract managesInstance(instance: T): boolean;\n\n  /**\n   * Disassociates an instance with it's buffer location and makes the instance\n   * in the buffer no longer drawable.\n   */\n  remove: (instance: T) => T;\n\n  /**\n   * Removes the manager from the scene it applied itself to.\n   */\n  abstract removeFromScene(): void;\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport {\n  BaseShaderIOInjection,\n  ShaderIOHeaderInjectionResult\n} from \"../../shaders/processing/base-shader-io-injection\";\nimport { MetricsProcessing } from \"../../shaders/processing/metrics-processing\";\nimport {\n  IInstanceAttribute,\n  IUniform,\n  IVertexAttribute,\n  ShaderInjectionTarget\n} from \"../../types\";\nimport { ILayerProps, Layer } from \"../layer\";\n\nexport type ShaderIOExpansion<T extends Instance> = {\n  /** The additional instance attributes to add to the layer's Shader IO */\n  instanceAttributes: IInstanceAttribute<T>[];\n  /** The additional uniforms to add to the layer's Shader IO */\n  uniforms: IUniform[];\n  /** The additional vertex attributes to add to the layer's Shader IO */\n  vertexAttributes: IVertexAttribute[];\n};\n\n/**\n * When processing attributes, uniforms, etc, it is a common event that special\n * ShaderIO types can be declared that requires additional ShaderIO\n * configuration to be added.\n *\n * This type of object can be added to the layer surface to provide a means to\n * process special attributes the current system or customized system will want\n * to handle.\n */\nexport abstract class BaseIOExpansion extends BaseShaderIOInjection {\n  /**\n   * This is called with the Layer's currently declared Shader IO configuration.\n   * The returned IO configuration will be added to the existing IO. Each\n   * BaseIOExpansion object will receive the expanded IO configuration of other\n   * expansion objects if the object is processed after another expansion\n   * object.\n   *\n   * NOTE: The inputs should NOT be modified in any way\n   */\n  expand<T extends Instance, U extends ILayerProps<T>>(\n    _layer: Layer<T, U>,\n    _instanceAttributes: IInstanceAttribute<T>[],\n    _vertexAttributes: IVertexAttribute[],\n    _uniforms: IUniform[]\n  ): ShaderIOExpansion<T> {\n    return {\n      instanceAttributes: [],\n      uniforms: [],\n      vertexAttributes: []\n    };\n  }\n\n  /**\n   * Every expansion object will be given the opportunity to validate the IO\n   * presented to it here, thus allowing unique IO configuration types to be\n   * confirmed before getting  completely processed.\n   *\n   * It will be expected that a unique Expansion object will have special\n   * requirements centered around the configuration object, thus it is expected\n   * this be implemented in a meaningful way to make devlopment clearer by\n   * making mistakes clearer to the developer.\n   *\n   * Messages should be logged within this method as warnings or errors when\n   * validations fail and then this method should return false indicating the\n   * validation failed.\n   *\n   * NOTE: The inputs should NOT be modified in any way\n   */\n  validate<T extends Instance, U extends ILayerProps<T>>(\n    _layer: Layer<T, U>,\n    _instanceAttributes: IInstanceAttribute<T>[],\n    _vertexAttributes: IVertexAttribute[],\n    _uniforms: IUniform[]\n  ): boolean {\n    return true;\n  }\n\n  /**\n   * This allows for injection into the header of the shader.\n   *\n   * The order these controllers are injected into the system determines the\n   * order the contents are written to the header. So dependent injections must\n   * be sorted appropriately.\n   *\n   * @param target The targetted shader object to receive the header. This will\n   *               be VERTEX or FRAGMENT but never ALL\n   * @param layer The layer that is currently being processed\n   * @param metrics Some metrics processed that are useful for making decisions\n   *                about buffering strategies etc.\n   */\n  processHeaderInjection(\n    _target: ShaderInjectionTarget,\n    _declarations: Map<string, string>,\n    _layer: Layer<Instance, ILayerProps<Instance>>,\n    _metrics: MetricsProcessing,\n    _vertexAttributes: IVertexAttribute[],\n    _instanceAttributes: IInstanceAttribute<Instance>[],\n    _uniforms: IUniform[]\n  ): ShaderIOHeaderInjectionResult {\n    return {\n      injection: \"\"\n    };\n  }\n\n  /**\n   * This allows for injection into the shader AFTER attribute destructuring has\n   * taken place.\n   *\n   * The order these controllers are injected into the system determines the\n   * order the contents are written to the header. So dependent injections must\n   * be sorted appropriately.\n   *\n   * @param layer The layer that is currently being processed\n   * @param metrics Some metrics processed that are useful for making decisions\n   *                about buffering strategies etc.\n   */\n  processAttributeDestructuring(\n    _layer: Layer<Instance, ILayerProps<Instance>>,\n    _declarations: Map<string, string>,\n    _metrics: MetricsProcessing,\n    _vertexAttributes: IVertexAttribute[],\n    _instanceAttributes: IInstanceAttribute<Instance>[],\n    _uniforms: IUniform[]\n  ): string {\n    return \"\";\n  }\n}\n","import { Bounds } from \"../../math/primitives/bounds\";\nimport { SubTexture } from \"./sub-texture\";\n\n/**\n * Helps us track the bounds of the image being loaded in tied in with the\n * texture it represents\n */\nexport interface IPackNodeDimensions<T> {\n  data: T;\n  bounds: Bounds<any>;\n}\n\n/**\n * This is used specifically by the atlas manager to aid in packing\n * in textures within an area. This will guarantee boundaries of textures are\n * not violated and provide proper feedback for where to draw a given image\n */\nexport class PackNode<T> {\n  child: [PackNode<T> | null, PackNode<T> | null] = [null, null];\n  isLeaf: boolean = true;\n  bounds: Bounds<any>;\n  data: T | null = null;\n\n  constructor(x: number, y: number, width: number, height: number) {\n    this.bounds = new Bounds({\n      height,\n      width,\n      x,\n      y\n    });\n  }\n\n  /**\n   * Deletes all of the sub nodes in this Mapping, thus clearing up memory usage\n   */\n  destroy() {\n    const child0 = this.child[0];\n    const child1 = this.child[1];\n    this.data = null;\n    if (child0) {\n      child0.destroy();\n    }\n    if (child1) {\n      child1.destroy();\n    }\n    this.child[0] = null;\n    this.child[1] = null;\n  }\n\n  /**\n   * Indicates if there is a child\n   */\n  hasChild(): boolean {\n    const child0 = this.child[0];\n    const child1 = this.child[1];\n    if (child0 && !child0.data) {\n      return !child0.isLeaf;\n    }\n    if (child1 && !child1.data) {\n      return !child1.isLeaf;\n    }\n    return false;\n  }\n\n  /**\n   * Inserts images into our mapping, fitting them appropriately\n   */\n  insert(image: IPackNodeDimensions<T>): PackNode<T> | null {\n    let child0 = this.child[0];\n    let child1 = this.child[1];\n\n    if (!this.isLeaf && child0 && child1) {\n      // Try inserting into first child\n      const newNode: PackNode<T> | null = child0.insert(image);\n      if (newNode !== null) return newNode;\n      // No room in first so insert into second\n      return child1.insert(image);\n    } else {\n      // If there's already an image here, return\n      if (this.data) return null;\n      // Check the fit status of the image in this nodes rectangle space\n      const fitFlag: number = this.bounds.fits(image.bounds);\n      // If we're too small, return null indicating can not fit\n      if (fitFlag === 0) return null;\n\n      // If we're just right, accept\n      if (fitFlag === 1) {\n        this.data = image.data;\n        return this;\n      }\n\n      // Otherwise, gotta split this node and create some leaves\n      this.isLeaf = false;\n      // Get the image width\n      const imgWidth: number = image.bounds.width;\n      const imgHeight: number = image.bounds.height;\n      // Decide which way to split\n      const dWidth: number = this.bounds.width - imgWidth;\n      const dHeight: number = this.bounds.height - image.bounds.height;\n\n      if (dWidth > dHeight) {\n        child0 = this.child[0] = new PackNode(\n          this.bounds.x,\n          this.bounds.y,\n          imgWidth,\n          this.bounds.height\n        );\n        child1 = this.child[1] = new PackNode(\n          this.bounds.x + imgWidth,\n          this.bounds.y,\n          dWidth,\n          this.bounds.height\n        );\n      } else {\n        child0 = this.child[0] = new PackNode(\n          this.bounds.x,\n          this.bounds.y,\n          this.bounds.width,\n          imgHeight\n        );\n        child1 = this.child[1] = new PackNode(\n          this.bounds.x,\n          this.bounds.y + imgHeight,\n          this.bounds.width,\n          dHeight\n        );\n      }\n    }\n\n    // Insert into first child we created\n    return child0.insert(image);\n  }\n\n  /**\n   * Removes the image from the mapping and tries to open up as much space as possible.\n   *\n   * @param {AtlasTexture} data The image to insert into the\n   */\n  remove(data: T): boolean {\n    const child0 = this.child[0];\n    const child1 = this.child[1];\n\n    if (child1 && child0 && !this.isLeaf) {\n      // Try removing from first child\n      let removed: boolean = child0.remove(data);\n      if (removed) return true;\n      // Try remove from second\n      removed = child1.remove(data);\n\n      if (!child0.hasChild()) {\n        if (!child1.hasChild()) {\n          this.child[0] = null;\n          this.child[1] = null;\n        }\n      }\n\n      return removed;\n    } else {\n      if (this.data === data) {\n        this.data = null;\n\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Applies a node's bounds to SubTexture.\n   */\n  static applyToSubTexture<T>(\n    root: PackNode<T>,\n    node: PackNode<T> | Bounds<T>,\n    texture?: SubTexture,\n    padding?: { top: number; left: number; right: number; bottom: number },\n    flipY?: boolean\n  ) {\n    if (!texture) return;\n\n    padding = padding || {\n      top: 0,\n      left: 0,\n      bottom: 0,\n      right: 0\n    };\n\n    const bounds = node instanceof PackNode ? node.bounds : node;\n\n    // Set our image's atlas properties\n    const ux = (bounds.x + padding.left) / root.bounds.width;\n    const uy = (bounds.y + padding.top) / root.bounds.height;\n    const uw =\n      (bounds.width - padding.left - padding.right) / root.bounds.width;\n    const uh =\n      (bounds.height - padding.top - padding.bottom) / root.bounds.height;\n\n    let atlasDimensions: Bounds<never>;\n\n    if (flipY) {\n      atlasDimensions = new Bounds({\n        bottom: 1.0 - uy,\n        left: ux,\n        right: ux + uw,\n        top: 1.0 - (uy + uh)\n      });\n    } else {\n      atlasDimensions = new Bounds({\n        top: 1.0 - uy,\n        left: ux,\n        right: ux + uw,\n        bottom: 1.0 - (uy + uh)\n      });\n    }\n\n    const bottom = atlasDimensions.bottom;\n    const top = atlasDimensions.y;\n    const left = atlasDimensions.x;\n    const right = atlasDimensions.x + atlasDimensions.width;\n\n    texture.atlasTL = [left, top];\n    texture.atlasBR = [right, bottom];\n    texture.atlasBL = [left, bottom];\n    texture.atlasTR = [right, top];\n    texture.widthOnAtlas = Math.abs(texture.atlasTR[0] - texture.atlasTL[0]);\n    texture.heightOnAtlas = Math.abs(texture.atlasTR[1] - texture.atlasBR[1]);\n    texture.pixelWidth = uw * root.bounds.width;\n    texture.pixelHeight = uh * root.bounds.height;\n  }\n}\n","import \"./base-modules\";\nexport * from \"./processing\";\n","import { BaseProjection } from \"../math\";\nimport { Bounds } from \"../math/primitives\";\nimport { IViewProps, View } from \"../surface/view\";\nimport { IMouseInteraction, ITouchInteraction } from \"./types\";\nimport { UserInputEventManager } from \"./user-input-event-manager\";\n\n/**\n * Classes can extend this and override the methods to respond to events.\n */\nexport abstract class EventManager {\n  private userInputManager: UserInputEventManager;\n\n  /** Allows an event manager to access it's governing surface */\n  get surface() {\n    return this.userInputManager.surface;\n  }\n\n  // MOUSE EVENTS\n\n  abstract handleMouseDown(e: IMouseInteraction): void;\n  abstract handleMouseUp(e: IMouseInteraction): void;\n  abstract handleMouseOver(e: IMouseInteraction): void;\n  abstract handleMouseOut(e: IMouseInteraction): void;\n  abstract handleMouseMove(e: IMouseInteraction): void;\n  abstract handleClick(e: IMouseInteraction): void;\n  abstract handleDrag(e: IMouseInteraction): void;\n  abstract handleWheel(e: IMouseInteraction): void;\n\n  // TOUCH EVENTS\n\n  /** Handles when a touch first interacts with the screen */\n  abstract handleTouchDown(e: ITouchInteraction): void;\n  /** Handles when a touch is no longer interacting with the screen */\n  abstract handleTouchUp(e: ITouchInteraction): void;\n  /** Handles when an existing touch slides off of it's start view. */\n  abstract handleTouchOut(e: ITouchInteraction): void;\n  /**\n   * Handles when the system nukes your touch whether you like it or not. Some examples of when this 'might' happen:\n   * Hand gestures in iOS Safari that causes the window to be closed or open up multitasking in some fashion.\n   * Basically, more and more convenience gestures in the OS has more and more potential to kill your touches.\n   * So make sure you are using this.\n   */\n  abstract handleTouchCancelled(e: ITouchInteraction): void;\n\n  /** Handles when a touch is dragged across the screen */\n  abstract handleTouchDrag(e: ITouchInteraction): void;\n  /** Handles when a touch has tapped the screen quickly */\n  abstract handleTap(e: ITouchInteraction): void;\n  /** Handles when a touch double taps quickly on the screen */\n  abstract handleDoubleTap(e: ITouchInteraction): void;\n  /** Handles when a touch is left in a location for an extended period of time */\n  abstract handleLongTouch(e: ITouchInteraction): void;\n  /** Handles when a touch taps a location with a lengthy delay */\n  abstract handleLongTap(e: ITouchInteraction): void;\n  /** Handles when multiple touches converge toward each other */\n  abstract handlePinch(e: ITouchInteraction): void;\n  /** Handles when multiple touches spread away from each other */\n  abstract handleSpread(e: ITouchInteraction): void;\n  /** Handles when multiple touches rotate about a point */\n  abstract handleTouchRotate(e: ITouchInteraction): void;\n  /** Handles when a single touch or multiple touches swipe quickly in a direction */\n  abstract handleSwipe(e: ITouchInteraction): void;\n\n  /**\n   * This retrieves the projections for the view specified by the provided viewId.\n   */\n  getProjection(viewId: string): BaseProjection<any> | null {\n    const view = this.userInputManager.getView(viewId);\n    if (view) return view.projection;\n    return null;\n  }\n\n  /**\n   * This retrieves the actual view for the view specified by the provided viewId.\n   */\n  getView(viewId: string): View<IViewProps> | null {\n    return (\n      (this.userInputManager && this.userInputManager.getView(viewId)) || null\n    );\n  }\n\n  /**\n   * This retrieves the screen bounds for the view specified by the provided viewId.\n   */\n  getViewScreenBounds(viewId: string): Bounds<View<IViewProps>> | null {\n    const view = this.userInputManager.getView(viewId);\n\n    if (view) {\n      return view.screenBounds;\n    }\n\n    return null;\n  }\n\n  /**\n   * This is used internally which provides the parent MouseEventManager via the param mouseManager for this\n   * EventManager.\n   */\n  setUserInputManager(mouseManager: UserInputEventManager) {\n    this.userInputManager = mouseManager;\n  }\n\n  /**\n   * This is called by the surface so the manager can choose a moment in the\n   * render cycle when to perform certain actions.\n   */\n  willRender() {\n    // Default noop\n  }\n\n  /**\n   * This is called by the surface so the manager can choose a moment in the\n   * render cycle when to perform certain actions.\n   */\n  didRender() {\n    // Default noop\n  }\n}\n","import { IInstanceProvider, InstanceDiff, InstanceDiffType } from \"../types\";\nimport { uid } from \"../util/uid\";\nimport { Instance } from \"./instance\";\n\ntype InstanceDisposer<T extends Instance> = [T, Function];\n\n/**\n * This is an optimized provider, that can provide instances that use the internal observable system\n * to deliver updates to the framework.\n */\nexport class InstanceProvider<T extends Instance>\n  implements IInstanceProvider<T> {\n  /** A uid provided to this object to give it some easy to identify uniqueness */\n  get uid() {\n    return this._uid;\n  }\n  private _uid: number = uid();\n  /** Stores the disposers that are called when the instance is no longer listened to */\n  private cleanObservation = new Map<number, InstanceDisposer<T>>();\n  /** This stores the changes to the instances themselves */\n  private instanceChanges = new Map<number, InstanceDiff<T>>();\n  /** This flag is true when resolving changes when the change list is retrieved. it blocks changes until the current list is resolved */\n  private allowChanges = true;\n  /**\n   * This indicates the context this provider was handled within. Currently, only one context is allowed per provider,\n   * so we use this to detect when multiple contexts have attempted use of this provider.\n   */\n  resolveContext: string = \"\";\n\n  constructor(instances?: T[]) {\n    if (instances) {\n      for (let i = 0, iMax = instances.length; i < iMax; ++i) {\n        const instance = instances[i];\n        this.add(instance);\n      }\n    }\n  }\n\n  /**\n   * Retrieve all of the changes applied to instances\n   */\n  get changeList(): InstanceDiff<T>[] {\n    this.allowChanges = false;\n    const changes: InstanceDiff<T>[] = [];\n    this.instanceChanges.forEach(val => changes.push(val));\n\n    return changes;\n  }\n\n  /**\n   * Adds an instance to the provider which will stream observable changes of the instance to\n   * the framework.\n   */\n  add(instance: T) {\n    // No need to duplicate the addition\n    if (this.cleanObservation.get(instance.uid)) {\n      return instance;\n    }\n\n    if (this.allowChanges) {\n      instance.observer = this;\n      const disposer: Function = instance.observableDisposer;\n      // Store the disposers so we can clean up the observable properties\n      this.cleanObservation.set(instance.uid, [instance, disposer]);\n      // Indicate we have a new instance\n      this.instanceChanges.set(instance.uid, [\n        instance,\n        InstanceDiffType.INSERT,\n        instance.changes\n      ]);\n    }\n\n    return instance;\n  }\n\n  /**\n   * Removes all instances from this provider\n   */\n  clear() {\n    this.cleanObservation.forEach(values => {\n      this.remove(values[0]);\n    });\n  }\n\n  /**\n   * Clear all resources held by this provider. It IS valid to lose reference to all instances\n   * and to this object, which would effectively cause this object to get GC'ed. But if you\n   * desire to hang onto the instance objects, then this should be called.\n   */\n  destroy() {\n    this.cleanObservation.forEach(values => {\n      values[1]();\n    });\n\n    this.cleanObservation.clear();\n    this.instanceChanges.clear();\n  }\n\n  /**\n   * This is called from observables to indicate it's parent has been updated.\n   * This is what an instance calls when it's observable property is modified.\n   */\n  instanceUpdated(instance: T) {\n    if (this.allowChanges) {\n      // Flag the instance as having a property changed\n      this.instanceChanges.set(instance.uid, [\n        instance,\n        InstanceDiffType.CHANGE,\n        instance.changes\n      ]);\n    }\n  }\n\n  /**\n   * Stops the instance's ability to register changes with this provider and flags\n   * a final removal diff change.\n   */\n  remove(instance: T) {\n    if (this.allowChanges) {\n      const disposer = this.cleanObservation.get(instance.uid);\n\n      if (disposer) {\n        disposer[1]();\n        this.cleanObservation.delete(instance.uid);\n        this.instanceChanges.set(instance.uid, [\n          instance,\n          InstanceDiffType.REMOVE,\n          {}\n        ]);\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Flagged all changes as dealt with\n   */\n  resolve(context: string) {\n    this.allowChanges = true;\n    this.instanceChanges.clear();\n\n    if (this.resolveContext && this.resolveContext !== context) {\n      throw new Error(\n        \"An instance provider has been issued to two layers. This is not a suppported feature yet and can cause issues.\"\n      );\n    }\n\n    this.resolveContext = context;\n  }\n\n  /**\n   * This performs an operation that forces all of the instances to be flagged as an\n   * 'add' change. This allows a layer listening to this provider to ensure it has added\n   * all currently existing instances monitored by the provider.\n   *\n   * NOTE: This is a VERY poor performing method and should probably be used by the framework\n   * and not manually.\n   */\n  sync() {\n    const emptyPropertyChanges: number[] = [];\n\n    // Loop through all registered instances (which is only stored in the disposer list kept by this provider)\n    this.cleanObservation.forEach(disposer => {\n      const [instance] = disposer;\n      // Flag the instance as having a property changed\n      this.instanceChanges.set(instance.uid, [\n        instance,\n        InstanceDiffType.INSERT,\n        emptyPropertyChanges\n      ]);\n    });\n  }\n}\n","import {\n  apply2,\n  apply3,\n  apply4,\n  Vec2,\n  Vec2Compat,\n  Vec3,\n  Vec3Compat,\n  Vec4\n} from \"./vector\";\n\nconst { cos, sin, tan } = Math;\nconst PI_2 = Math.PI / 2;\n\n// prettier-ignore\nexport type Mat2x2 = [\n  number, number,\n  number, number\n];\n\n// prettier-ignore\nexport type Mat3x3 = [\n  number, number, number,\n  number, number, number,\n  number, number, number\n];\n\n// prettier-ignore\nexport type Mat4x4 = [\n  number, number, number, number,\n  number, number, number, number,\n  number, number, number, number,\n  number, number, number, number\n];\n\n/** Mat2x2 row column index for convenience M2<row><column> or M2<Y><X> */\nexport const M200 = 0;\n/** Mat2x2 row column index for convenience M2<row><column> or M2<Y><X> */\nexport const M201 = 1;\n/** Mat2x2 row column index for convenience M2<row><column> or M2<Y><X> */\nexport const M210 = 2;\n/** Mat2x2 row column index for convenience M2<row><column> or M2<Y><X> */\nexport const M211 = 3;\n\n/** Mat3x3 row column index for convenience M3<row><column> or M3<Y><X> */\nexport const M300 = 0;\n/** Mat3x3 row column index for convenience M3<row><column> or M3<Y><X> */\nexport const M301 = 1;\n/** Mat3x3 row column index for convenience M3<row><column> or M3<Y><X> */\nexport const M302 = 2;\n/** Mat3x3 row column index for convenience M3<row><column> or M3<Y><X> */\nexport const M310 = 3;\n/** Mat3x3 row column index for convenience M3<row><column> or M3<Y><X> */\nexport const M311 = 4;\n/** Mat3x3 row column index for convenience M3<row><column> or M3<Y><X> */\nexport const M312 = 5;\n/** Mat3x3 row column index for convenience M3<row><column> or M3<Y><X> */\nexport const M320 = 6;\n/** Mat3x3 row column index for convenience M3<row><column> or M3<Y><X> */\nexport const M321 = 7;\n/** Mat3x3 row column index for convenience M3<row><column> or M3<Y><X> */\nexport const M322 = 8;\n\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M400 = 0;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M401 = 1;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M402 = 2;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M403 = 3;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M410 = 4;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M411 = 5;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M412 = 6;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M413 = 7;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M420 = 8;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M421 = 9;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M422 = 10;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M423 = 11;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M430 = 12;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M431 = 13;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M432 = 14;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M433 = 15;\n\n/**\n * Temp Matrix 3x3 registers. Can be used for intermediate operations. These\n * are EXTREMELY temporary and volatile for use. Use with EXTREME caution and\n * don't expect them to retain any exepcted value.\n *\n * These are here more for\n * nesting operations and providing the nested operation something to use so it\n * doesn't need to allocate memory to operate.\n *\n * If you use too many registers, you can get weird behavior as some operations\n * may use some registers as well.\n *\n * Again, this is EXTREMELY advanced useage and should NOT be your first\n * inclination to utilize.\n */\nexport const M3R: Mat3x3[] = new Array(20).fill(0).map(_ => identity3());\n\n/**\n * Temp Matrix 4x4 registers. Can be used for intermediate operations. These\n * are EXTREMELY temporary and volatile for use. Use with EXTREME caution and\n * don't expect them to retain any exepcted value.\n *\n * These are here more for\n * nesting operations and providing the nested operation something to use so it\n * doesn't need to allocate memory to operate.\n *\n * If you use too many registers, you can get weird behavior as some operations\n * may use some registers as well.\n *\n * Again, this is EXTREMELY advanced useage and should NOT be your first\n * inclination to utilize.\n */\nexport const M4R: Mat4x4[] = new Array(20).fill(0).map(_ => identity4());\n\n/**\n * It's often much faster to apply values to an existing matrix than to declare\n * a new matrix inline. But it can be annoying and bulky to write the complete\n * array to value sequence to perform such an application. Thus, this method\n * exists to make the process a little more bearable.\n */\nexport function apply2x2(\n  m: Mat2x2 | undefined,\n  m00: number,\n  m01: number,\n  m10: number,\n  m11: number\n) {\n  m = m || ((new Array(4) as any) as Mat2x2);\n  m[0] = m00;\n  m[1] = m01;\n  m[2] = m10;\n  m[3] = m11;\n\n  return m;\n}\n\n/**\n * It's often much faster to apply values to an existing matrix than to declare\n * a new matrix inline. But it can be annoying and bulky to write the complete\n * array to value sequence to perform such an application. Thus, this method\n * exists to make the process a little more bearable.\n */\nexport function apply3x3(\n  m: Mat3x3 | undefined,\n  m00: number,\n  m01: number,\n  m02: number,\n  m10: number,\n  m11: number,\n  m12: number,\n  m20: number,\n  m21: number,\n  m22: number\n) {\n  m = m || ((new Array(9) as any) as Mat3x3);\n  m[0] = m00;\n  m[1] = m01;\n  m[2] = m02;\n  m[3] = m10;\n  m[4] = m11;\n  m[5] = m12;\n  m[6] = m20;\n  m[7] = m21;\n  m[8] = m22;\n\n  return m;\n}\n\n/**\n * It's often much faster to apply values to an existing matrix than to declare\n * a new matrix inline. But it can be annoying and bulky to write the complete\n * array to value sequence to perform such an application. Thus, this method\n * exists to make the process a little more bearable.\n */\nexport function apply4x4(\n  m: Mat4x4 | undefined,\n  m00: number,\n  m01: number,\n  m02: number,\n  m03: number,\n  m10: number,\n  m11: number,\n  m12: number,\n  m13: number,\n  m20: number,\n  m21: number,\n  m22: number,\n  m23: number,\n  m30: number,\n  m31: number,\n  m32: number,\n  m33: number\n) {\n  m = m || ((new Array(16) as any) as Mat4x4);\n\n  m[0] = m00;\n  m[1] = m01;\n  m[2] = m02;\n  m[3] = m03;\n\n  m[4] = m10;\n  m[5] = m11;\n  m[6] = m12;\n  m[7] = m13;\n\n  m[8] = m20;\n  m[9] = m21;\n  m[10] = m22;\n  m[11] = m23;\n\n  m[12] = m30;\n  m[13] = m31;\n  m[14] = m32;\n  m[15] = m33;\n\n  return m;\n}\n\n/**\n * In many of these methods, there are moments that temporary matrices are\n * needed to store some results. Rather than allot and consume memory for temp\n * matrices and degrade performance, these will provide some containers to work\n * with. The values in these containers should never be assumed upon entry of a\n * method, nor shall these be used to make two methods operate together.\n */\n\nconst TEMP_M30 = identity3();\nconst TEMP_M31 = identity3();\nconst TEMP_M32 = identity3();\nconst TEMP_M33 = identity3();\n\n/**\n * Determinant value of a 2x2 matrix\n *\n * 3 OPS\n */\nexport function determinant2x2(mat: Mat2x2): number {\n  return mat[3] * mat[0] - mat[1] * mat[2];\n}\n\n/**\n * Determinant value of a 3x3 matrix\n *\n * 17 OPS\n */\nexport function determinant3x3(mat: Mat3x3): number {\n  return (\n    mat[0] * mat[4] * mat[8] -\n    mat[0] * mat[5] * mat[7] +\n    mat[1] * mat[5] * mat[6] -\n    mat[1] * mat[3] * mat[8] +\n    mat[2] * mat[3] * mat[7] -\n    mat[2] * mat[4] * mat[6]\n  );\n}\n\n/**\n * Determinant value of a 4x4 matrix\n *\n * 75 OPS, 4 temp Mat3x3, 8 method calls\n */\nexport function determinant4x4(mat: Mat4x4): number {\n  // prettier-ignore\n  apply3x3(TEMP_M30,\n     mat[5],  mat[6],  mat[7],\n     mat[9], mat[10], mat[11],\n    mat[13], mat[14], mat[15]\n  );\n\n  // prettier-ignore\n  apply3x3(TEMP_M31,\n     mat[4],  mat[6],  mat[7],\n     mat[8], mat[10], mat[11],\n    mat[12], mat[14], mat[15]\n  );\n\n  // prettier-ignore\n  apply3x3(TEMP_M32,\n     mat[4],  mat[5],  mat[7],\n     mat[8],  mat[9], mat[11],\n    mat[12], mat[13], mat[15]\n  );\n\n  // prettier-ignore\n  apply3x3(TEMP_M32,\n     mat[4],  mat[5],  mat[6],\n     mat[8],  mat[9], mat[10],\n    mat[12], mat[13], mat[14]\n  );\n\n  return (\n    mat[0] * determinant3x3(TEMP_M30) -\n    mat[1] * determinant3x3(TEMP_M31) +\n    mat[2] * determinant3x3(TEMP_M32) -\n    mat[3] * determinant3x3(TEMP_M33)\n  );\n}\n\n/**\n * Calculates the inverse of ONLY purely affine transforms. A general inverse is\n * considered too computationally expensive and alternative strategies should be\n * considered.\n *\n * 9 OPS, 1 method call\n */\nexport function affineInverse2x2(mat: Mat2x2, out?: Mat2x2): Mat2x2 | null {\n  const determinant = determinant2x2(mat);\n  if (determinant === 0) return null;\n\n  // prettier-ignore\n  return apply2x2(out,\n     mat[3] / determinant, -mat[1] / determinant,\n    -mat[2] / determinant,  mat[0] / determinant\n  );\n}\n\n/**\n * Calculates the inverse of ONLY purely affine transforms. A general inverse is\n * considered too computationally expensive and alternative strategies should be\n * considered.\n *\n * 56 OPS, 10 method calls\n */\nexport function affineInverse3x3(mat: Mat3x3, out?: Mat3x3): Mat3x3 | null {\n  // 17 OPS\n  const determiant = determinant3x3(mat);\n  if (determiant === 0) return null;\n\n  // 27 OPS 9 method calls\n  const m0 = determinant2x2([mat[4], mat[5], mat[7], mat[8]]);\n  const m1 = determinant2x2([mat[3], mat[5], mat[6], mat[8]]);\n  const m2 = determinant2x2([mat[3], mat[4], mat[6], mat[7]]);\n  const m3 = determinant2x2([mat[1], mat[2], mat[7], mat[8]]);\n  const m4 = determinant2x2([mat[0], mat[2], mat[6], mat[8]]);\n  const m5 = determinant2x2([mat[0], mat[1], mat[6], mat[7]]);\n  const m6 = determinant2x2([mat[1], mat[2], mat[4], mat[5]]);\n  const m7 = determinant2x2([mat[0], mat[2], mat[3], mat[5]]);\n  const m8 = determinant2x2([mat[0], mat[1], mat[3], mat[4]]);\n\n  // prettier-ignore\n  return apply3x3(out,\n     m0 / determiant, -m3 / determiant, m6 / determiant,\n    -m1 / determiant,  m4 / determiant, m7 / determiant,\n     m2 / determiant, -m5 / determiant, m8 / determiant\n  );\n}\n\n/**\n * Calculates the inverse of ONLY purely affine transforms. A general inverse is\n * considered too computationally expensive and alternative strategies should be\n * considered.\n *\n * 164 OPS + 3 temp 3x3 uses + 13 method calls\n */\nexport function affineInverse4x4(mat: Mat4x4, out?: Mat4x4): Mat4x4 | null {\n  const determiant = determinant4x4(mat);\n  if (determiant === 0) return null;\n\n  const s0 = determinant2x2([mat[0], mat[1], mat[4], mat[5]]);\n  const s1 = determinant2x2([mat[0], mat[2], mat[4], mat[6]]);\n  const s2 = determinant2x2([mat[0], mat[3], mat[4], mat[7]]);\n  const s3 = determinant2x2([mat[1], mat[2], mat[5], mat[6]]);\n  const s4 = determinant2x2([mat[1], mat[3], mat[5], mat[7]]);\n  const s5 = determinant2x2([mat[2], mat[3], mat[6], mat[7]]);\n\n  const c5 = determinant2x2([mat[10], mat[11], mat[14], mat[15]]);\n  const c4 = determinant2x2([mat[9], mat[11], mat[13], mat[15]]);\n  const c3 = determinant2x2([mat[9], mat[10], mat[13], mat[14]]);\n  const c2 = determinant2x2([mat[8], mat[11], mat[12], mat[15]]);\n  const c1 = determinant2x2([mat[8], mat[10], mat[12], mat[14]]);\n  const c0 = determinant2x2([mat[8], mat[9], mat[12], mat[13]]);\n\n  // prettier-ignore\n  return apply4x4(out,\n    //                                                     |                                                        |                                                           |\n     (mat[5] * c5 - mat[6] * c4 + mat[7] * c3) / determiant, (-mat[1] * c5 + mat[2] * c4 - mat[3] * c3) / determiant,  (mat[12] * s5 - mat[13] * s4 + mat[14] * s3) / determiant, (-mat[9] * s5 + mat[10] * s4 - mat[11] * s3) / determiant,\n    (-mat[4] * c5 + mat[6] * c2 - mat[7] * c1) / determiant,  (mat[0] * c5 - mat[2] * c2 + mat[3] * c1) / determiant, (-mat[12] * s5 + mat[14] * s2 - mat[15] * s1) / determiant,  (mat[8] * s5 - mat[10] * s2 + mat[11] * s1) / determiant,\n     (mat[4] * c4 - mat[5] * c2 + mat[7] * c0) / determiant, (-mat[0] * c4 + mat[1] * c2 - mat[3] * c0) / determiant,  (mat[12] * s4 - mat[13] * s2 + mat[15] * s0) / determiant,  (-mat[8] * s4 + mat[9] * s2 - mat[11] * s0) / determiant,\n    (-mat[4] * c3 + mat[5] * c1 - mat[6] * c0) / determiant,  (mat[0] * c3 - mat[1] * c1 + mat[2] * c0) / determiant, (-mat[12] * s3 + mat[13] * s1 - mat[14] * s0) / determiant,   (mat[8] * s3 - mat[9] * s1 + mat[10] * s0) / determiant\n  );\n}\n\n/**\n * 4 OPS\n */\nexport function multiplyScalar2x2(\n  mat: Mat2x2,\n  scale: number,\n  out?: Mat2x2\n): Mat2x2 {\n  // prettier-ignore\n  return apply2x2(out,\n    mat[0] * scale, mat[1] * scale,\n    mat[2] * scale, mat[3] * scale\n  );\n}\n\n/**\n * 9 OPS\n */\nexport function multiplyScalar3x3(\n  mat: Mat3x3,\n  scale: number,\n  out?: Mat3x3\n): Mat3x3 {\n  // prettier-ignore\n  return apply3x3(out,\n    mat[0] * scale, mat[1] * scale, mat[2] * scale,\n    mat[3] * scale, mat[4] * scale, mat[5] * scale,\n    mat[6] * scale, mat[7] * scale, mat[8] * scale\n  );\n}\n\n/**\n * 16 OPS\n */\nexport function multiplyScalar4x4(\n  mat: Mat4x4,\n  scale: number,\n  out?: Mat4x4\n): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n     mat[0] * scale,  mat[1] * scale,  mat[2] * scale,  mat[3] * scale,\n     mat[4] * scale,  mat[5] * scale,  mat[6] * scale,  mat[7] * scale,\n     mat[8] * scale,  mat[9] * scale, mat[10] * scale, mat[11] * scale,\n    mat[12] * scale, mat[13] * scale, mat[14] * scale, mat[15] * scale\n  );\n}\n\n/**\n * Convert or produce a 2x2 identity matrix\n */\nexport function identity2(out?: Mat2x2): Mat2x2 {\n  // prettier-ignore\n  return apply2x2(out,\n    1, 0,\n    0, 1\n  );\n}\n\n/**\n * Convert or produce a 3x3 identity matrix\n */\nexport function identity3(out?: Mat3x3): Mat3x3 {\n  // prettier-ignore\n  return apply3x3(out,\n    1, 0, 0,\n    0, 1, 0,\n    0, 0, 1\n  );\n}\n\n/**\n * Convert or produce a 4x4 identity matrix\n */\nexport function identity4(out?: Mat4x4): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  );\n}\n\n/**\n * Concat two 2x2 matrices. T = left x right\n * 12 OPS\n */\nexport function multiply2x2(left: Mat2x2, right: Mat2x2, out?: Mat2x2): Mat2x2 {\n  // prettier-ignore\n  return apply2x2(out,\n    right[M200] * left[M200] + right[M201] * left[M210], right[M200] * left[M201] + right[M201] * left[M211],\n    right[M210] * left[M200] + right[M211] * left[M210], right[M210] * left[M201] + right[M211] * left[M211],\n  );\n}\n\n/**\n * Concat two 3x3 matrices. T = left x right\n * 45 OPS\n */\nexport function multiply3x3(left: Mat3x3, right: Mat3x3, out?: Mat3x3): Mat3x3 {\n  // prettier-ignore\n  return apply3x3(out,\n    right[0] * left[0] + right[1] * left[3] + right[2] * left[6], right[0] * left[1] + right[1] * left[4] + right[2] * left[7], right[0] * left[2] + right[1] * left[5] + right[2] * left[8],\n    right[3] * left[0] + right[4] * left[3] + right[5] * left[6], right[3] * left[1] + right[4] * left[4] + right[5] * left[7], right[3] * left[2] + right[4] * left[5] + right[5] * left[8],\n    right[6] * left[0] + right[7] * left[3] + right[8] * left[6], right[6] * left[1] + right[7] * left[4] + right[8] * left[7], right[6] * left[2] + right[7] * left[5] + right[8] * left[8]\n  );\n}\n\n/**\n * Concat two 4x4 matrices. T = left x right\n * 112 OPS\n */\nexport function multiply4x4(left: Mat4x4, right: Mat4x4, out?: Mat4x4): Mat4x4 {\n  // prettier-ignore\n  out = out || ([] as any as Mat4x4);\n  out[0] =\n    right[0] * left[0] +\n    right[1] * left[4] +\n    right[2] * left[8] +\n    right[3] * left[12];\n  out[1] =\n    right[0] * left[1] +\n    right[1] * left[5] +\n    right[2] * left[9] +\n    right[3] * left[13];\n  out[2] =\n    right[0] * left[2] +\n    right[1] * left[6] +\n    right[2] * left[10] +\n    right[3] * left[14];\n  out[3] =\n    right[0] * left[3] +\n    right[1] * left[7] +\n    right[2] * left[11] +\n    right[3] * left[15];\n\n  out[4] =\n    right[4] * left[0] +\n    right[5] * left[4] +\n    right[6] * left[8] +\n    right[7] * left[12];\n  out[5] =\n    right[4] * left[1] +\n    right[5] * left[5] +\n    right[6] * left[9] +\n    right[7] * left[13];\n  out[6] =\n    right[4] * left[2] +\n    right[5] * left[6] +\n    right[6] * left[10] +\n    right[7] * left[14];\n  out[7] =\n    right[4] * left[3] +\n    right[5] * left[7] +\n    right[6] * left[11] +\n    right[7] * left[15];\n\n  out[8] =\n    right[8] * left[0] +\n    right[9] * left[4] +\n    right[10] * left[8] +\n    right[11] * left[12];\n  out[9] =\n    right[8] * left[1] +\n    right[9] * left[5] +\n    right[10] * left[9] +\n    right[11] * left[13];\n  out[10] =\n    right[8] * left[2] +\n    right[9] * left[6] +\n    right[10] * left[10] +\n    right[11] * left[14];\n  out[11] =\n    right[8] * left[3] +\n    right[9] * left[7] +\n    right[10] * left[11] +\n    right[11] * left[15];\n\n  out[12] =\n    right[12] * left[0] +\n    right[13] * left[4] +\n    right[14] * left[8] +\n    right[15] * left[12];\n  out[13] =\n    right[12] * left[1] +\n    right[13] * left[5] +\n    right[14] * left[9] +\n    right[15] * left[13];\n  out[14] =\n    right[12] * left[2] +\n    right[13] * left[6] +\n    right[14] * left[10] +\n    right[15] * left[14];\n  out[15] =\n    right[12] * left[3] +\n    right[13] * left[7] +\n    right[14] * left[11] +\n    right[15] * left[15];\n\n  return out;\n}\n\n/**\n * Concat a list of matrices in this order:\n * concat4x4(A, B, C, D, E, ..., N);\n * T = A * B * C * E * ... * N\n */\nexport function concat4x4(out?: Mat4x4, ...m: Mat4x4[]): Mat4x4 {\n  if (m.length <= 0) return identity4();\n  out = out || identity4();\n  if (m.length === 1) return copy4x4(m[0], out);\n\n  // Get the first multiplication value for the left hand side of the operation\n  let l = m[0];\n  // We use a register to reduce allocations and overhead\n  let register1 = M4R[M4R.length - 1];\n  let register2 = M4R[M4R.length - 2];\n  // Make sure our output doesn't clash with one of the registeres\n  if (out === register1) register1 = M4R[M4R.length - 3];\n  if (out === register2) register2 = M4R[M4R.length - 3];\n  let register = register1;\n\n  for (let i = 1, iMax = m.length - 1; i < iMax; ++i) {\n    // Each new matrix will be the right hand side of the operation\n    const r = m[i];\n    // Do the multiplication storing the result into a register\n    l = multiply4x4(l, r, register);\n    // Toggle to a new register for the next operation so we don't output into\n    // an input\n    register = register === register1 ? register2 : register1;\n  }\n\n  // Do the final operation with the last matrix, but this time store in our\n  // output value.\n  return multiply4x4(l, m[m.length - 1], out);\n}\n\n/**\n * Add each element by each element in two matrices\n * 4 OPS\n */\nexport function add2x2(left: Mat2x2, right: Mat2x2, out?: Mat2x2): Mat2x2 {\n  // prettier-ignore\n  return apply2x2(out,\n    left[0] + right[0], left[1] + right[1],\n    left[2] + right[2], left[3] + right[3]\n  );\n}\n\n/**\n * Add each element by each element in two matrices\n * 9 OPS\n */\nexport function add3x3(left: Mat3x3, right: Mat3x3, out?: Mat3x3): Mat3x3 {\n  // prettier-ignore\n  return apply3x3(out,\n    left[0] + right[0], left[1] + right[1], left[2] + right[2],\n    left[3] + right[3], left[4] + right[4], left[5] + right[5],\n    left[6] + right[6], left[7] + right[7], left[8] + right[8]\n  );\n}\n\n/**\n * Add each element by each element in two matrices\n * 16 OPS\n */\nexport function add4x4(left: Mat4x4, right: Mat4x4, out?: Mat4x4): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n      left[0] + right[0],   left[1] + right[1],   left[2] + right[2],   left[3] + right[3],\n      left[4] + right[4],   left[5] + right[5],   left[6] + right[6],   left[7] + right[7],\n      left[8] + right[8],   left[9] + right[9], left[10] + right[10], left[11] + right[11],\n    left[12] + right[12], left[13] + right[13], left[14] + right[14], left[15] + right[15]\n  );\n}\n\n/**\n * Subtract each element by each element in two matrices\n * 4 OPS\n */\nexport function subtract2x2(left: Mat2x2, right: Mat2x2, out?: Mat2x2): Mat2x2 {\n  // prettier-ignore\n  return apply2x2(out,\n    left[0] - right[0], left[1] - right[1],\n    left[2] - right[2], left[3] - right[3]\n  );\n}\n\n/**\n * Subtract each element by each element in two matrices\n * 9 OPS\n */\nexport function subtract3x3(left: Mat3x3, right: Mat3x3, out?: Mat3x3): Mat3x3 {\n  // prettier-ignore\n  return apply3x3(out,\n    left[0] - right[0], left[1] - right[1], left[2] - right[2],\n    left[3] - right[3], left[4] - right[4], left[5] - right[5],\n    left[6] - right[6], left[7] - right[7], left[8] - right[8]\n  );\n}\n\n/**\n * Subtract each element by each element in two matrices\n * 16 OPS\n */\nexport function subtract4x4(left: Mat4x4, right: Mat4x4, out?: Mat4x4): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n      left[0] - right[0],   left[1] - right[1],   left[2] - right[2],   left[3] - right[3],\n      left[4] - right[4],   left[5] - right[5],   left[6] - right[6],   left[7] - right[7],\n      left[8] - right[8],   left[9] - right[9], left[10] - right[10], left[11] - right[11],\n    left[12] - right[12], left[13] - right[13], left[14] - right[14], left[15] - right[15]\n  );\n}\n\n/**\n * Hadamard product of two matrices. This is essentially multiplying each\n * element by each element between the two. 4 OPS\n */\nexport function Hadamard2x2(left: Mat2x2, right: Mat2x2, out?: Mat2x2): Mat2x2 {\n  // prettier-ignore\n  return apply2x2(out,\n    left[0] * right[0], left[1] * right[1],\n    left[2] * right[2], left[3] * right[3]\n  );\n}\n\n/**\n * Hadamard product of two matrices. This is essentially multiplying each\n * element by each element between the two. 9 OPS\n */\nexport function Hadamard3x3(left: Mat3x3, right: Mat3x3, out?: Mat3x3): Mat3x3 {\n  // prettier-ignore\n  return apply3x3(out,\n    left[0] * right[0], left[1] * right[1], left[2] * right[2],\n    left[3] * right[3], left[4] * right[4], left[5] * right[5],\n    left[6] * right[6], left[7] * right[7], left[8] * right[8]\n  );\n}\n\n/**\n * Hadamard product of two matrices. This is essentially multiplying each\n * element by each element between the two. 16 OPS\n */\nexport function Hadamard4x4(left: Mat4x4, right: Mat4x4, out?: Mat4x4): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n      left[0] * right[0],   left[1] * right[1],   left[2] * right[2],   left[3] * right[3],\n      left[4] * right[4],   left[5] * right[5],   left[6] * right[6],   left[7] * right[7],\n      left[8] * right[8],   left[9] * right[9], left[10] * right[10], left[11] * right[11],\n    left[12] * right[12], left[13] * right[13], left[14] * right[14], left[15] * right[15]\n  );\n}\n\n/**\n * Transposes a 2x2 matrix:\n * [a, b] -> [a, c]\n * [c, d]    [b, d]\n */\nexport function transpose2x2(mat: Mat2x2, out?: Mat2x2): Mat2x2 {\n  // prettier-ignore\n  return apply2x2(out,\n    mat[0], mat[2],\n    mat[1], mat[3]\n  );\n}\n\n/**\n * Transposes a 3x3 matrix:\n * [a, b, c] -> [a, d, g]\n * [d, e, f]    [b, e, h]\n * [g, h, i]    [c, f, i]\n */\nexport function transpose3x3(mat: Mat3x3, out?: Mat3x3): Mat3x3 {\n  // prettier-ignore\n  return apply3x3(out,\n    mat[0], mat[3], mat[6],\n    mat[1], mat[4], mat[7],\n    mat[2], mat[5], mat[8]\n  );\n}\n\n/**\n * Transposes a 4x4 matrix:\n * [a, b, c, d] -> [a, e, i, m]\n * [e, f, g, h]    [b, f, j, n]\n * [i, j, k, l]    [c, g, k, o]\n * [m, n, o, p]    [d, h, l, p]\n */\nexport function transpose4x4(mat: Mat4x4, out?: Mat4x4): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n    mat[0], mat[4], mat[8],  mat[12],\n    mat[1], mat[5], mat[9],  mat[13],\n    mat[2], mat[6], mat[10], mat[14],\n    mat[3], mat[7], mat[11], mat[15]\n  );\n}\n\n/**\n * This makes a shear 2d matrix that shears parallel to the x-axis. The radians\n * should be input as a value between, non inclusive (-90 degrees, 90 degrees).\n * A shear >= 90 degrees is non-sensical as it would shear to infinity and\n * beyond.\n */\nexport function shearX2x2(radians: number, out?: Mat2x2): Mat2x2 {\n  if (radians >= Math.PI / 2 || radians <= -Math.PI / 2) {\n    console.warn(\"A shear matrix can not have radians >= PI / 2 or <= -PI / 2\");\n  }\n\n  out = out || identity2();\n\n  // prettier-ignore\n  return apply2x2(out,\n    1, 0,\n    tan(radians), 1\n  );\n}\n\n/**\n * This makes a shear 2d matrix that shears parallel to the y-axis. The radians\n * should be input as a value between, non inclusive (-90 degrees, 90 degrees).\n * A shear >= 90 degrees is non-sensical as it would shear to infinity and\n * beyond.\n */\nexport function shearY2x2(radians: number, out?: Mat2x2): Mat2x2 {\n  if (radians >= Math.PI / 2 || radians <= -Math.PI / 2) {\n    console.warn(\"A shear matrix can not have radians >= PI / 2 or <= -PI / 2\");\n  }\n\n  out = out || identity2();\n\n  // prettier-ignore\n  return apply2x2(out,\n    1, tan(radians),\n    0, 1\n  );\n}\n\n/**\n * This makes a shear 3d matrix that shears parallel to the x-axis. The radians\n * should be input as a value between, non inclusive (-90 degrees, 90 degrees).\n * A shear >= 90 degrees is non-sensical as it would shear to infinity and\n * beyond.\n */\nexport function shearX4x4(\n  alongY: number,\n  alongZ: number,\n  out?: Mat4x4\n): Mat4x4 {\n  if (alongZ >= PI_2 || alongZ <= -PI_2 || alongY >= PI_2 || alongY <= -PI_2) {\n    console.warn(\"A shear matrix can not have radians >= PI / 2 or <= -PI / 2\");\n  }\n\n  out = out || identity4();\n  const shearZ = tan(alongZ);\n  const shearY = tan(alongY);\n\n  // prettier-ignore\n  return apply4x4(\n    out,\n    1, 0, 0, 0,\n    shearY, 1, 0, 0,\n    shearZ, 0, 1, 0,\n    0, 0, 0, 1\n  );\n}\n\n/**\n * This makes a shear 3d matrix that shears parallel to the y-axis. The radians\n * should be input as a value between, non inclusive (-90 degrees, 90 degrees).\n * A shear >= 90 degrees is non-sensical as it would shear to infinity and\n * beyond.\n */\nexport function shearY4x4(\n  alongX: number,\n  alongZ: number,\n  out?: Mat4x4\n): Mat4x4 {\n  if (alongZ >= PI_2 || alongZ <= -PI_2 || alongX >= PI_2 || alongX <= -PI_2) {\n    console.warn(\"A shear matrix can not have radians >= PI / 2 or <= -PI / 2\");\n  }\n\n  out = out || identity4();\n  const shearZ = tan(alongZ);\n  const shearX = tan(alongX);\n\n  // prettier-ignore\n  return apply4x4(\n    out,\n    1, shearX, 0, 0,\n    0, 1, 0, 0,\n    0, shearZ, 1, 0,\n    0, 0, 0, 1\n  );\n}\n\n/**\n * This makes a shear 3d matrix that shears parallel to the z-axis. The radians\n * should be input as a value between, non inclusive (-90 degrees, 90 degrees).\n * A shear >= 90 degrees is non-sensical as it would shear to infinity and\n * beyond.\n */\nexport function shearZ4x4(\n  alongX: number,\n  alongY: number,\n  out?: Mat4x4\n): Mat4x4 {\n  if (alongY >= PI_2 || alongY <= -PI_2 || alongX >= PI_2 || alongX <= -PI_2) {\n    console.warn(\"A shear matrix can not have radians >= PI / 2 or <= -PI / 2\");\n  }\n\n  out = out || identity4();\n  const shearY = tan(alongY);\n  const shearX = tan(alongX);\n\n  // prettier-ignore\n  return apply4x4(\n    out,\n    1, 0, shearX, 0,\n    0, 1, shearY, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  );\n}\n\n/**\n * Transforms a Vec2 by a matrix\n */\nexport function transform2(m: Mat2x2, v: Vec2, out?: Vec2): Vec2 {\n  return apply2(\n    out,\n    m[M200] * v[0] + m[M210] * v[1],\n    m[M201] * v[0] + m[M211] * v[1]\n  );\n}\n\n/**\n * Transforms a Vec3 by a matrix.\n */\nexport function transform3(m: Mat3x3, v: Vec3, out?: Vec3): Vec3 {\n  return apply3(\n    out,\n    m[M300] * v[0] + m[M310] * v[1] + m[M320] * v[2],\n    m[M301] * v[0] + m[M311] * v[1] + m[M321] * v[2],\n    m[M302] * v[0] + m[M312] * v[1] + m[M322] * v[2]\n  );\n}\n\n/**\n * Transforms a Vec3 by the provided matrix but treats the Vec3 as a\n * [x, y, z, 1] Vec4.\n */\nexport function transform3as4(m: Mat4x4, v: Vec3, out?: Vec4): Vec4 {\n  return apply4(\n    out,\n    m[M400] * v[0] + m[M410] * v[1] + m[M420] * v[2] + m[M430] * 1,\n    m[M401] * v[0] + m[M411] * v[1] + m[M421] * v[2] + m[M431] * 1,\n    m[M402] * v[0] + m[M412] * v[1] + m[M422] * v[2] + m[M432] * 1,\n    m[M403] * v[0] + m[M413] * v[1] + m[M423] * v[2] + m[M433] * 1\n  );\n}\n\n/**\n * Transforms a vector by the provided matrix\n */\nexport function transform4(m: Mat4x4, v: Vec4, out?: Vec4): Vec4 {\n  return apply4(\n    out,\n    m[M400] * v[0] + m[M410] * v[1] + m[M420] * v[2] + m[M430] * v[3],\n    m[M401] * v[0] + m[M411] * v[1] + m[M421] * v[2] + m[M431] * v[3],\n    m[M402] * v[0] + m[M412] * v[1] + m[M422] * v[2] + m[M432] * v[3],\n    m[M403] * v[0] + m[M413] * v[1] + m[M423] * v[2] + m[M433] * v[3]\n  );\n}\n\n/**\n * Converts a 2x2 to a pretty print string\n */\nexport function toString2x2(mat: Mat2x2): string {\n  // prettier-ignore\n  return `Matrix: [\n  ${mat[0]}, ${mat[1]},\n  ${mat[2]}, ${mat[3]},\n]`;\n}\n\n/**\n * Converts a 3x3 to a pretty print string\n */\nexport function toString3x3(mat: Mat3x3): string {\n  // prettier-ignore\n  return `Matrix: [\n  ${mat[0]}, ${mat[1]}, ${mat[2]},\n  ${mat[3]}, ${mat[4]}, ${mat[5]},\n  ${mat[6]}, ${mat[7]}, ${mat[8]},\n]`;\n}\n\n/**\n * Converts a 4x4 to a pretty print string\n */\nexport function toString4x4(mat: Mat4x4): string {\n  // prettier-ignore\n  return `Matrix: [\n  ${mat[0]}, ${mat[1]}, ${mat[2]}, ${mat[3]},\n  ${mat[4]}, ${mat[5]}, ${mat[6]}, ${mat[7]},\n  ${mat[8]}, ${mat[9]}, ${mat[10]}, ${mat[11]},\n  ${mat[12]}, ${mat[13]}, ${mat[14]}, ${mat[15]},\n]`;\n}\n\n/**\n * Makes a 2x2 rotation matrix based on a single rotational value. Good for\n * rotating 2 dimensional values with as little information and operations as\n * possible.\n */\nexport function rotation2x2(radians: number, out?: Mat2x2): Mat2x2 {\n  out = out || (new Array(4) as Mat2x2);\n  const c = Math.cos(radians);\n  const s = Math.sin(radians);\n\n  out[M200] = c;\n  out[M201] = -s;\n  out[M210] = s;\n  out[M211] = c;\n\n  return out;\n}\n\n/**\n * We only support Euler X then Y then Z rotations. Specify the rotation values\n * for each axis to receive a matrix that will perform rotations by that amount\n * in that order.\n *\n * All of these rotations follow the right hand rule. If you need a different\n * mixture of ordered rotations, then consider simply concatenating 3 rotations\n * like so (for a ZYZ example):\n *\n * multiply4x4(rotation4x4(0, 0, Z), multiply4x4(rotation4x4(0, Y, 0),\n *   rotation4x4(0, 0, Z),\n *   )\n * );\n *\n * This will create a ZYZ rotation (with the right handed rule). If you need the\n * operations to be left handed you will have to use the transpose and do a\n * little extra math to make it happen or hand craft your own method for\n * generating rotational matrices.\n */\nexport function rotation4x4(x: number, y: number, z: number, out?: Mat4x4) {\n  if (x) {\n    if (y) {\n      if (z) {\n        // x, y, z\n        const cx = cos(x);\n        const cy = cos(y);\n        const cz = cos(z);\n        const sx = sin(x);\n        const sy = sin(y);\n        const sz = sin(z);\n\n        // prettier-ignore\n        /*return apply4x4(out,\n          c1 * c2,  - c1 * s2, s1, 0,\n          s0 * s1 * c2 + c0 * s2, -s0 * s1 * s2 + c0 * c2, -s0 * c1, 0,\n          s0 * s2 - c0 * s1 * c2, s0 * c2 + c0 * s1 * s2, c0 * c1, 0,\n          0, 0, 0, 1\n        );*/\n        return apply4x4(out,\n          cy * cz, cy * sz, -sy, 0,\n          sx * sy * cz - cx * sz, sx * sy * sz + cx * cz, sx * cy, 0,\n          cx * sy * cz + sx * sz, cx * sy * sz - sx * cz, cx * cy, 0,\n          0, 0, 0, 1\n        );\n      } else {\n        // x, y\n        const cx = cos(x);\n        const cy = cos(y);\n        const sx = sin(x);\n        const sy = sin(y);\n\n        // prettier-ignore\n        return apply4x4(out,\n          cy, 0, -sy, 0,\n          sx * sy, cx, sx * cy, 0,\n          cx * sy, -sx, cx * cy, 0,\n          0, 0, 0, 1\n        );\n      }\n    } else {\n      if (z) {\n        // x, z\n        const cx = cos(x);\n        const cz = cos(z);\n        const sx = sin(x);\n        const sz = sin(z);\n\n        // prettier-ignore\n        return apply4x4(out,\n          cz, sz, 0, 0,\n          -cx * sz, cx * cz, sx, 0,\n          sx * sz, -sx * cz, cx, 0,\n          0, 0, 0, 1\n        );\n      } else {\n        // x\n        const cx = cos(x);\n        const sx = sin(x);\n\n        // prettier-ignore\n        return apply4x4(out,\n           1,  0,  0, 0,\n           0,  cx, sx, 0,\n           0,  -sx, cx, 0,\n           0,  0,  0,  1\n        );\n      }\n    }\n  } else {\n    if (y) {\n      if (z) {\n        // y, z\n        const cy = cos(y);\n        const cz = cos(z);\n        const sy = sin(y);\n        const sz = sin(z);\n\n        // prettier-ignore\n        return apply4x4(out,\n          cy * cz, cy * sz, -sy, 0,\n          -sz, cz, 0, 0,\n          sy * cz, sy * sz, cy, 0,\n          0, 0, 0, 1\n       );\n      } else {\n        // y\n        const cy = cos(y);\n        const sy = sin(y);\n\n        // prettier-ignore\n        return apply4x4(out,\n          cy, 0, -sy, 0,\n           0, 1,   0, 0,\n          sy, 0,  cy, 0,\n           0, 0,   0, 1\n        );\n      }\n    } else {\n      if (z) {\n        // z\n        const cz = cos(z);\n        const sz = sin(z);\n\n        // prettier-ignore\n        return apply4x4(out,\n          cz, sz, 0, 0,\n         -sz, cz, 0, 0,\n           0,  0, 1, 0,\n           0,  0, 0, 1\n        );\n      } else {\n        // no x, y, z\n        return identity4(out);\n      }\n    }\n  }\n}\n\n/**\n * We only support Euler X then Y then Z rotations. Specify the rotation values\n * for each axis to receive a matrix that will perform rotations by that amount\n * in that order.\n */\nexport function rotation4x4by3(v: Vec3, out?: Mat4x4) {\n  return rotation4x4(v[0], v[1], v[2], out);\n}\n\n/**\n * Creates a scaling matrix from a vector\n */\nexport function scale4x4by3(p: Vec3Compat, out?: Mat4x4): Mat4x4 {\n  return scale4x4(p[0], p[1], p[2], out);\n}\n\n/**\n * Creates a 4x4 scaling matrix\n */\nexport function scale4x4(\n  x: number,\n  y: number,\n  z: number,\n  out?: Mat4x4\n): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n    x, 0, 0, 0,\n    0, y, 0, 0,\n    0, 0, z, 0,\n    0, 0, 0, 1\n  );\n}\n\n/**\n * Creates a translation Matrix from a vector\n */\nexport function translation4x4by3(t: Vec3Compat, out?: Mat4x4): Mat4x4 {\n  return translation4x4(t[0], t[1], t[2], out);\n}\n\n/**\n * Creates a translation Matrix\n */\nexport function translation4x4(\n  x: number,\n  y: number,\n  z: number,\n  out?: Mat4x4\n): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    x, y, z, 1\n  );\n}\n\n/**\n * Produces a perspective matrix for a given frustum:\n * n: near,\n * f: far,\n * l: left,\n * r: right,\n * b: bottom,\n * t: top\n */\nexport function perspectiveFrustum4x4(\n  n: number,\n  f: number,\n  l: number,\n  r: number,\n  t: number,\n  b: number,\n  out?: Mat4x4\n) {\n  out = out || identity4();\n\n  // This is a column major matrix that should homogenize coordinates to within\n  // unit cube if the specified point is within the expressed frustum.\n  // prettier-ignore\n  return apply4x4(out,\n      2 * n / (r - l),                 0,                      0,  0,\n                    0,   2 * n / (t - b),                      0,  0,\n    (r + l) / (r - l), (t + b) / (t - b),     -(f + n) / (f - n), -1,\n                    0,                 0, -(2 * f * n) / (f - n),  0\n  );\n}\n\n/**\n * Generate a projection matrix with perspective.\n * The provided FOV is for the horizontal FOV.\n */\nexport function perspective4x4(\n  fovRadians: number,\n  width: number,\n  height: number,\n  near: number,\n  far: number,\n  out?: Mat4x4\n): Mat4x4 {\n  const aspect = height / width;\n  const r = tan(fovRadians / 2) * near;\n  const l = -r;\n  const t = aspect * r;\n  const b = -t;\n\n  return perspectiveFrustum4x4(near, far, l, r, t, b, out);\n}\n\n/**\n * Generate a projection matrix with perspective.\n * The provided FOV is for the vertical FOV.\n */\nexport function perspectiveFOVY4x4(\n  fovRadians: number,\n  width: number,\n  height: number,\n  near: number,\n  far: number,\n  out?: Mat4x4\n): Mat4x4 {\n  const aspect = width / height;\n  const t = tan(fovRadians / 2) * near;\n  const b = -t;\n  const r = aspect * t;\n  const l = -r;\n\n  return perspectiveFrustum4x4(near, far, l, r, t, b, out);\n}\n\n/**\n * Generate a projection matrix with no perspective. Useful for flat 2D or\n * isometric rendering or other similar special case renderings.\n */\nexport function orthographic4x4(\n  left: number,\n  right: number,\n  bottom: number,\n  top: number,\n  near: number,\n  far: number,\n  out?: Mat4x4\n): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n                 2 / (right - left),                               0,                    0, 0,\n                                  0,              2 / (top - bottom),                    0, 0,\n                                  0,                               0,    -1 / (far - near), 0,\n    (right + left) / (left - right), (top + bottom) / (bottom - top), -near / (near - far), 1\n  );\n}\n\n/**\n * Performs the operations to project a Vec4 to screen coordinates using a\n * projection matrix. The x and y of the out Vec4 will be the final projection,\n * w should be resolved to 1, and the z coordinate will be in homogenous\n * coordinates where -1 <= z <= 1 iff z lies within frustum near and far planes.\n */\nexport function projectToScreen(\n  proj: Mat4x4,\n  point: Vec4,\n  width: number,\n  height: number,\n  out?: Vec4\n): Vec4 {\n  out = out || [0, 0, 0, 0];\n  transform4(proj, point, out);\n\n  return apply4(\n    out,\n    (out[0] / out[3] + 1) * 0.5 * width,\n    (out[1] / out[3] + 1) * 0.5 * height,\n    out[2] / out[3],\n    1\n  );\n}\n\n/**\n * Performs the operations to project a Vec3 to screen coordinates as a Vec4\n * with a w of value 1. using a projection matrix. The x and y of the out Vec4\n * will be the final projection, w should be resolved to 1, and the z coordinate\n * will be in homogenous coordinates where -1 <= z <= 1 iff z lies within\n * frustum near and far planes.\n */\nexport function project3As4ToScreen(\n  proj: Mat4x4,\n  point: Vec3Compat,\n  width: number,\n  height: number,\n  out?: Vec4\n) {\n  return projectToScreen(\n    proj,\n    [point[0], point[1], point[2], 1],\n    width,\n    height,\n    out\n  );\n}\n\n/**\n * Determines equality of two 2x2 matrices\n */\nexport function compare2x2(m1: Mat2x2, m2: Mat2x2): boolean {\n  return (\n    Math.abs(m1[0] - m2[0]) <= 1e-7 &&\n    Math.abs(m1[1] - m2[1]) <= 1e-7 &&\n    Math.abs(m1[2] - m2[2]) <= 1e-7 &&\n    Math.abs(m1[3] - m2[3]) <= 1e-7\n  );\n}\n\n/**\n * Determines equality of two 3x3 matrices.\n */\nexport function compare3x3(m1: Mat3x3, m2: Mat3x3): boolean {\n  return (\n    Math.abs(m1[0] - m2[0]) <= 1e-7 &&\n    Math.abs(m1[1] - m2[1]) <= 1e-7 &&\n    Math.abs(m1[2] - m2[2]) <= 1e-7 &&\n    Math.abs(m1[3] - m2[3]) <= 1e-7 &&\n    Math.abs(m1[4] - m2[4]) <= 1e-7 &&\n    Math.abs(m1[5] - m2[5]) <= 1e-7 &&\n    Math.abs(m1[6] - m2[6]) <= 1e-7 &&\n    Math.abs(m1[7] - m2[7]) <= 1e-7 &&\n    Math.abs(m1[8] - m2[8]) <= 1e-7\n  );\n}\n\n/**\n * Determines equality of two 4x4 matrices.\n */\nexport function compare4x4(m1: Mat4x4, m2: Mat4x4): boolean {\n  return (\n    Math.abs(m1[0] - m2[0]) <= 1e-7 &&\n    Math.abs(m1[1] - m2[1]) <= 1e-7 &&\n    Math.abs(m1[2] - m2[2]) <= 1e-7 &&\n    Math.abs(m1[3] - m2[3]) <= 1e-7 &&\n    Math.abs(m1[4] - m2[4]) <= 1e-7 &&\n    Math.abs(m1[5] - m2[5]) <= 1e-7 &&\n    Math.abs(m1[6] - m2[6]) <= 1e-7 &&\n    Math.abs(m1[7] - m2[7]) <= 1e-7 &&\n    Math.abs(m1[8] - m2[8]) <= 1e-7 &&\n    Math.abs(m1[9] - m2[9]) <= 1e-7 &&\n    Math.abs(m1[10] - m2[10]) <= 1e-7 &&\n    Math.abs(m1[11] - m2[11]) <= 1e-7 &&\n    Math.abs(m1[12] - m2[12]) <= 1e-7 &&\n    Math.abs(m1[13] - m2[13]) <= 1e-7 &&\n    Math.abs(m1[14] - m2[14]) <= 1e-7 &&\n    Math.abs(m1[15] - m2[15]) <= 1e-7\n  );\n}\n\n/**\n * Copies a Mat2x2 into a new storage object\n */\nexport function copy2x2(m: Mat2x2): Mat2x2 {\n  return [m[0], m[1], m[2], m[3]];\n}\n\n/**\n * Copies a Mat3x3 into a new storage object\n */\nexport function copy3x3(m: Mat3x3): Mat3x3 {\n  return [m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]];\n}\n\n/**\n * Copies a Mat4x4 into a new storage object\n */\nexport function copy4x4(m: Mat4x4, out?: Mat4x4): Mat4x4 {\n  if (out) {\n    out[0] = m[0];\n    out[1] = m[1];\n    out[2] = m[2];\n    out[3] = m[3];\n    out[4] = m[4];\n    out[5] = m[5];\n    out[6] = m[6];\n    out[7] = m[7];\n    out[8] = m[8];\n    out[9] = m[9];\n    out[10] = m[10];\n    out[11] = m[11];\n    out[12] = m[12];\n    out[13] = m[13];\n    out[14] = m[14];\n    out[15] = m[15];\n    return out;\n  }\n\n  return [\n    m[0],\n    m[1],\n    m[2],\n    m[3],\n    m[4],\n    m[5],\n    m[6],\n    m[7],\n    m[8],\n    m[9],\n    m[10],\n    m[11],\n    m[12],\n    m[13],\n    m[14],\n    m[15]\n  ];\n}\n\n/**\n * This performs the order multiplication of SRT in reverse as TRS.\n * This is a MAX speed SRT Matrix generation method that optimizing the\n * computations needed to create an SRT from separate smaller components.\n *\n * NOTE: The rotation is injected\n *\n * This optimization was computed utilizing wolfram alpha:\n * a t                 | b u                 | c v                 | 0\n * d t                 | e u                 | f v                 | 0\n * g t                 | h u                 | i v                 | 0\n * t (a x + d y + g z) | u (b x + e y + h z) | v (c x + f y + i z) | 1\n */\nexport function TRS4x4(\n  scale: Vec3,\n  rotation: Mat3x3,\n  translation: Vec3,\n  out?: Mat4x4\n) {\n  out = out || (([] as any) as Mat4x4);\n  const [t, u, v] = scale;\n  const [x, y, z] = translation;\n  const [a, b, c, d, e, f, g, h, i] = rotation;\n\n  out[M400] = a * t;\n  out[M401] = b * u;\n  out[M402] = c * v;\n  out[M403] = 0;\n\n  out[M410] = d * t;\n  out[M411] = e * u;\n  out[M412] = f * v;\n  out[M413] = 0;\n\n  out[M420] = g * t;\n  out[M421] = h * u;\n  out[M422] = i * v;\n  out[M423] = 0;\n\n  out[M430] = t * (a * x + d * y + g * z);\n  out[M431] = u * (b * x + e * y + h * z);\n  out[M432] = v * (c * x + f * y + i * z);\n  out[M433] = 1;\n}\n\n/**\n * This is a MAX speed TRS Matrix generation method that optimizing the\n * computations needed to create an SRT from separate smaller components.\n *\n * NOTE: The rotation is injected\n *\n * This optimization was computed utilizing wolfram alpha:\n * a t | b t | c t | 0\n * d u | e u | f u | 0\n * g v | h v | i v | 0\n * x   | y   | z   | 1)\n */\nexport function SRT4x4(\n  scale: Vec3,\n  rotation: Mat3x3,\n  translation: Vec3,\n  out?: Mat4x4\n) {\n  out = out || (([] as any) as Mat4x4);\n  const [t, u, v] = scale;\n  const [x, y, z] = translation;\n  const [a, b, c, d, e, f, g, h, i] = rotation;\n\n  out[M400] = a * t;\n  out[M401] = b * t;\n  out[M402] = c * t;\n  out[M403] = 0;\n\n  out[M410] = d * u;\n  out[M411] = e * u;\n  out[M412] = f * u;\n  out[M413] = 0;\n\n  out[M420] = g * v;\n  out[M421] = h * v;\n  out[M422] = i * v;\n  out[M423] = 0;\n\n  out[M430] = x;\n  out[M431] = y;\n  out[M432] = z;\n  out[M433] = 1;\n}\n\n/**\n * This performs the order multiplication of SRT in reverse as TRS.\n *\n * This is a MAX speed SRT Matrix generation method that optimizing the\n * computations needed to create an SRT from separate smaller components.\n *\n * NOTE: The rotation is injected\n *\n * This optimization was computed utilizing wolfram alpha:\n * a t           | b u           | 0 | 0\n * c t           | d u           | 0 | 0\n * 0             | 0             | 0 | 0\n * t (a x + c y) | u (b x + d y) | 0 | 1\n */\nexport function TRS4x4_2D(\n  scale: Vec2,\n  rotation: Mat2x2,\n  translation: Vec2,\n  out?: Mat4x4\n) {\n  out = out || (([] as any) as Mat4x4);\n  const [t, u] = scale;\n  const [x, y] = translation;\n  const [a, b, c, d] = rotation;\n\n  out[M400] = a * t;\n  out[M401] = b * u;\n  out[M402] = 0;\n  out[M403] = 0;\n\n  out[M410] = c * t;\n  out[M411] = d * u;\n  out[M412] = 0;\n  out[M413] = 0;\n\n  out[M420] = 0;\n  out[M421] = 0;\n  out[M422] = 1;\n  out[M423] = 0;\n\n  out[M430] = t * (a * x + c * y);\n  out[M431] = u * (b * x + d * y);\n  out[M432] = 0;\n  out[M433] = 1;\n}\n\n/**\n * This performs the order multiplication of SRT in reverse as TRS.\n *\n * This is a MAX speed SRT Matrix generation method that optimizing the\n * computations needed to create an SRT from separate smaller components.\n *\n * This specifically creates a full transform for 3D computations by creating\n * the appropriate 4x4 that properly represents the complete transform to world\n * space.\n *\n * NOTE: The rotation is injected\n *\n * This optimization was computed utilizing wolfram alpha:\n * a t | b t | 0 | 0\n * c u | d u | 0 | 0\n * 0   | 0   | 1 | 0\n * x   | y   | 0 | 1\n */\nexport function SRT4x4_2D(\n  scale: Vec2Compat,\n  rotation: Mat2x2,\n  translation: Vec2Compat,\n  out?: Mat4x4\n) {\n  out = out || (([] as any) as Mat4x4);\n  const [t, u] = scale;\n  const [x, y] = translation;\n  const [a, b, c, d] = rotation;\n\n  out[M400] = a * t;\n  out[M401] = b * t;\n  out[M402] = 0;\n  out[M403] = 0;\n\n  out[M410] = c * u;\n  out[M411] = d * u;\n  out[M412] = 0;\n  out[M413] = 0;\n\n  out[M420] = 0;\n  out[M421] = 0;\n  out[M422] = 1;\n  out[M423] = 0;\n\n  out[M430] = x;\n  out[M431] = y;\n  out[M432] = 0;\n  out[M433] = 1;\n}\n","import { GLSettings } from \"../gl\";\nimport { WebGLStat } from \"../gl/webgl-stat\";\nimport { Instance } from \"../instance-provider/instance\";\nimport { ObservableMonitoring } from \"../instance-provider/observable\";\nimport { ResourceRouter } from \"../resources\";\nimport { ShaderDeclarationStatementLookup } from \"../shaders\";\nimport {\n  IShaderProcessingResults,\n  ShaderProcessor\n} from \"../shaders/processing/shader-processor\";\nimport {\n  FragmentOutputType,\n  IInstanceAttribute,\n  IInstanceProvider,\n  IInstancingUniform,\n  ILayerEasingManager,\n  ILayerMaterialOptions,\n  ILayerRef,\n  INonePickingMetrics,\n  InstanceAttributeSize,\n  instanceAttributeSizeFloatCount,\n  IPickInfo,\n  IShaderInitialization,\n  ISinglePickingMetrics,\n  isString,\n  IUniformInternal,\n  IVertexAttribute,\n  IVertexAttributeInternal,\n  LayerBufferType,\n  OutputFragmentShader,\n  PickType,\n  StreamChangeStrategy,\n  UniformIOValue\n} from \"../types\";\nimport { isBoolean } from \"../types\";\nimport { isDefined } from \"../util/common-filters\";\nimport { mapInjectDefault } from \"../util/common-operations\";\nimport { createAttribute } from \"../util/create-attribute\";\nimport { onFrame } from \"../util/frame\";\nimport { IdentifyByKey, IdentifyByKeyOptions } from \"../util/identify-by-key\";\nimport { PromiseResolver } from \"../util/promise-resolver\";\nimport { uid } from \"../util/uid\";\nimport {\n  InstanceAttributeBufferManager,\n  InstanceAttributePackingBufferManager,\n  UniformBufferManager\n} from \"./buffer-management\";\nimport {\n  BufferManagerBase,\n  IBufferLocation\n} from \"./buffer-management/buffer-manager-base\";\nimport { InstanceDiffManager } from \"./buffer-management/instance-diff-manager\";\nimport { LayerInteractionHandler } from \"./layer-interaction-handler\";\nimport { generateLayerGeometry } from \"./layer-processing\";\nimport { LayerScene } from \"./layer-scene\";\nimport { Surface } from \"./surface\";\nimport { IViewProps, View } from \"./view\";\n\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * A type to describe the constructor of a Layer class.\n */\nexport interface ILayerConstructable<T extends Instance> {\n  new (surface: Surface, scene: LayerScene, props: ILayerProps<T>): Layer<\n    any,\n    any\n  >;\n}\n\n/**\n * This specifies a class type that can be used in creating a layer with\n * createLayer\n */\nexport type ILayerConstructionClass<\n  T extends Instance,\n  U extends ILayerProps<T>\n> = ILayerConstructable<T> & { defaultProps: U };\n\n/**\n * This is a pair of a Class Type and the props to be applied to that class\n * type.\n */\nexport type LayerInitializer = {\n  key: string;\n  init: [\n    ILayerConstructionClass<Instance, ILayerProps<Instance>>,\n    ILayerProps<Instance>\n  ];\n};\n\n/**\n * The internal system layer initializer that hides additional properties the\n * front facing API should not be concerned with.\n */\nexport type LayerInitializerInternal = {\n  key: string;\n  init: [\n    ILayerConstructionClass<Instance, ILayerPropsInternal<Instance>>,\n    ILayerPropsInternal<Instance>\n  ];\n};\n\n/**\n * Constructor options when generating a layer.\n */\nexport interface ILayerProps<T extends Instance> extends IdentifyByKeyOptions {\n  /**\n   * This allows for external overriding of the base shader modules for a layer.\n   * This can cause a layer to break if the overrides do not provide what the\n   * layer is expecting at the least.\n   */\n  baseShaderModules?(\n    shaderIO: IShaderInitialization<T>,\n    layerModules: { fs: string[]; vs: string[] }\n  ): { fs: string[]; vs: string[] };\n  /**\n   * This is the data provider where the instancing data is injected and\n   * modified.\n   */\n  data: IInstanceProvider<T>;\n  /**\n   * This allows you to remap a layer's fragment output to an output your system\n   * needs. For example: a layer may output a color to the glow buffer, but we\n   * need that information in a different destination view output:\n   *\n   * [FragmentOutput.GLOW]: FragmentOutput.COLOR\n   *\n   * Or we can use this to just disable a layer's output to a buffer:\n   *\n   * [FragmentOutput.GLOW]: FragmentOutput.NONE\n   *\n   * You should be careful to not accidentally map an output to the same output\n   * name the layer may already have in place.\n   */\n  mapOutput?: Record<number, number>;\n  /**\n   * Any pipeline declaring a layer cn manipulate a layer's default material\n   * settings as every pipeline can have some specific and significant needs the\n   * layer does not provide as a default.\n   */\n  materialOptions?: ILayerMaterialOptions;\n  /**\n   * This sets how instances can be picked via the mouse. This activates the\n   * mouse events for the layer IFF the value is not NONE.\n   */\n  picking?: PickType;\n  /**\n   * Used for debugging. Logs the generated shader for the layer in the console.\n   */\n  printShader?: boolean;\n  /**\n   * This allows an easing ref to be applied to the layer. This ref can be used\n   * for detailed information regarding easing values, which allows for easier\n   * management of timings and feedback for animations being piped to the GPU.\n   */\n  ref?: ILayerRef;\n  /**\n   * This is a property that allows for changes to stream in batches instead of\n   * commit in one giant push. This helps if you have 100's of 1000's of\n   * instances you need to update. Updating all the instances can put extreme\n   * pressure on your RAM and can cause massive frame lag. Picking a streaming\n   * strategy and amount to commit per frame can greatly improve user experience\n   * and can even help to prevent crashes from RAM over use.\n   *\n   * WARNING: Once changes start committing for a batch of changes, future\n   * changes will NOT be rendered or able to affect the GPU state UNTIL the\n   * streaming completes. Once the stream is completed, all edits that happen\n   * subsequently will begin streaming in as the next batch of changes.\n   *\n   * You are allowed to change the instance's properties while waiting for a set\n   * of changes to finish streaming.\n   */\n  streamChanges?: {\n    /**\n     * This is the amount of instance updates that can stream through per frame.\n     * This defaults to 10000 if not provided\n     */\n    count?: number;\n    /**\n     * This is the strategy for pulling the next set of instances to update to\n     * the GPU. Defaults to LINEAR\n     */\n    strategy?: StreamChangeStrategy;\n  };\n\n  // ---- EVENTS ----\n  /**\n   * Executes when the mouse is down on instances (Picking type must be set)\n   */\n  onMouseDown?(info: IPickInfo<T>): void;\n  /** Executes when the mouse moves on instances (Picking type must be set) */\n  onMouseMove?(info: IPickInfo<T>): void;\n  /**\n   * Executes when the mouse no longer over instances (Picking type must be set)\n   */\n  onMouseOut?(info: IPickInfo<T>): void;\n  /**\n   * Executes when the mouse is newly over instances (Picking type must be set)\n   */\n  onMouseOver?(info: IPickInfo<T>): void;\n  /**\n   * Executes when the mouse button is released when over instances (Picking\n   * type must be set)\n   */\n  onMouseUp?(info: IPickInfo<T>): void;\n  /**\n   * Executes when the mouse was down on an instance but is released up outside\n   * of that instance (Picking type must be set)\n   */\n  onMouseUpOutside?(info: IPickInfo<T>): void;\n  /**\n   * Executes when the mouse click gesture is executed over instances (Picking\n   * type must be set)\n   */\n  onMouseClick?(info: IPickInfo<T>): void;\n\n  /**\n   * Executes when there are no longer any touches that are down for the layer\n   * (Picking type must be set).\n   *\n   * NOTE: This executes for touches being released inside and outside their\n   * respective instance.\n   */\n  onTouchAllEnd?(info: IPickInfo<T>): void;\n  /**\n   * Executes when a touch is down on instances. Each touch will produce it's\n   * own event (Picking type must be set)\n   */\n  onTouchDown?(info: IPickInfo<T>): void;\n  /**\n   * Executes when a touch is up when over on instances. Each touch will produce\n   * it's own event (Picking type must be set)\n   */\n  onTouchUp?(info: IPickInfo<T>): void;\n  /**\n   * Executes when a touch was down on an instance but is released up outside of\n   * that instance (Picking type must be set)\n   */\n  onTouchUpOutside?(info: IPickInfo<T>): void;\n  /**\n   * Executes when a touch is moving atop of instances. Each touch will produce\n   * it's own event (Picking type must be set)\n   */\n  onTouchMove?(info: IPickInfo<T>): void;\n  /**\n   * Executes when a touch is moves off of an instance. Each touch will produce\n   * it's own event (Picking type must be set)\n   */\n  onTouchOut?(info: IPickInfo<T>): void;\n  /**\n   * Executes when a touch moves over instances while the touch is dragged\n   * around the screen. (Picking type must be set)\n   */\n  onTouchOver?(info: IPickInfo<T>): void;\n  /**\n   * Executes when a touch moves off of an instance and there is no longer ANY\n   * touches over the instance (Picking type must be set)\n   */\n  onTouchAllOut?(info: IPickInfo<T>): void;\n  /** Executes when a touch taps on instances. (Picking type must be set) */\n  onTap?(info: IPickInfo<T>): void;\n}\n\n/**\n * Layer properties that contains internal system values\n */\nexport interface ILayerPropsInternal<T extends Instance>\n  extends ILayerProps<T> {\n  /**\n   * The system provides this for the layer when the layer is being produced as\n   * a child of another layer\n   */\n  parent?: Layer<Instance, ILayerProps<Instance>>;\n}\n\n/**\n * This is the information a layer stores regarding its shader configuration\n * information\n */\nexport interface ILayerShaderIOInfo<T extends Instance> {\n  /** This is the attribute that specifies the _active flag for an instance */\n  activeAttribute: IInstanceAttribute<T>;\n  /**\n   * These are the fragment shaders associated with each View that is available.\n   */\n  fs: OutputFragmentShader;\n  /** This is all of the instance attributes generated for the layer */\n  instanceAttributes: IInstanceAttribute<T>[];\n  /** Provides the number of vertices a single instance spans */\n  instanceVertexCount: number;\n  /**\n   * INTERNAL: For the given shader IO provided this is how many instances can\n   * be present per buffer.\n   */\n  maxInstancesPerBuffer: number;\n  /**\n   * Default model configuration for rendering in the gl layer. Since there is a\n   * material per view, it goes to follow that there is a model per view.\n   */\n  drawMode: GLSettings.Model.DrawMode;\n  /** This is all of the uniforms generated for the layer */\n  uniforms: IUniformInternal[];\n  /** Uniforms generated or discovered during shader processing. */\n  materialUniforms: IInstancingUniform[];\n  /** This is all of the vertex attributes generated for the layer */\n  vertexAttributes: IVertexAttributeInternal[];\n  /**\n   * This is the vertex shader this layer has produced for processing it's\n   * geometry.\n   */\n  vs: string;\n}\n\ninterface ILayerEasingManagerInternal extends ILayerEasingManager {\n  easingComplete: PromiseResolver<void>;\n}\n\n/**\n * A base class for generating drawable content\n */\nexport class Layer<\n  T extends Instance,\n  U extends ILayerProps<T>\n> extends IdentifyByKey {\n  /**\n   * This MUST be implemented by sublayers in order for proper code hinting to\n   * happen\n   */\n  static defaultProps: any = {};\n\n  /**\n   * Calculated end time of all animations that will take place. This will cause\n   * the system to keep rendering and not go into an idle state until the time\n   * of the last rendered frame has exceeded the time flagged here.\n   */\n  animationEndTime: number = 0;\n  /**\n   * This is a flag that allows a system to indicate this layer should always\n   * re-render\n   */\n  isAnimationContinuous: boolean = false;\n  /** Buffer manager is read only. Must use setBufferManager */\n  private _bufferManager: BufferManagerBase<T, IBufferLocation>;\n  /**\n   * This matches an instance to the data buffers and positions to stream to the\n   * GPU for direct updates. Use setBufferManager to change this element.\n   */\n  get bufferManager() {\n    return this._bufferManager;\n  }\n  /** Buffer type is private and should not be directly modified */\n  private _bufferType: LayerBufferType;\n  /** This is the determined buffering strategy of the layer */\n  get bufferType() {\n    return this._bufferType;\n  }\n  /** When a layer creates children, this is populated with those children */\n  children?: Layer<Instance, ILayerProps<Instance>>[];\n  /** This determines the drawing order of the layer within it's scene */\n  depth: number = 0;\n  /** This contains the methods and controls for handling diffs for the layer */\n  diffManager: InstanceDiffManager<T>;\n  /**\n   * This gets populated when there are attributes that have easing applied to\n   * them. This subsequently gets applied to instances when they get added to\n   * the layer.\n   */\n  easingId: { [key: string]: number };\n  /**\n   * This is a manager used to monitor and handle the easing operations of the\n   * layer\n   */\n  private _easingManager: ILayerEasingManagerInternal = {\n    easingComplete: new PromiseResolver(),\n    complete: () => this._easingManager.easingComplete.promise\n  };\n\n  get easingManager(): ILayerEasingManager {\n    return this._easingManager;\n  }\n\n  /** This is the initializer used when making this layer. */\n  initializer: LayerInitializer;\n  /** This is the handler that manages interactions for the layer */\n  interactions: LayerInteractionHandler<T, U>;\n  /** The last time stamp this layer had its contents rendered */\n  lastFrameTime: number = 0;\n  /** This indicates whether this layer needs to draw */\n  needsViewDrawn: boolean = false;\n  /** Helps assert rendering order. Lower numbers render first. */\n  order?: number;\n  /**\n   * If this is populated, then this layer is the product of a parent producing\n   * this layer.\n   */\n  parent?: Layer<Instance, ILayerProps<Instance>>;\n  /** This is all of the picking metrics kept for handling picking scenarios */\n  picking: ISinglePickingMetrics<T> | INonePickingMetrics;\n  /** Properties handed to the Layer during a Surface render */\n  props: U;\n  /**\n   * This is the system provided resource manager that lets a layer request\n   * resources\n   */\n  resource: ResourceRouter;\n  /** This is the layer scene this layer feeds into */\n  scene: LayerScene;\n  /**\n   * This contains the shader IO information generated when the layer was\n   * created\n   */\n  shaderIOInfo: ILayerShaderIOInfo<T> = {} as ILayerShaderIOInfo<T>;\n  /**\n   * This is populated with the current streaming state for committing changes\n   * to the GPU. See ILayerProps for how the configuration happens for this\n   * object.\n   */\n  private streamChanges: {\n    /**\n     * When locked this layer will NOT stream in new changes as it has a current\n     * stream it is completing first.\n     */\n    locked: boolean;\n    /**\n     * When defined, this is the list of items currently being streamed to the\n     * GPU.\n     */\n    stream?: U[\"data\"][\"changeList\"];\n    /** The index our stream has iterated through for the current stream */\n    streamIndex: number;\n  } = {\n    locked: false,\n    streamIndex: 0\n  };\n  /** This is the surface this layer is generated under */\n  surface: Surface;\n\n  /** A uid provided to the layer to give it some uniqueness as an object */\n  get uid() {\n    return this._uid;\n  }\n  private _uid: number = uid();\n  /**\n   * This maps a uid to the instance. This is only populated if it's needed for\n   * the processes the layer uses (such as color picking).\n   */\n  uidToInstance = new Map<number, T>();\n  /**\n   * This is the view the layer is applied to. This changes as the rendering\n   * progresses. A configuration of the surface can specify several views for a\n   * set of layers. So, this will change with the current view being rendered\n   * during a draw pass.\n   *\n   * NOTE: The system sets this, modifying it yourself will only cause sorrow.\n   */\n  view: View<IViewProps>;\n  /**\n   * This flag indicates if the layer will be reconstructed from scratch next\n   * layer rendering cycle\n   */\n  willRebuildLayer: boolean = false;\n\n  /**\n   * This is a hook for the layer to respond to an instance being added via the\n   * diff manager. This is a simple opportunity to set some expectations of the\n   * instance and tie it directly to the layer it is processing under.\n   *\n   * By default for best performance, this method is undefined for the layer.\n   * One must be applied for the hook to take effect.\n   *\n   * For example: the primary case this arose was from instances needing the\n   * easing id mapping to allow for retrieval of the instance's easing\n   * information for a given layer association.\n   *\n   * WARNING: This is tied into a MAJOR performance sensitive portion of the\n   * framework. This should involve VERY simple assignments at best. Do NOT\n   * perform any logic in this callback or your application WILL suffer.\n   */\n  onDiffAdd?(instance: T): void;\n\n  /**\n   * This is an opportunity to clean up any instance's association with the\n   * layer it was originally a part of.\n   *\n   * WARNING: This is tied into a MAJOR performance sensitive portion of the\n   * framework. This should involve VERY simple assignments at best. Do NOT\n   * perform any logic in this callback or your application WILL suffer.\n   *\n   * EXTRA WARNING: You better make sure you instantiate this if you\n   * instantiated onDiffManagerAdd so you can clean out any bad memory\n   * allocation choices you made.\n   */\n  onDiffRemove?(instance: T): void;\n\n  /**\n   * Generates a reference object that can be used to retrieve layer specific\n   * metrics associated with the layer.\n   */\n  static createRef<T extends ILayerRef>(): T {\n    return {\n      easing: null\n    } as T;\n  }\n\n  constructor(surface: Surface, scene: LayerScene, props: ILayerProps<T>) {\n    // We do not establish bounds in the layer. The surface manager will take care of that for us\n    // After associating the layer with the view it is a part of.\n    super(props);\n    // Keep track of the surface this layer resides beneath\n    this.surface = surface;\n    // Track the parent Layer Scene this layer is under\n    this.scene = scene;\n    // Keep our props within the layer\n    this.props = Object.assign({}, Layer.defaultProps || {}, props as U);\n  }\n\n  /**\n   * Validates the shader initialization object from the layer.\n   */\n  private validateShaderIO(shaderIO: IShaderInitialization<T> | null) {\n    // If no metrics are provided, this layer is merely a shell layer and will\n    // not receive any GPU handling objects.\n    if (!shaderIO) {\n      this.picking.type = PickType.NONE;\n      debug(\n        \"Shell layer initialized. Nothing will be rendered for this layer\",\n        this.id\n      );\n      return true;\n    }\n\n    if (!shaderIO.fs || !shaderIO.vs) {\n      console.warn(\n        \"Layer needs to specify the fragment and vertex shaders:\",\n        this.id\n      );\n      return false;\n    }\n\n    return;\n  }\n\n  /**\n   * Performs clean ups on the data provided by the layer for the Shader\n   * Initialization to make it easier and more reliable to work with when\n   * processing.\n   */\n  private cleanShaderIOElements(shaderIO: IShaderInitialization<T>) {\n    // Clean out nulls provided as a convenience to the layer\n    shaderIO.instanceAttributes = (shaderIO.instanceAttributes || []).filter(\n      isDefined\n    );\n    shaderIO.vertexAttributes = (shaderIO.vertexAttributes || []).filter(\n      isDefined\n    );\n    shaderIO.uniforms = (shaderIO.uniforms || []).filter(isDefined);\n  }\n\n  /**\n   * When the layer declares it's shader intiialization, it can specify multiple\n   * fragment shader fragments each with their own output target type. We do NOT\n   * allow two fragments to point to the same type. This performs a thorough\n   * check to ensure that does not happen.\n   */\n  private checkForDuplicateOutputTypes(shaderIO: IShaderInitialization<T>) {\n    let { mapOutput } = this.props;\n\n    // If the fragment is just a string, then it's output source is the default\n    // COLOR target.\n    if (isString(shaderIO.fs)) {\n      shaderIO.fs = [\n        {\n          outputType: FragmentOutputType.COLOR,\n          source: shaderIO.fs\n        }\n      ];\n    }\n\n    // Use the layer's output mapping to transform the target outputs of the\n    // fragment shader\n    mapOutput = mapOutput || {};\n    const outputTypeCheck = new Set<number>();\n    let hasDuplicateType = false;\n    let nothingTarget = Number.MIN_SAFE_INTEGER;\n\n    // Perform fragment output mapping changes AND check for duplicate output\n    // targets which will be considered invalid.\n    for (let i = 0, iMax = shaderIO.fs.length; i < iMax; ++i) {\n      const output = shaderIO.fs[i];\n      const newOutput = mapOutput[output.outputType];\n\n      if (newOutput === void 0) {\n        if (outputTypeCheck.has(output.outputType)) {\n          hasDuplicateType = true;\n        }\n\n        outputTypeCheck.add(output.outputType);\n        continue;\n      }\n\n      // When mapped to nothing, we can not remove the fragment as it may be a\n      // requirement for later fragments, so we just map it's type to a\n      // non-sensical number.\n      if (newOutput === FragmentOutputType.NONE) {\n        output.outputType = nothingTarget++;\n      } else {\n        output.outputType = newOutput;\n      }\n\n      if (outputTypeCheck.has(output.outputType)) {\n        hasDuplicateType = true;\n      }\n\n      outputTypeCheck.add(output.outputType);\n    }\n\n    if (hasDuplicateType) {\n      console.warn(\"Layer has duplicate fragment shader output types\");\n      return false;\n    }\n\n    return;\n  }\n\n  /**\n   * Processes the fragment outputs a layer provides against each view and\n   * generates a merged fragment shader with those fragments optimized for each\n   * view.\n   */\n  private processFragmentShadersForEachView(\n    shaderIO: IShaderInitialization<T>,\n    views: View<IViewProps>[]\n  ) {\n    // If the fragment is just a string, then it's output source is the default\n    // COLOR target. THis also simplifies our data type to guarantee a list.\n    if (isString(shaderIO.fs)) {\n      shaderIO.fs = [\n        {\n          outputType: FragmentOutputType.COLOR,\n          source: shaderIO.fs\n        }\n      ];\n    }\n\n    // We inject automated picking items if the user has not defined their own\n    // picking output type.\n    const doAutomatedPicking =\n      this.picking.type === PickType.SINGLE &&\n      !Boolean(\n        shaderIO.fs.find(\n          output => output.outputType === FragmentOutputType.PICKING\n        )\n      );\n\n    if (this.picking.type === PickType.SINGLE && !doAutomatedPicking) {\n      throw new Error(\n        \"Do NOT specify picking prop on a layer when you have your own Picking output declared.\"\n      );\n    }\n\n    const pickingFragmentOutput = {\n      outputType: FragmentOutputType.PICKING,\n      source: require(\"../shaders/base-modules/shader-fragments/picking.fs\")\n    };\n\n    // We will store each fragment shader created per view\n    const outputFragmentShaders: OutputFragmentShader = new Map();\n    // Any of our processes from here on out can require and generate\n    // declarations that need to go into the application. This provides a means\n    // of passing those declarations to the shader processor when it builds the\n    // headers of our shader files.\n    const declarations: ShaderDeclarationStatementLookup = {\n      fs: new Map(),\n      vs: new Map(),\n      destructure: new Map()\n    };\n\n    // We must analyze our fragment shaders and views to determine which\n    // processing output we are going to actually output for the sake of the\n    // view. Each view that declares a unique output for the layer requires it's\n    // own shader or group of shaders.\n    for (let i = 0, iMax = views.length; i < iMax; ++i) {\n      const view = views[i];\n\n      // Delete previously existing picking fragment output so it can be\n      // injected in the correct location.\n      if (doAutomatedPicking) {\n        const index = shaderIO.fs.findIndex(\n          layerOutput => layerOutput.outputType === FragmentOutputType.PICKING\n        );\n\n        if (index > -1) {\n          shaderIO.fs.splice(index, 1);\n        }\n      }\n\n      // See which fragment output is the LAST needed output in the list\n      const viewOutputTargets = view.getOutputTargets();\n      let maxLayerOutputIndex = 0;\n      shaderIO.fs.forEach((layerOutput, i) => {\n        if (\n          viewOutputTargets?.find(\n            viewTarget => viewTarget.outputType === layerOutput.outputType\n          )\n        ) {\n          maxLayerOutputIndex = i;\n        }\n      });\n\n      // If Picking is enabled, we force inject a picking target for the\n      // fragement shader AFTER the last major output index so we don't\n      // accidentally cause needless fragment shader outputs to get bundled in.\n      if (doAutomatedPicking) {\n        shaderIO.fs.splice(maxLayerOutputIndex + 1, 0, pickingFragmentOutput);\n      }\n\n      let declarationsFS = mapInjectDefault(declarations.fs, view, new Map());\n\n      if (!declarationsFS) {\n        declarationsFS = new Map();\n        declarations.fs.set(view, declarationsFS);\n      }\n\n      // This processes the fragment shader's fragments written for the layer\n      // and combines all of the fragments that matches with the current view's\n      // output target types.\n      const outputFragmentShader = ShaderProcessor.makeOutputFragmentShader(\n        declarations.vs,\n        declarationsFS,\n        viewOutputTargets,\n        shaderIO.fs\n      );\n\n      if (!outputFragmentShader) {\n        console.warn(\n          \"Could not generate output fragment shaders for the view specified.\"\n        );\n        return false;\n      }\n\n      // Store the output fragment shaders for the given view\n      outputFragmentShaders.set(view, outputFragmentShader);\n    }\n\n    return { outputFragmentShaders, declarations };\n  }\n\n  /**\n   * This performs the actual generation of the vertex and fragment shaders this\n   * layer will use. Each fragment shader is now associated with it's respective\n   * view and will be generated accordingly.\n   */\n  private processLayerShaders(\n    shaderIO: IShaderInitialization<T>,\n    outputFragmentShaders: OutputFragmentShader,\n    declarations: ShaderDeclarationStatementLookup\n  ) {\n    let shaderMetrics:\n      | (Omit<IShaderProcessingResults<T>, \"fs\"> & { fs: OutputFragmentShader })\n      | null = null;\n\n    // Generate the actual shaders to be used by injecting all of the\n    // necessary fragments from all modules\n    shaderMetrics = new ShaderProcessor().process(\n      this,\n      shaderIO,\n      outputFragmentShaders,\n      declarations,\n      this.surface.getIOExpanders(),\n      this.surface.getShaderTransforms(),\n      this.surface.getIOSorting()\n    );\n\n    // Check to see if the Shader Processing failed. If so, return null as a\n    // failure flag.\n    if (!shaderMetrics) {\n      console.warn(\n        \"The shader processor did not produce metrics for the layer.\"\n      );\n      return false;\n    }\n\n    // Now that all of the elements of the layer are complete, let us apply them to the layer\n    this.shaderIOInfo = Object.assign<\n      ILayerShaderIOInfo<T>,\n      ILayerShaderIOInfo<T>\n    >(\n      {\n        // This is a filler active attribute. It gets replaced.\n        activeAttribute: createAttribute({\n          name: \"active\",\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.active ? 1 : 0]\n        }),\n        instanceAttributes: shaderMetrics.instanceAttributes,\n        instanceVertexCount: shaderIO.vertexCount,\n        vs: shaderMetrics.vs,\n        fs: shaderMetrics.fs,\n        materialUniforms: shaderMetrics.materialUniforms,\n        maxInstancesPerBuffer: shaderMetrics.maxInstancesPerBuffer,\n        drawMode: shaderIO.drawMode || GLSettings.Model.DrawMode.TRIANGLE_STRIP,\n        uniforms: shaderMetrics.uniforms,\n        vertexAttributes: shaderMetrics.vertexAttributes\n      },\n      this.shaderIOInfo\n    );\n\n    return;\n  }\n\n  /**\n   * Processes the static vertex information and applies GL Attributes for each\n   * item.\n   */\n  private processVertexAttributes(shaderIO: IShaderInitialization<T>) {\n    generateLayerGeometry(\n      this,\n      this.shaderIOInfo.maxInstancesPerBuffer,\n      this.shaderIOInfo.vertexAttributes,\n      shaderIO.vertexCount\n    );\n  }\n\n  /**\n   * This does special initialization by gathering the layers shader IO,\n   * generates a material and injects special automated uniforms and attributes\n   * to make instancing work for the shader.\n   */\n  init(views: View<IViewProps>[]) {\n    // Set up the pick type for the layer\n    const { picking = PickType.NONE } = this.props;\n\n    if (picking === PickType.SINGLE) {\n      this.picking = {\n        currentPickMode: PickType.NONE,\n        type: PickType.SINGLE,\n        uidToInstance: new Map<number, T>()\n      };\n    } else {\n      this.picking = {\n        currentPickMode: PickType.NONE,\n        type: PickType.NONE\n      };\n    }\n\n    // Set the resource manager this surface utilizes to the layer\n    this.resource = this.surface.resourceManager;\n    // Get the shader metrics the layer desires\n    const shaderIO = this.initShader();\n    // Ensure the layer has interaction handling applied to it\n    this.interactions = new LayerInteractionHandler(this);\n\n    // Perform validation checks and see if we need to quick exit with a layer\n    // construction flag.\n    const ioValidation = this.validateShaderIO(shaderIO);\n    if (ioValidation !== void 0) return ioValidation;\n    if (!shaderIO) return false;\n\n    let result;\n\n    // Shader initialization can be a little sloppy which creates some\n    // convenience in writing layers. This helps ensures some data types are\n    // established.\n    result = this.cleanShaderIOElements(shaderIO);\n    if (isBoolean(result)) return result;\n    // Layer fragments can not output to the same output targets.\n    result = this.checkForDuplicateOutputTypes(shaderIO);\n    if (isBoolean(result)) return result;\n    // Our fragment shaders are\n    result = this.processFragmentShadersForEachView(shaderIO, views);\n    if (isBoolean(result)) return result;\n    // Now take all of the information gathered and generate the actual shaders\n    // this layer will need to handle all of the views and attributes used\n    result = this.processLayerShaders(\n      shaderIO,\n      result.outputFragmentShaders,\n      result.declarations\n    );\n    if (isBoolean(result)) return result;\n    // After all processing is complete, let's initialize our vertex attributes\n    // which are used in our base geometry\n    result = this.processVertexAttributes(shaderIO);\n    if (isBoolean(result)) return result;\n    // Generate the correct buffering strategy for the layer\n    result = this.makeLayerBufferManager(this.surface.gl, this.scene);\n    if (isBoolean(result)) return result;\n    // Establish diff handlers based on the settings of the layer\n    result = this.updateDiffHandlers();\n    if (isBoolean(result)) return result;\n    // Handle debugging calls so we can print useful information about this\n    // layer\n    this.layerShaderDebugging();\n\n    // Establish initial ref needs\n    if (this.props.ref) {\n      this.props.ref.easing = this.easingManager;\n    }\n\n    return true;\n  }\n\n  private layerShaderDebugging() {\n    if (this.props.printShader) {\n      console.warn(\n        \"A Layer requested its shader be debugged. Do not leave this active for production:\",\n        \"Layer:\",\n        this.props.key,\n        \"Shader Metrics\",\n        this.shaderIOInfo\n      );\n      console.warn(\n        \"\\n\\nVERTEX SHADER\\n--------------\\n\\n\",\n        this.shaderIOInfo.vs\n      );\n\n      this.shaderIOInfo.fs.forEach((fs, view) => {\n        console.warn(\n          `\\n\\nFRAGMENT SHADER (view: ${\n            view.id\n          }):\\nOutput Targets${JSON.stringify(\n            fs.outputNames\n          )}\\n${JSON.stringify(fs.outputTypes)}\\n--------------\\n\\n`,\n          fs.source\n        );\n      });\n    }\n  }\n\n  /**\n   * This establishes basic modules required by the layer for the shaders. At\n   * it's core functionality, it will support the basic properties a layer has\n   * to provide, such as Picking modes\n   */\n  baseShaderModules(\n    shaderIO: IShaderInitialization<T>\n  ): { fs: string[]; vs: string[] } {\n    const additionalImportsVS: string[] = [];\n    const additionalImportsFS: string[] = [];\n\n    // All layers need the basic instancing functionality\n    additionalImportsVS.push(\"instancing\");\n\n    // See if the layer needs picking modules\n    if (this.picking.type === PickType.SINGLE) {\n      additionalImportsVS.push(\"picking\");\n    }\n\n    // See if there are any attributes that have  auto easing involved\n    const easing = (shaderIO.instanceAttributes || []).find(check =>\n      Boolean(check && check.easing)\n    );\n\n    // If easing is involved then we need to make sure that frame metrics are\n    // imported for our animations\n    if (easing) {\n      additionalImportsVS.push(\"frame\");\n    }\n\n    return {\n      fs: additionalImportsFS,\n      vs: additionalImportsVS\n    };\n  }\n\n  /**\n   * This provides a means for a layer to have child layers that are injected\n   * immediately after this layer.\n   *\n   * This essentially lets composite layer management occur allowing the\n   * compositer to behave as a layer does but have layers managed by it. This\n   * has the advantage of allowing a composition layer able to handle a data\n   * provider but split it's processing across it's own internal data providers\n   * which is thus picked up by it's child layers and output by the layers.\n   */\n  childLayers(): LayerInitializer[] {\n    return [];\n  }\n\n  /**\n   * Invalidate and free all resources assocated with this layer.\n   */\n  destroy() {\n    if (this.bufferManager) {\n      if (this.bufferManager.scene) this.bufferManager.scene.removeLayer(this);\n      this.bufferManager.removeFromScene();\n      this.bufferManager.destroy();\n    }\n  }\n\n  /**\n   * Lifecycle method for layers to inherit that executes after the props for\n   * the layer have been updated\n   */\n  didUpdateProps() {\n    /** LIFECYCLE */\n  }\n\n  /**\n   * This is where global uniforms should update their values. Executes every\n   * frame.\n   */\n  draw() {\n    // Make sure the stream lock is up to date before processing the next set of\n    // changes\n    this.updateStreamLock();\n    // Consume the diffs for the instances to update each element\n    const changeList = this.getChangeList();\n\n    // Set needsViewDrawn to be true if there is any change\n    if (changeList.length > 0) this.needsViewDrawn = true;\n    // Make some holder variables to prevent declaration within the loop\n    let change, instance, bufferLocations;\n    // Fast ref to the processor and manager\n    const diffManager = this.diffManager;\n    const processing = diffManager.processing;\n    const processor = diffManager.processor;\n\n    // Forewarn the processor how many instances are flagged for a change.\n    processor.incomingChangeList(changeList);\n    // Forewarn the buffer manager of changes so it can optimize it's handling\n    // of changes as well\n    this.bufferManager.incomingChangeList(changeList);\n\n    for (let i = 0, end = changeList.length; i < end; ++i) {\n      change = changeList[i];\n      instance = change[0];\n      bufferLocations = this.bufferManager.getBufferLocations(instance);\n      // The diff type is change[1] which we use to find the diff processing\n      // method to use\n      processing[change[1]](\n        processor,\n        instance,\n        Object.values(change[2]),\n        bufferLocations\n      );\n      // Clear the changes for the instance\n      instance.changes = {};\n    }\n\n    // Tell the diff processor that it has completed it's task set\n    processor.commit();\n    // Tell the manager changes are processed to allow it to free up resources\n    this.bufferManager.changesProcessed();\n    // Update our easing management\n    this.updateEasingManager();\n    // Trigger uniform updates\n    this.updateUniforms();\n  }\n\n  /**\n   * This handles updating our easingManager so references can properly react to\n   * easing completion times.\n   */\n  private updateEasingManager() {\n    // If we're streaming changes, then we have to wait for the stream to be\n    // finished before we can use the animation end time of the layer to\n    // establish the true end of all animations piped to the GPU.\n    if (this.props.streamChanges) {\n      // Wait for the stream to be emptied so we can\n      if (!this.streamChanges.stream || this.streamChanges.stream.length <= 0) {\n        // Get the existing resolver that is waiting for the animations to\n        // complete\n        const resolver = this._easingManager.easingComplete;\n        // Make a new resolver for next processes waiting for a current change\n        // set to complete\n        this._easingManager.easingComplete = new PromiseResolver<void>();\n\n        // Set a timer to complete when the layer has finished it's animation\n        // cycle\n        onFrame(() => {\n          resolver.resolve();\n        }, this.animationEndTime - this.surface.frameMetrics.currentTime);\n      }\n    }\n\n    // If this is a non-streamed change, then we simply wait until the layer's\n    // animation timer is resolved\n    else {\n      // Get the existing resolver that is waiting for the animations to\n      // complete\n      const resolver = this._easingManager.easingComplete;\n      // Make a new resolver for next processes waiting for a current change set\n      // to complete\n      this._easingManager.easingComplete = new PromiseResolver<void>();\n\n      // Set a timer to complete when the layer has finished it's animation\n      // cycle\n      onFrame(() => {\n        resolver.resolve();\n      }, this.animationEndTime - this.surface.frameMetrics.currentTime);\n    }\n  }\n\n  /**\n   * This gets the next changes that should be retrieved from a change stream. A\n   * stream is when changes are streamed in batches instead of committing all\n   * changes in a single update.\n   */\n  private getNextStreamChanges() {\n    let out: U[\"data\"][\"changeList\"];\n\n    // Get the stream changes settings from our props\n    const {\n      streamChanges = {\n        count: 10000,\n        strategy: StreamChangeStrategy.LINEAR\n      }\n    } = this.props;\n    // Get the stream that is currently in progress\n    const { stream = [], streamIndex } = this.streamChanges;\n\n    // Ensure we have a count set for the number of items to stream down\n    if (streamChanges.count === void 0) {\n      streamChanges.count = 10000;\n    }\n\n    // Validate the number of items to stream. Any number at 0 or less indicates a desire to stream all remaining\n    // changes.\n    if (streamChanges.count <= 0) {\n      streamChanges.count = Number.MAX_SAFE_INTEGER;\n    }\n\n    // Pick the strategy for pulling the next changes from the stream\n    switch (streamChanges.strategy) {\n      // Linear just pulls out changes as they came in\n      case StreamChangeStrategy.LINEAR:\n      default: {\n        out = stream.slice(streamIndex, streamIndex + streamChanges.count);\n        this.streamChanges.streamIndex += streamChanges.count;\n        break;\n      }\n    }\n\n    // If we hit the end of the stream, we need to dump the stream from memory.\n    if (\n      this.streamChanges.stream &&\n      this.streamChanges.streamIndex >= this.streamChanges.stream.length\n    ) {\n      delete this.streamChanges.stream;\n    }\n\n    return out;\n  }\n\n  /**\n   * This checks the status of the stream and determines if this layer is locked\n   * into a stream or is done processing the stream.\n   */\n  private updateStreamLock() {\n    this.streamChanges.locked = Boolean(\n      this.streamChanges.stream &&\n        this.streamChanges.streamIndex < this.streamChanges.stream.length\n    );\n  }\n\n  /**\n   * This gets the next instance changes to push to the GPU.\n   */\n  private getChangeList() {\n    let changeList: U[\"data\"][\"changeList\"];\n\n    // If we are streaming changes we do not accept new changes coming down but\n    // instead work on resolving the current stream\n    if (this.streamChanges.locked) {\n      changeList = this.getNextStreamChanges();\n    } else {\n      // If streaming changes is declared for the properties of the layer, then\n      // we need to gather the current change list into a stream and pull a set\n      // of the changes.\n      if (this.props.streamChanges) {\n        // We start a new stream so we have to begin at it's start index\n        this.streamChanges.streamIndex = 0;\n        // We lock the layer for the streaming changes so the stream will\n        // complete before new changes are applied\n        this.streamChanges.locked = true;\n        // Create the new stream from the existing changes.\n        this.streamChanges.stream = this.props.data.changeList;\n        // We provide no changes the first frame. There is some set up that can\n        // cause a spike in utilization, so we don't want the first changes to\n        // be too far ahead of the changes of others.\n        changeList = [];\n        // Since we retrieved all the current changes and applied it to our\n        // stream, we resolve the changes from the provider so new changes can\n        // be gathered whilst the stream resolves.\n        this.props.data.resolve(this.id);\n      } else {\n        // This is simply full copying all current changes as the next set of\n        // changes to be applied\n        changeList = this.props.data.changeList;\n        // Flag the changes as resolved since we gathered all changes and the\n        // changes will be immediately applied\n        this.props.data.resolve(this.id);\n      }\n    }\n\n    this.updateStreamLock();\n\n    return changeList;\n  }\n\n  /**\n   * This retrieves the observable IDs for instance observable properties. This\n   * triggers a getter of the indicated property.\n   *\n   * Do NOT use this in intensive loops, try to cache these results where\n   * possible.\n   */\n  getInstanceObservableIds<K extends keyof T>(\n    instance: T,\n    properties: Extract<K, string>[]\n  ): { [key: string]: number } {\n    const out: { [key: string]: number } = {};\n\n    // Loop through all of the requested properties to see if they are\n    // observable and have an id associated with them.\n    for (let i = 0, iMax = properties.length; i < iMax; ++i) {\n      // Activate monitoring of ids, this also resets the monitor's list\n      ObservableMonitoring.setObservableMonitor(true);\n      // Trigger the getter of the property\n      instance[properties[i]];\n      // We now can see if the property triggered an identifier thus indicating\n      // it's observable and has an ID\n      const propertyIds = ObservableMonitoring.getObservableMonitorIds(true);\n\n      // If an id is found, then the property was observable.\n      if (propertyIds[0] !== undefined) {\n        out[properties[i]] = propertyIds[0];\n      }\n    }\n\n    // SUPER IMPORTANT to deactivate this here. Leaving this turned on causes\n    // memory to be chewed up for every property getter.\n    ObservableMonitoring.setObservableMonitor(false);\n\n    return out;\n  }\n\n  /**\n   * The options for a GL Material without uniforms.\n   */\n  getMaterialOptions(): ILayerMaterialOptions {\n    return {};\n  }\n\n  /**\n   * This sets up all of the data bindings that will transport data from the CPU\n   * to the Shader on the GPU.\n   *\n   * Instance Attributes: These are very frequently changing attributes\n   * Vertex Attributes: These are attributes that should be static on a vertex.\n   *                    Conisder it very costly to update. The only time making\n   *                    these modifieable is in the event of GL_POINTS.\n   * Uniforms: These set up the uniforms for the layer, thus having all normal\n   *           implications of a uniform. Global across the fragment and vertex\n   *           shaders and can be modified with little consequence.\n   *\n   * NOTE: Return null to indicate this layer is not going to render anything.\n   * This is typical for parent layers that manage child layers who themselves\n   * do not cause rendering of any sort.\n   */\n  initShader(): IShaderInitialization<T> | null {\n    return {\n      fs: \"${import: no-op}\",\n      instanceAttributes: [],\n      uniforms: [],\n      vertexAttributes: [],\n      vertexCount: 0,\n      vs: \"${import: no-op}\"\n    };\n  }\n\n  /**\n   * Indicates if this layer is managing an instance or not. This is normally\n   * done by determining if this layer's buffer manager has assigned buffer\n   * space to the instance. In special layer cases this may be overridden here\n   * to make the assertion in some other way.\n   */\n  managesInstance(instance: T): boolean {\n    return this.bufferManager && this.bufferManager.managesInstance(instance);\n  }\n\n  /**\n   * This method determines the buffering strategy that the layer should be\n   * utilizing based on provided vertex and instance attributes.\n   */\n  getLayerBufferType<T extends Instance>(\n    _gl: WebGLRenderingContext,\n    vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<T>[]\n  ) {\n    let type = LayerBufferType.UNIFORM;\n    let attributesUsed = 0;\n\n    // The layer only gets it's buffer type calculated once\n    if (this.bufferType !== undefined) {\n      return this.bufferType;\n    }\n\n    // Uncomment this to force the uniform buffer strategy\n    // this.setBufferType(LayerBufferType.UNIFORM);\n    // return LayerBufferType.UNIFORM;\n\n    if (WebGLStat.HARDWARE_INSTANCING) {\n      for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n        const attribute = vertexAttributes[i];\n        attributesUsed += Math.ceil(attribute.size / 4);\n      }\n\n      for (let i = 0, end = instanceAttributes.length; i < end; ++i) {\n        const attribute = instanceAttributes[i];\n        attributesUsed += Math.ceil(\n          instanceAttributeSizeFloatCount[attribute.size || 1] / 4\n        );\n      }\n\n      // Too many attempted single attributes. We will next attempt to see if we\n      // can pack the vertex attributes down into blocks.\n      if (attributesUsed > WebGLStat.MAX_VERTEX_ATTRIBUTES) {\n        attributesUsed = 0;\n\n        for (let i = 0, end = instanceAttributes.length; i < end; ++i) {\n          const attribute = instanceAttributes[i];\n          attributesUsed = Math.max(attributesUsed, attribute.block || 0);\n        }\n\n        for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n          const attribute = vertexAttributes[i];\n          attributesUsed += Math.ceil(attribute.size / 4);\n        }\n\n        // If we can fit now, then we are good to go with using attribute\n        // packing\n        if (attributesUsed < WebGLStat.MAX_VERTEX_ATTRIBUTES) {\n          type = LayerBufferType.INSTANCE_ATTRIBUTE_PACKING;\n\n          debug(\n            `Performance Issue (Moderate):\n            Layer %o is utilizing too many vertex attributes and is now using vertex packing.\n            Max Vertex units %o\n            Used Vertex units %o\n            Instance Attributes %o\n            Vertex Attributes %o`,\n            this.id,\n            WebGLStat.MAX_VERTEX_ATTRIBUTES,\n            attributesUsed,\n            instanceAttributes,\n            vertexAttributes\n          );\n        }\n      } else {\n        // If we make it here, we are good to go using hardware instancing!\n        // Hooray performance!\n        type = LayerBufferType.INSTANCE_ATTRIBUTE;\n      }\n    }\n\n    // No other faster mode supported: use uniform instancing\n    if (type === LayerBufferType.UNIFORM) {\n      debug(\n        `Performance Issue (High):\n        Layer %o is utilizing too many vertex attributes and is now using a uniform buffer.\n        Max Vertex units %o\n        Used Vertex units %o\n        Instance Attributes %o\n        Vertex Attributes %o`,\n        this.id,\n        WebGLStat.MAX_VERTEX_ATTRIBUTES,\n        attributesUsed,\n        instanceAttributes,\n        vertexAttributes\n      );\n      type = LayerBufferType.UNIFORM;\n    }\n\n    // Apply the type to the layer\n    this.setBufferType(type);\n\n    return type;\n  }\n\n  /**\n   * This generates the buffer manager to be used to manage instances getting\n   * applied to attribute locations.\n   */\n  makeLayerBufferManager(gl: WebGLRenderingContext, scene: LayerScene) {\n    // Esnure the buffering type has been calculated for the layer\n    const type = this.getLayerBufferType(\n      gl,\n      this.shaderIOInfo.vertexAttributes,\n      this.shaderIOInfo.instanceAttributes\n    );\n\n    switch (type) {\n      // This is the Instance Attribute buffering strategy, which means the system\n      case LayerBufferType.INSTANCE_ATTRIBUTE: {\n        this.setBufferManager(new InstanceAttributeBufferManager(this, scene));\n        break;\n      }\n\n      // This is the Instance Attribute buffering strategy, which means the system\n      case LayerBufferType.INSTANCE_ATTRIBUTE_PACKING: {\n        this.setBufferManager(\n          new InstanceAttributePackingBufferManager(this, scene)\n        );\n        break;\n      }\n\n      // Anything not utiliziing a specialized buffering strategy will use the uniform compatibility mode\n      default: {\n        this.setBufferManager(new UniformBufferManager(this, scene));\n        break;\n      }\n    }\n  }\n\n  /**\n   * This checks the state of the layer and determines how it should handle it's\n   * diff event handlers\n   */\n  updateDiffHandlers() {\n    // See if there are any attributes that have  auto easing involved\n    const easing = (this.shaderIOInfo.instanceAttributes || []).find(check =>\n      Boolean(check && check.easing)\n    );\n\n    // Establish the diff processing this layer needs to do based on the Easing IO present\n    // This will ensure there is not already some diff manager handling already established as a base layer's\n    // implementation.\n    if (easing) {\n      if (this.picking.type === PickType.SINGLE) {\n        this.onDiffAdd = this.handleDiffAddWithPickingAndEasing;\n        this.onDiffRemove = this.handleDiffRemoveWithPickingAndEasing;\n      } else {\n        this.onDiffAdd = this.handleDiffAddWithEasing;\n        this.onDiffRemove = this.handleDiffRemoveWithEasing;\n      }\n    } else {\n      if (this.picking.type === PickType.SINGLE) {\n        this.onDiffAdd = this.handleDiffAddWithPicking;\n        this.onDiffRemove = this.handleDiffRemoveWithPicking;\n      }\n    }\n  }\n\n  /**\n   * This is the default implementation for onDiffManagerAdd that gets applied\n   * if easing is present in the layer's IO.\n   */\n  private handleDiffAddWithEasing(instance: T) {\n    instance.easingId = this.easingId;\n  }\n\n  /**\n   * Handles diff manager add operations when the layer has picking enabled\n   */\n  private handleDiffAddWithPicking(instance: T) {\n    // Make sure the instance is mapped to it's UID\n    this.uidToInstance.set(instance.uid, instance);\n  }\n\n  /**\n   * Handles diff manager add operations when the layer has picking AND easing\n   * enabled\n   */\n  private handleDiffAddWithPickingAndEasing(instance: T) {\n    // Make sure the instance is mapped to it's UID\n    this.uidToInstance.set(instance.uid, instance);\n    // Make sure the instance has it's easing identifiers available for it's use within this layer\n    instance.easingId = this.easingId;\n  }\n\n  /**\n   * This is the default implementation for onDiffManagerRemove that gets\n   * applied if easing is present in the layer's IO\n   */\n  private handleDiffRemoveWithEasing(instance: T) {\n    if (instance.easing) delete instance.easing;\n    delete instance.easingId;\n  }\n\n  /**\n   * Handles diff manager remove operations when the layer has picking enabled\n   */\n  private handleDiffRemoveWithPicking(instance: T) {\n    // Remove the instance from our identifier list to prevent memory zombies\n    this.uidToInstance.delete(instance.uid);\n  }\n\n  /**\n   * Handles diff manager remove operations when the layer has picking AND\n   * easing enabled\n   */\n  private handleDiffRemoveWithPickingAndEasing(instance: T) {\n    // Remove the instance from our identifier list to prevent memory zombies\n    this.uidToInstance.delete(instance.uid);\n    // Remove the reference to the easing identifiers to prevent memory zombies\n    if (instance.easing) delete instance.easing;\n    delete instance.easingId;\n  }\n\n  /**\n   * This tells the framework to rebuild the layer from scratch, thus\n   * reconstructing the shaders and geometries of the layer.\n   */\n  rebuildLayer() {\n    this.willRebuildLayer = true;\n\n    // Children will be rebuilt as well\n    if (this.children) {\n      for (let i = 0, iMax = this.children.length; i < iMax; ++i) {\n        const child = this.children[i];\n        child.rebuildLayer();\n      }\n    }\n  }\n\n  /**\n   * Retrieves the changes from the data provider and resolves the provider.\n   * This should be used by sub Layer classes that wish to create their own\n   * custom draw handlers.\n   *\n   * Set preserverProvider to true to let the system know the provider's changes\n   * are still required.\n   */\n  resolveChanges(preserveProvider?: boolean) {\n    // Consume the diffs for the instances to update each element\n    const changeList = this.props.data.changeList;\n    // Set needsViewDrawn to be true if there is any change\n    if (changeList.length > 0) this.needsViewDrawn = true;\n\n    // See if we should make the provider not consume it's changes yet\n    if (!preserveProvider) {\n      // Resolve the changes from the provider so it can start collecting\n      // a new list of changes to apply\n      this.props.data.resolve(this.id);\n    }\n\n    // Clear the changes from all instances to be ready for next frame\n    for (let i = 0, iMax = changeList.length; i < iMax; ++i) {\n      changeList[i][0].changes = {};\n    }\n\n    // Return the list of changes so the changes can be handled in some fashion\n    return changeList;\n  }\n\n  /**\n   * Applies a buffer manager to the layer which handles instance changes and\n   * applies those changes to an appropriate buffer at the appropriate location.\n   */\n  setBufferManager(bufferManager: BufferManagerBase<T, IBufferLocation>) {\n    if (!this._bufferManager) {\n      this._bufferManager = bufferManager;\n      this.diffManager = new InstanceDiffManager<T>();\n      this.diffManager.makeProcessor(this, bufferManager);\n    } else {\n      console.warn(\n        \"You can not change a layer's buffer strategy once it has been instantiated.\"\n      );\n    }\n  }\n\n  /**\n   * Only allows the buffer type to be set once\n   */\n  setBufferType(val: LayerBufferType) {\n    if (this._bufferType === undefined) {\n      this._bufferType = val;\n    } else {\n      console.warn(\n        \"You can not change a layers buffer strategy once it has been instantiated.\"\n      );\n    }\n  }\n\n  /**\n   * This method returns a flag indicating whether or not the layer should\n   * trigger it's view to redraw. By default, a redraw is triggered (this\n   * returns true) when a shallow comparison of the current props and the\n   * incoming props are different. This method can be overridden to place custom\n   * logic at this point to indicate when redraws should happen.\n   *\n   * NOTE: This should be considered for redraw logic centered around changes in\n   * the layer itself. There ARE additional triggers in the system that causes\n   * redraws. This method just aids in ensuring necessary redraws take place for\n   * layer level logic and props.\n   */\n  shouldDrawView(oldProps: U, newProps: U) {\n    for (const key in newProps) {\n      if (newProps[key] !== oldProps[key]) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * This triggers the layer to update the material uniforms that have been\n   * created for the layer. This is primarily used internally.\n   */\n  updateUniforms() {\n    let uniform: IUniformInternal;\n    let value: UniformIOValue;\n\n    // Loop through the uniforms that are across all instances\n    for (let i = 0, end = this.shaderIOInfo.uniforms.length; i < end; ++i) {\n      uniform = this.shaderIOInfo.uniforms[i];\n      value = uniform.update(uniform);\n      uniform.materialUniforms.forEach(\n        materialUniform => (materialUniform.value = value)\n      );\n    }\n  }\n\n  /**\n   * Lifecycle: Fires before the props object is updated with the newProps.\n   * Allows layer to respond to diff changes.\n   */\n  willUpdateProps(newProps: ILayerProps<T>) {\n    // Pick type changes needs to trigger layer rebuild.\n    if (newProps.picking !== this.props.picking) {\n      this.rebuildLayer();\n    }\n\n    // Populate the ref with the information of this layer\n    if (newProps.ref !== this.props.ref && this.props.ref) {\n      this.props.ref.easing = this.easingManager;\n    }\n  }\n}\n","export interface IShaderTemplateResults {\n  /** This is the resulting shader string generated from the templating */\n  shader: string;\n  /** This is the template options provided by the shader. {option: num occurrences} */\n  shaderProvidedOptions: Map<string, number>;\n  /**\n   * This is the template options provided by the shader that were not resolved by the options parameter\n   * {option: num occurrences}\n   */\n  unresolvedShaderOptions: Map<string, number>;\n  /** This is the options provided to the template that did not get resolved by the shader {option: 1} */\n  unresolvedProvidedOptions: Map<string, number>;\n  /** This is the list of options that DID get resolved by the options provided {option: num occurrences} */\n  resolvedShaderOptions: Map<string, number>;\n}\n\nexport interface IShaderTemplateRequirements {\n  /** A string identifier to make it easier to identify which shader template failed requirements */\n  name: string;\n  /** The options that must be present within both provided options AND within the template */\n  values: string[];\n}\n\nexport interface IShaderTemplateOptions {\n  /** Callback for 'required' errors being emitted */\n  onError?(msg: string): void;\n  /** Callback that allows overrides for token replacement. Provides the token found and the suggested replacement for it */\n  onToken?(token: string, replace: string): string;\n  /**\n   * If this is provided, the shader templater will search out the void main method of the shader and provide the body\n   * contents of that main() method. You can edit those body contents and return the edited value to replace the body\n   * with those contents.\n   *\n   * If the body in the callback is null, then that means a main() method could NOT be determined.\n   */\n  onMain?(\n    body: string | null,\n    header?: string\n  ): string | { main: string; header: string };\n\n  /** This is a key value pair the template uses to match tokens found to replacement values */\n  options?: { [key: string]: string };\n  /** This is used to indicate which tokens are required both within the shader AND within the 'options' */\n  required?: IShaderTemplateRequirements;\n  /** This is the shader written with templating information */\n  shader: string;\n}\n\n/**\n * This is a method that aids in making shaders a bit more dynamic with simple string replacement based on tokens written\n * into the shader. Tokens in the shader will appear as ${token} and will either be ignored by this method and thus removed\n * or will be replaced with a provided value.\n *\n * This method will give feedback on the replacements taking place and simplify the process of detecting errors within the process.\n */\nexport function shaderTemplate(\n  templateOptions: IShaderTemplateOptions\n): IShaderTemplateResults {\n  const {\n    shader,\n    options = {},\n    required,\n    onError,\n    onToken,\n    onMain\n  } = templateOptions;\n  const matched = new Map<string, number>();\n  const noValueProvided = new Map<string, number>();\n  const notFound = new Map<string, number>();\n  const shaderOptions = new Map<string, number>();\n\n  const shaderResults = shader.replace(\n    /\\$\\{([^\\}]*)\\}/g,\n    (_x: string, match: string) => {\n      let replace = \"\";\n      shaderOptions.set(match, (shaderOptions.get(match) || 0) + 1);\n\n      if (match in options) {\n        matched.set(match, (matched.get(match) || 0) + 1);\n        replace = options[match];\n      } else {\n        noValueProvided.set(match, (noValueProvided.get(match) || 0) + 1);\n      }\n\n      if (onToken) {\n        replace = onToken(match, replace);\n      }\n\n      return replace;\n    }\n  );\n\n  Object.keys(options).forEach(option => {\n    if (!matched.get(option)) {\n      notFound.set(option, (notFound.get(option) || 0) + 1);\n    }\n  });\n\n  // Provide metrics\n  const results = {\n    resolvedShaderOptions: matched,\n    shader: shaderResults,\n    shaderProvidedOptions: shaderOptions,\n    unresolvedProvidedOptions: notFound,\n    unresolvedShaderOptions: noValueProvided\n  };\n\n  if (required) {\n    // This will ensure that BOTH the parameter input AND the shader provided the required options.\n    required.values.forEach(require => {\n      if (results.unresolvedProvidedOptions.get(require)) {\n        const msg = `${required.name}: Could not resolve all the required inputs. Input: ${require}`;\n        if (onError) onError(msg);\n        else console.error(msg);\n      } else if (results.unresolvedShaderOptions.get(require)) {\n        const msg = `${required.name}: A required option was not provided in the options parameter. Option: ${require}`;\n        if (onError) onError(msg);\n        else console.error(msg);\n      } else if (!results.resolvedShaderOptions.get(require)) {\n        const msg = `${required.name}: A required option was not provided in the options parameter. Option: ${require}`;\n        if (onError) onError(msg);\n        else console.error(msg);\n      }\n    });\n  }\n\n  // If onMain is specified, then the caller is wanting to manipulate the body\n  // of the main method of the shader\n  if (onMain) {\n    const shader = results.shader;\n    // Use this regex to find the beginning of the main method up to it's\n    // opening bracket.\n    const found = shader.match(\n      /void((.+)|\\s)(main(\\s+)\\(\\)|main\\(\\))(((.+)(\\s*)\\{)|(\\s*)\\{)/gm\n    );\n    if (found && found.length > 0) {\n      const start = shader.indexOf(found[0]);\n      // Validate we found something useful\n      if (start < 0) onMain(null);\n      // At this point, we can take the shader and get a string that starts with\n      // the body of the void main() method.\n      else {\n        const header = shader.substr(0, start);\n        const bodyStart = shader.substr(start + found[0].length);\n        // We now must count valid context brackets till we find a bracket that\n        // would close the context of the main body.\n        let insideMultiLine = false;\n        let insideSingleLine = false;\n        let openBracket = 1;\n        let closeBracket = 0;\n        let endBody = -1;\n\n        // When openBracket === close bracket, we have the location of the end\n        // of the body of the main method\n        for (let i = 0, iMax = bodyStart.length; i < iMax; ++i) {\n          const char = bodyStart[i];\n          const nextChar = bodyStart[i + 1];\n\n          // Analyze each character for comments and valid bracket contexts\n          switch (char) {\n            case \"/\":\n              switch (nextChar) {\n                case \"*\":\n                  if (!insideMultiLine && !insideSingleLine) {\n                    insideMultiLine = true;\n                    i++;\n                  }\n                  break;\n\n                case \"/\":\n                  if (!insideMultiLine && !insideSingleLine) {\n                    insideSingleLine = true;\n                    i++;\n                  }\n                  break;\n              }\n              break;\n\n            case \"*\":\n              if (nextChar === \"/\") {\n                if (!insideSingleLine) {\n                  insideMultiLine = false;\n                  i++;\n                }\n              }\n              break;\n\n            case \"\\n\":\n            case \"\\r\":\n              if (!insideMultiLine) {\n                insideSingleLine = false;\n              }\n              break;\n\n            case \"{\":\n              if (!insideMultiLine && !insideSingleLine) {\n                openBracket++;\n              }\n              break;\n\n            case \"}\":\n              if (!insideMultiLine && !insideSingleLine) {\n                closeBracket++;\n              }\n\n              if (openBracket === closeBracket) {\n                endBody = i;\n              }\n              break;\n          }\n\n          // If end body is detected, then we stop looping\n          if (endBody !== -1) {\n            break;\n          }\n        }\n\n        if (endBody !== -1) {\n          const body = bodyStart.substr(0, endBody);\n          const footer = bodyStart.substr(endBody + 1);\n          const modifiedBody = onMain(body, `${header}\\n${footer}`);\n\n          if (typeof modifiedBody === \"string\") {\n            results.shader =\n              shader.substr(0, start + found[0].length) +\n              modifiedBody +\n              shader.substr(start + found[0].length + endBody);\n          } else {\n            results.shader =\n              shader.substr(0, start) +\n              modifiedBody.header +\n              shader.substr(start, found[0].length) +\n              modifiedBody.main +\n              shader.substr(start + found[0].length + endBody);\n          }\n        } else {\n          onMain(null);\n        }\n      }\n    }\n  }\n\n  return results;\n}\n","import { Geometry, GLSettings, Material, Model } from \"../../gl\";\n\nexport function generateLayerModel(\n  geometry: Geometry,\n  material: Material,\n  drawMode?: GLSettings.Model.DrawMode\n): Model {\n  const model = new Model(geometry, material);\n  model.drawMode = drawMode || GLSettings.Model.DrawMode.TRIANGLE_STRIP;\n\n  return model;\n}\n","import { Camera, CameraProjectionType } from \"../../util/camera\";\nimport { Control2D, IControl2DOptions } from \"./control-2d\";\n\n/**\n * This is a complex camera that layers simpler 2D concepts over an actual 3D projection camera. This camera FORCES the\n * orthographic projection type to work with the 2D layering system created.\n *\n * Essentially this Camera is a two layer concept rolled into one. This is done this way to make the front end API\n * simpler to use and understand while providing ease of use and conveniences for the 2D layer system.\n */\nexport class Camera2D extends Camera {\n  /** These are the 2d controls to make manipulating a 2D world easier */\n  control2D: Control2D;\n\n  get scale2D() {\n    return this.control2D.scale;\n  }\n\n  get offset() {\n    return this.control2D.offset;\n  }\n\n  constructor(options?: IControl2DOptions) {\n    // Force this 2d camera to be an orthographic projection type\n    super({\n      left: -100,\n      right: 100,\n      top: -100,\n      bottom: 100,\n      near: -100,\n      far: 100000,\n      type: CameraProjectionType.ORTHOGRAPHIC\n    });\n\n    // Generate the controller that manipulates our 2D world\n    this.control2D = new Control2D(this, options);\n  }\n}\n","import {\n  AutoEasingMethod,\n  IAutoEasingMethod\n} from \"../../math/auto-easing-method\";\nimport { copy3, divide3, scale3, subtract3, Vec3 } from \"../../math/vector\";\nimport { Surface } from \"../../surface\";\nimport { uid } from \"../../util/uid\";\nimport { Camera2D } from \"./camera-2d\";\n\nexport interface IControl2DOptions {\n  /** The world space offset of elements in the chart */\n  offset?: Vec3;\n  /** The world space scaling present in the chart */\n  scale?: Vec3;\n}\n\nconst immediateAnimation = AutoEasingMethod.immediate<Vec3>(0);\n\n/**\n * Controls for 2D world manipulation\n */\nexport class Control2D {\n  get id() {\n    return this._id;\n  }\n  private _id: number = uid();\n\n  /** The animation set to this camera to animate it's scale and offset */\n  animation: IAutoEasingMethod<Vec3> = AutoEasingMethod.immediate(0);\n  /** This records when the end of the animation for the camera will be completed */\n  animationEndTime: number = 0;\n  /** The 2d camera to work with */\n  camera: Camera2D;\n  /** Indicates which time frame the offset was retrieved so it will only broadcast a change event once for that timeframe */\n  private offsetBroadcastTime: number = 0;\n  /** Indicates which time frame the scale was retrieved so it will only broadcast a change event once for that timeframe */\n  private scaleBroadcastTime: number = 0;\n  /** Represents how much an element should be offset in world space */\n  private _offset: Vec3 = [0, 0, 0];\n  private startOffset: Vec3 = [0, 0, 0];\n  private startOffsetTime: number = 0;\n  private offsetEndTime: number = 0;\n  /** Represents how scaled each axis should be in world space */\n  private _scale: Vec3 = [1, 1, 1];\n  private startScale: Vec3 = [1, 1, 1];\n  private startScaleTime: number = 0;\n  private scaleEndTime: number = 0;\n  /** This is the surface the camera is controlled by */\n  surface: Surface;\n  /** When set, this will broadcast any change in the camera that will affect the view range */\n  private onViewChange?: (camera: Camera2D, view: string) => void;\n  /** Flag indicating the camera needs to broadcast it's changes */\n  private needsBroadcast = false;\n\n  constructor(camera: Camera2D, options?: IControl2DOptions) {\n    this.camera = camera;\n\n    if (options) {\n      this._offset = copy3(options.offset || this._offset);\n      this._scale = copy3(options.scale || this._scale);\n    }\n  }\n\n  /**\n   * Performs the broadcast of changes for the camera if the camera needed a broadcast.\n   */\n  broadcast(viewId: string) {\n    // First we do a simple get of the animated properties. This will cause the broadcast flag to\n    // be set if there are any changes for the current frame.\n    this.offset;\n    this.scale;\n\n    // If the broadcast flag get's set, we should emit the event for the change.\n    if (this.needsBroadcast) {\n      this.needsBroadcast = false;\n      if (this.onViewChange) this.onViewChange(this.camera, viewId);\n    }\n  }\n\n  /**\n   * Adjusts offset to set the middle at the provided location relative to a provided view.\n   */\n  centerOn(viewId: string, position: Vec3) {\n    const viewBounds = this.surface.getViewSize(viewId);\n    if (!viewBounds) return;\n    const midScreen: Vec3 = [viewBounds.width / 2, viewBounds.height / 2, 0];\n    const fromScreenCenter: Vec3 = subtract3(\n      position,\n      divide3(midScreen, this._scale)\n    );\n\n    const currentAnimation = this.animation;\n    this.setOffset(copy3(this.offset));\n    this.animation = immediateAnimation;\n    this.setOffset(scale3(fromScreenCenter, -1));\n    this.animation = currentAnimation;\n  }\n\n  /**\n   * Retrieves the current frame's time from the surface this camera is managed under.\n   */\n  private getCurrentTime() {\n    if (this.surface) {\n      return this.surface.frameMetrics.currentTime;\n    }\n\n    return 0;\n  }\n\n  /**\n   * Gets the source offset value\n   */\n  getOffset() {\n    return this._offset;\n  }\n\n  /**\n   * Gets the source scale value\n   */\n  getScale() {\n    return this._scale;\n  }\n\n  /**\n   * Retrieves the animated value of the offset of the camera.\n   * To get a non-animated version of the offset use getOffset()\n   */\n  get offset() {\n    const currentTime = this.getCurrentTime();\n\n    if (this.onViewChange) {\n      if (this.offsetBroadcastTime < this.offsetEndTime) {\n        this.offsetBroadcastTime = currentTime;\n        this.needsBroadcast = true;\n      }\n    }\n\n    return this.animation.cpu(\n      this.startOffset,\n      this._offset,\n      (currentTime - this.startOffsetTime) / this.animation.duration\n    );\n  }\n\n  /**\n   * Sets the id of this camera\n   */\n  setId(id: number) {\n    this._id = id;\n    this.camera.needsViewDrawn = true;\n  }\n\n  /**\n   * Sets the location of the camera by adjusting the offsets to match.\n   * Whatever is set for the \"animation\" property determines the animation.\n   */\n  setOffset(offset: Vec3) {\n    // Start offset is the offset of the camera at the current evaluated time\n    this.startOffset = copy3(this.offset);\n    // Copy the new end offset value\n    this._offset = copy3(offset);\n    // Get the current time as our starter time of the animating\n    this.startOffsetTime = this.getCurrentTime();\n    // Get the time the offset will complete\n    this.offsetEndTime = this.startOffsetTime + this.animation.duration;\n    // The total animation end time will be the max end time of all animateable properties\n    this.updateEndTime();\n    // Flag the view for a redraw\n    this.camera.needsViewDrawn = true;\n\n    // Broadcast change\n    if (this.onViewChange) {\n      this.offsetBroadcastTime = this.startOffsetTime;\n      this.needsBroadcast = true;\n    }\n  }\n\n  /**\n   * Retrieves the animated scale. If you want straight end scale value, use getScale()\n   */\n  get scale() {\n    const currentTime = this.getCurrentTime();\n\n    if (this.onViewChange) {\n      if (this.scaleBroadcastTime < this.scaleEndTime) {\n        this.scaleBroadcastTime = currentTime;\n        this.needsBroadcast = true;\n      }\n    }\n\n    return this.animation.cpu(\n      this.startScale,\n      this._scale,\n      (currentTime - this.startScaleTime) / this.animation.duration\n    );\n  }\n\n  /**\n   * Applies the handler for broadcasting view changes from the camera.\n   */\n  setViewChangeHandler(handler: Control2D[\"onViewChange\"]) {\n    this.onViewChange = handler;\n  }\n\n  /**\n   * Sets and animates the scale of the camera.\n   * Whatever is set for the \"animation\" property determines the animation.\n   */\n  setScale(scale: Vec3) {\n    // Start scale is the scale of the camera at the current evaluated time\n    this.startScale = copy3(this.scale);\n    // Store the destination value of the scale\n    this._scale = copy3(scale);\n    // Start of the animation is now\n    this.startScaleTime = this.getCurrentTime();\n    // Get the time the scale will complete animation\n    this.scaleEndTime = this.startScaleTime + this.animation.duration;\n    // Update end animation time\n    this.updateEndTime();\n    // Flag this as needing a redraw so all views using it will update.\n    this.camera.needsViewDrawn = true;\n\n    // Broadcast change\n    if (this.onViewChange) {\n      this.scaleBroadcastTime = this.startScaleTime;\n      this.needsBroadcast = true;\n    }\n  }\n\n  /**\n   * Resolves all flags indicating updates needed.\n   */\n  resolve() {\n    this.camera.needsViewDrawn = false;\n    this.needsBroadcast = false;\n  }\n\n  update() {\n    this.camera.needsViewDrawn = true;\n  }\n\n  private updateEndTime() {\n    this.animationEndTime = Math.max(this.scaleEndTime, this.offsetEndTime);\n  }\n}\n","import { Texture } from \"../../gl/texture\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport {\n  ShaderDeclarationStatements,\n  ShaderIOHeaderInjectionResult\n} from \"../../shaders/processing/base-shader-io-injection\";\nimport { MetricsProcessing } from \"../../shaders/processing/metrics-processing\";\nimport { ILayerProps, Layer } from \"../../surface/layer\";\nimport {\n  BaseIOExpansion,\n  ShaderIOExpansion\n} from \"../../surface/layer-processing/base-io-expansion\";\nimport {\n  IInstanceAttribute,\n  InstanceAttributeSize,\n  IResourceInstanceAttribute,\n  IResourceType,\n  IUniform,\n  IValueInstanceAttribute,\n  IVertexAttribute,\n  ShaderInjectionTarget,\n  UniformSize\n} from \"../../types\";\nimport { ResourceRouter } from \"../resource-router\";\n\nconst debugCtx = \"TextureIOExpansion\";\n\n/** Resource Attribute typeguard */\nfunction isTextureAttribute<T extends Instance>(\n  attr: any,\n  router: ResourceRouter,\n  resourceType: number\n): attr is IResourceInstanceAttribute<T> {\n  return (\n    attr &&\n    attr.resource &&\n    router.getResourceType(attr.resource.key()) === resourceType &&\n    attr.resource.name !== undefined &&\n    attr.resource.key !== undefined\n  );\n}\n\n/**\n * Minimal information a resource is required to have to operate for this\n * expander.\n */\ninterface ITextureIOExpansionResource extends IResourceType {\n  texture: Texture;\n}\n\n/**\n * Minimal manager requirements for being applied to this expanded.\n */\ninterface ITextureResourceManager {\n  /** The router all resources flow through */\n  router: ResourceRouter;\n  /** A method for retrieving the resource by the resources key id */\n  getResource(key: string): ITextureIOExpansionResource | null;\n}\n\n/**\n * This is an expansion handler for resource attributes that requires a texture\n * to be included as a uniform on behalf of the attribute.\n */\nexport class TextureIOExpansion extends BaseIOExpansion {\n  /** The manager which will contain the texture object to be used */\n  manager: ITextureResourceManager;\n  /** The resource type this expansion filters on */\n  resourceType: number;\n\n  constructor(resourceType: number, manager: ITextureResourceManager) {\n    super();\n    this.manager = manager;\n    this.resourceType = resourceType;\n  }\n\n  /**\n   * Provides expanded IO for attributes with resource properties.\n   */\n  expand<T extends Instance, U extends ILayerProps<T>>(\n    _layer: Layer<T, U>,\n    instanceAttributes: IInstanceAttribute<T>[],\n    _vertexAttributes: IVertexAttribute[],\n    _uniforms: IUniform[]\n  ): ShaderIOExpansion<T> {\n    // Pull down the manager to this method's context\n    const manager = this.manager;\n    // Retrieve all of the instance attributes that are atlas references\n    const atlasInstanceAttributes: IResourceInstanceAttribute<T>[] = [];\n    // Key: The atlas uniform name requested\n    const requestedTextureInjections = new Map<string, [boolean, boolean]>();\n\n    // Get the atlas requests that have unique names. We only need one uniform\n    // For a single unique provided name. We also must merge the requests for\n    // Vertex and fragment injections\n    instanceAttributes.forEach(\n      (\n        attribute: IValueInstanceAttribute<T> | IResourceInstanceAttribute<T>\n      ) => {\n        if (\n          isTextureAttribute(attribute, this.manager.router, this.resourceType)\n        ) {\n          // Auto set the size of the attribute. Attribute's that are a resource\n          // automatically Consume a size of four unless otherwise stated by the\n          // attribute\n          if (attribute.size === undefined) {\n            attribute.size = InstanceAttributeSize.FOUR;\n          }\n\n          // Get the atlas resource uniform (sampler2D) injection targets. We\n          // default to only the Fragment shader as it's the most commonly used\n          // location for sampler2Ds\n          const injection: number =\n            attribute.resource.shaderInjection ||\n            ShaderInjectionTarget.FRAGMENT;\n          // See if we already have an injection for the given injected uniform\n          // name for an atlas resource.\n          const injections = requestedTextureInjections.get(\n            attribute.resource.name\n          );\n\n          if (injections) {\n            requestedTextureInjections.set(attribute.resource.name, [\n              injections[0] ||\n                injection === ShaderInjectionTarget.VERTEX ||\n                injection === ShaderInjectionTarget.ALL,\n              injections[1] ||\n                injection === ShaderInjectionTarget.FRAGMENT ||\n                injection === ShaderInjectionTarget.ALL\n            ]);\n          } else {\n            atlasInstanceAttributes.push(attribute);\n            requestedTextureInjections.set(attribute.resource.name, [\n              injection === ShaderInjectionTarget.VERTEX ||\n                injection === ShaderInjectionTarget.ALL,\n              injection === ShaderInjectionTarget.FRAGMENT ||\n                injection === ShaderInjectionTarget.ALL\n            ]);\n          }\n        }\n      }\n    );\n\n    // Make uniforms for all of the unique atlas requests.\n    const uniforms = atlasInstanceAttributes.map(\n      (instanceAttribute): IUniform[] => {\n        let injection: ShaderInjectionTarget = ShaderInjectionTarget.FRAGMENT;\n\n        if (instanceAttribute.resource) {\n          const injections = requestedTextureInjections.get(\n            instanceAttribute.resource.name\n          );\n\n          if (injections) {\n            injection =\n              (injections[0] && injections[1] && ShaderInjectionTarget.ALL) ||\n              (injections[0] &&\n                !injections[1] &&\n                ShaderInjectionTarget.VERTEX) ||\n              (!injections[0] &&\n                injections[1] &&\n                ShaderInjectionTarget.FRAGMENT) ||\n              injection;\n          }\n        }\n\n        return [\n          // This injects the sampler that the shader will use for sampling\n          // texels\n          {\n            name: instanceAttribute.resource.name,\n            shaderInjection: injection,\n            size: UniformSize.TEXTURE,\n            update: () => {\n              const resource = manager.getResource(\n                instanceAttribute.resource.key()\n              );\n\n              if (resource) {\n                return resource.texture || Texture.emptyTexture;\n              }\n\n              return Texture.emptyTexture;\n            }\n          },\n          // This provides the size of the texture that is applied to the\n          // sampler.\n          {\n            name: `${instanceAttribute.resource.name}_size`,\n            shaderInjection: injection,\n            size: UniformSize.TWO,\n            update: () => {\n              const resource = manager.getResource(\n                instanceAttribute.resource.key()\n              );\n\n              if (resource) {\n                const texture = resource.texture;\n\n                if (texture && texture.data) {\n                  const { width, height } = texture.data;\n                  return [width || 1, height || 1];\n                }\n              }\n\n              return [1, 1];\n            }\n          }\n        ];\n      }\n    );\n\n    const flatten: IUniform[] = [];\n    uniforms.forEach(list => list.forEach(uniform => flatten.push(uniform)));\n\n    return {\n      instanceAttributes: [],\n      vertexAttributes: [],\n      uniforms: flatten\n    };\n  }\n\n  /**\n   * Validates the IO about to be expanded.\n   */\n  validate<T extends Instance, U extends ILayerProps<T>>(\n    _layer: Layer<T, U>,\n    instanceAttributes: IInstanceAttribute<T>[],\n    _vertexAttributes: IVertexAttribute[],\n    _uniforms: IUniform[]\n  ): boolean {\n    let foundError = false;\n\n    instanceAttributes.forEach(attribute => {\n      if (attribute.easing && attribute.resource) {\n        console.warn(\n          \"An instance attribute can not have both easing and resource properties. Undefined behavior will occur.\"\n        );\n        console.warn(attribute);\n\n        foundError = true;\n      }\n    });\n\n    return !foundError;\n  }\n\n  /**\n   * For texture resources, we need the uniforms with a size of ATLAS to be\n   * injected as a sampler2D instead of a vector sizing which the basic io\n   * expansion can only provide.\n   */\n  processHeaderInjection(\n    target: ShaderInjectionTarget,\n    declarations: ShaderDeclarationStatements,\n    _layer: Layer<Instance, ILayerProps<Instance>>,\n    _metrics: MetricsProcessing,\n    _vertexAttributes: IVertexAttribute[],\n    _instanceAttributes: IInstanceAttribute<Instance>[],\n    uniforms: IUniform[]\n  ): ShaderIOHeaderInjectionResult {\n    const out = {\n      injection: \"\"\n    };\n\n    for (let i = 0, iMax = uniforms.length; i < iMax; ++i) {\n      const uniform = uniforms[i];\n      const injection = uniform.shaderInjection || ShaderInjectionTarget.VERTEX;\n\n      if (uniform.size === UniformSize.TEXTURE && injection === target) {\n        this.setDeclaration(\n          declarations,\n          uniform.name,\n          `uniform sampler2D ${uniform.name};\\n`,\n          debugCtx\n        );\n      }\n    }\n\n    return out;\n  }\n}\n","import { EventManager } from \"./event-manager\";\nimport { IMouseInteraction, ITouchInteraction } from \"./types\";\n\n/**\n * This is a simple way to access the events executing on the chart.\n */\nexport class SimpleEventHandler extends EventManager {\n  constructor(handlers: Partial<EventManager>) {\n    super();\n    Object.assign(this, handlers);\n  }\n\n  handleMouseDown(_e: IMouseInteraction): void {\n    /* No op */\n  }\n\n  handleMouseUp(_e: IMouseInteraction): void {\n    /* No op */\n  }\n\n  handleMouseOver(_e: IMouseInteraction): void {\n    /* No op */\n  }\n\n  handleMouseOut(_e: IMouseInteraction): void {\n    /* No op */\n  }\n\n  handleMouseMove(_e: IMouseInteraction): void {\n    /* No op */\n  }\n\n  handleClick(_e: IMouseInteraction): void {\n    /* No op */\n  }\n\n  handleDrag(_e: IMouseInteraction): void {\n    /* No op */\n  }\n\n  handleWheel(_e: IMouseInteraction): void {\n    /* No op */\n  }\n\n  handleTouchCancelled(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleTouchDown(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleTouchUp(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleTouchOut(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleTouchDrag(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleTap(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleDoubleTap(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleLongTouch(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleLongTap(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handlePinch(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleSpread(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleTouchRotate(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleSwipe(_e: ITouchInteraction): void {\n    /* No op */\n  }\n}\n","import { GLSettings } from \"./gl-settings\";\nimport { GLContext, IExtensions } from \"./types\";\nimport { WebGLStat } from \"./webgl-stat\";\n\n/**\n * This file contains all method used to decode/encode GLSettings to GL types\n */\n\n/**\n * Decodes a DrawMode to a GL setting\n */\nexport function drawMode(gl: GLContext, mode: GLSettings.Model.DrawMode) {\n  switch (mode) {\n    case GLSettings.Model.DrawMode.LINES:\n      return gl.LINES;\n    case GLSettings.Model.DrawMode.LINE_LOOP:\n      return gl.LINE_LOOP;\n    case GLSettings.Model.DrawMode.LINE_STRIP:\n      return gl.LINE_STRIP;\n    case GLSettings.Model.DrawMode.POINTS:\n      return gl.POINTS;\n    case GLSettings.Model.DrawMode.TRIANGLES:\n      return gl.TRIANGLES;\n    case GLSettings.Model.DrawMode.TRIANGLE_FAN:\n      return gl.TRIANGLE_FAN;\n    case GLSettings.Model.DrawMode.TRIANGLE_STRIP:\n      return gl.TRIANGLE_STRIP;\n\n    default:\n      return gl.TRIANGLES;\n  }\n}\n\n/**\n * Decodes the TexelDataType to a GL setting\n */\nexport function texelFormat(\n  gl: GLContext,\n  format: GLSettings.Texture.TexelDataType\n) {\n  switch (format) {\n    case GLSettings.Texture.TexelDataType.Alpha:\n      return gl.ALPHA;\n    case GLSettings.Texture.TexelDataType.DepthComponent:\n      return gl.DEPTH_COMPONENT;\n    case GLSettings.Texture.TexelDataType.DepthStencil:\n      return gl.DEPTH_STENCIL;\n    case GLSettings.Texture.TexelDataType.Luminance:\n      return gl.LUMINANCE;\n    case GLSettings.Texture.TexelDataType.LuminanceAlpha:\n      return gl.LUMINANCE_ALPHA;\n    case GLSettings.Texture.TexelDataType.RGB:\n      return gl.RGB;\n    case GLSettings.Texture.TexelDataType.RGBA:\n      return gl.RGBA;\n\n    default:\n      if (gl instanceof WebGL2RenderingContext) {\n        switch (format) {\n          case GLSettings.Texture.TexelDataType.R8:\n            return gl.R8;\n          case GLSettings.Texture.TexelDataType.R16F:\n            return gl.R16F;\n          case GLSettings.Texture.TexelDataType.R32F:\n            return gl.R32F;\n          case GLSettings.Texture.TexelDataType.R8UI:\n            return gl.R8UI;\n          case GLSettings.Texture.TexelDataType.RG8:\n            return gl.RG8;\n          case GLSettings.Texture.TexelDataType.RG16F:\n            return gl.RG16F;\n          case GLSettings.Texture.TexelDataType.RG32F:\n            return gl.RG32F;\n          case GLSettings.Texture.TexelDataType.RG8UI:\n            return gl.RG8UI;\n          case GLSettings.Texture.TexelDataType.RG16UI:\n            return gl.RG16UI;\n          case GLSettings.Texture.TexelDataType.RG32UI:\n            return gl.RG32UI;\n          case GLSettings.Texture.TexelDataType.RGB8:\n            return gl.RGB8;\n          case GLSettings.Texture.TexelDataType.SRGB8:\n            return gl.SRGB8;\n          case GLSettings.Texture.TexelDataType.RGB565:\n            return gl.RGB565;\n          case GLSettings.Texture.TexelDataType.R11F_G11F_B10F:\n            return gl.R11F_G11F_B10F;\n          case GLSettings.Texture.TexelDataType.RGB9_E5:\n            return gl.RGB9_E5;\n          case GLSettings.Texture.TexelDataType.RGB16F:\n            return gl.RGB16F;\n          case GLSettings.Texture.TexelDataType.RGB32F:\n            return gl.RGB32F;\n          case GLSettings.Texture.TexelDataType.RGB8UI:\n            return gl.RGB8UI;\n          case GLSettings.Texture.TexelDataType.RGBA8:\n            return gl.RGBA8;\n          case GLSettings.Texture.TexelDataType.SRGB8_ALPHA8:\n            return gl.SRGB8_ALPHA8;\n          case GLSettings.Texture.TexelDataType.RGB5_A1:\n            return gl.RGB5_A1;\n          case GLSettings.Texture.TexelDataType.RGB10_A2:\n            return gl.RGB10_A2;\n          case GLSettings.Texture.TexelDataType.RGBA4:\n            return gl.RGBA4;\n          case GLSettings.Texture.TexelDataType.RGBA16F:\n            return gl.RGBA16F;\n          case GLSettings.Texture.TexelDataType.RGBA32F:\n            if (\n              WebGLStat.FLOAT_TEXTURE_READ.full &&\n              WebGLStat.FLOAT_TEXTURE_WRITE.full\n            ) {\n              return gl.RGBA32F;\n            } else {\n              return gl.RGBA16F;\n            }\n          case GLSettings.Texture.TexelDataType.RGBA8UI:\n            return gl.RGBA8UI;\n\n          case GLSettings.Texture.TexelDataType.DEPTH_COMPONENT16:\n            return gl.DEPTH_COMPONENT16;\n          case GLSettings.Texture.TexelDataType.DEPTH_COMPONENT24:\n            return gl.DEPTH_COMPONENT24;\n          case GLSettings.Texture.TexelDataType.DEPTH_COMPONENT32F:\n            return gl.DEPTH_COMPONENT32F;\n\n          case GLSettings.Texture.TexelDataType.RGBA32UI:\n            return gl.RGBA32UI;\n          case GLSettings.Texture.TexelDataType.RGB32UI:\n            return gl.RGB32UI;\n          case GLSettings.Texture.TexelDataType.RGBA16UI:\n            return gl.RGBA16UI;\n          case GLSettings.Texture.TexelDataType.RGB16UI:\n            return gl.RGB16UI;\n          case GLSettings.Texture.TexelDataType.RGBA32I:\n            return gl.RGBA32I;\n          case GLSettings.Texture.TexelDataType.RGB32I:\n            return gl.RGB32I;\n          case GLSettings.Texture.TexelDataType.RGBA16I:\n            return gl.RGBA16I;\n          case GLSettings.Texture.TexelDataType.RGB16I:\n            return gl.RGB16I;\n          case GLSettings.Texture.TexelDataType.RGBA8I:\n            return gl.RGBA8I;\n          case GLSettings.Texture.TexelDataType.RGB8I:\n            return gl.RGB8I;\n\n          default:\n            console.warn(\n              \"An unsupported texel format was provided that is not supported in WebGL 1 or 2\"\n            );\n            return gl.RGBA;\n        }\n      }\n\n      console.warn(\n        \"An Unsupported texel format was provided. Some formats are only available in WebGL 2\",\n        format\n      );\n      return gl.RGBA;\n  }\n}\n\n/**\n * Decodes the SourcePixelFormat to a GL setting\n */\nexport function inputImageFormat(\n  gl: GLContext,\n  format: GLSettings.Texture.SourcePixelFormat\n) {\n  switch (format) {\n    case GLSettings.Texture.SourcePixelFormat.Byte:\n      return gl.BYTE;\n    case GLSettings.Texture.SourcePixelFormat.Float:\n      return gl.FLOAT;\n    case GLSettings.Texture.SourcePixelFormat.HalfFloat:\n      console.warn(\"Unsupported HALF_FLOAT\");\n      return gl.BYTE;\n    case GLSettings.Texture.SourcePixelFormat.Int:\n      return gl.INT;\n    case GLSettings.Texture.SourcePixelFormat.Short:\n      return gl.SHORT;\n    case GLSettings.Texture.SourcePixelFormat.UnsignedByte:\n      return gl.UNSIGNED_BYTE;\n    case GLSettings.Texture.SourcePixelFormat.UnsignedInt:\n      return gl.UNSIGNED_INT;\n    case GLSettings.Texture.SourcePixelFormat.UnsignedShort:\n      return gl.UNSIGNED_SHORT;\n    case GLSettings.Texture.SourcePixelFormat.UnsignedShort_4_4_4_4:\n      return gl.UNSIGNED_SHORT_4_4_4_4;\n    case GLSettings.Texture.SourcePixelFormat.UnsignedShort_5_5_5_1:\n      return gl.UNSIGNED_SHORT_5_5_5_1;\n    case GLSettings.Texture.SourcePixelFormat.UnsignedShort_5_6_5:\n      return gl.UNSIGNED_SHORT_5_6_5;\n\n    default:\n      console.warn(\"An Unsupported input image format was provided\", format);\n      return gl.BYTE;\n  }\n}\n\n/**\n * Decodes TextureMagFilter to a GL setting\n */\nexport function magFilter(\n  gl: GLContext,\n  filter: GLSettings.Texture.TextureMagFilter\n) {\n  switch (filter) {\n    case GLSettings.Texture.TextureMagFilter.Linear:\n      return gl.LINEAR;\n    case GLSettings.Texture.TextureMagFilter.Nearest:\n      return gl.NEAREST;\n  }\n}\n\n/**\n * Decodes TextureMinFilter to a GL setting\n */\nexport function minFilter(\n  gl: GLContext,\n  filter: GLSettings.Texture.TextureMinFilter,\n  hasMipMaps: boolean\n) {\n  switch (filter) {\n    case GLSettings.Texture.TextureMinFilter.Linear:\n      return gl.LINEAR;\n    case GLSettings.Texture.TextureMinFilter.Nearest:\n      return gl.NEAREST;\n    case GLSettings.Texture.TextureMinFilter.LinearMipMapLinear:\n      return hasMipMaps ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR;\n    case GLSettings.Texture.TextureMinFilter.LinearMipMapNearest:\n      return hasMipMaps ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR;\n    case GLSettings.Texture.TextureMinFilter.NearestMipMapLinear:\n      return hasMipMaps ? gl.NEAREST_MIPMAP_LINEAR : gl.NEAREST;\n    case GLSettings.Texture.TextureMinFilter.NearestMipMapNearest:\n      return hasMipMaps ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST;\n\n    default:\n      return gl.LINEAR;\n  }\n}\n\n/**\n * Decodes a ColorBufferFormat to valid color render buffer storage formats\n *\n * Takes in any of the render buffer formats, but will default invalid color\n * buffer formats to RGBA4\n */\nexport function colorBufferFormat(\n  gl: GLContext,\n  format:\n    | GLSettings.RenderTarget.ColorBufferFormat\n    | GLSettings.RenderTarget.DepthBufferFormat\n    | GLSettings.RenderTarget.StencilBufferFormat\n) {\n  switch (format) {\n    case GLSettings.RenderTarget.ColorBufferFormat.RGB565:\n      return gl.RGB565;\n    case GLSettings.RenderTarget.ColorBufferFormat.RGB5_A1:\n      return gl.RGB5_A1;\n    case GLSettings.RenderTarget.ColorBufferFormat.RGBA4:\n      return gl.RGBA4;\n\n    default:\n      if (gl instanceof WebGL2RenderingContext) {\n        switch (format) {\n          case GLSettings.RenderTarget.ColorBufferFormat.R8:\n            return gl.R8;\n          case GLSettings.RenderTarget.ColorBufferFormat.R8UI:\n            return gl.R8UI;\n          case GLSettings.RenderTarget.ColorBufferFormat.R8I:\n            return gl.R8I;\n          case GLSettings.RenderTarget.ColorBufferFormat.R16UI:\n            return gl.R16UI;\n          case GLSettings.RenderTarget.ColorBufferFormat.R16I:\n            return gl.R16I;\n          case GLSettings.RenderTarget.ColorBufferFormat.R32UI:\n            return gl.R32UI;\n          case GLSettings.RenderTarget.ColorBufferFormat.R32I:\n            return gl.R32I;\n          case GLSettings.RenderTarget.ColorBufferFormat.RG8:\n            return gl.RG8;\n          case GLSettings.RenderTarget.ColorBufferFormat.RG8UI:\n            return gl.RG8UI;\n          case GLSettings.RenderTarget.ColorBufferFormat.RG8I:\n            return gl.RG8I;\n          case GLSettings.RenderTarget.ColorBufferFormat.RG16UI:\n            return gl.RG16UI;\n          case GLSettings.RenderTarget.ColorBufferFormat.RG16I:\n            return gl.RG16I;\n          case GLSettings.RenderTarget.ColorBufferFormat.RG32UI:\n            return gl.RG32UI;\n          case GLSettings.RenderTarget.ColorBufferFormat.RG32I:\n            return gl.RG32I;\n          case GLSettings.RenderTarget.ColorBufferFormat.RGB8:\n            return gl.RGB8;\n          case GLSettings.RenderTarget.ColorBufferFormat.RGBA8:\n            return gl.RGBA8;\n          case GLSettings.RenderTarget.ColorBufferFormat.SRGB8_ALPHA8:\n            return gl.SRGB8_ALPHA8;\n          case GLSettings.RenderTarget.ColorBufferFormat.RGB10_A2:\n            return gl.RGB10_A2;\n          case GLSettings.RenderTarget.ColorBufferFormat.RGBA8UI:\n            return gl.RGBA8UI;\n          case GLSettings.RenderTarget.ColorBufferFormat.RGBA8I:\n            return gl.RGBA8I;\n          case GLSettings.RenderTarget.ColorBufferFormat.RGB10_A2UI:\n            return gl.RGB10_A2UI;\n          case GLSettings.RenderTarget.ColorBufferFormat.RGBA16UI:\n            return gl.RGBA16UI;\n          case GLSettings.RenderTarget.ColorBufferFormat.RGBA16I:\n            return gl.RGBA16I;\n          case GLSettings.RenderTarget.ColorBufferFormat.RGBA32I:\n            return gl.RGBA32I;\n          case GLSettings.RenderTarget.ColorBufferFormat.RGBA32UI:\n            return gl.RGBA32UI;\n        }\n      }\n\n      return gl.RGBA4;\n  }\n}\n\n/**\n * Decodes a DepthBufferFormat to valid color depth buffer storage formats.\n *\n * Takes in any of the render buffer formats, but will default invalid depth\n * buffer formats to DEPTH_COMPONENT16\n */\nexport function depthBufferFormat(\n  gl: GLContext,\n  format:\n    | GLSettings.RenderTarget.DepthBufferFormat\n    | GLSettings.RenderTarget.ColorBufferFormat\n    | GLSettings.RenderTarget.StencilBufferFormat\n) {\n  switch (format) {\n    case GLSettings.RenderTarget.DepthBufferFormat.DEPTH_COMPONENT16:\n      return gl.DEPTH_COMPONENT16;\n    case GLSettings.RenderTarget.DepthBufferFormat.DEPTH_STENCIL:\n      return gl.DEPTH_STENCIL;\n\n    default:\n      if (gl instanceof WebGL2RenderingContext) {\n        switch (format) {\n          case GLSettings.RenderTarget.DepthBufferFormat.DEPTH_COMPONENT24:\n            return gl.DEPTH_COMPONENT24;\n          case GLSettings.RenderTarget.DepthBufferFormat.DEPTH_COMPONENT32F:\n            return gl.DEPTH_COMPONENT32F;\n          case GLSettings.RenderTarget.DepthBufferFormat.DEPTH24_STENCIL8:\n            return gl.DEPTH24_STENCIL8;\n          case GLSettings.RenderTarget.DepthBufferFormat.DEPTH32F_STENCIL8:\n            return gl.DEPTH32F_STENCIL8;\n        }\n      }\n\n      return gl.DEPTH_COMPONENT16;\n  }\n}\n\n/**\n * Decodes a StencilBufferFormat to valid stencil render buffer storage formats\n *\n * Takes in any of the render buffer formats, but will default invalid stencil\n * buffer formats to STENCIL_INDEX8\n */\nexport function stencilBufferFormat(\n  gl: GLContext,\n  format:\n    | GLSettings.RenderTarget.ColorBufferFormat\n    | GLSettings.RenderTarget.DepthBufferFormat\n    | GLSettings.RenderTarget.StencilBufferFormat\n) {\n  switch (format) {\n    case GLSettings.RenderTarget.StencilBufferFormat.STENCIL_INDEX8:\n      return gl.STENCIL_INDEX8;\n\n    default:\n      return gl.STENCIL_INDEX8;\n  }\n}\n\n/**\n * Decodes Wrapping to a GL setting\n */\nexport function wrapMode(gl: GLContext, mode: GLSettings.Texture.Wrapping) {\n  switch (mode) {\n    case GLSettings.Texture.Wrapping.CLAMP_TO_EDGE:\n      return gl.CLAMP_TO_EDGE;\n    case GLSettings.Texture.Wrapping.MIRRORED_REPEAT:\n      return gl.MIRRORED_REPEAT;\n    case GLSettings.Texture.Wrapping.REPEAT:\n      return gl.REPEAT;\n  }\n}\n\n/**\n * Decodes an index to an appropriate color attachment for a frame buffer\n */\nexport function indexToColorAttachment(\n  gl: GLContext,\n  extensions: IExtensions,\n  index: number,\n  isSingleBuffer: boolean,\n  isDrawBufferAttachment: boolean\n) {\n  if (isSingleBuffer) {\n    return gl.COLOR_ATTACHMENT0;\n  }\n\n  const glExt = extensions.drawBuffers;\n\n  if (isDrawBufferAttachment) {\n    if (glExt instanceof WebGL2RenderingContext) {\n      switch (index) {\n        case -2:\n          return gl.BACK;\n        case -1:\n          return gl.NONE;\n        case 0:\n          return glExt.DRAW_BUFFER0;\n        case 1:\n          return glExt.DRAW_BUFFER1;\n        case 2:\n          return glExt.DRAW_BUFFER2;\n        case 3:\n          return glExt.DRAW_BUFFER3;\n        case 4:\n          return glExt.DRAW_BUFFER4;\n        case 5:\n          return glExt.DRAW_BUFFER5;\n        case 6:\n          return glExt.DRAW_BUFFER6;\n        case 7:\n          return glExt.DRAW_BUFFER7;\n        case 8:\n          return glExt.DRAW_BUFFER8;\n        case 9:\n          return glExt.DRAW_BUFFER9;\n        case 10:\n          return glExt.DRAW_BUFFER10;\n        case 11:\n          return glExt.DRAW_BUFFER11;\n        case 12:\n          return glExt.DRAW_BUFFER12;\n        case 13:\n          return glExt.DRAW_BUFFER13;\n        case 14:\n          return glExt.DRAW_BUFFER14;\n        case 15:\n          return glExt.DRAW_BUFFER15;\n        default:\n          console.warn(\"Attachments are only available for -2 - 15\");\n      }\n    } else if (glExt) {\n      switch (index) {\n        case -2:\n          return gl.BACK;\n        case -1:\n          return gl.NONE;\n        case 0:\n          return glExt.DRAW_BUFFER0_WEBGL;\n        case 1:\n          return glExt.DRAW_BUFFER1_WEBGL;\n        case 2:\n          return glExt.DRAW_BUFFER2_WEBGL;\n        case 3:\n          return glExt.DRAW_BUFFER3_WEBGL;\n        case 4:\n          return glExt.DRAW_BUFFER4_WEBGL;\n        case 5:\n          return glExt.DRAW_BUFFER5_WEBGL;\n        case 6:\n          return glExt.DRAW_BUFFER6_WEBGL;\n        case 7:\n          return glExt.DRAW_BUFFER7_WEBGL;\n        case 8:\n          return glExt.DRAW_BUFFER8_WEBGL;\n        case 9:\n          return glExt.DRAW_BUFFER9_WEBGL;\n        case 10:\n          return glExt.DRAW_BUFFER10_WEBGL;\n        case 11:\n          return glExt.DRAW_BUFFER11_WEBGL;\n        case 12:\n          return glExt.DRAW_BUFFER12_WEBGL;\n        case 13:\n          return glExt.DRAW_BUFFER13_WEBGL;\n        case 14:\n          return glExt.DRAW_BUFFER14_WEBGL;\n        case 15:\n          return glExt.DRAW_BUFFER15_WEBGL;\n        default:\n          console.warn(\"Attachments are only available for 0 - 15\");\n      }\n    }\n  } else {\n    if (glExt instanceof WebGL2RenderingContext) {\n      switch (index) {\n        case -2:\n          return gl.BACK;\n        case -1:\n          return gl.NONE;\n        case 0:\n          return glExt.COLOR_ATTACHMENT0;\n        case 1:\n          return glExt.COLOR_ATTACHMENT1;\n        case 2:\n          return glExt.COLOR_ATTACHMENT2;\n        case 3:\n          return glExt.COLOR_ATTACHMENT3;\n        case 4:\n          return glExt.COLOR_ATTACHMENT4;\n        case 5:\n          return glExt.COLOR_ATTACHMENT5;\n        case 6:\n          return glExt.COLOR_ATTACHMENT6;\n        case 7:\n          return glExt.COLOR_ATTACHMENT7;\n        case 8:\n          return glExt.COLOR_ATTACHMENT8;\n        case 9:\n          return glExt.COLOR_ATTACHMENT9;\n        case 10:\n          return glExt.COLOR_ATTACHMENT10;\n        case 11:\n          return glExt.COLOR_ATTACHMENT11;\n        case 12:\n          return glExt.COLOR_ATTACHMENT12;\n        case 13:\n          return glExt.COLOR_ATTACHMENT13;\n        case 14:\n          return glExt.COLOR_ATTACHMENT14;\n        case 15:\n          return glExt.COLOR_ATTACHMENT15;\n        default:\n          console.warn(\"Attachments are only available for -2 - 15\");\n      }\n    } else if (glExt) {\n      switch (index) {\n        case -2:\n          return gl.BACK;\n        case -1:\n          return gl.NONE;\n        case 0:\n          return glExt.COLOR_ATTACHMENT0_WEBGL;\n        case 1:\n          return glExt.COLOR_ATTACHMENT1_WEBGL;\n        case 2:\n          return glExt.COLOR_ATTACHMENT2_WEBGL;\n        case 3:\n          return glExt.COLOR_ATTACHMENT3_WEBGL;\n        case 4:\n          return glExt.COLOR_ATTACHMENT4_WEBGL;\n        case 5:\n          return glExt.COLOR_ATTACHMENT5_WEBGL;\n        case 6:\n          return glExt.COLOR_ATTACHMENT6_WEBGL;\n        case 7:\n          return glExt.COLOR_ATTACHMENT7_WEBGL;\n        case 8:\n          return glExt.COLOR_ATTACHMENT8_WEBGL;\n        case 9:\n          return glExt.COLOR_ATTACHMENT9_WEBGL;\n        case 10:\n          return glExt.COLOR_ATTACHMENT10_WEBGL;\n        case 11:\n          return glExt.COLOR_ATTACHMENT11_WEBGL;\n        case 12:\n          return glExt.COLOR_ATTACHMENT12_WEBGL;\n        case 13:\n          return glExt.COLOR_ATTACHMENT13_WEBGL;\n        case 14:\n          return glExt.COLOR_ATTACHMENT14_WEBGL;\n        case 15:\n          return glExt.COLOR_ATTACHMENT15_WEBGL;\n        default:\n          console.warn(\"Attachments are only available for 0 - 15\");\n      }\n    }\n  }\n\n  return gl.COLOR_ATTACHMENT0;\n}\n\n/**\n * Maps an index to a texture units Enum key to use on a WebGLRenderingContext object\n */\nexport function indexToTextureUnit(gl: GLContext, index: number) {\n  // This is the proper conversion instead of unsing the built in enums. The indices\n  // are controlled via gl.max_texture_image_units. This number can be higher than\n  // the enums indicate.\n  return gl.TEXTURE0 + index;\n}\n\n/**\n * Maps a texture unit to an index that can be used for a uniform.\n */\nexport function textureUnitToIndex(gl: GLContext, unit: number) {\n  // This is the proper conversion instead of unsing the built in enums. The indices\n  // are controlled via gl.max_texture_image_units. This number can be higher than\n  // the enums indicate.\n  return unit - gl.TEXTURE0;\n}\n","import { FragmentOutputType } from \"../types\";\nimport { uid } from \"../util/uid\";\nimport { ColorBuffer } from \"./color-buffer\";\nimport { GLProxy } from \"./gl-proxy\";\nimport { GLSettings } from \"./gl-settings\";\nimport { Material } from \"./material\";\nimport { Texture } from \"./texture\";\n\n/**\n * This specifies a buffer and matches it to a hinting output type. The buffer\n * can be a Texture or a ColorBuffer of sorts. The outputType really only\n * matters for Texture types as it is used to help link Texture resources that\n * other processes are capable of providing information for.\n */\nexport type RenderBufferOutputTarget = {\n  outputType: number;\n  buffer: ColorBuffer | Texture;\n};\n\n/**\n * These are the options available for creating a new RenderTarget.\n */\nexport interface IRenderTargetOptions {\n  /**\n   * Specifies the buffers the render target will render into when draw calls\n   * happen.\n   */\n  buffers: {\n    /**\n     * The color buffer attachment. This allows multiple color buffers for MRT\n     * when available.\n     */\n    color?: RenderBufferOutputTarget | RenderBufferOutputTarget[];\n    /**\n     * The depth buffer attachment. Exclusion automatically makes depth testing\n     * not work.\n     */\n    depth?: GLSettings.RenderTarget.DepthBufferFormat | Texture | ColorBuffer;\n    /**\n     * The stencil buffer attachment. Exclusion automatically disables stencil\n     * testing.\n     */\n    stencil?: GLSettings.RenderTarget.StencilBufferFormat | Texture;\n  };\n  /**\n   * The height of the render target. This is used when the textures are not\n   * dictating the width and the height. This is required if no Textures are\n   * specified as a buffer.\n   */\n  height?: number;\n  /**\n   * If set to true, then disposing this render target will NOT cause the\n   * targets that are textures to be disposed when this is disposed.\n   */\n  retainTextureTargets?: boolean;\n  /**\n   * The width of the render target. This is used when the textures are not\n   * dictating the width and the width. This is required if no Textures are\n   * specified as a buffer.\n   */\n  width?: number;\n}\n\n/**\n * This represents an FBO render target to be rendered into. This can manage\n * several targets at once for MRT (or within compatibility modes).\n *\n * DO NOT EDIT existing render targets after they are constructed. Just dispose\n * of old targets and create new ones.\n */\nexport class RenderTarget {\n  /**\n   * This gets flagged as invalid and will not re-attempt compilation until\n   * something changes.\n   */\n  isInvalid: boolean = false;\n\n  /** UID for the object */\n  get uid() {\n    return this._uid;\n  }\n  private _uid = uid();\n\n  /** The buffer settings utilized in rendering this target */\n  get buffers() {\n    return {\n      color: Array.isArray(this._buffers.color)\n        ? this._buffers.color.slice(0)\n        : this._buffers.color,\n      depth: this._buffers.depth,\n      stencil: this._buffers.stencil\n    };\n  }\n  private _buffers: IRenderTargetOptions[\"buffers\"];\n  /**\n   * The height of the render target. This is automatically set if any of the\n   * buffers are a Texture object. Otherwise, this reflects the value provided\n   * in the options.\n   */\n  get height() {\n    return this._height;\n  }\n  private _height: number;\n  /**\n   * The width of the render target. This is automatically set if any of the\n   * buffers are a Texture object. Otherwise, this reflects the value provided\n   * in the options.\n   */\n  get width() {\n    return this._width;\n  }\n  private _width: number;\n  /**\n   * This is a flag indicating if the render target passed it's frame buffer\n   * status check\n   */\n  get validFramebuffer() {\n    return this._validFramebuffer;\n  }\n  private _validFramebuffer: boolean = false;\n\n  /**\n   * This allows outputTargets to be specified as disabled so they will not\n   * receive rendering output.\n   */\n  public get disabledTargets(): Set<number> {\n    return this._disabledTargets;\n  }\n  public set disabledTargets(v: Set<number>) {\n    this._disabledTargets = v;\n  }\n  private _disabledTargets = new Set<number>();\n\n  /**\n   * Flag indicating whether or not to preserve render targets that are textures\n   * or not. This is set to true for when a RenderTarget is being disposed, thus\n   * cleaning out the FBO and it's attachments, but we need the Texture to live\n   * on for additional purposes.\n   */\n  retainTextureTargets: boolean = false;\n\n  /**\n   * This contains gl state that is processed and identified for the render\n   * target. Modifying this outside of the framework is guaranteed to break\n   * something.\n   */\n  gl?: {\n    /** Identifier for the FBO object representing this target */\n    fboId: WebGLFramebuffer;\n    /**\n     * Each material that is generated has the potential to need a FBO to\n     * properly target the buffers it is capable of rendering to.\n     */\n    fboByMaterial: WeakMap<Material, WebGLFramebuffer>;\n    /** The color buffer(s) this target is rendering into */\n    colorBufferId?:\n      | { data: WebGLRenderbuffer; outputType: number; attachment: number }\n      | { data: Texture; outputType: number; attachment: number }\n      | {\n          data: WebGLRenderbuffer | Texture;\n          outputType: number;\n          attachment: number;\n        }[];\n    /** The depth buffer this target is rendering into */\n    depthBufferId?: WebGLRenderbuffer | Texture;\n    /** The stencil buffer this target is rendering into */\n    stencilBufferId?: WebGLRenderbuffer | Texture;\n    /** The managing GL proxy of this target */\n    proxy: GLProxy;\n  };\n\n  constructor(options: IRenderTargetOptions) {\n    this._buffers = {\n      color: Array.isArray(options.buffers.color)\n        ? options.buffers.color.slice(0)\n        : options.buffers.color,\n      depth: options.buffers.depth,\n      stencil: options.buffers.stencil\n    };\n    this._width = options.width || 0;\n    this._height = options.height || 0;\n    this.retainTextureTargets = options.retainTextureTargets || false;\n    this.calculateDimensions();\n  }\n\n  /**\n   * This analyzes the buffers for Textures to infer the width and height. This\n   * also ensures all Texture objects are the same size to prevent errors.\n   */\n  private calculateDimensions() {\n    const textures: Texture[] = [];\n\n    if (this._buffers.color instanceof Texture) {\n      textures.push(this._buffers.color);\n    } else if (Array.isArray(this._buffers.color)) {\n      for (let i = 0, iMax = this._buffers.color.length; i < iMax; ++i) {\n        const buffer = this._buffers.color[i];\n\n        if (buffer.buffer instanceof Texture) {\n          textures.push(buffer.buffer);\n        }\n      }\n    } else if (\n      this._buffers.color &&\n      this._buffers.color.buffer instanceof Texture\n    ) {\n      textures.push(this._buffers.color.buffer);\n    }\n\n    if (this._buffers.depth instanceof Texture) {\n      textures.push(this._buffers.depth);\n    }\n\n    if (this._buffers.stencil instanceof Texture) {\n      textures.push(this._buffers.stencil);\n    }\n\n    // If we have textures specified, we now measure them all to ensure they are\n    // the same width and height dimensions. This width and height will also be\n    // used as this render target's dimensions. This is how the texture buffers\n    // specify the dimensions of the render target and ignores other set\n    // dimensions applied to the render target.\n    if (textures.length > 0 && textures[0].data) {\n      const { width, height } = textures[0].data;\n\n      for (let i = 0, iMax = textures.length; i < iMax; ++i) {\n        const texture = textures[i];\n\n        if (!texture.data) {\n          console.warn(\n            \"A texture specified for thie RenderTarget did not have any data associated with it.\"\n          );\n          return;\n        }\n\n        const { width: checkWidth, height: checkHeight } = texture.data;\n\n        if (checkWidth !== width || checkHeight !== height) {\n          console.warn(\n            \"Texture applied to the render target is invalid as it does not match dimensions of all textures applied:\",\n            texture,\n            textures,\n            \"The texture will be removed as a target for the render target\"\n          );\n\n          this.removeTextureFromBuffer(texture);\n        }\n      }\n\n      this._width = width;\n      this._height = height;\n    }\n\n    // Ensure valid dimensions were established for this render target.\n    if (!this._width || !this._height) {\n      console.warn(\n        \"A RenderTarget was not able to establish valid dimensions. This target had no texture buffers and did not specify valid width and height values.\",\n        this\n      );\n    }\n  }\n\n  /**\n   * Free all resources associated with this render target.\n   */\n  dispose() {\n    if (this.gl) {\n      this.gl.proxy.disposeRenderTarget(this);\n    }\n  }\n\n  /**\n   * Retrieves all color buffers associated with this target and returns them as\n   * a guaranteed list.\n   */\n  getBuffers() {\n    if (Array.isArray(this.buffers.color)) {\n      return this.buffers.color;\n    } else if (this.buffers.color) {\n      return [this.buffers.color];\n    }\n\n    return [];\n  }\n\n  /**\n   * Retrieves all generated GL buffers associated with this target and returns\n   * them as a guaranteed list.\n   *\n   * NOTE: This is NOT intended to be used outside of the GL rendering portions\n   * of the application. Messing with this or it's return values is EXTREMELY\n   * unadvised unless you absolutely know what you are doing. COnsider being\n   * safer with getBuffers instead.\n   */\n  getGLBuffers() {\n    if (!this.gl) {\n      // We know what went wrong if this is marked as invalid. No need to spew\n      // death to the console.\n      if (!this.isInvalid) {\n        console.warn(\n          \"Attempted to retrieve gl buffers before the render target was compiled.\"\n        );\n      }\n      return [];\n    }\n\n    if (Array.isArray(this.gl.colorBufferId)) {\n      return this.gl.colorBufferId;\n    } else {\n      return [this.gl.colorBufferId];\n    }\n  }\n\n  /**\n   * Gets an ordered list of all output types this render target handles.\n   */\n  getOutputTypes() {\n    return this.getBuffers().map(buffer => buffer.outputType);\n  }\n\n  /**\n   * Retrieves the size of this render target (All buffers for this target will\n   * match these dimensions).\n   */\n  getSize() {\n    return [this._width, this._height];\n  }\n\n  /**\n   * Retrieves all of the textures associated with this render target\n   */\n  getTextures() {\n    const textures: Texture[] = [];\n\n    if (Array.isArray(this.buffers.color)) {\n      this.buffers.color.forEach(buffer => {\n        if (buffer.buffer instanceof Texture) {\n          textures.push(buffer.buffer);\n        }\n      });\n    } else if (this.buffers.color) {\n      if (this.buffers.color.buffer instanceof Texture) {\n        textures.push(this.buffers.color.buffer);\n      }\n    }\n\n    if (this.buffers.depth instanceof Texture) {\n      textures.push(this.buffers.depth);\n    }\n\n    if (this.buffers.stencil instanceof Texture) {\n      textures.push(this.buffers.stencil);\n    }\n\n    return textures;\n  }\n\n  /**\n   * This is a simple check to see if this render target is merely a color\n   * buffer target type. This is a useful check for the renderer as being a\n   * simple single color buffer target has implications to matching the render\n   * target to materials.\n   */\n  isColorTarget() {\n    if (Array.isArray(this.buffers.color)) {\n      if (this.buffers.color.length === 1) {\n        return this.buffers.color[0].outputType === FragmentOutputType.COLOR;\n      }\n    } else {\n      return this.buffers.color?.outputType === FragmentOutputType.COLOR;\n    }\n\n    return false;\n  }\n\n  /**\n   * Cleanses a texture from being used as a buffer\n   */\n  private removeTextureFromBuffer(texture: Texture) {\n    if (Array.isArray(this._buffers.color)) {\n      const found = this._buffers.color.find(b => b.buffer === texture);\n      if (!found) return;\n      const index = this._buffers.color.indexOf(found);\n      if (index > -1) this._buffers.color.splice(index, 1);\n    } else if (this._buffers.color?.buffer === texture) {\n      delete this._buffers.color;\n    }\n\n    if (this._buffers.depth === texture) {\n      delete this._buffers.depth;\n    }\n\n    if (this._buffers.stencil === texture) {\n      delete this._buffers.stencil;\n    }\n  }\n\n  /**\n   * Changes the size of this render target. This is a VERY costly operation. It\n   * will delete all existing buffers associated with this target. Change the\n   * intended size of each buffer / texture, then cause the buffer / texture to\n   * get recreated with the new size settings.\n   *\n   * This operation clears any existing texture contents that may have existed.\n   */\n  setSize(width: number, height: number) {\n    // Delete all previous GL content\n    this.dispose();\n    // Set our new width and height desires\n    this._width = width;\n    this._height = height;\n    // Adjust all of the texture objects data to size properly\n    const textures = this.getTextures();\n\n    textures.forEach(texture => {\n      texture.data = {\n        buffer: null,\n        height,\n        width\n      };\n    });\n  }\n\n  /**\n   * Flags this render target as having a valid framebuffer for rendering.\n   */\n  setAsValid() {\n    this._validFramebuffer = true;\n  }\n}\n","export * from \"./absolute-position\";\nexport * from \"./bounds\";\n","import { uid } from \"../util/uid\";\nimport { Bounds } from \"./primitives/bounds\";\nimport { Ray } from \"./ray\";\nimport { apply2, compare2, Vec2, Vec2Compat } from \"./vector\";\n\n/**\n * This object expresses a suite of methods that aids in projecting values from\n * screen to world and vice versa. These methods can be implemented in many ways\n * and should be customized to a view + camera configuration.\n */\nexport abstract class BaseProjection<T> {\n  /** Provides a numerical UID for this object */\n  get uid() {\n    return this._uid;\n  }\n  private _uid: number = uid();\n  /** Allows for a sensical identifier to be applied to this projection. */\n  id: string = \"\";\n\n  /**\n   * This is set to ensure the projections that happen properly translates the\n   * pixel ratio to normal Web coordinates\n   */\n  pixelRatio: number = 1;\n  /** This is the rendering bounds within screen space */\n  get screenBounds(): Bounds<T> {\n    if (!this._scaledScreenBounds) {\n      this._scaledScreenBounds = new Bounds<T>({\n        x: this._screenBounds.x * this._screenScale[0],\n        y: this._screenBounds.y * this._screenScale[1],\n        width: this._screenBounds.width * this._screenScale[0],\n        height: this._screenBounds.height * this._screenScale[1]\n      });\n    }\n\n    return this._scaledScreenBounds;\n  }\n\n  set screenBounds(val: Bounds<T>) {\n    delete this._scaledScreenBounds;\n    this._screenBounds = val;\n  }\n  /**\n   * This helps resolve view's that don't correlate to the screen perfectly.\n   * This would include times a view renders to a resource at a scaled valued\n   * compared to the actual dimensions of the screen.\n   */\n  get screenScale(): Vec2 {\n    return this._screenScale;\n  }\n\n  set screenScale(val: Vec2) {\n    if (!compare2(val, this._screenScale)) {\n      delete this._scaledScreenBounds;\n      this._screenScale = val;\n    }\n  }\n  /**\n   * The bounds of the render space on the canvas this view will render on. This\n   * is the size of the render space within the context so this will include the\n   * pixelRatio as needed.\n   */\n  viewBounds: Bounds<T>;\n\n  private _screenScale: Vec2 = [1, 1];\n  private _screenBounds: Bounds<T>;\n  private _scaledScreenBounds?: Bounds<T>;\n\n  /**\n   * This projects a point to be relative to the rendering dimensions of the\n   * view.\n   */\n  screenToRenderSpace(point: Vec2, out?: Vec2) {\n    out = this.screenToView(point, out);\n\n    return apply2(out, point[0] * this.pixelRatio, point[1] * this.pixelRatio);\n  }\n\n  /**\n   * This projects a point relative to the render space of the view to the\n   * screen coordinates\n   */\n  renderSpaceToScreen(point: Vec2, out?: Vec2) {\n    out = out || [0, 0];\n\n    return apply2(\n      out,\n      point[0] / this.pixelRatio - this.screenBounds.x,\n      point[1] / this.pixelRatio - this.screenBounds.y\n    );\n  }\n\n  /**\n   * Takes a coordinate in screen coordinates and maps it to a point that is\n   * relative to a view's viewport on the screen.\n   */\n  screenToView(point: Vec2, out?: Vec2) {\n    out = out || [0, 0];\n\n    return apply2(\n      out,\n      point[0] - this.screenBounds.x,\n      point[1] - this.screenBounds.y\n    );\n  }\n\n  /**\n   * Takes a coordinate that is relative to a view's viewport within the screen\n   * and maps it to a coordinate relative to the screen.\n   */\n  viewToScreen(point: Vec2, out?: Vec2) {\n    out = out || [0, 0];\n\n    return apply2(\n      out,\n      point[0] + this.screenBounds.x,\n      point[1] + this.screenBounds.y\n    );\n  }\n\n  /**\n   * Maps a coordinate relative to the screen to a coordinate found within the\n   * world space.\n   */\n  abstract screenToWorld(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n\n  /**\n   * Maps a coordinate relative to the screen to a ray that emanates from the\n   * selected coordinate such that the ray extending to infinity would be\n   * projected to the same point.\n   */\n  abstract screenRay(point: Vec2Compat): Ray;\n\n  /**\n   * Maps a coordinate found within the world to a relative coordinate within\n   * the screen space.\n   */\n  abstract worldToScreen(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n\n  /**\n   * Maps a coordinate relative to the view's viewport to a coordinate found\n   * within the world.\n   */\n  abstract viewToWorld(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n\n  /**\n   * Maps a coordinate found within the world to a relative coordinate within\n   * the view's viewport.\n   */\n  abstract worldToView(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n}\n\n/**\n * This is an implementation of the BaseProjection with the abstract methods\n * implmented but not functional\n */\nexport class SimpleProjection extends BaseProjection<any> {\n  screenToWorld(point: Vec2Compat, _out?: Vec2Compat): Vec2Compat {\n    return point;\n  }\n\n  screenRay(_point: Vec2Compat): Ray {\n    return [\n      [0, 0, -1],\n      [0, 0, -2]\n    ];\n  }\n\n  worldToScreen(point: Vec2Compat, _out?: Vec2Compat): Vec2Compat {\n    return point;\n  }\n\n  viewToWorld(point: Vec2Compat, _out?: Vec2Compat): Vec2Compat {\n    return point;\n  }\n\n  worldToView(point: Vec2Compat, _out?: Vec2Compat): Vec2Compat {\n    return point;\n  }\n}\n","export * from \"./color-buffer-resource\";\nexport * from \"./color-buffer-resource-manager\";\nexport * from \"./color-buffer-resource-request\";\n","import { WebGLRenderer } from \"../../gl\";\nimport { Texture, TextureOptions } from \"../../gl/texture\";\nimport { ResourceType, TextureSize } from \"../../types\";\nimport { IdentifyByKey } from \"../../util/identify-by-key\";\nimport { BaseResourceOptions } from \"../base-resource-manager\";\n\n/**\n * Options required for generating a RenderTexture.\n */\nexport interface IRenderTextureResource extends BaseResourceOptions {\n  /** Set the type of the resource to explicitally be an atlas resource */\n  type: ResourceType.TEXTURE;\n  /** This is the height of the texture */\n  height: number;\n  /** This is the width of the texture */\n  width: number;\n  /**\n   * This applies any desired settings to the Texture.\n   * Some noteable defaults this system sets:\n   *  - generateMipMaps is true and\n   *  - premultiply alpha is true.\n   */\n  textureSettings?: TextureOptions;\n}\n\n/**\n * Use this to aid in creating a texture in the resources portion of configuring\n * your surface.\n */\nexport function createTexture(\n  options: Omit<IRenderTextureResource, \"type\" | \"key\"> &\n    Partial<Pick<IRenderTextureResource, \"key\">>\n): IRenderTextureResource {\n  return {\n    key: \"\",\n    type: ResourceType.TEXTURE,\n    ...options\n  };\n}\n\n/**\n * Type guard for the Render Texture resource type.\n */\nexport function isRenderTextureResource(\n  val: any\n): val is IRenderTextureResource {\n  return val && val.key !== void 0 && val.type === ResourceType.TEXTURE;\n}\n\n/**\n * This defines a general purpose texture that can be rendered into and be\n * rendered.\n */\nexport class RenderTexture extends IdentifyByKey\n  implements IRenderTextureResource {\n  /** Set the type of the resource to explicitally be an atlas resource */\n  type: ResourceType.TEXTURE = ResourceType.TEXTURE;\n  /** This is the height of the texture */\n  height: number;\n  /** This is the width of the texture */\n  width: number;\n  /**\n   * This applies any desired settings to the Texture.\n   * Some noteable defaults this system sets:\n   *  - generateMipMaps is true and\n   *  - premultiply alpha is true.\n   */\n  textureSettings?: TextureOptions;\n  /** The actual texture resource generated */\n  texture: Texture;\n\n  constructor(options: IRenderTextureResource, renderer?: WebGLRenderer) {\n    super(options);\n    this.height = options.height;\n    this.width = options.width;\n    this.textureSettings = options.textureSettings;\n    this.createTexture(renderer);\n  }\n\n  /**\n   * Frees up resources associated with this object. This object is no longer\n   * valid after this is called and will produce undefined results if attempted\n   * to use again.\n   */\n  destroy() {\n    this.texture.destroy();\n  }\n\n  /**\n   * This generates the texture object needed for this atlas.\n   */\n  private createTexture(renderer?: WebGLRenderer) {\n    if (this.texture) return;\n\n    // Establish the settings to be applied to the Texture. Provide some default\n    // configuration.\n    this.textureSettings = {\n      generateMipMaps: true,\n      premultiplyAlpha: false,\n      ...this.textureSettings\n    };\n\n    let width, height;\n    const size = renderer?.getRenderSize() || [1, 1];\n\n    if (this.width <= TextureSize.SCREEN) {\n      if (!renderer) {\n        throw new Error(\n          \"Can not generate Render Texture with a dynamic width or height when the WebGLRenderer is not available\"\n        );\n      }\n\n      width = size[0] / -this.width;\n    } else width = this.width;\n\n    if (this.height <= TextureSize.SCREEN) {\n      if (!renderer) {\n        throw new Error(\n          \"Can not generate Render Texture with a dynamic width or height when the WebGLRenderer is not available\"\n        );\n      }\n\n      height = size[1] / -this.width;\n    } else height = this.height;\n\n    // Generate the texture\n    this.texture = new Texture({\n      data: this.textureSettings?.data || {\n        width,\n        height,\n        buffer: null\n      },\n      ...this.textureSettings\n    });\n  }\n}\n","import { Texture } from \"../../gl/texture\";\nimport { Omit, ResourceType } from \"../../types\";\nimport { BaseResourceRequest } from \"../base-resource-manager\";\n\n/**\n * Base information an RenderTexture resource can provide.\n */\nexport interface IRenderTextureResourceRequest extends BaseResourceRequest {\n  /**\n   * This is the key of the resource to be used for the request. Resources are\n   * defined in the pipeline.\n   */\n  key: string;\n  /**\n   * Once loaded into the texture, this will be populated revealing the\n   * informaion needed to sample the image from the RenderTexture.\n   */\n  texture?: Texture;\n  /** Set the type of this resource for categorization by resource managers */\n  type: ResourceType.TEXTURE;\n}\n\n/**\n * Simple wrapper to make autocomplete easier for making an RenderTexture\n * request.\n */\nexport function textureRequest(\n  options: Omit<Partial<IRenderTextureResourceRequest>, \"type\"> &\n    Pick<IRenderTextureResourceRequest, \"key\">\n): IRenderTextureResourceRequest {\n  return {\n    type: ResourceType.TEXTURE,\n    ...options\n  };\n}\n","import {\n  apply3,\n  apply4,\n  copy4x4,\n  decomposeRotation,\n  forward3,\n  identity3,\n  identity4,\n  inverse3,\n  length4Components,\n  lookAtQuat,\n  M3R,\n  M4R,\n  Mat4x4,\n  matrix3x3FromUnitQuatModel,\n  multiply4x4,\n  oneQuat,\n  Quaternion,\n  rotateVectorByUnitQuat,\n  scale3,\n  SRT4x4,\n  subtract3,\n  transpose3x3,\n  TRS4x4,\n  V3R,\n  Vec3\n} from \"../../math\";\nimport { UpdateProp } from \"../../types\";\nimport { Instance3D } from \"./instance-3d\";\nimport { resolveUpdate, scheduleUpdate } from \"./transform-base\";\nimport { TreeNode } from \"./tree-node\";\n\n/**\n * The initial properties of the transform on creation\n */\nexport interface ITransform {\n  /** Starting position in local space */\n  localPosition?: Vec3;\n  /** Starting rotation in local space */\n  localRotation?: Quaternion;\n  /** Starting scale in local space */\n  localScale?: Vec3;\n  /** A parent transform relative to this transform */\n  parent?: Transform;\n}\n\n/**\n * This is a wrapper for a 3D matrix for transforming coordinates from one\n * vector space to another. Follows the order of ISROT: Identity, Scale,\n * Rotation, Origin, Translation. However, this only provides the SRT properties\n * for simpler affine transforms.\n *\n * This class also helps manage a balance between local and world information\n * needed for the transform.\n *\n * This operates with less information and less calculations when only the local\n * orientations are used (or no parent is set).\n */\nexport class Transform extends TreeNode<Transform> {\n  /** Indicates this transform is queued for an update in the update loop */\n  private isQueuedForUpdate = false;\n  /**\n   * Helper flag indicating it is relevant to have the world orientation\n   * decomposed from the world transform.\n   */\n  private needsWorldOrientation = false;\n  /**\n   * Flag indicates the world matrix has been updated but has not been through\n   * a decomposition yet.\n   */\n  private needsWorldDecomposition = false;\n  /**\n   * Flag that indicates this transform has a matrix that performs the\n   * operations in reverse (such as for a camera.)\n   */\n  private hasViewMatrix: boolean = false;\n\n  /** This is a special instance listener for the transform */\n  private _instance: Instance3D | null = null;\n  set instance(val: Instance3D | null) {\n    if (this._instance !== val && this._instance) {\n      this._instance.transform.instance = null;\n      if (val) val.transform = this;\n    }\n\n    this._instance = val;\n  }\n\n  /**\n   * This is the inner matrix that represents the culmination of all the\n   * properties into a single transform matrix. It is invalid and will cause\n   * undefined behavior if the elements of this matrix are modified. You should\n   * use the provided methods of this Transform class to manipulate this matrix.\n   *\n   * This matrix is what is used to transform coordinates into world space, thus\n   * it is also the culmination of all the parent's to this particular\n   * transform.\n   */\n  get matrix(): Mat4x4 {\n    this.update();\n    return this._matrix.value;\n  }\n  private _matrix: UpdateProp<Mat4x4> = { value: identity4() };\n\n  /**\n   * This is the local matrix which represents the transform this Transform\n   * performs which does NOT include the parent transforms to this transform.\n   */\n  get localMatrix(): Mat4x4 {\n    this.update();\n    return this._localMatrix.value;\n  }\n  private _localMatrix: UpdateProp<Mat4x4> = { value: this._matrix.value };\n\n  /**\n   * This is the transform matrix that contains the operations in reverse order.\n   * This produces a 'view matrix' for the transform and shouldn't be considered\n   * an inverse matrix. This is commonly used for Camera constructs whos\n   * orientation is reverse to the world (the camera would exist in world space\n   * using the normal world matrix, but the operations to transform everything\n   * to the cameras perspective is in the exact opposite order.)\n   */\n  get viewMatrix(): Mat4x4 {\n    this.hasViewMatrix = true;\n    if (this._viewMatrix === void 0) this.invalidate();\n    this.update();\n    if (this._viewMatrix === void 0) return identity4();\n    return this._viewMatrix.value;\n  }\n  private _viewMatrix?: UpdateProp<Mat4x4>;\n\n  /**\n   * This excludes any parent transform information and is the view matrix\n   * specific to this transform.\n   *\n   * This is the transform matrix that contains the operations in reverse order.\n   * This produces a 'view matrix' for the transform and shouldn't be considered\n   * an inverse matrix. This is commonly used for Camera constructs whos\n   * orientation is reverse to the world (the camera would exist in world space\n   * using the normal world matrix, but the operations to transform everything\n   * to the cameras perspective is in the exact opposite order.)\n   */\n  get localViewMatrix(): Mat4x4 {\n    this.hasViewMatrix = true;\n    if (this._localViewMatrix === void 0) this.invalidate();\n    this.update();\n    if (this._localViewMatrix === void 0) return identity4();\n    return this._localViewMatrix.value;\n  }\n  private _localViewMatrix?: UpdateProp<Mat4x4>;\n\n  /**\n   * Transforms can have an additional modification for non-affine or\n   * specialized transforms that are generally considered too expensive to keep\n   * track of at all times.\n   *\n   * This is NOT applied to the viewMatrix output. Use localViewTransform for\n   * that.\n   *\n   * Applying this matrix to this Transform will make 'world space' values\n   * invalid.\n   *\n   * Why do world calculations stop working? Since this transform is so generic\n   * there is no good way to derive that information anymore.\n   */\n  get localTransform() {\n    return this._localTransform?.value;\n  }\n  set localTransform(val: Mat4x4 | undefined) {\n    if (val) {\n      if (!this._localTransform) this._localTransform = { value: identity4() };\n      copy4x4(val, this._localTransform.value);\n      this._localTransform.didUpdate = true;\n    } else {\n      delete this._localTransform;\n    }\n\n    this.invalidate();\n  }\n  private _localTransform?: UpdateProp<Mat4x4>;\n\n  /**\n   * This is the same as localTransform except it is ONLY applied to the view.\n   * We have a transform for the view and the node separated as there are more\n   * cases to have specialized view calculations, but require having the node be\n   * left unaffected. Such as having elements follow the Camera, but have the\n   * camera distort the final output space.\n   *\n   * Transforms can have an additional modification for non-affine or\n   * specialized transforms that are generally considered too expensive to keep\n   * track of at all times.\n   *\n   * Applying this matrix to this Transform will make 'world space' values\n   * invalid.\n   *\n   * Why do world calculations stop working? Since this transform is so generic\n   * there is no good way to derive that information anymore.\n   */\n  get localViewTransform() {\n    return this._localViewTransform?.value;\n  }\n  set localViewTransform(val: Mat4x4 | undefined) {\n    if (val) {\n      if (!this._localViewTransform) {\n        this._localViewTransform = { value: identity4() };\n      }\n      copy4x4(val, this._localViewTransform.value);\n      this._localViewTransform.didUpdate = true;\n    } else {\n      delete this._localViewTransform;\n    }\n\n    this.invalidate();\n  }\n  private _localViewTransform?: UpdateProp<Mat4x4>;\n\n  /**\n   * Orientation of this transform in world space. When no parent is present\n   * rotation === localRotation.\n   *\n   * If localTransform is present, this value may be incorrect.\n   */\n  get rotation() {\n    this.needsWorldOrientation = true;\n    this.update();\n    return this._rotation.value;\n  }\n  set rotation(val: Quaternion) {\n    if (!this.parent) {\n      this.localRotation = val;\n    } else {\n      console.warn(\n        \"NOT IMPLEMENTED: Setting world rotation when a parent is present is not supported yet. Use localRotation for now.\"\n      );\n    }\n  }\n\n  /**\n   * Orientation of this transform without it's parent's orientation. When no\n   * parent is present rotation === localRotation.\n   */\n  get localRotation() {\n    return this._localRotation.value;\n  }\n  set localRotation(val: Quaternion) {\n    apply4(this._localRotation.value, val[0], val[1], val[2], val[3]);\n    this._localRotation.didUpdate = true;\n    this.invalidate();\n    this.needsForwardUpdate = true;\n  }\n  private _rotation: UpdateProp<Quaternion> = { value: oneQuat() };\n  private _localRotation: UpdateProp<Quaternion> = {\n    value: this._rotation.value\n  };\n  private localRotationMatrix = identity3();\n\n  /**\n   * The scale of the Transform in world space. When there is no parent,\n   * localScale === scale.\n   *\n   * If localTransform is present, this value may be incorrect.\n   */\n  get scale() {\n    this.needsWorldOrientation = true;\n    this.update();\n    return this._scale.value;\n  }\n  set scale(val: Vec3) {\n    if (!this.parent) {\n      this.localScale = val;\n    } else {\n      console.warn(\n        \"NOT IMPLEMENTED: Setting world scale is not supported yet. Use localScale for now.\"\n      );\n    }\n  }\n  /**\n   * The scale this Transform applies ignoring the parent Transform. When there\n   * is no parent, localScale === scale.\n   */\n  get localScale() {\n    return this._localScale.value;\n  }\n  set localScale(val: Vec3) {\n    apply3(this._localScale.value, val[0], val[1], val[2]);\n    this._localScale.didUpdate = true;\n    this.invalidate();\n  }\n  private _scale: UpdateProp<Vec3> = { value: [1, 1, 1] };\n  private _localScale: UpdateProp<Vec3> = { value: this._scale.value };\n\n  /**\n   * Translation of this transform in world space. When there is no parent,\n   * position === localPosition.\n   *\n   * If localTransform is present, this value may be incorrect.\n   */\n  get position() {\n    this.needsWorldOrientation = true;\n    this.update();\n    return this._position.value;\n  }\n  set position(val: Vec3) {\n    if (!this.parent) {\n      this.localPosition = val;\n    } else {\n      console.warn(\n        \"NOT IMPLEMENTED: Setting world position is not supported yet. Use localPosition for now.\"\n      );\n    }\n  }\n\n  /**\n   * The position this transform applies ignoring the parent Transform. When\n   * there is no parent, position === localPosition.\n   */\n  get localPosition() {\n    return this._localPosition.value;\n  }\n  set localPosition(val: Vec3) {\n    this._localPosition.value[0] = val[0];\n    this._localPosition.value[1] = val[1];\n    this._localPosition.value[2] = val[2];\n    this._localPosition.didUpdate = true;\n    this.invalidate();\n  }\n  private _position: UpdateProp<Vec3> = { value: [0, 0, 0] };\n  private _localPosition: UpdateProp<Vec3> = {\n    value: this._position.value\n  };\n\n  /**\n   * The forward vector for this particular transform in world space. When no\n   * parent is present, forward === localForward.\n   */\n  get forward() {\n    if (this.needsForwardUpdate || this.parent?.childUpdate.has(this)) {\n      this.needsForwardUpdate = false;\n      rotateVectorByUnitQuat(\n        forward3(),\n        this._rotation.value,\n        this._forward.value\n      );\n    }\n\n    return this._forward.value;\n  }\n  /**\n   * The forward vector for this particular transform ignoring the parent\n   * transform. When no parent is present, forward === localForward.\n   */\n  get localForward() {\n    if (this.needsForwardUpdate) {\n      this.needsForwardUpdate = false;\n      rotateVectorByUnitQuat(\n        forward3(),\n        this._localRotation.value,\n        this._localForward.value\n      );\n    }\n\n    return this._localForward.value;\n  }\n  private _forward: UpdateProp<Vec3> = { value: forward3() };\n  private _localForward: UpdateProp<Vec3> = { value: this._forward.value };\n  private needsForwardUpdate: boolean = false;\n\n  constructor(options?: ITransform) {\n    super();\n    if (!options) return;\n    if (options.localPosition) this.localPosition = options.localPosition;\n    if (options.localRotation) this.localRotation = options.localRotation;\n    if (options.localScale) this.localScale = options.localScale;\n    if (options.parent) this.parent = options.parent;\n  }\n\n  /**\n   * Adjusts the transform's properties all at once to shave off a little bit of\n   * overhead.\n   */\n  applyLocalSRT(scale: Vec3, rotation: Quaternion, translation: Vec3) {\n    this._localScale.value = scale;\n    this._localPosition.value = translation;\n    this._localRotation.value = rotation;\n    this._localScale.didUpdate = true;\n    this._localPosition.didUpdate = true;\n    this._localRotation.didUpdate = true;\n\n    this.invalidate();\n    if (this._instance) this._instance.transform = this;\n  }\n\n  /**\n   * This method contains the math involved in decomposing our world SRT matrix\n   * so we can view the Transform's orientation relative to world space.\n   */\n  private decomposeWorldMatrix() {\n    // If no triggers occurred, we need to not decompose\n    if (\n      !this.needsWorldDecomposition ||\n      !this.parent ||\n      !this._matrix.didUpdate ||\n      this._matrix.value === this._localMatrix.value\n    ) {\n      return;\n    }\n\n    // Check to see if something is utilizing world orientation from either this\n    // transform or from the instance itself. If neither are, then we should not\n    // decompose the matrix as nothing is reading the value.\n    if (this._instance) {\n      if (!this._instance.needsWorldUpdate || !this.needsWorldOrientation) {\n        return;\n      }\n    } else if (!this.needsWorldOrientation) {\n      return;\n    }\n\n    this.needsWorldDecomposition = false;\n    const m = this._matrix.value;\n    const translation = this._position.value;\n    const scale = this._scale.value;\n\n    // Translation is stored in the last row\n    this._position.didUpdate =\n      translation[0] !== m[12] ||\n      translation[1] !== m[13] ||\n      translation[2] !== m[14];\n    if (this._position.didUpdate) {\n      apply3(translation, m[12], m[13], m[14]);\n    }\n\n    // Scale is the magnitude of each row vector\n    const sx = length4Components(m[0], m[1], m[2], m[3]);\n    const sy = length4Components(m[4], m[5], m[6], m[7]);\n    const sz = length4Components(m[8], m[9], m[10], m[11]);\n    this._scale.didUpdate =\n      scale[0] !== sx || scale[1] !== sy || scale[2] !== sz;\n    apply3(scale, sx, sy, sz);\n    this._scale.didUpdate = true;\n\n    // Use the calculated scale to make a pure rotation matrix from which we can\n    // derive a Quaternion for the world orientation.\n    // prettier-ignore\n    const [a, b, c, d] = this._rotation.value;\n    decomposeRotation(this._matrix.value, sx, sy, sz, this._rotation.value);\n    const r = this._rotation.value;\n    this._rotation.didUpdate =\n      r[0] !== a || r[1] !== b || r[2] !== c || r[3] !== d;\n  }\n\n  /**\n   * Orients this transform to make the forward direction point toward a\n   * position relative to this transform. When no parent is present, lookAt and\n   * lookAtLocal behaves exactly the same.\n   */\n  lookAtLocal(position: Vec3, up?: Vec3) {\n    lookAtQuat(\n      subtract3(position, this._localPosition.value, V3R[0]),\n      up || [0, 1, 0],\n      this._localRotation.value\n    );\n    this._localRotation.didUpdate = true;\n    this.invalidate();\n    this.needsForwardUpdate = true;\n  }\n\n  /**\n   * Makes world space and local space information have it's own memory\n   * allotment as they should be different after calling this method.\n   */\n  private divideMemory() {\n    this._forward.value = forward3();\n    this._matrix.value = identity4();\n    this._rotation.value = oneQuat();\n    this._scale.value = [1, 1, 1];\n    this._position.value = [0, 0, 0];\n\n    if (this.hasViewMatrix && this._viewMatrix && this._localViewMatrix) {\n      this._viewMatrix.value = identity4();\n    }\n  }\n\n  /**\n   * Merges local and world space information as they'll be identical.\n   */\n  private mergeMemory() {\n    this._forward.value = this._localForward.value;\n    this._matrix.value = this._localMatrix.value;\n    this._rotation.value = this._localRotation.value;\n    this._scale.value = this._localScale.value;\n    this._position.value = this._localPosition.value;\n\n    if (this.hasViewMatrix && this._viewMatrix && this._localViewMatrix) {\n      this._viewMatrix.value = this._localViewMatrix.value;\n    }\n  }\n\n  /**\n   * Changes the parent transform of this Transform. This triggers required\n   * updates for this Transform.\n   */\n  setParent(v?: Transform, unsafe?: boolean) {\n    if (v === this.parent) return;\n\n    // If we are going into an undefined parent state, then we can merge our\n    // world and local values to save on RAM\n    if (!v) {\n      this.mergeMemory();\n    }\n\n    // Once we set a parent matrix, this transform must handle a dividing moment\n    // where the world and local properties are no longer equivalent.\n    else if (!this.parent) {\n      this.divideMemory();\n    }\n\n    // Set the parent and flag everything for update\n    this.invalidate();\n    this.needsForwardUpdate = true;\n    this._localScale.didUpdate = true;\n    this._localRotation.didUpdate = true;\n    this._localPosition.didUpdate = true;\n\n    super.setParent(v, unsafe);\n  }\n\n  /**\n   * We override the invalidation to aid in handling the issue with our\n   * rendering system being \"passive\" and our node structure to be \"passive\" as\n   * well.\n   */\n  invalidate() {\n    this.queueForUpdate();\n    return super.invalidate();\n  }\n\n  /**\n   * This is an ambiguous but simple method that attempts to re-optimize this\n   * transform. If you have maybe a one time analysis of properties over the\n   * course of a lengthy period of time, consider calling this.\n   *\n   * Instances and transforms take the approach of \"shifting gears\" toward world\n   * decomposition after world orientations are queried. However, you may not\n   * always need or rarely need a specific world orientation. Thus calling this\n   * method will make the instance and transform assume it no longer needs world\n   * orientations once again until something queries for it.\n   */\n  optimize() {\n    this.needsWorldOrientation = false;\n  }\n\n  /**\n   * Ensures this transform WILL receive an update if it fits requirements for\n   * potentially missing an update that may be needed by passive elements.\n   */\n  queueForUpdate() {\n    // If the invalidation did happen, then we check our monitored instance to\n    // see if it's actively waiting on any of the transform's properties. If it\n    // is, then the invalidation should also immediately trigger an update and\n    // trigger the resource updates for the instance.\n    if (!this.isQueuedForUpdate && this._instance && this._instance.active) {\n      this.isQueuedForUpdate = true;\n      scheduleUpdate(this);\n    }\n  }\n\n  /**\n   * If needed, this updates the matrix for this transform. This is called\n   * automatically when the matrix is retrieved.\n   *\n   * The unsafe flag causes this node to update without ensuring it's parents\n   * are out of date. Recommended to not use this flag ever. The system handles\n   * all of that for you.\n   */\n  update(unsafe?: boolean) {\n    let updateWorldMatrix = false;\n\n    // If this is queued for an update, we can remove it now as it's definitely\n    // up to date at this point.\n    if (this.isQueuedForUpdate) {\n      resolveUpdate(this);\n      this.isQueuedForUpdate = false;\n    }\n\n    // If this node directly needs an update we should update our local matrix\n    if (this.needsUpdate) {\n      const R = this.localRotationMatrix;\n\n      if (this._localRotation.didUpdate) {\n        matrix3x3FromUnitQuatModel(this._localRotation.value, R);\n      }\n\n      // Concat the SRT transform in this order Scale -> Rotation -> Translation\n      // We utilize our existing matrix to reduce redundant allocations of\n      // matrix information.\n      if (this._localTransform) {\n        // With a local transform we want to make the local transform appended\n        // as a last step applied: so translate -> rotate -> scale ->\n        // localTransform\n        SRT4x4(this._localScale.value, R, this._localPosition.value, M4R[0]);\n\n        multiply4x4(\n          this._localTransform.value,\n          M4R[0],\n          this._localMatrix.value\n        );\n      } else {\n        SRT4x4(\n          this._localScale.value,\n          R,\n          this._localPosition.value,\n          this._localMatrix.value\n        );\n      }\n\n      this._localMatrix.didUpdate = true;\n      // Since we updated the local matrix, let's make sure the world matrix\n      // gets updated as well\n      updateWorldMatrix = true;\n\n      if (this.hasViewMatrix) {\n        if (this._viewMatrix === void 0) {\n          this._viewMatrix = { value: identity4() };\n        }\n\n        // If the localViewMatrix has not been initialized, do it now\n        if (this._localViewMatrix === void 0) {\n          // We must merge the local and complete matrix depending on the parent\n          // status. If there is a parent, the local matrix gets it's own memory\n          // space, otherwise local and complete view matrix share the same\n          // matrix.\n          if (this.parent) {\n            this._localViewMatrix = { value: identity4() };\n          } else {\n            this._localViewMatrix = { value: this._viewMatrix.value };\n          }\n        }\n\n        // When generating this transform, it is important to remember that when\n        // you envision the camera looking at something, everything else is in\n        // the exact opposite orientation to the camera. Remember: this view\n        // matrix gets APPLIED to geometry to orient it correclty to the camera.\n        // Thus the world is being moved for the sake of the camera, the camera\n        // itself is not moving. THUS: all operations to make this matrix will\n        // be the INVERSE of where the camera is physically located and oriented\n        if (this._localViewTransform) {\n          TRS4x4(\n            inverse3(this._localScale.value, V3R[0]),\n            transpose3x3(R, M3R[1]),\n            scale3(this._localPosition.value, -1, V3R[1]),\n            M4R[0]\n          );\n\n          multiply4x4(\n            this._localViewTransform.value,\n            M4R[0],\n            this._localViewMatrix.value\n          );\n        } else {\n          TRS4x4(\n            inverse3(this._localScale.value, V3R[0]),\n            transpose3x3(R, M3R[1]),\n            scale3(this._localPosition.value, -1, V3R[1]),\n            this._localViewMatrix.value\n          );\n        }\n\n        this._localViewMatrix.didUpdate = true;\n      }\n    }\n\n    // If our parent has this node flagged for update, then this means our world\n    // matrix is no longer valid.\n    if (this.parent) {\n      // If the parent node specifically needs an update, then we need to\n      // process the updates of all the nodes bubling up the tree\n      if (this.parent.needsUpdate) {\n        // Flagging this as a child being out of date could mean several nodes\n        // up the chain are out of date as well. So we shall update those nodes\n        // starting at the top most out of date node, and work our way down\n        if (!unsafe) {\n          this.processParentUpdates(transform => {\n            transform.update(true);\n          });\n        }\n\n        updateWorldMatrix = true;\n      }\n\n      // If the parent doesn't need updating, but we still have a child\n      // unresolved flag set, then we still need the world matrix for this node\n      // updated.\n      else if (this.parent.childUpdate.has(this)) {\n        updateWorldMatrix = true;\n      }\n\n      // If something changed that required the world matrix to be recalculated,\n      // then let's update it.\n      if (updateWorldMatrix) {\n        // Apply the world change\n        multiply4x4(\n          this.parent._matrix.value,\n          this._localMatrix.value,\n          this._matrix.value\n        );\n\n        this._matrix.didUpdate = true;\n        this.needsWorldDecomposition = true;\n\n        // Update view matrices as well if present. This is a little more costly\n        // than normal matrix chaining as we don't accidentally force parent\n        // matrices to support having their own view matrix. View matrices need\n        // to be a bit more isolated as they are a much rarer occurrence in\n        // these types of display trees. So, to prevent creation and chaining of\n        // view matrices, we simply calculate the parent's world view matrix for\n        // it, then apply that calculated matrix to our local view matrix.\n        if (this.hasViewMatrix && this._viewMatrix && this._localViewMatrix) {\n          // If our parent has a view matrix, awesome! Let's use that to speed\n          // up calculations.\n          if (\n            this.parent.hasViewMatrix &&\n            this.parent._viewMatrix &&\n            this.parent._localViewMatrix\n          ) {\n            multiply4x4(\n              this.parent._viewMatrix.value,\n              this._localViewMatrix.value,\n              this._viewMatrix.value\n            );\n          }\n\n          // Otherwise, don't attempt to retrieve the matrix lest we\n          // accidentally casue the parent to generate a view matrix which is\n          // not ideal.\n          else {\n            // Get a complete rotation transform in world space for the parent\n            matrix3x3FromUnitQuatModel(this.parent.rotation, M3R[0]);\n\n            // Generate a view matrix on behalf of the parent using the world\n            // orientation of the parent\n            TRS4x4(\n              inverse3(this.parent._scale.value, V3R[0]),\n              transpose3x3(M3R[0], M3R[1]),\n              scale3(this.parent._position.value, -1, V3R[1]),\n              M4R[0]\n            );\n\n            // Use our computed parent view matrix to make the total oriented\n            // view happen.\n            multiply4x4(\n              this._localViewMatrix.value,\n              M4R[0],\n              this._viewMatrix.value\n            );\n          }\n\n          this._viewMatrix.didUpdate = true;\n        }\n      }\n    }\n\n    // Make sure our world orientations are up to date if we updated our world\n    // matrix.\n    this.decomposeWorldMatrix();\n\n    // Perform all of the triggers needed to update the instance to the latest\n    // information. If neither matrix had an update, then there is nothing that\n    // needs to update for the instance as the matrices are the culmination of\n    // all changes that could be made\n    if (\n      this._instance &&\n      this._instance.active &&\n      (this._localMatrix.didUpdate || this._matrix.didUpdate)\n    ) {\n      if (this._instance.needsLocalUpdate) {\n        if (this._localRotation.didUpdate) {\n          (this._instance as any)._localRotation = this._localRotation.value;\n        }\n\n        if (this._localPosition.didUpdate) {\n          (this._instance as any)._localPosition = this._localPosition.value;\n        }\n\n        if (this._localScale.didUpdate) {\n          (this._instance as any)._localScale = this._localScale.value;\n        }\n      }\n\n      // If we don't have a parent, then the local and the world positioning is\n      // merged and thus the world needs to be updated based on the local\n      if (this._instance.needsWorldUpdate) {\n        if (this.parent) {\n          if (this._rotation.didUpdate) {\n            (this._instance as any)._rotation = this._rotation.value;\n          }\n\n          if (this._scale.didUpdate) {\n            (this._instance as any)._scale = this._scale.value;\n          }\n\n          if (this._position.didUpdate) {\n            (this._instance as any)._position = this._position.value;\n          }\n        } else {\n          if (this._localRotation.didUpdate) {\n            (this._instance as any)._rotation = this._localRotation.value;\n          }\n\n          if (this._localPosition.didUpdate) {\n            (this._instance as any)._position = this._localPosition.value;\n          }\n\n          if (this._localScale.didUpdate) {\n            (this._instance as any)._scale = this._localScale.value;\n          }\n        }\n      }\n\n      if (this._matrix.didUpdate) {\n        (this._instance as any)._matrix = this._matrix.value;\n      }\n\n      if (this._localMatrix.didUpdate) {\n        (this._instance as any)._localMatrix = this._localMatrix.value;\n\n        if (!this.parent) {\n          (this._instance as any)._matrix = this._matrix.value;\n        }\n      }\n    }\n\n    this._localScale.didUpdate = false;\n    this._localRotation.didUpdate = false;\n    this._localPosition.didUpdate = false;\n    this._rotation.didUpdate = false;\n    this._scale.didUpdate = false;\n    this._position.didUpdate = false;\n    this._matrix.didUpdate = false;\n    this._localMatrix.didUpdate = false;\n\n    this.resolve();\n  }\n}\n\nexport const IdentityTransform: Readonly<Transform> = new Transform();\n","import { InstanceIOValue } from \"../types\";\nimport { uid } from \"../util/uid\";\nimport { isVec4, Vec, VecMath } from \"./vector\";\n\nconst { min, max, pow, round, sin, PI } = Math;\nconst GPU_PI = round(PI * 1000) / 1000;\n\nfunction clamp(x: number, minVal: number, maxVal: number) {\n  return min(max(x, minVal), maxVal);\n}\n\nexport enum AutoEasingLoopStyle {\n  /** Time will go from 0 -> 1 then stop at 1 */\n  NONE = 1,\n  /** Time will go from 0 -> infinity */\n  CONTINUOUS = 4,\n  /** Time will continuously go 0 -> 1 then 0 -> 1 then 0 -> 1 etc etc */\n  REPEAT = 2,\n  /** Time will continously go 0 -> 1 then 1 -> 0 then 0 -> 1 then 1 -> 0 etc etc */\n  REFLECT = 3\n}\n\n/**\n * This defines a GPU enabled easing method that will be executed on the GPU to maneuver\n *\n */\nexport interface IAutoEasingMethod<T extends InstanceIOValue> {\n  /** An easing method that should produce IDENTICAL values to the values of the gpu easing method using the exact same parameters */\n  cpu(start: T, end: T, t: number, out?: T): T;\n  /** This adds a delay to the starting time of an easing change */\n  delay: number;\n  /** This is how long the easing method should last */\n  duration: number;\n  /**\n   * An easing method written in shader language that should produce IDENTICAL\n   * values to the values of the cpu easing method using the exact same parameters.\n   */\n  gpu: string;\n  /**\n   * This defines the looping style of the easing.\n   */\n  loop: AutoEasingLoopStyle;\n  /**\n   * This shall be the name of the easing method as it appears in the spu shader.\n   * BE WARNED: This name is used to dedup the methods created on the shader. So,\n   * if you use the same name as another ease method used on a single layer, you run\n   * the risk of one overriding the other with an undefined chance of who wins.\n   */\n  methodName: string;\n  /**\n   * A unique identifier for the auto easing method.\n   */\n  uid: number;\n\n  /**\n   * This lets you modify some auto easing validation rules.\n   */\n  validation?: {\n    ignoreEndValueCheck?: boolean;\n    ignoreOverTimeCheck?: boolean;\n  };\n}\n\n// GPU easing methods! Written here because it's cleaner to write `` style strings\n// Against the left side of the editor\n\nconst immediateGPU = `\n$\\{easingMethod} {\n  return end;\n}\n`;\n\nconst linearGPU = `\n$\\{easingMethod} {\n  return (end - start) * t + start;\n}\n`;\n\nconst easeInQuadGPU = `\n$\\{easingMethod} {\n  float time = t * t;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeOutQuadGPU = `\n$\\{easingMethod} {\n  float time = t * (2.0 - t);\n  return (end - start) * time + start;\n}\n`;\n\nconst easeInOutQuadGPU = `\n$\\{easingMethod} {\n  float time = t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeInCubicGPU = `\n$\\{easingMethod} {\n  float time = t * t * t;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeOutCubicGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = t1 * t1 * t1 + 1.0;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeInOutCubicGPU = `\n$\\{easingMethod} {\n  float time = t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeInQuartGPU = `\n$\\{easingMethod} {\n  float time = t * t * t * t;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeOutQuartGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = 1.0 - t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeInOutQuartGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = t < 0.5 ? 8.0 * t * t * t * t : 1.0 - 8.0 * t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeInQuintGPU = `\n$\\{easingMethod} {\n  float time = t * t * t * t * t;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeOutQuintGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = 1.0 + t1 * t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeInOutQuintGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = t < 0.5 ? 16.0 * t * t * t * t * t : 1.0 + 16.0 * t1 * t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeOutElasticGPU = `\n$\\{easingMethod} {\n  float p = 0.3;\n  float time = pow(2.0, -10.0 * t) * sin((t - p / 4.0) * (2.0 * ${GPU_PI}) / p) + 1.0;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeBackInGPU = `\n$\\{easingMethod} {\n  float time = t * t * t - t * 1.05 * sin(t * ${GPU_PI});\n  return (end - start) * time + start;\n}\n`;\n\nconst easeBackOutGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float a = 1.7;\n  float time = (t1 * t1 * ((a + 1.0) * t1 + a) + 1.0);\n  return (end - start) * time + start;\n}\n`;\n\nconst easeBackInOutGPU = `\n$\\{easingMethod} {\n  float a = 1.4;\n  float a1 = a * 1.525;\n  float t1 = t / 0.5;\n  float t2 = t1 - 2.0;\n  float time =\n    (t1 < 1.0) ? 0.5 * (t1 * t1 * (a1 + 1.0) * t1 - a1) :\n    0.5 * (t2 * t2 * ((a1 + 1.0) * t2 + a1) + 2.0)\n  ;\n\n  return (end - start) * time + start;\n}\n`;\n\nconst continuousSinusoidalGPU = `\n$\\{easingMethod} {\n  $\\{T} direction = end - start;\n  return start + direction * 0.5 + direction * sin(t * ${GPU_PI} * 2.0) * 0.5;\n}\n`;\n\nconst slerpQuatLinearGPU = `\n$\\{easingMethod} {\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - t, t),\n    vec2(sin((1.0 - t) * omega) / sinom, sin(t * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end1;\n}\n`;\n\nconst slerpQuatInQuadGPU = `\n$\\{easingMethod} {\n  float time = t * t;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end1;\n}\n`;\n\nconst slerpQuatOutQuadGPU = `\n$\\{easingMethod} {\n  float time = t * (2.0 - t);\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end1;\n}\n`;\n\nconst slerpQuatInOutQuadGPU = `\n$\\{easingMethod} {\n  float time = t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end1;\n}\n`;\n\nconst slerpQuatInCubicGPU = `\n$\\{easingMethod} {\n  float time = t * t * t;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end1;\n}\n`;\n\nconst slerpQuatOutCubicGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = t1 * t1 * t1 + 1.0;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end1;\n}\n`;\n\nconst slerpQuatInOutCubicGPU = `\n$\\{easingMethod} {\n  float time = t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end1;\n}\n`;\n\nconst slerpQuatInQuartGPU = `\n$\\{easingMethod} {\n  float time = t * t * t * t;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end1;\n}\n`;\n\nconst slerpQuatOutQuartGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = 1.0 - t1 * t1 * t1 * t1;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end1;\n}\n`;\n\nconst slerpQuatInOutQuartGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = t < 0.5 ? 8.0 * t * t * t * t : 1.0 - 8.0 * t1 * t1 * t1 * t1;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end1;\n}\n`;\n\nconst slerpQuatInQuintGPU = `\n$\\{easingMethod} {\n  float time = t * t * t * t * t;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end1;\n}\n`;\n\nconst slerpQuatOutQuintGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = 1.0 + t1 * t1 * t1 * t1 * t1;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end1;\n}\n`;\n\nconst slerpQuatInOutQuintGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = t < 0.5 ? 16.0 * t * t * t * t * t : 1.0 + 16.0 * t1 * t1 * t1 * t1 * t1;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end1;\n}\n`;\n\nconst slerpQuatOutElasticGPU = `\n$\\{easingMethod} {\n  float p = 0.3;\n  float time = pow(2.0, -10.0 * t) * sin((t - p / 4.0) * (2.0 * ${GPU_PI}) / p) + 1.0;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end1;\n}\n`;\n\nconst slerpQuatBackInGPU = `\n$\\{easingMethod} {\n  float time = t * t * t - t * 1.05 * sin(t * ${GPU_PI});\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end1;\n}\n`;\n\nconst slerpQuatBackOutGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float a = 1.7;\n  float time = (t1 * t1 * ((a + 1.0) * t1 + a) + 1.0);\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end1;\n}\n`;\n\nconst slerpQuatBackInOutGPU = `\n$\\{easingMethod} {\n  float a = 1.4;\n  float a1 = a * 1.525;\n  float t1 = t / 0.5;\n  float t2 = t1 - 2.0;\n  float time =\n    (t1 < 1.0) ? 0.5 * (t1 * t1 * (a1 + 1.0) * t1 - a1) :\n    0.5 * (t2 * t2 * ((a1 + 1.0) * t2 + a1) + 2.0)\n  ;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end1;\n}\n`;\n\n/**\n * Class of base AutoEasingMethods as well as helper constructs for making the methods.\n */\nexport class AutoEasingMethod<T extends InstanceIOValue>\n  implements IAutoEasingMethod<T> {\n  /**\n   * Autoeasing methods for linear easing\n   */\n  static immediate<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, _t: number, out?: T) => {\n        const { copy } = VecMath(start);\n        return copy(end, out);\n      },\n      delay,\n      duration,\n      gpu: immediateGPU,\n      loop,\n      methodName: \"immediate\"\n    };\n  }\n\n  /**\n   * Autoeasing methods for linear easing\n   */\n  static linear<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        const { add, scale, subtract } = VecMath(start);\n        t = clamp(t, 0, 1);\n        return add(scale(subtract(end, start), t), start, out);\n      },\n      delay,\n      duration,\n      gpu: linearGPU,\n      loop,\n      methodName: \"linear\"\n    };\n  }\n\n  /**\n   * Auto easing for Accelerating to end\n   */\n  static easeInQuad<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeInQuadGPU,\n      loop,\n      methodName: \"easeInQuad\"\n    };\n  }\n\n  /**\n   * Auto easing for decelerating to end\n   */\n  static easeOutQuad<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = t * (2 - t);\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeOutQuadGPU,\n      loop,\n      methodName: \"easeOutQuad\"\n    };\n  }\n\n  /**\n   * Auto easing for Accelerate to mid, then decelerate to end\n   */\n  static easeInOutQuad<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeInOutQuadGPU,\n      loop,\n      methodName: \"easeInOutQuad\"\n    };\n  }\n\n  /**\n   * Auto easing for Slower acceleration\n   */\n  static easeInCubic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeInCubicGPU,\n      loop,\n      methodName: \"easeInCubic\"\n    };\n  }\n\n  /**\n   * Auto easing for Slower deceleration\n   */\n  static easeOutCubic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = --t * t * t + 1;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeOutCubicGPU,\n      loop,\n      methodName: \"easeOutCubic\"\n    };\n  }\n\n  /**\n   * Auto easing for Slower acceleration to mid, and slower deceleration to end\n   */\n  static easeInOutCubic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time =\n          t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeInOutCubicGPU,\n      loop,\n      methodName: \"easeInOutCubic\"\n    };\n  }\n\n  /**\n   * Auto easing for even Slower acceleration to end\n   */\n  static easeInQuart<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeInQuartGPU,\n      loop,\n      methodName: \"easeInQuart\"\n    };\n  }\n\n  /**\n   * Auto easing for even Slower deceleration to end\n   */\n  static easeOutQuart<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = 1 - --t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeOutQuartGPU,\n      loop,\n      methodName: \"easeOutQuart\"\n    };\n  }\n\n  /**\n   * Auto easing for even Slower acceleration to mid, and even slower deceleration to end\n   */\n  static easeInOutQuart<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeInOutQuartGPU,\n      loop,\n      methodName: \"easeInOutQuart\"\n    };\n  }\n\n  /**\n   * Auto easing for super slow accelerating to the end\n   */\n  static easeInQuint<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = t * t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeInQuintGPU,\n      loop,\n      methodName: \"easeInQuint\"\n    };\n  }\n\n  /**\n   * Auto easing for super slow decelerating to the end\n   */\n  static easeOutQuint<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = 1 + --t * t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeOutQuintGPU,\n      loop,\n      methodName: \"easeOutQuint\"\n    };\n  }\n\n  /**\n   * Auto easing for super slow accelerating to mid and super slow decelerating to the end\n   */\n  static easeInOutQuint<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time =\n          t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeInOutQuintGPU,\n      loop,\n      methodName: \"easeInOutQuint\"\n    };\n  }\n\n  /**\n   * Auto easing for elastic effect\n   */\n  static easeOutElastic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const p = 0.3;\n        const time = pow(2, -10 * t) * sin(((t - p / 4) * (2 * PI)) / p) + 1;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeOutElasticGPU,\n      loop,\n      methodName: \"easeOutElastic\"\n    };\n  }\n\n  /**\n   * Auto easing for retracting first then shooting to the end\n   */\n  static easeBackIn<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const a = 1.05;\n        const time = t * t * t - t * a * sin(t * PI);\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeBackInGPU,\n      loop,\n      methodName: \"easeBackIn\"\n    };\n  }\n\n  /**\n   * Auto easing for overshooting at the end\n   */\n  static easeBackOut<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const a = 1.7;\n        const t1 = t - 1;\n        const time = t1 * t1 * ((a + 1) * t1 + a) + 1;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeBackOutGPU,\n      loop,\n      methodName: \"easeBackOut\"\n    };\n  }\n\n  /**\n   * Auto easing for overshooting at the end\n   */\n  static easeBackInOut<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const a = 1.7;\n        const a1 = a * 1.525;\n        const t1 = t / 0.5;\n        const t2 = t1 - 2;\n        const time =\n          t1 < 1\n            ? 0.5 * (t1 * t1 * (a1 + 1) * t1 - a1)\n            : 0.5 * (t2 * t2 * ((a1 + 1) * t2 + a1) + 2);\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeBackInOutGPU,\n      loop,\n      methodName: \"easeBackInOut\"\n    };\n  }\n\n  /**\n   * This is an easing method that performs a sinusoidal wave where the amplitude is\n   * (start - end) * 2 and the wave starts at the start value.\n   *\n   * This is intended to work best with the CONTINUOUS loop style.\n   */\n  static continuousSinusoidal<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.CONTINUOUS\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        const { add, scale, subtract } = VecMath(start);\n        t = clamp(t, 0, 1);\n        const direction = subtract(end, start);\n        const halfDirection = scale(direction, 0.5);\n        // const amplitude = length(direction) * 2.0;\n        return add(\n          add(start, halfDirection),\n          scale(halfDirection, sin(t * PI * 2) * 1.0),\n          out\n        );\n      },\n      delay,\n      duration,\n      gpu: continuousSinusoidalGPU,\n      loop,\n      methodName: \"repeatingSinusoidal\",\n\n      // Since this is sinusoidial and operates off of a continuous time structure\n      validation: {\n        // When time = 1 our value will = start and NOT end\n        ignoreEndValueCheck: true,\n        // When the time is > 1 our value will not clamp to the value at 1.\n        ignoreOverTimeCheck: true\n      }\n    };\n  }\n\n  static slerpQuatLinear<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n\n        t = clamp(t, 0, 1);\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, t, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatLinearGPU,\n      loop,\n      methodName: \"slerpQuatLinear\"\n    };\n  }\n\n  static slerpQuatInQuad<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = t * t;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatInQuadGPU,\n      loop,\n      methodName: \"slerpQuatInQuad\"\n    };\n  }\n\n  static slerpQuatOutQuad<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = t * (2 - t);\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatOutQuadGPU,\n      loop,\n      methodName: \"slerpQuatOutQuad\"\n    };\n  }\n\n  static slerpQuatInOutQuad<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatInOutQuadGPU,\n      loop,\n      methodName: \"slerpQuatInOutQuad\"\n    };\n  }\n\n  static slerpQuatInCubic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = t * t * t;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatInCubicGPU,\n      loop,\n      methodName: \"slerpQuatInCubic\"\n    };\n  }\n\n  static slerpQuatOutCubic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = --t * t * t + 1;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatOutCubicGPU,\n      loop,\n      methodName: \"slerpQuatOutCubic\"\n    };\n  }\n\n  static slerpQuatInOutCubic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time =\n          t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatInOutCubicGPU,\n      loop,\n      methodName: \"slerpQuatInOutCubic\"\n    };\n  }\n\n  static slerpQuatInQuart<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = t * t * t * t;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatInQuartGPU,\n      loop,\n      methodName: \"slerpQuatInQuart\"\n    };\n  }\n\n  static slerpQuatOutQuart<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = 1 - --t * t * t * t;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatOutQuartGPU,\n      loop,\n      methodName: \"slerpQuatOutQuart\"\n    };\n  }\n\n  static slerpQuatInOutQuart<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatInOutQuartGPU,\n      loop,\n      methodName: \"slerpQuatInOutQuart\"\n    };\n  }\n\n  static slerpQuatInQuint<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = t * t * t * t * t;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatInQuintGPU,\n      loop,\n      methodName: \"slerpQuatInQuint\"\n    };\n  }\n\n  static slerpQuatOutQuint<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = 1 + --t * t * t * t * t;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatOutQuintGPU,\n      loop,\n      methodName: \"slerpQuatOutQuint\"\n    };\n  }\n\n  static slerpQuatInOutQuint<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time =\n          t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatInOutQuintGPU,\n      loop,\n      methodName: \"slerpQuatInOutQuint\"\n    };\n  }\n\n  static slerpQuatOutElastic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const p = 0.3;\n        const time = pow(2, -10 * t) * sin(((t - p / 4) * (2 * PI)) / p) + 1;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatOutElasticGPU,\n      loop,\n      methodName: \"slerpQuatOutElastic\"\n    };\n  }\n\n  static slerpQuatBackIn<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const a = 1.05;\n        const time = t * t * t - t * a * sin(t * PI);\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatBackInGPU,\n      loop,\n      methodName: \"slerpQuatBackIn\"\n    };\n  }\n\n  static slerpQuatBackOut<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const a = 1.7;\n        const t1 = t - 1;\n        const time = t1 * t1 * ((a + 1) * t1 + a) + 1;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatBackOutGPU,\n      loop,\n      methodName: \"slerpQuatBackOut\"\n    };\n  }\n\n  static slerpQuatBackInOut<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const a = 1.7;\n        const a1 = a * 1.525;\n        const t1 = t / 0.5;\n        const t2 = t1 - 2;\n        const time =\n          t1 < 1\n            ? 0.5 * (t1 * t1 * (a1 + 1) * t1 - a1)\n            : 0.5 * (t2 * t2 * ((a1 + 1) * t2 + a1) + 2);\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatBackInOutGPU,\n      loop,\n      methodName: \"slerpQuatBackInOut\"\n    };\n  }\n\n  /** A uid for the easing method */\n  uid = uid();\n  /** The easing method for the cpu */\n  cpu: IAutoEasingMethod<T>[\"cpu\"];\n  /** Time before a delay  */\n  delay: number = 0;\n  /** The time in ms is takes to complete the animation */\n  duration: number = 500;\n  /** The easing method on the GPU */\n  gpu: IAutoEasingMethod<T>[\"gpu\"];\n  /** The looping style of the animation */\n  loop = AutoEasingLoopStyle.NONE;\n  /** Method name of the ease function on the gpu */\n  methodName: string;\n\n  constructor(\n    cpu: IAutoEasingMethod<T>[\"cpu\"],\n    gpu: IAutoEasingMethod<T>[\"gpu\"],\n    duration?: number,\n    method?: string\n  ) {\n    this.cpu = cpu;\n    this.gpu = gpu;\n    this.duration = duration || 500;\n    this.methodName = method || \"easingMethod\";\n  }\n}\n","import { onAnimationLoop } from \"../../util/frame\";\n\n/**\n * This is the minimal interface required for a Transform node. This base exists\n * because not all node control is equal. No matter what, this needs to result\n * in output that places a node in 3D space, but there are different levels of\n * dimensionality for how this happens.\n *\n * For instance, the original intent of this interface is to allow for 3D and 2D\n * transform nodes. 3D has the full need of 4x4 matrics to transform\n * orientations into 3D space and rotate on all axis. 2D still needs to be\n * translated into the 3D world, but it's operations are specifically based on a\n * single axis of rotation and x,y coordinates which requires significantly less\n * operations to manage.\n */\nexport interface ITransformBase {}\n\n/**\n * Stores objects that MUST be updated for the sake of elements waiting for\n * updates from the transform. Due to elements being passive and our\n * TreeNode structure being passive, this is our glue that detects the elements\n * that WOULD have actively requested the update but won't due to passively\n * waiting without interaction.\n */\nconst updateSet = new Set<{ update(): void }>();\n\n/** Flags an object for an update cycle */\nexport const scheduleUpdate = updateSet.add.bind(updateSet);\n/** Removes an object from needing a scheduled update */\nexport const resolveUpdate = updateSet.delete.bind(updateSet);\n\n/**\n * We create a looping function to ensure the objects that MUST be updated\n * are dequeued and properly updated.\n */\nconst updateLoop = async () => {\n  // This pattern guarantees an always running loop that can not be stopped. The\n  // animation loop will continue forever and also cause a Promise that will\n  // never resolve. The Promise resolves only when the loop is stopped somehow,\n  // which we then immediately start our loop back up again.\n  await onAnimationLoop(\n    () => {\n      if (updateSet.size === 0) return;\n      updateSet.forEach(t => t.update());\n      updateSet.clear();\n    },\n    undefined,\n    Number.POSITIVE_INFINITY\n  );\n\n  updateLoop();\n};\n\nupdateLoop();\n","/**\n * This is simply a structural model that depicts parent child relationships\n * that forms a strict tree. This model does not allow for circular dependencies\n * within the tree structure.\n *\n * Circular dependencies can be formed (for performance reasons) but queries\n * against the tree will discover those dependencies and properly error at that\n * time.\n *\n * This also facilitates flow down updates. If this node needs an update, then\n * all of it's branches beneath it require an update as well. This also\n * facilitates gated updates to each child, meaning, if this node needs an\n * update, it will retain flags for each child to be updated. This allows us to\n * update this node but not immediately require all children beneath the node to\n * update. This makes updates more opt-in or 'as needed', thus allowing branches\n * to never update if they never need to.\n */\nexport abstract class TreeNode<T extends TreeNode<any>> {\n  /**\n   * The parent node of this node.\n   */\n  public get parent() {\n    return this._parent;\n  }\n  public set parent(parent: T | undefined) {\n    this.setParent(parent);\n  }\n  private _parent?: T;\n\n  /**\n   * The children registered with this node. This node will be the \"parent\"\n   * property of all the nodes in this list.\n   */\n  private _children: T[] = [];\n  public get children(): ReadonlyArray<T> {\n    return this._children;\n  }\n\n  /** This flag indicates this node itself needs to be updated */\n  public get needsUpdate(): boolean {\n    return this._needsUpdate;\n  }\n  private _needsUpdate: boolean = false;\n\n  /** This stores which children require updating still */\n  private _childUpdate: Set<T> = new Set();\n  public get childUpdate(): ReadonlySet<T> {\n    return this._childUpdate;\n  }\n\n  /**\n   * This adds a child to this node. This allows for unsafe adding of the child\n   * which will not update the other hierarchy properties.\n   */\n  addChild(child: T, unsafe?: boolean) {\n    // A child can not be doubly registered.\n    if (child.parent === this) return;\n\n    // Ensure the child references this node as it's parent now. The unsafe flag\n    // indicates we do not need to ensure the parent.\n    if (!unsafe) {\n      child.setParent(this, true);\n    }\n\n    this._children.push(child);\n    this._childUpdate.add(child);\n    child.invalidate();\n  }\n\n  /**\n   * This flags this node as invalid and sets all of it's children as needing to\n   * be updated as a result. This effectively flags the entrie branch system\n   * beneath this node as needing to be updated.\n   */\n  invalidate() {\n    // Only invalidate if this is not invalidated already\n    if (this._needsUpdate) return false;\n    this._needsUpdate = true;\n\n    // Invalidate all children\n    for (let i = 0, iMax = this._children.length; i < iMax; ++i) {\n      const child = this._children[i];\n      this._childUpdate.add(child);\n      child.invalidate();\n    }\n\n    return true;\n  }\n\n  /**\n   * This retrieves and analyzes all of the nodes that are needing an update up\n   * the chain from the current node. This resolves each node as it's\n   * discovered.\n   */\n  processParentUpdates(handle: (node: T) => void) {\n    // No parent update needed\n    if (!this._parent || !this._parent._needsUpdate) return;\n\n    const toProcess = [];\n    let next = this._parent;\n\n    while (next) {\n      toProcess.push(next);\n\n      if (next._parent && next._parent.needsUpdate) {\n        next = next._parent;\n      } else {\n        break;\n      }\n    }\n\n    // We now have all the parents up the chain that need updating before this\n    // node can be processed. We want to process these nodes from the top most\n    // parent downward, our list is built bottom up, so we have to loop it in\n    // reverse\n    for (let i = toProcess.length - 1; i >= 0; --i) {\n      const process = toProcess[i];\n      handle(process);\n      process.resolve();\n    }\n  }\n\n  /**\n   * Removes the specified child from this node. Only works if the child\n   * specifies this node as it's parent. This allows for unsafe removal of the\n   * child which will not update the other hierarchy properties.\n   */\n  removeChild(child: T, unsafe?: boolean) {\n    // Only nodes that are registered children of this node can be removed\n    if (child._parent !== this) return;\n\n    // Ensure the child has it's parent updated to no parent. The unsafe flag\n    // indicates this will be handled elsewhere.\n    if (child._parent !== void 0 && !unsafe) {\n      child.setParent(undefined, true);\n    }\n\n    // Clear the child from our child list\n    this._children.splice(this._children.indexOf(child), 1);\n    this._childUpdate.delete(child);\n  }\n\n  /**\n   * Clears update flags that are set from invalidation. This clears the nodes\n   * personal flag as well as the gate flag the parent contains for the node as\n   * well.\n   */\n  resolve() {\n    if (!this._needsUpdate) return;\n    this._needsUpdate = false;\n\n    if (this._parent) {\n      this._parent._childUpdate.delete(this);\n    }\n  }\n\n  /**\n   * Sets the parent of this node to the specified node. This is the same in\n   * most cases to node.parent = aNode; but this method allows for unsafe\n   * modification to the parent.\n   */\n  setParent(parent?: T, unsafe?: boolean) {\n    if (this._parent === parent) return;\n\n    if (!unsafe) {\n      // Add this as a child to the new parent\n      if (parent !== void 0) {\n        parent.addChild(this, true);\n      }\n\n      // Remove this from the old parent's child list\n      if (this._parent) {\n        this._parent.removeChild(this, true);\n      }\n    }\n\n    this._parent = parent;\n    this.invalidate();\n  }\n}\n","import { ISingleTouchInteraction } from \"../event-management/types\";\n\n/**\n * This file contains common methods for filtering data within the framework.\n */\n\n/**\n * When applied to a filter (eg - .filter(isDefined)), this will make the resulting array not have any FALSEY values.\n * This will also ensure the resulting TYPE of the array is not undefined or null. Thus:\n *\n * const test: (Type1 | Type2 | ... | undefined | null)[] = []\n * const notNull = test.filter(isDefined);\n *\n * notNull will now have a type that excludes undefined and null values.\n *\n * NOTE: The type correction seems to only work when you use this method DIRECTLY as a filter parameter\n * .filter(isDefined) Works!\n * .filter(val => isDefined(val)) Does NOT adjust typings!\n *\n * WARNING: This WILL filter out FALSEY values. So if values like 0 or '' is VALID, then beware.\n */\nexport function isDefined<T>(val: T | null | undefined): val is T {\n  return val !== void 0 && val !== null;\n}\n\n/**\n * This is a filter for touch events. This will filter down a list of ISingleTouchInteractions to a list that has\n * interactions who only have a specified start view.\n */\nexport function touchesHasStartView(view: string | string[]) {\n  if (Array.isArray(view)) {\n    return (touch: ISingleTouchInteraction) =>\n      view.indexOf(touch.start.view.id) >= 0;\n  }\n\n  return (touch: ISingleTouchInteraction) => touch.start.view.id === view;\n}\n\n/**\n * This is a filter for touch events. This will filter down a list of ISingleTouchInteractions to a list that has\n * interactions who only have a view that was under the start position of the touch.\n */\nexport function touchesContainsStartView(view: string | string[]) {\n  if (Array.isArray(view)) {\n    return (touch: ISingleTouchInteraction) =>\n      touch.start.views.find(v => view.indexOf(v.view.id) >= 0);\n  }\n\n  return (touch: ISingleTouchInteraction) =>\n    touch.start.views.find(v => v.view.id === view);\n}\n","function isFunction(val: any): val is Function {\n  return val && val.call !== void 0 && val.apply !== void 0;\n}\n\n/**\n * Method for handling retrieving a map value. This will inject a provided default value if the key does not return\n * a valid value. This will not work as expected if 'undefined' is a valid expected value.\n */\nexport function mapInjectDefault<T, U>(\n  map: Map<T, U>,\n  key: T,\n  defaultValue: U | (() => U)\n): U {\n  let value = map.get(key);\n\n  if (value === undefined) {\n    if (isFunction(defaultValue)) {\n      value = defaultValue();\n    } else {\n      value = defaultValue;\n    }\n\n    map.set(key, value);\n  }\n\n  return value;\n}\n\n/**\n * Method for handling retrieving a map value. This will provide a provided default value with no mutation to the map.\n * This will not work as expected if 'undefined' is a valid expected value.\n */\nexport function mapGetWithDefault<T, U>(\n  map: Map<T, U>,\n  key: T,\n  defaultValue: U | (() => U)\n): U {\n  let value = map.get(key);\n\n  if (value === undefined) {\n    if (isFunction(defaultValue)) {\n      value = defaultValue();\n    } else {\n      value = defaultValue;\n    }\n  }\n\n  return value;\n}\n","import { Instance } from \"../instance-provider/instance\";\nimport { IInstanceAttribute } from \"../types\";\n\n/**\n * Makes it easier to type out and get better editor help in establishing initShader\n */\nexport function createAttribute<T extends Instance>(\n  options: IInstanceAttribute<T> & Partial<{ [key: string]: any }>\n) {\n  return options;\n}\n","export * from \"./generate-default-scene\";\nexport * from \"./generate-layer-material\";\nexport * from \"./base-io-expansion\";\nexport * from \"./generate-layer-geometry\";\nexport * from \"./generate-layer-model\";\nexport * from \"./base-io-expanders\";\n","/**\n * This is the name used in the shader generated by the system to handle uniform buffer instancing.\n */\nexport const uniformBufferInstanceBufferName = \"instanceData\";\n/**\n * This is the identifying name used as the active atttribute\n * that determines if an instance is rendered or not.\n */\nexport const activeAttributeName = \"_active\";\n/**\n * Constant that can convert a number expressed in degrees to radians by multiplying\n */\nexport const TO_RADIANS = Math.PI / 180;\n/**\n * Constant that can convert a number expressed in radians to degrees by multiplying\n */\nexport const TO_DEGREES = 180 / Math.PI;\n","import { Scene } from \"../gl/scene\";\nimport { Instance } from \"../instance-provider/instance\";\nimport { IdentifyByKey, IdentifyByKeyOptions } from \"../util/identify-by-key\";\nimport { ReactiveDiff } from \"../util/reactive-diff\";\nimport {\n  ILayerProps,\n  ILayerPropsInternal,\n  Layer,\n  LayerInitializer,\n  LayerInitializerInternal\n} from \"./layer\";\nimport { generateDefaultElements } from \"./layer-processing/generate-default-scene\";\nimport { Surface } from \"./surface\";\nimport { IViewProps, View, ViewInitializer } from \"./view\";\n\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * Defines the input for an available scene layers can add themselves to. Each scene can be rendered with multiple\n * views.\n */\nexport interface ISceneOptions extends IdentifyByKeyOptions {\n  /**\n   * This decalres all of the layers that should be applied to this scene.\n   */\n  layers: LayerInitializer[];\n  /** Helps assert a guaranteed rendering order for scenes. Lower numbers reender first. */\n  order?: number;\n  /**\n   * This indicates all of the views this scene can be rendered with. For instance: You have a\n   * world scene and you want to render it stereoscopically for VR. Then you can specify two\n   * views with two viewports to render the scene on both halves of the canvas.\n   *\n   * Or perhaps you want an aerial shot as a minimap in the bottom right corner while the rest\n   * of the canvas renders a first person view, then you would make two views for that as well.\n   */\n  views: ViewInitializer<IViewProps>[];\n}\n\n/**\n * This defines a scene to which layers are added to. It also tracks the views that this scene\n * is rendered with.\n */\nexport class LayerScene extends IdentifyByKey {\n  static DEFAULT_SCENE_ID = \"__default__\";\n\n  /** This is the GL scene which actually sets up the rendering objects */\n  container: Scene | undefined = new Scene();\n  /** This is the diff tracker for the layers for the scene which allows us to make the pipeline easier to manage */\n  layerDiffs: ReactiveDiff<\n    Layer<Instance, ILayerProps<Instance>>,\n    LayerInitializer\n  >;\n  /** Helps assert a guaranteed render order for scenes. Lower numbers render first. */\n  order?: number;\n  /** The presiding surface over this scene */\n  surface?: Surface;\n  /** This is the diff tracker for the views for the scene which allows us to make the pip0eline easier to manage */\n  viewDiffs: ReactiveDiff<View<IViewProps>, ViewInitializer<IViewProps>>;\n\n  /** This is all of the layers attached to the scene */\n  get layers(): Layer<any, any>[] {\n    return this.layerDiffs.items;\n  }\n\n  /** This is all of the views attached to the scene */\n  get views(): View<IViewProps>[] {\n    return this.viewDiffs.items;\n  }\n\n  constructor(surface: Surface | undefined, options: ISceneOptions) {\n    super(options);\n    this.surface = surface;\n    this.init(options);\n  }\n\n  /**\n   * Initialize all that needs to be initialized\n   */\n  private init(options: ISceneOptions) {\n    // Make sure there is a rendering context set up\n    if (!this.surface || !this.surface.gl) return;\n    // Make a Scene for the GL layer to accept and render objects from\n    this.container = new Scene();\n    // Make default scene elements\n    const defaultElements = generateDefaultElements(this.surface.gl);\n\n    // Create the diff manager to handle the layers coming in.\n    this.layerDiffs = new ReactiveDiff({\n      buildItem: async (initializer: LayerInitializerInternal) => {\n        debug(\"Building layer\", initializer.key);\n        if (!this.surface) return null;\n        const layerClass = initializer.init[0];\n        const props = initializer.init[1];\n        // Generate the new layer and provide it it's initial props\n        const layer = new layerClass(\n          this.surface,\n          this,\n          Object.assign({}, layerClass.defaultProps, props)\n        );\n        // Keep the initializer object that generated the layer for reference and debugging\n        layer.initializer = initializer;\n        // Sync the data provider applied to the layer in case the provider has existing data\n        // before being applied to the layer\n        layer.props.data.sync();\n        // Look in the props of the layer for the parent of the layer\n        layer.parent = props.parent;\n\n        // If the parent is present, the parent should have the child added\n        if (props.parent) {\n          if (props.parent.children) props.parent.children.push(layer);\n          else props.parent.children = [layer];\n        }\n\n        // Add the layer to this surface\n        if (!layer.init(this.views)) {\n          console.warn(\n            \"Error initializing layer:\",\n            props.key,\n            \"A layer was unable to be added to the surface. See previous warnings (if any) to determine why they could not be instantiated\"\n          );\n\n          return null;\n        }\n\n        // Get the children for the layer\n        const children = layer.childLayers();\n        // Add in the children of the layer\n        this.layerDiffs.inline(children);\n\n        return layer;\n      },\n\n      destroyItem: async (\n        initializer: LayerInitializer,\n        layer: Layer<Instance, ILayerProps<Instance>>\n      ) => {\n        debug(\"Destroying layer\", initializer.key);\n        layer.destroy();\n        return true;\n      },\n\n      updateItem: async (\n        initializer: LayerInitializer,\n        layer: Layer<Instance, ILayerProps<Instance>>\n      ) => {\n        const props: ILayerPropsInternal<Instance> = initializer.init[1];\n        // Execute lifecycle method\n        layer.willUpdateProps(props);\n\n        // If we have a provider that is about to be newly set to the layer, then the provider\n        // needs to do a full sync in order to have existing elements in the provider\n        if (props.data !== layer.props.data) {\n          props.data.sync();\n        }\n\n        // Check to see if the layer is going to require it's view to be redrawn based on the props for the Layer changing,\n        // or by custom logic of the layer.\n        if (layer.shouldDrawView(layer.props, props)) {\n          layer.needsViewDrawn = true;\n        }\n\n        // Make sure the layer has the current props applied to it\n        Object.assign(layer.props, props);\n        // Keep the initializer up to date with the injected props\n        layer.initializer.init[1] = layer.props;\n        // Lifecycle hook\n        layer.didUpdateProps();\n\n        // If we are having a parent swap, we need to make sure the previous parent does not\n        // register this layer as a child anymore\n        if (props.parent) {\n          if (layer.parent && layer.parent !== props.parent) {\n            // RESUME: We're making sure deleted layers or regenerated layers properly have parent child relationships\n            // updated properly.\n            const children = layer.parent.children || [];\n            const index = children.indexOf(layer) || -1;\n\n            if (index > -1) {\n              children.splice(index, 1);\n            }\n          }\n        }\n\n        // Always make sure the layer's parent is set properly by the props\n        layer.parent = props.parent;\n\n        // A layer may flag itself as needing to be rebuilt. This is handled here and is completed by deleting\n        // the layer completely then generating the layer anew.\n        if (layer.willRebuildLayer) {\n          this.layerDiffs.rebuild();\n          layer.willRebuildLayer = false;\n        }\n\n        // If the layer is not regenerated, then during this render phase we add in the child layers of this layer.\n        else {\n          this.layerDiffs.inline(layer.childLayers());\n        }\n      }\n    });\n\n    // Create the diff manager to handle the views coming in.\n    this.viewDiffs = new ReactiveDiff({\n      buildItem: async (initializer: ViewInitializer<IViewProps>) => {\n        if (!this.surface) return null;\n        const newView = new initializer.init[0](this, initializer.init[1]);\n        newView.props.camera = newView.props.camera || defaultElements.camera;\n        newView.pixelRatio = this.surface.pixelRatio;\n        newView.resource = this.surface.resourceManager;\n        this.surface.userInputManager.waitingForRender = true;\n\n        return newView;\n      },\n\n      // No special needs for destroying/removing a view\n      destroyItem: async (\n        _initializer: ViewInitializer<IViewProps>,\n        _view: View<IViewProps>\n      ) => true,\n\n      // Hand off the initializer to the update of the view\n      updateItem: async (\n        initializer: ViewInitializer<IViewProps>,\n        view: View<IViewProps>\n      ) => {\n        const props = initializer.init[1];\n        view.willUpdateProps(props);\n\n        if (view.shouldDrawView(view.props, props)) {\n          view.needsDraw = true;\n        }\n\n        Object.assign(view.props, props);\n        view.didUpdateProps();\n\n        if (this.surface) {\n          this.surface.userInputManager.waitingForRender = true;\n        }\n      }\n    });\n\n    // Now add in the initial data into our diff objects\n    this.update(options);\n  }\n\n  /**\n   * Release any resources this may be hanging onto\n   */\n  destroy() {\n    delete this.container;\n    this.layerDiffs.destroy();\n    this.viewDiffs.destroy();\n  }\n\n  /**\n   * Ensures a layer is removed from the scene\n   */\n  removeLayer(layer: Layer<any, any>) {\n    if (this.layers) {\n      const index = this.layers.indexOf(layer);\n\n      if (index >= 0) {\n        this.layers.splice(index, 1);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Hand off the diff objects to our view and layer diffs\n   */\n  async update(options: ISceneOptions) {\n    this.order = options.order;\n    await this.viewDiffs.diff(options.views);\n    await this.layerDiffs.diff(options.layers);\n    // After the views and layers have been updated and created, we can now tell\n    // the views to establish their render targets as creating the render\n    // targets is dependent on how the layer's analyzed the output of the views\n    this.views.forEach(view => view.createRenderTarget());\n  }\n}\n","import { IdentifiableById } from \"../types\";\n\n/**\n * These are the minimum properties required for a ReactiveDiff to monitor a set of objects.\n */\nexport type ReactiveDiffObject<U> = {\n  /** The identifier of the object which is used to determine who is added/removed/updated */\n  key: string | number;\n  /** When inline() is used, it designates the caller of inline as the parent object */\n  parent?: U;\n};\n\n/**\n * Customizes a ReactiveDiff object\n */\nexport interface IReactiveDiffOptions<U, T extends ReactiveDiffObject<U>> {\n  /** This method will execute when this controller has determined a new object should be constructed */\n  buildItem(intiializer: T): Promise<U | null>;\n  /** This method will execute when this controller has determined an object should be deconstructed */\n  destroyItem(intiializer: T, item: U): Promise<boolean | null>;\n  /** This method will execute when this controller has determined an object has potential new properties to be applied to it */\n  updateItem(initializer: T, item: U): Promise<void>;\n}\n\n/**\n * This is a helper object to monitor a set of objects\n */\nexport class ReactiveDiff<\n  U extends IdentifiableById | null,\n  T extends ReactiveDiffObject<U>\n> {\n  /** The options used to construct this controller */\n  private options: IReactiveDiffOptions<U, T>;\n  /** All items flagged for disposing */\n  private willDispose = new Set<T[\"key\"]>();\n  /** We track all items by their key for quicker processing */\n  private keyToItem = new Map<T[\"key\"], U>();\n  /** We track all initializers by their key for quicker processing */\n  private keyToInitializer = new Map<T[\"key\"], T>();\n  /** Used to faciliate and enable the inline() ability */\n  private currentInitalizerIndex = 0;\n  /**\n   * The current initializers being processed. This is used to ensure the inline() method can inject correctly without\n   * jmutating the input initializer list.\n   */\n  private currentInitializers: T[] = [];\n  /**\n   * This is the list of the items generated and managed by this diff object, this list is in the order they appear\n   * in the diff initializers injected into the diff.\n   */\n  private _items: U[] = [];\n  /**\n   * While processing, this keeps track of the currently executing initializer and object\n   */\n  private currentInitializer?: T;\n  private currentItem?: U;\n  /**\n   * This stores deferred inlined elements that are waiting for their parent to be completely created\n   */\n  private deferredInlining?: T[];\n\n  /** A list of all the items currently alive and managed by this diff */\n  get items(): U[] {\n    return this._items.slice(0);\n  }\n\n  constructor(options: IReactiveDiffOptions<U, T>) {\n    this.options = options;\n  }\n\n  /**\n   * This triggers all resources currently managed by this diff manager to process their destroy procedure\n   */\n  async destroy() {\n    const promises: Promise<boolean | null>[] = [];\n\n    for (let i = 0, iMax = this.currentInitializers.length; i < iMax; ++i) {\n      const init = this.currentInitializers[i];\n      const item = this.keyToItem.get(init.key);\n      if (!item) continue;\n      promises.push(this.options.destroyItem(init, item));\n    }\n\n    await Promise.all(promises);\n  }\n\n  /**\n   * This injects the objects into the diff to be processed for new and removed items.\n   */\n  async diff(intializers: T[]) {\n    // Make sure we don't mutate the input\n    const processing = intializers.slice(0);\n    this.currentInitializers = processing;\n    // Clear out our items listing so we can repopulate it with the correct order of elements injected\n    this._items = [];\n\n    // We loop through all items injected to see who is new, who exists already, and who no longer\n    // exists in our input list. We MUST analyze the length on the loop as this list can be expanded.\n    // We use a while loop to ensure the async pattern is honored.\n    let i = 0;\n    while (i < processing.length) {\n      const initializer = processing[i];\n      this.currentInitalizerIndex = i;\n      this.currentInitializer = initializer;\n\n      // Existing items will be in our dispose list, so since we received this item again\n      // then we merely have an update and we remove the flag that would cause it to get tossed away\n      if (this.willDispose.has(initializer.key)) {\n        let item = this.keyToItem.get(initializer.key) || null;\n\n        if (item) {\n          this.currentItem = item;\n          await this.options.updateItem(initializer, item);\n        } else {\n          item = await this.options.buildItem(initializer);\n        }\n\n        if (item) {\n          this.keyToInitializer.set(initializer.key, initializer);\n          this.willDispose.delete(initializer.key);\n          this._items.push(item);\n        }\n      }\n\n      // Items that are not existing already will not be in the dispose queue\n      else {\n        this.inline = this.inlineDeferred;\n        const item = await this.options.buildItem(initializer);\n        this.inline = this.inlineImmediate;\n\n        // Check to see if we successfully generated an item\n        if (item) {\n          this.currentItem = item;\n\n          if (this.deferredInlining) {\n            this.inline(this.deferredInlining);\n            delete this.deferredInlining;\n          }\n\n          this.keyToItem.set(initializer.key, item);\n          this.keyToInitializer.set(initializer.key, initializer);\n          this._items.push(item);\n        }\n      }\n\n      delete this.currentItem;\n      i++;\n    }\n\n    // Now that we have processed all incoming items, the remaining items in our disposal list\n    // are the items we should remove.\n    this.willDispose.forEach(async (key: string) => {\n      const item = this.keyToItem.get(key);\n      const initializer = this.keyToInitializer.get(key);\n      if (!item || !initializer) return;\n      const success = await this.options.destroyItem(initializer, item);\n\n      if (success) {\n        this.keyToItem.delete(key);\n        this.keyToInitializer.delete(key);\n      }\n    });\n\n    // Clear the disposal list so we can make it anew\n    this.willDispose.clear();\n\n    // Now we take all existing items and flag them anew for disposal\n    this.keyToInitializer.forEach(item => {\n      this.willDispose.add(item.key);\n    });\n\n    // Don't hang onto the mutated list of initializers\n    this.currentInitializers = [];\n    delete this.currentItem;\n    delete this.currentInitializer;\n  }\n\n  /**\n   * Returns a specified item by key\n   */\n  getByKey(key: string) {\n    return this.keyToItem.get(key);\n  }\n\n  /**\n   * This method is used to inline new elements at the time a creation occurs\n   */\n  private inlineDeferred = (newInitializers: T[]) => {\n    this.deferredInlining = newInitializers;\n  };\n\n  /**\n   * This method is used to inline new elements at the time an update occurs\n   */\n  private inlineImmediate = (newInitializers: T[]) => {\n    if (\n      newInitializers.length > 0 &&\n      this.currentInitializers &&\n      this.currentItem\n    ) {\n      this.currentInitializers.splice(\n        this.currentInitalizerIndex + 1,\n        0,\n        ...newInitializers\n      );\n\n      for (let i = 0, iMax = newInitializers.length; i < iMax; ++i) {\n        const init = newInitializers[i];\n        init.parent = this.currentItem;\n      }\n    }\n  };\n\n  /**\n   * Inlining new items takes on two different modes: immediate inlining for during update cycles\n   * and inlining during creation cycles which requires deferring the inline until the creation of the item has been completed.\n   */\n  inline = this.inlineImmediate;\n\n  /**\n   * Only during the updateItem phase of an item can this be called. This will cause the item\n   * to be fully destroyed, then reconstructed instead of go through an update.\n   */\n  async rebuild() {\n    // Only execute if currently running diffs and if currently in an update phase\n    if (!this.currentItem || !this.currentInitializer) return;\n    // Clear the item from any look ups\n    this.keyToItem.delete(this.currentItem.id);\n    this.keyToInitializer.delete(this.currentItem.id);\n    // Perform the destruction of the item\n    this.options.destroyItem(this.currentInitializer, this.currentItem);\n    // Rebuild the item\n    const item = await this.options.buildItem(this.currentInitializer);\n\n    // Re-add the item to the lookups if the rebuild succeeded\n    if (item) {\n      this.keyToItem.set(this.currentItem.id, item);\n      this.keyToInitializer.set(this.currentItem.id, this.currentInitializer);\n    }\n  }\n}\n","import { GLSettings } from \"../gl/gl-settings\";\nimport { ILayerMaterialOptions } from \"../types\";\n\n/**\n * These are material options you may commonly see for handling various scenarios.\n */\nexport class CommonMaterialOptions {\n  /**\n   * Sets up blending for transparent shapes.\n   * Removes need for gl_FragColor.rgb *= gl_FragColor.a in shader.\n   */\n  static transparentShapeBlending: ILayerMaterialOptions = {\n    blending: {\n      blendDst: GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha,\n      blendEquation: GLSettings.Material.BlendingEquations.Add,\n      blendSrc: GLSettings.Material.BlendingSrcFactor.SrcAlpha\n    },\n    culling: GLSettings.Material.CullSide.NONE\n  };\n\n  /**\n   * Sets up blending for transparent images. This requires the image to be premultipled alpha.\n   * Removes need for texel.rgb *= texel.a; as it assumes the value is premultiplied.\n   */\n  static transparentImageBlending: ILayerMaterialOptions = {\n    blending: {\n      blendSrc: GLSettings.Material.BlendingSrcFactor.One,\n      blendDst: GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha,\n      blendEquation: GLSettings.Material.BlendingEquations.Add\n    },\n    culling: GLSettings.Material.CullSide.NONE\n  };\n}\n","import { Texture } from \"../../gl/texture\";\nimport { ResourceType } from \"../../types\";\nimport { BaseResourceRequest } from \"../base-resource-manager\";\nimport { FontMap, KernedLayout } from \"./font-map\";\n\nexport enum FontResourceRequestFetch {\n  /** Retrieves the tex coordinates on the font map of the specified character glyph. Defaults to [0, 0, 0, 0] */\n  TEXCOORDS = 0,\n  /** Retrieves the pixel size of the character glyph on the font map */\n  IMAGE_SIZE = 1\n}\n\n/**\n * Properties needed to make a font resource request\n */\nexport interface IFontResourceRequest extends BaseResourceRequest {\n  /** The character being requested from the fontmap */\n  character?: string;\n  /** This changes the information retrieved as a result of the request method. */\n  fetch?: FontResourceRequestFetch;\n  /**\n   * When the request has been processed and results become available, this is populated with the FontMap object that has everything\n   * needed for the requester to get the information needed.\n   */\n  fontMap?: FontMap;\n  /**\n   * The characters for which we want to have the kerning information retrieved. This will be applied as a list of words\n   * for which we want the kerning information. We do this to prevent concating the words into a single string which can\n   * make it really difficult to preload all possible label combinations.\n   */\n  kerningPairs?: string[];\n  /** When provided, the request will fill in the metrics for the input parameters */\n  metrics?: {\n    /** The desired font size for the layout */\n    fontSize: number;\n    /**\n     * The system will populate this for you with the layout (top left is at 0,0) of the text.\n     * If maxWidth is provided, this will be the layout of the truncated text.\n     */\n    layout?: KernedLayout;\n    /** Spacing between letters in a label */\n    letterSpacing: number;\n    /** When provided, this will cause the system to see if the text should be truncated or not */\n    maxWidth?: number;\n    /** This is the source text that we wish to receive the metrics for. */\n    text: string;\n    /** These are the characters to use to indicate truncation in the event truncation takes place */\n    truncation?: string;\n    /**\n     * If maxWidth is provided, this will provide the calculated truncated text. This will be the full\n     * text if no truncation is provided.\n     */\n    truncatedText?: string;\n  };\n  /** This is to satisfy the use of the TextureIOExpansion. This is the texture within the fontmap */\n  texture?: Texture;\n  /** Establish the only type that this request shall be is a FONT type */\n  type: ResourceType.FONT;\n}\n\n/**\n * Wrapper method to create a font resource request to make typings and intellisense work better.\n */\nexport function fontRequest(\n  options: Omit<IFontResourceRequest, \"type\">\n): IFontResourceRequest {\n  return {\n    type: ResourceType.FONT,\n    ...options\n  };\n}\n\n/**\n * Provides a Preload string that can be applied to 'preload' in a FontMapSource that will cause all numbers to be able\n * to render without interruption.\n */\nexport function preloadNumber() {\n  return (\n    \".101112131415161718191.202122232425262728292.303132333435363738393.404142434445464748494.505152535455565758595.\" +\n    \"606162636465666768696.707172737475767778797.808182838485868788898.909192939495969798999.000102030405060708090.\" +\n    \"$0$1$2$3$4$5$6$7$8$9$\" +\n    \"%0%1%2%3%4%5%6%7%8%9%\" +\n    \"-0-1-2-3-4-5-6-7-8-9-\" +\n    \"+0+1+2+3+4+5+6+7+8+9+\" +\n    \")0)1)2)3)4)5)6)7)8)9)\" +\n    \"(0(1(2(3(4(5(6(7(8(9(\"\n  );\n}\n","import { Texture, TextureOptions } from \"../../gl/texture\";\nimport { Vec2 } from \"../../math/vector\";\nimport { Omit, ResourceType, TextureSize } from \"../../types\";\nimport { IdentifyByKey } from \"../../util/identify-by-key\";\nimport { BaseResourceOptions } from \"../base-resource-manager\";\nimport { IAtlasResourceRequest } from \"./atlas-resource-request\";\nimport { PackNode } from \"./pack-node\";\nimport { SubTexture } from \"./sub-texture\";\nimport { VideoTextureMonitor } from \"./video-texture-monitor\";\n\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * Options required for generating an atlas.\n */\nexport interface IAtlasResource extends BaseResourceOptions {\n  /** Set the type of the resource to explicitally be an atlas resource */\n  type: ResourceType.ATLAS;\n  /** This is the height of the texture */\n  height: TextureSize;\n  /** This is the width of the atlas */\n  width: TextureSize;\n  /**\n   * This applies any desired settings to the Texture.\n   * Some noteable defaults this system sets:\n   *  - generateMipMaps is true and\n   *  - premultiply alpha is true.\n   */\n  textureSettings?: TextureOptions;\n}\n\n/**\n * Use this in the property creation of atlas'.\n */\nexport function createAtlas(\n  options: Omit<IAtlasResource, \"type\" | \"key\"> &\n    Partial<Pick<IAtlasResource, \"key\">>\n): IAtlasResource {\n  return {\n    key: \"\",\n    type: ResourceType.ATLAS,\n    ...options\n  };\n}\n\n/**\n * Type guard for the atlas resource type.\n */\nexport function isAtlasResource(val: BaseResourceOptions): val is Atlas {\n  return val && val.type === ResourceType.ATLAS;\n}\n\ntype ResourceReference = {\n  subtexture: SubTexture;\n  count: number;\n  videoMonitor?: VideoTextureMonitor;\n};\n\n/**\n * This represents a single Texture on the gpu that is composed of several smaller textures\n * as a 'look up'.\n */\nexport class Atlas extends IdentifyByKey implements IAtlasResource {\n  /** Stores the size of the atlas texture */\n  height: TextureSize;\n  /** This is the packing of the atlas with images */\n  packing: PackNode<SubTexture>;\n  /**\n   * This is storage for handling resource reference counting. When a resource's reference drops below\n   * a count of 1, then the resource is disposed and it's space on the atlas is flagged for freeing up\n   * should the atlas need to consolidate resources.\n   */\n  resourceReferences = new Map<\n    IAtlasResourceRequest[\"source\"],\n    ResourceReference\n  >();\n  /** This is the actual texture object that represents the atlas on the GPU */\n  texture: Texture;\n  /** These are the applied settings to our texture */\n  textureSettings?: TextureOptions;\n  /** The resource type for resource management */\n  type: number = ResourceType.ATLAS;\n  /** Stores the size of the atlas texture */\n  width: TextureSize;\n\n  constructor(options: IAtlasResource) {\n    super(options);\n    const canvas = document.createElement(\"canvas\");\n    this.width = canvas.width = options.width;\n    this.height = canvas.height = options.height;\n    this.textureSettings = options.textureSettings;\n\n    if (options.width < 0 || options.height < 0) {\n      throw new Error(\n        \"TextureSize Error: An atlas does NOT support Screen Texture sizing.\"\n      );\n    }\n\n    // Set up the packing for this atlas\n    this.packing = new PackNode(0, 0, options.width, options.height);\n    // Make sure the texture is started and updated\n    this.createTexture(canvas);\n  }\n\n  /**\n   * This generates the texture object needed for this atlas.\n   */\n  private createTexture(canvas?: HTMLCanvasElement) {\n    if (this.texture) return;\n\n    // Establish the settings to be applied to the Texture\n    let textureSettings;\n\n    if (this.textureSettings) {\n      textureSettings = {\n        generateMipMaps: true,\n        premultiplyAlpha: true,\n        ...this.textureSettings\n      };\n    } else {\n      textureSettings = {\n        generateMipMaps: true,\n        premultiplyAlpha: true\n      };\n    }\n\n    // Generate the texture\n    this.texture = new Texture({\n      data: canvas,\n      ...textureSettings\n    });\n  }\n\n  /**\n   * This frees up all the resources down to the GPU related to this atlas. It also\n   * loops through every resource and invalidates the texturing information within\n   * them so subsequent accidental renders will appear as a single color rather than\n   * an artifacted element.\n   */\n  destroy() {\n    // Delete the GPU's texture object\n    this.texture.destroy();\n\n    // Invalidate the Sub textures so they don't start rendering wild colors. Instead\n    // should render a single color at the 0, 0 mark of the texture.\n    this.resourceReferences.forEach(resource => {\n      this.invalidateTexture(resource.subtexture);\n    });\n  }\n\n  /**\n   * This invalidates the SubTexture of an atlas resource.\n   */\n  private invalidateTexture(texture: SubTexture) {\n    const zero: Vec2 = [0, 0];\n\n    // Make anything trying to render with the image not render much anything useful\n    texture.aspectRatio = 1;\n    texture.atlasBL = zero;\n    texture.atlasBR = zero;\n    texture.atlasTL = zero;\n    texture.atlasTR = zero;\n    texture.isValid = false;\n    texture.texture = null;\n    texture.pixelHeight = 0;\n    texture.pixelWidth = 0;\n    delete texture.source;\n\n    // Video monitoring should be stopped at this point.\n    if (texture.video) {\n      texture.video.monitor.destroy();\n      delete texture.video;\n    }\n  }\n\n  /**\n   * This will look through all resources in this atlas and will determine if the resource\n   * should be removed or not.\n   */\n  resolveResources() {\n    const toRemove: IAtlasResourceRequest[\"source\"][] = [];\n\n    this.resourceReferences.forEach((ref, source) => {\n      if (ref.count <= 0 && ref.subtexture) {\n        debug(\n          \"A subtexture on an atlas has been invalidated as it is deemed no longer used: %o\",\n          ref.subtexture\n        );\n        this.invalidateTexture(ref.subtexture);\n        toRemove.push(source);\n      }\n    });\n\n    for (let i = 0, iMax = toRemove.length; i < iMax; ++i) {\n      this.resourceReferences.delete(toRemove[i]);\n    }\n  }\n\n  /**\n   * This flags a resource no longeer used and decrements it's reference count.\n   * If the use of the resource drops low enough, this will clear out the resurce\n   * completely.\n   */\n  stopUsingResource(request: IAtlasResourceRequest) {\n    const reference: ResourceReference = this.resourceReferences.get(\n      request.source\n    ) || {\n      subtexture: request.texture || new SubTexture(),\n      count: 0\n    };\n\n    reference.count--;\n  }\n\n  /**\n   * This flags a resource for use and increments it's reference count.\n   */\n  useResource(request: IAtlasResourceRequest) {\n    const reference = this.resourceReferences.get(request.source) || {\n      subtexture: request.texture,\n      count: 0\n    };\n\n    reference.count++;\n  }\n}\n","import { observable } from \"../../../instance-provider\";\nimport {\n  IInstanceOptions,\n  Instance\n} from \"../../../instance-provider/instance\";\nimport { Vec2 } from \"../../../math\";\nimport { isWhiteSpace, Size } from \"../../../types\";\nimport { Anchor, AnchorType } from \"../../types\";\nimport { GlyphInstance } from \"./glyph-instance\";\nimport { TextAreaInstance } from \"./text-area-instance\";\n\nexport interface ILabelInstanceOptions extends IInstanceOptions {\n  /**\n   * The point on the label which will be placed in world space via the x, y coords. This is also the point\n   * which the label will be scaled around.\n   */\n  anchor?: Anchor;\n  /** The color the label should render as */\n  color: [number, number, number, number];\n  /** Depth sorting of the label (or the z value of the label) */\n  depth?: number;\n  /** The font size of the label in px */\n  fontSize?: number;\n  /** When this is set labels will only draw the label up to this size. If below, the label will automatically truncate with ellipses */\n  maxWidth?: number;\n  /** When in BOUND_MAX mode, this allows the label to scale up beyond it's max size */\n  maxScale?: number;\n  /** Scales the label uniformly */\n  scale?: number;\n  /** The text rendered by this label*/\n  text: string;\n  /** The xy coordinate where the label will be anchored to in world space */\n  origin: Vec2;\n  /**\n   * Special flag for the instance that will cause the instance to not render any glyphs but will ensure the label's\n   * Kerning is calculated.\n   */\n  preload?: boolean;\n  /** Spacing width between letters in a label */\n  letterSpacing?: number;\n  /** Event when the label is completely ready to render all of it's glyphs */\n  onReady?(instance: LabelInstance): void;\n}\n\n/**\n * This generates a new label instance which will render a single line of text for a given layer.\n * There are restrictions surrounding labels due to texture sizes and rendering limitations.\n */\nexport class LabelInstance extends Instance {\n  /** This is the rendered color of the label */\n  @observable color: [number, number, number, number] = [0, 0, 0, 1];\n  /** Depth sorting of the label (or the z value of the label) */\n  @observable depth: number = 0;\n  /**\n   * Font size in world coordinates. This causes scaling relative to the base font resource available.\n   * IE- If the font resource is rendered at 32 and this is 16, then the output rendering will\n   *     be glyphs that are 50% the size of the rendered glyph in the font map. This can cause\n   *     artefacts based on the rendering strategy used.\n   */\n  @observable fontSize: number = 12;\n  /** When in BOUND_MAX mode, this controls how much scaling is allowed up to the base font size */\n  @observable maxScale: number = 1;\n  /**\n   * This is the maximum width the label can take up. If this is exceeded the label gets truncated.\n   * A max width of 0 or less is unbounded and will not truncate the text. When a max width is specified,\n   * there will always be a minimum requirement to show ellipses which inevitably causes a min width to\n   * arise and is dependent on the font in use.\n   */\n  @observable maxWidth: number = 0;\n  /** The x coordinate where the label will be anchored to in world space */\n  @observable origin: Vec2 = [0, 0];\n  /** Scales the label uniformly */\n  @observable scale: number = 1.0;\n  /** The rendered text for the label. */\n  @observable text: string = \"\";\n  /** Spacing between letters in a label */\n  @observable letterSpacing: number = 0;\n\n  /** This executes when the label is finished waiting for it's glyphs to be ready to render */\n  onReady?: (label: LabelInstance) => void;\n  /** The text area this label is associated with (may NOT be associated at all) */\n  parentTextArea?: TextAreaInstance;\n  /**\n   * Special flag for the instance that will cause the instance to not render any glyphs but will ensure the label's\n   * Kerning is calculated.\n   */\n  preload: boolean = false;\n  /**\n   * After the label has been rendered, this will be populated with all of the glyphs that\n   * have been created for the label. Using this you can manipulate each character very easily.\n   *\n   * NOTE: it helps to use nextFrame() to wait for this to be populated after the label has been mounted.\n   */\n  glyphs: GlyphInstance[] = [];\n  /**\n   * After the label has been rendered, this will be populated with the calculated width and height of the\n   * label.\n   */\n  size: Size = [0, 0];\n\n  /**\n   * If a maxWidth is specified, there is a chance the text will be truncated.\n   * This provides the calculated truncated text. If not populated, then no truncation\n   * has happened.\n   */\n  truncatedText: string = \"\";\n\n  /** This is the anchor location relative to the label's render space */\n  @observable\n  anchor: Anchor = {\n    padding: 0,\n    paddingDirection: [0, 0],\n    type: AnchorType.TopLeft,\n    x: 0,\n    y: 0\n  };\n\n  constructor(options: ILabelInstanceOptions) {\n    super(options);\n\n    this.anchor = options.anchor || this.anchor;\n    this.color = options.color || this.color;\n    this.depth = options.depth || this.depth;\n    this.fontSize = options.fontSize || this.fontSize;\n    this.maxScale = options.maxScale || this.maxScale;\n    this.maxWidth = options.maxWidth || 0;\n    this.onReady = options.onReady;\n    this.origin = options.origin;\n    this.preload = options.preload || false;\n    this.scale = options.scale || this.scale;\n    this.text = options.text || this.text;\n    this.letterSpacing = options.letterSpacing || this.letterSpacing;\n\n    // Make sure the anchor is set to the appropriate location\n    options.anchor && this.setAnchor(options.anchor);\n  }\n\n  getWidth(): number {\n    return this.size[0];\n  }\n\n  /**\n   * This applies a new anchor to this label and properly determines it's anchor position on the label\n   */\n  setAnchor(anchor: Anchor) {\n    const newAnchor = {\n      padding: anchor.padding || 0,\n      paddingDirection: anchor.paddingDirection,\n      type: anchor.type,\n      x: anchor.x || 0,\n      y: anchor.y || 0\n    };\n\n    // Apply the anchor\n    this.anchor = newAnchor;\n  }\n\n  /**\n   * Looks for the subtext provided, then provides the glyphs for that subtext if any.\n   */\n  subTextGlyphs(text: string): GlyphInstance[] {\n    const glyphs: GlyphInstance[] = [];\n    const index = this.text.indexOf(text);\n    // The substring must exist within the text.\n    if (index < 0) return glyphs;\n    // Current glyph index we are at as white space does not receive a glyph.\n    let glyphIndex = 0;\n\n    for (\n      let i = 0, iMax = Math.min(this.text.length, index + text.length);\n      i < iMax;\n      ++i\n    ) {\n      if (!isWhiteSpace(this.text[i])) {\n        glyphIndex++;\n\n        if (i >= index) {\n          glyphs.push(this.glyphs[glyphIndex]);\n        }\n      }\n    }\n\n    return glyphs;\n  }\n\n  /**\n   * Trigger for when resources are prepped for this instance\n   */\n  resourceTrigger() {\n    // No triggers are needed for the label instance as it's a wrapper for glyphs.\n    // The only trigger needed is when the active flag is altered by the manager.\n  }\n}\n","import { IView2DProps } from \"../../../2d\";\nimport { IRenderTextureResource } from \"../../../resources/texture/render-texture\";\nimport {\n  FragmentOutputType,\n  ILayerMaterialOptions,\n  UniformSize\n} from \"../../../types\";\nimport { postProcess } from \"../../post-process\";\n\nexport enum BoxSampleDirection {\n  DOWN,\n  UP\n}\n\nexport interface IBoxSample {\n  /** Specifies the resource taken in that will be blurred for the output */\n  input: IRenderTextureResource;\n  /** Specifies an output resource key to send the results to */\n  output?: IRenderTextureResource;\n  /** For debugging only. Prints generated shader to the console. */\n  printShader?: boolean;\n  /** Set for down or up sampling */\n  direction: BoxSampleDirection;\n  /** Options to send to the view */\n  view?: Partial<IView2DProps>;\n  /**\n   * Allows you to control material options such as blend modes of the post\n   * process effect.\n   */\n  material?: ILayerMaterialOptions;\n}\n\n/**\n * Performs downsampling or upsampling of an image by utilizing the linear\n * interpolation properties of texture samplong using the GPU.\n */\nexport function boxSample(options: IBoxSample) {\n  const { output, input } = options;\n\n  return postProcess({\n    printShader: options.printShader,\n    view: Object.assign(\n      output\n        ? {\n            output: {\n              buffers: { [FragmentOutputType.COLOR]: output },\n              depth: false\n            }\n          }\n        : {},\n      options.view\n    ),\n    buffers: { color: input },\n    shader: require(\"./box-sample.fs\"),\n    material: options.material,\n    uniforms: [\n      {\n        name: \"delta\",\n        size: UniformSize.ONE,\n        update: () => (options.direction === BoxSampleDirection.DOWN ? 1 : 0.5)\n      }\n    ]\n  });\n}\n","import { CanvasElement, isOffscreenCanvas } from \"../gl\";\nimport { Bounds } from \"../math/primitives\";\nimport { add2, length2, scale2, subtract2, Vec2 } from \"../math/vector\";\nimport { LayerScene } from \"../surface/layer-scene\";\nimport { Surface } from \"../surface/surface\";\nimport { IViewProps, NoView, View } from \"../surface/view\";\nimport { isDefined } from \"../util/common-filters\";\nimport { eventElementPosition, normalizeWheel } from \"../util/mouse\";\nimport { QuadTree } from \"../util/quad-tree\";\nimport { EventManager } from \"./event-manager\";\nimport {\n  IEventInteraction,\n  IMouseInteraction,\n  IMouseMetrics,\n  IMultiTouchInteraction,\n  IMultiTouchMetrics,\n  ISingleTouchInteraction,\n  ITouchInteraction,\n  ITouchMetrics,\n  IWheelMetrics\n} from \"./types\";\n\n// If a mouse up after a mouse down happens before this many milliseconds, a\n// click gesture will happen\nconst VALID_CLICK_DELAY = 1e3;\nconst VALID_TAP_DELAY = 200;\nconst emptyView: View<IViewProps> = new NoView();\n\nemptyView.fitViewtoViewport(\n  new Bounds({ x: 0, y: 0, width: 100, height: 100 }),\n  new Bounds({ x: 0, y: 0, width: 100, height: 100 })\n);\n\nfunction sortByDepth(a: Bounds<View<IViewProps>>, b: Bounds<View<IViewProps>>) {\n  if (b.d && a.d) return b.d.depth - a.d.depth;\n  return 0;\n}\n\n/**\n * Sorts touch metrics by the identifier for the touch\n */\nfunction sortByIdentifier(a: ITouchMetrics, b: ITouchMetrics) {\n  return a.touch.identifier - b.touch.identifier;\n}\n\n/**\n * This manages mouse events on the provided canvas and provides some higher\n * level interactions with the surface.\n */\nexport class UserInputEventManager {\n  /** This is the canvas context we are rendering to */\n  context: CanvasElement;\n  /**\n   * This is list of Event Managers that receive the events and gestures which\n   * respond to the events and perform actions.\n   */\n  eventManagers: EventManager[];\n  /** This is the quad tree for finding intersections with the mouse */\n  quadTree: QuadTree<Bounds<View<IViewProps>>>;\n  /** The parent layer surface this event manager is beneath */\n  surface: Surface;\n  /** The events created that need to be removed */\n  eventCleanup: [string, EventListenerOrEventListenerObject][] = [];\n  /** This is the most recent event interaction produced by this manager */\n  currentInteraction?: IEventInteraction;\n\n  /**\n   * This flag is set when the system is waiting to render the elements to\n   * establish bounds. No Mouse interations will happen while this is set to\n   * true.\n   */\n  private _waitingForRender: boolean = true;\n\n  get waitingForRender() {\n    return this._waitingForRender;\n  }\n\n  set waitingForRender(val: boolean) {\n    this._waitingForRender = val;\n\n    // When we're no longer waiting for render to occur we update all of our\n    // views in the quad tree\n    if (!val) {\n      this.quadTree = new QuadTree(0, 0, 0, 0);\n      const scenes = this.scenes;\n      const bounds = [];\n\n      for (let i = 0, iMax = scenes.length; i < iMax; ++i) {\n        const scene = scenes[i];\n\n        for (let k = 0, kMax = scene.views.length; k < kMax; ++k) {\n          const view = scene.views[k];\n          bounds.push(view.screenBounds);\n        }\n      }\n\n      this.quadTree.addAll(bounds);\n    }\n  }\n\n  get scenes(): LayerScene[] {\n    if (!this.surface || !this.surface.sceneDiffs) return [];\n    return this.surface.sceneDiffs.items;\n  }\n\n  constructor(\n    canvas: CanvasElement,\n    surface: Surface,\n    controllers: EventManager[],\n    handlesWheelEvents?: boolean\n  ) {\n    this.context = canvas;\n    this.surface = surface;\n    this.setControllers(controllers);\n    this.addContextListeners(handlesWheelEvents);\n  }\n\n  /**\n   * This sets up the DOM events to listen to the events that are broadcasted by the canvas.\n   * These events are set up in such a way as to continue some events when the user\n   * drags the mouse off of the browser or off the canvas without releasing.\n   */\n  addContextListeners(handlesWheelEvents?: boolean) {\n    // Enable mouse support\n    this.addMouseContextListeners(handlesWheelEvents);\n    // Enable touch support\n    this.addTouchContextListeners();\n  }\n\n  /**\n   * Adds all listeners needed to make the mouse interact with the context.\n   */\n  private addMouseContextListeners(handlesWheelEvents?: boolean) {\n    const element = this.context;\n    // If we are working with an offscreen canvas, there are no mouse events to be applied\n    if (isOffscreenCanvas(element)) return;\n    // This will store the metrics calculated and found for the mouse\n    let mouseMetrics: IMouseMetrics | undefined;\n    // This is a special flag that aids in managing when the mouse is moving over a document AND the element. Both can\n    // not calculate the movements of the mouse at the same time, lest they fry the delta information before both events\n    // get processed by the managers.\n    let elementMovedBeforeDocMoved = false;\n\n    if (handlesWheelEvents) {\n      const wheelHandler = (event: MouseWheelEvent) => {\n        const mouse = eventElementPosition(event, element);\n        const viewsUnderMouse = this.getViewsUnderPosition(mouse);\n        if (viewsUnderMouse.length <= 0) return;\n\n        mouseMetrics = {\n          canClick: false,\n          currentPosition: mouse,\n          deltaPosition: [0, 0],\n          previousPosition: mouse,\n          start: mouse,\n          startTime: Date.now(),\n          startView: viewsUnderMouse[0].d,\n          event,\n          wheel: this.makeWheel(event),\n          button: -1\n        };\n\n        const interaction = this.makeMouseInteraction(mouseMetrics);\n\n        this.eventManagers.forEach(controller => {\n          controller.handleWheel(interaction);\n        });\n\n        event.stopPropagation();\n        event.preventDefault();\n      };\n\n      if (\"onwheel\" in element) {\n        element.onwheel = wheelHandler;\n      }\n\n      if (\"addEventListener\" in element) {\n        element.addEventListener(\"DOMMouseScroll\", wheelHandler);\n        this.eventCleanup.push([\"DOMMouseScroll\", wheelHandler]);\n      }\n    }\n\n    element.onmouseleave = (event: any) => {\n      // No interactions while waiting for the render to update\n      if (this.waitingForRender || !mouseMetrics) return;\n\n      const mouse = eventElementPosition(event, element);\n      mouseMetrics.deltaPosition = subtract2(\n        mouse,\n        mouseMetrics.currentPosition\n      );\n      mouseMetrics.previousPosition = mouseMetrics.currentPosition;\n      mouseMetrics.currentPosition = mouse;\n      const interaction = this.makeMouseInteraction(mouseMetrics);\n\n      this.eventManagers.forEach(controller => {\n        controller.handleMouseOut(interaction);\n      });\n    };\n\n    element.onmousemove = (event: any) => {\n      // No interactions while waiting for the render to update\n      if (this.waitingForRender) return;\n      const mouse = eventElementPosition(event, element);\n\n      if (!mouseMetrics) {\n        const viewsUnderMouse = this.getViewsUnderPosition(mouse);\n\n        mouseMetrics = {\n          canClick: false,\n          currentPosition: mouse,\n          deltaPosition: [0, 0],\n          previousPosition: mouse,\n          start: mouse,\n          startTime: Date.now(),\n          startView: viewsUnderMouse[0].d,\n          event,\n          wheel: this.makeWheel(),\n          button: -1\n        };\n      }\n\n      mouseMetrics.deltaPosition = subtract2(\n        mouse,\n        mouseMetrics.currentPosition\n      );\n      mouseMetrics.previousPosition = mouseMetrics.currentPosition;\n      mouseMetrics.currentPosition = mouse;\n      mouseMetrics.canClick = false;\n      const interaction = this.makeMouseInteraction(mouseMetrics);\n\n      this.eventManagers.forEach(controller => {\n        controller.handleMouseMove(interaction);\n      });\n\n      elementMovedBeforeDocMoved = true;\n    };\n\n    element.onmousedown = (event: any) => {\n      // No interactions while waiting for the render to update\n      if (this.waitingForRender) return;\n\n      const startPosition = eventElementPosition(event, element);\n      const downViews = this.getViewsUnderPosition(startPosition);\n\n      // If no views under this view, then we just quick exit with no interactions\n      if (downViews.length <= 0) {\n        return;\n      }\n\n      mouseMetrics = {\n        canClick: true,\n        currentPosition: startPosition,\n        deltaPosition: [0, 0],\n        previousPosition: startPosition,\n        start: startPosition,\n        startTime: Date.now(),\n        startView: downViews[0].d,\n        event,\n        wheel: this.makeWheel(),\n        button: event.button\n      };\n\n      const interaction = this.makeMouseInteraction(mouseMetrics);\n\n      this.eventManagers.forEach(controller => {\n        controller.handleMouseDown(interaction);\n      });\n\n      event.stopPropagation();\n\n      document.onmousemove = (event: any) => {\n        if (!mouseMetrics) return;\n\n        if (!elementMovedBeforeDocMoved) {\n          const mouse = eventElementPosition(event, element);\n          mouseMetrics.deltaPosition = subtract2(\n            mouse,\n            mouseMetrics.currentPosition\n          );\n          mouseMetrics.previousPosition = mouseMetrics.currentPosition;\n          mouseMetrics.currentPosition = mouse;\n          mouseMetrics.canClick = false;\n        }\n\n        const interaction = this.makeMouseInteraction(mouseMetrics);\n\n        this.eventManagers.forEach(controller => {\n          controller.handleDrag(interaction);\n        });\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        // Reset the element moved flag so we can see if the doc movement needs to handle the mouse metrics\n        elementMovedBeforeDocMoved = false;\n      };\n\n      document.onmouseup = _event => {\n        document.onmousemove = null;\n        document.onmouseup = null;\n        document.onmouseover = null;\n        mouseMetrics = undefined;\n      };\n\n      document.onmouseover = event => {\n        if (!mouseMetrics) return;\n\n        const mouse = eventElementPosition(event, element);\n        mouseMetrics.deltaPosition = subtract2(\n          mouse,\n          mouseMetrics.currentPosition\n        );\n        mouseMetrics.previousPosition = mouseMetrics.currentPosition;\n        mouseMetrics.currentPosition = mouse;\n        const interaction = this.makeMouseInteraction(mouseMetrics);\n\n        this.eventManagers.forEach(controller => {\n          controller.handleMouseOver(interaction);\n        });\n\n        event.stopPropagation();\n      };\n\n      element.onmouseup = event => {\n        if (!mouseMetrics) return;\n        const mouse = eventElementPosition(event, element);\n        mouseMetrics.deltaPosition = subtract2(\n          mouse,\n          mouseMetrics.currentPosition\n        );\n        mouseMetrics.previousPosition = mouseMetrics.currentPosition;\n        mouseMetrics.currentPosition = mouse;\n        mouseMetrics.button = event.button;\n        const interaction = this.makeMouseInteraction(mouseMetrics);\n\n        this.eventManagers.forEach(controller => {\n          controller.handleMouseUp(interaction);\n        });\n\n        // If we release the mouse before the valid click delay\n        if (\n          mouseMetrics.canClick &&\n          Date.now() - mouseMetrics.startTime < VALID_CLICK_DELAY\n        ) {\n          this.eventManagers.forEach(controller => {\n            controller.handleClick(interaction);\n          });\n        }\n\n        mouseMetrics = undefined;\n      };\n\n      // Text will not be selected when it is being dragged\n      const experimental = element as any;\n      if (experimental.onselectstart !== undefined) {\n        experimental.onselectstart = function() {\n          return false;\n        };\n      } else {\n        element.addEventListener(\"selectstart\", function() {\n          event.preventDefault();\n        });\n      }\n    };\n  }\n\n  /**\n   * Adds all the listeners necessary to make the context interactive with multitouch support.\n   */\n  private addTouchContextListeners() {\n    // This is the element we are listening to for touch events\n    const element = this.context;\n    // If this is an offscreen canvas, no interactions will happen\n    if (isOffscreenCanvas(element)) return;\n    // This stores the most recent touch metrics associated with a touch by the touch's identifier\n    const trackedTouches = new Map<number, ITouchMetrics>();\n    // This is the most recent touch interaction event recorded for the touch, identifiable by the touch's identifier\n    const currentTouchInteractions = new Map<number, ISingleTouchInteraction>();\n\n    /**\n     * Converts Touch interaction list to touch metrics\n     */\n    function getTouchMetrics(touches: ISingleTouchInteraction[]) {\n      return touches.map(t => t.touch);\n    }\n\n    /**\n     * Gets the touch that happened the most recent.\n     */\n    function getLatestTouch(touches: ISingleTouchInteraction[]) {\n      return touches.reduce(\n        (p, n) => (n.touch.startTime > p.touch.startTime ? n : p),\n        touches[0]\n      );\n    }\n\n    /**\n     * This is the multitouch query object handed to our controllers so they can query for metrics for multiple touches\n     */\n    const multiTouchInteraction: IMultiTouchInteraction = {\n      center: (touches: ISingleTouchInteraction[]) => {\n        if (touches.length <= 0) return [0, 0];\n\n        return this.getTouchCenter(getTouchMetrics(touches));\n      },\n\n      centerDelta: (touches: ISingleTouchInteraction[]) => {\n        if (touches.length <= 0) return [0, 0];\n        const metrics = getTouchMetrics(touches);\n        const previous = this.getTouchCenter(\n          metrics,\n          (touch: ITouchMetrics) => touch.previousPosition\n        );\n        const current = this.getTouchCenter(metrics);\n\n        return subtract2(current, previous);\n      },\n\n      centerStart: (touches: ISingleTouchInteraction[]) => {\n        if (touches.length <= 0) return [0, 0];\n        const primary = getLatestTouch(touches).touch;\n\n        return this.getTouchCenter(\n          getTouchMetrics(touches),\n          (touch: ITouchMetrics) => {\n            if (touch === primary) {\n              return touch.start;\n            }\n\n            return touch.startRelative.get(primary) || [0, 0];\n          }\n        );\n      },\n\n      id: (touches: ISingleTouchInteraction[]) => {\n        const metrics = getTouchMetrics(touches);\n\n        return metrics\n          .sort(sortByIdentifier)\n          .map(m => m.touch.identifier)\n          .join(\"_\");\n      },\n\n      rotation: (touches: ISingleTouchInteraction[]) => {\n        if (touches.length <= 0) return 0;\n        const metrics = getTouchMetrics(touches);\n        const center = this.getTouchCenter(metrics);\n\n        return this.getAverageAngle(metrics, center);\n      },\n\n      rotationDelta: (touches: ISingleTouchInteraction[]) => {\n        if (touches.length <= 0) return 0;\n        const metrics = getTouchMetrics(touches);\n        const previousCenter = this.getTouchCenter(\n          metrics,\n          (touch: ITouchMetrics) => touch.previousPosition\n        );\n        const previousAngle = this.getAverageAngle(\n          metrics,\n          previousCenter,\n          (touch: ITouchMetrics) => touch.previousPosition\n        );\n        const currentCenter = this.getTouchCenter(metrics);\n        const currentAngle = this.getAverageAngle(metrics, currentCenter);\n\n        return currentAngle - previousAngle;\n      },\n\n      rotationStart: (touches: ISingleTouchInteraction[]) => {\n        if (touches.length <= 0) return 0;\n        const primary = getLatestTouch(touches).touch;\n        const metrics = getTouchMetrics(touches);\n\n        const startCenter = this.getTouchCenter(\n          metrics,\n          (touch: ITouchMetrics) => {\n            if (touch === primary) {\n              return touch.start;\n            }\n\n            return touch.startRelative.get(primary) || [0, 0];\n          }\n        );\n\n        return this.getAverageAngle(\n          metrics,\n          startCenter,\n          (touch: ITouchMetrics) => {\n            if (touch === primary) {\n              return touch.start;\n            }\n\n            return touch.startRelative.get(primary) || [0, 0];\n          }\n        );\n      },\n\n      spread: (touches: ISingleTouchInteraction[]) => {\n        if (touches.length <= 0) return 0;\n        const metrics = getTouchMetrics(touches);\n        const center = this.getTouchCenter(metrics);\n\n        return this.getAverageDistance(metrics, center);\n      },\n\n      spreadDelta: (touches: ISingleTouchInteraction[]) => {\n        if (touches.length <= 0) return 0;\n        const metrics = getTouchMetrics(touches);\n        const previousCenter = this.getTouchCenter(\n          metrics,\n          (touch: ITouchMetrics) => touch.previousPosition\n        );\n        const previousSpread = this.getAverageDistance(\n          metrics,\n          previousCenter,\n          (touch: ITouchMetrics) => touch.previousPosition\n        );\n        const currentCenter = this.getTouchCenter(metrics);\n        const currentSpread = this.getAverageDistance(metrics, currentCenter);\n\n        return currentSpread - previousSpread;\n      },\n\n      spreadStart: (touches: ISingleTouchInteraction[]) => {\n        if (touches.length <= 0) return 0;\n        const primary = getLatestTouch(touches).touch;\n        const metrics = getTouchMetrics(touches);\n\n        const startCenter = this.getTouchCenter(\n          metrics,\n          (touch: ITouchMetrics) => {\n            if (touch === primary) {\n              return touch.start;\n            }\n\n            return touch.startRelative.get(primary) || [0, 0];\n          }\n        );\n\n        return this.getAverageDistance(\n          metrics,\n          startCenter,\n          (touch: ITouchMetrics) => {\n            if (touch === primary) {\n              return touch.start;\n            }\n\n            return touch.startRelative.get(primary) || [0, 0];\n          }\n        );\n      }\n    };\n\n    element.ontouchstart = event => {\n      event.preventDefault();\n      event.stopPropagation();\n      const touches = this.getTouches(event);\n      const currentTouches: ITouchMetrics[] = [];\n      const newTouches: ITouchMetrics[] = [];\n\n      for (let i = 0, iMax = touches.length; i < iMax; ++i) {\n        const touch = touches[i];\n        const trackedTouch = trackedTouches.get(touch.identifier);\n\n        if (!trackedTouch) {\n          const position = eventElementPosition(touch);\n          const downViews = this.getViewsUnderPosition(position);\n          if (downViews.length <= 0) continue;\n          const startView = downViews[0].d;\n\n          const metrics: ITouchMetrics = {\n            canTap: true,\n            currentPosition: position,\n            deltaPosition: [0, 0],\n            startTime: Date.now(),\n            start: position,\n            startView,\n            previousPosition: position,\n            startRelative: new Map(),\n            touch\n          };\n\n          // Track the information with the touch\n          trackedTouches.set(touch.identifier, metrics);\n          // Identify which touches are new\n          newTouches.push(metrics);\n        } else {\n          // Identify existing touches\n          currentTouches.push(trackedTouch);\n        }\n      }\n\n      // If we have a change in touch count, then we have to create relative start positions for all touches that\n      // now exists\n      if (newTouches.length > 0) {\n        const allTouches = newTouches.concat(currentTouches);\n        const singleInteractions: ISingleTouchInteraction[] = [];\n\n        for (let i = 0, iMax = newTouches.length; i < iMax; ++i) {\n          const newTouch = newTouches[i];\n\n          for (let k = 0, kMax = allTouches.length; k < kMax; ++k) {\n            const touch = allTouches[k];\n\n            if (newTouch !== touch) {\n              touch.startRelative.set(newTouch, touch.currentPosition);\n            }\n          }\n\n          // Make the interaction for the single touch\n          const interaction = this.makeSingleTouchInteraction(newTouch);\n          singleInteractions.push(interaction);\n          currentTouchInteractions.set(newTouch.touch.identifier, interaction);\n        }\n\n        const downEvent: ITouchInteraction = {\n          touches: singleInteractions,\n          allTouches: allTouches\n            .map(t => currentTouchInteractions.get(t.touch.identifier))\n            .filter(isDefined),\n          multitouch: multiTouchInteraction\n        };\n\n        // Broadcast to the controllers\n        this.eventManagers.forEach(controller => {\n          controller.handleTouchDown(downEvent);\n        });\n      }\n\n      // Add all of the document events\n      document.ontouchend = event => {\n        documenttouchend.call(document, event);\n        document.ontouchend = null;\n        document.ontouchcancel = null;\n        document.ontouchmove = null;\n      };\n\n      document.ontouchcancel = event => {\n        documenttouchcancel.call(document, event);\n        document.ontouchend = null;\n        document.ontouchcancel = null;\n        document.ontouchmove = null;\n      };\n\n      document.ontouchmove = documenttouchmove;\n    };\n\n    const documenttouchend = (element.ontouchend = event => {\n      // Prevent document events from handling twice\n      event.stopPropagation();\n      event.preventDefault();\n\n      // The touches actually ended are in the changed list in the event\n      const touches = this.getTouches(event, \"changed\");\n      const allTouches = Array.from(currentTouchInteractions.values());\n      const upTouches: ITouchMetrics[] = [];\n\n      for (let i = 0, iMax = touches.length; i < iMax; ++i) {\n        const touch = touches[i];\n        const touchMetrics = trackedTouches.get(touch.identifier);\n        if (!touchMetrics) continue;\n\n        // Detect a tap gesture\n        if (\n          touchMetrics.canTap &&\n          Date.now() - touchMetrics.startTime < VALID_TAP_DELAY\n        ) {\n          const interactions = [this.makeSingleTouchInteraction(touchMetrics)];\n\n          const tapEvent: ITouchInteraction = {\n            touches: interactions,\n            allTouches,\n            multitouch: multiTouchInteraction\n          };\n\n          // Broadcast to the controllers\n          this.eventManagers.forEach(controller => {\n            controller.handleTap(tapEvent);\n          });\n        }\n\n        // Always touch up as the touch is ended\n        upTouches.push(touchMetrics);\n        trackedTouches.delete(touch.identifier);\n        currentTouchInteractions.delete(touch.identifier);\n      }\n\n      if (upTouches.length > 0) {\n        const interactions = upTouches.map(metrics =>\n          this.makeSingleTouchInteraction(metrics)\n        );\n\n        const moveEvent: ITouchInteraction = {\n          touches: interactions,\n          allTouches,\n          multitouch: multiTouchInteraction\n        };\n\n        // Broadcast to the controllers\n        this.eventManagers.forEach(controller => {\n          controller.handleTouchUp(moveEvent);\n        });\n      }\n    });\n\n    const documenttouchmove = (element.ontouchmove = event => {\n      // We do not want the move events bubbling to the document to have repeat events broadcasted\n      event.stopPropagation();\n      event.preventDefault();\n\n      const touches = this.getTouches(event);\n      const moved = [];\n      const unmoved = [];\n\n      for (let i = 0, iMax = touches.length; i < iMax; ++i) {\n        const touch = touches[i];\n        const trackedTouch = trackedTouches.get(touch.identifier);\n\n        if (trackedTouch) {\n          const position = eventElementPosition(touch);\n          const deltaPosition = subtract2(\n            position,\n            trackedTouch.currentPosition\n          );\n\n          if (length2(deltaPosition) <= 0) {\n            unmoved.push(trackedTouch);\n            Object.assign(trackedTouch, {\n              currentPosition: position,\n              deltaPosition,\n              previousPosition: trackedTouch.currentPosition,\n              touch\n            });\n            continue;\n          }\n\n          moved.push(trackedTouch);\n\n          Object.assign(trackedTouch, {\n            canTap: false,\n            currentPosition: position,\n            deltaPosition,\n            previousPosition: trackedTouch.currentPosition,\n            touch\n          });\n        }\n      }\n\n      if (moved.length > 0) {\n        const all = moved.concat(unmoved);\n        const interactions = moved.map(metrics =>\n          this.makeSingleTouchInteraction(metrics)\n        );\n\n        const moveEvent: ITouchInteraction = {\n          touches: interactions,\n          allTouches: all\n            .map(m => currentTouchInteractions.get(m.touch.identifier))\n            .filter(isDefined),\n          multitouch: multiTouchInteraction\n        };\n\n        // Broadcast to the controllers\n        this.eventManagers.forEach(controller => {\n          controller.handleTouchDrag(moveEvent);\n        });\n      }\n    });\n\n    const documenttouchcancel = (element.ontouchcancel = event => {\n      // Prevent the document events from firing twice\n      event.stopPropagation();\n      event.preventDefault();\n\n      // The touches actually ended are in the changed list in the event\n      const touches = this.getTouches(event, \"changed\");\n      const allTouches = Array.from(currentTouchInteractions.values());\n      const upTouches: ITouchMetrics[] = [];\n\n      for (let i = 0, iMax = touches.length; i < iMax; ++i) {\n        const touch = touches[i];\n        const touchMetrics = trackedTouches.get(touch.identifier);\n        if (!touchMetrics) continue;\n        // Always touch up as the touch is ended\n        upTouches.push(touchMetrics);\n        trackedTouches.delete(touch.identifier);\n        currentTouchInteractions.delete(touch.identifier);\n      }\n\n      if (upTouches.length > 0) {\n        const interactions = upTouches.map(metrics =>\n          this.makeSingleTouchInteraction(metrics)\n        );\n\n        const moveEvent: ITouchInteraction = {\n          touches: interactions,\n          allTouches,\n          multitouch: multiTouchInteraction\n        };\n\n        // Broadcast to the controllers\n        this.eventManagers.forEach(controller => {\n          controller.handleTouchCancelled(moveEvent);\n        });\n      }\n    });\n  }\n\n  /**\n   * This takes all of the touches and averages their distance from the center point.\n   */\n  getAverageDistance(\n    touches: ITouchMetrics[],\n    center: Vec2,\n    accessor?: (touch: ITouchMetrics) => Vec2\n  ): number {\n    let total = 0;\n    if (touches.length <= 0) return total;\n    if (!accessor) accessor = (touch: ITouchMetrics) => touch.currentPosition;\n\n    for (let i = 0, iMax = touches.length; i < iMax; ++i) {\n      const touch = touches[i];\n      total += length2(subtract2(accessor(touch), center));\n    }\n\n    return total / touches.length;\n  }\n\n  /**\n   * This takes all of the touches and averages their angle around the center point.\n   */\n  getAverageAngle(\n    touches: ITouchMetrics[],\n    center: Vec2,\n    accessor?: (touch: ITouchMetrics) => Vec2\n  ): number {\n    let total = 0;\n    if (touches.length <= 0) return total;\n    if (!accessor) accessor = (touch: ITouchMetrics) => touch.currentPosition;\n\n    for (let i = 0, iMax = touches.length; i < iMax; ++i) {\n      const touch = touches[i];\n      const direction = subtract2(accessor(touch), center);\n      let angle = Math.atan2(direction[1], direction[0]);\n      if (angle < 0) angle += Math.PI * 2;\n      total += angle;\n    }\n\n    return total / touches.length;\n  }\n\n  /**\n   * This takes a list of touches and averages their position for a mid point between all of them.\n   */\n  getTouchCenter(\n    touches: ITouchMetrics[],\n    accessor?: (touch: ITouchMetrics) => Vec2\n  ): Vec2 {\n    let total: Vec2 = [0, 0];\n    if (touches.length <= 0) return total;\n    if (!accessor) accessor = (touch: ITouchMetrics) => touch.currentPosition;\n\n    for (let i = 0, iMax = touches.length; i < iMax; ++i) {\n      const touch = touches[i];\n      const position = accessor(touch);\n      total = add2(total, position);\n    }\n\n    return scale2(total, 1 / touches.length);\n  }\n\n  /**\n   * Retrieves all touches from a touch event. This normalizes the touch information across: touches, changedTouches,\n   * and targetTouches\n   */\n  getTouches(event: TouchEvent, category?: \"touches\" | \"changed\" | \"target\") {\n    const touches = new Map<number, Touch>();\n\n    if (\n      event.touches &&\n      event.touches.length > 0 &&\n      (!category || category === \"touches\")\n    ) {\n      for (let i = 0, iMax = event.touches.length; i < iMax; ++i) {\n        const touch = event.touches.item(i);\n        if (!touch) continue;\n        touches.set(touch.identifier, touch);\n      }\n    }\n\n    if (\n      event.changedTouches &&\n      event.changedTouches.length > 0 &&\n      (!category || category === \"changed\")\n    ) {\n      for (let i = 0, iMax = event.changedTouches.length; i < iMax; ++i) {\n        const touch = event.changedTouches.item(i);\n        if (!touch) continue;\n        touches.set(touch.identifier, touch);\n      }\n    }\n\n    if (\n      event.targetTouches &&\n      event.targetTouches.length > 0 &&\n      (!category || category === \"target\")\n    ) {\n      for (let i = 0, iMax = event.targetTouches.length; i < iMax; ++i) {\n        const touch = event.targetTouches.item(i);\n        if (!touch) continue;\n        touches.set(touch.identifier, touch);\n      }\n    }\n\n    return Array.from(touches.values());\n  }\n\n  /**\n   * Retrieves the view for the provided id\n   */\n  getView(viewId: string): View<IViewProps> | null {\n    const scenes = this.scenes;\n\n    for (let i = 0, iMax = scenes.length; i < iMax; ++i) {\n      const scene = scenes[i];\n      const view = scene.viewDiffs.getByKey(viewId);\n      if (view) return view;\n    }\n\n    return null;\n  }\n\n  /**\n   * Retrieves the views underneath the mouse with the top most view as\n   * the first view in the list.\n   */\n  getViewsUnderPosition = (mouse: Vec2) => {\n    // Find the views the mouse has interacted with\n    const hitViews = this.quadTree.query(mouse);\n    // Sort them by depth\n    hitViews.sort(sortByDepth);\n\n    return hitViews;\n  };\n\n  /**\n   * This makes the metrics for interactions with the views.\n   */\n  makeMouseInteraction(mouse: IMouseMetrics): IMouseInteraction {\n    // Find the views the mouse has interacted with\n    const hitViews = this.getViewsUnderPosition(mouse.currentPosition);\n    let targetSceneView = hitViews[0] && hitViews[0].d;\n    if (!targetSceneView) targetSceneView = emptyView;\n    const startViews = this.getViewsUnderPosition(mouse.start);\n    let startView = mouse.startView;\n    if (!startView) startView = emptyView;\n\n    const interaction = {\n      canvas: isOffscreenCanvas(this.context) ? undefined : this.context,\n      mouse,\n      screen: {\n        position: mouse.currentPosition\n      },\n      start: {\n        position: startView.projection.screenToView(mouse.start),\n        view: startView,\n        views: startViews.map(v => {\n          if (!v.d) v.d = emptyView;\n\n          return {\n            position: v.d.projection.screenToView(mouse.start),\n            view: v.d\n          };\n        })\n      },\n      target: {\n        position: targetSceneView.projection.screenToView(\n          mouse.currentPosition\n        ),\n        view: targetSceneView,\n        views: hitViews.map(v => {\n          if (!v.d) v.d = emptyView;\n\n          return {\n            position: v.d.projection.screenToView(mouse.currentPosition),\n            view: v.d\n          };\n        })\n      }\n    };\n\n    this.currentInteraction = interaction;\n\n    return interaction;\n  }\n\n  /**\n   * Make an interaction depicting the interactions with the touch\n   */\n  makeSingleTouchInteraction(touch: ITouchMetrics): ISingleTouchInteraction {\n    const position = touch.currentPosition;\n    const hitViews = this.getViewsUnderPosition(position);\n    let targetSceneView = hitViews[0] && hitViews[0].d;\n    if (!targetSceneView) targetSceneView = emptyView;\n    let startView = touch.startView;\n    if (!startView) startView = emptyView;\n\n    const interaction = {\n      canvas: isOffscreenCanvas(this.context) ? undefined : this.context,\n      touch,\n      screen: {\n        position\n      },\n      start: {\n        position: startView.projection.screenToView(touch.start),\n        view: startView,\n        views: this.getViewsUnderPosition(touch.start).map(v => {\n          if (!v.d) v.d = emptyView;\n\n          return {\n            position: v.d.projection.screenToView(touch.start),\n            view: v.d\n          };\n        })\n      },\n      target: {\n        position: targetSceneView.projection.screenToView(position),\n        view: targetSceneView,\n        views: hitViews.map(v => {\n          if (!v.d) v.d = emptyView;\n\n          return {\n            position: v.d.projection.screenToView(position),\n            view: v.d\n          };\n        })\n      }\n    };\n\n    this.currentInteraction = interaction;\n\n    return interaction;\n  }\n\n  /**\n   * This produces an object for handling several touches at once. It will store all of the combinations of touches\n   * and their associative metrics into the lookup mapping provideds.\n   */\n  makeMultiTouchInteractions(\n    touchMetrics: ITouchMetrics[],\n    multiTouchLookup: Map<string, IMultiTouchMetrics>\n  ) {\n    // Make sure the identifiers come out in the same order of permutation everytime. This makes the combined identifiers\n    // stay properly maintained.\n    touchMetrics.sort(sortByIdentifier);\n    // Now make all of the combinations of touches that are possible between all of the current touches\n    const allCombinations = this.allTouchCombinations(touchMetrics);\n\n    // With all combinations in place, we can now find any combination that newly exists as a result of the new touches.\n    for (let i = 0, iMax = allCombinations.length; i < iMax; ++i) {\n      const combo = allCombinations[i];\n      const id = combo.map(metrics => metrics.touch.identifier).join(\"_\");\n      let multitouch = multiTouchLookup.get(id);\n\n      if (!multitouch) {\n        const center = this.getTouchCenter(combo);\n        multitouch = {\n          touches: combo,\n          averageSpreadDelta: 0,\n          startCenter: center,\n          currentCenter: center,\n          currentRotation: this.getAverageAngle(combo, center),\n          centerDelta: [0, 0],\n          rotationDelta: 0\n        };\n\n        multiTouchLookup.set(id, multitouch);\n      }\n    }\n  }\n\n  /**\n   * This updates all existing multitouch metrics with their new frame of data\n   */\n  updateMultiTouchInteractions(\n    touchMetrics: ITouchMetrics[],\n    multiTouchLookup: Map<string, IMultiTouchMetrics>\n  ) {\n    // Make sure the identifiers come out in the same order of permutation everytime. This makes the combined identifiers\n    // stay properly maintained.\n    touchMetrics.sort(sortByIdentifier);\n    // Now make all of the combinations of touches that are possible between all of the current touches\n    const allCombinations = this.allTouchCombinations(touchMetrics);\n\n    for (let i = 0, iMax = allCombinations.length; i < iMax; ++i) {\n      const combo = allCombinations[i];\n      const id = combo.map(metrics => metrics.touch.identifier).join(\"_\");\n      const multitouch = multiTouchLookup.get(id);\n\n      if (multitouch) {\n        const center = this.getTouchCenter(combo);\n        const rotation = this.getAverageAngle(combo, center);\n\n        multitouch.centerDelta = subtract2(center, multitouch.currentCenter);\n        multitouch.currentCenter = center;\n        multitouch.rotationDelta = rotation - multitouch.currentRotation;\n        multitouch.currentRotation = rotation;\n      }\n    }\n  }\n\n  /**\n   * This makes all of the possible combinations of touches.\n   */\n  allTouchCombinations(list: ITouchMetrics[]) {\n    const allCombinations = [];\n    const listSize = list.length;\n    const combinationsCount = 1 << listSize;\n\n    for (let i = 1; i < combinationsCount; i++) {\n      const combination = [];\n\n      for (let j = 0; j < listSize; j++) {\n        if (i & (1 << j)) {\n          combination.push(list[j]);\n        }\n      }\n\n      allCombinations.push(combination);\n    }\n    return allCombinations;\n  }\n\n  makeWheel(event?: MouseWheelEvent): IWheelMetrics {\n    if (!event) {\n      return {\n        delta: [0, 0]\n      };\n    }\n\n    const wheel = normalizeWheel(event);\n\n    return {\n      delta: [wheel.pixelX, wheel.pixelY]\n    };\n  }\n\n  /**\n   * When the renderer is resized, we must reform our quad tree\n   */\n  resize = () => {\n    this._waitingForRender = true;\n  };\n\n  /**\n   * Sets the controllers to receive events from this manager.\n   */\n  setControllers(controllers: EventManager[]) {\n    this.eventManagers = controllers;\n\n    for (const controller of this.eventManagers) {\n      controller.setUserInputManager(this);\n    }\n  }\n\n  destroy() {\n    delete this.quadTree;\n\n    if (!isOffscreenCanvas(this.context)) {\n      this.context.onmousedown = null;\n      this.context.onmousemove = null;\n      this.context.onmouseleave = null;\n    }\n\n    const experimental = this.context as any;\n\n    if (experimental.onmousewheel) {\n      experimental.onmousewheel = null;\n    }\n\n    this.eventCleanup.forEach(event => {\n      this.context.removeEventListener(event[0], event[1]);\n    });\n  }\n}\n","import { isString } from \"../types\";\nimport { Attribute } from \"./attribute\";\nimport { ColorBuffer } from \"./color-buffer\";\nimport { Geometry } from \"./geometry\";\nimport {\n  colorBufferFormat,\n  depthBufferFormat,\n  drawMode,\n  indexToColorAttachment,\n  inputImageFormat,\n  magFilter,\n  minFilter,\n  stencilBufferFormat,\n  texelFormat,\n  wrapMode\n} from \"./gl-decode\";\nimport { GLSettings } from \"./gl-settings\";\nimport { GLState } from \"./gl-state\";\nimport { Material } from \"./material\";\nimport { Model } from \"./model\";\nimport { RenderTarget } from \"./render-target\";\nimport { Texture } from \"./texture\";\nimport { GLContext, IExtensions } from \"./types\";\nimport { WebGLStat } from \"./webgl-stat\";\n\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * Type guard to see if a textire object's data is a buffer.\n */\nfunction isDataBuffer(\n  val: any\n): val is { width: number; height: number; buffer: ArrayBufferView | null } {\n  return (\n    (val &&\n      val.buffer &&\n      val.buffer.byteOffset !== undefined &&\n      val.buffer.byteLength) ||\n    val.buffer === null\n  );\n}\n\n/**\n * Tests if a value is a power of 2\n */\nfunction isPowerOf2(val: number) {\n  return (val & (val - 1)) === 0;\n}\n\n/**\n * This determines if a texture object is ready for use meaning\n * it's compiled and has a current active texture unit.\n */\nfunction isTextureReady(\n  texture: Texture\n): texture is Texture & {\n  gl: { textureId: WebGLTexture; textureUnit: number };\n} {\n  return Boolean(\n    texture.gl && texture.gl.textureId && texture.gl.textureUnit > -1\n  );\n}\n\n/**\n * This is where all objects go to be processed and updated with webgl calls. Such as textures, geometries, etc\n */\nexport class GLProxy {\n  /** Message to include with debugging statements, warnings and errors */\n  debugContext: string = \"\";\n  /** This is the gl context we're manipulating. */\n  gl: GLContext;\n  /** This is the state tracker of the GL context */\n  state: GLState;\n  /** These are the extensions established for the context */\n  extensions: IExtensions;\n\n  /**\n   * Store all of the compiled shaders based on the string text of the\n   * shader so we never duplicate a shader program.\n   */\n  private fragmentShaders = new Map<string, WebGLShader>();\n  /**\n   * Store all of the compiled shaders based on the string text of the\n   * shader so we never duplicate a shader program.\n   */\n  private vertexShaders = new Map<string, WebGLShader>();\n  /**\n   * Make a look up for existing programs based on shader objects.\n   */\n  private programs = new Map<\n    WebGLShader,\n    Map<WebGLShader, { useCount: number; program: WebGLProgram }>\n  >();\n\n  constructor(gl: GLContext, state: GLState, extensions: IExtensions) {\n    this.gl = gl;\n    this.state = state;\n    this.extensions = extensions;\n  }\n\n  /**\n   * This enables the desired and supported extensions this framework utilizes.\n   */\n  static addExtensions(gl: GLContext): IExtensions {\n    const instancing = gl.getExtension(\"ANGLE_instanced_arrays\");\n    const mrt = gl.getExtension(\"WEBGL_draw_buffers\");\n    const floatTex = gl.getExtension(\"OES_texture_float\");\n    const floatTexFilterLinear = gl.getExtension(\"OES_texture_float_linear\");\n    const halfFloatTex = gl.getExtension(\"OES_texture_half_float\");\n    const halfFloatTexFilterLinear = gl.getExtension(\n      \"OES_texture_half_float_linear\"\n    );\n    const anisotropicFiltering = gl.getExtension(\n      \"EXT_texture_filter_anisotropic\"\n    );\n    const renderFloatTexture = gl.getExtension(\"EXT_color_buffer_float\");\n    const vao = gl.getExtension(\"OES_vertex_array_object\");\n\n    const anisotropicStats = {\n      maxAnistropicFilter: 0\n    };\n\n    // This exists as an extension or as a webgl2 context\n    if (!instancing && !(gl instanceof WebGL2RenderingContext)) {\n      debug(\n        \"This device does not have hardware instancing. All buffering strategies will be utilizing compatibility modes.\"\n      );\n    }\n\n    // This exists as an extension or as a webgl2 context\n    if (!mrt && !(gl instanceof WebGL2RenderingContext)) {\n      debug(\n        \"This device does not have hardware multi-render target capabilities. The system will have to fallback to multiple render passes to multiple FBOs to achieve the same result.\"\n      );\n    }\n\n    // This only exists as an extension\n    if (!anisotropicFiltering) {\n      debug(\n        \"This device does not have hardware anisotropic filtering for textures. This property will be ignored when setting texture settings.\"\n      );\n    } else {\n      anisotropicStats.maxAnistropicFilter = gl.getParameter(\n        anisotropicFiltering.MAX_TEXTURE_MAX_ANISOTROPY_EXT\n      );\n    }\n\n    if (!vao && !(gl instanceof WebGL2RenderingContext)) {\n      debug(\n        \"This device does not support Vertex Array Objects. This could cause performance issues for high numbers of draw calls.\"\n      );\n    }\n\n    return {\n      instancing:\n        (gl instanceof WebGL2RenderingContext ? gl : instancing) || undefined,\n      drawBuffers:\n        (gl instanceof WebGL2RenderingContext ? gl : mrt) || undefined,\n      anisotropicFiltering: anisotropicFiltering\n        ? {\n            ext: anisotropicFiltering,\n            stat: anisotropicStats\n          }\n        : undefined,\n      renderFloatTexture: renderFloatTexture,\n      floatTex:\n        (gl instanceof WebGL2RenderingContext ? gl : floatTex) || undefined,\n      floatTexFilterLinear:\n        (gl instanceof WebGL2RenderingContext ? gl : floatTexFilterLinear) ||\n        undefined,\n      halfFloatTex:\n        (gl instanceof WebGL2RenderingContext ? gl : halfFloatTex) || undefined,\n      halfFloatTexFilterLinear:\n        (gl instanceof WebGL2RenderingContext\n          ? gl\n          : halfFloatTexFilterLinear) || undefined,\n      vao: (gl instanceof WebGL2RenderingContext ? gl : vao) || undefined\n    };\n  }\n\n  /**\n   * Clears the specified buffers\n   */\n  clear(color?: boolean, depth?: boolean, stencil?: boolean) {\n    let mask = 0;\n\n    if (color) mask = mask | this.gl.COLOR_BUFFER_BIT;\n    if (depth) mask = mask | this.gl.DEPTH_BUFFER_BIT;\n    if (stencil) mask = mask | this.gl.STENCIL_BUFFER_BIT;\n\n    this.gl.clear(mask);\n  }\n\n  /**\n   * Takes an Attribute object and ensures it's buffer is created and initialized.\n   */\n  compileAttribute(attribute: Attribute) {\n    if (attribute.gl) return;\n\n    const gl = this.gl;\n    const buffer = gl.createBuffer();\n\n    if (!buffer) {\n      console.warn(\n        this.debugContext,\n        \"Could bot create WebGLBuffer. Printing any existing gl errors:\"\n      );\n      this.printError();\n\n      return;\n    }\n\n    // State change\n    this.state.bindVBO(buffer);\n\n    // Upload the data to the GPU\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      attribute.data,\n      attribute.isDynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW\n    );\n\n    attribute.gl = {\n      bufferId: buffer,\n      type: gl.ARRAY_BUFFER,\n      proxy: this\n    };\n\n    // Indicate the attribute is updated to it's latest needs and concerns\n    attribute.resolve();\n\n    return true;\n  }\n\n  /**\n   * Takes a geometry object and ensures all of it's buffers are generated\n   */\n  compileGeometry(geometry: Geometry) {\n    // If the geometry's gl context is made, it is already compiled.\n    if (geometry.gl) return;\n    let success = true;\n\n    // Make our geometry gl context\n    geometry.gl = {\n      proxy: this\n    };\n\n    // If we have the ability to have a vao, let's use this moment to fully\n    // establish it for this geometry\n    if (this.extensions.vao) {\n      let vao: WebGLVertexArrayObject | null;\n\n      if (this.extensions.vao instanceof WebGL2RenderingContext) {\n        vao = this.extensions.vao.createVertexArray();\n      } else {\n        vao = this.extensions.vao.createVertexArrayOES();\n      }\n\n      // If the vao can not be created, let's just harmlessly skip making it\n      // happen\n      if (vao) {\n        this.state.disableVertexAttributeArray();\n        this.state.bindVAO(vao);\n\n        geometry.attributes.forEach((attribute, name) => {\n          if (this.updateAttribute(attribute)) {\n            this.useAttribute(name, attribute, geometry);\n          }\n        });\n\n        geometry.gl.vao = vao;\n        this.state.bindVAO(null);\n      } else {\n        debug(\n          \"WARNING: Could not make VAO for Geometry. This is fine, but this could cause a hit on performance.\"\n        );\n      }\n    }\n\n    // Loop through each attribute of the geometry\n    geometry.attributes.forEach(attribute => {\n      success = Boolean(this.compileAttribute(attribute) && success);\n    });\n\n    return success;\n  }\n\n  /**\n   * This creates the shaders and programs needed to create a material.\n   */\n  compileMaterial(material: Material) {\n    // If the gl object exists, then this is considered finished\n    if (material.gl) return;\n\n    // Check for existing vertex shader object FIRST. Vertex shaders are common\n    // across all fragment shader outputs for our MRT structure.\n    let vs = this.vertexShaders.get(material.vertexShader) || null;\n\n    // If none exists, then compile\n    if (!vs) {\n      vs = this.gl.createShader(this.gl.VERTEX_SHADER);\n\n      if (!vs) {\n        console.warn(\n          this.debugContext,\n          \"Could not create a Vertex WebGLShader. Printing GL Errors:\"\n        );\n        this.printError();\n        return;\n      }\n\n      this.gl.shaderSource(vs, material.vertexShader);\n      this.gl.compileShader(vs);\n\n      if (this.gl.isContextLost()) {\n        console.warn(\"Context was lost during compilation\");\n      }\n\n      if (!this.gl.getShaderParameter(vs, this.gl.COMPILE_STATUS)) {\n        console.error(\n          this.debugContext,\n          \"VERTEX SHADER COMPILER ERROR\",\n          material.name\n        );\n        console.warn(\n          \"Could not compile provided shader. Printing logs and errors:\"\n        );\n        console.warn(this.lineFormatShader(material.vertexShader));\n        console.warn(\"LOGS:\");\n        console.warn(this.gl.getShaderInfoLog(vs));\n        this.printError();\n        this.gl.deleteShader(vs);\n\n        return;\n      }\n    }\n\n    // Retrieve the Programs available for this vertex shader\n    let vertexPrograms = this.programs.get(vs);\n\n    if (!vertexPrograms) {\n      vertexPrograms = new Map();\n      this.programs.set(vs, vertexPrograms);\n    }\n\n    const materialGL: Material[\"gl\"] = {\n      vsId: vs,\n      fsId: [],\n      programId: [],\n      proxy: this,\n      programByTarget: new WeakMap(),\n      outputsByProgram: new WeakMap()\n    };\n\n    // We use this to aggregate all uniforms across all programs generated to\n    // analyze if we are missing uniforms or need to strip out uniforms\n    const usedUniforms = new Set<string>();\n\n    // We must loop through all of the fragment shaders the material can\n    // provide. Each fragment shader is designed for specific outputs to match a\n    // render target's configuration.\n    material.fragmentShader.forEach(fragmentShader => {\n      if (!vertexPrograms || !vs) return;\n\n      // Check for existing shader programs for the fragment shader\n      let fs = this.fragmentShaders.get(fragmentShader.source) || null;\n\n      // If none exists, then we create and compile the fragments shader\n      if (!fs) {\n        fs = this.gl.createShader(this.gl.FRAGMENT_SHADER);\n\n        if (!fs) {\n          console.warn(\n            this.debugContext,\n            \"Could not create a Fragment WebGLShader. Printing GL Errors:\"\n          );\n          this.printError();\n          return;\n        }\n\n        this.gl.shaderSource(fs, fragmentShader.source);\n        this.gl.compileShader(fs);\n\n        if (this.gl.isContextLost()) {\n          console.warn(\"Context was lost during compilation\");\n        }\n\n        if (!this.gl.getShaderParameter(fs, this.gl.COMPILE_STATUS)) {\n          console.error(\n            this.debugContext,\n            \"FRAGMENT SHADER COMPILER ERROR:\",\n            material.name\n          );\n          console.warn(\n            \"Could not compile provided shader. Printing logs and errors:\"\n          );\n          console.warn(this.lineFormatShader(fragmentShader.source));\n          console.warn(\"LOGS:\");\n          console.warn(this.gl.getShaderInfoLog(fs));\n          this.printError();\n          this.gl.deleteShader(fs);\n\n          return;\n        }\n      }\n\n      // Get the use metrics for the program the vs and fs shader create\n      let useMetrics = vertexPrograms.get(fs) || null;\n\n      // No use metrics yet means we must generate the program\n      if (!useMetrics) {\n        const program = this.gl.createProgram();\n\n        if (!program) {\n          console.warn(\n            this.debugContext,\n            \"Could not create a WebGLProgram. Printing GL Errors:\"\n          );\n          this.printError();\n\n          return;\n        }\n\n        useMetrics = {\n          useCount: 1,\n          program\n        };\n\n        this.gl.attachShader(program, vs);\n        this.gl.attachShader(program, fs);\n\n        // Make the shaders operate together\n        this.gl.linkProgram(program);\n        this.gl.validateProgram(program);\n\n        if (\n          !this.gl.getProgramParameter(program, this.gl.LINK_STATUS) ||\n          !this.gl.getProgramParameter(program, this.gl.VALIDATE_STATUS)\n        ) {\n          const info = this.gl.getProgramInfoLog(program);\n          console.warn(\n            this.debugContext,\n            \"Could not compile WebGL program. \\n\\n\",\n            info\n          );\n          this.gl.deleteProgram(program);\n\n          return;\n        }\n\n        vertexPrograms.set(fs, useMetrics);\n      }\n\n      // Existing use metrics simply means: we have a program for the vs and fs\n      // shader combo, so simply incremenet it's use count.\n      else {\n        useMetrics.useCount++;\n      }\n\n      // Establish the gl context info that makes this material tick.\n      materialGL.fsId?.push({\n        id: fs,\n        outputTypes: fragmentShader.outputTypes\n      });\n      materialGL.programId?.push({\n        id: useMetrics.program,\n        outputTypes: fragmentShader.outputTypes\n      });\n      materialGL.outputsByProgram.set(\n        useMetrics.program,\n        fragmentShader.outputTypes\n      );\n\n      // Switch to the program so we can aggregate all of the uniforms the\n      // program will utilize.\n      this.state.useProgram(useMetrics.program);\n      // Get the current program applied to our state\n      const program = this.state.currentProgram;\n      if (!program) return false;\n\n      // Get the total uniforms requested by the program so we can loop through them\n      const totalProgramUniforms = this.gl.getProgramParameter(\n        program,\n        this.gl.ACTIVE_UNIFORMS\n      );\n\n      for (let i = 0; i < totalProgramUniforms; i++) {\n        const uniformInfo = this.gl.getActiveUniform(program, i);\n\n        if (uniformInfo) {\n          // Special case for arrays where gl reports the name back with an\n          // array index appended\n          usedUniforms.add(uniformInfo.name.replace(\"[0]\", \"\"));\n        }\n      }\n\n      return;\n    });\n\n    // Set the generated GL identifiers to our material\n    material.gl = materialGL;\n\n    // Let's get a list of all uniforms the shaders are demanding and make sure\n    // the material is supplying them. If not, then the shader will not have all\n    // of the information it may need and thus would be considered invalid\n    // rendering.\n\n    // We now delete any uniforms that are not matched between material and\n    // program as they are not needed and will just be lingering unused clutter.\n    const uniformToRemove = new Set<string>();\n\n    Object.keys(material.uniforms).forEach(name => {\n      if (!usedUniforms.has(name)) {\n        uniformToRemove.add(name);\n      }\n    });\n\n    uniformToRemove.forEach(name => {\n      delete material.uniforms[name];\n    });\n\n    // Now we validate we have all of the uniforms the program requested\n    if (Object.keys(material.uniforms).length !== usedUniforms.size) {\n      console.warn(\n        this.debugContext,\n        \"A program is requesting a set of uniforms:\",\n        Array.from(usedUniforms.values()),\n        \"but our material only provides\",\n        Object.keys(material.uniforms),\n        \"thus the expected rendering will be considered invalid.\"\n      );\n\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * This does what is needed to generate a GPU FBO that we can utilize as a render target\n   * for subsequent draw calls.\n   */\n  compileRenderTarget(target: RenderTarget) {\n    // Do not attempt recompiles and spewing out errors.\n    if (target.isInvalid) return false;\n    // If the gl target exists, then this is considered to be compiled already\n    if (target.gl) return true;\n\n    // We will now create the frame buffer and render buffers and targets necessary\n    // to make this render target work.\n    const gl = this.gl;\n    const fbo = gl.createFramebuffer();\n\n    if (!fbo) {\n      console.warn(\n        this.debugContext,\n        \"Could not generate a frame buffer object. Printing GL errors:\"\n      );\n      this.printError();\n      return false;\n    }\n\n    // Change state\n    this.state.bindFBO(fbo);\n\n    // Generate the context to be attached to the render target\n    const glContext: RenderTarget[\"gl\"] = {\n      fboId: fbo,\n      proxy: this,\n      fboByMaterial: new WeakMap()\n    };\n\n    // Color buffer\n    if (Array.isArray(target.buffers.color)) {\n      // Ensure MRT is enabled for this hardware. If it is not, we should not\n      // allow this branch to continue\n      if (!this.extensions.drawBuffers) {\n        console.warn(\n          \"Attempted to manage a render target with MRT but the hardware does not support MRT. Use multiple render targets instead.\"\n        );\n        return false;\n      }\n\n      const buffers: {\n        data: WebGLRenderbuffer | Texture;\n        outputType: number;\n        attachment: number;\n      }[] = [];\n      let isReady = true;\n      glContext.colorBufferId = buffers;\n      const isSingleBuffer = target.buffers.color.length <= 1;\n\n      target.buffers.color.forEach((buffer, i) => {\n        if (!isReady) return;\n        if (buffer.buffer instanceof Texture) {\n          const bufferAttachment = indexToColorAttachment(\n            gl,\n            this.extensions,\n            i,\n            isSingleBuffer,\n            false\n          );\n          buffers.push({\n            data: buffer.buffer,\n            outputType: buffer.outputType,\n            attachment: bufferAttachment\n          });\n\n          if (isTextureReady(buffer.buffer)) {\n            gl.framebufferTexture2D(\n              gl.FRAMEBUFFER,\n              bufferAttachment,\n              gl.TEXTURE_2D,\n              buffer.buffer.gl.textureId,\n              0\n            );\n          } else {\n            console.warn(\n              this.debugContext,\n              \"Attempted to compile render target whose target texture was not ready for use.\"\n            );\n            isReady = false;\n          }\n        } else {\n          const rboId = this.compileColorBuffer(\n            buffer.buffer,\n            target.width,\n            target.height\n          );\n\n          if (rboId) {\n            const bufferAttachment = indexToColorAttachment(\n              gl,\n              this.extensions,\n              i,\n              isSingleBuffer,\n              false\n            );\n            buffers.push({\n              data: rboId,\n              outputType: buffer.outputType,\n              attachment: bufferAttachment\n            });\n            gl.framebufferRenderbuffer(\n              gl.FRAMEBUFFER,\n              bufferAttachment,\n              gl.RENDERBUFFER,\n              rboId\n            );\n          }\n        }\n      });\n\n      if (!isReady) {\n        return false;\n      }\n    } else if (target.buffers.color !== undefined) {\n      const buffer = target.buffers.color;\n\n      if (buffer.buffer instanceof Texture) {\n        const bufferAttachment = indexToColorAttachment(\n          gl,\n          this.extensions,\n          0,\n          true,\n          false\n        );\n        glContext.colorBufferId = {\n          data: buffer.buffer,\n          outputType: buffer.outputType,\n          attachment: bufferAttachment\n        };\n\n        if (isTextureReady(buffer.buffer)) {\n          gl.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            bufferAttachment,\n            gl.TEXTURE_2D,\n            buffer.buffer.gl.textureId,\n            0\n          );\n        } else {\n          console.warn(\n            this.debugContext,\n            \"Attempted to compile render target whose target texture was not ready for use.\"\n          );\n          return false;\n        }\n      } else {\n        const rboId = this.compileColorBuffer(\n          buffer.buffer,\n          target.width,\n          target.height\n        );\n\n        if (rboId) {\n          const bufferAttachment = indexToColorAttachment(\n            gl,\n            this.extensions,\n            0,\n            true,\n            false\n          );\n          glContext.colorBufferId = {\n            data: rboId,\n            outputType: buffer.outputType,\n            attachment: bufferAttachment\n          };\n          gl.framebufferRenderbuffer(\n            gl.FRAMEBUFFER,\n            bufferAttachment,\n            gl.RENDERBUFFER,\n            rboId\n          );\n        }\n      }\n    }\n\n    // Depth buffer\n    if (target.buffers.depth !== undefined) {\n      const buffer = target.buffers.depth;\n\n      if (buffer instanceof Texture) {\n        glContext.depthBufferId = buffer;\n\n        if (isTextureReady(buffer)) {\n          gl.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            gl.DEPTH_ATTACHMENT,\n            gl.TEXTURE_2D,\n            buffer.gl.textureId,\n            0\n          );\n        }\n      } else if (buffer instanceof ColorBuffer) {\n        const rboId = this.compileDepthBuffer(\n          depthBufferFormat(gl, buffer.internalFormat),\n          target.width,\n          target.height\n        );\n\n        if (rboId) {\n          glContext.depthBufferId = rboId;\n          gl.framebufferRenderbuffer(\n            gl.FRAMEBUFFER,\n            gl.DEPTH_ATTACHMENT,\n            gl.RENDERBUFFER,\n            rboId\n          );\n        }\n      } else {\n        const rboId = this.compileDepthBuffer(\n          buffer,\n          target.width,\n          target.height\n        );\n\n        if (rboId) {\n          glContext.depthBufferId = rboId;\n          gl.framebufferRenderbuffer(\n            gl.FRAMEBUFFER,\n            gl.DEPTH_ATTACHMENT,\n            gl.RENDERBUFFER,\n            rboId\n          );\n        }\n      }\n    }\n\n    // Stencil buffer\n    if (target.buffers.stencil !== undefined) {\n      const buffer = target.buffers.stencil;\n\n      if (buffer instanceof Texture) {\n        glContext.stencilBufferId = buffer;\n\n        if (isTextureReady(buffer)) {\n          gl.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            gl.STENCIL_ATTACHMENT,\n            gl.TEXTURE_2D,\n            buffer.gl.textureId,\n            0\n          );\n        }\n      } else {\n        const rboId = this.compileStencilBuffer(\n          buffer,\n          target.width,\n          target.height\n        );\n\n        if (rboId) {\n          glContext.stencilBufferId = rboId;\n          gl.framebufferRenderbuffer(\n            gl.FRAMEBUFFER,\n            gl.STENCIL_ATTACHMENT,\n            gl.RENDERBUFFER,\n            rboId\n          );\n        }\n      }\n    }\n\n    // Store the generated information in the target\n    target.gl = glContext;\n\n    // Check framebuffer for success\n    const frameBufferCheckResult = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    let unidentifiedResult = false;\n    let stillUnidentifiedResult = false;\n    let message = \"\";\n\n    switch (frameBufferCheckResult) {\n      case gl.FRAMEBUFFER_COMPLETE:\n        target.setAsValid();\n        break;\n\n      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n        message = \"FRAMEBUFFER_INCOMPLETE_ATTACHMENT\";\n        break;\n\n      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n        message = \"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\";\n        break;\n\n      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n        message = \"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\";\n        break;\n\n      case gl.FRAMEBUFFER_UNSUPPORTED:\n        message = \"FRAMEBUFFER_UNSUPPORTED\";\n        break;\n\n      default:\n        unidentifiedResult = true;\n        break;\n    }\n\n    // WebGL 2 specific checks\n    if (gl instanceof WebGL2RenderingContext) {\n      switch (frameBufferCheckResult) {\n        case gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:\n          message = \"FRAMEBUFFER_INCOMPLETE_MULTISAMPLE\";\n          break;\n\n        case gl.RENDERBUFFER_SAMPLES:\n          message = \"RENDERBUFFER_SAMPLES\";\n          break;\n\n        default:\n          stillUnidentifiedResult = true;\n          break;\n      }\n    }\n\n    if (unidentifiedResult && stillUnidentifiedResult) {\n      console.warn(\n        this.debugContext,\n        \"A framebuffer check failed to return a known result. This FBO for render target will be assumed failed\"\n      );\n      console.warn(\"Result:\", frameBufferCheckResult, \"Render Target:\", target);\n      message = \"UNKNOWN\";\n    }\n\n    if (message) {\n      console.warn(\n        this.debugContext,\n        \"When creating a new FrameBuffer Object, the check on the framebuffer failed. Printing Errors:\"\n      );\n      console.warn(message);\n      this.printError();\n      console.warn(\"FAILED RENDER TARGET:\", target);\n      delete target.gl;\n      target.isInvalid = true;\n\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Produces a render buffer object intended for a render target for the depth buffer attachment\n   */\n  private compileDepthBuffer(\n    buffer: GLSettings.RenderTarget.DepthBufferFormat,\n    width: number,\n    height: number\n  ) {\n    const gl = this.gl;\n    const rbo = gl.createRenderbuffer();\n\n    if (!rbo) {\n      console.warn(\n        this.debugContext,\n        \"Could not generate a WebGLRenderBuffer. Printing GL Errors:\"\n      );\n      this.printError();\n      return;\n    }\n\n    // State change\n    this.state.bindRBO(rbo);\n    // Set the storage format of the RBO\n    gl.renderbufferStorage(\n      gl.RENDERBUFFER,\n      depthBufferFormat(gl, buffer),\n      width,\n      height\n    );\n\n    return rbo;\n  }\n\n  /**\n   * Produces a render buffer object intended for a render target for the stencil buffer attachment\n   */\n  private compileStencilBuffer(\n    buffer: GLSettings.RenderTarget.StencilBufferFormat,\n    width: number,\n    height: number\n  ) {\n    const gl = this.gl;\n    const rbo = gl.createRenderbuffer();\n\n    if (!rbo) {\n      console.warn(\n        this.debugContext,\n        \"Could not generate a WebGLRenderBuffer. Printing GL Errors:\"\n      );\n      this.printError();\n      return;\n    }\n\n    // State change\n    this.state.bindRBO(rbo);\n    // Set the storage format of the RBO\n    gl.renderbufferStorage(\n      gl.RENDERBUFFER,\n      stencilBufferFormat(gl, buffer),\n      width,\n      height\n    );\n\n    return rbo;\n  }\n\n  /**\n   * Produces a render buffer object intended for a render target for the color\n   * buffer attachment\n   */\n  private compileColorBuffer(\n    buffer: ColorBuffer,\n    width: number,\n    height: number\n  ) {\n    const gl = this.gl;\n    const rbo = gl.createRenderbuffer();\n\n    if (!rbo) {\n      console.warn(\n        this.debugContext,\n        \"Could not generate a WebGLRenderBuffer. Printing GL Errors:\"\n      );\n      this.printError();\n      return;\n    }\n\n    // State change\n    this.state.bindRBO(rbo);\n    // Set the storage format of the RBO\n    gl.renderbufferStorage(\n      gl.RENDERBUFFER,\n      colorBufferFormat(gl, buffer.internalFormat),\n      width,\n      height\n    );\n\n    buffer.gl = {\n      bufferId: rbo,\n      proxy: this\n    };\n\n    return rbo;\n  }\n\n  /**\n   * This does what is needed to generate a GPU texture object and format it to\n   * the Texture object specifications.\n   */\n  compileTexture(texture: Texture) {\n    if (!texture.gl) return;\n    // If the id is already established, this does not need a compile but an\n    // update\n    if (texture.gl.textureId) return;\n\n    // The texture must have a unit established in order to be compiled\n    if (texture.gl.textureUnit < 0) {\n      console.warn(\n        this.debugContext,\n        \"A Texture object attempted to be compiled without an established Texture Unit.\",\n        texture\n      );\n      return;\n    }\n\n    // Set our unit to the unit allotted to the texture for this operation\n    this.state.setActiveTextureUnit(texture.gl.textureUnit);\n\n    const gl = this.gl;\n    const textureId = gl.createTexture();\n\n    if (!textureId) {\n      console.warn(\n        this.debugContext,\n        \"Could not generate a texture object on the GPU. Printing any gl errors:\"\n      );\n      this.printError();\n      return;\n    }\n\n    // Establish the texture's generated gl context\n    texture.gl.textureId = textureId;\n    // No matter what, when compiled both data and settings should be updated\n    // immediately\n    texture.needsDataUpload = true;\n    texture.needsSettingsUpdate = true;\n\n    // Upload the texture's data to the object\n    this.updateTextureData(texture);\n    // Make sure the settings for the texture are set correctly to match the\n    // texture object\n    this.updateTextureSettings(texture);\n\n    return true;\n  }\n\n  /**\n   * Executes the draw operation for a given model\n   */\n  draw(model: Model) {\n    let instancing;\n    let drawRange = [0, 0];\n\n    // Get the appropriate draw range from the model\n    if (\n      model.vertexDrawRange &&\n      model.vertexDrawRange[0] >= 0 &&\n      model.vertexDrawRange[1] >= 0\n    ) {\n      drawRange = [\n        model.vertexDrawRange[0],\n        model.vertexDrawRange[1] - model.vertexDrawRange[0]\n      ];\n    } else {\n      drawRange = [0, model.vertexCount];\n    }\n\n    // Only if this geometry has instances requested will it attempt to render\n    // instances\n    if (model.drawInstances >= 0 && model.geometry.isInstanced) {\n      instancing = this.extensions.instancing;\n    }\n\n    // Optimization: No draw valid draw buffers when a render target is\n    // established and MRT is enabled: then don't don't\n    if (WebGLStat.MRT || WebGLStat.MRT_EXTENSION) {\n      if (this.state.renderTarget) {\n        if (!this.state.drawBuffers.find(target => target !== this.gl.NONE)) {\n          return;\n        }\n      }\n    }\n\n    if (instancing && instancing instanceof WebGL2RenderingContext) {\n      instancing.drawArraysInstanced(\n        drawMode(this.gl, model.drawMode),\n        drawRange[0],\n        drawRange[1],\n        model.drawInstances\n      );\n    } else if (instancing) {\n      instancing.drawArraysInstancedANGLE(\n        drawMode(this.gl, model.drawMode),\n        drawRange[0],\n        drawRange[1],\n        model.drawInstances\n      );\n    } else {\n      this.gl.drawArrays(\n        drawMode(this.gl, model.drawMode),\n        drawRange[0],\n        drawRange[1]\n      );\n    }\n\n    // Without committing to the GPU, we set the draw buffer to require a state\n    // change again.\n    this.state.setDrawBuffers([], true);\n  }\n\n  /**\n   * Destroys an attribute's resources from the GL Context\n   */\n  disposeAttribute(attribute: Attribute) {\n    if (!attribute.gl) return;\n    this.gl.deleteBuffer(attribute.gl.bufferId);\n    delete attribute.gl;\n  }\n\n  /**\n   * Destroys a color buffer's resources from the GL Context\n   */\n  disposeColorBuffer(colorBuffer: ColorBuffer) {\n    if (colorBuffer.gl) {\n      if (colorBuffer.gl.bufferId) {\n        this.disposeRenderBuffer(colorBuffer.gl.bufferId);\n      }\n\n      delete colorBuffer.gl;\n    }\n  }\n\n  /**\n   * Destroys a geometry's resources from the GL Context\n   */\n  disposeGeometry(geometry: Geometry) {\n    if (geometry.gl) {\n      if (this.extensions.vao && geometry.gl.vao) {\n        if (this.extensions.vao instanceof WebGL2RenderingContext) {\n          this.extensions.vao.deleteVertexArray(geometry.gl.vao);\n        } else {\n          this.extensions.vao.deleteVertexArrayOES(geometry.gl.vao);\n        }\n      }\n    }\n  }\n\n  /**\n   * Destroys a material's resources from the GL Context.\n   */\n  disposeMaterial(material: Material) {\n    if (material.gl) {\n      const { vsId, fsId: fsIds, programId } = material.gl;\n      let fsLookup = this.programs.get(vsId);\n\n      // If nothing is found we have something with odd state. Just delete the vertex\n      // and fake the object to continue the program normally\n      if (!fsLookup) {\n        fsLookup = new Map();\n        this.gl.deleteShader(vsId);\n      }\n\n      for (let i = 0, iMax = fsIds.length; i < iMax; ++i) {\n        const fsId = fsIds[i];\n        let useMetrics = fsLookup.get(fsId);\n\n        // No use metrics means odd state, make a fake object to continue the process normally\n        if (!useMetrics) {\n          useMetrics = {\n            useCount: 0,\n            program: programId\n          };\n        }\n\n        // We're removing a material from utilizing this program, thus reduce it's useage\n        useMetrics.useCount--;\n\n        // If the useage is at or drops below zero, the program is no longer valid and not in use\n        if (useMetrics.useCount < 1) {\n          this.gl.deleteProgram(useMetrics.program);\n          fsLookup.delete(fsId);\n\n          // If removing this fragment shader reference reduces the lookups to zero, then the\n          // vertex shader is not paired with anything and has no programs. It is ready for\n          // removal as well\n          if (fsLookup.size <= 0) {\n            this.gl.deleteShader(vsId);\n          }\n        }\n\n        // The fragment shader is a bit trickier, we must go through all vertex shader lookups and see\n        // if the fragment shader exists in any of them. If not: the fragment shader is ready for removal\n        let found = false;\n        this.programs.forEach(fsLookup => {\n          if (fsLookup.has(fsId)) found = true;\n        });\n\n        // If no fragment shader references remain: delete it.\n        if (!found) {\n          this.gl.deleteShader(fsId);\n        }\n      }\n    }\n\n    delete material.gl;\n  }\n\n  /**\n   * Destroy a render buffer (RBO)\n   */\n  disposeRenderBuffer(buffer: WebGLRenderbuffer) {\n    this.gl.deleteRenderbuffer(buffer);\n  }\n\n  /**\n   * Destroys a render target's resources from the GL context\n   */\n  disposeRenderTarget(target: RenderTarget) {\n    if (target.gl) {\n      // List of color buffers for MRT\n      if (Array.isArray(target.gl.colorBufferId)) {\n        target.gl.colorBufferId.forEach(buffer => {\n          if (buffer.data instanceof Texture && !target.retainTextureTargets) {\n            this.disposeTexture(buffer.data);\n          } else if (buffer.data instanceof WebGLRenderbuffer) {\n            this.disposeRenderBuffer(buffer.data);\n          }\n        });\n      } else if (\n        target.gl.colorBufferId &&\n        target.gl.colorBufferId.data instanceof Texture &&\n        !target.retainTextureTargets\n      ) {\n        this.disposeTexture(target.gl.colorBufferId.data);\n      } else if (target.gl.colorBufferId instanceof WebGLRenderbuffer) {\n        this.disposeRenderBuffer(target.gl.colorBufferId.data);\n      }\n\n      // Dispose of depth buffer\n      if (\n        target.gl.depthBufferId instanceof Texture &&\n        !target.retainTextureTargets\n      ) {\n        this.disposeTexture(target.gl.depthBufferId);\n      } else if (target.gl.depthBufferId instanceof WebGLRenderbuffer) {\n        this.disposeRenderBuffer(target.gl.depthBufferId);\n      }\n\n      // Dispose of stencil buffer\n      if (\n        target.gl.stencilBufferId instanceof Texture &&\n        !target.retainTextureTargets\n      ) {\n        this.disposeTexture(target.gl.stencilBufferId);\n      } else if (target.gl.stencilBufferId instanceof WebGLRenderbuffer) {\n        this.disposeRenderBuffer(target.gl.stencilBufferId);\n      }\n\n      // Delete the framebuffer object associated with this render target\n      this.gl.deleteFramebuffer(target.gl.fboId);\n\n      // Clean up the context generated for the render target\n      delete target.gl;\n    }\n  }\n\n  /**\n   * Destroys a texture's resources from the GL context\n   */\n  disposeTexture(texture: Texture) {\n    if (texture.gl && !texture.destroyed) {\n      this.gl.deleteTexture(texture.gl.textureId);\n      this.state.freeTextureUnit(texture);\n    }\n\n    delete texture.gl;\n  }\n\n  /**\n   * Retrieves the gl context from the canvas\n   */\n  static getContext(canvas: HTMLCanvasElement, options: {}) {\n    // Attempt to fetch the same webgl as webgl stat reports, if it fails,\n    // attempt to fetch in descending order a known version of webgl.\n    const names = [\n      WebGLStat.WEBGL_VERSION,\n      \"webgl\",\n      \"webgl2\",\n      \"experimental-webgl\"\n    ];\n    let context: GLContext | null = null;\n    let extensions: IExtensions = {};\n\n    for (let i = 0; i < names.length; ++i) {\n      const name = names[i];\n      const ctx = canvas.getContext(name, options);\n\n      if (\n        ctx &&\n        (ctx instanceof WebGLRenderingContext ||\n          ctx instanceof WebGL2RenderingContext)\n      ) {\n        debug(\n          \"Generated GL Context of version with attributes:\",\n          name,\n          options\n        );\n        context = ctx;\n        extensions = GLProxy.addExtensions(context);\n        break;\n      }\n    }\n\n    return {\n      context,\n      extensions\n    };\n  }\n\n  /**\n   * This decodes and prints any webgl context error in a  human readable manner.\n   */\n  printError() {\n    const glError = this.gl.getError();\n\n    switch (glError) {\n      case this.gl.NO_ERROR:\n        console.warn(\"GL Error: No Error\");\n        break;\n\n      case this.gl.INVALID_ENUM:\n        console.warn(\"GL Error: INVALID ENUM\");\n        break;\n\n      case this.gl.INVALID_VALUE:\n        console.warn(\"GL Error: INVALID_VALUE\");\n        break;\n\n      case this.gl.INVALID_OPERATION:\n        console.warn(\"GL Error: INVALID OPERATION\");\n        break;\n\n      case this.gl.INVALID_FRAMEBUFFER_OPERATION:\n        console.warn(\"GL Error: INVALID FRAMEBUFFER OPERATION\");\n        break;\n\n      case this.gl.OUT_OF_MEMORY:\n        console.warn(\"GL Error: OUT OF MEMORY\");\n        break;\n\n      case this.gl.CONTEXT_LOST_WEBGL:\n        console.warn(\"GL Error: CONTEXT LOST WEBGL\");\n        break;\n\n      default:\n        console.warn(\n          \"GL Error: GL Context output an unrecognized error value:\",\n          glError\n        );\n        break;\n    }\n  }\n\n  /**\n   * Breaks down a string into a multiline structure. Helps pretty print some\n   * items.\n   */\n  lineFormat(str: string) {\n    const lines = str.split(\"\\n\");\n    const lineChars = String(lines.length).length + 1;\n\n    return `\\n${lines\n      .map(\n        (l, i) =>\n          `${Array(lineChars - String(i + 1).length).join(\" \")}${i + 1}: ${l}`\n      )\n      .join(\"\\n\")}`;\n  }\n\n  /**\n   * Prints a shader broken down by lines\n   */\n  lineFormatShader(\n    shader: Material[\"fragmentShader\"] | Material[\"vertexShader\"]\n  ) {\n    if (isString(shader)) {\n      return this.lineFormat(shader);\n    } else {\n      return shader.forEach(\n        s =>\n          `\\nSHADER FOR OUTPUT TYPES: ${s.outputTypes} ${this.lineFormat(\n            s.source\n          )}`\n      );\n    }\n  }\n\n  /**\n   * Ensures a texture object is compiled and/or updated.\n   */\n  updateTexture(texture: Texture) {\n    if (!texture.gl || texture.gl.textureUnit < 0) {\n      console.warn(\n        this.debugContext,\n        \"Can not update or compile a texture that does not have an established texture unit.\",\n        texture\n      );\n      return;\n    }\n\n    // Perform any necessary compilation or settings changes requested of the texture\n    this.compileTexture(texture);\n    this.updateTextureData(texture);\n    this.updateTexturePartialData(texture);\n    this.updateTextureSettings(texture);\n\n    // Indicate all updates required of the texture have been performed\n    texture.resolve();\n  }\n\n  /**\n   * Ensures the texture object has it's data uploaded to the GPU\n   */\n  private updateTextureData(texture: Texture) {\n    // Check for upload flag\n    if (!texture.needsDataUpload) return;\n    // Check for gl context established\n    if (!texture.gl) return;\n    // This texture must have an establish texture id\n    if (!texture.gl.textureId) return;\n\n    // The texture must have a unit established in order to have it's data updated\n    if (texture.gl.textureUnit < 0) {\n      console.warn(\n        this.debugContext,\n        \"A Texture object attempted to update it's data without an established Texture Unit.\",\n        texture\n      );\n      return;\n    }\n\n    const gl = this.gl;\n\n    // Ensure we are operating on the correct active unit\n    this.state.setActiveTextureUnit(texture.gl.textureUnit);\n    // Ensure our texture is bound as the active texture unit\n    this.state.bindTexture(\n      texture,\n      GLSettings.Texture.TextureBindingTarget.TEXTURE_2D\n    );\n\n    // Make sure the settings are properly set for the texture before performing the data upload\n    texture.needsSettingsUpdate = true;\n    this.updateTextureSettings(texture);\n\n    // First set the data in the texture\n    if (\n      gl instanceof WebGLRenderingContext ||\n      (gl as any) instanceof WebGL2RenderingContext\n    ) {\n      if (isDataBuffer(texture.data)) {\n        if (\n          !isPowerOf2(texture.data.width) ||\n          !isPowerOf2(texture.data.height)\n        ) {\n          debug(\"Created a texture that is not using power of 2 dimensions.\");\n        }\n\n        const texFormat = texelFormat(gl, texture.internalFormat);\n        const dataFormat = texelFormat(gl, texture.format);\n\n        if (gl instanceof WebGLRenderingContext) {\n          if (texFormat !== dataFormat) {\n            console.warn(\n              \"WebGL 1 requires format and data format to be identical\"\n            );\n          }\n        }\n\n        gl.texImage2D(\n          gl.TEXTURE_2D,\n          0,\n          texFormat,\n          texture.data.width,\n          texture.data.height,\n          0,\n          dataFormat,\n          inputImageFormat(gl, texture.type),\n          texture.data.buffer\n        );\n      } else if (texture.data) {\n        if (\n          !isPowerOf2(texture.data.width) ||\n          !isPowerOf2(texture.data.height)\n        ) {\n          debug(\n            \"Created a texture that is not using power of 2 dimensions. %o\",\n            texture\n          );\n        }\n\n        gl.texImage2D(\n          gl.TEXTURE_2D,\n          0,\n          texelFormat(gl, texture.internalFormat),\n          texelFormat(gl, texture.format),\n          inputImageFormat(gl, texture.type),\n          // @ts-ignore Typescript is not able to pick the correct overload for the type check for this for some reason\n          texture.data\n        );\n      }\n\n      if (texture.generateMipMaps) {\n        gl.generateMipmap(gl.TEXTURE_2D);\n      }\n    }\n\n    // Let's not hang onto large data buffers that are being uploaded to the gpu. Let's\n    // delete the buffer but keep some simple metrics about it.\n    if (texture.data) {\n      texture.data = {\n        width: texture.data.width,\n        height: texture.data.height,\n        buffer: null\n      };\n    }\n\n    // Clear the flag for updates\n    texture.needsDataUpload = false;\n  }\n\n  /**\n   * This consumes all of the partial texture updates applied to the texture.\n   */\n  private updateTexturePartialData(texture: Texture) {\n    // Check for partial update flag\n    if (!texture.needsPartialDataUpload) return;\n    // Check for gl context established\n    if (!texture.gl) return;\n    // This texture must have an establish texture id\n    if (!texture.gl.textureId) return;\n\n    // The texture must have a unit established in order to have it's data updated\n    if (texture.gl.textureUnit < 0) {\n      console.warn(\n        this.debugContext,\n        \"A Texture object attempted to update it's data without an established Texture Unit.\",\n        texture\n      );\n      return;\n    }\n\n    // Get gl context to work with\n    const gl = this.gl;\n    // Ensure we are operating on the correct active unit\n    this.state.setActiveTextureUnit(texture.gl.textureUnit);\n    // Ensure our texture is bound as the active texture unit\n    this.state.bindTexture(\n      texture,\n      GLSettings.Texture.TextureBindingTarget.TEXTURE_2D\n    );\n\n    // Loop through all the necessary update regions and apply the changes\n    texture.updateRegions.forEach(region => {\n      const buffer = region[0];\n      const bounds = region[1];\n\n      // First set the data in the texture\n      if (\n        gl instanceof WebGLRenderingContext ||\n        (gl as any) instanceof WebGL2RenderingContext\n      ) {\n        if (isDataBuffer(buffer)) {\n          gl.texSubImage2D(\n            gl.TEXTURE_2D,\n            0,\n            bounds.x,\n            bounds.y,\n            buffer.width,\n            buffer.height,\n            texelFormat(gl, texture.format),\n            inputImageFormat(gl, texture.type),\n            buffer.buffer\n          );\n        } else if (buffer) {\n          gl.texSubImage2D(\n            gl.TEXTURE_2D,\n            0,\n            bounds.x,\n            bounds.y,\n            texelFormat(gl, texture.format),\n            inputImageFormat(gl, texture.type),\n            // @ts-ignore Typescript is not able to pick the correct overload for the type check for this for some reason\n            buffer\n          );\n        }\n\n        if (texture.generateMipMaps) {\n          gl.generateMipmap(gl.TEXTURE_2D);\n        }\n      }\n    });\n\n    // Flag the deed as done\n    texture.needsPartialDataUpload = false;\n  }\n\n  /**\n   * Modifies all settings needing modified on the provided texture object.\n   */\n  private updateTextureSettings(texture: Texture) {\n    // Check update flag\n    if (!texture.needsSettingsUpdate) return;\n    // Check for gl context\n    if (!texture.gl || !texture.data) return;\n    // This texture must have an establish texture id\n    if (!texture.gl.textureId) return;\n\n    // The texture must have a unit established in order to be compiled\n    if (texture.gl.textureUnit < 0) {\n      console.warn(\n        this.debugContext,\n        \"A Texture object attempted to update it's settings without an established Texture Unit.\",\n        texture\n      );\n      return;\n    }\n\n    const isPower2 =\n      isPowerOf2(texture.data.width) && isPowerOf2(texture.data.height);\n    const gl = this.gl;\n    this.state.setActiveTextureUnit(texture.gl.textureUnit);\n    this.state.bindTexture(\n      texture,\n      GLSettings.Texture.TextureBindingTarget.TEXTURE_2D\n    );\n\n    let texMagFilter;\n    let texMinFilter;\n\n    // Handle special cases for floating textures and performance\n    if (texture.isHalfFloatTexture) {\n      if (WebGLStat.FLOAT_TEXTURE_READ.halfLinearFilter) {\n        texMagFilter = magFilter(gl, texture.magFilter);\n\n        switch (texture.minFilter) {\n          case GLSettings.Texture.TextureMinFilter.Nearest:\n          case GLSettings.Texture.TextureMinFilter.NearestMipMapLinear:\n          case GLSettings.Texture.TextureMinFilter.NearestMipMapNearest:\n            texMinFilter = minFilter(\n              gl,\n              GLSettings.Texture.TextureMinFilter.Nearest,\n              texture.generateMipMaps\n            );\n            break;\n\n          case GLSettings.Texture.TextureMinFilter.Linear:\n          case GLSettings.Texture.TextureMinFilter.LinearMipMapLinear:\n          case GLSettings.Texture.TextureMinFilter.LinearMipMapNearest:\n            texMinFilter = minFilter(\n              gl,\n              GLSettings.Texture.TextureMinFilter.Nearest,\n              texture.generateMipMaps\n            );\n            break;\n        }\n      } else {\n        texMagFilter = magFilter(\n          gl,\n          GLSettings.Texture.TextureMagFilter.Nearest\n        );\n        texMinFilter = minFilter(\n          gl,\n          GLSettings.Texture.TextureMinFilter.Nearest,\n          texture.generateMipMaps\n        );\n      }\n    } else if (texture.isFloatTexture) {\n      if (WebGLStat.FLOAT_TEXTURE_READ.fullLinearFilter) {\n        texMagFilter = magFilter(gl, texture.magFilter);\n\n        switch (texture.minFilter) {\n          case GLSettings.Texture.TextureMinFilter.Nearest:\n          case GLSettings.Texture.TextureMinFilter.NearestMipMapLinear:\n          case GLSettings.Texture.TextureMinFilter.NearestMipMapNearest:\n            texMinFilter = minFilter(\n              gl,\n              GLSettings.Texture.TextureMinFilter.Nearest,\n              texture.generateMipMaps\n            );\n            break;\n\n          case GLSettings.Texture.TextureMinFilter.Linear:\n          case GLSettings.Texture.TextureMinFilter.LinearMipMapLinear:\n          case GLSettings.Texture.TextureMinFilter.LinearMipMapNearest:\n            texMinFilter = minFilter(\n              gl,\n              GLSettings.Texture.TextureMinFilter.Nearest,\n              texture.generateMipMaps\n            );\n            break;\n        }\n      } else {\n        texMagFilter = magFilter(\n          gl,\n          GLSettings.Texture.TextureMagFilter.Nearest\n        );\n        texMinFilter = minFilter(\n          gl,\n          GLSettings.Texture.TextureMinFilter.Nearest,\n          texture.generateMipMaps\n        );\n      }\n    }\n\n    // Handle special case for NPOT textures and WebGL 1\n    else if (!isPower2 && gl instanceof WebGLRenderingContext) {\n      texMagFilter = magFilter(gl, GLSettings.Texture.TextureMagFilter.Linear);\n      texMinFilter = minFilter(\n        gl,\n        GLSettings.Texture.TextureMinFilter.Linear,\n        texture.generateMipMaps\n      );\n    }\n\n    // Otherwise, we should be good to use the settings specified!\n    else {\n      texMagFilter = magFilter(gl, texture.magFilter);\n      texMinFilter = minFilter(gl, texture.minFilter, texture.generateMipMaps);\n    }\n\n    // Set filtering and other properties to the texture\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texMagFilter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texMinFilter);\n\n    if (!texture.isFloatTexture) {\n      gl.texParameteri(\n        gl.TEXTURE_2D,\n        gl.TEXTURE_WRAP_S,\n        wrapMode(gl, texture.wrapHorizontal)\n      );\n      gl.texParameteri(\n        gl.TEXTURE_2D,\n        gl.TEXTURE_WRAP_T,\n        wrapMode(gl, texture.wrapVertical)\n      );\n    }\n\n    // NOTE: All pixelStorei with boolean settings:\n    // The typescript definitions are wrong right now thus requiring some weird casting\n    // voodoo. The correct value according to the webgl specs IS true right here and not a number\n    // for this particular enum.\n\n    if (!texture.isFloatTexture) {\n      gl.pixelStorei(\n        gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,\n        (texture.premultiplyAlpha as unknown) as number\n      );\n\n      gl.pixelStorei(\n        gl.UNPACK_FLIP_Y_WEBGL,\n        (texture.flipY as unknown) as number\n      );\n    }\n\n    // Apply the anistropic extension (if available)\n    if (this.extensions.anisotropicFiltering) {\n      const { ext, stat } = this.extensions.anisotropicFiltering;\n      const anisotropy = Math.min(\n        stat.maxAnistropicFilter,\n        Math.floor(texture.anisotropy)\n      );\n\n      if (!isNaN(anisotropy) && !texture.isFloatTexture) {\n        gl.texParameterf(\n          gl.TEXTURE_2D,\n          ext.TEXTURE_MAX_ANISOTROPY_EXT,\n          anisotropy\n        );\n      }\n    }\n\n    // Clear the flag for updates\n    texture.needsSettingsUpdate = false;\n  }\n\n  /**\n   * This updates an attribute's buffer data\n   */\n  updateAttribute(attribute: Attribute) {\n    if (!attribute.gl) return this.compileAttribute(attribute);\n\n    // Make sure an update is even needed\n    if (!attribute.fullUpdate && !attribute.needsUpdate) {\n      return true;\n    }\n\n    const gl = this.gl;\n\n    // Check to see if this should be a complete buffer update\n    if (\n      attribute.fullUpdate ||\n      attribute.updateRange.count < 0 ||\n      attribute.updateRange.offset < 0\n    ) {\n      // State change\n      this.state.bindVBO(attribute.gl.bufferId);\n      // Upload data\n      gl.bufferData(\n        gl.ARRAY_BUFFER,\n        attribute.data,\n        attribute.isDynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW\n      );\n    }\n\n    // Otherwise, we work to upload only a partial update to the buffer\n    else if (attribute.updateRange.count > 0) {\n      // State change\n      this.state.bindVBO(attribute.gl.bufferId);\n      // Upload data\n      const start = attribute.updateRange.offset;\n      gl.bufferSubData(\n        gl.ARRAY_BUFFER,\n        start * 4,\n        attribute.data.subarray(start, start + attribute.updateRange.count)\n      );\n    }\n\n    // Flag the attribute as updated to all of it's necessities\n    attribute.resolve();\n\n    return true;\n  }\n\n  /**\n   * This performs all necessary functions to use the attribute utilizing\n   * the current program in use.\n   */\n  useAttribute(name: string, attribute: Attribute, geometry: Geometry) {\n    // We need a valid program in use.\n    if (!this.state.currentProgram) return false;\n    // Must have it's gl context established\n    if (!attribute.gl) return false;\n\n    // Ensure the attribute has established location information for this program\n    attribute.gl.locations = attribute.gl.locations || new Map();\n    // Find existing attribute location for the current program\n    let location = attribute.gl.locations.get(this.state.currentProgram);\n\n    // If no location is found for this attribute for this program we must query for it\n    if (location === undefined) {\n      location = this.gl.getAttribLocation(this.state.currentProgram, name);\n\n      if (location === -1) {\n        debug(\n          \"WARN: An attribute is not being used with the current material: %o\",\n          name,\n          attribute\n        );\n      }\n\n      attribute.gl.locations.set(this.state.currentProgram, location);\n    }\n\n    // Exit if our location is invalid for this attribute. It won't be used in next draw call.\n    if (location === -1) return;\n\n    // At this point we're ready to establish the attribute's state and stride\n    this.state.bindVBO(attribute.gl.bufferId);\n\n    switch (attribute.size) {\n      // For sizes that fit within a single vertex block, this is the simplest way to establish the pointer\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        // Enable the use of the vertex location\n        this.state.willUseVertexAttributeArray(location);\n\n        // Now we establish the metrics of the buffer\n        this.gl.vertexAttribPointer(\n          location,\n          attribute.size, // How many floats used for the attribute\n          this.gl.FLOAT, // We are only sending over float data right now\n          attribute.normalize,\n          0,\n          0\n        );\n\n        if (\n          geometry.isInstanced &&\n          attribute.isInstanced &&\n          this.extensions.instancing\n        ) {\n          this.state.setVertexAttributeArrayDivisor(location, 1);\n        } else {\n          this.state.setVertexAttributeArrayDivisor(location, 0);\n        }\n        break;\n\n      // For sizes that exceed a single 'block' for a vertex attribute, one must break up the attribute pointers as the\n      // max allowed size is 4 at a time.\n      default:\n        const totalBlocks = Math.ceil(attribute.size / 4);\n\n        for (let i = 0; i < totalBlocks; ++i) {\n          // Enable the use of the vertex location\n          this.state.willUseVertexAttributeArray(location + i);\n\n          this.gl.vertexAttribPointer(\n            location + i,\n            4,\n            this.gl.FLOAT,\n            attribute.normalize,\n            totalBlocks * 4 * 4,\n            i * 16\n          );\n\n          if (\n            geometry.isInstanced &&\n            attribute.isInstanced &&\n            this.extensions.instancing\n          ) {\n            this.state.setVertexAttributeArrayDivisor(location + i, 1);\n          } else {\n            this.state.setVertexAttributeArrayDivisor(location + i, 0);\n          }\n        }\n\n        break;\n    }\n\n    return true;\n  }\n}\n","import { Vec2 } from \"../math\";\nimport { GLProxy } from \"./gl-proxy\";\nimport { GLSettings } from \"./gl-settings\";\n\n/**\n * This is the options to apply to a texture\n */\nexport type ColorBufferOptions = Omit<Partial<ColorBuffer>, \"destroy\">;\n\n/**\n * This is a buffer that is essentially the same as a Texture resource; however,\n * is different in that it can not be used as a texture in render processes. In\n * some rare cases, this is a faster render target on some hardware than others.\n */\nexport class ColorBuffer {\n  /**\n   * Indicates this ColorBuffer has been destroyed, meaning it is useless and\n   * invalid to use within the application.\n   */\n  public get destroyed(): boolean {\n    return this._destroyed;\n  }\n  private _destroyed: boolean = false;\n\n  /**\n   * This stores any gl state associated with this object. Modifying this object\n   * will cause the system to get out of sync with the GPU; however, the values\n   * inside this object can be read and used for custom WebGL calls as needed.\n   */\n  gl?: {\n    /** The identifier used by gl to target this color buffer. */\n    bufferId: WebGLRenderbuffer | null;\n    /**\n     * This is the proxy communicator with the context that generates and\n     * destroys Color Buffers.\n     */\n    proxy: GLProxy;\n  };\n\n  /**\n   * Tells the input packing to premultiply the alpha values with the other\n   * channels as the texture is generated. See:\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei\n   */\n  get internalFormat() {\n    return this._internalFormat;\n  }\n  set internalFormat(val: ColorBuffer[\"_internalFormat\"]) {\n    this.needsSettingsUpdate = true;\n    this._internalFormat = val;\n  }\n  private _internalFormat:\n    | GLSettings.RenderTarget.ColorBufferFormat\n    | GLSettings.RenderTarget.DepthBufferFormat\n    | GLSettings.RenderTarget.StencilBufferFormat =\n    GLSettings.RenderTarget.ColorBufferFormat.RGBA4;\n\n  /** Flag indicates if the Render Buffer needs it's settings modified */\n  needsSettingsUpdate: boolean = false;\n\n  /**\n   * The dimensions of this color buffer object.\n   */\n  get size() {\n    return this._size;\n  }\n  set size(val: ColorBuffer[\"_size\"]) {\n    this.needsSettingsUpdate = true;\n    this._size = val;\n  }\n  private _size: Vec2 = [0, 0];\n\n  /**\n   * Default ctor\n   */\n  constructor(options: ColorBufferOptions) {\n    this.size = options.size || this.size;\n    this.internalFormat = options.internalFormat ?? this.internalFormat;\n  }\n\n  /**\n   * Destroys and frees the resources this buffer utilizes in the gl context.\n   * This also invalidates this as a viable resource permanently.\n   */\n  destroy() {\n    if (this.gl) {\n      this.gl.proxy.disposeColorBuffer(this);\n    }\n\n    this._destroyed = true;\n  }\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","import { compare4, copy4, flatten4, Vec4 } from \"../math/vector\";\nimport { FragmentOutputType, TypeVec } from \"../types\";\nimport { indexToTextureUnit, textureUnitToIndex } from \"./gl-decode\";\nimport { GLProxy } from \"./gl-proxy\";\nimport { GLSettings } from \"./gl-settings\";\nimport { Material } from \"./material\";\nimport { RenderTarget } from \"./render-target\";\nimport { Texture } from \"./texture\";\nimport {\n  IExtensions,\n  IMaterialUniform,\n  MaterialUniformType,\n  MaterialUniformValue,\n  UseMaterialStatus\n} from \"./types\";\n\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * This class represents all of the current state and settings that the gl context is in currently. This\n * helps to decide when to make gl calls to alter the state and not do so unecessarily.\n *\n * This state focuses on global state settings like bound objects and gl settings. Other state\n * for the GL context is stored within objects that are generated, such as Texture and Attribute.\n */\nexport class GLState {\n  /** Message to include with debug, warns, and errors */\n  debugContext: string = \"\";\n  /** The extensions enabled for the context */\n  private extensions: IExtensions;\n  /** Stores the gl context this is watching the state over */\n  private gl: WebGLRenderingContext;\n  /** This is a proxy to execute commands that do not change global gl state */\n  private glProxy: GLProxy;\n  /** Lookup a texture unit to it's current assigned texture. */\n  private _textureUnitToTexture = new Map<number, Texture | null>();\n  /** This holds which texture units are free for use and have no Texture assigned to them */\n  private _freeUnits: number[] = [];\n\n  /** Indicates if blending is enabled */\n  get blendingEnabled() {\n    return this._blendingEnabled;\n  }\n  private _blendingEnabled = true;\n\n  /** The current destination factor used in the blending equation */\n  get blendDstFactor() {\n    return this._blendDstFactor;\n  }\n  private _blendDstFactor = GLSettings.Material.BlendingDstFactor.One;\n\n  /** The current destination factor used in the blending equation */\n  get blendSrcFactor() {\n    return this._blendSrcFactor;\n  }\n  private _blendSrcFactor:\n    | GLSettings.Material.BlendingSrcFactor\n    | GLSettings.Material.BlendingDstFactor =\n    GLSettings.Material.BlendingDstFactor.One;\n\n  /** The current equation used in the blend mode */\n  get blendEquation() {\n    return this._blendEquation;\n  }\n  private _blendEquation = GLSettings.Material.BlendingEquations.Add;\n\n  /** Indicates which faces will be culled */\n  get cullFace() {\n    return this._cullFace;\n  }\n  private _cullFace: GLSettings.Material.CullSide =\n    GLSettings.Material.CullSide.NONE;\n\n  /** The channels in the color buffer a fragment is allowed to write to */\n  get colorMask() {\n    return this._colorMask;\n  }\n  private _colorMask: TypeVec<boolean> = [true, true, true, true];\n\n  /** The current color the context will clear when clear with the color buffer bit is called */\n  get clearColor() {\n    return this._clearColor;\n  }\n  private _clearColor: Vec4 = [0.0, 0.0, 0.0, 1.0];\n\n  /** Comparator used when testing a fragment against the depth buffer */\n  get depthFunc() {\n    return this._depthFunc;\n  }\n  private _depthFunc = GLSettings.Material.DepthFunctions.ALWAYS;\n\n  /** Indicates if fragments are tested against the depth buffer or not */\n  get depthTestEnabled() {\n    return this._depthTestEnabled;\n  }\n  private _depthTestEnabled = true;\n\n  /** Indicates if the fragment will write to the depth buffer or not */\n  get depthMask() {\n    return this._depthMask;\n  }\n  private _depthMask = true;\n\n  /** Indicates if dithering is enabled */\n  get ditheringEnabled() {\n    return this._ditheringEnabled;\n  }\n  private _ditheringEnabled = true;\n\n  /** The currently bound frame buffer object. null if nothing bound. */\n  get boundFBO() {\n    return this._boundFBO;\n  }\n  private _boundFBO: WebGLFramebuffer | null = null;\n\n  /**\n   * This is the current render target who's FBO is bound. A null render target\n   * indicates the target is the screen.\n   */\n  get renderTarget() {\n    return this._renderTarget;\n  }\n  private _renderTarget: RenderTarget | null;\n\n  /** The currently bound render buffer object. null if nothing bound. */\n  get boundRBO() {\n    return this._boundRBO;\n  }\n  private _boundRBO: WebGLRenderbuffer | null = null;\n\n  /** The current id of the current bound vao. If null, nothing is bound */\n  get boundVAO() {\n    return this._boundVAO;\n  }\n  private _boundVAO: WebGLVertexArrayObject | null = null;\n\n  /** The current id of the current bound vbo. If null, nothing is bound */\n  get boundVBO() {\n    return this._boundVBO;\n  }\n  private _boundVBO: WebGLBuffer | null = null;\n\n  /**\n   * The current texture object bound. If null, nothing is bound. This also tracks\n   * the texture unit to which it was bound. The unit and the texture object must match for\n   * a binding call to be skipped.\n   */\n  get boundTexture() {\n    return this._boundTexture;\n  }\n  private _boundTexture: { id: WebGLTexture | null; unit: number } = {\n    id: null,\n    unit: -1\n  };\n\n  /** The current program in use */\n  get currentProgram() {\n    return this._currentProgram;\n  }\n  private _currentProgram: WebGLProgram | null = null;\n\n  /** Indicates if the scissor test is enabled in the context */\n  get scissorTestEnabled() {\n    return this._scissorTestEnabled;\n  }\n  private _scissorTestEnabled: boolean = false;\n\n  /** The current bounds of the scissor test */\n  get scissorBounds() {\n    return this._scissorBounds;\n  }\n  private _scissorBounds = { x: 0, y: 0, width: 1, height: 1 };\n\n  /** These are the current uniforms uploaded to the GPU */\n  get currentUniforms() {\n    return this._currentUniforms;\n  }\n  private _currentUniforms: {\n    [name: string]: IMaterialUniform<MaterialUniformType>;\n  };\n\n  /** This is the texture unit currently active */\n  get activeTextureUnit() {\n    return this._activeTextureUnit;\n  }\n  private _activeTextureUnit: number = -1;\n\n  /** This is the buffer state set and activated for the drawBuffers call */\n  get drawBuffers() {\n    return this._drawBuffers;\n  }\n  private _drawBuffers: number[] = [];\n\n  /**\n   * This contains all of the textures that are are needing to be utilized for\n   * next draw. Textures are used by either uniforms or by RenderTargets in a\n   * single draw call. Thus we track the uniforms or the render targets awaiting\n   * use of the texture.\n   */\n  get textureWillBeUsed() {\n    return this._textureWillBeUsed;\n  }\n  private _textureWillBeUsed = new Map<\n    Texture,\n    Set<WebGLUniformLocation> | RenderTarget\n  >();\n\n  /** The current viewport gl is using */\n  get viewport() {\n    return this._viewport;\n  }\n  private _viewport = { x: 0, y: 0, width: 100, height: 100 };\n\n  /** This contains all of the currently enabled vertex attribute pointers */\n  get enabledVertexAttributeArray() {\n    return this._enabledVertexAttributeArray\n      .slice(0)\n      .filter(n => n !== undefined);\n  }\n  private _enabledVertexAttributeArray: number[] = [];\n  private _willUseVertexAttributeArray: number[] = [];\n\n  /** Tracks the current divisor set to a given vertex array location. */\n  private _vertexAttributeArrayDivisor = new Map<number, number>();\n\n  /**\n   * Generate a new state manager and establish some initial state settings by querying the context.\n   */\n  constructor(gl: WebGLRenderingContext, extensions: IExtensions) {\n    this.gl = gl;\n    this.extensions = extensions;\n    // Retrieve how many units are allowed at the same time to be assiged so we can initialize our free units array\n    const totalUnits = this.gl.getParameter(\n      gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS\n    );\n\n    for (let i = 0; i < totalUnits; ++i) {\n      this._freeUnits.push(indexToTextureUnit(gl, i));\n    }\n\n    // Initialize state to valid value\n    this._activeTextureUnit = gl.TEXTURE0;\n  }\n\n  /**\n   * Sets the provided vertex array as the current bound item.\n   */\n  bindVAO(id: WebGLVertexArrayObject | null) {\n    if (this._boundVAO !== id) {\n      this._boundVAO = id;\n\n      if (this.extensions.vao) {\n        if (this.extensions.vao instanceof WebGL2RenderingContext) {\n          this.extensions.vao.bindVertexArray(id);\n        } else {\n          this.extensions.vao.bindVertexArrayOES(id);\n        }\n      }\n    }\n  }\n\n  /**\n   * Sets the provided buffer identifier as the current bound item.\n   */\n  bindVBO(id: WebGLBuffer | null) {\n    if (this._boundVBO !== id) {\n      this._boundVBO = id;\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, id);\n    }\n  }\n\n  /**\n   * Sets the provided buffer identifier as the current bound item\n   */\n  bindRBO(id: WebGLRenderbuffer) {\n    if (this._boundRBO !== id) {\n      this._boundRBO = id;\n      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, id);\n    }\n  }\n\n  /**\n   * Sets the provided buffer identifier as the current bound item\n   */\n  bindFBO(id: WebGLFramebuffer | null) {\n    if (this._boundFBO !== id) {\n      this._boundFBO = id;\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, id);\n    }\n  }\n\n  /**\n   * Sets the provided buffer identifier as the current bound item. This automatically\n   * updates all stateful information to track that a texture is now utilizing a texture unit.\n   */\n  bindTexture(\n    texture: Texture,\n    target: GLSettings.Texture.TextureBindingTarget\n  ) {\n    if (!texture.gl || !texture.gl.textureId) return;\n\n    if (\n      !texture ||\n      this._boundTexture.id !== texture.gl.textureId ||\n      this._boundTexture.unit !== this._activeTextureUnit\n    ) {\n      this._boundTexture = {\n        id: texture.gl.textureId,\n        unit: this._activeTextureUnit\n      };\n\n      switch (target) {\n        case GLSettings.Texture.TextureBindingTarget.TEXTURE_2D:\n          this.gl.bindTexture(this.gl.TEXTURE_2D, texture.gl.textureId);\n          break;\n\n        case GLSettings.Texture.TextureBindingTarget.TEXTURE_2D:\n          this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, texture.gl.textureId);\n          break;\n      }\n\n      // Since the binding happened, we HAVE to track that this texture is now the texture\n      // for the current active unit. We must also remove the unit from any texture previously\n      // utilizing the unit\n      const previous = this._textureUnitToTexture.get(this._activeTextureUnit);\n\n      if (previous) {\n        if (previous.gl) previous.gl.textureUnit = -1;\n      }\n\n      this._textureUnitToTexture.set(this._activeTextureUnit, texture);\n      texture.gl.textureUnit = this._activeTextureUnit;\n    }\n  }\n\n  /**\n   * Disables all vertex attribute array indices enabled\n   */\n  disableVertexAttributeArray() {\n    for (\n      let i = 0, iMax = this._enabledVertexAttributeArray.length;\n      i < iMax;\n      ++i\n    ) {\n      const index = this._enabledVertexAttributeArray[i];\n      this.gl.disableVertexAttribArray(index);\n    }\n\n    this._enabledVertexAttributeArray = [];\n    this._willUseVertexAttributeArray = [];\n    this._vertexAttributeArrayDivisor.clear();\n  }\n\n  /**\n   * Flags an attribute array as going to be used. Any attribute array location\n   * no longer in use will be disabled when applyVertexAttributeArrays is called.\n   */\n  willUseVertexAttributeArray(index: number) {\n    // Flag the index as will be used\n    this._willUseVertexAttributeArray[index] = index;\n    // If already enabled we're done\n    if (this._enabledVertexAttributeArray[index] !== void 0) return;\n    // Flag the index as enabled\n    this._enabledVertexAttributeArray[index] = index;\n    // Otherwise, get this location enabled right away\n    this.gl.enableVertexAttribArray(index);\n  }\n\n  /**\n   * This enables the necessary vertex attribute arrays.\n   */\n  applyVertexAttributeArrays() {\n    // All locations that should be enabled are now enabled\n    // Disable any locations that will not be used\n    for (\n      let i = 0, iMax = this._enabledVertexAttributeArray.length;\n      i < iMax;\n      ++i\n    ) {\n      const index = this._enabledVertexAttributeArray[i];\n\n      if (index !== void 0) {\n        if (this._willUseVertexAttributeArray[index] !== void 0) return;\n        this.gl.disableVertexAttribArray(index);\n        delete this._enabledVertexAttributeArray[index];\n      }\n    }\n\n    // Reset the use array for next draw\n    this._willUseVertexAttributeArray = [];\n  }\n\n  /**\n   * Applies (if necessary) the divisor for a given array. This only works if the array location\n   * is enabled.\n   */\n  setVertexAttributeArrayDivisor(index: number, divisor: number) {\n    if (!this.extensions.instancing) return;\n\n    if (this._enabledVertexAttributeArray[index] !== undefined) {\n      if (this._vertexAttributeArrayDivisor.get(index) !== divisor) {\n        if (this.extensions.instancing instanceof WebGL2RenderingContext) {\n          this.extensions.instancing.vertexAttribDivisor(index, divisor);\n        } else {\n          this.extensions.instancing.vertexAttribDivisorANGLE(index, divisor);\n        }\n\n        this._vertexAttributeArrayDivisor.set(index, divisor);\n      }\n    }\n  }\n\n  /**\n   * This takes a texture and flags it's texture unit as freed if the texture has a used unit\n   */\n  freeTextureUnit(texture: Texture) {\n    if (texture.gl) {\n      if (texture.gl.textureUnit > -1) {\n        this._freeUnits.unshift(texture.gl.textureUnit);\n        texture.gl.textureUnit = -1;\n      }\n    }\n  }\n\n  /**\n   * Changes the active texture unit to the provided unit.\n   */\n  setActiveTextureUnit(unit: number) {\n    if (this._activeTextureUnit !== unit) {\n      this._activeTextureUnit = unit;\n      this.gl.activeTexture(unit);\n    }\n  }\n\n  /**\n   * Changes the gl clear color state\n   */\n  setClearColor(color: Vec4) {\n    if (!compare4(color, this._clearColor)) {\n      this._clearColor = copy4(color);\n      this.applyClearColor();\n    }\n  }\n\n  /**\n   * Change the drawBuffer state, if it's available\n   *\n   * 0 - n specifies COLOR_ATTACHMENT\n   * -1 specifies NONE\n   * -2 specifies BACK\n   */\n  setDrawBuffers(attachments: number[], preventCommit?: boolean) {\n    // See if a state change really is necessary\n    let different = attachments.length !== this._drawBuffers.length;\n\n    if (!different) {\n      for (let i = 0, iMax = attachments.length; i < iMax; ++i) {\n        if (this._drawBuffers[i] !== attachments[i]) {\n          different = true;\n          break;\n        }\n      }\n    }\n\n    if (!different) return;\n\n    if (this.glProxy.extensions.drawBuffers instanceof WebGL2RenderingContext) {\n      if (!preventCommit) {\n        this.glProxy.extensions.drawBuffers.drawBuffers(attachments);\n      }\n    } else if (this.glProxy.extensions.drawBuffers) {\n      if (!preventCommit) {\n        this.glProxy.extensions.drawBuffers.drawBuffersWEBGL(attachments);\n      }\n    } else {\n      console.warn(\n        \"Attempted to use drawBuffers for MRT, but MRT is NOT supported by this hardware. Use multiple render targets instead\"\n      );\n      return;\n    }\n\n    this._drawBuffers = attachments;\n  }\n\n  /**\n   * Sets the GPU proxy to be used to handle commands that call to the GPU but don't alter\n   * global GL state.\n   */\n  setProxy(proxy: GLProxy) {\n    this.glProxy = proxy;\n  }\n\n  /**\n   * Enables or disables the scissor test\n   */\n  setScissor(\n    bounds: { x: number; y: number; width: number; height: number } | null\n  ) {\n    if (bounds) {\n      if (!this._scissorTestEnabled) {\n        this._scissorTestEnabled = true;\n        this.gl.enable(this.gl.SCISSOR_TEST);\n      }\n\n      if (\n        bounds.x !== this._scissorBounds.x ||\n        bounds.y !== this._scissorBounds.y ||\n        bounds.width !== this._scissorBounds.width ||\n        bounds.height !== this._scissorBounds.height\n      ) {\n        this._scissorBounds = bounds;\n        this.applyScissorBounds();\n      }\n    } else {\n      if (this._scissorTestEnabled) {\n        this._scissorTestEnabled = false;\n        this.gl.disable(this.gl.SCISSOR_TEST);\n      }\n    }\n  }\n\n  /**\n   * Applies a viewport to the given state\n   */\n  setViewport(x: number, y: number, width: number, height: number) {\n    if (\n      x !== this._viewport.x ||\n      y !== this._viewport.y ||\n      width !== this._viewport.width ||\n      height !== this._viewport.height\n    ) {\n      this._viewport = { x, y, width, height };\n      this.applyViewport();\n    }\n  }\n\n  /**\n   * Uses the program indicated\n   */\n  useProgram(program: WebGLProgram) {\n    if (this._currentProgram !== program) {\n      this._currentProgram = program;\n      this.gl.useProgram(this._currentProgram);\n    }\n  }\n\n  /**\n   * Sets all current gl state to match the materials settings.\n   */\n  useMaterial(material: Material): UseMaterialStatus {\n    // Make sure the material is compiled\n    if (!material.gl) {\n      if (!this.glProxy.compileMaterial(material)) {\n        return UseMaterialStatus.INVALID;\n      }\n\n      if (!material.gl) {\n        return UseMaterialStatus.INVALID;\n      }\n    }\n\n    if (!material.gl.programId || material.gl.programId.length === 0) {\n      return UseMaterialStatus.INVALID;\n    }\n\n    // After determining we have a material that is capable of rendering, we now\n    // look to match the material's program to the current output target output\n    // types as best as possible\n    const programId = this.findMaterialProgram(material);\n\n    // Last check to make sure our process did find a program to run from the\n    // material.\n    if (programId === void 0) {\n      console.warn(\n        \"Could NOT determine a program for the given material that would appropriately match with the current RenderTarget\"\n      );\n      return UseMaterialStatus.NO_RENDER_TARGET_MATCHES;\n    }\n\n    // If we have a render target, we should set up a few elements such as draw\n    // buffer arrangement.\n    if (this._renderTarget) {\n      material.gl.programByTarget.set(this._renderTarget, programId);\n\n      // Next we check to see if multi render targets is enabled. If it is, we\n      // need to make sure our draw buffer state is set correctly.\n      if (this.glProxy.extensions.drawBuffers) {\n        // Look at each output the material is writing to. These outputs will be\n        // in the order of location[0] - location[n]\n        const fragOutputs = material.gl.outputsByProgram.get(programId);\n        const renderOutputs = this._renderTarget.getGLBuffers();\n\n        if (!fragOutputs || !renderOutputs) {\n          console.warn(\n            \"Could not establish the buffers to utilize for the render target\"\n          );\n          return UseMaterialStatus.NO_RENDER_TARGET_MATCHES;\n        }\n\n        const attachments: number[] = [];\n\n        // For each fragment output we must find the index of the corresponding\n        // target output\n        for (let i = 0, iMax = renderOutputs.length; i < iMax; ++i) {\n          const renderOutput = renderOutputs[i];\n          const target = fragOutputs.find(\n            output => renderOutput?.outputType === output\n          );\n\n          // The output type does not exist in the target outputs, thus we bind\n          // nothing. If a fragment has an output that does not exist, then no\n          // binding specification is needed (not even gl.NONE). If a render\n          // output exists, but the fragment has no output THEN we need a\n          // gl.NONE for that buffer.\n          if (target === void 0) {\n            attachments.push(this.gl.NONE);\n          }\n\n          // If our render target has specified the output target be disabled,\n          // then tell the buffer to render to nothing\n          else if (\n            this._renderTarget.disabledTargets.has(\n              renderOutput?.outputType || 0\n            )\n          ) {\n            attachments.push(this.gl.NONE);\n          }\n\n          // The output type exists so we use the index as the attachment\n          // location\n          else {\n            attachments.push(renderOutput?.attachment || this.gl.NONE);\n          }\n        }\n\n        // Apply our draw buffers in the appropriate manner.\n        this.setDrawBuffers(attachments);\n      }\n    }\n\n    // Use the material's program\n    this.useProgram(programId);\n    // Synchronize the material's settings to the gl state\n    this.syncMaterial(material);\n\n    return UseMaterialStatus.VALID;\n  }\n\n  /**\n   * This examines a given material to find the most appropriate program to run\n   * based on the current RenderTarget\n   */\n  private findMaterialProgram(material: Material): WebGLProgram | void {\n    if (!material.gl) return;\n\n    // If we are rendering to the screen, then the material should render it's\n    // COLOR output to the screen. We find the program that has the LEAST number\n    // of targets AND outputs a COLOR target.\n    if (!this._renderTarget || this._renderTarget.isColorTarget()) {\n      let programId: WebGLProgram | void;\n\n      // If the program is defined already, then we simply return that program as\n      // the program to use\n      if (this._renderTarget) {\n        programId = material.gl.programByTarget.get(this._renderTarget);\n        if (programId !== void 0) return programId;\n      }\n\n      let targetCount = Number.MAX_SAFE_INTEGER;\n\n      for (let i = 0, iMax = material.gl.programId.length; i < iMax; ++i) {\n        const program = material.gl.programId[i];\n        if (program.outputTypes.length < targetCount) {\n          if (program.outputTypes.indexOf(FragmentOutputType.COLOR) >= 0) {\n            programId = program.id;\n            targetCount = program.outputTypes.length;\n          }\n        }\n      }\n\n      // If no color output is found we just use the furthest out render target\n      if (!programId) {\n        programId = material.gl.programId[material.gl.programId.length - 1];\n      }\n\n      return programId;\n    }\n\n    // If the program is defined already, then we simply return that program as\n    // the program to use\n    let programId: WebGLProgram | void = material.gl.programByTarget.get(\n      this._renderTarget\n    );\n    if (programId !== void 0) return programId;\n\n    // If we have not determined the most appropriate program for the provided\n    // render target to material combination, then we need to analyze and figure\n    // that out. The best match will be a program that has the most output types\n    // that matches the current render target's output types.\n    const allOutputs = new Set<number>();\n    const buffers = this._renderTarget.getBuffers();\n\n    for (let i = 0, iMax = buffers.length; i < iMax; ++i) {\n      const buffer = buffers[i];\n      if (!buffer) continue;\n      allOutputs.add(buffer.outputType);\n    }\n\n    // With all of our render target's outputs established we now look through\n    // the material for the best match to the potential output. A best match\n    // will be material outputs closest to the number of outputs of the render\n    // target. If there are multiple material outputs that match the render\n    // target outputs, then the best match is the material with the least number\n    // of outputs.\n    let maxMatches = 0;\n    let pick: { id: WebGLProgram; outputTypes: number[] }[] = [];\n\n    for (let i = 0, iMax = material.gl.programId.length; i < iMax; ++i) {\n      const fragment = material.gl.programId[i];\n      let matchCount = 0;\n\n      for (let k = 0, kMax = fragment.outputTypes.length; k < kMax; ++k) {\n        const outputType = fragment.outputTypes[k];\n        if (allOutputs.has(outputType)) matchCount++;\n      }\n\n      if (matchCount > maxMatches) {\n        maxMatches = matchCount;\n        pick = [fragment];\n      } else if (matchCount === maxMatches) {\n        pick.push(fragment);\n      }\n    }\n\n    if (pick.length === 0) return;\n    else if (pick.length === 1) programId = pick[0].id;\n    else if (pick.length > 1) {\n      programId = pick.reduce((p, n) =>\n        n.outputTypes.length < p.outputTypes.length ? n : p\n      );\n    }\n\n    return programId;\n  }\n\n  /**\n   * Sets all current gl state to match the render target specified\n   */\n  useRenderTarget(target: RenderTarget | null) {\n    if (!target) {\n      this.bindFBO(null);\n      this._renderTarget = null;\n      return true;\n    }\n\n    // The gl context must be specified for the target in order to use it\n    if (!target.gl) return false;\n    // Bind the FBO of the target as the current item we are rendering into\n    this.bindFBO(target.gl.fboId);\n    // Set the render target as our current render target that we are outputting\n    // to.\n    this._renderTarget = target;\n\n    return true;\n  }\n\n  /**\n   * This syncs the state of the GL context with the requested state of a\n   * material\n   */\n  syncMaterial(material: Material) {\n    const gl = this.gl;\n    const depthWrite = Boolean(material.depthWrite);\n\n    // Depth mode changes\n    if (this._depthMask !== depthWrite) {\n      this._depthMask = depthWrite;\n      gl.depthMask(this._depthMask);\n    }\n\n    if (this._depthTestEnabled !== material.depthTest) {\n      this._depthTestEnabled = material.depthTest;\n      this._depthTestEnabled\n        ? gl.enable(gl.DEPTH_TEST)\n        : gl.disable(gl.DEPTH_TEST);\n    }\n\n    if (this._depthFunc !== material.depthFunc) {\n      this._depthFunc = material.depthFunc;\n      this.applyDepthFunc();\n    }\n\n    // Blending changes\n    if (material.blending) {\n      if (!this._blendingEnabled) {\n        gl.enable(gl.BLEND);\n        this._blendingEnabled = true;\n      }\n\n      if (\n        this._blendDstFactor !== material.blending.blendDst ||\n        this._blendSrcFactor !== material.blending.blendSrc ||\n        this._blendEquation !== material.blending.blendEquation\n      ) {\n        this._blendDstFactor =\n          material.blending.blendDst || this._blendDstFactor;\n        this._blendSrcFactor =\n          material.blending.blendSrc || this._blendSrcFactor;\n        this._blendEquation =\n          material.blending.blendEquation || this._blendEquation;\n        this.applyBlendFactors();\n      }\n    } else {\n      if (this._blendingEnabled) {\n        gl.disable(gl.BLEND);\n        this._blendingEnabled = false;\n      }\n    }\n\n    // Cull mode\n    if (this._cullFace !== material.culling) {\n      this._cullFace = material.culling;\n      this.applyCullFace();\n    }\n\n    // Color mode\n    if (\n      this._colorMask[0] !== material.colorWrite[0] ||\n      this._colorMask[1] !== material.colorWrite[1] ||\n      this._colorMask[2] !== material.colorWrite[2] ||\n      this._colorMask[3] !== material.colorWrite[3]\n    ) {\n      this._colorMask = material.colorWrite;\n      this.applyColorMask();\n    }\n\n    // Dithering\n    if (this._ditheringEnabled !== material.dithering) {\n      this._ditheringEnabled = material.dithering;\n      this._ditheringEnabled ? gl.enable(gl.DITHER) : gl.disable(gl.DITHER);\n    }\n\n    // Uniforms\n    this._currentUniforms = material.uniforms;\n\n    if (!this._currentProgram) {\n      return false;\n    }\n\n    // Now we can update and retrieve the locations for each uniform in the program\n    Object.entries(material.uniforms).forEach(([name, uniform]) => {\n      if (!this._currentProgram) return;\n      if (!uniform.gl) uniform.gl = new Map();\n      let glSettings = uniform.gl.get(this._currentProgram);\n\n      // If no settings for the given program are present, then we must\n      // query the program for the uniform's locations and what not.\n      if (!glSettings) {\n        const location = this.gl.getUniformLocation(this._currentProgram, name);\n\n        if (!location) {\n          glSettings = {\n            location: void 0\n          };\n\n          debug(\n            this.debugContext,\n            `A Material specified a uniform ${name}, but none was found in the current program.`\n          );\n\n          return;\n        }\n\n        glSettings = {\n          location\n        };\n\n        // Store the found location for the uniform\n        uniform.gl.set(this._currentProgram, glSettings);\n      }\n\n      // After locations for the uniforms are established, we must now copy the\n      // uniform info into the GPU\n      if (glSettings.location) this.uploadUniform(glSettings.location, uniform);\n    });\n\n    // Textures\n    if (this._textureWillBeUsed.size > 0) {\n      if (!this.applyUsedTextures()) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Performs the upload operation of a uniform to the GL context\n   */\n  private uploadUniform(\n    location: WebGLUniformLocation,\n    uniform: IMaterialUniform<MaterialUniformType>\n  ) {\n    let v;\n\n    switch (uniform.type) {\n      case MaterialUniformType.FLOAT:\n        v = uniform.value as MaterialUniformValue<MaterialUniformType.FLOAT>;\n        this.gl.uniform1f(location, v);\n        break;\n\n      case MaterialUniformType.VEC2:\n        v = uniform.value as MaterialUniformValue<MaterialUniformType.VEC2>;\n        this.gl.uniform2f(location, v[0], v[1]);\n        break;\n\n      case MaterialUniformType.VEC3:\n        v = uniform.value as MaterialUniformValue<MaterialUniformType.VEC3>;\n        this.gl.uniform3f(location, v[0], v[1], v[2]);\n        break;\n\n      case MaterialUniformType.VEC4:\n        v = uniform.value as MaterialUniformValue<MaterialUniformType.VEC4>;\n        this.gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n        break;\n\n      case MaterialUniformType.VEC4_ARRAY:\n        v = uniform.value as MaterialUniformValue<\n          MaterialUniformType.VEC4_ARRAY\n        >;\n        this.gl.uniform4fv(location, flatten4(v));\n        break;\n\n      case MaterialUniformType.MATRIX3x3:\n        v = uniform.value as MaterialUniformValue<\n          MaterialUniformType.MATRIX3x3\n        >;\n        this.gl.uniformMatrix3fv(location, false, v);\n        break;\n\n      case MaterialUniformType.MATRIX4x4:\n        v = uniform.value as MaterialUniformValue<\n          MaterialUniformType.MATRIX4x4\n        >;\n        this.gl.uniformMatrix4fv(location, false, v);\n        break;\n\n      case MaterialUniformType.FLOAT_ARRAY:\n        v = uniform.value as MaterialUniformValue<\n          MaterialUniformType.FLOAT_ARRAY\n        >;\n        this.gl.uniform1fv(location, v);\n        break;\n\n      case MaterialUniformType.TEXTURE:\n        v = uniform.value as MaterialUniformValue<MaterialUniformType.TEXTURE>;\n        this.willUseTextureUnit(v, location);\n        break;\n\n      default:\n        console.warn(\n          this.debugContext,\n          \"A uniform specified an unrecognized type. It will not sync with the GPU:\",\n          uniform\n        );\n    }\n  }\n\n  /**\n   * This will consume the values aggregated within willUseTextureUnit. All Texture objects\n   * consumed will be assigned an active texture unit (if one was not already applied), then\n   * the Texture will be compiled / updated as necessary and applied to all uniforms requiring\n   * a Sampler unit.\n   */\n  applyUsedTextures() {\n    // Assign texture units to the textures that will be used\n    const failedTextures = this.assignTextureUnits(\n      Array.from(this._textureWillBeUsed.keys())\n    );\n\n    // We apply the default unit to each texture that failed. Output will be made from the\n    // previous method, so at this point, let's just try to make lemonade out of lemons (set\n    // sane defaults)\n    failedTextures.forEach(texture => {\n      if (texture.gl) {\n        texture.gl.textureUnit = this.gl.TEXTURE0;\n      } else {\n        texture.gl = {\n          textureId: null,\n          textureUnit: this.gl.TEXTURE0,\n          proxy: this.glProxy\n        };\n      }\n    });\n\n    // Let's sort out which textures are affiliated with a RenderTarget or with a uniform set.\n    const textureToUniforms = new Map<Texture, Set<WebGLUniformLocation>>();\n    const renderTargets = new Set<RenderTarget>();\n\n    this._textureWillBeUsed.forEach((targets, texture) => {\n      if (targets instanceof RenderTarget) {\n        renderTargets.add(targets);\n      } else {\n        textureToUniforms.set(texture, targets);\n      }\n    });\n\n    // Now our list of render targets is guaranteed to have their textures set with an active texture unit,\n    // so we can now officially ensure the render target is compiled.\n    renderTargets.forEach(target => {\n      const textures = target.getTextures();\n      const failed = textures.some(texture => {\n        // Only compile and process successful texture units\n        if (failedTextures.indexOf(texture) < 0) {\n          this.glProxy.updateTexture(texture);\n        } else return true;\n\n        return false;\n      });\n\n      if (!failed) {\n        this.glProxy.compileRenderTarget(target);\n      } else {\n        console.warn(\n          this.debugContext,\n          \"A RenderTarget can not be used because all of it's textures could not be compiled.\"\n        );\n      }\n    });\n\n    // Now that all of our textures have units, we loop through each texture and have them\n    // compiled and/or updated then upload the unit to the appropriate uniforms indicated.\n    textureToUniforms.forEach((uniforms, texture) => {\n      // Only compile and process successful texture units\n      if (failedTextures.indexOf(texture) < 0) {\n        this.glProxy.updateTexture(texture);\n\n        uniforms.forEach(uniform => {\n          this.uploadTextureToUniform(uniform, texture);\n        });\n      }\n\n      // Failed textures get their uniforms filled with the default 0 texture unit\n      else {\n        uniforms.forEach(uniform => {\n          this.gl.uniform1i(uniform, textureUnitToIndex(this.gl, 0));\n        });\n      }\n    });\n\n    // We used the textures! This is no longer needed\n    this._textureWillBeUsed.clear();\n\n    return true;\n  }\n\n  /**\n   * Attempts to assign free or freed texture units to the provided texture objects.\n   * This will return a list of textures\n   */\n  private assignTextureUnits(textures: Texture[]) {\n    const needsUnit: Texture[] = [];\n    const hasUnit: Texture[] = [];\n\n    // First establish all textures that need a unit\n    textures.forEach(texture => {\n      if (!texture.gl || texture.gl.textureUnit < 0) {\n        needsUnit.push(texture);\n      } else {\n        hasUnit.push(texture);\n      }\n    });\n\n    // We now first see if we have free units to statisfy the needs\n    while (this._freeUnits.length > 0 && needsUnit.length > 0) {\n      const texture = needsUnit.shift();\n      if (!texture) continue;\n\n      const freeUnit = this._freeUnits.shift();\n\n      if (freeUnit === undefined) {\n        needsUnit.unshift(texture);\n        continue;\n      }\n\n      if (!texture.gl) {\n        texture.gl = {\n          textureId: null,\n          textureUnit: freeUnit,\n          proxy: this.glProxy\n        };\n      } else {\n        texture.gl.textureUnit = freeUnit;\n      }\n\n      hasUnit.push(texture);\n    }\n\n    // If nothing needs a unit still, then we can just exit now\n    if (needsUnit.length <= 0) {\n      return needsUnit;\n    }\n\n    // We now get any remaining texture that still needs a unit. We will claim the unit\n    // of a texture using a unit but is NOT going to be used for the next call.\n    // If there are no units available in this manner, then we are officially using too many\n    // textures for the next draw call.\n    debug(\n      \"WARNING: Too many textures in use are causing texture units to be swapped. Doing this occasionally is fine, but handling this on a frame loop can have serious performance concerns.\"\n    );\n\n    // Get a list of texture units in use but are not required for next draw call\n    const inUse = new Map<Texture, boolean>();\n\n    this._textureUnitToTexture.forEach(texture => {\n      if (texture) {\n        inUse.set(texture, false);\n      }\n    });\n\n    hasUnit.forEach(texture => {\n      inUse.set(texture, true);\n    });\n\n    const canGiveUpUnit: Texture[] = [];\n\n    inUse.forEach((isUsed, texture) => {\n      if (!isUsed) canGiveUpUnit.push(texture);\n    });\n\n    // We should now have all textures able to give up their unit for the next draw call\n    if (canGiveUpUnit.length === 0) {\n      console.warn(\n        this.debugContext,\n        \"There are too many textures being used for a single draw call. These textures will not be utilized on the GPU\",\n        needsUnit\n      );\n      console.warn(\"Current GL State:\", this);\n      return needsUnit;\n    }\n\n    while (canGiveUpUnit.length > 0 && needsUnit.length > 0) {\n      const texture = needsUnit.shift();\n      if (!texture) continue;\n\n      const freeUnit = canGiveUpUnit.shift();\n\n      if (\n        freeUnit === undefined ||\n        !freeUnit.gl ||\n        freeUnit.gl.textureUnit < 0\n      ) {\n        needsUnit.unshift(texture);\n        continue;\n      }\n\n      if (!texture.gl) {\n        texture.gl = {\n          textureId: null,\n          textureUnit: freeUnit.gl.textureUnit,\n          proxy: this.glProxy\n        };\n      } else {\n        texture.gl.textureUnit = freeUnit.gl.textureUnit;\n      }\n\n      hasUnit.push(texture);\n    }\n\n    // If by some voodoo we still have not provided a unit for a texture needing it, then we have a problem\n    if (needsUnit.length > 0) {\n      console.error(\n        this.debugContext,\n        \"There are too many textures being used for a single draw call. These textures will not be utilized on the GPU\",\n        needsUnit\n      );\n      console.warn(\"Current GL State:\", this);\n    }\n\n    return needsUnit;\n  }\n\n  /**\n   * Applies the necessary value for a texture to be applied to a sampler uniform.\n   */\n  private uploadTextureToUniform(\n    location: WebGLUniformLocation,\n    texture: Texture\n  ) {\n    if (texture.gl && texture.gl.textureUnit >= 0) {\n      this.gl.uniform1i(\n        location,\n        textureUnitToIndex(this.gl, texture.gl.textureUnit)\n      );\n    } else {\n      console.warn(\n        this.debugContext,\n        \"Attempted to set a Texture Object to a uniform, but the Texture object did not have a valid texture unit.\",\n        texture\n      );\n    }\n  }\n\n  /**\n   * This flags a texture as going to be used within the next upcoming draw call\n   */\n  willUseTextureUnit(\n    texture: Texture,\n    target: WebGLUniformLocation | RenderTarget\n  ) {\n    const uniforms = this._textureWillBeUsed.get(texture);\n\n    if (target instanceof RenderTarget) {\n      if (!uniforms) {\n        this._textureWillBeUsed.set(texture, target);\n      } else if (uniforms instanceof RenderTarget) {\n        if (uniforms !== target) {\n          console.warn(\n            this.debugContext,\n            \"A Texture is attempting to be used by two different render targets in a single draw.\"\n          );\n        }\n      }\n    } else {\n      if (!uniforms) {\n        this._textureWillBeUsed.set(texture, new Set([target]));\n      } else {\n        if (uniforms instanceof RenderTarget) {\n          console.warn(\n            this.debugContext,\n            \"A texture in a single draw is attempting to attach to a uniform AND a render target which is invalid.\"\n          );\n        } else {\n          uniforms.add(target);\n        }\n      }\n    }\n  }\n\n  /**\n   * This method applies ALL of the state elements monitored and force sets them with WebGL calls\n   * to make sure the GPU is in the same state as this state object.\n   */\n  syncState() {\n    const gl = this.gl;\n\n    this._blendingEnabled ? gl.enable(gl.BLEND) : gl.disable(gl.BLEND);\n    this._ditheringEnabled ? gl.enable(gl.DITHER) : gl.disable(gl.DITHER);\n    this._depthTestEnabled\n      ? gl.enable(gl.DEPTH_TEST)\n      : gl.disable(gl.DEPTH_TEST);\n    this._scissorTestEnabled\n      ? gl.enable(gl.SCISSOR_TEST)\n      : gl.disable(gl.SCISSOR_TEST);\n    this.setActiveTextureUnit(this._activeTextureUnit);\n    this.applyClearColor();\n    this.applyCullFace();\n    this.applyBlendFactors();\n    this.applyBlendEquation();\n    this.applyColorMask();\n    this.applyDepthFunc();\n    this.applyScissorBounds();\n    this.applyViewport();\n    gl.depthMask(this._depthMask);\n  }\n\n  /**\n   * Applies the current clearColor to the gl state\n   */\n  private applyClearColor() {\n    const gl = this.gl;\n\n    gl.clearColor(\n      this._clearColor[0],\n      this._clearColor[1],\n      this._clearColor[2],\n      this._clearColor[3]\n    );\n  }\n\n  /**\n   * Applies the current depth function to the gl state\n   */\n  private applyDepthFunc() {\n    const gl = this.gl;\n\n    switch (this._depthFunc) {\n      case GLSettings.Material.DepthFunctions.ALWAYS:\n        gl.depthFunc(gl.ALWAYS);\n        break;\n      case GLSettings.Material.DepthFunctions.EQUAL:\n        gl.depthFunc(gl.EQUAL);\n        break;\n      case GLSettings.Material.DepthFunctions.GREATER:\n        gl.depthFunc(gl.GREATER);\n        break;\n      case GLSettings.Material.DepthFunctions.GREATER_OR_EQUAL:\n        gl.depthFunc(gl.GEQUAL);\n        break;\n      case GLSettings.Material.DepthFunctions.LESS:\n        gl.depthFunc(gl.LESS);\n        break;\n      case GLSettings.Material.DepthFunctions.LESS_OR_EQUAL:\n        gl.depthFunc(gl.LEQUAL);\n        break;\n      case GLSettings.Material.DepthFunctions.NEVER:\n        gl.depthFunc(gl.NEVER);\n        break;\n      case GLSettings.Material.DepthFunctions.NOTEQUAL:\n        gl.depthFunc(gl.NOTEQUAL);\n        break;\n\n      default:\n        gl.depthFunc(gl.ALWAYS);\n        break;\n    }\n  }\n\n  /**\n   * Applies the current scissor bounds to the gl state\n   */\n  private applyScissorBounds() {\n    this.gl.scissor(\n      this._scissorBounds.x,\n      this._scissorBounds.y,\n      this._scissorBounds.width,\n      this._scissorBounds.height\n    );\n  }\n\n  /**\n   * Applies the writing mask to the color buffer to the gl state.\n   */\n  private applyColorMask() {\n    this.gl.colorMask(\n      this.colorMask[0] || false,\n      this.colorMask[1] || false,\n      this.colorMask[2] || false,\n      this.colorMask[3] || false\n    );\n  }\n\n  /**\n   * Applies the blending equations to the gl state\n   */\n  private applyBlendEquation() {\n    const gl = this.gl;\n\n    switch (this._blendEquation) {\n      case GLSettings.Material.BlendingEquations.Add:\n        gl.blendEquation(gl.FUNC_ADD);\n        break;\n      case GLSettings.Material.BlendingEquations.Subtract:\n        gl.blendEquation(gl.FUNC_SUBTRACT);\n        break;\n      case GLSettings.Material.BlendingEquations.ReverseSubtract:\n        gl.blendEquation(gl.FUNC_REVERSE_SUBTRACT);\n        break;\n      // case GLSettings.Material.BlendingEquations.Min: /** Requires extension for Webgl 1 */ break;\n      // case GLSettings.Material.BlendingEquations.Max: /** Requires extension for Webgl 1 */ break;\n    }\n  }\n\n  /**\n   * Applies the blending factors to the gl state\n   */\n  private applyBlendFactors() {\n    const gl = this.gl;\n    let dst, src;\n\n    switch (this._blendDstFactor) {\n      case GLSettings.Material.BlendingDstFactor.DstAlpha:\n        dst = gl.BLEND_DST_ALPHA;\n        break;\n      case GLSettings.Material.BlendingDstFactor.DstColor:\n        dst = gl.BLEND_DST_RGB;\n        break;\n      case GLSettings.Material.BlendingDstFactor.One:\n        dst = gl.ONE;\n        break;\n      case GLSettings.Material.BlendingDstFactor.OneMinusDstAlpha:\n        dst = gl.ONE_MINUS_DST_ALPHA;\n        break;\n      case GLSettings.Material.BlendingDstFactor.OneMinusDstColor:\n        dst = gl.ONE_MINUS_DST_COLOR;\n        break;\n      case GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha:\n        dst = gl.ONE_MINUS_SRC_ALPHA;\n        break;\n      case GLSettings.Material.BlendingDstFactor.OneMinusSrcColor:\n        dst = gl.ONE_MINUS_SRC_COLOR;\n        break;\n      case GLSettings.Material.BlendingDstFactor.SrcAlpha:\n        dst = gl.SRC_ALPHA;\n        break;\n      case GLSettings.Material.BlendingDstFactor.SrcColor:\n        dst = gl.SRC_COLOR;\n        break;\n      case GLSettings.Material.BlendingDstFactor.Zero:\n        dst = gl.ZERO;\n        break;\n\n      default:\n        dst = gl.ONE;\n        break;\n    }\n\n    switch (this._blendSrcFactor) {\n      case GLSettings.Material.BlendingDstFactor.DstAlpha:\n        src = gl.BLEND_DST_ALPHA;\n        break;\n      case GLSettings.Material.BlendingDstFactor.DstColor:\n        src = gl.BLEND_DST_RGB;\n        break;\n      case GLSettings.Material.BlendingDstFactor.One:\n        src = gl.ONE;\n        break;\n      case GLSettings.Material.BlendingDstFactor.OneMinusDstAlpha:\n        src = gl.ONE_MINUS_DST_ALPHA;\n        break;\n      case GLSettings.Material.BlendingDstFactor.OneMinusDstColor:\n        src = gl.ONE_MINUS_DST_COLOR;\n        break;\n      case GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha:\n        src = gl.ONE_MINUS_SRC_ALPHA;\n        break;\n      case GLSettings.Material.BlendingDstFactor.OneMinusSrcColor:\n        src = gl.ONE_MINUS_SRC_COLOR;\n        break;\n      case GLSettings.Material.BlendingDstFactor.SrcAlpha:\n        src = gl.SRC_ALPHA;\n        break;\n      case GLSettings.Material.BlendingDstFactor.SrcColor:\n        src = gl.SRC_COLOR;\n        break;\n      case GLSettings.Material.BlendingDstFactor.Zero:\n        src = gl.ZERO;\n        break;\n      case GLSettings.Material.BlendingSrcFactor.SrcAlphaSaturate:\n        src = gl.SRC_ALPHA_SATURATE;\n        break;\n\n      default:\n        src = gl.ONE;\n        break;\n    }\n\n    gl.blendFunc(src, dst);\n  }\n\n  /**\n   * Applies the cull face property to the gl state\n   */\n  private applyCullFace() {\n    const gl = this.gl;\n\n    if (this._cullFace !== GLSettings.Material.CullSide.NONE) {\n      gl.enable(gl.CULL_FACE);\n    }\n\n    switch (this._cullFace) {\n      case GLSettings.Material.CullSide.CW:\n        gl.frontFace(gl.CW);\n        gl.cullFace(gl.FRONT);\n        break;\n      case GLSettings.Material.CullSide.CCW:\n        gl.frontFace(gl.CCW);\n        gl.cullFace(gl.FRONT);\n        break;\n      case GLSettings.Material.CullSide.BOTH:\n        gl.frontFace(gl.CW);\n        gl.cullFace(gl.FRONT_AND_BACK);\n        break;\n\n      default:\n        gl.disable(gl.CULL_FACE);\n    }\n  }\n\n  /**\n   * This applies the current viewport property to the gl context\n   */\n  private applyViewport() {\n    this.gl.viewport(\n      this._viewport.x,\n      this._viewport.y,\n      this._viewport.width,\n      this._viewport.height\n    );\n  }\n}\n","import { Model } from \"./model\";\n\n/**\n * This is an object that contains a list of buffers and state for those buffers to\n * be rendered together.\n */\nexport class Scene {\n  /** The models this scene will render. They will be rendered in the order they were insertted */\n  models = new Set<Model>();\n\n  /**\n   * Add a model to be rendered within the scene\n   */\n  add(model: Model) {\n    this.models.add(model);\n  }\n\n  /**\n   * Remove a model from the scene\n   */\n  remove(model: Model) {\n    this.models.delete(model);\n  }\n}\n","import { Vec4 } from \"../math\";\nimport { Size } from \"../types\";\nimport { Attribute } from \"./attribute\";\nimport { Geometry } from \"./geometry\";\nimport { GLProxy } from \"./gl-proxy\";\nimport { GLState } from \"./gl-state\";\nimport { Model } from \"./model\";\nimport { RenderTarget } from \"./render-target\";\nimport { Scene } from \"./scene\";\nimport { UseMaterialStatus } from \"./types\";\nimport { WebGLStat } from \"./webgl-stat\";\n\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * Options used to create or update the renderer.\n */\nexport interface IWebGLRendererOptions {\n  /**\n   * Determines if the rendering context renders to a buffer with an alpha channel.\n   * Performs better if no alpha channel is used, but may be needed if any DOM elements or\n   * backgrounds needs to bleed through the canvas.\n   */\n  alpha?: boolean;\n  /**\n   * Set to true to use the system antialiasing set up. Performs much better when false, but definitely\n   * looks better when true.\n   */\n  antialias?: boolean;\n  /**\n   * This is the canvas that is required to retrieve the webgl context to make all webgl calls with.\n   */\n  canvas: HTMLCanvasElement;\n  /**\n   * This needs to be true in order to query the canvas current rendered output. Performs better when false,\n   * but some cases may need it to do such operations like snapshots etc.\n   */\n  preserveDrawingBuffer?: boolean;\n  /**\n   * Set to true to make the default context expect premultipled alpha for blending.\n   */\n  premultipliedAlpha?: boolean;\n\n  /**\n   * Callback indicating a context could not be generated.\n   */\n  onNoContext?(): void;\n}\n\n/**\n * Internal state of the renderer.\n */\nexport interface IWebGLRendererState {\n  /** Sets up a clear mask to ensure the clear operation only happens once per draw */\n  clearMask: [boolean, boolean, boolean];\n  /** Stores which render target is in focus for the current operations on the renderer */\n  currentRenderTarget: RenderTarget | RenderTarget[] | null;\n  /** The current display size of the canvas */\n  displaySize: Size;\n  /** The current pixel ratio in use */\n  pixelRatio: number;\n  /** The current rendering size of the canvas */\n  renderSize: Size;\n}\n\n/**\n * This is the primary file where the rendering and compositing resources and managing\n * gl state happens. A context is provided for the renderer to work with, then it is the\n * renderer's job to ensure state changes as expected and provide as much convenience as necessary\n * to make working with the webgl pipeline as easy as possible.\n */\nexport class WebGLRenderer {\n  /** When this is set this creates */\n  set debugContext(val: string) {\n    if (this.glProxy) this.glProxy.debugContext = val;\n    if (this.glState) this.glState.debugContext = val;\n  }\n\n  /** The context the renderer is managing */\n  private _gl?: WebGLRenderingContext;\n  /** The readonly gl context the renderer determined for use */\n  get gl() {\n    return this._gl;\n  }\n  /**\n   * This is the compiler that performs all actions related to creating and\n   * updating buffers and objects on the GPU\n   */\n  glProxy: GLProxy;\n  /** This handles anything related to state changes in the GL state */\n  glState: GLState;\n  /** The options that constructed or are currently applied to the renderer */\n  options: IWebGLRendererOptions;\n\n  /** Any current internal state the renderer has applied to it's target */\n  state: IWebGLRendererState = {\n    clearMask: [false, false, false],\n    currentRenderTarget: null,\n    displaySize: [1, 1],\n    pixelRatio: 1,\n    renderSize: [1, 1]\n  };\n\n  constructor(options: IWebGLRendererOptions) {\n    // Assign defaults to our options\n    this.options = Object.assign(\n      {\n        alpha: false,\n        antialias: false,\n        preserveDrawingBuffer: false\n      },\n      options\n    );\n\n    // Make sure we are provided a canvas to work with\n    if (!this.options.canvas) {\n      console.warn(\"WebGLRenderer ERROR: A canvas is REQUIRED as a parameter.\");\n    }\n\n    // Initialize context for the renderer\n    this.getContext();\n  }\n\n  /**\n   * Clears the specified buffers.\n   */\n  clear(color?: boolean, depth?: boolean, stencil?: boolean) {\n    const clear = this.state.clearMask;\n\n    this.state.clearMask = [\n      clear[0] || color || false,\n      clear[1] || depth || false,\n      clear[2] || stencil || false\n    ];\n  }\n\n  /**\n   * Clears the color either set with setClearColor, or clears the color\n   * specified.\n   */\n  clearColor(color?: Vec4) {\n    if (color) {\n      this.glState.setClearColor(color);\n    }\n  }\n\n  /**\n   * Free all resources this renderer utilized. Make sure textures and\n   * frame/render/geometry buffers are all deleted. We may even use aggressive\n   * buffer removal that force resizes the buffers so their resources are\n   * immediately reduced instead of waiting for the JS engine to free up\n   * resources.\n   */\n  dispose() {\n    // TODO\n  }\n\n  /**\n   * Retrieve and establish the context from the canvas.\n   */\n  getContext() {\n    if (this._gl) return this._gl;\n\n    const gl = GLProxy.getContext(this.options.canvas, {\n      alpha: this.options.alpha || false,\n      antialias: this.options.antialias || false,\n      premultipliedAlpha: this.options.premultipliedAlpha || false,\n      preserveDrawingBuffer: this.options.preserveDrawingBuffer || false\n    });\n\n    if (gl.context) {\n      this._gl = gl.context;\n      this.glState = new GLState(gl.context, gl.extensions);\n      this.glProxy = new GLProxy(gl.context, this.glState, gl.extensions);\n      this.glState.setProxy(this.glProxy);\n\n      // Make sure our GPU is synced with our default state\n      this.glState.syncState();\n    } else if (this.options.onNoContext) {\n      this.options.onNoContext();\n    } else {\n      console.warn(\n        \"No context was able to be produced, and the handler onNoContext was not implemented for such cases.\"\n      );\n    }\n\n    return this._gl;\n  }\n\n  /**\n   * Retrieves the size of the canvas ignoring pixel ratio.\n   */\n  getDisplaySize(): Size {\n    return this.state.displaySize;\n  }\n\n  /**\n   * Retrieves the current pixel ratio in use for the context.\n   */\n  getPixelRatio() {\n    return this.state.pixelRatio;\n  }\n\n  /**\n   * Retrieves the size of the rendering context. This is the pixel dimensions\n   * of what is being rendered into.\n   */\n  getRenderSize(): Size {\n    return this.state.renderSize;\n  }\n\n  /**\n   * Returns the full viewport for the current target.\n   *\n   * If a RenderTarget is not set, then this returns the viewport of the canvas\n   * ignoring the current pixel ratio.\n   */\n  getFullViewport() {\n    const target = this.state.currentRenderTarget;\n\n    // Multiple render targets MUST have the same dimensions so it's valid to\n    // use a single target.\n    if (Array.isArray(target)) {\n      return {\n        x: 0,\n        y: 0,\n        width: target[0].width,\n        height: target[0].height\n      };\n    } else if (target) {\n      return {\n        x: 0,\n        y: 0,\n        width: target.width,\n        height: target.height\n      };\n    } else {\n      const size = this.getRenderSize();\n\n      return {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      };\n    }\n  }\n\n  /**\n   * Prepares the specified attribute\n   */\n  prepareAttribute(geometry: Geometry, attribute: Attribute, name: string) {\n    // If we successfully update/compile the attribute, then we enable it's\n    // vertex array\n    if (this.glProxy.updateAttribute(attribute)) {\n      // If our geometry has a vao, we do not need to set the state of the\n      // attribute every time we prepare for a draw call.\n      if (!geometry.gl || !geometry.gl.vao) {\n        this.glProxy.useAttribute(name, attribute, geometry);\n      }\n    }\n\n    // Otherwise, we flag this as invalid geometry so we don't cause errors or\n    // undefined behavior while rendering\n    else {\n      console.warn(\"Could not update attribute\", attribute);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Renders the Scene specified\n   */\n  render(scene: Scene, target: RenderTarget | RenderTarget[] | null = null) {\n    // Context must be established to render\n    if (!this.gl) return;\n    // Establish the rendering output we are going to use\n    this.setRenderTarget(target);\n    // We'll remove any models that have errored from the scene\n    const toRemove: Model[] = [];\n\n    // We must analyze the render target for MRT so we can set ALL of the\n    // buffers for the draw buffers so they will be cleared by the clear command\n    if (\n      target &&\n      !Array.isArray(target) &&\n      (WebGLStat.MRT || WebGLStat.MRT_EXTENSION)\n    ) {\n      const buffers = target.getGLBuffers();\n      this.glState.setDrawBuffers(\n        buffers.map(buffer => buffer?.attachment || 0)\n      );\n    }\n\n    // After the draw buffer state has been set we can now clear the selection\n    // Apply the last clear mask provided for the render\n    const clear = this.state.clearMask;\n    if (clear[0] || clear[1] || clear[2]) {\n      this.glProxy.clear(clear[0], clear[1], clear[2]);\n      this.state.clearMask = [false, false, false];\n    }\n\n    // With multiple render targets we have to render the whole scene per target\n    if (Array.isArray(target)) {\n      for (let i = 0, iMax = target.length; i < iMax; ++i) {\n        const renderTarget = target[i];\n        this.glState.useRenderTarget(renderTarget);\n\n        // If the fbo is not ready, we're not drawing\n        if (renderTarget && !renderTarget.gl) {\n          return;\n        }\n\n        // Loop through all of the models of the scene and process them for\n        // rendering\n        scene.models.forEach((model: Model) => {\n          this.renderModel(model, toRemove);\n        });\n      }\n    }\n\n    // Single render target, we render the scene a single time (even if there\n    // are multiple buffers, it will just enable MRT based on the material in\n    // use)\n    else {\n      // If the fbo is not ready, we're not drawing\n      if (target && !target.gl) {\n        return;\n      }\n\n      // Loop through all of the models of the scene and process them for\n      // rendering\n      scene.models.forEach((model: Model) => {\n        this.renderModel(model, toRemove);\n      });\n    }\n\n    // Clear out any failed models from the scene\n    toRemove.forEach(model => {\n      scene.remove(model);\n    });\n  }\n\n  /**\n   * Renders the specified model\n   */\n  private renderModel(model: Model, toRemove: Model[]) {\n    const geometry = model.geometry;\n    const material = model.material;\n\n    // Specify we want a new material state to be in effect\n    const materialStatus = this.glState.useMaterial(material);\n\n    // Let's put the material's program in use first so we can have the\n    // attribute information available to us.\n    switch (materialStatus) {\n      case UseMaterialStatus.VALID: {\n        this.glProxy.compileGeometry(geometry);\n        let geometryIsValid = true;\n\n        // Faster to use defined functions rather than closures for loops\n        const attributeLoop = (attribute: Attribute, name: string) => {\n          geometryIsValid =\n            this.prepareAttribute(geometry, attribute, name) && geometryIsValid;\n        };\n\n        // First update/compile all aspects of the geometry\n        geometry.attributes.forEach(attributeLoop);\n\n        // If the geometry has a VAO then we just bind it and our geometry is\n        // ready to go\n        if (geometry.gl?.vao) {\n          this.glState.bindVAO(geometry.gl.vao);\n        } else {\n          // Now all of our attributes are established, we must make sure our vertex\n          // arrays are cleaned up\n          this.glState.applyVertexAttributeArrays();\n        }\n\n        // If all of the attribute updates passed correctly, then we can use the\n        // established state to make our draw call\n        if (geometryIsValid) {\n          this.glProxy.draw(model);\n        } else {\n          console.warn(\n            \"Geometry was unable to update correctly, thus we are skipping the drawing of\",\n            model\n          );\n\n          toRemove.push(model);\n        }\n\n        // As good practice, stop using the VAO when it's done being used\n        this.glState.bindVAO(null);\n        break;\n      }\n\n      case UseMaterialStatus.INVALID: {\n        console.warn(\n          \"Could not utilize material. Skipping draw call for:\",\n          material,\n          geometry\n        );\n\n        toRemove.push(model);\n        break;\n      }\n\n      case UseMaterialStatus.NO_RENDER_TARGET_MATCHES: {\n        debug(\n          \"Skipped draw for material due to no output matches for the current render target\"\n        );\n        break;\n      }\n\n      default:\n        debug(\"Skipped draw for material due to unknown reasons\");\n        break;\n    }\n  }\n\n  /**\n   * Reads the pixels from the current Render Target (or more specifically from\n   * the current framebuffer)\n   *\n   * By default the viewport is set based on the canvas being rendered into.\n   * Include a render target to make the viewport be applied with the target\n   * considered rather than needing pixel density considerations.\n   *\n   * When the current render target has multiple buffers or IS multiple buffers,\n   * then you have the ability to use bufferType to target a buffer based on\n   * it's outputType to specify that buffer from which you wish to read.\n   */\n  readPixels(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    out: ArrayBufferView,\n    bufferType: number = 0\n  ) {\n    if (!this.gl) return;\n    const allTargets = this.state.currentRenderTarget;\n    let canRead = true;\n    let target: RenderTarget | null | undefined;\n\n    // When our render target is multiple render targets, let's find one that\n    // has a colorBuffer with an outputType that matches our parameter\n    if (Array.isArray(allTargets)) {\n      target = allTargets.find(t => {\n        if (Array.isArray(t.buffers.color)) {\n          return t.buffers.color.find(b => b.outputType === bufferType);\n        } else {\n          return t.buffers.color?.outputType === bufferType;\n        }\n      });\n    }\n\n    // If we have a single render target with multiple color buffers, then we\n    // have the need to make an FBO that places the correct targeted color\n    // buffer as the COLOR_ATTACHMENT0 for the readPixels operation to apply to\n    // it.\n    //\n    // TODO:\n    //\n    // It looks like picking a COLOR ATTACHMENT can be done using the\n    // readBuffer() method. However, readBuffer is not always available so we\n    // will have to use the additional FBO as a fallback.\n    else if (allTargets && Array.isArray(allTargets?.buffers.color)) {\n      if (allTargets.buffers.color.length > 1) {\n        console.warn(\n          \"It is not yet implemented to read the pixels from a RenderTarget with multiple color buffers\"\n        );\n        return;\n      }\n\n      target = allTargets;\n    } else {\n      target = allTargets;\n    }\n\n    if (target) {\n      canRead = target.validFramebuffer;\n    }\n\n    if (!canRead) {\n      console.warn(\n        \"Framebuffer is incomplete. Can not read pixels at this time.\"\n      );\n      return;\n    }\n\n    x = Math.max(0, x);\n    y = Math.max(0, y);\n\n    if (target) {\n      if (x + width > target.width) width = target.width - x;\n      if (y + height > target.height) height = target.height - y;\n      const _height = target.height;\n\n      this.gl.readPixels(\n        x,\n        _height - y - height,\n        width,\n        height,\n        this.gl.RGBA,\n        this.gl.UNSIGNED_BYTE,\n        out\n      );\n    } else {\n      const size = this.getRenderSize();\n      const _height = size[1];\n\n      if (x + width > size[0]) width = size[0] - x;\n      if (y + height > size[1]) height = size[1] - y;\n\n      this.gl.readPixels(\n        x,\n        _height - y - height,\n        width,\n        height,\n        this.gl.RGBA,\n        this.gl.UNSIGNED_BYTE,\n        out\n      );\n    }\n  }\n\n  /**\n   * Sets the clear color to be used when the clear operation executes.\n   */\n  setClearColor(color: Vec4) {\n    this.glState.setClearColor(color);\n  }\n\n  /**\n   * Applies a given ratio for the provided canvas context.\n   */\n  setPixelRatio(ratio: number) {\n    const { canvas } = this.options;\n    const size = this.getDisplaySize();\n\n    canvas.width = size[0] * ratio;\n    canvas.height = size[1] * ratio;\n\n    this.state.pixelRatio = ratio;\n  }\n\n  /**\n   * Sets the region the scissor test will accept as visible. Anything outside\n   * the region will be clipped.\n   *\n   * By default the scissor region is set based on the canvas being rendered\n   * into. Include a render target to make the scissor region be applied with\n   * the target considered rather than needing pixel density considerations.\n   */\n  setScissor(\n    bounds?: { x: number; y: number; width: number; height: number },\n    target?: RenderTarget | RenderTarget[] | null\n  ) {\n    target = target || this.state.currentRenderTarget || null;\n\n    // Multiple render targets are required to be the same height so we just\n    // examine the first\n    if (Array.isArray(target)) {\n      const _height = target[0].height;\n\n      if (bounds) {\n        const { x, y, width, height } = bounds;\n        // Apply the viewport in a fashion that is more web dev friendly where\n        // top left is 0, 0\n        this.glState.setScissor({ x, y: _height - y - height, width, height });\n      } else {\n        this.glState.setScissor(null);\n      }\n    } else if (target) {\n      const _height = target.height;\n\n      if (bounds) {\n        const { x, y, width, height } = bounds;\n        // Apply the viewport in a fashion that is more web dev friendly where\n        // top left is 0, 0\n        this.glState.setScissor({ x, y: _height - y - height, width, height });\n      } else {\n        this.glState.setScissor(null);\n      }\n    } else {\n      const { renderSize } = this.state;\n      const _height = renderSize[1];\n\n      if (bounds) {\n        const { x, y, width, height } = bounds;\n        this.glState.setScissor({\n          x: x,\n          y: _height - y - height,\n          width: width,\n          height: height\n        });\n      } else {\n        this.glState.setScissor(null);\n      }\n    }\n  }\n\n  /**\n   * Resizes the render area to the specified amount.\n   */\n  setSize(width: number, height: number) {\n    const { canvas } = this.options;\n    const { pixelRatio } = this.state;\n\n    // Set the rendering width and height of the canvas to the screen's resolution for maximum sharpness\n    // but it must be limited by the max texture size the hardware supports\n    canvas.width = Math.min(width * pixelRatio, WebGLStat.MAX_TEXTURE_SIZE);\n    canvas.height = Math.min(height * pixelRatio, WebGLStat.MAX_TEXTURE_SIZE);\n\n    // Scale the canvas to fit the desired width and height\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n\n    this.state.renderSize = [canvas.width, canvas.height];\n    this.state.displaySize = [width, height];\n  }\n\n  /**\n   * This sets the context to render into the indicated target\n   */\n  setRenderTarget(target: RenderTarget | RenderTarget[] | null) {\n    // Don't need to do anything for same render targets\n    if (this.state.currentRenderTarget === target) return;\n\n    // If we have multiple targets for MRT then make sure\n    if (Array.isArray(target)) {\n      // If our render target approach is multiple render targets, then we only\n      // need to ensure the targets have their FBO generated appropriately\n      target.forEach(renderTarget => {\n        if (!renderTarget.gl) {\n          this.glProxy.compileRenderTarget(renderTarget);\n        }\n      });\n    } else if (!this.glState.useRenderTarget(target) && target) {\n      // If unable to use yet, this indicates the FBO needs to be compiled\n      // Probably due to uncompiled texture objects that the FBO needs.\n      // First flag all textures as needing a texture unit\n      target.getTextures().forEach(texture => {\n        this.glState.willUseTextureUnit(texture, target);\n      });\n\n      // Now apply those textures (compile them while utilizing the texture\n      // units requested) This will also trigger the compilation of the target\n      // since the textures used are flagged for use This will also ensure the\n      // FBO is in use for the next draw call\n      this.glState.applyUsedTextures();\n\n      // Compile the render target then use if successful\n      if (this.glProxy.compileRenderTarget(target)) {\n        this.glState.useRenderTarget(target);\n      }\n    }\n\n    // Set this as the current render target for the renderer\n    this.state.currentRenderTarget = target;\n  }\n\n  /**\n   * Sets the viewport we render into.\n   *\n   * By default the viewport is set based on the canvas being rendered into. Include a render target\n   * to make the viewport be applied with the target considered rather than needing pixel density considerations.\n   */\n  setViewport(bounds: { x: number; y: number; width: number; height: number }) {\n    const target = this.state.currentRenderTarget;\n    const { x, y, width, height } = bounds;\n\n    // Multiple render targets are required to be the same dimensions\n    if (Array.isArray(target)) {\n      const _height = target[0].height;\n\n      // Apply the viewport in a fashion that is more web dev friendly where top left is 0, 0\n      this.glState.setViewport(x, _height - y - height, width, height);\n    } else if (target) {\n      const _height = target.height;\n\n      // Apply the viewport in a fashion that is more web dev friendly where top left is 0, 0\n      this.glState.setViewport(x, _height - y - height, width, height);\n    } else {\n      const { renderSize } = this.state;\n      const _height = renderSize[1];\n\n      // Apply the viewport in a fashion that is more web dev friendly where top left is 0, 0\n      this.glState.setViewport(x, _height - y - height, width, height);\n    }\n  }\n}\n","import { Bounds } from \"./bounds\";\n\n/**\n * Anytime this is used to express bounds of an object, it is expected\n * to behave like CSS styling with absolute positioning.\n *\n * Setting a left and a right will auto calculate width (setting width takes precedence)\n *\n * You can set numbers to a %. If no % is present all other characters will be ignored\n * (px, em, and other dimensions will not be supported...just px by default unless %)\n */\nexport type AbsolutePosition = {\n  bottom?: number | string;\n  height?: number | string;\n  left?: number | string;\n  right?: number | string;\n  top?: number | string;\n  width?: number | string;\n};\n\nfunction value(val: number | string, ref: number, scaleRatio: number) {\n  const parse = `${val}`;\n  const num = parseFloat(parse);\n\n  if (isNaN(num)) {\n    return 0;\n  }\n\n  // If this is a percentage use the reference as the num to multiply against\n  if (parse.indexOf(\"%\") > -1) {\n    return (num / 100.0) * ref;\n  }\n\n  return num * scaleRatio;\n}\n\n/**\n * This evaluates an absolute position with a reference to produce meaningful bounds.\n *\n * The scaleRatio provided should be available in or for percents to have the same weighting\n * as whole number values.\n */\nexport function getAbsolutePositionBounds<T>(\n  item: AbsolutePosition,\n  reference: Bounds<any>,\n  scaleRatio: number\n): Bounds<T> {\n  if (reference.width === 0 || reference.height === 0) {\n    console.warn(\n      \"An AbsolutePosition evaluated to invalid dimensions.\",\n      \"Please ensure that the object provided and the reference has valid dimensions\",\n      \"to produce dimensions with width and height that are non-zero.\",\n      \"item:\",\n      item,\n      \"reference:\",\n      reference.toString()\n    );\n  }\n\n  const bounds = Bounds.emptyBounds<T>();\n  let width;\n  let height;\n\n  // Calculate the horizontal values\n  if (item.width) {\n    bounds.width = value(item.width, reference.width, scaleRatio);\n\n    if (item.left !== undefined) {\n      bounds.x = value(item.left, reference.width, scaleRatio);\n    } else if (item.right !== undefined) {\n      bounds.x =\n        reference.width -\n        value(item.right, reference.width, scaleRatio) -\n        bounds.width;\n    }\n  } else {\n    const left = value(item.left || 0, reference.width, scaleRatio);\n    const right =\n      reference.width - value(item.right || 0, reference.width, scaleRatio);\n    width = right - left;\n\n    if (width < 0) {\n      console.warn(\n        \"An AbsolutePosition evaluated to invalid dimensions.\",\n        \"Please ensure that the object provided and the reference has valid dimensions\",\n        \"to produce dimensions with width and height that are greater than zero.\",\n        \"item:\",\n        item,\n        \"reference:\",\n        reference.toString()\n      );\n    }\n\n    bounds.x = left;\n    bounds.width = width;\n  }\n\n  // Calculate the vertical values\n  if (item.height) {\n    bounds.height = value(item.height, reference.height, scaleRatio);\n\n    if (item.top !== undefined) {\n      bounds.y = value(item.top, reference.height, scaleRatio);\n    } else if (item.bottom !== undefined) {\n      bounds.y =\n        reference.height -\n        value(item.bottom, reference.height, scaleRatio) -\n        bounds.height;\n    }\n  } else {\n    const top = value(item.top || 0, reference.height, scaleRatio);\n    const bottom =\n      reference.height - value(item.bottom || 0, reference.height, scaleRatio);\n    height = bottom - top;\n\n    if (height === undefined || height < 0) {\n      console.warn(\n        \"An AbsolutePosition evaluated to invalid dimensions.\",\n        \"Please ensure that the object provided and the reference has valid dimensions\",\n        \"to produce dimensions with width and height that are greater than zero.\",\n        \"item:\",\n        item,\n        \"reference:\",\n        reference.toString()\n      );\n    }\n\n    bounds.y = top;\n    bounds.height = height;\n  }\n\n  if (\n    bounds.width === 0 ||\n    bounds.height === 0 ||\n    isNaN(bounds.x + bounds.y + bounds.width + bounds.height)\n  ) {\n    bounds.x = 0;\n    bounds.y = 0;\n    bounds.width = reference.width;\n    bounds.height = reference.height;\n  }\n\n  return bounds;\n}\n","import { Vec } from \"../math/vector\";\nimport { IEasingProps } from \"../types\";\n\n/**\n * This object represents the data associated with easing. It provides the\n * information needed to make an easing equation execute to completion. It also\n * contains a few methods to aid in properly adjusting the easing values.\n */\nexport class EasingProps implements IEasingProps {\n  delay: number = 0;\n  duration: number;\n  end: Vec;\n  isManualStart = false;\n  isTimeSet = false;\n  start: Vec;\n  startTime: number;\n\n  constructor(options: IEasingProps) {\n    Object.assign(this, options);\n  }\n\n  /**\n   * If you manually set values for the easing properties, then you use this to return\n   * the easing object back to an automated state which is where the start value is\n   * the calculated current position of the output and the delay and duration is determined\n   * by the easing set to the layer's IAutomatedEasingMethod value set to the layer.\n   */\n  setAutomatic() {\n    this.isManualStart = false;\n    this.isTimeSet = false;\n  }\n\n  /**\n   * This controls the start value of the easing. This should be used to force a starting\n   * value of the animation.\n   *\n   * Use setAutomatic() to return to default easing behavior.\n   */\n  setStart(start?: Vec) {\n    if (start) {\n      if (this.start.length !== start.length) {\n        console.warn(\n          \"A manual easing adjustment provided an incompatible value for the easing type.\"\n        );\n      } else {\n        this.start = start;\n        this.isManualStart = true;\n      }\n    }\n  }\n\n  /**\n   * This controls of the timing of the easing equation. This should be used to adjust\n   * when a value is to be adjusted\n   *\n   * Use setAutomatic() to return to default easing behavior.\n   */\n  setTiming(delay?: number, duration?: number) {\n    this.delay = delay === undefined ? this.delay : delay;\n    this.duration = duration === undefined ? this.duration : duration;\n    this.isTimeSet = true;\n  }\n}\n","import { GLSettings, WebGLRenderer } from \"../../gl\";\nimport { ColorBuffer, ColorBufferOptions } from \"../../gl/color-buffer\";\nimport { ResourceType, TextureSize } from \"../../types\";\nimport { IdentifyByKey } from \"../../util/identify-by-key\";\nimport { BaseResourceOptions } from \"../base-resource-manager\";\n\n/**\n * Options required for generating a RenderTexture.\n */\nexport interface IColorBufferResource extends BaseResourceOptions {\n  /** Set the type of the resource to explicitally be an atlas resource */\n  type: ResourceType.COLOR_BUFFER;\n  /**\n   * This is the height of the texture. Use the TextureSize to set a sensical\n   * size or set a specialized sizing based on screen dimensions.\n   */\n  height: number;\n  /**\n   * This is the width of the texture. Use the TextureSize to set a sensical\n   * size or set a specialized sizing based on screen dimensions.\n   */\n  width: number;\n  /**\n   * This applies any desired settings to the Texture.\n   * Some noteable defaults this system sets:\n   *  - generateMipMaps is true and\n   *  - premultiply alpha is true.\n   */\n  colorBufferSettings?: ColorBufferOptions;\n}\n\n/**\n * Use this to aid in creating a texture in the resources portion of configuring\n * your surface.\n */\nexport function createColorBuffer(\n  options: Omit<IColorBufferResource, \"type\" | \"key\"> &\n    Partial<Pick<IColorBufferResource, \"key\">>\n): IColorBufferResource {\n  return {\n    key: \"\",\n    type: ResourceType.COLOR_BUFFER,\n    ...options\n  };\n}\n\n/**\n * Type guard for the Render Texture resource type.\n */\nexport function isColorBufferResource(val: any): val is IColorBufferResource {\n  return (\n    val !== void 0 &&\n    val.key !== void 0 &&\n    val.type === ResourceType.COLOR_BUFFER\n  );\n}\n\n/**\n * This defines a general purpose color buffer resource that can be rendered into.\n */\nexport class ColorBufferResource extends IdentifyByKey\n  implements IColorBufferResource {\n  /** Set the type of the resource to explicitally be an atlas resource */\n  type: ResourceType.COLOR_BUFFER = ResourceType.COLOR_BUFFER;\n  /** This is the height of the texture */\n  height: number;\n  /** This is the width of the texture */\n  width: number;\n  /**\n   * This applies any desired settings to the Texture.\n   * Some noteable defaults this system sets:\n   *  - generateMipMaps is true and\n   *  - premultiply alpha is true.\n   */\n  colorBufferSettings?: ColorBufferOptions;\n  /** The actual texture resource generated */\n  colorBuffer: ColorBuffer;\n\n  constructor(options: IColorBufferResource, renderer?: WebGLRenderer) {\n    super(options);\n    this.height = options.height;\n    this.width = options.width;\n    this.colorBufferSettings = options.colorBufferSettings;\n    this.createColorBuffer(renderer);\n  }\n\n  /**\n   * Frees up resources associated with this object. This object is no longer\n   * valid after this is called and will produce undefined results if attempted\n   * to use again.\n   */\n  destroy() {\n    this.colorBuffer.destroy();\n  }\n\n  /**\n   * This generates the colorBuffer object needed for this atlas.\n   */\n  private createColorBuffer(renderer?: WebGLRenderer) {\n    if (this.colorBuffer) return;\n\n    // Establish the settings to be applied to the Color Buffer. Provide some default\n    // configuration.\n    this.colorBufferSettings = {\n      ...this.colorBufferSettings\n    };\n\n    let width, height;\n    const size = renderer?.getRenderSize() || [1, 1];\n\n    if (this.width <= TextureSize.SCREEN) {\n      if (!renderer) {\n        throw new Error(\n          \"Can not generate Render Texture with a dynamic width or height when the WebGLRenderer is not available\"\n        );\n      }\n\n      width = size[0] / -this.width;\n    } else width = this.width;\n\n    if (this.height <= TextureSize.SCREEN) {\n      if (!renderer) {\n        throw new Error(\n          \"Can not generate Render Texture with a dynamic width or height when the WebGLRenderer is not available\"\n        );\n      }\n\n      height = size[1] / -this.width;\n    } else height = this.height;\n\n    // Generate the color buffer\n    this.colorBuffer = new ColorBuffer({\n      internalFormat: GLSettings.RenderTarget.ColorBufferFormat.RGBA4,\n      size: [width, height],\n      ...this.colorBufferSettings\n    });\n  }\n}\n","import { EulerOrder, EulerRotation } from \"../types\";\nimport {\n  identity3,\n  identity4,\n  M300,\n  M301,\n  M302,\n  M310,\n  M311,\n  M312,\n  M320,\n  M321,\n  M322,\n  M400,\n  M401,\n  M402,\n  M403,\n  M410,\n  M411,\n  M412,\n  M413,\n  M420,\n  M421,\n  M422,\n  M423,\n  M430,\n  M431,\n  M432,\n  M433,\n  Mat3x3,\n  Mat4x4\n} from \"./matrix\";\nimport {\n  add3,\n  cross3,\n  dot3,\n  dot4,\n  normalize3,\n  scale3,\n  V3R,\n  Vec3,\n  vec3,\n  Vec3Compat,\n  Vec4\n} from \"./vector\";\n\nconst { cos, sin, sqrt, exp, acos, atan2, PI } = Math;\n\n// We often need some variable registers that match matrix elements in a lot of\n// our quaternion algorithms. We keep them in the module scope so we don't have\n// to declare them in the scope of the method to reduce Garbage.\nlet m00: number;\nlet m01: number;\nlet m02: number;\n// let m03: number;\n// let m04: number;\nlet m10: number;\nlet m11: number;\nlet m12: number;\nlet m13: number;\n// let m14: number;\nlet m20: number;\nlet m21: number;\nlet m22: number;\nlet m23: number;\n// let m24: number;\n// let m30: number;\nlet m31: number;\nlet m32: number;\nlet m33: number;\n// let m34: number;\n\n// Other common registers are the components of the quat\n// let x: number;\n// let y: number;\n// let z: number;\nlet w: number;\n\n// Vector registers for axes\nlet vx: Vec3;\nlet vy: Vec3;\nlet vz: Vec3;\n// let vw: Vec3;\n\n/** Expresses a quaternion [scalar, i, j, k] */\nexport type Quaternion = Vec4;\n\n/** Temp Quaternion register. Can be used for intermediate operations */\nexport const QR1 = zeroQuat();\n/** Temp Quaternion register. Can be used for intermediate operations */\nexport const QR2 = zeroQuat();\n/** Temp Quaternion register. Can be used for intermediate operations */\nexport const QR3 = zeroQuat();\n/** Temp Quaternion register. Can be used for intermediate operations */\nexport const QR4 = zeroQuat();\n\n/** Helper index to make index selection more readable if desired */\nexport const QX = 1;\n/** Helper index to make index selection more readable if desired */\nexport const QY = 2;\n/** Helper index to make index selection more readable if desired */\nexport const QZ = 3;\n/** Helper index to make index selection more readable if desired */\nexport const QW = 0;\n\nexport function clamp(x: number, min: number, max: number) {\n  if (x > max) return max;\n  if (x < min) return min;\n  return x;\n}\n\n/**\n * Generates a new zero quaternion\n */\nexport function zeroQuat(out?: Quaternion): Quaternion {\n  if (out) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n\n    return out;\n  }\n\n  return [0, 0, 0, 0];\n}\n\n/**\n * Adds two quaternions.\n */\nexport function addQuat(\n  q1: Quaternion,\n  q2: Quaternion,\n  out?: Quaternion\n): Quaternion {\n  out = out || zeroQuat();\n  out[0] = q1[0] + q2[0];\n  out[1] = q1[1] + q2[1];\n  out[2] = q1[2] + q2[2];\n  out[3] = q1[3] + q2[3];\n\n  return out;\n}\n\n/**\n * Multiplies two quaternions.\n * Note: Quaternion multiplication is noncommutative.\n */\nexport function multiplyQuat(\n  q1: Quaternion,\n  q2: Quaternion,\n  out?: Quaternion\n): Quaternion {\n  out = out || zeroQuat();\n\n  const a1 = q1[0],\n    a2 = q2[0],\n    b1 = q1[1],\n    b2 = q2[1],\n    c1 = q1[2],\n    c2 = q2[2],\n    d1 = q1[3],\n    d2 = q2[3];\n\n  out[0] = a1 * a2 - b1 * b2 - c1 * c2 - d1 * d2;\n  out[1] = a1 * b2 + b1 * a2 + c1 * d2 - d1 * c2;\n  out[2] = a1 * c2 - b1 * d2 + c1 * a2 + d1 * b2;\n  out[3] = a1 * d2 + b1 * c2 - c1 * b2 + d1 * a2;\n\n  return out;\n}\n\n/**\n * Performs quaternion division:\n * q1 / q2 = q1 * q2^-1\n */\nexport function divideQuat(\n  q1: Quaternion,\n  q2: Quaternion,\n  out?: Quaternion\n): Quaternion {\n  out = out || zeroQuat();\n\n  const a1 = q1[0],\n    b1 = q1[1],\n    c1 = q1[2],\n    d1 = q1[3];\n\n  const a2 = q2[0],\n    b2 = q2[1],\n    c2 = q2[2],\n    d2 = q2[3];\n\n  const norm = a2 * a2 + b2 * b2 + c2 * c2 + d2 * d2;\n\n  if (norm === 0) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  } else {\n    const r = 1 / norm;\n\n    out[0] = (a1 * a2 + b1 * b2 + c1 * c2 + d1 * d2) * r;\n    out[1] = (b1 * a2 - a1 * b2 - c1 * d2 + d1 * c2) * r;\n    out[2] = (c1 * a2 - a1 * c2 - d1 * b2 + b1 * d2) * r;\n    out[3] = (d1 * a2 - a1 * d2 - b1 * c2 + c1 * b2) * r;\n  }\n\n  return out;\n}\n\n/**\n * Calculates the exponentiation of a quaternion\n */\nexport function exponentQuat(q: Quaternion, out?: Quaternion): Quaternion {\n  out = out || zeroQuat();\n\n  const a = q[0],\n    b = q[1],\n    c = q[2],\n    d = q[3];\n\n  const norm = sqrt(b * b + c * c + d * d);\n  const wExp = exp(a);\n  const scale = (wExp / norm) * sin(norm);\n\n  if (norm === 0) {\n    out[0] = exp(a);\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  } else {\n    out[0] = wExp * cos(norm);\n    out[1] = b * scale;\n    out[2] = c * scale;\n    out[3] = d * scale;\n  }\n\n  return out;\n}\n\n/**\n * Multiplies a quaternion by a scalar.\n */\nexport function scaleQuat(\n  q: Quaternion,\n  scale: number,\n  out?: Quaternion\n): Quaternion {\n  out = out || zeroQuat();\n\n  out[0] = q[0] * scale;\n  out[1] = q[1] * scale;\n  out[2] = q[2] * scale;\n  out[3] = q[3] * scale;\n\n  return out;\n}\n\n/**\n * This provides a sort of \"directional\" unit quaternion such that:\n * q2 - q1 = diff\n * where\n * diff * q1 = q2\n *\n * The math for this is:\n * diff = q2 * inverse(q1)\n *\n * Optimzied for Unit quats:\n * inverse(q1) = conjugate(q1) / abs(q1)\n * where\n * abs(q1) = 1 for unit quats\n */\nexport function diffUnitQuat(\n  q1: Quaternion,\n  q2: Quaternion,\n  out?: Quaternion\n): Quaternion {\n  out = out || zeroQuat();\n  return multiplyQuat(q2, conjugateQuat(q1), out);\n}\n\n/**\n * Computes the conjugate of a quaternion.\n */\nexport function conjugateQuat(q: Quaternion, out?: Quaternion): Quaternion {\n  out = out || zeroQuat();\n\n  out[0] = q[0];\n  out[1] = -q[1];\n  out[2] = -q[2];\n  out[3] = -q[3];\n\n  return out;\n}\n\n/**\n * Computes the inverse, or reciprocal, of a quaternion.\n */\nexport function inverseQuat(q: Quaternion, out?: Quaternion): Quaternion {\n  out = out || zeroQuat();\n\n  const a = q[0],\n    b = q[1],\n    c = q[2],\n    d = q[3];\n\n  const norm = a * a + b * b + c * c + d * d;\n\n  if (norm === 0) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  } else {\n    const r = 1 / norm;\n\n    out[0] = a * r;\n    out[1] = -b * r;\n    out[2] = -c * r;\n    out[3] = -d * r;\n  }\n\n  return out;\n}\n\n/**\n * Computes the length of a quaternion: that is, the square root of\n * the product of the quaternion with its conjugate.  Also known as\n * the \"norm\".\n */\nexport function lengthQuat(q: Quaternion): number {\n  const a = q[0],\n    b = q[1],\n    c = q[2],\n    d = q[3];\n\n  return sqrt(a * a + b * b + c * c + d * d);\n}\n\n/**\n * Normalizes a quaternion so its length is equal to 1.  The result of\n * normalizing a zero quaternion is undefined.\n */\nexport function normalizeQuat(q: Quaternion, out?: Quaternion): Quaternion {\n  out = out || zeroQuat();\n  const len = lengthQuat(q);\n  if (len === 0) return [0, 0, 0, 0];\n  const rlen = 1 / len;\n\n  return scaleQuat(q, rlen, out);\n}\n\n/**\n * Provides the real part of the quaternion.\n */\nexport function realQuat(q: Quaternion): number {\n  return q[0];\n}\n\n/**\n * Provides the vector part of the quaternion.\n */\nexport function imaginaryQuat(q: Quaternion): Vec3 {\n  return [q[1], q[2], q[3]];\n}\n\n/**\n * Dot product of two quaternions\n */\nexport function dotQuat(q1: Quaternion, q2: Quaternion): number {\n  return dot4(q1, q2);\n}\n\n/**\n * Constructs a rotation quaternion from an axis (a normalized\n * Vec3) and an angle (in radians).\n */\nexport function fromEulerAxisAngleToQuat(\n  axis: Vec3,\n  angle: number,\n  out?: Quaternion\n): Quaternion {\n  out = out || zeroQuat();\n  const x = axis[0],\n    y = axis[1],\n    z = axis[2];\n  const r = 1 / sqrt(x * x + y * y + z * z);\n  const s = sin(angle / 2);\n  out[0] = cos(angle / 2);\n  out[1] = s * x * r;\n  out[2] = s * y * r;\n  out[3] = s * z * r;\n\n  return out;\n}\n\n/**\n * This converts a general euler angle of any rotation order into a quaternion\n */\nexport function fromOrderedEulerToQuat(\n  angles: Vec3,\n  order: EulerOrder,\n  out?: Quaternion\n): Quaternion {\n  out = out || zeroQuat();\n  const x = angles[0],\n    y = angles[1],\n    z = angles[2];\n\n  const cos = Math.cos;\n  const sin = Math.sin;\n\n  const c1 = cos(x / 2);\n  const c2 = cos(y / 2);\n  const c3 = cos(z / 2);\n\n  const s1 = sin(x / 2);\n  const s2 = sin(y / 2);\n  const s3 = sin(z / 2);\n\n  switch (order) {\n    case EulerOrder.xyz:\n      out[1] = s1 * c2 * c3 + c1 * s2 * s3;\n      out[2] = c1 * s2 * c3 - s1 * c2 * s3;\n      out[3] = c1 * c2 * s3 + s1 * s2 * c3;\n      out[0] = c1 * c2 * c3 - s1 * s2 * s3;\n      /*out[0] = c1 * c2 * c3 + s1 * s2 * s3;\n      out[1] = s1 * c2 * c3 - c1 * s2 * s3;\n      out[2] = c1 * s2 * c3 + s1 * c2 * s3;\n      out[3] = c1 * c2 * s3 - s1 * s2 * c3;*/\n      break;\n\n    case EulerOrder.yxz:\n      out[0] = c1 * c2 * c3 + s1 * s2 * s3;\n      out[1] = s1 * c2 * c3 + c1 * s2 * s3;\n      out[2] = c1 * s2 * c3 - s1 * c2 * s3;\n      out[3] = c1 * c2 * s3 - s1 * s2 * c3;\n      /*out[0] = c1 * c2 * c3 - s1 * s2 * s3;\n      out[1] = c1 * s2 * c3 - s1 * c2 * s3;\n      out[2] = c1 * s2 * s3 + s1 * c2 * c3 ;\n      out[3] = c1 * c2 * s3 + s1 * s2 * c3;*/\n      break;\n\n    case EulerOrder.zxy:\n      out[0] = c1 * c2 * c3 - s1 * s2 * s3;\n      out[1] = s1 * c2 * c3 - c1 * s2 * s3;\n      out[2] = c1 * s2 * c3 + s1 * c2 * s3;\n      out[3] = c1 * c2 * s3 + s1 * s2 * c3;\n      break;\n\n    case EulerOrder.zyx:\n      out[0] = c1 * c2 * c3 + s1 * s2 * s3;\n      out[1] = s1 * c2 * c3 - c1 * s2 * s3;\n      out[2] = c1 * s2 * c3 + s1 * c2 * s3;\n      out[3] = c1 * c2 * s3 - s1 * s2 * c3;\n\n      break;\n\n    case EulerOrder.yzx:\n      out[0] = c1 * c2 * c3 - s1 * s2 * s3;\n      out[1] = s1 * c2 * c3 + c1 * s2 * s3;\n      out[2] = c1 * s2 * c3 + s1 * c2 * s3;\n      out[3] = c1 * c2 * s3 - s1 * s2 * c3;\n\n      break;\n\n    case EulerOrder.xzy:\n      out[0] = c1 * c2 * c3 + s1 * s2 * s3;\n      out[1] = s1 * c2 * c3 - c1 * s2 * s3;\n      out[2] = c1 * s2 * c3 - s1 * c2 * s3;\n      out[3] = c1 * c2 * s3 + s1 * s2 * c3;\n\n      break;\n  }\n\n  return out;\n}\n\n/**\n * This converts a euler angle of any ordering and turns it into an euler of XYZ\n * orientation which is the expected rotation of most elements in this\n * framework.\n */\nexport function toEulerXYZfromOrderedEuler(\n  euler: Vec3,\n  order: EulerOrder,\n  out?: EulerRotation\n): EulerRotation {\n  out = out || [0, 0, 0];\n  const q = fromOrderedEulerToQuat(euler, order);\n  toOrderedEulerFromQuat(q, EulerOrder.xyz, out);\n  // toOrderedEulerFromQuat(q, EulerOrder.zyx, out);\n  return out;\n}\n\n/**\n * Helper method for toEulerQuat\n */\nfunction twoAxisRotation(\n  r11: number,\n  r12: number,\n  r2: number,\n  r31: number,\n  r32: number,\n  out: number[]\n) {\n  out[0] = atan2(r11, r12);\n  out[1] = acos(r2);\n  out[2] = atan2(r31, r32);\n}\n\n/**\n * Helper method for toEulerQuat\n * TODO: May not need this method anymore?\n */\n// function threeAxisRotation(\n//   r11: number,\n//   r12: number,\n//   r2: number,\n//   r31: number,\n//   r32: number,\n//   out: number[]\n// ) {\n//   // out[0] = atan2(r31, r32);\n//   out[0] = atan2(r11, r12);\n//   out[1] = asin(r2);\n//   // out[2] = atan2(r11, r12);\n//   out[2] = atan2(r31, r32);\n// }\n\n/**\n * Produces a XYZ Euler angle from the provided Quaternion.\n */\nexport function toEulerFromQuat(q: Quaternion, out?: EulerRotation) {\n  return toOrderedEulerFromQuat(q, EulerOrder.zyx, out);\n}\n\n/**\n * Converts a quaternion to an ordered Euler angle.\n *\n * NOTE: It is best to convert to XYZ ordering if using with this framework's 3D\n * system, or simply use toEulerFromQuat if this is desired. Only use this if\n * you specifically need an Euler angle for a known purpose.\n */\nexport function toOrderedEulerFromQuat(\n  q: Quaternion,\n  order: EulerOrder,\n  out?: Vec3\n): EulerRotation {\n  out = out || [0, 0, 0];\n\n  const q0 = q[0],\n    q1 = q[1],\n    q2 = q[2],\n    q3 = q[3];\n\n  const m = matrix4x4FromUnitQuatView(q);\n  const m11 = m[0],\n    m12 = m[4],\n    m13 = m[8];\n  const m21 = m[1],\n    m22 = m[5],\n    m23 = m[9];\n  const m31 = m[2],\n    m32 = m[6],\n    m33 = m[10];\n\n  switch (order) {\n    case EulerOrder.zyx:\n      /*threeAxisRotation(\n        2 * (q[1] * q[2] + q[0] * q[3]),\n        q[0] * q[0] + q[1] * q[1] - q[2] * q[2] - q[3] * q[3],\n        -2 * (q[1] * q[3] - q[0] * q[2]),\n        2 * (q[2] * q[3] + q[0] * q[1]),\n        q[0] * q[0] - q[1] * q[1] - q[2] * q[2] + q[3] * q[3],\n        out\n      );\n      threeAxisRotation(\n        2 * q0 * q3 - 2 * q1 * q2,\n        q1 * q1 + q0 * q0 - q3 * q3 - q2 * q2,\n        2 * q1 * q3 + 2 * q0 * q2,\n        2 * q0 * q1 - 2 * q2 * q3,\n        q3 * q3 - q2 * q2 - q1 * q1 + q0 * q0,\n        out\n      )*/\n\n      out[1] = Math.asin(-clamp(m31, -1, 1));\n\n      if (Math.abs(m31) < 0.99999) {\n        out[0] = Math.atan2(m32, m33);\n        out[2] = Math.atan2(m21, m11);\n      } else {\n        out[0] = 0;\n        out[2] = Math.atan2(-m12, m22);\n      }\n      break;\n\n    case EulerOrder.zyz:\n      /*twoAxisRotation(\n        2 * (q[2] * q[3] - q[0] * q[1]),\n        2 * (q[1] * q[3] + q[0] * q[2]),\n        q[0] * q[0] - q[1] * q[1] - q[2] * q[2] + q[3] * q[3],\n        2 * (q[2] * q[3] + q[0] * q[1]),\n        -2 * (q[1] * q[3] - q[0] * q[2]),\n        out\n      );*/\n      twoAxisRotation(\n        2 * q2 * q3 + 2 * q0 * q1,\n        2 * q0 * q2 - 2 * q1 * q3,\n        q3 * q3 - q2 * q2 - q1 * q1 + q0 * q0,\n        2 * q2 * q3 - 2 * q0 * q1,\n        2 * q1 * q3 + 2 * q0 * q2,\n        out\n      );\n      break;\n\n    case EulerOrder.zxy:\n      /*threeAxisRotation(\n        -2 * (q[1] * q[2] - q[0] * q[3]),\n        q[0] * q[0] - q[1] * q[1] + q[2] * q[2] - q[3] * q[3],\n        2 * (q[2] * q[3] + q[0] * q[1]),\n        -2 * (q[1] * q[3] - q[0] * q[2]),\n        q[0] * q[0] - q[1] * q[1] - q[2] * q[2] + q[3] * q[3],\n        out\n      );\n      threeAxisRotation(\n        2 * q1 * q2 + 2 * q0 * q3,\n        q2 * q2 - q3 * q3 + q0 * q0 - q1 * q1,\n        2 * q0 * q1 - 2 * q2 * q3,\n        2 * q1 * q3 + 2 * q0 * q2,\n        q3 * q3 - q2 * q2 - q1 * q1 + q0 * q0,\n        out\n      )*/\n      out[0] = Math.asin(clamp(m32, -1, 1));\n\n      if (Math.abs(m32) < 0.99999) {\n        out[1] = Math.atan2(-m31, m33);\n        out[2] = Math.atan2(-m12, m22);\n      } else {\n        out[1] = 0;\n        out[2] = Math.atan2(m21, m11);\n      }\n\n      break;\n\n    case EulerOrder.zxz:\n      /*twoAxisRotation(\n        2 * (q[1] * q[3] + q[0] * q[2]),\n        -2 * (q[2] * q[3] - q[0] * q[1]),\n        q[0] * q[0] - q[1] * q[1] - q[2] * q[2] + q[3] * q[3],\n        2 * (q[1] * q[3] - q[0] * q[2]),\n        2 * (q[2] * q[3] + q[0] * q[1]),\n        out\n      );*/\n      twoAxisRotation(\n        2 * q1 * q3 - 2 * q0 * q2,\n        2 * q2 * q3 + 2 * q0 * q1,\n        q3 * q3 - q2 * q2 - q1 * q1 + q0 * q0,\n        2 * q1 * q3 + 2 * q0 * q2,\n        2 * q0 * q1 - 2 * q2 * q3,\n        out\n      );\n      break;\n\n    case EulerOrder.yxz:\n      /*threeAxisRotation(\n        2 * (q[1] * q[3] + q[0] * q[2]),\n        q[0] * q[0] - q[1] * q[1] - q[2] * q[2] + q[3] * q[3],\n        -2 * (q[2] * q[3] - q[0] * q[1]),\n        2 * (q[1] * q[2] + q[0] * q[3]),\n        q[0] * q[0] - q[1] * q[1] + q[2] * q[2] - q[3] * q[3],\n        out\n      );\n      threeAxisRotation(\n        2 * q0 * q2 - 2 * q1 * q3,\n        q3 * q3 - q2 * q2 - q1 * q1 + q0 * q0,\n        2 * q2 * q3 + 2 * q0 * q1,\n        2 * q0 * q3 - 2 * q1 * q2,\n        q2 * q2 - q3 * q3 + q0 * q0 - q1 * q1,\n        out\n      )*/\n\n      out[0] = Math.asin(-clamp(m23, -1, 1));\n\n      if (Math.abs(m23) < 0.9999) {\n        out[1] = Math.atan2(m13, m33);\n        out[2] = Math.atan2(m21, m22);\n      } else {\n        out[1] = Math.atan2(-m31, m11);\n        out[2] = 0;\n      }\n      break;\n\n    case EulerOrder.yxy:\n      /*twoAxisRotation(\n        2 * (q[1] * q[2] - q[0] * q[3]),\n        2 * (q[2] * q[3] + q[0] * q[1]),\n        q[0] * q[0] - q[1] * q[1] + q[2] * q[2] - q[3] * q[3],\n        2 * (q[1] * q[2] + q[0] * q[3]),\n        -2 * (q[2] * q[3] - q[0] * q[1]),\n        out\n      );*/\n      twoAxisRotation(\n        2 * q1 * q2 + 2 * q0 * q3,\n        2 * q0 * q1 - 2 * q2 * q3,\n        q2 * q2 - q3 * q3 + q0 * q0 - q1 * q1,\n        2 * q1 * q2 - 2 * q0 * q3,\n        2 * q2 * q3 + 2 * q0 * q1,\n        out\n      );\n      break;\n\n    case EulerOrder.yzx:\n      /*threeAxisRotation(\n        -2 * (q[1] * q[3] - q[0] * q[2]),\n        q[0] * q[0] + q[1] * q[1] - q[2] * q[2] - q[3] * q[3],\n        2 * (q[1] * q[2] + q[0] * q[3]),\n        -2 * (q[2] * q[3] - q[0] * q[1]),\n        q[0] * q[0] - q[1] * q[1] + q[2] * q[2] - q[3] * q[3],\n        out\n      );\n      threeAxisRotation(\n        2 * q1 * q3 + 2 * q0 * q2,\n        q1 * q1 + q0 * q0 - q3 * q3 - q2 * q2,\n        2 * q0 * q3 - 2 * q1 * q2,\n        2 * q2 * q3 + 2 * q0 * q1,\n        q2 * q2 - q3 * q3 + q0 * q0 - q1 * q1,\n        out\n      )*/\n\n      out[2] = Math.asin(clamp(m21, -1, 1));\n\n      if (Math.abs(m21) < 0.99999) {\n        out[0] = Math.atan2(-m23, m22);\n        out[1] = Math.atan2(-m31, m11);\n      } else {\n        out[0] = 0;\n        out[1] = Math.atan2(m13, m33);\n      }\n      break;\n\n    case EulerOrder.yzy:\n      /*twoAxisRotation(\n        2 * (q[2] * q[3] + q[0] * q[1]),\n        -2 * (q[1] * q[2] - q[0] * q[3]),\n        q[0] * q[0] - q[1] * q[1] + q[2] * q[2] - q[3] * q[3],\n        2 * (q[2] * q[3] - q[0] * q[1]),\n        2 * (q[1] * q[2] + q[0] * q[3]),\n        out\n      );*/\n      twoAxisRotation(\n        2 * q2 * q3 - 2 * q0 * q1,\n        2 * q1 * q2 + 2 * q0 * q3,\n        q2 * q2 - q3 * q3 + q0 * q0 - q1 * q1,\n        2 * q2 * q3 + 2 * q0 * q1,\n        2 * q0 * q3 - 2 * q1 * q2,\n        out\n      );\n      break;\n\n    case EulerOrder.xyz:\n      /*threeAxisRotation(\n        -2 * (q[2] * q[3] - q[0] * q[1]),\n        q[0] * q[0] - q[1] * q[1] - q[2] * q[2] + q[3] * q[3],\n        2 * (q[1] * q[3] + q[0] * q[2]),\n        -2 * (q[1] * q[2] - q[0] * q[3]),\n        q[0] * q[0] + q[1] * q[1] - q[2] * q[2] - q[3] * q[3],\n        out\n      );\n      threeAxisRotation(\n        2 * q2 * q3 + 2 * q0 * q1,\n        q3 * q3 - q2 * q2 - q1 * q1 + q0 * q0,\n        2 * q0 *q2 - 2 * q1 * q3,\n        2 * q1 * q2 + 2 * q0 * q3,\n        q1 * q1 + q0 * q0 - q3 * q3 - q2 * q2,\n        out\n      );*/\n\n      out[1] = Math.asin(clamp(m13, -1, 1));\n\n      if (Math.abs(m13) < 0.99999) {\n        out[0] = Math.atan2(-m23, m33);\n        out[2] = Math.atan2(-m12, m11);\n      } else {\n        out[0] = Math.atan2(m32, m22);\n        out[2] = 0;\n      }\n      break;\n\n    case EulerOrder.xyx:\n      /*twoAxisRotation(\n        2 * (q[1] * q[2] + q[0] * q[3]),\n        -2 * (q[1] * q[3] - q[0] * q[2]),\n        q[0] * q[0] + q[1] * q[1] - q[2] * q[2] - q[3] * q[3],\n        2 * (q[1] * q[2] - q[0] * q[3]),\n        2 * (q[1] * q[3] + q[0] * q[2]),\n        out\n      );*/\n      twoAxisRotation(\n        2 * q1 * q2 - 2 * q0 * q3,\n        2 * q1 * q3 + 2 * q0 * q2,\n        q1 * q1 + q0 * q0 - q3 * q3 - q2 * q2,\n        2 * q1 * q2 + 2 * q0 * q3,\n        2 * q0 * q2 - 2 * q1 * q3,\n        out\n      );\n      break;\n\n    case EulerOrder.xzy:\n      /*threeAxisRotation(\n        2 * (q[2] * q[3] + q[0] * q[1]),\n        q[0] * q[0] - q[1] * q[1] + q[2] * q[2] - q[3] * q[3],\n        -2 * (q[1] * q[2] - q[0] * q[3]),\n        2 * (q[1] * q[3] + q[0] * q[2]),\n        q[0] * q[0] + q[1] * q[1] - q[2] * q[2] - q[3] * q[3],\n        out\n      );\n      threeAxisRotation(\n        2 * q0 * q1 - 2 * q2 * q3,\n        q2 * q2 - q3 * q3 + q0 * q0 - q1 * q1,\n        2 * q1 * q2 + 2 * q0 * q3,\n        2 * q0 * q2 - 2 * q1 * q3,\n        q1 * q1 + q0 * q0 - q3 * q3 - q2 * q2,\n        out\n      )*/\n\n      out[2] = Math.asin(-clamp(m12, -1, 1));\n\n      if (Math.abs(m12) < 0.99999) {\n        out[0] = Math.atan2(m32, m22);\n        out[1] = Math.atan2(m13, m11);\n      } else {\n        out[0] = Math.atan2(-m23, m33);\n        out[1] = 0;\n      }\n\n      break;\n\n    case EulerOrder.xzx:\n      /*twoAxisRotation(\n        2 * (q[1] * q[3] - q[0] * q[2]),\n        2 * (q[1] * q[2] + q[0] * q[3]),\n        q[0] * q[0] + q[1] * q[1] - q[2] * q[2] - q[3] * q[3],\n        2 * (q[1] * q[3] + q[0] * q[2]),\n        -2 * (q[1] * q[2] - q[0] * q[3]),\n        out\n      );*/\n\n      twoAxisRotation(\n        2 * q1 * q3 + 2 * q0 * q2,\n        2 * q0 * q3 - 2 * q1 * q2,\n        q1 * q1 + q0 * q0 - q3 * q3 - q2 * q2,\n        2 * q1 * q3 - 2 * q0 * q2,\n        2 * q1 * q2 + 2 * q0 * q3,\n        out\n      );\n      break;\n\n    default:\n      console.warn(\"Invalid Euler rotation order.\");\n      break;\n  }\n\n  return out;\n}\n\nexport function toOrderedEulerFromQuat2(\n  quat: Quaternion,\n  order: EulerOrder,\n  out?: Vec3\n) {\n  out = out || [0, 0, 0];\n\n  const m = matrix4x4FromUnitQuatView(quat);\n  const m11 = m[0],\n    m12 = m[4],\n    m13 = m[8];\n  const m21 = m[1],\n    m22 = m[5],\n    m23 = m[9];\n  const m31 = m[2],\n    m32 = m[6],\n    m33 = m[10];\n\n  switch (order) {\n    case EulerOrder.xyz:\n      out[1] = Math.asin(clamp(m13, -1, 1));\n\n      if (Math.abs(m13) < 0.99999) {\n        out[0] = Math.atan2(-m23, m33);\n        out[2] = Math.atan2(-m12, m11);\n      } else {\n        out[0] = Math.atan2(m32, m22);\n        out[2] = 0;\n      }\n\n      break;\n    case EulerOrder.yxz:\n      out[0] = Math.asin(-clamp(m23, -1, 1));\n\n      if (Math.abs(m23) < 0.9999) {\n        out[1] = Math.atan2(m13, m33);\n        out[2] = Math.atan2(m21, m22);\n      } else {\n        out[1] = Math.atan2(-m31, m11);\n        out[2] = 0;\n      }\n\n      break;\n    case EulerOrder.zxy:\n      out[0] = Math.asin(clamp(m32, -1, 1));\n\n      if (Math.abs(m32) < 0.99999) {\n        out[1] = Math.atan2(-m31, m33);\n        out[2] = Math.atan2(-m12, m22);\n      } else {\n        out[1] = 0;\n        out[2] = Math.atan2(m21, m11);\n      }\n\n      break;\n    case EulerOrder.zyx:\n      out[1] = Math.asin(-clamp(m31, -1, 1));\n\n      if (Math.abs(m31) < 0.99999) {\n        out[0] = Math.atan2(m32, m33);\n        out[2] = Math.atan2(m21, m11);\n      } else {\n        out[0] = 0;\n        out[2] = Math.atan2(-m12, m22);\n      }\n\n      break;\n    case EulerOrder.yzx:\n      out[2] = Math.asin(clamp(m21, -1, 1));\n\n      if (Math.abs(m21) < 0.99999) {\n        out[0] = Math.atan2(-m23, m22);\n        out[1] = Math.atan2(-m31, m11);\n      } else {\n        out[0] = 0;\n        out[1] = Math.atan2(m13, m33);\n      }\n\n      break;\n    case EulerOrder.xzy:\n      out[2] = Math.asin(-clamp(m12, -1, 1));\n\n      if (Math.abs(m12) < 0.99999) {\n        out[0] = Math.atan2(m32, m22);\n        out[1] = Math.atan2(m13, m11);\n      } else {\n        out[0] = Math.atan2(-m23, m33);\n        out[1] = 0;\n      }\n\n      break;\n  }\n}\n\n/**\n * Extracts the angle part, in radians, of a rotation quaternion.\n */\nexport function angleQuat(quat: Quaternion): number {\n  const a = quat[0];\n\n  if (a < -1.0 || a > 1.0) {\n    return 0.0;\n  }\n\n  const angle = 2 * acos(a);\n\n  if (angle > PI) {\n    return angle - 2 * PI;\n  }\n\n  return angle;\n}\n\n/**\n * Extracts the axis part, as a Vec3, of a rotation quaternion.\n */\nexport function axisQuat(quat: Quaternion): Vec3 {\n  const x = quat[1],\n    y = quat[2],\n    z = quat[3];\n\n  const length = sqrt(x * x + y * y + z * z);\n\n  if (length === 0) return [0, 0, 0];\n\n  const r = 1 / sqrt(x * x + y * y + z * z);\n\n  return [x * r, y * r, z * r];\n}\n\n/**\n * Produces a transform matrix from a returned unit quaternion. This is a matrix\n * that is from a 'models' perspective where the model orients itself to match\n * the orientation.\n */\nexport function matrix3x3FromUnitQuatModel(q: Quaternion, m?: Mat3x3): Mat3x3 {\n  let wx, wy, wz, xx, yy, yz, xy, xz, zz, x2, y2, z2;\n  m = m || identity3();\n\n  // Calculate coefficients\n  x2 = q[1] + q[1];\n  y2 = q[2] + q[2];\n  z2 = q[3] + q[3];\n  xx = q[1] * x2;\n  xy = q[1] * y2;\n  xz = q[1] * z2;\n  yy = q[2] * y2;\n  yz = q[2] * z2;\n  zz = q[3] * z2;\n  wx = q[0] * x2;\n  wy = q[0] * y2;\n  wz = q[0] * z2;\n\n  m[M300] = 1.0 - (yy + zz);\n  m[M301] = xy - wz;\n  m[M302] = xz + wy;\n\n  m[M310] = xy + wz;\n  m[M311] = 1.0 - (xx + zz);\n  m[M312] = yz - wx;\n\n  m[M320] = xz - wy;\n  m[M321] = yz + wx;\n  m[M322] = 1.0 - (xx + yy);\n\n  return m;\n}\n\n/**\n * Produces a transform matrix from a returned unit quaternion. This is a matrix\n * that is from a 'models' perspective where the model orients itself to match\n * the orientation.\n */\nexport function matrix4x4FromUnitQuatModel(q: Quaternion, m?: Mat4x4): Mat4x4 {\n  let wx, wy, wz, xx, yy, yz, xy, xz, zz, x2, y2, z2;\n  m = m || identity4();\n\n  // calculate coefficients\n  x2 = q[1] + q[1];\n  y2 = q[2] + q[2];\n  z2 = q[3] + q[3];\n  xx = q[1] * x2;\n  xy = q[1] * y2;\n  xz = q[1] * z2;\n  yy = q[2] * y2;\n  yz = q[2] * z2;\n  zz = q[3] * z2;\n  wx = q[0] * x2;\n  wy = q[0] * y2;\n  wz = q[0] * z2;\n\n  m[M400] = 1.0 - (yy + zz);\n  m[M401] = xy - wz;\n  m[M402] = xz + wy;\n  m[M403] = 0.0;\n\n  m[M410] = xy + wz;\n  m[M411] = 1.0 - (xx + zz);\n  m[M412] = yz - wx;\n  m[M413] = 0.0;\n\n  m[M420] = xz - wy;\n  m[M421] = yz + wx;\n  m[M422] = 1.0 - (xx + yy);\n  m[M423] = 0.0;\n\n  m[M430] = 0;\n  m[M431] = 0;\n  m[M432] = 0;\n  m[M433] = 1;\n\n  return m;\n}\n\n/**\n * Produces a transform matrix from a returned unit quaternion. This is a matrix\n * that is from a 'views' perspective where the world orients to match the view.\n */\nexport function matrix3x3FromUnitQuatView(q: Quaternion, m?: Mat3x3): Mat3x3 {\n  let wx, wy, wz, xx, yy, yz, xy, xz, zz, x2, y2, z2;\n  m = m || identity3();\n\n  // calculate coefficients\n  x2 = q[1] + q[1];\n  y2 = q[2] + q[2];\n  z2 = q[3] + q[3];\n  xx = q[1] * x2;\n  xy = q[1] * y2;\n  xz = q[1] * z2;\n  yy = q[2] * y2;\n  yz = q[2] * z2;\n  zz = q[3] * z2;\n  wx = q[0] * x2;\n  wy = q[0] * y2;\n  wz = q[0] * z2;\n\n  m[M300] = 1.0 - (yy + zz);\n  m[M310] = xy - wz;\n  m[M320] = xz + wy;\n\n  m[M301] = xy + wz;\n  m[M311] = 1.0 - (xx + zz);\n  m[M321] = yz - wx;\n\n  m[M302] = xz - wy;\n  m[M312] = yz + wx;\n  m[M322] = 1.0 - (xx + yy);\n\n  return m;\n}\n\n/**\n * Produces a transform matrix from a returned unit quaternion. This is a matrix\n * that is from a 'views' perspective where the world orients to match the view.\n */\nexport function matrix4x4FromUnitQuatView(q: Quaternion, m?: Mat4x4): Mat4x4 {\n  let wx, wy, wz, xx, yy, yz, xy, xz, zz, x2, y2, z2;\n  m = m || identity4();\n\n  // calculate coefficients\n  x2 = q[1] + q[1];\n  y2 = q[2] + q[2];\n  z2 = q[3] + q[3];\n  xx = q[1] * x2;\n  xy = q[1] * y2;\n  xz = q[1] * z2;\n  yy = q[2] * y2;\n  yz = q[2] * z2;\n  zz = q[3] * z2;\n  wx = q[0] * x2;\n  wy = q[0] * y2;\n  wz = q[0] * z2;\n\n  m[M400] = 1.0 - (yy + zz);\n  m[M410] = xy - wz;\n  m[M420] = xz + wy;\n  m[M430] = 0.0;\n\n  m[M401] = xy + wz;\n  m[M411] = 1.0 - (xx + zz);\n  m[M421] = yz - wx;\n  m[M431] = 0.0;\n\n  m[M402] = xz - wy;\n  m[M412] = yz + wx;\n  m[M422] = 1.0 - (xx + yy);\n  m[M432] = 0.0;\n\n  m[M403] = 0;\n  m[M413] = 0;\n  m[M423] = 0;\n  m[M433] = 1;\n\n  return m;\n}\n\n/**\n * Converts Euler angles [roll(X), pitch(Y), yaw(Z)]\n */\nexport function eulerToQuat(\n  angles: EulerRotation,\n  out?: Quaternion\n): Quaternion {\n  out = out || zeroQuat();\n  let cr, cp, cy, sr, sp, sy, cpcy, spsy, cpsy, spcy;\n  const [roll, pitch, yaw] = angles;\n\n  // calculate trig identities\n  cr = cos(roll / 2);\n  cp = cos(pitch / 2);\n  cy = cos(yaw / 2);\n  sr = sin(roll / 2);\n  sp = sin(pitch / 2);\n  sy = sin(yaw / 2);\n  cpcy = cp * cy;\n  spsy = sp * sy;\n  cpsy = cp * sy;\n  spcy = sp * cy;\n  out[0] = cr * cpcy + sr * spsy;\n  out[1] = sr * cpcy - cr * spsy;\n  out[2] = cr * spcy + sr * cpsy;\n  out[3] = cr * cpsy - sr * spcy;\n\n  return out;\n}\n\n/**\n * This produces a quaternion that creates an orientation that will look in the\n * direction specified.\n */\nexport function lookAtQuat(\n  forward: Vec3Compat,\n  up: Vec3Compat,\n  q?: Quaternion\n): Quaternion {\n  q = q || zeroQuat();\n  vz = normalize3([-forward[0], -forward[1], -forward[2]], V3R[V3R.length - 1]);\n  vx = normalize3(cross3(up, vz, V3R[V3R.length - 2]));\n  vy = cross3(vz, vx, V3R[V3R.length - 3]);\n\n  m11 = vx[0];\n  m12 = vy[0];\n  m13 = vz[0];\n  m21 = vx[1];\n  m22 = vy[1];\n  m23 = vz[1];\n  m31 = vx[2];\n  m32 = vy[2];\n  m33 = vz[2];\n\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  w = (1 + m11 + m22 + m33) * 0.25; // w^2\n\n  if (w > 0.0) {\n    w = Math.sqrt(w);\n    q[0] = w;\n    w = 1 / (4 * w);\n    q[1] = (m23 - m32) * w;\n    q[2] = (m31 - m13) * w;\n    q[3] = (m12 - m21) * w;\n  } else {\n    q[0] = 0;\n    w = -0.5 * (m22 + m33); // x^2\n\n    if (w > 0) {\n      w = Math.sqrt(w);\n      q[1] = w;\n      w *= 2;\n      q[2] = m12 / w;\n      q[3] = m13 / w;\n    } else {\n      q[1] = 0;\n      w = 0.5 * (1 - m33); // y^2\n\n      if (w > 0) {\n        w = Math.sqrt(w);\n        q[2] = w;\n        q[3] = m23 / (2 * w);\n      } else {\n        q[2] = 0;\n        q[3] = 1;\n      }\n    }\n  }\n\n  return q;\n}\n\nexport function matrix3x3ToQuaternion(mat: Mat3x3, q?: Quaternion): Quaternion {\n  q = q || zeroQuat();\n\n  m00 = mat[0];\n  m01 = mat[3];\n  m02 = mat[6];\n  m10 = mat[1];\n  m11 = mat[4];\n  m12 = mat[7];\n  m20 = mat[2];\n  m21 = mat[5];\n  m22 = mat[8];\n\n  w = m00 + m11 + m22;\n\n  if (w > 0.0) {\n    const s = sqrt(w + 1.0) * 2;\n    q[0] = 0.25 * s;\n    q[1] = (m21 - m12) / s;\n    q[2] = (m02 - m20) / s;\n    q[3] = (m10 - m01) / s;\n\n    return q;\n  }\n\n  if (m00 > m11 && m00 > m22) {\n    const s = sqrt(1.0 + m00 - m11 - m22) * 2;\n    q[0] = (m21 - m12) / s;\n    q[1] = 0.25 * s;\n    q[2] = (m01 + m10) / s;\n    q[3] = (m02 + m20) / s;\n\n    return q;\n  }\n\n  if (m11 > m22) {\n    const s = sqrt(1.0 + m11 - m00 - m22) * 2;\n\n    q[0] = (m02 - m20) / s;\n    q[1] = (m10 + m01) / s;\n    q[2] = 0.25 * s;\n    q[3] = (m21 + m12) / s;\n\n    return q;\n  }\n\n  const s = sqrt(1.0 + m22 - m00 - m11) * 2;\n  q[0] = (m10 - m01) / s;\n  q[1] = (m20 + m02) / s;\n  q[2] = (m21 + m12) / s;\n  q[3] = 0.25 * s;\n\n  return q;\n}\n\nexport function matrix4x4ToQuaternion(mat: Mat4x4, q?: Quaternion): Quaternion {\n  q = q || zeroQuat();\n\n  m00 = mat[0];\n  m01 = mat[4];\n  m02 = mat[8];\n  m10 = mat[1];\n  m11 = mat[5];\n  m12 = mat[9];\n  m20 = mat[2];\n  m21 = mat[6];\n  m22 = mat[10];\n\n  w = m00 + m11 + m22;\n\n  if (w > 0.0) {\n    const s = sqrt(w + 1.0) * 2;\n    q[0] = 0.25 * s;\n    // num = 0.5 / num;\n    q[1] = (m21 - m12) / s;\n    q[2] = (m02 - m20) / s;\n    q[3] = (m10 - m01) / s;\n\n    return q;\n  }\n\n  if (m00 > m11 && m00 > m22) {\n    // const num7 = sqrt(1.0 + m00 - m11 - m22);\n    // const num4 = 0.5 / num7;\n    const s = sqrt(1.0 + m00 - m11 - m22) * 2;\n    q[0] = (m21 - m12) / s;\n    q[1] = 0.25 * s;\n    q[2] = (m01 + m10) / s;\n    q[3] = (m02 + m20) / s;\n\n    return q;\n  }\n\n  if (m11 > m22) {\n    // const num6 = sqrt(1.0 + m11 - m00 - m22);\n    // const num3 = 0.5 / num6;\n    const s = sqrt(1.0 + m11 - m00 - m22) * 2;\n\n    q[0] = (m02 - m20) / s;\n    q[1] = (m10 + m01) / s;\n    q[2] = 0.25 * s;\n    q[3] = (m21 + m12) / s;\n\n    return q;\n  }\n\n  // const num5 = sqrt(1.0 + m22 - m00 - m11);\n  // const num2 = 0.5 / num5;\n  const s = sqrt(1.0 + m22 - m00 - m11) * 2;\n  q[0] = (m10 - m01) / s;\n  q[1] = (m20 + m02) / s;\n  q[2] = (m21 + m12) / s;\n  q[3] = 0.25 * s;\n\n  return q;\n}\n\n/**\n * This decomposes the rotational component of a matrix into a quaternion.\n * You must provide the scale magnitudes of the matrix for the operation to\n * work. This means getting:\n * sx = length4(row0);\n * sy = length4(row1);\n * sz = length4(row2);\n */\nexport function decomposeRotation(\n  mat: Mat4x4,\n  sx: number,\n  sy: number,\n  sz: number,\n  q?: Quaternion\n) {\n  q = q || zeroQuat();\n\n  m11 = mat[0] / sx;\n  m12 = mat[4] / sy;\n  m13 = mat[8] / sz;\n  m21 = mat[1] / sx;\n  m22 = mat[5] / sy;\n  m23 = mat[9] / sz;\n  m31 = mat[2] / sx;\n  m32 = mat[6] / sy;\n  m33 = mat[10] / sz;\n\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  w = (1 + m11 + m22 + m33) * 0.25; // w^2\n\n  if (w > 0.0) {\n    w = Math.sqrt(w);\n    q[0] = w;\n    w = 1 / (4 * w);\n    q[1] = (m23 - m32) * w;\n    q[2] = (m31 - m13) * w;\n    q[3] = (m12 - m21) * w;\n  } else {\n    q[0] = 0;\n    w = -0.5 * (m22 + m33); // x^2\n\n    if (w > 0) {\n      w = Math.sqrt(w);\n      q[1] = w;\n      w *= 2;\n      q[2] = m12 / w;\n      q[3] = m13 / w;\n    } else {\n      q[1] = 0;\n      w = 0.5 * (1 - m33); // y^2\n\n      if (w > 0) {\n        w = Math.sqrt(w);\n        q[2] = w;\n        q[3] = m23 / (2 * w);\n      } else {\n        q[2] = 0;\n        q[3] = 1;\n      }\n    }\n  }\n\n  return q;\n}\n\nexport function lookAtMatrix(\n  forward: Vec3Compat,\n  up: Vec3Compat,\n  m?: Mat4x4\n): Mat4x4 {\n  m = m || identity4();\n\n  const z = normalize3([-forward[0], -forward[1], -forward[2]]);\n  const x = normalize3(cross3(up, z));\n  // No need to normalize the cross product as z and x are unit vectors at this\n  // point\n  const y = cross3(z, x);\n\n  m[0] = x[0];\n  m[1] = y[0];\n  m[2] = z[0];\n  m[3] = 0.0;\n  m[4] = x[1];\n  m[5] = y[1];\n  m[6] = z[1];\n  m[7] = 0.0;\n  m[8] = x[2];\n  m[9] = y[2];\n  m[10] = z[2];\n  m[11] = 0.0;\n  m[12] = 0.0;\n  m[13] = 0.0;\n  m[14] = 0.0;\n  m[15] = 1.0;\n\n  return m;\n}\n\n/**\n * Rotates a vector using some nice tricks with a quaternion's value.\n */\nexport function rotateVectorByUnitQuat(v: Vec3, q: Quaternion, out?: Vec3) {\n  vx = vec3(q[1], q[2], q[3]);\n  w = q[0];\n\n  return add3(\n    add3(scale3(vx, 2 * dot3(vx, v)), scale3(v, w * w - dot3(vx, vx))),\n    scale3(cross3(vx, v), 2 * w),\n    out\n  );\n}\n\n/**\n * SLERP interpolation between two quaternion orientations. The Quaternions MUST\n * be unit quats for this to be valid. If the quat has gotten out of\n * normalization from precision errors, consider renormalizing the quaternion.\n */\nexport function slerpUnitQuat(\n  from: Quaternion,\n  to: Quaternion,\n  t: number,\n  out?: Quaternion\n): Quaternion {\n  out = out || zeroQuat();\n  const to1: Vec4 = [0, 0, 0, 0];\n  let omega, cosom, sinom, scale0, scale1;\n  cosom = from[1] * to[1] + from[2] * to[2] + from[3] * to[3] + from[0] * to[0];\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    to1[0] = -to[1];\n    to1[1] = -to[2];\n    to1[2] = -to[3];\n    to1[3] = -to[0];\n  } else {\n    to1[0] = to[1];\n    to1[1] = to[2];\n    to1[2] = to[3];\n    to1[3] = to[0];\n  }\n\n  // Calculate coefficients for final values. We use SLERP if the difference\n  // between the two angles isn't too big.\n  if (1.0 - cosom > 0.0000001) {\n    omega = acos(cosom);\n    sinom = sin(omega);\n    scale0 = sin((1.0 - t) * omega) / sinom;\n    scale1 = sin(t * omega) / sinom;\n  }\n\n  // We linear interpolate for quaternions that are very close together in\n  // angle.\n  else {\n    scale0 = 1.0 - t;\n    scale1 = t;\n  }\n\n  // calculate final values\n  out[1] = scale0 * from[1] + scale1 * to1[0];\n  out[2] = scale0 * from[2] + scale1 * to1[1];\n  out[3] = scale0 * from[3] + scale1 * to1[2];\n  out[0] = scale0 * from[0] + scale1 * to1[3];\n\n  return out;\n}\n\n/**\n * One basis quaternion\n */\nexport function oneQuat(): Quaternion {\n  return [1, 0, 0, 0];\n}\n\n/**\n * i basis quaternion\n */\nexport function iQuat(): Quaternion {\n  return [0, 1, 0, 0];\n}\n\n/**\n * j basis quaternion\n */\nexport function jQuat(): Quaternion {\n  return [0, 0, 1, 0];\n}\n\n/**\n * i basis quaternion\n */\nexport function kQuat(): Quaternion {\n  return [0, 0, 0, 1];\n}\n","import {\n  add3,\n  copy3,\n  normalize3,\n  scale3,\n  subtract3,\n  Vec3\n} from \"../math/vector\";\n\n/**\n * Represents a ray starting from some origin eminating in a direction. [Origin,\n * Direction]. The direction is a unit vector so:\n *\n * add3(Origin, scale3(Direction, Distance)) is how you would use the ray to\n * find a location in a given direction.\n */\nexport type Ray = [Vec3, Vec3];\n\n/**\n * Create a ray structur from an origin and a direction.\n */\nexport function ray(origin: Vec3, direction: Vec3): Ray {\n  return [origin, direction];\n}\n\n/**\n * Provides a location based on a ray and a given distance away\n */\nexport function rayToLocation(ray: Ray, distance: number, out?: Vec3): Vec3 {\n  out = out || [0, 0, 0];\n\n  return add3(ray[0], scale3(ray[1], distance), out);\n}\n\n/**\n * Generates a ray from two points. Ray starts at 'origin' and points toward\n * 'destination'\n */\nexport function rayFromPoints(origin: Vec3, destination: Vec3, out?: Ray): Ray {\n  out = out || [\n    [0, 0, 0],\n    [0, 0, 0]\n  ];\n  copy3(origin, out[0]);\n  normalize3(subtract3(destination, origin), out[1]);\n\n  return out;\n}\n","/**\n * Shallow comparison of two objects\n */\nexport function shallowCompare(objA: any, objB: any) {\n  if (!objA || !objB) {\n    return objA === objB;\n  }\n\n  return !Boolean(\n    Object.keys(Object.assign({}, objA, objB)).find(\n      key => objA[key] !== objB[key]\n    )\n  );\n}\n","/**\n * Performs a splice operation like an array on a string. Does not mutate original string.\n */\nfunction spliceStr(str: string, index: number, count: number, add?: string) {\n  // We cannot pass negative indexes directly to the 2nd slicing operation.\n  if (index < 0) {\n    index = str.length + index;\n    if (index < 0) {\n      index = 0;\n    }\n  }\n\n  return str.slice(0, index) + (add || \"\") + str.slice(index + count);\n}\n\n/**\n * Removes comments from a valid shader source string\n */\nexport function removeComments(str: string): string {\n  // We now must count valid context brackets till we find a bracket that would\n  // close the context of the main body.\n  let insideMultilineComment = false;\n  let insideSingleLineComment = false;\n\n  const comments = [];\n  let currentMultiline = { start: -1, stop: -1 };\n  let currentSingleLine = { start: -1, stop: -1 };\n\n  // When openBracket === close bracket, we have the location of the end of the\n  // body of the main method\n  for (let i = 0, iMax = str.length; i < iMax; ++i) {\n    const char = str[i];\n    const nextChar = str[i + 1];\n\n    // Analyze each character for comments and valid bracket contexts\n    switch (char) {\n      case \"/\":\n        switch (nextChar) {\n          case \"*\":\n            if (!insideSingleLineComment && !insideMultilineComment) {\n              currentMultiline.start = i;\n              insideMultilineComment = true;\n              i++;\n            }\n            break;\n\n          case \"/\":\n            if (!insideMultilineComment && !insideSingleLineComment) {\n              currentSingleLine.start = i;\n              insideSingleLineComment = true;\n              i++;\n            }\n            break;\n        }\n        break;\n\n      case \"*\":\n        if (nextChar === \"/\") {\n          if (insideMultilineComment) {\n            currentMultiline.stop = i + 2;\n            comments.push(currentMultiline);\n            currentMultiline = { start: -1, stop: -1 };\n            insideMultilineComment = false;\n            i++;\n          }\n        }\n        break;\n\n      case \"\\n\":\n      case \"\\r\":\n        if (insideSingleLineComment) {\n          // console.log('STOP SINGLE LINE');\n          currentSingleLine.stop = i;\n          comments.push(currentSingleLine);\n          currentSingleLine = { start: -1, stop: -1 };\n          insideSingleLineComment = false;\n        }\n        break;\n    }\n  }\n\n  // Our indices discovered are ascending in nature, so we must remove them\n  // descending\n  comments.reverse();\n\n  comments.forEach(comment => {\n    str = spliceStr(str, comment.start, comment.stop - comment.start);\n  });\n\n  return str;\n}\n","/**\n * This file is dedicted to the all important step of processing desired inputs\n * from the layer and coming up with automated generated uniforms and attributes\n * that the shader's will need in order to operate with the conveniences the\n * library offers. This includes things such as injecting camera projection\n * uniforms, resource uniforms, animation adjustments etc etc.\n */\nimport { Instance } from \"../../instance-provider/instance\";\nimport { ILayerProps, Layer } from \"../../surface/layer\";\nimport { BaseIOExpansion } from \"../../surface/layer-processing/base-io-expansion\";\nimport {\n  IInstanceAttribute,\n  IShaderInitialization,\n  IUniform,\n  IUniformInternal,\n  IVertexAttribute,\n  IVertexAttributeInternal\n} from \"../../types\";\nimport { BaseIOSorting } from \"./base-io-sorting\";\nimport { packAttributes } from \"./pack-attributes\";\nimport { ProcessShaderImportResults } from \"./shader-processor\";\n\n/**\n * Instance attribute typeguard\n */\nfunction isInstanceAttribute<T extends Instance>(\n  attr: any\n): attr is IInstanceAttribute<T> {\n  return Boolean(attr);\n}\n\n/**\n * Vertex attribute typeguard\n */\nfunction isVertexAttribute(attr: any): attr is IVertexAttribute {\n  return Boolean(attr);\n}\n\n/**\n * Uniform typeguard\n */\nfunction isUniform(attr: any): attr is IUniform {\n  return Boolean(attr);\n}\n\n/**\n * Converts a layer's vertex to the internal vertex structure used by the\n * framework.\n */\nfunction toVertexAttributeInternal(\n  attribute: IVertexAttribute\n): IVertexAttributeInternal {\n  return Object.assign({}, attribute, { materialAttribute: null });\n}\n\n/**\n * Converts a layer's uniform to the internal uniform structure used by the\n * framework.\n */\nfunction toUniformInternal(uniform: IUniform): IUniformInternal {\n  return Object.assign({}, uniform, { materialUniforms: [] });\n}\n\n/**\n * This processes instance attributes and performs some basic validation on them\n * to ensure their properties are sane and expected for rendering.\n */\nfunction validateInstanceAttributes<T extends Instance>(\n  layer: Layer<T, any>,\n  instanceAttributes: IInstanceAttribute<T>[],\n  vertexAttributes: IVertexAttribute[],\n  _uniforms: IUniform[]\n) {\n  instanceAttributes.forEach(attribute => {\n    if (attribute.name === undefined) {\n      console.warn(\n        \"All instance attributes MUST have a name on Layer:\",\n        layer.id\n      );\n    }\n\n    if (\n      instanceAttributes.find(\n        attr => attr !== attribute && attr.name === attribute.name\n      )\n    ) {\n      console.warn(\n        \"An instance attribute can not have the same name used more than once:\",\n        attribute.name\n      );\n    }\n\n    if (vertexAttributes.find(attr => attr.name === attribute.name)) {\n      console.warn(\n        \"An instance attribute and a vertex attribute in a layer can not share the same name:\",\n        attribute.name\n      );\n    }\n\n    if (!attribute.resource) {\n      if (attribute.size === undefined) {\n        console.warn(\"An instance attribute requires the size to be defined.\");\n        console.warn(attribute);\n      }\n    }\n  });\n}\n\n/**\n * This processes the results of shaders importing modules by gathering the\n * attributes and uniforms that arose from them.\n */\nfunction gatherIOFromShaderModules<\n  T extends Instance,\n  U extends ILayerProps<T>\n>(\n  layer: Layer<T, U>,\n  shaderIO: IShaderInitialization<T>,\n  importResults: ProcessShaderImportResults\n) {\n  if (!importResults) return;\n\n  // Get the existing items from the IO\n  let moduleInstanceAttributes = shaderIO.instanceAttributes || [];\n  let moduleUniforms = shaderIO.uniforms || [];\n  let moduleVertexAttributes = shaderIO.vertexAttributes || [];\n\n  // Add in the module requested items\n  importResults.shaderModuleUnits.forEach(unit => {\n    if (unit.instanceAttributes) {\n      moduleInstanceAttributes = moduleInstanceAttributes.concat(\n        unit.instanceAttributes(layer)\n      );\n    }\n\n    if (unit.uniforms) {\n      moduleUniforms = moduleUniforms.concat(unit.uniforms(layer));\n    }\n\n    if (unit.vertexAttributes) {\n      moduleVertexAttributes = moduleVertexAttributes.concat(\n        unit.vertexAttributes(layer)\n      );\n    }\n  });\n\n  // Dedup any element by name and show warnings when any item is overridden\n  const uniformNames = new Set<string>();\n  const instanceAttributeNames = new Set<string>();\n  const vertexAttributeNames = new Set<string>();\n\n  moduleUniforms.filter(uniform => {\n    if (uniform) {\n      if (uniformNames.has(uniform.name)) {\n        console.warn(\n          \"Included shader modules has introduced duplicate uniform names:\",\n          uniform.name,\n          \"One will be overridden thus causing a potential crash of the shader.\"\n        );\n        return false;\n      }\n\n      uniformNames.add(uniform.name);\n\n      return true;\n    }\n\n    return false;\n  });\n\n  moduleInstanceAttributes.filter(attribute => {\n    if (attribute) {\n      if (instanceAttributeNames.has(attribute.name)) {\n        console.warn(\n          \"Included shader modules has introduced duplicate Instance Attribute names:\",\n          attribute.name,\n          \"One will be overridden thus causing a potential crash of the shader.\"\n        );\n        return false;\n      }\n\n      instanceAttributeNames.add(attribute.name);\n\n      return true;\n    }\n\n    return false;\n  });\n\n  moduleVertexAttributes.filter(attribute => {\n    if (attribute) {\n      if (vertexAttributeNames.has(attribute.name)) {\n        console.warn(\n          \"Included shader modules has introduced duplicate Vertex Attribute names:\",\n          attribute.name,\n          \"One will be overridden thus causing a potential crash of the shader.\"\n        );\n        return false;\n      }\n\n      vertexAttributeNames.add(attribute.name);\n\n      return true;\n    }\n\n    return false;\n  });\n\n  // Apply any changes to the IO object\n  shaderIO.instanceAttributes = moduleInstanceAttributes;\n  shaderIO.uniforms = moduleUniforms;\n  shaderIO.vertexAttributes = moduleVertexAttributes;\n}\n\n/**\n * This is the primary method that analyzes all shader IO and determines which\n * elements needs to be automatically injected into the shader.\n *\n * @param gl The WebGL context this is being utilized on behalf of.\n * @param layer The layer who's ShaderIO we're analyzing and developing.\n * @param shaderIO The initial ShaderIO the layer has provided.\n * @param ioExpansion The list of BaseIOExpansion objects we will use to expand\n *                    and process the layer's initial Shader IO\n * @param sortIO  The methods to sort the IO configurations\n * @param importResults The Shader IO object provided by the layer after it's\n *                      had it's imports analyzed from the provided shader.\n */\nexport function injectShaderIO<T extends Instance, U extends ILayerProps<T>>(\n  gl: WebGLRenderingContext,\n  layer: Layer<T, U>,\n  shaderIO: IShaderInitialization<T>,\n  ioExpansion: BaseIOExpansion[],\n  sortIO: BaseIOSorting,\n  importResults: ProcessShaderImportResults\n) {\n  // After processing imports, we can now include any uniforms, or attributes\n  // the shader modules requested to be included in the layer so that the\n  // modules can operate properly. This mostly includes items such as times,\n  // projection matrices etc that the system should be providing rather than the\n  // layer\n  gatherIOFromShaderModules(layer, shaderIO, importResults);\n\n  // All of the instance attributes with nulls filtered out\n  const instanceAttributes = (shaderIO.instanceAttributes || []).filter(\n    isInstanceAttribute\n  );\n  // All of the vertex attributes with nulls filtered out\n  const vertexAttributes = (shaderIO.vertexAttributes || []).filter(\n    isVertexAttribute\n  );\n  // All of the uniforms with nulls filtered out\n  const uniforms = (shaderIO.uniforms || []).filter(isUniform);\n\n  // Now we process all of the custom attribute expansion specified by the\n  // surface to process the layer's IO to make special features with the\n  // attributes operate correctly.\n  for (let i = 0, iMax = ioExpansion.length; i < iMax; ++i) {\n    const expansion = ioExpansion[i];\n\n    // Do special expansion validation for attributes that may meet the criteria\n    // of the expander. If the validation fails, then we skip performing the\n    // expansion as it would result in invalid or undefined behavior. This\n    // validation method should provide all of the logged output necessary to\n    // determine why the configuration was wrong.\n    if (\n      expansion.validate(layer, instanceAttributes, vertexAttributes, uniforms)\n    ) {\n      // Perform the expansion\n      const extraIO = expansion.expand(\n        layer,\n        instanceAttributes,\n        vertexAttributes,\n        uniforms\n      );\n      // Now we add in the extra IO discovered\n      extraIO.instanceAttributes\n        .filter(isInstanceAttribute)\n        .forEach(attr => instanceAttributes.push(attr));\n      extraIO.vertexAttributes\n        .filter(isVertexAttribute)\n        .forEach(attr => vertexAttributes.push(attr));\n      extraIO.uniforms.filter(isUniform).forEach(attr => uniforms.push(attr));\n    }\n  }\n\n  // Do a final validation pass of the attributes injected so we can provide\n  // feedback as to why things behave odd\n  validateInstanceAttributes(\n    layer,\n    instanceAttributes,\n    vertexAttributes,\n    uniforms\n  );\n\n  // Gather instance attributes in such a way to not be mutated\n  const allInstanceAttributes = instanceAttributes.slice(0);\n  // Make sure the vertex attributes are internal attributes at this point\n  const allVertexAttributes = (vertexAttributes || []).map(\n    toVertexAttributeInternal\n  );\n  // Convert our uniforms to the internal structure they need to be\n  const allUniforms = uniforms.map(toUniformInternal);\n\n  // Apply the sorting\n  allInstanceAttributes.sort(sortIO.sortInstanceAttributes);\n  allUniforms.sort(sortIO.sortUniforms);\n  allVertexAttributes.sort(sortIO.sortVertexAttributes);\n\n  // Let's pack in our attributes automagically so we can determine block and\n  // block indices.\n  packAttributes(allInstanceAttributes);\n  // Before we make the vertex attributes, we must determine the buffering\n  // strategy our layer will utilize\n  layer.getLayerBufferType(gl, vertexAttributes, allInstanceAttributes);\n\n  return {\n    instanceAttributes: allInstanceAttributes,\n    uniforms: allUniforms,\n    vertexAttributes: allVertexAttributes\n  };\n}\n","/**\n * The purpose of this file and processes is to take a layers attributes and\n * instance attributes and optimally pack them into blocks. As it should be\n * known an attribute and a uniform is limited by the hardware in 'blocks'. Each\n * block for webgl 1.0 is 4 floats. If you use a single float and not the rest,\n * you have used an entire block.\n *\n * Thus, we pack down the attributes into appropriate block indices and slots.\n */\n\nimport { Instance } from \"../../instance-provider/instance\";\nimport { IInstanceAttribute, InstanceAttributeSize } from \"../../types\";\n\n/**\n * A quick representation of an available block with a convenience method to\n * easily apply metrics to an attribute if it fits.\n */\nclass Block<T extends Instance> {\n  index: number = 0;\n  available: number = 4;\n\n  constructor(blockIndex: number) {\n    this.index = blockIndex;\n  }\n\n  setAttribute(attr: IInstanceAttribute<T>) {\n    if ((attr.size || 0) <= this.available) {\n      attr.block = this.index;\n      attr.blockIndex = 4 - this.available;\n      this.available -= attr.size || 0;\n\n      return true;\n    }\n\n    return false;\n  }\n}\n\n/**\n * This loops through all attributes and ensures each attribute is applied\n */\nfunction ensureSizes<T extends Instance>(attributes: IInstanceAttribute<T>[]) {\n  attributes.forEach(attr => {\n    if (attr.resource && attr.size === undefined) {\n      attr.size = InstanceAttributeSize.FOUR;\n    }\n\n    // If the size of the attribute is not determiend at this point, we do our\n    // best to find it by whatever means possible\n    if (!attr.size) {\n      try {\n        // We inject a very phoney instance, we don't need accurate data, we\n        // will be happy if we get an array of undefineds which should be in\n        // line with the size of the attribute.\n        const check = attr.update(new Instance({}) as T);\n\n        // We see if the output is sane\n        if (check.length > 0 && check.length <= InstanceAttributeSize.FOUR) {\n          attr.size = check.length;\n        }\n      } catch (err) {\n        console.warn(\n          \"The system could not determine the size of the provided attribute. Please provide the size of the attribute:\",\n          attr\n        );\n      }\n    }\n  });\n}\n\n/**\n * This is the packing method that calculates the block and block index best\n * suited for an attribute so a layer developer does not have to worry about it.\n */\nexport function packAttributes<T extends Instance>(\n  attributes: IInstanceAttribute<T>[]\n) {\n  // First make sure each attribute has a size\n  ensureSizes(attributes);\n  // Keep a list of the blocks we have decided needs to be in use\n  const blocks: Block<T>[] = [];\n\n  // Loop through all attributes and pack em' in\n  attributes.forEach(attr => {\n    // A matrix 4x4 is a special case where it requires 4 consecutive blocks to\n    // work correctly\n    if (attr.size && attr.size === InstanceAttributeSize.MAT4X4) {\n      attr.block = blocks.length;\n      attr.blockIndex = 0;\n\n      // We know any block that gets created instantly receives some content.\n      // Thus we know to fit the matrix we need to simply immediately create 4\n      // blocks.\n      for (let i = 0; i < 4; ++i) {\n        const newBlock = new Block(blocks.length);\n        newBlock.available = 0;\n        newBlock.index = 0;\n        blocks.push(newBlock);\n      }\n\n      return;\n    }\n\n    // Look for a block that can fit our attribute\n    const block = blocks.find(block => {\n      if (block.setAttribute(attr)) {\n        return Boolean(block);\n      }\n\n      return false;\n    });\n\n    // If our attribute did not fit into any of the existing blocks, then we\n    // must create a new block to stuff our attribute into.\n    if (!block) {\n      const newBlock = new Block(blocks.length);\n      blocks.push(newBlock);\n\n      if (!newBlock.setAttribute(attr)) {\n        console.warn(\n          \"There was a problem packing an attribute into a block. No block would accommodate it:\",\n          attr\n        );\n      }\n    }\n  });\n}\n","import { ShaderInjectionTarget } from \"../../types\";\nimport { shaderTemplate } from \"../../util/shader-templating\";\nimport {\n  ShaderModuleUnit,\n  ShaderModuleUnitOptions\n} from \"./shader-module-unit\";\n\nconst debug = require(\"debug\")(\"performance\");\nconst debugModuleVS = require(\"debug\")(\"shader-module-vs\");\nconst debugModuleFS = require(\"debug\")(\"shader-module-fs\");\n\n/**\n * This is the results expected from a compile() operation from the\n * ShaderModule.\n */\nexport interface IShaderCompileResults {\n  /** Error messages generated from analyzing the shaders */\n  errors: string[];\n  /** The generated shader from analyzing the module */\n  shader: string | null;\n  /** The shader module units discovered during the processing of the module */\n  shaderModuleUnits: Set<ShaderModuleUnit>;\n}\n\n/**\n * The partial token that must be matched to indicate an import statement.\n * (Must be the first non-whitespace word found in the token)\n */\nconst IMPORT_TOKEN = \"import\";\n/**\n * This is a delimiter between the import token and the identifying import id\n * value provided. This must be the next non-whitespace character found after\n * the import token.\n *\n * We allow whitespace between the token and it's delimiter to allow for style\n * preference\n *\n * import: id\n * import:id\n * import : id\n *\n * etc.\n */\nconst IMPORT_DELIMITER = \":\";\n\n/**\n * Tests to see if a ShaderModuleUnit is compatible with a provided Shader\n * Target\n */\nfunction isUnitCompatible(\n  unit: ShaderModuleUnit,\n  target: ShaderInjectionTarget\n) {\n  return (\n    Boolean(unit) &&\n    (unit.compatibility === target ||\n      unit.compatibility === ShaderInjectionTarget.ALL)\n  );\n}\n\n/**\n * This file defines modules for shaders. Shader modules are global to the\n * window context.\n */\nexport class ShaderModule {\n  /**\n   * These are all of the currently registered modules for the Shader Modules\n   */\n  static modules = new Map<\n    string,\n    { fs?: ShaderModuleUnit; vs?: ShaderModuleUnit }\n  >();\n\n  /**\n   * This registers a new ShaderModuleUnit. It makes the module available by\n   * it's importId within shaders using this framework.\n   *\n   * If the module is registered with no returned output, the registration was a\n   * success. Any returned output indicates issues encountered while registering\n   * the module.\n   */\n  static register(\n    unit: ShaderModuleUnit | ShaderModuleUnitOptions | ShaderModuleUnitOptions[]\n  ): string | null {\n    // If the input is just Shader Module Unit options injected, then we simply\n    // handle wrapping the options into a ShaderModuleUnit and do a\n    // registration.\n    if (!(unit instanceof ShaderModuleUnit)) {\n      if (Array.isArray(unit)) {\n        let out = \"\";\n\n        unit.forEach(options => {\n          const output = ShaderModule.register(options);\n          if (output) out += `${output}\\n`;\n        });\n\n        // If there was no output at any time, let's be sure to return a simple\n        // null\n        if (!out) {\n          return null;\n        }\n\n        return out;\n      }\n\n      return ShaderModule.register(new ShaderModuleUnit(unit));\n    }\n\n    let current = ShaderModule.modules.get(unit.moduleId);\n\n    if (!current) {\n      current = {};\n      ShaderModule.modules.set(unit.moduleId, current);\n    }\n\n    const fs = current.fs;\n    const vs = current.vs;\n    const isFSCompatible = isUnitCompatible(\n      unit,\n      ShaderInjectionTarget.FRAGMENT\n    );\n    const isVSCompatible = isUnitCompatible(unit, ShaderInjectionTarget.VERTEX);\n\n    if (fs && isFSCompatible) {\n      if (fs.isFinal) {\n        return `Module ID: ${unit.moduleId} Can not override the module's existing Fragment registration as the exisitng module is marked as final`;\n      }\n\n      debug(\n        \"A Shader Module Unit has overridden an existing module for the Fragment Shader Module ID: %o\",\n        unit.moduleId\n      );\n    }\n\n    if (vs && isVSCompatible) {\n      if (vs.isFinal) {\n        return `Module ID: ${unit.moduleId} Can not override the module's existing Vertex registration as the exisitng module is marked as final`;\n      }\n\n      debug(\n        \"A Shader Module Unit has overridden an existing module for the Vertex Shader Module ID: %o\",\n        unit.moduleId\n      );\n    }\n\n    // Register the module as it passed all scrutiny by this point\n    if (isFSCompatible) {\n      current.fs = unit;\n    }\n\n    if (isVSCompatible) {\n      current.vs = unit;\n    }\n\n    // Lock the unit down indicating it can no longer be modified ever again.\n    unit.lock();\n\n    return null;\n  }\n\n  /**\n   * This gathers all of the dependents for the module as ids. This also causes\n   * the contents of the module to be stripped of it's import statements.\n   */\n  static analyzeDependents(unit: ShaderModuleUnit) {\n    // If the dependents are already established for this unit and it can not be\n    // modified further, then we do not bother to analyze the dependents again.\n    if (unit.dependents && unit.isLocked) {\n      return [];\n    }\n\n    // Gathers error messages found while processing the module\n    const errors: string[] = [];\n    // Stores the dependents in the order they are found in the module\n    const dependents: string[] = [];\n    // Stores all of the unique dependents found for this module\n    const dependentSet = new Set<string>();\n    // Get then compatibility target of the module unit so we can properly see\n    // what modules are available to the unit and what is not.\n    const target = unit.compatibility;\n    // This is the identifier of the module requesting it's dependents\n    const id = unit.moduleId;\n\n    // Here we process the module contents and look for additional import\n    // statements.\n    const templateResults = shaderTemplate({\n      // We do not want any direct replacement options, we will handle token\n      // analyzing via our onToken callback so we can find our special \"import:\"\n      // case\n      options: {},\n      // Provide the shader to our template processor\n      shader: unit.content,\n\n      // We do not want to remove any template macros that do not deal with\n      // extension\n      onToken: token => {\n        const trimmedToken = token.trim();\n\n        // See if the token is the first thing to appear\n        if (trimmedToken.indexOf(IMPORT_TOKEN) === 0) {\n          // Analyze the remainder of the token to find the necessary colon to\n          // be the NEXT Non-whitespace character\n          const afterToken = trimmedToken.substr(IMPORT_TOKEN.length).trim();\n\n          // Make sure the character IS a colon\n          if (afterToken[0] === IMPORT_DELIMITER) {\n            // Indicates if content was properly found for the requested ID\n            let moduleContentFound = false;\n            // At this point, ANYTHING after the colon is the module id being\n            // requested (with white space trimmed) We allow comma delimited\n            // module ids to be specified\n            const moduleIds = afterToken\n              .substr(IMPORT_DELIMITER.length)\n              .trim()\n              .split(\",\");\n\n            // Wealso  allow trailing comma\n            if (moduleIds[moduleIds.length - 1].trim().length === 0) {\n              moduleIds.pop();\n            }\n\n            // Loop through all discovered module ids after the import statement\n            moduleIds.forEach(moduleId => {\n              // Make sure whitespace is cleared\n              moduleId = moduleId.trim();\n              // Get the requested module\n              const mod = ShaderModule.modules.get(moduleId);\n\n              // If we found the module, great! We can store the identifier as a\n              // module associated with this shader string thus reducing\n              // processing time needed for next processing.\n              if (mod) {\n                if (\n                  target === ShaderInjectionTarget.FRAGMENT ||\n                  target === ShaderInjectionTarget.ALL\n                ) {\n                  if (mod.fs) {\n                    moduleContentFound = true;\n\n                    if (!dependentSet.has(moduleId)) {\n                      dependents.push(moduleId);\n                    }\n                  } else {\n                    errors.push(\n                      `Could not find requested target fragment module for Module ID: ${moduleId} requested by module: ${id}`\n                    );\n                  }\n                }\n\n                if (\n                  target === ShaderInjectionTarget.VERTEX ||\n                  target === ShaderInjectionTarget.ALL\n                ) {\n                  if (mod.vs) {\n                    moduleContentFound = true;\n\n                    if (!dependentSet.has(moduleId)) {\n                      dependents.push(moduleId);\n                    }\n                  } else {\n                    errors.push(\n                      `Could not find requested target vertex module for Module ID: ${moduleId} requested by module: ${id}`\n                    );\n                  }\n                }\n\n                if (!mod.vs && !mod.fs) {\n                  errors.push(\n                    \"Could not find a vertex or fragment shader within exisitng module\"\n                  );\n                }\n\n                if (!moduleContentFound) {\n                  errors.push(\n                    `Error Processing module Module ID: ${moduleId} requested by module: ${id}`\n                  );\n                }\n              } else {\n                errors.push(\n                  `Could not find requested module: ${moduleId} requested by module: ${id}`\n                );\n              }\n            });\n\n            // Clear the import token from the body of the shader\n            return \"\";\n          }\n        }\n\n        // Leave any token not processed alone\n        return `$\\{${token}}`;\n      }\n    });\n\n    // Update the content to be stripped of it's import statements\n    unit.applyAnalyzedContent(templateResults.shader);\n    // Update the dependents to include the modules found that this module\n    // requested\n    unit.dependents = dependents;\n\n    return errors;\n  }\n\n  /**\n   * This examines a shader string and replaces all import statements with any\n   * existing registered modules. This will also output any issues such as\n   * requested modules that don't exist and detect circular dependencies and\n   * such ilk.\n   *\n   * @param shader The content of the shader to analyze for import statements\n   * @param target The shader target type to consider\n   * @param additionalModules Additional modules to include in the shader\n   *                          regardless if the shader requested it or not\n   */\n  static process(\n    id: string,\n    shader: string,\n    target: ShaderInjectionTarget,\n    additionalModules?: string[]\n  ): IShaderCompileResults {\n    // The discovered shader module units during processing\n    const shaderModuleUnits = new Set<ShaderModuleUnit>();\n    // This stores the module id's that have already been included in the shader\n    const included = new Set<string>();\n    // This stores the import stack that is currently being processed\n    const processing: (string | null)[] = [];\n    // This is all of the processed errors discovered while resolving imports\n    const errors: string[] = [];\n    // Pick a debugging target based on shader target\n    const debugTarget =\n      target === ShaderInjectionTarget.VERTEX ? debugModuleVS : debugModuleFS;\n    debugTarget(\"Processing Shader for context %o:\", id);\n\n    // Internal checking method of the state of the process to find circular\n    // dependencies\n    function checkCircularDependency(unit: ShaderModuleUnit) {\n      // Get the id of the module being processed for quick reference\n      const id = unit.moduleId;\n      // Debugging for the import id's found along with the current stack\n      debugTarget(\n        \"%o: %o\",\n        id,\n        processing\n          .slice(0)\n          .reverse()\n          .join(\" -> \")\n      );\n\n      // First look to see if the identifier is already in the processing queue.\n      // If it is, we have a heinous circular dependency.\n      const queueIndex = processing.indexOf(id);\n      // Queue up this id as being processed\n      processing.unshift(id);\n\n      // See if the circular dependency is found.\n      if (queueIndex > -1) {\n        // Since we have a queue of our processing path, we can show the\n        // circular dependency path\n        const circularPath = processing.slice(0, queueIndex + 2).reverse();\n        // Spew the blood\n        errors.push(\n          `A Shader has detected a Circular dependency in import requests: ${circularPath.join(\n            \" -> \"\n          )}`\n        );\n        // Remove the id from the queue\n        processing.shift();\n\n        // Return a null flag indicating the process failed.\n        return false;\n      }\n\n      return true;\n    }\n\n    // We place this method as an internal recursive strategy to solving this\n    // issue due to the complexities of the problem at hand. We have shaders\n    // that have tokens analyzed that MUST be immediately resolved to a correct\n    // value. Thus we can not use a process queue to remove the need for the\n    // recursion. Also, as this is a static method, this provides some needed\n    // properties within the context of the function that we do not want exposed\n    // at all, which is impossible to hide within a static context (private\n    // static is not supported).\n    function process(unit: ShaderModuleUnit): string | null {\n      // This is the id of the module unit  currently being processed\n      const id = unit.moduleId;\n\n      // Do the circular dependency check for the module\n      if (!checkCircularDependency(unit)) {\n        return null;\n      }\n\n      // At this point we need to determine if the id has already been included\n      // in the module imports Each import should only be included once so we\n      // prevent duplicate items from showing up\n      if (id && included.has(id)) {\n        // Remove the id from the queue\n        processing.shift();\n\n        // Return empty, but not errored\n        return \"\";\n      }\n\n      // This will store all of the module content that should be injected as\n      // the header\n      let includedModuleContent = \"\";\n      // Make sure the dependents for the module are properly analyzed\n      const dependentsErrors = ShaderModule.analyzeDependents(unit);\n      // Add in any errors discovered during module analysis\n      dependentsErrors.forEach(error => errors.push(error));\n      // Get the dependents for the module for processing\n      const dependents = unit.dependents;\n      debugTarget(\"Module dependencies detected %o\", dependents);\n\n      if (dependents && dependents.length > 0) {\n        for (let i = 0, iMax = dependents.length; i < iMax; ++i) {\n          // The dependent is the id of the module id dependency\n          const moduleId = dependents[i];\n          // Get the requested module\n          const mod = ShaderModule.modules.get(moduleId);\n\n          // If we found the module, great! We can see if the found module has a\n          // compatible target for this module.\n          if (mod) {\n            let moduleContent;\n\n            if (\n              target === ShaderInjectionTarget.FRAGMENT ||\n              target === ShaderInjectionTarget.ALL\n            ) {\n              if (mod.fs) {\n                shaderModuleUnits.add(mod.fs);\n                moduleContent = process(mod.fs);\n              } else {\n                errors.push(\n                  `Could not find requested target fragment module for Module ID: ${moduleId} requested by module: ${id}`\n                );\n              }\n            }\n\n            if (\n              target === ShaderInjectionTarget.VERTEX ||\n              target === ShaderInjectionTarget.ALL\n            ) {\n              if (mod.vs) {\n                shaderModuleUnits.add(mod.vs);\n                moduleContent = process(mod.vs);\n              } else {\n                errors.push(\n                  `Could not find requested target vertex module for Module ID: ${moduleId} requested by module: ${id}`\n                );\n              }\n            }\n\n            if (!mod.vs && !mod.fs) {\n              errors.push(\n                \"Could not find a vertex or fragment shader within exisitng module\"\n              );\n            }\n\n            if (moduleContent === null) {\n              errors.push(\n                `Error Processing module Module ID: ${moduleId} requested by module: ${id}`\n              );\n            }\n\n            // Include the discovered content in the module content output\n            includedModuleContent += moduleContent || \"\";\n          } else {\n            errors.push(\n              `Could not find requested module: ${moduleId} requested by module: ${id}`\n            );\n          }\n        }\n      }\n\n      // Remove the id being processed currently\n      processing.shift();\n      // Add the id to the list of items that have been included\n      included.add(id || \"\");\n\n      // Place the included module content at the top of the shader and return\n      // this module with it's necessary inclusions\n      return `${includedModuleContent.trim()}\\n\\n${unit.content.trim()}`;\n    }\n\n    // We throw in the additional imports  at the top of the shader being\n    // analyzed\n    let modifedShader = shader;\n\n    if (additionalModules) {\n      let imports = \"\";\n\n      additionalModules.forEach(moduleId => {\n        imports += `$\\{import: ${moduleId}}\\n`;\n      });\n\n      modifedShader = imports + shader;\n    }\n\n    // Make our shader a temp module unit to make it compatible with the rest of\n    // the shader module processing\n    const tempShaderModuleUnit = new ShaderModuleUnit({\n      content: modifedShader,\n      compatibility: target,\n      moduleId: `Layer \"${id}\" ${\n        target === ShaderInjectionTarget.ALL\n          ? \"fs vs\"\n          : target === ShaderInjectionTarget.VERTEX\n          ? \"vs\"\n          : \"fs\"\n      }`\n    });\n\n    // Generate the results needed\n    const results = {\n      errors,\n      shader: process(tempShaderModuleUnit),\n      shaderModuleUnits\n    };\n\n    return results;\n  }\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport { ILayerProps, Layer } from \"../../surface/layer\";\nimport {\n  IInstanceAttribute,\n  IUniform,\n  IVertexAttribute,\n  Omit,\n  ShaderInjectionTarget\n} from \"../../types\";\n\n/**\n * This is the message used when a module unit is attempted to be modified after\n * it has been locked down\n */\nconst LOCKED_MODULE_UNIT_MESSAGE =\n  \"Once a ShaderModuleUnit has been registered, you CAN NOT modify it! Module ID:\";\n\n/** Options for the constructor for a new ShaderModuleUnit */\nexport type ShaderModuleUnitOptions = Omit<Partial<ShaderModuleUnit>, \"lock\">;\n\n/**\n * This is a module unit that can be registered as a ShaderModule which the\n * system will use to resolve imports within a shader.\n */\nexport class ShaderModuleUnit {\n  /** This description appears in the generated import snippets for writing GLSL */\n  description: string;\n  private _isLocked: boolean;\n  private _content: string;\n  private _compatibility: ShaderInjectionTarget;\n  private _moduleId: string;\n  private _dependents: string[] | null = null;\n\n  /**\n   * This is the content that replaces shader imports\n   */\n  get content(): string {\n    return this._content;\n  }\n  set content(val: string) {\n    if (this._isLocked) {\n      console.warn(LOCKED_MODULE_UNIT_MESSAGE, this._moduleId);\n      return;\n    }\n\n    this._content = val;\n  }\n\n  /**\n   * This defines which shader type the content is compatible with. You can only\n   * have one content assigned per each ShaderInjectionTarget type. Thus you can\n   * have a module such as 'picking' with two unique implementations one for\n   * Fragment and one for Vertex shaders. Or you can assign it to both.\n   */\n  get compatibility(): ShaderInjectionTarget {\n    return this._compatibility;\n  }\n  set compatibility(val: ShaderInjectionTarget) {\n    if (this._isLocked) {\n      console.warn(LOCKED_MODULE_UNIT_MESSAGE, this._moduleId);\n      return;\n    }\n\n    this._compatibility = val;\n  }\n\n  /**\n   * This is the list of module id dependents this unit will need. We store this\n   * here so the module can be analyzed once. Import statements will be stripped\n   * and the sub module contents will be added to the top of the contents of the\n   * shader. This only stores ids, as the ids will still need to be analyzed so\n   * duplication can be prevented.\n   */\n  get dependents(): string[] | null {\n    return this._dependents;\n  }\n  set dependents(val: string[] | null) {\n    // If this has been locked AND the dependents have been established then\n    // dependents can not be adjusted.\n    if (this._isLocked && this._dependents !== null) {\n      console.warn(LOCKED_MODULE_UNIT_MESSAGE, this._moduleId);\n      return;\n    }\n\n    this._dependents = val;\n  }\n\n  /**\n   * Method for the unit to provide instance attributes for the module\n   */\n  instanceAttributes?<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>\n  ): IInstanceAttribute<T>[];\n\n  /**\n   * Indicates this unit cannot be modified anymore.\n   */\n  isLocked() {\n    return this._isLocked;\n  }\n\n  /**\n   * Allows a module to prevent overrides by another module using the same\n   * moduleId. Attempted overrides will throw warnings.\n   */\n  isFinal?: boolean;\n  /**\n   * This is the string ID a shader must use to include the provided content.\n   */\n  get moduleId(): string {\n    return this._moduleId;\n  }\n  set moduleId(val: string) {\n    if (this._isLocked) {\n      console.warn(LOCKED_MODULE_UNIT_MESSAGE, this._moduleId);\n      return;\n    }\n\n    this._moduleId = val;\n  }\n\n  /**\n   * Method so the unit can provide uniforms for the module.\n   */\n  uniforms?<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>\n  ): IUniform[];\n\n  /**\n   * Method so the unit can provide vertex attributes for the module.\n   */\n  vertexAttributes?<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>\n  ): IVertexAttribute[];\n\n  /**\n   * Default ctor for creating a new Shader Module Unit to be registered with\n   * the system.\n   */\n  constructor(options: ShaderModuleUnitOptions) {\n    Object.assign(this, options);\n  }\n\n  /**\n   * Applies the content after it's been processed for import statements. You\n   * can not set the content this way again after processing has happened.\n   */\n  applyAnalyzedContent(content: string) {\n    if (this._isLocked && this.dependents !== null) {\n      console.warn(LOCKED_MODULE_UNIT_MESSAGE, this._moduleId);\n      return;\n    }\n\n    this._content = content;\n  }\n\n  /**\n   * Makes this unit unable to be modified in anyway\n   */\n  lock() {\n    this._isLocked = true;\n  }\n}\n","export * from \"./buffer-manager-base\";\nexport * from \"./instance-attribute-buffering/instance-attribute-buffer-manager\";\nexport * from \"./instance-attribute-packed-buffering/instance-attribute-packing-buffer-manager\";\nexport * from \"./uniform-buffering/uniform-buffer-manager\";\n","import { AbsolutePosition } from \"../../math/primitives/absolute-position\";\nimport { Camera, CameraProjectionType } from \"../../util/camera\";\n\nexport interface IDefaultElements {\n  /** Default chartting camera */\n  camera: Camera;\n  /** The default viewport that encompasses the entire canvas */\n  viewport: AbsolutePosition;\n}\n\n/**\n * This generates all of the cameras/views/scenes necessary for default viewing of elements.\n *\n * These defaults are required to ensure the following:\n *\n * - Orthographic view\n * - top left corner of the canvas is 0,0\n * - y axis is +y downward\n * - entire canvas is the viewport.\n */\nexport function generateDefaultElements(\n  context: WebGLRenderingContext\n): IDefaultElements {\n  // Generate a default view camera that is\n  // - Orthographic\n  // - (0, 0) is the top left of the canvas\n  // - the y axis is +y going downward\n  const height = context.canvas.height;\n  const width = context.canvas.width;\n  const aspectRatio = width / height;\n\n  const viewport = {\n    aspectRatio: aspectRatio,\n    bottom: -height / 2,\n    far: 10000000,\n    left: -width / 2,\n    near: -100,\n    right: width / 2,\n    top: height / 2,\n    viewSize: height\n  };\n\n  const defaultCamera = new Camera({\n    type: CameraProjectionType.ORTHOGRAPHIC,\n    left: viewport.left,\n    right: viewport.right,\n    top: viewport.top,\n    bottom: viewport.bottom,\n    near: viewport.near,\n    far: viewport.far\n  });\n\n  defaultCamera.scale = [1.0, -1.0, 1.0];\n  defaultCamera.position = [0.0, 0.0, -300.0];\n  defaultCamera.update();\n\n  // This is a viewport that covers the entire context\n  const defaultViewport = {\n    bottom: 0,\n    left: 0,\n    right: 0,\n    top: 0\n  };\n\n  return {\n    camera: defaultCamera,\n    viewport: defaultViewport\n  };\n}\n","import { Attribute } from \"../../gl\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport { MetricsProcessing } from \"../../shaders/processing/metrics-processing\";\nimport { ILayerProps, Layer } from \"../../surface/layer\";\nimport { IViewProps, View } from \"../../surface/view\";\nimport {\n  IInstanceAttribute,\n  IInstancingUniform,\n  IUniform,\n  IVertexAttribute,\n  ShaderInjectionTarget\n} from \"../../types\";\n\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * The result of an injection into the header of a shader. Allows for injection content into the header\n * and provide extra Shader IO such as uniforms and attributes.\n */\nexport type ShaderIOHeaderInjectionResult = {\n  /** The content to inject into the shader */\n  injection: string;\n  /** Additional geometry changes possibly caused by the header injection */\n  geometry?: {\n    attributes: { [key: string]: Attribute };\n  };\n  /** Additional material changes possibly caused by the header injection changes */\n  material?: {\n    uniforms: IInstancingUniform[];\n  };\n};\n\nexport type ShaderDeclarationStatements = Map<string, string>;\n\nexport type ShaderDeclarationStatementLookup = {\n  fs: Map<View<IViewProps>, ShaderDeclarationStatements>;\n  vs: ShaderDeclarationStatements;\n  destructure: ShaderDeclarationStatements;\n};\n\n/**\n * This is the basis to allow the system to have additional shader injection capabilities.\n * This will cover an object or manager that wishes to inject elements into the header of the\n * shader and inject elements after attribute destructuring.\n */\nexport abstract class BaseShaderIOInjection {\n  /**\n   * This is a helper to apply declarations to the input declaration object. This will automatically use the\n   * performance debug output to provide useful information when overrides occur.\n   */\n  setDeclaration(\n    declarations: ShaderDeclarationStatements,\n    key: string,\n    value: string,\n    debugMessageCtx?: string\n  ) {\n    if (declarations.has(key)) {\n      debug(\n        \"%s: Overriding declaration %s\\nSetting new value: %s\",\n        debugMessageCtx || \"Expand IO Declarations\",\n        key,\n        value\n      );\n    }\n\n    declarations.set(key, value);\n  }\n\n  /**\n   * This allows for injection into the header of the shader.\n   *\n   * The order these controllers are injected\n   * into the system determines the order the contents are written to the header. So dependent injections\n   * must be sorted appropriately.\n   *\n   * @param target Specifies which shader type we should be writing the header for. Will be FS OR VS not ALL.\n   * @param declarations This is where the output should register declarations so the system can composite them together.\n   *                     This allows for IO Injections to override each other on declared names and help them set up expectations\n   *                     amongst each other for shader output.\n   * @param layer The layer that is currently being processed\n   * @param metrics Some metrics processed that are useful for making decisions about buffering strategies etc.\n   */\n  abstract processHeaderInjection(\n    target: ShaderInjectionTarget,\n    declarations: ShaderDeclarationStatements,\n    layer: Layer<Instance, ILayerProps<Instance>>,\n    metrics: MetricsProcessing,\n    vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<Instance>[],\n    uniforms: IUniform[]\n  ): ShaderIOHeaderInjectionResult;\n\n  /**\n   * This allows for injection into the shader AFTER attribute destructuring has taken place.\n   *\n   * The order these controllers are injected\n   * into the system determines the order the contents are written to the header. So dependent injections\n   * must be sorted appropriately.\n   *\n   * @param layer The layer that is currently being processed\n   * @param declarations This is where the output should register declarations so the system can composite them together.\n   *                     This allows for IO Injections to override each other on declared names and help them set up expectations\n   *                     amongst each other for shader output.\n   * @param metrics Some metrics processed that are useful for making decisions about buffering strategies etc.\n   */\n  abstract processAttributeDestructuring(\n    layer: Layer<Instance, ILayerProps<Instance>>,\n    declarations: ShaderDeclarationStatements,\n    metrics: MetricsProcessing,\n    vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<Instance>[],\n    uniforms: IUniform[]\n  ): string;\n}\n","import { Instance } from \"../../../instance-provider\";\nimport {\n  AutoEasingLoopStyle,\n  AutoEasingMethod\n} from \"../../../math/auto-easing-method\";\nimport { Vec, VecMath, VecMethods } from \"../../../math/vector\";\nimport {\n  ShaderDeclarationStatements,\n  ShaderIOHeaderInjectionResult\n} from \"../../../shaders/processing/base-shader-io-injection\";\nimport { MetricsProcessing } from \"../../../shaders/processing/metrics-processing\";\nimport { ILayerProps, Layer } from \"../../../surface/layer\";\nimport {\n  FrameMetrics,\n  IEasingInstanceAttribute,\n  IEasingProps,\n  IInstanceAttribute,\n  InstanceAttributeSize,\n  InstanceIOValue,\n  IUniform,\n  IVertexAttribute,\n  ShaderInjectionTarget\n} from \"../../../types\";\nimport { EasingProps } from \"../../../util/easing-props\";\nimport {\n  IShaderTemplateRequirements,\n  shaderTemplate\n} from \"../../../util/shader-templating\";\nimport { BaseIOExpansion, ShaderIOExpansion } from \"../base-io-expansion\";\n\nconst debugCtx = \"EasingIOExpansion\";\n\nconst { abs, max } = Math;\n\nconst BLANK_EASING_PROPS: IEasingProps = {\n  duration: 0,\n  start: [0],\n  end: [0],\n  startTime: 0\n};\n\n/** Converts a size to a shader type */\nconst sizeToType: { [key: number]: string } = {\n  1: \"float\",\n  2: \"vec2\",\n  3: \"vec3\",\n  4: \"vec4\",\n  9: \"mat3\",\n  16: \"mat4\",\n  /** This is the special case for instance attributes that want an atlas resource */\n  99: \"vec4\"\n};\n\n/**\n * These are the templating names used within Auto Easing gpu methods\n */\nconst templateVars = {\n  easingMethod: \"easingMethod\",\n  T: \"T\"\n};\n\n/**\n * Tests an attribute to see if it is an easing attribute\n */\nfunction isEasingAttribute<T extends Instance>(\n  attr: any\n): attr is IEasingInstanceAttribute<T> {\n  return (\n    Boolean(attr) && attr.easing && attr.size !== undefined && attr.size <= 4\n  );\n}\n\n/**\n * Make a utility method to make easing attributes easier to understand how to\n * construct.\n */\nexport function createEasingAttribute<T extends Instance>(\n  attr: Omit<\n    IInstanceAttribute<T>,\n    \"resource\" | \"childAttributes\" | \"parentAttribute\" | \"block\" | \"blockIndex\"\n  > & {\n    easing: AutoEasingMethod<Vec>;\n  }\n) {\n  return attr;\n}\n\n/**\n * This is an expansion handler for easing attributes.\n */\nexport class EasingIOExpansion extends BaseIOExpansion {\n  /** This is used to make it easy to remember an easing attribute's original name */\n  private baseAttributeName = new Map<IInstanceAttribute<Instance>, string>();\n\n  /**\n   * Provides expanded IO for attributes with easing properties.\n   *\n   * Most of this process is hijacking the existing easing attribute to inject it's own\n   * update method to handle calculating current position to animate to a new position\n   * when a value is changed.\n   *\n   * This also provides new child attributes that must be changed when the original attributes\n   * value is changed.\n   */\n  expand<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>,\n    instanceAttributes: IInstanceAttribute<T>[],\n    _vertexAttributes: IVertexAttribute[],\n    _uniforms: IUniform[]\n  ): ShaderIOExpansion<T> {\n    const usedInstanceAttributes = new Set<number>();\n    const easingAttributes: IEasingInstanceAttribute<T>[] = [];\n    const newAttributes: IInstanceAttribute<T>[] = [];\n\n    // We gather all of the easing attributes first so we can modify the attribute array\n    // On next pass\n    for (const attribute of instanceAttributes) {\n      if (isEasingAttribute(attribute)) {\n        easingAttributes.push(attribute);\n      }\n    }\n\n    const easingIds: { [key: string]: number } = {};\n    layer.easingId = easingIds;\n\n    // Now loop through each easing attribute and generate attributes needed for the easing method\n    for (let i = 0, iMax = easingAttributes.length; i < iMax; ++i) {\n      const attribute = easingAttributes[i];\n      const { cpu: easing, loop, uid: providedUID } = attribute.easing;\n      const { name, size, update } = attribute;\n      const easingUID = providedUID;\n\n      // The attribute that is the primary attribute that declares the easing attribute\n      // will become the \"_end\" attribute as whenever it is set, it will change the\n      // destination value of the easing method.\n      this.baseAttributeName.set(attribute, attribute.name);\n      attribute.name = `_${attribute.name}_end`;\n\n      // Make our easing ID lookup so instances can access their easing information for higher level\n      // animation control.\n      easingIds[attribute.name] = easingUID;\n\n      // Ensure the AutoEasing method is unique\n      if (usedInstanceAttributes.has(easingUID)) {\n        console.error(\n          \"Undefined behavior occurs if you reuse an IAutoEasingMethod. Please ensure you are using uid() from the util to give the IAutoEasingMethod its uid, or just use the default provided methods\"\n        );\n      }\n\n      // Flag the uid of the easing method as used\n      usedInstanceAttributes.add(easingUID);\n      // We keep this in a scope above the update as we utilize the fact that the attributes will update\n      // In the order they are declared for a single instance. The attributes will all share this information.\n      const attributeDataShare: { values: IEasingProps } = {\n        values: BLANK_EASING_PROPS\n      };\n\n      // Remove declaring any variables within the scope of the update method for speed\n      let delay: number,\n        attributeDelay: number,\n        attributeDuration: number,\n        duration: number,\n        easingValues: IEasingProps,\n        timeValue: number,\n        end: InstanceIOValue,\n        currentTime: number,\n        frameMetrics: FrameMetrics,\n        values: IEasingProps | undefined,\n        vecMethods: VecMethods<Vec>,\n        instanceEasing: Map<number, IEasingProps>,\n        isContinuous: boolean;\n\n      // Hijack the update from the attribute to a new update method which will\n      // Be able to interact with the values for the easing methodology\n      attribute.update = instance => {\n        frameMetrics = layer.surface.frameMetrics;\n        // We retrieve properties that we want to be dynamic from the easing equation\n        attributeDelay = attribute.easing.delay;\n        attributeDuration = attribute.easing.duration;\n        // First get the value that is to be our new destination\n        end = update(instance);\n        currentTime = frameMetrics.currentTime;\n        // Get the easing values specific to an instance.\n        instance.easing = instanceEasing = instance.easing || new Map();\n        values = instanceEasing.get(easingUID);\n\n        // If the easing values do not exist yet, make them now\n        if (!vecMethods || !values) {\n          // Get all of the vector methods that apply to the provided item\n          vecMethods = VecMath(end);\n\n          values = new EasingProps({\n            duration: attributeDuration,\n            end: vecMethods.copy(end),\n            start: vecMethods.copy(end),\n            startTime: currentTime\n          });\n\n          // Make sure the instance contains the current easing values\n          instanceEasing.set(easingUID, values);\n        }\n\n        // On instance reactivation we want the easing to just be at it's end\n        // value\n        else if (instance.reactivate) {\n          vecMethods.copy(end, values.end);\n          vecMethods.copy(end, values.end);\n          values.startTime = currentTime;\n        }\n\n        // Assign the established values\n        easingValues = values;\n        duration = attributeDuration;\n        delay = attributeDelay;\n\n        if (easingValues.isTimeSet) {\n          duration = easingValues.duration || attributeDuration;\n          delay = easingValues.delay || 0;\n        }\n\n        if (!easingValues.isManualStart) {\n          // Previous position time value\n          timeValue = 1;\n\n          switch (loop) {\n            // Continuous means we start at 0 and let the time go to infinity\n            case AutoEasingLoopStyle.CONTINUOUS:\n              timeValue = (currentTime - easingValues.startTime) / duration;\n              isContinuous = true;\n              break;\n\n            // Repeat means going from 0 to 1 then 0 to 1 etc etc\n            case AutoEasingLoopStyle.REPEAT:\n              timeValue =\n                ((currentTime - easingValues.startTime) / duration) % 1;\n              isContinuous = true;\n              break;\n\n            // Reflect means going from 0 to 1 then 1 to 0 then 0 to 1 etc etc\n            case AutoEasingLoopStyle.REFLECT:\n              const timePassed =\n                (currentTime - easingValues.startTime) / duration;\n              // This is a triangle wave for an input\n              timeValue = abs(((timePassed / 2.0) % 1) - 0.5) * 2.0;\n              isContinuous = true;\n              break;\n\n            // No loop means just linear time\n            case AutoEasingLoopStyle.NONE:\n            default:\n              timeValue = (currentTime - easingValues.startTime) / duration;\n              isContinuous = false;\n              break;\n          }\n\n          // Now get the value of where our instance currently is located this\n          // frame\n          easingValues.start = easing(\n            easingValues.start,\n            easingValues.end,\n            timeValue,\n            easingValues.start\n          );\n        }\n\n        // Set the current time as the start time of our animation\n        easingValues.startTime = currentTime + delay;\n        // Set the provided value as our destination\n        vecMethods.copy(end, easingValues.end);\n        // Update the information shared between this attribute and it's\n        // children\n        attributeDataShare.values = easingValues;\n\n        // Set the layer's animation end time\n        layer.animationEndTime = max(\n          layer.animationEndTime,\n          easingValues.startTime + duration + frameMetrics.frameDuration\n        );\n\n        // Flag the layer's continuous animation so continuous easing loop\n        // styles will keep rendering indefinitely\n        layer.isAnimationContinuous = isContinuous;\n\n        return end;\n      };\n\n      // The attribute is going to generate some child attributes\n      // Making the additional attributes children of this attribute\n      // will force them to update when the parent attribute is updated.\n      attribute.childAttributes = attribute.childAttributes || [];\n\n      // Attribute for the start value of the animation\n      const startAttr: IInstanceAttribute<T> = {\n        name: `_${name}_start`,\n        parentAttribute: attribute,\n        size,\n        update: _o => attributeDataShare.values.start\n      };\n\n      attribute.childAttributes.push(startAttr);\n      newAttributes.push(startAttr);\n\n      // Attribute for the starting time of the animation\n      const startTimeAttr: IInstanceAttribute<T> = {\n        name: `_${name}_start_time`,\n        parentAttribute: attribute,\n        size: InstanceAttributeSize.ONE,\n        update: _o => [attributeDataShare.values.startTime]\n      };\n\n      attribute.childAttributes.push(startTimeAttr);\n      newAttributes.push(startTimeAttr);\n\n      // Attribute for how long the animation will run\n      const durationAttr: IInstanceAttribute<T> = {\n        name: `_${name}_duration`,\n        parentAttribute: attribute,\n        size: InstanceAttributeSize.ONE,\n        update: _o => [attributeDataShare.values.duration]\n      };\n\n      attribute.childAttributes.push(durationAttr);\n      newAttributes.push(durationAttr);\n    }\n\n    // Return all of the new attributes to work with\n    return {\n      instanceAttributes: newAttributes,\n      vertexAttributes: [],\n      uniforms: []\n    };\n  }\n\n  /**\n   * Validates the IO about to be expanded.\n   */\n  validate<T extends Instance, U extends ILayerProps<T>>(\n    _layer: Layer<T, U>,\n    instanceAttributes: IInstanceAttribute<T>[],\n    _vertexAttributes: IVertexAttribute[],\n    _uniforms: IUniform[]\n  ): boolean {\n    let foundError = false;\n\n    instanceAttributes.forEach(attribute => {\n      if (attribute.easing && attribute.resource) {\n        console.warn(\n          \"An instance attribute can not have both easing and resource properties. Undefined behavior will occur.\"\n        );\n        console.warn(attribute);\n\n        foundError = true;\n      }\n\n      if (attribute.easing) {\n        if (attribute.size === undefined) {\n          console.warn(\n            \"An Instance Attribute with easing MUST have a size declared\"\n          );\n        }\n      }\n    });\n\n    return !foundError;\n  }\n\n  /**\n   * Easing provides some unique destructuring for the packed in vertex\n   * information.\n   */\n  processAttributeDestructuring(\n    _layer: Layer<Instance, ILayerProps<Instance>>,\n    declarations: ShaderDeclarationStatements,\n    _metrics: MetricsProcessing,\n    _vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<Instance>[],\n    _uniforms: IUniform[]\n  ): string {\n    // We analyze our instance attributes for easing attributes. When we find an\n    // attribute with easing, we can make a quick assumption about the names of\n    // attributes provided that we can easily use to destructure a properly\n    // named attribute that contains the correct algorithm to produce the\n    // specified easing for the attribute.\n    const out = \"\";\n\n    for (let i = 0, iMax = instanceAttributes.length; i < iMax; ++i) {\n      const attribute = instanceAttributes[i];\n\n      // If this is the source easing attribute, we must add it in as an eased\n      // method along with a calculation for the Easing interpolation time value\n      // based on the current time and the injected start time of the change.\n      if (!attribute.easing || !attribute.size) continue;\n      // Get the base name of the attribute since the original name gets changed\n      // for the expansion process.\n      const baseName = this.baseAttributeName.get(attribute);\n\n      if (!baseName) {\n        console.warn(\n          \"Could not determine a base name for an easing attribute.\"\n        );\n        continue;\n      }\n\n      // Clear the basename out as it's only needed for this operation.\n      this.baseAttributeName.delete(attribute);\n\n      // We first write in the time calculation based on the loop style of the\n      // easing method\n      const time = `_${baseName}_time`;\n      const duration = `_${baseName}_duration`;\n      const startTime = `_${baseName}_start_time`;\n\n      switch (attribute.easing.loop) {\n        // Continuous means letting the time go from 0 to infinity\n        case AutoEasingLoopStyle.CONTINUOUS: {\n          this.setDeclaration(\n            declarations,\n            time,\n            `  float ${time} = (currentTime - ${startTime}) / ${duration};\\n`,\n            debugCtx\n          );\n          break;\n        }\n\n        // Repeat means going from 0 to 1 then 0 to 1 etc etc\n        case AutoEasingLoopStyle.REPEAT: {\n          this.setDeclaration(\n            declarations,\n            time,\n            `  float ${time} = clamp(fract((currentTime - ${startTime}) / ${duration}), 0.0, 1.0);\\n`,\n            debugCtx\n          );\n          break;\n        }\n\n        // Reflect means going from 0 to 1 then 1 to 0 then 0 to 1 etc etc\n        case AutoEasingLoopStyle.REFLECT: {\n          const timePassed = `_${baseName}_timePassed`;\n          const pingPong = `_${baseName}_pingPong`;\n\n          // Get the time passed in a linear fashion\n          this.setDeclaration(\n            declarations,\n            timePassed,\n            `  float ${timePassed} = (currentTime - ${startTime}) / ${duration};\\n`,\n            debugCtx\n          );\n          // Make a triangle wave from the time passed to ping pong the value\n          this.setDeclaration(\n            declarations,\n            pingPong,\n            `  float ${pingPong} = abs((fract(${timePassed} / 2.0)) - 0.5) * 2.0;\\n`,\n            debugCtx\n          );\n          // Ensure we're clamped to the right values\n          this.setDeclaration(\n            declarations,\n            time,\n            `  float ${time} = clamp(${pingPong}, 0.0, 1.0);\\n`,\n            debugCtx\n          );\n          break;\n        }\n\n        // No loop means just linear time\n        case AutoEasingLoopStyle.NONE:\n        default: {\n          this.setDeclaration(\n            declarations,\n            time,\n            `  float ${time} = clamp((currentTime - ${startTime}) / ${duration}, 0.0, 1.0);\\n`,\n            debugCtx\n          );\n          break;\n        }\n      }\n\n      // After the time calculation we inject the actual easing equation to\n      // calculate the value needed for the attribute in the shader\n      this.setDeclaration(\n        declarations,\n        baseName,\n        `  ${sizeToType[attribute.size]} ${baseName} = ${\n          attribute.easing.methodName\n        }(_${baseName}_start, _${baseName}_end, _${baseName}_time);\\n`,\n        debugCtx\n      );\n    }\n\n    return out;\n  }\n\n  /**\n   * For easing, the header must be populated with the easing method\n   */\n  processHeaderInjection(\n    target: ShaderInjectionTarget,\n    declarations: ShaderDeclarationStatements,\n    _layer: Layer<Instance, ILayerProps<Instance>>,\n    _metrics: MetricsProcessing,\n    _vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<Instance>[],\n    _uniforms: IUniform[]\n  ): ShaderIOHeaderInjectionResult {\n    const out = { injection: \"\" };\n\n    // Easing equations are only applicable to the vertex shader where attribute destructuring happens\n    if (target !== ShaderInjectionTarget.VERTEX) return out;\n\n    const methods = new Map<string, Map<InstanceAttributeSize, string>>();\n    out.injection = \"// Auto Easing Methods specified by the layer\\n\";\n\n    // First dedupe the methods needed by their method name\n    instanceAttributes.forEach(attribute => {\n      if (attribute.easing && attribute.size) {\n        let methodSizes = methods.get(attribute.easing.methodName);\n\n        if (!methodSizes) {\n          methodSizes = new Map<InstanceAttributeSize, string>();\n          methods.set(attribute.easing.methodName, methodSizes);\n        }\n\n        methodSizes.set(attribute.size, attribute.easing.gpu);\n      }\n    });\n\n    if (methods.size === 0) {\n      out.injection = \"\";\n      return out;\n    }\n\n    const required: IShaderTemplateRequirements = {\n      name: \"Easing Method Generation\",\n      values: [templateVars.easingMethod]\n    };\n\n    // Now generate the full blown method for each element. We create overloaded methods for\n    // Each method name for each vector size required\n    methods.forEach(\n      (methodSizes: Map<InstanceAttributeSize, string>, methodName: string) => {\n        methodSizes.forEach((method, size) => {\n          const sizeType = sizeToType[size];\n\n          const templateOptions: { [key: string]: string } = {\n            [templateVars.easingMethod]: `${sizeType} ${methodName}(${sizeType} start, ${sizeType} end, float t)`,\n            [templateVars.T]: `${sizeType}`\n          };\n\n          const results = shaderTemplate({\n            options: templateOptions,\n            required,\n            shader: method\n          });\n\n          this.setDeclaration(\n            declarations,\n            `${sizeType} ${methodName}`,\n            `${results.shader}\\n`,\n            debugCtx\n          );\n        });\n      }\n    );\n\n    return out;\n  }\n}\n","import { uniformBufferInstanceBufferName } from \"../../../constants\";\nimport { WebGLStat } from \"../../../gl\";\nimport { MaterialUniformType } from \"../../../gl/types\";\nimport { Instance } from \"../../../instance-provider/instance\";\nimport { Vec4 } from \"../../../math/vector\";\nimport {\n  ShaderDeclarationStatements,\n  ShaderIOHeaderInjectionResult\n} from \"../../../shaders/processing/base-shader-io-injection\";\nimport { MetricsProcessing } from \"../../../shaders/processing/metrics-processing\";\nimport { ILayerProps, Layer } from \"../../../surface/layer\";\nimport { BaseIOExpansion } from \"../../../surface/layer-processing/base-io-expansion\";\nimport {\n  IInstanceAttribute,\n  InstanceAttributeSize,\n  IUniform,\n  IVertexAttribute,\n  LayerBufferType,\n  PickType,\n  ShaderInjectionTarget,\n  UniformSize\n} from \"../../../types\";\n\n/** Provides a label for performance debugging */\nconst debugCtx = \"BasicIOExpansion\";\n/** Defines the elements for destructuring out of a vector */\nconst VECTOR_COMPONENTS = [\"x\", \"y\", \"z\", \"w\"];\n\n/** Converts a size to a shader type */\nconst sizeToType: Record<UniformSize, string> = {\n  [UniformSize.ONE]: \"float\",\n  [UniformSize.TWO]: \"vec2\",\n  [UniformSize.THREE]: \"vec3\",\n  [UniformSize.FOUR]: \"vec4\",\n  [UniformSize.MATRIX3]: \"mat3\",\n  [UniformSize.MATRIX4]: \"mat4\",\n  [UniformSize.FLOAT_ARRAY]: \"float\",\n  [UniformSize.VEC4_ARRAY]: \"vec4\",\n  /** This is the special case for instance attributes that want an atlas resource */\n  [UniformSize.TEXTURE]: \"vec4\"\n};\n\n/**\n * Specific type guard to help with uniform value outputs\n */\nfunction isArray(val: any): val is number[] | Float32Array {\n  return val && val.length;\n}\n\n/**\n * Generates a define statement to hold the length of the uniform array to help\n * with writing slightly more dynamic shaders.\n */\nfunction makeArrayLength(uniform: IUniform) {\n  const size = uniform.size;\n\n  if (size === UniformSize.FLOAT_ARRAY || size === UniformSize.VEC4_ARRAY) {\n    const value = uniform.update(uniform);\n\n    if (isArray(value)) {\n      return `#define ${uniform.name}_length ${value.length}\\n`;\n    }\n  }\n\n  return \"\";\n}\n\n/**\n * Examines a uniform size and determines if it should have an array declaration\n * or not.\n */\nfunction makeArrayDeclaration(uniform: IUniform) {\n  const size = uniform.size;\n\n  if (size === UniformSize.FLOAT_ARRAY || size === UniformSize.VEC4_ARRAY) {\n    const value = uniform.update(uniform);\n\n    if (isArray(value)) {\n      return `[${uniform.name}_length]`;\n    }\n  }\n\n  return \"\";\n}\n\n/**\n * This method properly provides a vector's chunk of data based on a swizzle. So a size of 2\n * provides vector.xy and a size of 4 provides vector.xyzw.\n */\nfunction makeVectorSwizzle(start: number, size: number) {\n  return VECTOR_COMPONENTS.slice(start, start + size).join(\"\");\n}\n\n/**\n * This is the basic needs of processing attributes and uniforms and injecting their declarations into the shader.\n * This will handle buffer management associated with normal hardware instancing, vertex packing, and\n * uniform packing.\n *\n * This will not expand the IO in any way, rather this forms the basis for the IO input declarations in the shader\n * and arranges these declarations to handle all of the base Buffer management systems provided in the\n * default DeltaV library.\n */\nexport class BasicIOExpansion extends BaseIOExpansion {\n  /**\n   * This is the special case where attributes are packed into a uniform buffer instead of into\n   * attributes. This is to maximize compatibility with hardware and maximize flexibility in creative approaches\n   * to utilizing shaders that need a lot of input.\n   */\n  private generateUniformAttributePacking(\n    declarations: ShaderDeclarationStatements,\n    metrics: MetricsProcessing\n  ): ShaderIOHeaderInjectionResult {\n    // Add the uniform buffer to the shader\n    this.setDeclaration(\n      declarations,\n      uniformBufferInstanceBufferName,\n      `\\n// Instance Attributes as a packed Uniform Buffer\\nuniform vec4 ${uniformBufferInstanceBufferName}[${metrics.totalInstanceUniformBlocks}];\\n`,\n      debugCtx\n    );\n    // Add the number of blocks an instance utilizes\n    this.setDeclaration(\n      declarations,\n      \"instanceSize\",\n      `int instanceSize = ${metrics.totalInstanceUniformBlocks};`,\n      debugCtx\n    );\n    // Add the block retrieval method to aid in the Destructuring process\n    this.setDeclaration(\n      declarations,\n      \"getBlock\",\n      `vec4 getBlock(int index, int instanceIndex) { return ${uniformBufferInstanceBufferName}[(instanceSize * instanceIndex) + index]; }`,\n      debugCtx\n    );\n\n    return {\n      injection: \"\",\n      material: {\n        uniforms: [\n          {\n            name: uniformBufferInstanceBufferName,\n            type: MaterialUniformType.VEC4_ARRAY,\n            value: new Array(metrics.totalInstanceUniformBlocks)\n              .fill(0)\n              .map<Vec4>(() => [0, 0, 0, 0])\n          }\n        ]\n      }\n    };\n  }\n\n  /**\n   * This properly handles any special case destructuring for making the decalred attribute names available\n   * after the ${attribute} declaration.\n   */\n  processAttributeDestructuring(\n    layer: Layer<Instance, ILayerProps<Instance>>,\n    declarations: ShaderDeclarationStatements,\n    metrics: MetricsProcessing,\n    _vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<Instance>[],\n    _uniforms: IUniform[]\n  ): string {\n    let out = \"\";\n\n    // Prevent mutating\n    const orderedAttributes = instanceAttributes.slice(0);\n\n    // See which buffer strategy our layer is using and produce a destructuring strategy that suits it\n    switch (layer.bufferType) {\n      case LayerBufferType.INSTANCE_ATTRIBUTE:\n        out = this.processDestructuringInstanceAttribute(\n          declarations,\n          orderedAttributes\n        );\n        break;\n\n      case LayerBufferType.INSTANCE_ATTRIBUTE_PACKING:\n        out = this.processDestructuringInstanceAttributePacking(\n          declarations,\n          orderedAttributes\n        );\n        break;\n\n      case LayerBufferType.UNIFORM:\n        out = this.processDestructuringUniformBuffer(\n          declarations,\n          orderedAttributes,\n          metrics.blocksPerInstance\n        );\n        break;\n    }\n\n    // For now we add in our picking varying assignment should it be needed\n    if (layer.picking.type === PickType.SINGLE) {\n      out +=\n        \"\\n// This portion is where the shader assigns the picking color that gets passed to the fragment shader\\n_picking_color_pass_ = _pickingColor;\\n\";\n    }\n\n    return out;\n  }\n\n  /**\n   * Destructuring for normal instancing via attributes with no packing\n   */\n  private processDestructuringInstanceAttribute(\n    _declarations: ShaderDeclarationStatements,\n    _orderedAttributes: IInstanceAttribute<Instance>[]\n  ) {\n    // No-op, the attributes for normal instance attribute destructuring will simply be used directly\n    // as they will not be packed in and will simply out\n    return \"\";\n  }\n\n  /**\n   * This generates all Destructuring needs for the Instance Attribute Packing strategy. For this scenario\n   * attributes are tighly packed into attribute blocks rather than explicitly named attributes, thus the blocks\n   * must be destructured into the proper names of the attributes.\n   *\n   * This will, as well, destructure the auto easing methods.\n   */\n  private processDestructuringInstanceAttributePacking<T extends Instance>(\n    declarations: ShaderDeclarationStatements,\n    orderedAttributes: IInstanceAttribute<T>[]\n  ) {\n    let out = \"\";\n\n    // The attributes are generated in blocks already. Thus all that need be done for this scenario\n    // is merely perform block destructuring\n    out += this.processDestructureBlocks(declarations, orderedAttributes);\n\n    return out;\n  }\n\n  /**\n   * This generates all Destructuring needs for the Uniform Packing strategy. For this scenario,\n   * attributes are tighly packed into uniform blocks rather than attributes, thus the blocks\n   * must be destructured into the proper names of the attributes.\n   *\n   * This will, as well, destructure the auto easing methods.\n   */\n  private processDestructuringUniformBuffer<T extends Instance>(\n    declarations: ShaderDeclarationStatements,\n    orderedAttributes: IInstanceAttribute<T>[],\n    blocksPerInstance: number\n  ) {\n    this.setDeclaration(\n      declarations,\n      \"instanceIndex\",\n      \"int instanceIndex = int(instance);\",\n      debugCtx\n    );\n\n    // Generate the blocks\n    for (let i = 0; i < blocksPerInstance; ++i) {\n      this.setDeclaration(\n        declarations,\n        `block${i}`,\n        `  vec4 block${i} = getBlock(${i}, instanceIndex);\\n`,\n        debugCtx\n      );\n    }\n\n    // Destructure the blocks\n    return this.processDestructureBlocks(declarations, orderedAttributes);\n  }\n\n  /**\n   * This produces the destructuring elements needed to utilize the attribute data stored in blocks with names\n   * like:\n   *\n   * vec4 block0;\n   * vec4 block1;\n   *\n   * etc\n   */\n  private processDestructureBlocks<T extends Instance>(\n    declarations: ShaderDeclarationStatements,\n    orderedAttributes: IInstanceAttribute<T>[]\n  ) {\n    const out = \"\";\n\n    orderedAttributes.forEach(attribute => {\n      const block = attribute.block || 0;\n\n      // An attribute that is utilizing a matrix will span itself across 4 blocks\n      if (attribute.size === InstanceAttributeSize.MAT4X4) {\n        // If we have a size the size of a block, then don't swizzle the vector\n        this.setDeclaration(\n          declarations,\n          attribute.name,\n          `  ${sizeToType[attribute.size]} ${\n            attribute.name\n          } = mat4(block${block}, block${block + 1}, block${block +\n            2}, block${block + 3});\\n`,\n          debugCtx\n        );\n      } else if (attribute.size === InstanceAttributeSize.FOUR) {\n        // If we have a size the size of a block, then don't swizzle the vector\n        this.setDeclaration(\n          declarations,\n          attribute.name,\n          `  ${sizeToType[attribute.size]} ${\n            attribute.name\n          } = block${block};\\n`,\n          debugCtx\n        );\n      } else {\n        // Do normal destructuring with any other size and type\n        this.setDeclaration(\n          declarations,\n          attribute.name,\n          `  ${sizeToType[attribute.size || 1]} ${\n            attribute.name\n          } = block${block}.${makeVectorSwizzle(\n            attribute.blockIndex || 0,\n            attribute.size || 1\n          )};\\n`,\n          debugCtx\n        );\n      }\n    });\n\n    return out;\n  }\n\n  /**\n   * This processes the declarations needed to set up the Input for the shader\n   * from the layer.\n   *\n   * This handles the buffer strategies of:\n   *\n   * Vertex Attributes,\n   * Vertex Attribute Packing,\n   * Uniform Packing\n   */\n  processHeaderInjection(\n    target: ShaderInjectionTarget,\n    declarations: ShaderDeclarationStatements,\n    layer: Layer<Instance, ILayerProps<Instance>>,\n    metrics: MetricsProcessing,\n    vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<Instance>[],\n    uniforms: IUniform[]\n  ): ShaderIOHeaderInjectionResult {\n    let attributeDeclarations = {\n      injection: \"\"\n    };\n\n    // Attributes are only injected into the vertex shader\n    if (target === ShaderInjectionTarget.VERTEX) {\n      attributeDeclarations = this.processAttributeHeader(\n        declarations,\n        layer,\n        metrics,\n        vertexAttributes,\n        instanceAttributes\n      );\n    }\n\n    const uniformDeclaration = this.processUniformHeader(\n      declarations,\n      uniforms,\n      target\n    );\n\n    return {\n      ...attributeDeclarations,\n      injection: attributeDeclarations.injection + uniformDeclaration\n    };\n  }\n\n  /**\n   * Processes all IO for attribute declarations needed in the header of the shader.\n   */\n  private processAttributeHeader(\n    declarations: ShaderDeclarationStatements,\n    layer: Layer<Instance, ILayerProps<Instance>>,\n    metrics: MetricsProcessing,\n    vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<Instance>[]\n  ): ShaderIOHeaderInjectionResult {\n    let materialChanges = undefined;\n    let out = \"// Shader input\\n\";\n\n    // If we are in a uniform buffer type strategy. Then we generate a uniform buffer that will contain\n    // our instance attribute information along with some extras to help dereference from the buffer.\n    if (\n      layer.bufferType === LayerBufferType.UNIFORM &&\n      instanceAttributes.length > 0\n    ) {\n      const packing = this.generateUniformAttributePacking(\n        declarations,\n        metrics\n      );\n      materialChanges = packing.material;\n      out += packing.injection;\n    }\n\n    // Add in the vertex attributes input\n    out += this.processVertexAttributes(declarations, vertexAttributes);\n\n    // If we are in an instance attribute Buffer Type strategy, then we simply list out\n    // the attributes listed in our instance attributes as attributes.\n    if (\n      layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE &&\n      instanceAttributes.length > 0\n    ) {\n      out += this.processInstanceAttributeBufferStrategy(\n        declarations,\n        instanceAttributes\n      );\n    }\n\n    // If we are in an instance attribute \"packing\" buffer type strategy, then the layer\n    // is expecting to have attributes that are \"blocks\" instead of explicitally named\n    // attributes. The layer will be utilizing the blocks to efficiently pack in our instance information\n    if (\n      layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE_PACKING &&\n      instanceAttributes.length > 0\n    ) {\n      out += this.processInstanceAttributePackingBufferStrategy(\n        declarations,\n        metrics.instanceMaxBlock\n      );\n    }\n\n    return {\n      injection: out,\n      material: materialChanges\n    };\n  }\n\n  /**\n   * Processes all IO for uniform declarations needed in the header of the shader.\n   */\n  private processUniformHeader(\n    declarations: ShaderDeclarationStatements,\n    uniforms: IUniform[],\n    injectionType: ShaderInjectionTarget\n  ) {\n    const out = \"\";\n    const injection = injectionType || ShaderInjectionTarget.VERTEX;\n\n    uniforms.forEach(uniform => {\n      uniform.shaderInjection =\n        uniform.shaderInjection || ShaderInjectionTarget.VERTEX;\n\n      if (\n        uniform.shaderInjection === injection ||\n        uniform.shaderInjection === ShaderInjectionTarget.ALL\n      ) {\n        this.setDeclaration(\n          declarations,\n          uniform.name,\n          `${makeArrayLength(uniform)}uniform ${uniform.qualifier || \"\"}${\n            uniform.qualifier ? \" \" : \"\"\n          }${sizeToType[uniform.size]} ${uniform.name}${makeArrayDeclaration(\n            uniform\n          )};\\n`,\n          debugCtx\n        );\n      }\n    });\n\n    return out;\n  }\n\n  /**\n   * Produces attributes that are explicitally named and set by the attribute itself.\n   */\n  private processInstanceAttributeBufferStrategy<T extends Instance>(\n    declarations: ShaderDeclarationStatements,\n    instanceAttributes: IInstanceAttribute<T>[]\n  ) {\n    // Our declaration for an attribute is different between Shader 20 and\n    // Shader 30\n    let attrDeclaration = \"attribute\";\n\n    if (WebGLStat.SHADERS_3_0) {\n      attrDeclaration = \"in\";\n    }\n\n    instanceAttributes.forEach(attribute => {\n      this.setDeclaration(\n        declarations,\n        attribute.name,\n        `${attrDeclaration} ${\n          sizeToType[attribute.size || 1]\n        } ${attribute.qualifier || \"\"}${(attribute.qualifier && \" \") || \"\"} ${\n          attribute.name\n        };\\n`,\n        debugCtx\n      );\n    });\n\n    return \"\";\n  }\n\n  /**\n   * Produces attributes that are blocks instead of individual attributes. The system uses these\n   * blocks to pack attributes tightly together to maximize capabilities.\n   */\n  private processInstanceAttributePackingBufferStrategy(\n    declarations: ShaderDeclarationStatements,\n    maxBlock: number\n  ) {\n    // Our declaration for an attribute is different between Shader 20 and\n    // Shader 30\n    let attrDeclaration = \"attribute\";\n\n    if (WebGLStat.SHADERS_3_0) {\n      attrDeclaration = \"in\";\n    }\n\n    // Now print out blocks up to that block\n    for (let i = 0, iMax = maxBlock + 1; i < iMax; ++i) {\n      this.setDeclaration(\n        declarations,\n        `block${i}`,\n        `${attrDeclaration} ${\n          sizeToType[InstanceAttributeSize.FOUR]\n        } block${i};\\n`,\n        debugCtx\n      );\n    }\n\n    return \"\";\n  }\n\n  /**\n   * Produces the vertex attributes without any bias or modification.\n   */\n  private processVertexAttributes(\n    declarations: ShaderDeclarationStatements,\n    vertexAttributes: IVertexAttribute[]\n  ) {\n    // Our declaration for an attribute is different between Shader 20 and\n    // Shader 30\n    let attrDeclaration = \"attribute\";\n\n    if (WebGLStat.SHADERS_3_0) {\n      attrDeclaration = \"in\";\n    }\n\n    // No matter what, vertex attributes listed are strictly vertex attributes\n    vertexAttributes.forEach(attribute => {\n      this.setDeclaration(\n        declarations,\n        attribute.name,\n        `${attrDeclaration} ${\n          sizeToType[attribute.size]\n        } ${attribute.qualifier || \"\"}${(attribute.qualifier && \" \") || \"\"}${\n          attribute.name\n        };\\n`,\n        debugCtx\n      );\n    });\n\n    return \"\";\n  }\n}\n","import { activeAttributeName } from \"../../../constants\";\nimport { Instance } from \"../../../instance-provider/instance\";\nimport { ShaderDeclarationStatements } from \"../../../shaders/processing/base-shader-io-injection\";\nimport { MetricsProcessing } from \"../../../shaders/processing/metrics-processing\";\nimport { ILayerProps, Layer } from \"../../../surface/layer\";\nimport { BaseIOExpansion } from \"../../../surface/layer-processing/base-io-expansion\";\nimport { IInstanceAttribute, IUniform, IVertexAttribute } from \"../../../types\";\n\nconst debugCtx = \"ActiveIOExpansion\";\n\n/**\n * This is a special case io expander that handles detecting the _active attribute\n * and properly injecting the _active handler in the destructuring phase.\n *\n * Any IO expansion that writes destructuring logic will have it's destructuring logic\n */\nexport class ActiveIOExpansion extends BaseIOExpansion {\n  processAttributeDestructuring(\n    _layer: Layer<Instance, ILayerProps<Instance>>,\n    declarations: ShaderDeclarationStatements,\n    _metrics: MetricsProcessing,\n    _vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<Instance>[],\n    _uniforms: IUniform[]\n  ): string {\n    const out = \"\";\n\n    // Find the active attribute. If it exists we inject our active attribute handler\n    if (!instanceAttributes.find(attr => attr.name === activeAttributeName)) {\n      return out;\n    }\n\n    // The final item in the destructuring will always be the active attribute handler to ensure elements\n    // honor the active control\n    this.setDeclaration(\n      declarations,\n      \"__active_attribute_handler__\",\n      require(\"./fragments/active-attribute-handler.vs\"),\n      debugCtx\n    );\n\n    return out;\n  }\n}\n","let toEmit: { [key: string]: [Function, number, number] } = {};\n\nexport function emitOnce(\n  id: string,\n  callback: (calledCountBeforeEmit: number, id: string) => void\n) {\n  const emit = toEmit[id] || [callback, -1, 0];\n  toEmit[id] = emit;\n  emit[2]++;\n\n  clearTimeout(emit[1]);\n  emit[1] = window.setTimeout(() => {\n    callback(emit[2], id);\n    delete toEmit[id];\n  }, 1);\n}\n\nexport function flushEmitOnce() {\n  for (const id in toEmit) {\n    const emit = toEmit[id];\n    clearTimeout(emit[1]);\n    emit[0](emit[2], id);\n  }\n\n  toEmit = {};\n}\n","import { uniformBufferInstanceBufferName } from \"../../../constants\";\nimport { Attribute, Geometry, Material, Model } from \"../../../gl\";\nimport {\n  IMaterialUniform,\n  isUniformVec4Array,\n  MaterialUniformType\n} from \"../../../gl/types\";\nimport { Instance } from \"../../../instance-provider\";\nimport { Vec2, Vec4 } from \"../../../math\";\nimport { IInstanceAttribute } from \"../../../types\";\nimport { uid } from \"../../../util/uid\";\nimport { Layer } from \"../../layer\";\nimport { generateLayerModel } from \"../../layer-processing/generate-layer-model\";\nimport { LayerScene } from \"../../layer-scene\";\nimport { BufferManagerBase, IBufferLocation } from \"../buffer-manager-base\";\n\nexport interface IUniformBufferLocation extends IBufferLocation {\n  /** This is the index of the instance as it appears in the buffer */\n  instanceIndex: number;\n  /** This is the instance data uniform */\n  buffer: IMaterialUniform<MaterialUniformType.VEC4_ARRAY>;\n  /** This is the instance data range within the instanceData uniform */\n  range: Vec2;\n}\n\n/**\n * Typeguard for uniform buffer locations\n */\nexport function isUniformBufferLocation(\n  val: any\n): val is IUniformBufferLocation {\n  return (\n    val &&\n    val.buffer &&\n    val.buffer.value &&\n    val.type === MaterialUniformType.VEC4_ARRAY\n  );\n}\n\nexport interface InstanceUniformBuffer {\n  /** This tracks which instances are active. Helps optimize draw range */\n  activeInstances: boolean[];\n  /** This is all of the clusters within this buffer */\n  clusters: IUniformBufferLocation[];\n  /** The first instance in the draw range */\n  firstInstance: number;\n  /** The unique geometry object for the buffer: Used to set draw range */\n  geometry: Geometry;\n  /** The last instance in the draw range */\n  lastInstance: number;\n  /** The unique material for the buffer: Used to provide a new set of uniforms */\n  material: Material;\n  /** The unique model generated for the buffer: Used to allow the buffer to be rendered by adding to a scene */\n  model: Model;\n}\n\n/**\n * This is a Buffer Management system that performs instancing via the uniforms available to the hardware.\n * This improves compatibility with instancing for systems DRAMATICALLY as ALL systems WILL support uniforms.\n * This will NOT perform the best against true hardware instancing support, but it will have edge cases where it\n * is needed.\n *\n * When a layer has too many instance + vertex attributes for the hardware, the system will defer to this buffer methodology.\n *\n * This class does a whoooooole lot of making the magical instancing optimization controls possible.\n *\n * Our instancing hackyness comes from the idea that uniforms are fast, and you don't have to commit\n * ALL of them when you touch just a little piece, and you don't have worry about drivers not supporting\n * partial vertex buffer updates.\n *\n * This also is WebGL 1.0 compatible without any extensions that are poorly implemented. And again: does\n * NOT require entire attribute buffer commits.\n *\n * Uniforms are limited for any given draw call. So we have to create multiple materials to support\n * chunks of the instances that need to be drawn. We then have to associate an instance with the set\n * of uniforms that is related to the instance and keep them paired together. If we have too many instances\n * we must generate more buffers to accomodate them.\n *\n * If we remove instances, we must free up the uniform set so that others can use the uniforms. While the uniforms\n * are not in use, the instance should not be rendering.\n */\nexport class UniformBufferManager<T extends Instance> extends BufferManagerBase<\n  T,\n  IUniformBufferLocation\n> {\n  /** The number of uniform blocks an instance requires */\n  private uniformBlocksPerInstance: number;\n  /** The generated buffers by this manager */\n  private buffers: InstanceUniformBuffer[] = [];\n  /** The uniform clusters that are free and can be used by an instance */\n  private availableClusters: IUniformBufferLocation[] = [];\n  /** A lookup of an instance to a cluster of uniforms associated with it */\n  private instanceToCluster: { [key: number]: IUniformBufferLocation } = {};\n  /** A map of a cluster of uniforms to the buffer it comes from */\n  private clusterToBuffer = new Map<\n    IUniformBufferLocation,\n    InstanceUniformBuffer\n  >();\n\n  constructor(layer: Layer<T, any>, scene: LayerScene) {\n    super(layer, scene);\n\n    let maxUniformBlock: number = 0;\n    layer.shaderIOInfo.instanceAttributes.forEach(\n      (attributes: IInstanceAttribute<T>) => {\n        maxUniformBlock = Math.max(attributes.block || 0, maxUniformBlock);\n      }\n    );\n\n    this.uniformBlocksPerInstance = maxUniformBlock + 1;\n  }\n\n  /**\n   * This adds an instance to the manager and gives the instance an associative\n   * block of uniforms to work with.\n   */\n  add = (instance: T) => {\n    // If there are no available buffers, we must add a buffer\n    if (this.availableClusters.length <= 0) {\n      this.makeNewBuffer();\n    }\n\n    const cluster = this.availableClusters.pop();\n\n    if (cluster) {\n      this.instanceToCluster[instance.uid] = cluster;\n    } else {\n      console.warn(\n        \"No valid cluster available for instance added to uniform manager.\"\n      );\n    }\n\n    return cluster;\n  };\n\n  /**\n   * Free all resources this manager may be holding onto\n   */\n  destroy() {\n    this.buffers.forEach(buffer => {\n      buffer.geometry.destroy();\n      buffer.material.dispose();\n    });\n  }\n\n  /**\n   * This retireves the uniforms associated with an instance, or returns nothing\n   * if the instance has not been associated yet.\n   */\n  getBufferLocations(instance: T) {\n    return this.instanceToCluster[instance.uid];\n  }\n\n  /**\n   * TODO: The uniform buffer does not need to utilize this yet. it will be more necessary\n   * when this manager updates only changed properties.\n   */\n  getActiveAttributePropertyId() {\n    return -1;\n  }\n\n  /**\n   * TODO: This is irrelevant tot his manager for now.\n   * Number of instances this buffer manages.\n   */\n  getInstanceCount() {\n    return -1;\n  }\n\n  /**\n   * TODO: The uniform buffer updates ALL attributes every change for any property so far.\n   * This should be fixed for performance improvements on the compatibility mode.\n   */\n  getUpdateAllPropertyIdList() {\n    return [];\n  }\n\n  /**\n   * Checks to see if the instance is managed by this manager.\n   */\n  managesInstance(instance: T) {\n    return this.instanceToCluster[instance.uid] === undefined;\n  }\n\n  /**\n   * Disassociates an instance with it's group of uniforms and makes the instance\n   * in the buffer no longer drawable.\n   */\n  remove = function(instance: T) {\n    const cluster = this.instanceToCluster[instance.uid];\n\n    // If the instance is associated with a cluster, we can add the cluster back to being available\n    // For another instance.\n    if (cluster) {\n      delete this.instanceToCluster[instance.uid];\n      this.availableClusters.push(cluster);\n    }\n\n    return instance;\n  };\n\n  /**\n   * Clears all elements of this manager from the current scene it was in.\n   */\n  removeFromScene() {\n    const scene = this.scene;\n\n    if (scene.container) {\n      for (let i = 0, end = this.buffers.length; i < end; ++i) {\n        const buffer = this.buffers[i];\n        scene.container.remove(buffer.model);\n      }\n\n      delete this.scene;\n    }\n  }\n\n  /**\n   * Applies the buffers to the provided scene for rendering.\n   */\n  setScene(scene: LayerScene) {\n    if (scene.container) {\n      for (let i = 0, end = this.buffers.length; i < end; ++i) {\n        const buffer = this.buffers[i];\n        scene.container.add(buffer.model);\n      }\n\n      this.scene = scene;\n    } else {\n      console.warn(\"Can not set a scene that has an undefined container.\");\n    }\n  }\n\n  /**\n   * This generates a new buffer of uniforms to associate instances with.\n   */\n  makeNewBuffer() {\n    const shaderIOInfo = this.layer.shaderIOInfo;\n    // We generate a new geometry object for the buffer as the geometry\n    // Needs to have it's own unique draw range per buffer for optimal\n    // Performance\n    const newGeometry = new Geometry();\n    shaderIOInfo.vertexAttributes.forEach(attribute => {\n      if (attribute.materialAttribute) {\n        newGeometry.addAttribute(attribute.name, attribute.materialAttribute);\n      }\n    });\n\n    // This is the material that is generated for the layer that utilizes all of the generated and\n    // Injected shader IO and shader fragments\n    const newMaterial = this.makeLayerMaterial();\n    // Now make a Model for the buffer so it can be rendered withn the scene\n    const newModel = generateLayerModel(\n      newGeometry,\n      newMaterial,\n      shaderIOInfo.drawMode\n    );\n    // Ensure the draw range covers every instance in the geometry.\n    newModel.vertexDrawRange = [\n      0,\n      shaderIOInfo.maxInstancesPerBuffer * shaderIOInfo.instanceVertexCount\n    ];\n\n    // Make our new buffer which will manage the geometry and everything necessary\n    const buffer: InstanceUniformBuffer = {\n      activeInstances: [],\n      clusters: [],\n      firstInstance: 0,\n      geometry: newGeometry,\n      lastInstance: 0,\n      material: newMaterial,\n      model: newModel\n    };\n\n    this.buffers.push(buffer);\n\n    // Now that we have created a new buffer, we have all of it's uniforms\n    // To use to render more instances. We must take the instancing uniforms\n    // And divvy them up into clusters for our available buffer.\n    let uniformIndex = 0;\n    const uniformName = uniformBufferInstanceBufferName;\n    const instanceData = newMaterial.uniforms[uniformName];\n\n    // Type guard this uniform to ensure we're dealing with the correct type\n    if (isUniformVec4Array(instanceData)) {\n      // We must ensure the vector objects are TOTALLY unique otherwise they'll get shared across buffers\n      instanceData.value = instanceData.value.map<Vec4>(() => [\n        0.0,\n        0.0,\n        0.0,\n        0.0\n      ]);\n    } else {\n      console.warn(\n        \"Material is utilizing an invalid uniform type for Uniform Buffer Management. Buffering will not be possible.\"\n      );\n      return;\n    }\n\n    // A fake attribute to satisfy type requirements\n    const fakeAttribute = Object.assign(\n      {},\n      shaderIOInfo.instanceAttributes[0],\n      {\n        bufferAttribute: new Attribute(new Float32Array(1), 1),\n        uid: uid()\n      }\n    );\n\n    for (let i = 0, end = shaderIOInfo.maxInstancesPerBuffer; i < end; ++i) {\n      const cluster: IUniformBufferLocation = {\n        attribute: fakeAttribute, // TODO: This is not needed for the uniform method yet. When we break down\n        // the uniform updates into attributes, this will be utilized.\n        buffer: instanceData,\n        instanceIndex: i,\n        range: [uniformIndex, 0]\n      };\n\n      uniformIndex += this.uniformBlocksPerInstance;\n      cluster.range[1] = uniformIndex;\n\n      buffer.clusters.push(cluster);\n      this.availableClusters.push(cluster);\n      this.clusterToBuffer.set(cluster, buffer);\n    }\n\n    // Grab the global uniforms from the material and add it to the uniform's materialUniform list so that\n    // We can keep uniforms consistent across all Instances\n    for (let i = 0, end = shaderIOInfo.uniforms.length; i < end; ++i) {\n      const uniform = shaderIOInfo.uniforms[i];\n      uniform.materialUniforms.push(newMaterial.uniforms[uniform.name]);\n    }\n\n    // Now that we are ready to utilize the buffer, let's add it to the scene so it may be rendered.\n    // Each new buffer equates to one draw call.\n    if (this.scene && this.scene.container) {\n      this.scene.container.add(buffer.model);\n    }\n  }\n}\n","import { Instance } from \"../../instance-provider\";\nimport { InstanceDiff } from \"../../types\";\nimport {\n  BufferManagerBase,\n  IBufferLocation,\n  IBufferLocationGroup\n} from \"./buffer-manager-base\";\nimport { IInstanceDiffManagerTarget } from \"./instance-diff-manager\";\n\n/**\n * Base requirements for handling diffs from a layer.\n */\nexport abstract class BaseDiffProcessor<T extends Instance> {\n  layer: IInstanceDiffManagerTarget<T>;\n  bufferManager: BufferManagerBase<T, IBufferLocation>;\n\n  constructor(\n    layer: IInstanceDiffManagerTarget<T>,\n    bufferManager: BufferManagerBase<T, IBufferLocation>\n  ) {\n    this.layer = layer;\n    this.bufferManager = bufferManager;\n  }\n\n  /** Perform an 'add' operation for the instance's buffer */\n  abstract addInstance(\n    manager: this,\n    instance: T,\n    propIds: number[],\n    bufferLocation?: IBufferLocation | IBufferLocationGroup<IBufferLocation>\n  ): void;\n  /** Perform a 'change' operation for the instance's buffer */\n  abstract changeInstance(\n    manager: this,\n    instance: T,\n    propIds: number[],\n    bufferLocation?: IBufferLocation | IBufferLocationGroup<IBufferLocation>\n  ): void;\n  /** Perform a 'remove' operation for the instance's buffer */\n  abstract removeInstance(\n    manager: this,\n    instance: T,\n    propIds: number[],\n    bufferLocation?: IBufferLocation | IBufferLocationGroup<IBufferLocation>\n  ): void;\n\n  /**\n   * This indicates all changes have been applied, this allows the processor to finalize buffer updates\n   */\n  abstract commit(): void;\n  /**\n   * This will be called with the changes that WILL be processed. This allows this processor to make extra judgement calls on\n   * how it will process the changes and let's it optimize itself before changes are actually processed. An example optimization:\n   *\n   * Buffers have an update range we can adjust so only a piece of the buffer is updated. However, calculating that range causes\n   * overhead to calculate the affected range. So, if we have mass changes happening for major sections of the buffer (number of\n   * changes approaches some large percentage of the instances supported by the buffer), then it would be more efficient just to\n   * update the entire buffer rather than discover the portion needing updating.\n   */\n  abstract incomingChangeList(changes: InstanceDiff<T>[]): void;\n}\n","import {\n  IMouseInteraction,\n  ISingleTouchInteraction,\n  ITouchInteraction\n} from \"../event-management/types\";\nimport { Instance } from \"../instance-provider/instance\";\nimport {\n  IColorPickingData,\n  IMousePickInfo,\n  ITouchPickInfo,\n  PickType\n} from \"../types\";\nimport { mapGetWithDefault, mapInjectDefault } from \"../util/common-operations\";\nimport { ILayerProps, Layer } from \"./layer\";\nimport { IViewProps, View } from \"./view\";\n\n/**\n * This manages mouse gestures broadcast to the layer and handles appropriate actions such as determining\n * how to make the interaction translate to picking events for the layer's instances.\n *\n * Summarized: layer-mouse-events processes and filters events for the Views, this processes those events for the layers\n * and their instances.\n */\nexport class LayerInteractionHandler<\n  T extends Instance,\n  U extends ILayerProps<T>\n> {\n  /** This is the color picking information most recently rendered */\n  colorPicking?: IColorPickingData;\n  /** This tracks the elements that have the mouse currently over them */\n  isMouseOver = new Set<T>();\n  /** This tracks the elements the mouse was down on */\n  isMouseDown = new Set<T>();\n  /** This is the layer the interaction handler manages events for */\n  layer: Layer<T, U>;\n\n  /** Tracks elements that have a touch over them */\n  isTouchOver = new Map<number, Set<T>>();\n  isTouchDown = new Map<number, Set<T>>();\n\n  constructor(layer: Layer<T, U>) {\n    this.layer = layer;\n  }\n\n  /**\n   * Retrieves the color picking instance determined for the procedure.\n   */\n  getColorPickInstance(view: View<IViewProps>) {\n    if (\n      this.colorPicking &&\n      this.layer.picking.type === PickType.SINGLE &&\n      this.colorPicking.view === view\n    ) {\n      return this.layer.uidToInstance.get(\n        0xffffff - this.colorPicking.nearestColor\n      );\n    }\n\n    return null;\n  }\n\n  /**\n   * Handles mouse down gestures for a layer within a view\n   */\n  handleMouseOver(_view: View<any>, _interaction: IMouseInteraction) {\n    // This is the mouse over for the view itself. We should probably just let\n    // the mouse over events handle the interactions With the instances\n  }\n\n  /**\n   * Handles touch down gestures for a layer within a view\n   */\n  handleTouchOver(\n    _view: View<any>,\n    _interaction: ITouchInteraction,\n    _touch: ISingleTouchInteraction\n  ) {\n    // This is the touch over for the view itself. We should probably just let\n    // the touch over events handle the interactions With the instances\n  }\n\n  /**\n   * Handles mouse down gestures for a layer within a view\n   */\n  handleMouseDown(view: View<any>, interaction: IMouseInteraction) {\n    // This handles interactions for PickType ALL layers\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      const { onMouseDown } = this.layer.props;\n\n      // If we have a listener for either event we should continue to process\n      // the event in more detail\n      if (onMouseDown) {\n        const world = view.projection.screenToWorld(\n          interaction.screen.position\n        );\n        const instances: T[] = [];\n\n        if (this.layer.picking.type === PickType.SINGLE) {\n          // Get the instance for the nearest color\n          const instanceForColor = this.getColorPickInstance(view);\n\n          if (instanceForColor) {\n            instances.push(instanceForColor);\n          }\n        }\n\n        const info: IMousePickInfo<T> = {\n          interaction,\n          instances,\n          layer: this.layer.id,\n          projection: view.projection,\n          screen: interaction.screen.position,\n          world\n        };\n\n        onMouseDown(info);\n\n        // We track all the elements the mouse is currently down on\n        this.isMouseDown.clear();\n        instances.forEach(o => this.isMouseDown.add(o));\n      }\n    }\n  }\n\n  /**\n   * Handles touch events for instances for layers\n   */\n  handleTouchDown(\n    view: View<any>,\n    interaction: ITouchInteraction,\n    touch: ISingleTouchInteraction\n  ) {\n    const { onTouchDown, onTouchOver } = this.layer.props;\n\n    // Validate the conditions on the layer justifies having events be processed\n    // for the layer\n    if (\n      !this.layer.picking ||\n      this.layer.picking.type === PickType.NONE ||\n      (!onTouchDown && !onTouchOver)\n    ) {\n      return;\n    }\n\n    const world = view.projection.screenToWorld(touch.screen.position);\n    const instances: T[] = [];\n\n    if (this.layer.picking.type === PickType.SINGLE) {\n      // Get the instance for the nearest color\n      const instanceForColor = this.getColorPickInstance(view);\n\n      if (instanceForColor) {\n        instances.push(instanceForColor);\n      }\n    }\n\n    const info: ITouchPickInfo<T> = {\n      interaction,\n      touch,\n      instances,\n      layer: this.layer.id,\n      projection: view.projection,\n      screen: touch.screen.position,\n      world\n    };\n\n    // Add the instances involved in the touch down to our down state items.\n    // Being down also happens to cause the touch to be in an 'over' state as\n    // well This is more unique to touch as there is not a cursor following the\n    // event before the event happens\n    const isTouchDown = mapInjectDefault(\n      this.isTouchDown,\n      touch.touch.touch.identifier,\n      () => new Set()\n    );\n\n    const isTouchOver = mapInjectDefault(\n      this.isTouchOver,\n      touch.touch.touch.identifier,\n      () => new Set()\n    );\n\n    instances.forEach(instance => {\n      isTouchDown.add(instance);\n      isTouchOver.add(instance);\n    });\n\n    // Broadcast the touch over/down event\n    if (onTouchOver) onTouchOver(info);\n    if (onTouchDown) onTouchDown(info);\n  }\n\n  /**\n   * Handles mouse out events for a layer within the view\n   */\n  handleMouseOut(view: View<any>, interaction: IMouseInteraction) {\n    // This will fire an instance mouse out for any over instances in the queue\n    // since we left the view Thus no instances shall be considered 'over'\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      const { onMouseOut } = this.layer.props;\n\n      if (onMouseOut) {\n        const world = view.projection.screenToWorld(\n          interaction.screen.position\n        );\n\n        const info: IMousePickInfo<T> = {\n          interaction,\n          instances: Array.from(this.isMouseOver.keys()),\n          layer: this.layer.id,\n          projection: view.projection,\n          screen: interaction.screen.position,\n          world\n        };\n\n        onMouseOut(info);\n      }\n    }\n\n    // We clear as no instances are over anymore\n    this.isMouseOver.clear();\n  }\n\n  /**\n   * Handles touch events that have been dragged off of a view\n   */\n  handleTouchOut(\n    view: View<any>,\n    interaction: ITouchInteraction,\n    touch: ISingleTouchInteraction\n  ) {\n    const { onTouchOut } = this.layer.props;\n\n    if (\n      !this.layer.picking ||\n      this.layer.picking.type === PickType.NONE ||\n      !onTouchOut\n    ) {\n      return;\n    }\n\n    const world = view.projection.screenToWorld(touch.screen.position);\n\n    const info: ITouchPickInfo<T> = {\n      interaction,\n      touch,\n      instances: Array.from(this.isMouseOver.keys()),\n      layer: this.layer.id,\n      projection: view.projection,\n      screen: touch.screen.position,\n      world\n    };\n\n    onTouchOut(info);\n\n    // We must clear out ALL touch over state for the touch as we are not even\n    // on the view anymore\n    this.isTouchOver.delete(touch.touch.touch.identifier);\n  }\n\n  /**\n   * Handles mouse up gestures for the layer within the provided view\n   */\n  handleMouseUp(view: View<any>, interaction: IMouseInteraction) {\n    const { onMouseUp, onMouseUpOutside } = this.layer.props;\n\n    // Check to ensure the layer is configured to accept the events\n    if (\n      !this.layer.picking ||\n      this.layer.picking.type === PickType.NONE ||\n      !onMouseUp\n    ) {\n      return;\n    }\n\n    const world = view.projection.screenToWorld(interaction.screen.position);\n    const instances: T[] = [];\n\n    if (this.layer.picking.type === PickType.SINGLE) {\n      // Get the instance for the nearest color\n      const instanceForColor = this.getColorPickInstance(view);\n\n      if (instanceForColor) {\n        instances.push(instanceForColor);\n      }\n    }\n\n    let info: IMousePickInfo<T> = {\n      interaction,\n      instances,\n      layer: this.layer.id,\n      projection: view.projection,\n      screen: interaction.screen.position,\n      world\n    };\n\n    // Broadcast the mouse up event to the layers\n    onMouseUp(info);\n    // Now we look to see which of the mouse down instances were NOT in the\n    // mouse up instances to detect mouse up outside events\n    instances.forEach(instance => this.isMouseDown.delete(instance));\n    // If no mouse downs remain, then we simply stop here\n    if (this.isMouseDown.size <= 0 || !onMouseUpOutside) return;\n\n    // Otherwise, broadcast a mouse up outside event for all instances remaining\n    info = {\n      interaction,\n      instances: Array.from(this.isMouseDown.values()),\n      layer: this.layer.id,\n      projection: view.projection,\n      screen: interaction.screen.position,\n      world\n    };\n\n    // Broadcast the mouse up outside event to the layers\n    onMouseUpOutside(info);\n  }\n\n  /**\n   * Handles touch up events that occur over a view\n   */\n  handleTouchUp(\n    view: View<any>,\n    interaction: ITouchInteraction,\n    touch: ISingleTouchInteraction\n  ) {\n    const {\n      onTouchUp,\n      onTouchUpOutside,\n      onTouchOut,\n      onTouchAllEnd\n    } = this.layer.props;\n\n    // Check to ensure the layer is configured to accept the events\n    if (\n      !this.layer.picking ||\n      this.layer.picking.type === PickType.NONE ||\n      (!onTouchUp && !onTouchUpOutside && !onTouchOut && !onTouchAllEnd)\n    ) {\n      return;\n    }\n\n    const world = view.projection.screenToWorld(touch.screen.position);\n    const instances: T[] = [];\n\n    if (this.layer.picking.type === PickType.SINGLE) {\n      // Get the instance for the nearest color\n      const instanceForColor = this.getColorPickInstance(view);\n\n      if (instanceForColor) {\n        instances.push(instanceForColor);\n      }\n    }\n\n    let info: ITouchPickInfo<T> = {\n      interaction,\n      touch,\n      instances,\n      layer: this.layer.id,\n      projection: view.projection,\n      screen: touch.screen.position,\n      world\n    };\n\n    // Broadcast the touch up event to the layers\n    if (onTouchOut) onTouchOut(info);\n    if (onTouchUp) onTouchUp(info);\n\n    // If this is touch down\n    const isTouchDown = mapGetWithDefault(\n      this.isTouchDown,\n      touch.touch.touch.identifier,\n      new Set()\n    );\n    // Now we look to see which of the touch down instances were NOT in the\n    // touch up instances to detect touch up outside events\n    instances.forEach(instance => isTouchDown.delete(instance));\n\n    // If no touch downs remain, then we simply stop here\n    if (isTouchDown.size > 0 && onTouchUpOutside) {\n      // Otherwise, broadcast a touch up outside event for all instances remaining\n      info = {\n        interaction,\n        touch,\n        instances: Array.from(isTouchDown.values()),\n        layer: this.layer.id,\n        projection: view.projection,\n        screen: touch.screen.position,\n        world\n      };\n\n      // Broadcast the mouse up outside event to the layers\n      onTouchUpOutside(info);\n    }\n\n    // Clear the touch down state information\n    this.isTouchDown.delete(touch.touch.touch.identifier);\n\n    // If no more touches are considered down anymore, then we have an all end\n    // event\n    if (this.isTouchDown.size <= 0 && onTouchAllEnd) {\n      info = {\n        interaction,\n        touch,\n        instances: [],\n        layer: this.layer.id,\n        projection: view.projection,\n        screen: touch.screen.position,\n        world\n      };\n\n      onTouchAllEnd(info);\n    }\n  }\n\n  /**\n   * Mouse move events on the layer will detect when instances have their item\n   * newly over or just moved on\n   */\n  handleMouseMove(view: View<any>, interaction: IMouseInteraction) {\n    // This handles interactions for PickType ALL layers\n    const { onMouseOver, onMouseMove, onMouseOut } = this.layer.props;\n\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      // If we have a listener for either event we should continue to process\n      // the event in more detail\n      if (onMouseOver || onMouseMove || onMouseOut) {\n        let info: IMousePickInfo<T>;\n        const world = view.projection.screenToWorld(\n          interaction.screen.position\n        );\n        const instances: T[] = [];\n\n        if (this.layer.picking.type === PickType.SINGLE) {\n          // Get the instance for the nearest color\n          const instanceForColor = this.getColorPickInstance(view);\n\n          if (instanceForColor) {\n            instances.push(instanceForColor);\n          }\n        }\n\n        // MOUSE OUT\n        // First broadcast Mouse out events\n        const isCurrentlyOver = new Set<T>();\n        instances.forEach(o => isCurrentlyOver.add(o));\n\n        // Broadcast the the picking info for all instances that the mouse moved\n        // off of\n        if (onMouseOut) {\n          const noLongerOver: T[] = [];\n\n          this.isMouseOver.forEach(o => {\n            if (!isCurrentlyOver.has(o)) {\n              noLongerOver.push(o);\n            }\n          });\n\n          // This is the pick info object we will broadcast from the layer\n          info = {\n            interaction,\n            instances: noLongerOver,\n            layer: this.layer.id,\n            projection: view.projection,\n            screen: interaction.screen.position,\n            world\n          };\n\n          if (noLongerOver.length > 0) onMouseOut(info);\n        }\n\n        // MOUSE OVER Broadcast the picking info for newly over instances to any\n        // of the layers listeners if needed\n        if (onMouseOver) {\n          const notOverInstances = instances.filter(\n            o => !this.isMouseOver.has(o)\n          );\n          info = {\n            interaction,\n            instances: notOverInstances,\n            layer: this.layer.id,\n            projection: view.projection,\n            screen: interaction.screen.position,\n            world\n          };\n\n          if (notOverInstances.length > 0) onMouseOver(info);\n        }\n\n        // MOUSE MOVE Broadcast the the picking info for all instances that the\n        // mouse moved on\n        if (onMouseMove) {\n          // This is the pick info object we will broadcast from the layer\n          info = {\n            interaction,\n            instances,\n            layer: this.layer.id,\n            projection: view.projection,\n            screen: interaction.screen.position,\n            world\n          };\n\n          onMouseMove(info);\n        }\n\n        // We store the current hovered over items as our over item list for\n        // next interaction\n        this.isMouseOver = isCurrentlyOver;\n      }\n    }\n  }\n\n  /**\n   * Handles touches that are moving along the screen\n   */\n  handleTouchMove(\n    view: View<any>,\n    interaction: ITouchInteraction,\n    touch: ISingleTouchInteraction\n  ) {\n    // This handles interactions for PickType ALL layers\n    const { onTouchOver, onTouchMove, onTouchOut } = this.layer.props;\n\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      // If we have a listener for either event we should continue to process\n      // the event in more detail\n      if (onTouchOver || onTouchMove || onTouchOut) {\n        let info: ITouchPickInfo<T>;\n        const world = view.projection.screenToWorld(touch.screen.position);\n        const instances: T[] = [];\n\n        if (this.layer.picking.type === PickType.SINGLE) {\n          // Get the instance for the nearest color\n          const instanceForColor = this.getColorPickInstance(view);\n\n          if (instanceForColor) {\n            instances.push(instanceForColor);\n          }\n        }\n\n        // Get the current touch over state for the given touch.\n        const isTouchOver = mapGetWithDefault(\n          this.isTouchOver,\n          touch.touch.touch.identifier,\n          new Set()\n        );\n\n        // TOUCH OUT\n        // First broadcast touch out events\n        const isCurrentlyOver = new Set<T>();\n        instances.forEach(o => isCurrentlyOver.add(o));\n\n        // Broadcast the the picking info for all instances that the touch moved\n        // off of\n        if (onTouchOut) {\n          const noLongerOver: T[] = [];\n\n          isTouchOver.forEach(o => {\n            if (!isCurrentlyOver.has(o)) {\n              noLongerOver.push(o);\n            }\n          });\n\n          // This is the pick info object we will broadcast from the layer\n          info = {\n            interaction,\n            touch,\n            instances: noLongerOver,\n            layer: this.layer.id,\n            projection: view.projection,\n            screen: touch.screen.position,\n            world\n          };\n\n          if (noLongerOver.length > 0) onTouchOut(info);\n        }\n\n        // TOUCH OVER Broadcast the picking info for newly over instances to any\n        // of the layers listeners if needed\n        if (onTouchOver) {\n          const notOverInstances = instances.filter(o => !isTouchOver.has(o));\n          info = {\n            interaction,\n            touch,\n            instances: notOverInstances,\n            layer: this.layer.id,\n            projection: view.projection,\n            screen: touch.screen.position,\n            world\n          };\n\n          if (notOverInstances.length > 0) onTouchOver(info);\n        }\n\n        // TOUCH MOVE Broadcast the the picking info for all instances that the\n        // touch moved on\n        if (onTouchMove) {\n          // This is the pick info object we will broadcast from the layer\n          info = {\n            interaction,\n            touch,\n            instances,\n            layer: this.layer.id,\n            projection: view.projection,\n            screen: touch.screen.position,\n            world\n          };\n\n          onTouchMove(info);\n        }\n\n        // We store the current hovered over items as our over item list for\n        // next interaction\n        this.isMouseOver = isCurrentlyOver;\n      }\n    }\n  }\n\n  /**\n   * Handles click gestures on the layer within a view\n   */\n  handleMouseClick(view: View<any>, interaction: IMouseInteraction) {\n    // This handles interactions for PickType ALL layers\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      const { onMouseClick } = this.layer.props;\n\n      // If we have a listener for either event we should continue to process the event in more detail\n      if (onMouseClick) {\n        const world = view.projection.screenToWorld(\n          interaction.screen.position\n        );\n        const instances: T[] = [];\n\n        if (this.layer.picking.type === PickType.SINGLE) {\n          // Get the instance for the nearest color\n          const instanceForColor = this.getColorPickInstance(view);\n\n          if (instanceForColor) {\n            instances.push(instanceForColor);\n          }\n        }\n\n        const info: IMousePickInfo<T> = {\n          interaction,\n          instances,\n          layer: this.layer.id,\n          projection: view.projection,\n          screen: interaction.screen.position,\n          world\n        };\n\n        onMouseClick(info);\n      }\n    }\n  }\n\n  /**\n   * Handles tap interactions with the view\n   */\n  handleTap(\n    view: View<any>,\n    interaction: ITouchInteraction,\n    touch: ISingleTouchInteraction\n  ) {\n    // This handles interactions for PickType ALL layers\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      const { onTap } = this.layer.props;\n\n      // If we have a listener for either event we should continue to process the event in more detail\n      if (onTap) {\n        const world = view.projection.screenToWorld(touch.screen.position);\n        const instances: T[] = [];\n\n        if (this.layer.picking.type === PickType.SINGLE) {\n          // Get the instance for the nearest color\n          const instanceForColor = this.getColorPickInstance(view);\n\n          if (instanceForColor) {\n            instances.push(instanceForColor);\n          }\n        }\n\n        const info: ITouchPickInfo<T> = {\n          interaction,\n          touch,\n          instances,\n          layer: this.layer.id,\n          projection: view.projection,\n          screen: touch.screen.position,\n          world\n        };\n\n        onTap(info);\n      }\n    }\n  }\n\n  /**\n   * Handles drag gestures for the layer within the view\n   */\n  handleMouseDrag(_view: View<any>, _interaction: IMouseInteraction) {\n    // We probably should not broadcast drag events for the sake of instances. Instance dragging should be handled on\n    // An instance by instance basis rather than coming from the view's gestures\n  }\n}\n","import { Vec2 } from \"../math/vector\";\nimport { normalizeWheel } from \"./normalize-wheel\";\n\n/**\n * Analyzes a MouseEvent and calculates the mouse coordinates (relative to the element).\n */\nfunction eventElementPosition(e: any, relative?: HTMLElement): Vec2 {\n  let mouseX: number = 0,\n    mouseY: number = 0,\n    eventX: number = 0,\n    eventY: number = 0,\n    object: any =\n      relative || (e.nativeEvent && e.nativeEvent.target) || e.target;\n\n  // Get mouse position on document crossbrowser\n  if (!e) {\n    e = window.event;\n  }\n\n  if (e.pageX || e.pageY) {\n    mouseX = e.pageX;\n    mouseY = e.pageY;\n  } else if (e.clientX || e.clientY) {\n    let scrollLeft = 0;\n    let scrollTop = 0;\n\n    if (document.documentElement) {\n      scrollLeft = document.documentElement.scrollLeft;\n      scrollTop = document.documentElement.scrollTop;\n    }\n\n    mouseX = e.clientX + document.body.scrollLeft + scrollLeft;\n    mouseY = e.clientY + document.body.scrollTop + scrollTop;\n  }\n\n  // Get parent element position in document\n  if (object.offsetParent) {\n    do {\n      eventX += object.offsetLeft;\n      eventY += object.offsetTop;\n      object = object.offsetParent;\n    } while (object);\n  }\n\n  // Mouse position minus elm position is mouseposition relative to element:\n  return [mouseX - eventX, mouseY - eventY];\n}\n\nexport { eventElementPosition, normalizeWheel };\n","import { Bounds } from \"../math/primitives/bounds\";\nimport { isVec2, Vec2 } from \"../math/vector\";\n\n// A configuration that controls how readily a quadtree will split to another level\n// Adjusting this number can improve or degrade your performance significantly and\n// Must be tested for specific use cases\nconst maxPopulation: number = 5;\nconst maxDepth: number = 10;\n\nexport type IQuadTreeItem = Bounds<any>;\n\n/**\n * This filters a quad tree query by type\n *\n * @export\n * @template T\n */\nexport function filterQuery<T extends IQuadTreeItem>(\n  type: Function[],\n  queryValues: IQuadTreeItem[]\n): T[] {\n  const filtered: T[] = [];\n\n  queryValues.forEach((obj: IQuadTreeItem) => {\n    if (type.find(t => obj instanceof t)) {\n      filtered.push(obj as T);\n    }\n  });\n\n  return filtered;\n}\n\n/**\n * Allows typing of a callback argument\n */\nexport interface IQuadTreeVisitFunction<T extends IQuadTreeItem> {\n  /**\n   * A callback to use during add or query\n   *\n   * Called do provide aggregation or filtering like Array.reduce or\n   * Array.filter, but in a QuadTree instead.\n   *\n   * @param node  The node to effect the function upon\n   * @param child The child to add to the node\n   */\n  (node: QuadTreeNode<T>, child?: IQuadTreeItem): void;\n}\n\n/**\n * This is a class used specifically by the quad tree nodes to indicate split space\n * within the quad tree.\n *\n * @class Quadrants\n */\nexport class QuadTreeQuadrants<T extends IQuadTreeItem> {\n  TL: QuadTreeNode<T>;\n  TR: QuadTreeNode<T>;\n  BL: QuadTreeNode<T>;\n  BR: QuadTreeNode<T>;\n\n  /**\n   * Ensures all memory is released for all nodes and all references are removed\n   * to potentially high memory consumption items\n   *\n   * @memberOf Quadrants\n   */\n  destroy() {\n    this.TL.destroy();\n    this.TR.destroy();\n    this.BL.destroy();\n    this.BR.destroy();\n    delete this.TL;\n    delete this.TR;\n    delete this.BL;\n    delete this.BR;\n  }\n\n  /**\n   * Creates an instance of Quadrants.\n   *\n   * @param bounds The bounds this will create quandrants for\n   * @param depth  The child depth of this element\n   *\n   * @memberOf Quadrants\n   */\n  constructor(bounds: IQuadTreeItem, depth: number) {\n    const mid = bounds.mid;\n    this.TL = new QuadTreeNode<T>(bounds.x, mid[0], bounds.y, mid[1], depth);\n    this.TR = new QuadTreeNode<T>(\n      mid[0],\n      bounds.right,\n      bounds.y,\n      mid[1],\n      depth\n    );\n    this.BL = new QuadTreeNode<T>(\n      bounds.x,\n      mid[0],\n      mid[1],\n      bounds.bottom,\n      depth\n    );\n    this.BR = new QuadTreeNode<T>(\n      mid[0],\n      bounds.right,\n      mid[1],\n      bounds.bottom,\n      depth\n    );\n  }\n}\n\n/**\n * The quad tree node. This Node will take in a certain population before dividing itself into\n * 4 quadrants which it will attempt to inject it's population into. If a member of the population\n * does not completely get injected into one of the quadrants it remains as a member of this node.\n *\n * @export\n * @class Node\n */\nexport class QuadTreeNode<T extends IQuadTreeItem> {\n  bounds: Bounds<never>;\n  children: T[] = [];\n  depth: number = 0;\n  nodes: QuadTreeQuadrants<T>;\n\n  /**\n   * Destroys this node and ensures all child nodes are destroyed as well.\n   *\n   * @memberOf Node\n   */\n  destroy() {\n    delete this.children;\n    delete this.bounds;\n\n    if (this.nodes) {\n      this.nodes.destroy();\n      delete this.nodes;\n    }\n  }\n\n  /**\n   * Creates an instance of Node.\n   *\n   * @param l     The bounding left wall of the space this node covers\n   * @param r     The bounding right wall of the space this node covers\n   * @param t     The bounding top wall of the space this node covers\n   * @param b     The bounding bottom wall of the space this node covers\n   * @param depth The depth within the quad tree this node resides\n   *\n   * @memberOf Node\n   */\n  constructor(\n    left: number,\n    right: number,\n    top: number,\n    bottom: number,\n    depth?: number\n  ) {\n    // If params insertted\n    if (arguments.length >= 4) {\n      this.bounds = new Bounds({ left, right, top, bottom });\n    } else {\n      // Otherwise, make tiny start area\n      this.bounds = new Bounds({ left: 0, right: 1, top: 0, bottom: 1 });\n    }\n\n    // Ensure the depth is set\n    this.depth = depth || 0;\n  }\n\n  /**\n   * Adds an object that extends Bounds (or is Bounds) and properly injects it into this node\n   * or into a sub quadrant if this node is split already. If the child is outside the boundaries\n   * this quad tree spans (and this is the root node), the quad tree will expand to include\n   * the new child.\n   *\n   * @param child The Bounds type object to inject\n   * @param props Properties that can be retrieved with the child object if applicable\n   *\n   * @returns True if the insertion was successful\n   *\n   * @memberOf Node\n   */\n  add(child: T, props: any): boolean {\n    // This is the entry function for adding children, so we must first expand our top node\n    // To cover the area that the child is located.\n    // If we're in bounds, then let's just add the child\n    if (child.isInside(this.bounds)) {\n      return this.doAdd(child);\n    } else {\n      // Otherwise, we need to expand first\n      this.cover(child);\n      return this.add(child, props);\n    }\n  }\n\n  /**\n   * Adds a list of new children to this quad tree. It performs the same operations as\n   * addChild for each child in the list, however, it more efficiently recalculates the\n   * bounds necessary to cover the area the children cover.\n   *\n   * @param children      List of Bounds objects to inject\n   */\n  addAll(children: T[]) {\n    // Make sure we cover the entire area of all the children.\n    // We can speed this up a lot if we first calculate the total bounds the new children covers\n    let minX = Number.MAX_SAFE_INTEGER,\n      minY = Number.MAX_SAFE_INTEGER,\n      maxX = Number.MIN_SAFE_INTEGER,\n      maxY = Number.MIN_SAFE_INTEGER;\n\n    const { min, max } = Math;\n\n    // Get the dimensions of the new bounds\n    for (let i = 0, iMax = children.length; i < iMax; ++i) {\n      const child = children[i];\n\n      minX = min(minX, child.x);\n      maxX = max(child.right, maxX);\n      minY = min(minY, child.y);\n      maxY = max(maxY, child.bottom);\n    }\n\n    // Make sure our bounds includes the specified bounds\n    this.cover(\n      new Bounds({ left: minX, right: maxX, top: minY, bottom: maxY })\n    );\n    // Add all of the children into the tree\n    children.forEach(child => this.doAdd(child));\n  }\n\n  /**\n   * Ensures this quad tree includes the bounds specified in it's spatial coverage.\n   * This will cause all children to be re-injected into the tree.\n   *\n   * @param bounds The bounds to include in the tree's coverage\n   */\n  cover(bounds: IQuadTreeItem) {\n    // If we are already covering the area: abort\n    if (bounds.isInside(this.bounds)) {\n      return;\n    }\n\n    // Make our bounds cover the new area\n    this.bounds.encapsulate(bounds);\n    this.bounds.x -= 1;\n    this.bounds.y -= 1;\n    this.bounds.width += 2;\n    this.bounds.height += 2;\n    // Get all of the children underneath this node\n    const allChildren = this.gatherChildren([]);\n\n    // Destroy the split nodes\n    if (this.nodes) {\n      // completely...destroy...\n      this.nodes.destroy();\n      delete this.nodes;\n    }\n\n    // Reinsert all children with the new dimensions in place\n    allChildren.forEach(child => this.doAdd(child));\n  }\n\n  /**\n   * When adding children, this performs the actual action of injecting the child into the tree\n   * without the process of seeing if the tree needs a spatial adjustment to account for the child.\n   *\n   * @param child The Bounds item to inject into the tree\n   *\n   * @returns True if the injection was successful\n   */\n  doAdd(child: T): boolean {\n    // If nodes are present, then we have already exceeded the population of this node\n    if (this.nodes) {\n      if (child.isInside(this.nodes.TL.bounds)) {\n        return this.nodes.TL.doAdd(child);\n      }\n\n      if (child.isInside(this.nodes.TR.bounds)) {\n        return this.nodes.TR.doAdd(child);\n      }\n\n      if (child.isInside(this.nodes.BL.bounds)) {\n        return this.nodes.BL.doAdd(child);\n      }\n\n      if (child.isInside(this.nodes.BR.bounds)) {\n        return this.nodes.BR.doAdd(child);\n      }\n\n      // Otherwise, this is a child overlapping this border\n      this.children.push(child);\n\n      return true;\n    } else if (child.isInside(this.bounds)) {\n      // Otherwise, we have not had a split due to population limits being exceeded\n      this.children.push(child);\n\n      // If we exceeded our population for this quadrant, it is time to split up\n      if (this.children.length > maxPopulation && this.depth < maxDepth) {\n        this.split();\n      }\n\n      return true;\n    }\n\n    // This is when there is something wrong with the insertted child. The bounds\n    // For the quad should have grown without issue, but in this case the bounds\n    // Could not grow to accomodate the child.\n    if (isNaN(child.width + child.height + child.x + child.y)) {\n      console.error(\n        \"Child did not fit into bounds because a dimension is NaN\",\n        child\n      );\n    } else if (child.area === 0) {\n      console.error(\n        \"Child did not fit into bounds because the area is zero\",\n        child\n      );\n    }\n\n    // Don't insert the child and continue\n    return true;\n  }\n\n  /**\n   * Collects all children of all the current and sub nodes into a single list.\n   *\n   * @param list The list we must aggregate children into\n   *\n   * @return The list specified as the list parameter\n   */\n  gatherChildren(list: T[], visit?: IQuadTreeVisitFunction<T>): T[] {\n    if (visit) visit(this);\n\n    for (let i = 0, iMax = this.children.length; i < iMax; ++i) {\n      list.push(this.children[i]);\n    }\n\n    if (this.nodes) {\n      this.nodes.TL.gatherChildren(list, visit);\n      this.nodes.TR.gatherChildren(list, visit);\n      this.nodes.BL.gatherChildren(list, visit);\n      this.nodes.BR.gatherChildren(list, visit);\n    }\n\n    return list;\n  }\n\n  /**\n   * Entry query for determining query type based on input object\n   *\n   * @param bounds Can be a Bounds or a Point object\n   * @param visit  A callback function that will receive the Node as it is analyzed. This gives\n   *               information on a spatial scale, how a query reaches it's target intersections.\n   *\n   * @return An array of children that intersects with the query\n   */\n  query(bounds: IQuadTreeItem | Vec2, visit?: IQuadTreeVisitFunction<T>): T[] {\n    // Query a rectangle\n    if (bounds instanceof Bounds) {\n      if (bounds.hitBounds(this.bounds)) {\n        return this.queryBounds(bounds, [], visit);\n      }\n\n      // Return an empty array when nothing is collided with\n      return [];\n    } else if (isVec2(bounds)) {\n      // Query a point\n      if (this.bounds.containsPoint(bounds)) {\n        return this.queryPoint(bounds, [], visit);\n      }\n    }\n\n    // Return an empty array when nothing is collided with\n    return [];\n  }\n\n  /**\n   * Queries children for intersection with a bounds object\n   *\n   * @param b     The Bounds to test children against\n   * @param list  The list of children to aggregate into the query\n   * @param visit A callback function that will receive the Node as it is analyzed. This gives\n   *              information on a spatial scale, how a query reaches it's target intersections.\n   *\n   * @return     Returns the exact same list that was input as the list param\n   */\n  queryBounds(\n    b: IQuadTreeItem,\n    list: T[],\n    visit?: IQuadTreeVisitFunction<T>\n  ): T[] {\n    // As an optimization for querying by bounds, if the bounds engulfs these bounds,\n    // we can assume all of the contents of this node and child nodes are hit by the bounds\n    // So simply gather the child items and don't do extra tests\n    if (this.bounds.isInside(b)) {\n      this.gatherChildren(list, visit);\n      return list;\n    }\n\n    // Gather the children as hit at this point\n    this.children.forEach(c => {\n      if (c.hitBounds(b)) {\n        list.push(c);\n      }\n    });\n\n    if (visit) {\n      visit(this);\n    }\n\n    if (this.nodes) {\n      if (b.hitBounds(this.nodes.TL.bounds)) {\n        this.nodes.TL.queryBounds(b, list, visit);\n      }\n\n      if (b.hitBounds(this.nodes.TR.bounds)) {\n        this.nodes.TR.queryBounds(b, list, visit);\n      }\n\n      if (b.hitBounds(this.nodes.BL.bounds)) {\n        this.nodes.BL.queryBounds(b, list, visit);\n      }\n\n      if (b.hitBounds(this.nodes.BR.bounds)) {\n        this.nodes.BR.queryBounds(b, list, visit);\n      }\n    }\n\n    return list;\n  }\n\n  /**\n   * Queries children for intersection with a point\n   *\n   * @param p     The Point to test children against\n   * @param list  The list of children to aggregate into the query\n   * @param visit A callback function that will receive the Node as it is analyzed. This gives\n   *              information on a spatial scale, how a query reaches it's target intersections.\n   *\n   * @return      Returns the exact same list that was input as the list param\n   */\n  queryPoint(p: any, list: T[], visit?: IQuadTreeVisitFunction<T>): T[] {\n    this.children.forEach(c => {\n      if (c.containsPoint(p)) {\n        list.push(c);\n      }\n    });\n\n    if (visit) {\n      visit(this);\n    }\n\n    if (this.nodes) {\n      if (this.nodes.TL.bounds.containsPoint(p)) {\n        this.nodes.TL.queryPoint(p, list, visit);\n      }\n\n      if (this.nodes.TR.bounds.containsPoint(p)) {\n        this.nodes.TR.queryPoint(p, list, visit);\n      }\n\n      if (this.nodes.BL.bounds.containsPoint(p)) {\n        this.nodes.BL.queryPoint(p, list, visit);\n      }\n\n      if (this.nodes.BR.bounds.containsPoint(p)) {\n        this.nodes.BR.queryPoint(p, list, visit);\n      }\n    }\n\n    return list;\n  }\n\n  /**\n   * Creates four sub quadrants for this node.\n   */\n  split() {\n    // Gather all items to be handed down\n    const allChildren: T[] = [];\n    this.gatherChildren(allChildren);\n    // Gather all props for the children to be handed down as well\n    this.nodes = new QuadTreeQuadrants<T>(this.bounds, this.depth + 1);\n    // Clear the children from our node to be reinjected to re-assess where they belong\n    // within the split nodes\n    this.children = [];\n\n    for (let i = 0, iMax = allChildren.length; i < iMax; ++i) {\n      const child = allChildren[i];\n      if (child) this.doAdd(child);\n    }\n  }\n\n  /**\n   * Traverses the quad tree returning every quadrant encountered\n   *\n   * @param cb A callback that has the parameter (node) which is a quadrant in the tree\n   */\n  visit(cb: IQuadTreeVisitFunction<T>): void {\n    const finished = Boolean(cb(this));\n\n    if (this.nodes && !finished) {\n      this.nodes.TL.visit(cb);\n      this.nodes.TR.visit(cb);\n      this.nodes.BL.visit(cb);\n      this.nodes.BR.visit(cb);\n    }\n  }\n}\n\nexport class QuadTree<T extends IQuadTreeItem> extends QuadTreeNode<T> {}\n","import { EventManager } from \"./event-manager\";\nimport { SimpleEventHandler } from \"./simple-event-handler\";\nimport {\n  IEventInteraction,\n  IMouseInteraction,\n  ITouchInteraction\n} from \"./types\";\n\n/**\n * This takes in events and stores them for a later moment to be dequeued in a\n * controlled manner where timing is important relative to other actions\n * happening.\n */\nexport class QueuedEventHandler extends EventManager {\n  private handlers: SimpleEventHandler;\n  private preserveQueueMouse: [Function, IEventInteraction][] = [];\n  private singleQueueMouse = new Map<Function, IEventInteraction>();\n  private preserveQueueTouch: [Function, ITouchInteraction][] = [];\n  private singleQueueTouch = new Map<Function, ITouchInteraction>();\n  private preserveEvents: boolean = false;\n\n  /**\n   * Default ctor for Queued event handling.\n   *\n   * @param handlers Custom handlers for all of the normal Event manager events\n   * @param preserveEvents When set to true, ALL events will be stored and\n   *                       broadcasted upon dequeuing of the events. Conversely,\n   *                       when false, only the last event of a given event type\n   *                       will be preserved for broadcast.\n   */\n  constructor(\n    handlers: Partial<EventManager>,\n    preserveEvents: boolean = false\n  ) {\n    super();\n    this.handlers = new SimpleEventHandler(handlers);\n    this.preserveEvents = preserveEvents;\n  }\n\n  /**\n   * Broadcast all of the events this manager is hanging onto in the order the\n   * events were received.\n   */\n  dequeue() {\n    try {\n      if (this.preserveEvents) {\n        this.preserveQueueMouse.forEach(queue => {\n          queue[0](queue[1]);\n        });\n\n        this.preserveQueueTouch.forEach(queue => {\n          queue[0](queue[1]);\n        });\n      } else {\n        this.singleQueueMouse.forEach((event, handler) => {\n          handler(event);\n        });\n\n        this.singleQueueTouch.forEach((event, handler) => {\n          handler(event);\n        });\n      }\n    } catch (err) {\n      console.error(\"Queued events had errors. Further events aborted\");\n      console.error(err.stack || err.message);\n    }\n\n    this.preserveQueueMouse = [];\n    this.singleQueueMouse.clear();\n    this.preserveQueueTouch = [];\n    this.singleQueueTouch.clear();\n  }\n\n  handleMouseDown(e: IMouseInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueMouse.push([this.handlers.handleMouseDown, e]);\n    } else this.singleQueueMouse.set(this.handlers.handleMouseDown, e);\n  }\n\n  handleMouseUp(e: IMouseInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueMouse.push([this.handlers.handleMouseUp, e]);\n    } else this.singleQueueMouse.set(this.handlers.handleMouseUp, e);\n  }\n\n  handleMouseOver(e: IMouseInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueMouse.push([this.handlers.handleMouseOver, e]);\n    } else this.singleQueueMouse.set(this.handlers.handleMouseOver, e);\n  }\n\n  handleMouseOut(e: IMouseInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueMouse.push([this.handlers.handleMouseOut, e]);\n    } else this.singleQueueMouse.set(this.handlers.handleMouseOut, e);\n  }\n\n  handleMouseMove(e: IMouseInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueMouse.push([this.handlers.handleMouseMove, e]);\n    } else this.singleQueueMouse.set(this.handlers.handleMouseMove, e);\n  }\n\n  handleClick(e: IMouseInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueMouse.push([this.handlers.handleClick, e]);\n    } else this.singleQueueMouse.set(this.handlers.handleClick, e);\n  }\n\n  handleDrag(e: IMouseInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueMouse.push([this.handlers.handleDrag, e]);\n    } else this.singleQueueMouse.set(this.handlers.handleDrag, e);\n  }\n\n  handleWheel(e: IMouseInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueMouse.push([this.handlers.handleWheel, e]);\n    } else this.singleQueueMouse.set(this.handlers.handleWheel, e);\n  }\n\n  handleTouchCancelled(e: ITouchInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueTouch.push([this.handlers.handleTouchCancelled, e]);\n    } else this.singleQueueTouch.set(this.handlers.handleTouchCancelled, e);\n  }\n\n  handleTouchDown(e: ITouchInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueTouch.push([this.handlers.handleTouchDown, e]);\n    } else this.singleQueueTouch.set(this.handlers.handleTouchDown, e);\n  }\n\n  handleTouchUp(e: ITouchInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueTouch.push([this.handlers.handleTouchUp, e]);\n    } else this.singleQueueTouch.set(this.handlers.handleTouchUp, e);\n  }\n\n  handleTouchOut(e: ITouchInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueTouch.push([this.handlers.handleTouchOut, e]);\n    } else this.singleQueueTouch.set(this.handlers.handleTouchOut, e);\n  }\n\n  handleTouchDrag(e: ITouchInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueTouch.push([this.handlers.handleTouchDrag, e]);\n    } else this.singleQueueTouch.set(this.handlers.handleTouchDrag, e);\n  }\n\n  handleTap(e: ITouchInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueTouch.push([this.handlers.handleTap, e]);\n    } else this.singleQueueTouch.set(this.handlers.handleTap, e);\n  }\n\n  handleDoubleTap(e: ITouchInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueTouch.push([this.handlers.handleDoubleTap, e]);\n    } else this.singleQueueTouch.set(this.handlers.handleDoubleTap, e);\n  }\n\n  handleLongTouch(e: ITouchInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueTouch.push([this.handlers.handleLongTouch, e]);\n    } else this.singleQueueTouch.set(this.handlers.handleLongTouch, e);\n  }\n\n  handleLongTap(e: ITouchInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueTouch.push([this.handlers.handleLongTap, e]);\n    } else this.singleQueueTouch.set(this.handlers.handleLongTap, e);\n  }\n\n  handlePinch(e: ITouchInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueTouch.push([this.handlers.handlePinch, e]);\n    } else this.singleQueueTouch.set(this.handlers.handlePinch, e);\n  }\n\n  handleSpread(e: ITouchInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueTouch.push([this.handlers.handleSpread, e]);\n    } else this.singleQueueTouch.set(this.handlers.handleSpread, e);\n  }\n\n  handleTouchRotate(e: ITouchInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueTouch.push([this.handlers.handleTouchRotate, e]);\n    } else this.singleQueueTouch.set(this.handlers.handleTouchRotate, e);\n  }\n\n  handleSwipe(e: ITouchInteraction): void {\n    if (this.preserveEvents) {\n      this.preserveQueueTouch.push([this.handlers.handleSwipe, e]);\n    } else this.singleQueueTouch.set(this.handlers.handleSwipe, e);\n  }\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport { IInstanceAttribute, IUniform, IVertexAttribute } from \"../../types\";\n\n/**\n * This provides the sorting methods to be applied to\n */\nexport class BaseIOSorting {\n  /**\n   * This sorts the attributes such that the attributes that MUST be updated first are put to the top.\n   * This is necessary for complex attributes like atlas and easing attributes who have other attributes\n   * that have dependent behaviors based on their source attribute.\n   */\n  sortInstanceAttributes<T extends Instance>(\n    a: IInstanceAttribute<T>,\n    b: IInstanceAttribute<T>\n  ) {\n    if (a.resource && !b.resource) return -1;\n    if (a.easing && !b.easing) return -1;\n    return 1;\n  }\n\n  /**\n   * This sorts the vertex attributes in the expected order of updating.\n   */\n  sortVertexAttributes(_a: IVertexAttribute, _b: IVertexAttribute) {\n    return 1;\n  }\n\n  /**\n   * This sorts the uniforms in the expected order of updating.\n   */\n  sortUniforms(_a: IUniform, _b: IUniform) {\n    return 1;\n  }\n}\n","export * from \"./cpu-sdf\";\nexport * from \"./font-manager\";\nexport * from \"./font-map\";\nexport * from \"./font-renderer\";\nexport * from \"./font-resource-manager\";\nexport * from \"./font-resource-request\";\nexport * from \"./glyph-renderer\";\n","import { Bounds } from \"../../math/primitives\";\nimport { PackNode } from \"../../resources/texture/pack-node\";\nimport { Omit, ResourceType, Size } from \"../../types\";\nimport { BaseResourceOptions } from \"../base-resource-manager\";\nimport { SubTexture } from \"../texture/sub-texture\";\nimport { FontMap, FontMapGlyphType } from \"./font-map\";\nimport { FontRenderer } from \"./font-renderer\";\nimport { fontRequest, IFontResourceRequest } from \"./font-resource-request\";\n\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * Valid glyph rendering sizes that the system will use when rendering the glyphs to the font map's texture.\n */\nexport enum FontGlyphRenderSize {\n  /** NOT RECOMMENDED: You lose a lot of quality with this size. Use only if you do not need your text larger than 16 ever. */\n  _16 = 16,\n  /** Ideal size for simple SDF technique that trades used memory for quality */\n  _32 = 32,\n  /** Better quality glyphs for rendering, but suffers from resource useasge */\n  _64 = 64,\n  /** NOT RECOMMENDED: This is very large and will not allow for many glyphs on a single texture */\n  _128 = 128\n}\n\n/**\n * Metrics for a font map source specification.\n */\nexport interface IFontMapMetrics {\n  /**\n   * EXPERIMENTAL: When enabled, this allows the framework to cache the kerning pair calculations in the local storage.\n   * This can greatly speed up reload times of this chart, but may come with consequences as well.\n   */\n  localKerningCache?: boolean;\n  /** A type indicator to help identify which type of font resource is provided */\n  type?: FontMapGlyphType;\n  /** Size the font is rendered to the font map */\n  size: number;\n  /** Family of the font to be rendered to the font map */\n  family: string;\n  /** Font weight of the font to be rendered to the font map */\n  weight: string | number;\n  /** Applies pre-computed strings to warm up kerning pairs and glyph renderings before any label is generated. */\n  preload?: string;\n}\n\nexport interface ISimpleFontMapMetrics extends IFontMapMetrics {\n  type: undefined;\n}\n\n/**\n * Indicates a bitmap font source.\n */\nexport interface IBitmapFontSource extends IFontMapMetrics {\n  /** This indicates a bitmap style of font rendering is required of the font. */\n  type: FontMapGlyphType.BITMAP;\n}\n\n/**\n * The available properties of a prerendered font source\n */\nexport interface IPrerenderedFontSource extends IFontMapMetrics {\n  /** This is the glyph renderings in Base64 encoding */\n  glyphs: { [key: string]: string };\n  /** This is the glyph used when no glyph is available */\n  errorGlyph: string;\n}\n\n/**\n * This is a provided pre-rendered SDF resource object format.\n */\nexport interface IPrerenderedSDFFontSource extends IPrerenderedFontSource {\n  /** This is the indicator that this prerendered resource is SDF */\n  type: FontMapGlyphType.SDF;\n}\n\n/**\n * This is a provided pre-rendered MSDF resource object format.\n */\nexport interface IPrerenderedMSDFFontSource extends IPrerenderedFontSource {\n  /** This is the indicator that this prerendered resource is MlSDF */\n  type: FontMapGlyphType.MSDF;\n}\n\n/**\n * These are the valid sources of a font from which the system will derive the glyphs and font metrics necessary\n * to render text to the screen.\n */\nexport type FontMapSource =\n  | IFontMapMetrics\n  | IBitmapFontSource\n  | IPrerenderedSDFFontSource\n  | IPrerenderedMSDFFontSource;\n\n/**\n * Options for creating a new Font Resource.\n */\nexport interface IFontResourceOptions extends BaseResourceOptions {\n  /**\n   * When this is provided ONLY these characters will be supplied by this resource.\n   * This is simply a string with every character to allow. Filtering glyphs can greatly\n   * speed up performance. When not provided, the system will analyze strings as they stream in\n   * and will update the atlas with the needed glyphs to render the text.\n   */\n  characterFilter?: string;\n  /**\n   * When this is set, the system will add glyphs to the font map from the font source provided as the glyphs\n   * are needed. This performs not as well as preset fonts. You can combine dynamic with characterFilter to have\n   * initial glyphs be preloaded and work faster from the start. Or you can use the character filter but NOT be dynamic\n   * and enforce strict character allowances.\n   */\n  dynamic?: boolean;\n  /** If the system has generated the font map for this resource, this will be populated */\n  fontMap?: FontMap;\n  /**\n   * This is the source the font information is derived from.\n   *\n   * A string will cause the system to use canvas rendering to attempt to best calculate the font glyphs and metrics as best\n   * as possible. This is the slowest possible method to render text.\n   *\n   * It is much better to used the pre-rendered formats.\n   */\n  fontSource: FontMapSource;\n  /** Enforce the resource to be a FONT type */\n  type: ResourceType.FONT;\n  /** If provided will constrain the texture to the provided size */\n  fontMapSize?: Size;\n}\n\n/**\n * Type guard for font resource options type\n */\nexport function isFontResource(\n  val: BaseResourceOptions\n): val is IFontResourceOptions {\n  return val && val.type === ResourceType.FONT;\n}\n\n/**\n * This is the string font source type guard.\n */\nfunction isSimpleFontMetrics(val: any): val is ISimpleFontMapMetrics {\n  return val && val.type === undefined;\n}\n\n/**\n * Method for making typings and API feedback easier. Just a wrapper for building\n * an IFontResourceOptions object. Excludes the need to specify the type.\n */\nexport function createFont(\n  options: Omit<IFontResourceOptions, \"type\" | \"key\"> &\n    Partial<Pick<IFontResourceOptions, \"key\">>\n): IFontResourceOptions {\n  return {\n    key: \"\",\n    type: ResourceType.FONT,\n    ...options\n  };\n}\n\n/**\n * This manager is responsible for handling the actual generation and updating of Font textures.\n *\n * This manager handles consuming resource options and producing an appropriate resource based on\n * either generating the SDF at run time or loading up a provided pre-rendered font resource.\n */\nexport class FontManager {\n  /** The lookup for the font map resources by their key */\n  fontMaps = new Map<string, FontMap>();\n  /**\n   * Contains the methods needed to render glyphs and calculate kerning\n   * when no precomputed resources are available.\n   */\n  fontRenderer = new FontRenderer();\n\n  /**\n   * This takes all requests that want layout information included for a group of text\n   * and populates the request with the appropriate information.\n   */\n  async calculateMetrics(\n    resourceKey: string,\n    requests: IFontResourceRequest[]\n  ) {\n    debug(\"Calculating metrics for requests\");\n    const fontMap = this.fontMaps.get(resourceKey);\n    if (!fontMap) return;\n\n    for (let i = 0, iMax = requests.length; i < iMax; ++i) {\n      const request = requests[i];\n      const metrics = request.metrics;\n\n      // Only some requests will have metrics to be calculated\n      if (metrics) {\n        // Get the layout of the request\n        metrics.layout = fontMap.getStringLayout(\n          metrics.text,\n          metrics.fontSize,\n          metrics.letterSpacing\n        );\n\n        // If a max width is present, we need to calculate the truncation of the label\n        if (metrics.maxWidth) {\n          debug(\"Calculating truncation for\", metrics.text, metrics.maxWidth);\n\n          metrics.layout = await fontMap.getTruncatedLayout(\n            metrics.layout,\n            metrics.truncation || \"\",\n            metrics.maxWidth,\n            metrics.fontSize,\n            metrics.letterSpacing,\n            this.fontRenderer\n          );\n\n          // Show what the truncated text is\n          metrics.truncatedText = metrics.layout.text;\n        }\n      }\n    }\n  }\n\n  /**\n   * Converts a character filter to a deduped list of single characters\n   */\n  private characterFilterToCharacters(filter: string): string {\n    const characters = new Set<string>();\n    let all = \"\";\n\n    for (let i = 0, iMax = filter.length; i < iMax; ++i) {\n      const char = filter[i];\n\n      if (!characters.has(char)) {\n        characters.add(char);\n        all += char;\n      }\n    }\n\n    return all;\n  }\n\n  /**\n   * This generates a new font map object to work with. It will either be pre-rendered or dynamically\n   * populated as requests are made.\n   */\n  async createFontMap(resourceOptions: IFontResourceOptions) {\n    // This will contain all of the characters that the map initially starts with\n    const characters: string = this.characterFilterToCharacters(\n      resourceOptions.characterFilter || \"\"\n    );\n    // This is the generated font map specified by the resource options\n    let fontMap: FontMap | undefined;\n    // This is the source information of the font which the system will utilize to produce the map\n    const fontSource = resourceOptions.fontSource;\n    // This is the determined glyph type of the resource\n    let glyphType: FontMapGlyphType = FontMapGlyphType.SDF;\n\n    // We now determine what type of font source the options provide and set our font map\n    // up properly for it.\n    if (fontSource) {\n      if (isSimpleFontMetrics(fontSource)) {\n        glyphType = FontMapGlyphType.BITMAP;\n      } else {\n        glyphType = fontSource.type || glyphType;\n      }\n    }\n\n    // Create our new font map resource\n    fontMap = new FontMap({\n      ...resourceOptions,\n      glyphType\n    });\n\n    // Apply initial characters to the fontMap\n    await this.updateFontMapCharacters(characters, fontMap);\n    // Keep the generated font map as our resource\n    this.fontMaps.set(resourceOptions.key, fontMap);\n\n    // Check if the font source has some preload characters needed to update the fontmap with to improve initial render\n    // times of resources making requests\n    if (resourceOptions.fontSource.preload) {\n      this.updateFontMap(resourceOptions.key, [\n        fontRequest({\n          key: resourceOptions.key,\n          character: \"\",\n          kerningPairs: [resourceOptions.fontSource.preload],\n          metrics: {\n            fontSize: 12,\n            text: resourceOptions.fontSource.preload,\n            letterSpacing: 0\n          }\n        })\n      ]);\n    }\n\n    return fontMap;\n  }\n\n  /**\n   * Free all generated resources here.\n   */\n  destroy() {\n    // Clears up resources\n    this.fontMaps.forEach(font => font.destroy());\n  }\n\n  /**\n   * Destroy a single font map\n   */\n  destroyFontMap(key: string) {\n    const fontMap = this.fontMaps.get(key);\n    if (!fontMap) return;\n    fontMap.destroy();\n  }\n\n  /**\n   * This updates a font map with requests made. After the font map is updated, the\n   * requests should be populated with the appropriate sub texture information.\n   */\n  async updateFontMap(resourceKey: string, requests: IFontResourceRequest[]) {\n    const fontMap = this.fontMaps.get(resourceKey);\n    if (!fontMap) return;\n\n    let allPairs: string[] = [];\n    const allCharacters = new Set<string>();\n\n    // Aggregate all kerning and character requests and needs\n    for (let i = 0, iMax = requests.length; i < iMax; ++i) {\n      const req = requests[i];\n      if (req.character) allCharacters.add(req.character);\n      if (req.kerningPairs) allPairs = allPairs.concat(req.kerningPairs);\n\n      // We add in truncation characters as well if provided\n      if (req.metrics) {\n        if (req.metrics.truncation) {\n          const truncation = req.metrics.truncation.replace(/\\s/g, \"\");\n          allPairs.push(truncation);\n\n          for (let i = 0, iMax = req.metrics.truncation.length; i < iMax; ++i) {\n            allCharacters.add(truncation);\n          }\n        }\n      }\n    }\n\n    // Kerning pairs are also candidates for being rendered to the font map\n    for (let i = 0, iMax = allPairs.length; i < iMax; ++i) {\n      allCharacters.add(allPairs[i]);\n    }\n\n    // Convert the characters to be rendered to a sinple string\n    let uniqueCharacters: string = \"\";\n    allCharacters.forEach(char => (uniqueCharacters += char));\n\n    // Perform the updates to the font map\n    await this.updateFontMapCharacters(uniqueCharacters, fontMap);\n    // Perform the updates to the kerning pairs\n    await this.updateKerningPairs(allPairs, fontMap);\n\n    // After all this is done, all the requests can be populated with the font map\n    // signaling the request now has the resources to accomplish what it needs\n    for (let i = 0, iMax = requests.length; i < iMax; ++i) {\n      requests[i].fontMap = fontMap;\n    }\n  }\n\n  /**\n   * This updates the calculated kerning pairs for a given font map.\n   */\n  private async updateKerningPairs(pairs: string[], fontMap?: FontMap) {\n    if (!fontMap) return;\n\n    // Calculate the new kerning pair information\n    const kerning = await this.fontRenderer.estimateKerning(\n      pairs,\n      fontMap.fontString,\n      fontMap.fontSource.size,\n      fontMap.kerning,\n      !fontMap.spaceWidth\n    );\n\n    // Add the pairs to the font map\n    fontMap.addKerning(kerning.pairs);\n    // Set the calculated width of a space\n    fontMap.spaceWidth = fontMap.spaceWidth || kerning.spaceWidth;\n  }\n\n  /**\n   * This updates a specified font map with a list of characters expected within it.\n   */\n  private async updateFontMapCharacters(characters: string, fontMap?: FontMap) {\n    if (!fontMap) return;\n    const texture = fontMap.texture;\n\n    // We must determine which characters are not supported by the font map first\n    const toAdd = fontMap.findMissingCharacters(characters);\n    // Nothing to add, then nothig to do!\n    if (toAdd.length <= 0) return;\n\n    // Get all the glyph data we need to update to the Font Map's texture\n    const glyphs = this.fontRenderer.makeBitmapGlyphs(\n      toAdd,\n      fontMap.fontString,\n      fontMap.fontSource.size\n    );\n\n    // Apply each newly rendered glyph into the font map\n    for (const char in glyphs) {\n      const metrics = glyphs[char];\n\n      if (texture.data) {\n        const packBounds = new Bounds({\n          x: 0,\n          y: 0,\n          width: metrics.glyph.width,\n          height: metrics.glyph.height\n        });\n\n        // Make the sub texture object our packing is going to associate with\n        const subTexture = new SubTexture();\n\n        // Pack the glyph information into the font map texture\n        const packing = fontMap.packing.insert({\n          data: subTexture,\n          bounds: packBounds\n        });\n\n        if (!packing) {\n          console.warn(\n            \"Font map is full and could not pack in any more glyphs\"\n          );\n          return;\n        }\n\n        // Now use the packing information to update our texture\n        PackNode.applyToSubTexture(\n          fontMap.packing,\n          packing,\n          subTexture,\n          undefined,\n          true\n        );\n\n        // Apply the image to the texture\n        texture.update(metrics.glyph, {\n          ...packing.bounds,\n          y:\n            fontMap.packing.bounds.height -\n            packing.bounds.y -\n            packing.bounds.height\n        });\n\n        // Register the glyph with the font map\n        if (subTexture) fontMap.registerGlyph(char, subTexture);\n        else {\n          console.warn(\n            \"Could not generate a subtexture for the font map registration.\"\n          );\n        }\n      } else {\n        console.warn(\n          \"Can not update font map as the maps texture data is not defined.\"\n        );\n      }\n    }\n  }\n\n  /**\n   * TODO:\n   * We do not use this method yet as we do not have a format set for prerendered fonts.\n   * Currently the system only uses the bitmap font dynamic pattern.\n   *\n   * This renders the specified characters from a pre-rendered font source in ImageData that can be used to composite\n   * a texture.\n   */\n  async getPrerenderedImageData(\n    source: IPrerenderedFontSource,\n    glyphSize: FontGlyphRenderSize,\n    characters: string[]\n  ) {\n    const promises: Promise<void>[] = [];\n\n    // Loop through all of the characters to be loaded from the source\n    characters.forEach(char => {\n      let glyphData = source.glyphs[char];\n\n      // Make sure the character exists, if not, use the error glyph provided by the source\n      if (!glyphData) {\n        glyphData = source.errorGlyph;\n      }\n\n      // A valid error glyph MUST be present\n      if (!source.errorGlyph) {\n        console.warn(\n          \"The prerendered source provided did NOT provide a proper glyph for rendering when a glyph could not be located.\"\n        );\n        return [];\n      }\n\n      // Set up the waiting mechanisms and the resources to render our glyphs from Base64\n      const image = new Image();\n      let resolve: Function;\n      const promise = new Promise<void>(resolver => (resolve = resolver));\n\n      // Wait for the image to finish loading\n      image.onload = function() {\n        // Make our canvas context to render the glyph data to.\n        const canvas: HTMLCanvasElement = document.createElement(\"canvas\");\n        const context = canvas.getContext(\"2d\");\n        if (!context) return;\n        // Our canvas to render to will be the specified glyphSize block\n        canvas.width = glyphSize;\n        canvas.height = glyphSize;\n        // We want to draw the glyph the size of the desired glyph rendering\n        context.drawImage(image, 0, 0, glyphSize, glyphSize);\n        // Retreieve the data rendered to the canvas as our glyph data\n        const glyphData = context.getImageData(0, 0, glyphSize, glyphSize);\n        // Resolve with the rendered portion\n        resolve(glyphData);\n      };\n\n      // If an error occurrs\n      image.onerror = function() {\n        console.warn(\n          \"There was an issue with loading the glyph data for character:\",\n          char\n        );\n        resolve(null);\n      };\n\n      // Begin loading the glyph data into the image\n      image.src = source.glyphs[char];\n      promises.push(promise);\n\n      return [];\n    });\n\n    // This will contain all of the glyph render information\n    return await Promise.all(promises);\n  }\n}\n","import { nextFrame } from \"./frame\";\nimport { PromiseResolver } from \"./promise-resolver\";\n\n/**\n * This produces a method that is a gate for methods that may be entered multiple times before a valid dimension occurs.\n * This allows you to reduce the number of times the method is allowed to actually execute (reduced to a single\n * execution) once the dimensions are valid.\n *\n * For example, if we have an init() method that keeps getting called until object is properly initialized, but the\n * object is waiting for valid dimensions from it's container then you can get this pattern to happen:\n *\n * obj.init(); // no valid dimensions\n * obj.init(); // no valid dimensions\n * // dimensions are now valid!\n * obj.init(); // Initializes properly!\n *\n * You will notice an inherent problem or challenge. obj.init() probably contains code that shouldn't execute unless\n * the dimensions are available. Additionally you may see this happen:\n *\n * obj.init(); // no valid dimensions\n * // Nothing else happens\n * // Dimensions are now valid!\n * // obj.init isn't ever going to get called again\n *\n * So you are stuck with needing a robust initializer that can handle being called multiple times, only execute once,\n * and can wait for the dimensions to occur. It's also assumed the most recent init() call should be the one true\n * method call.\n *\n * So we have this method which allows you to make such a robust method:\n *\n * class Obj {\n *   waitToInit = waitForValidDimensions(container);\n *\n *   async init() {\n *     const result = this.waitToInit();\n *     if (!result) return;\n *     // Do your init\n *   }\n * }\n *\n * Now init methods will stack up waiting for the valid dimensions, but upon valid dimensions being available, all the\n * methods will resolve but only the latest init will actually execute as it will be the only one provided a 'true'\n * result.\n */\nexport function waitForValidDimensions(container?: HTMLElement) {\n  // This is the context flag for the operation. This let's us know which resolution is the most recent and is validly\n  // waiting for the container to finish\n  let waitForSizeContext = 0;\n  // We queue up all the resolvers for this context, this way we can resolve all existing gates if the container\n  // should change. If we're waiting for a new container with the same context, then we should assume the others that\n  // are waiting are no longer valid as only the most recent will resolve as a valid result (which, again, will be\n  // against a new container)\n  let resolvers: PromiseResolver<boolean>[] = [];\n\n  // This is the gate method that is used to await upon to receive a result from waiting for the dimensions.\n  const gate: Function & { cancel: Function } = Object.assign(\n    async (otherContainer?: HTMLElement): Promise<boolean> => {\n      // Check the input container, if we're suddenly waiting for a new container, the previous contexts should be\n      // invalid\n      if (otherContainer !== void 0 && otherContainer !== container) {\n        resolvers.forEach(r => r.resolve(false));\n        container = otherContainer;\n      }\n\n      // If a valid container is not specified, there is no way for this to ever resolve, so we immediately resolve to\n      // false.\n      if (!container) return false;\n\n      const waitForSizeId = ++waitForSizeContext;\n      const resolver = new PromiseResolver<boolean>();\n      let box = container.getBoundingClientRect();\n      let observer: MutationObserver | undefined;\n      resolvers.push(resolver);\n\n      // Check to ensure the box width and height is valid\n      if (box.width === 0 || box.height === 0) {\n        let observing = true;\n        const toWatch = {\n          attributes: true\n        };\n\n        // Try to use a DOM concept for waiting for changes to the container\n        observer = new MutationObserver(mutationsList => {\n          if (!observing) return;\n\n          for (const mutation of mutationsList) {\n            if (mutation.type === \"attributes\") {\n              // Make sure our container context stayed valid\n              if (!container) return;\n              box = container.getBoundingClientRect();\n\n              if (box.width !== 0 && box.height !== 0) {\n                if (observer) {\n                  observer.disconnect();\n                  observer = void 0;\n                }\n\n                observing = false;\n                resolver.resolve(waitForSizeId === waitForSizeContext);\n              }\n            }\n          }\n        });\n\n        observer.observe(container, toWatch);\n\n        // Give the system an additional way to check for a valid sizing if the observer fails\n        await nextFrame();\n        box = container.getBoundingClientRect();\n\n        if (observing && box.width !== 0 && box.height !== 0) {\n          observer.disconnect();\n          observing = false;\n          resolver.resolve(waitForSizeId === waitForSizeContext);\n        }\n      } else {\n        // Both calls awaiting a size must be async in order for this method to work\n        await nextFrame();\n        resolver.resolve(waitForSizeId === waitForSizeContext);\n      }\n\n      const result = await resolver.promise;\n\n      // Absolutely make sure the observer is disconnected as the promise can be resolved externally from other processes\n      // completing.\n      if (observer) {\n        observer.disconnect();\n        observer = void 0;\n      }\n\n      if (result) {\n        resolvers.forEach(r => r.resolve(false));\n        resolvers = [];\n      }\n\n      return result;\n    },\n\n    // We apply a cancel method to allow for a manual forced cancellation of all contexts waiting for the valid\n    // dimensions to occur. This allows for proper memory cleansing\n    {\n      cancel: () => {\n        resolvers.forEach(r => r.resolve(false));\n        resolvers = [];\n      }\n    }\n  );\n\n  return gate;\n}\n","import { IUniform } from \"../types\";\n\n/**\n * Makes it easier to type out and get better editor help in establishing initShader\n */\nexport function createUniform(options: IUniform) {\n  return options;\n}\n","import { IVertexAttribute } from \"../types\";\n\n/**\n * Makes it easier to type out and get better editor help in establishing initShader\n */\nexport function createVertex(options: IVertexAttribute) {\n  return options;\n}\n","import { GLSettings, Texture, TextureOptions } from \"../../gl\";\nimport { add2, scale2, Vec2 } from \"../../math/vector\";\nimport { isWhiteSpace, ResourceType, Size, TextureSize } from \"../../types\";\nimport { IdentifyByKey } from \"../../util/identify-by-key\";\nimport { PackNode } from \"../texture/pack-node\";\nimport { SubTexture } from \"../texture/sub-texture\";\nimport {\n  FontManager,\n  FontMapSource,\n  IFontResourceOptions\n} from \"./font-manager\";\nimport { FontRenderer, KerningPairs } from \"./font-renderer\";\n\nconst debug = require(\"debug\")(\"performance\");\n\nexport enum FontMapGlyphType {\n  /** Straight images for each glyph */\n  BITMAP,\n  /** Signed distance field glyphs */\n  SDF,\n  /** Multichannel signed distance fields */\n  MSDF\n}\n\nexport interface IFontMapOptions extends IFontResourceOptions {\n  /**\n   * This is the initial characters registered with this font map. If this is not Dynamic,\n   * these are the only characters this map can provide.\n   */\n  characters?: [string, SubTexture][];\n  /**\n   * This is the glyph type for the font.\n   */\n  glyphType: FontMapGlyphType;\n}\n\n/**\n * This describes a string's individual letter offsets when properly kerned relative to each other.\n */\nexport type KernedLayout = {\n  /** The scaling of the font relative to the desired font size vs the rendered size of the font on the font map */\n  fontScale: number;\n  /** This is the glyphs given positions. This is essentially the text minus the whitespace. */\n  glyphs: string;\n  /**\n   * This provides the kerning of each letter. The order of the positions provided is in\n   * the order the letters appear in the text measured. This is all relative to placing the\n   * top left of the rendering at [0, 0]\n   */\n  positions: Vec2[];\n  /** The width and height of the entire rendered string */\n  size: Size;\n  /** The text used in calculating this layout */\n  text: string;\n};\n\n/**\n * This represents the actual font map resource. It contains the raw texture object for manipulating.\n */\nexport class FontMap extends IdentifyByKey implements IFontResourceOptions {\n  /** Makes a CSS font string from the font properties in the map */\n  get fontString() {\n    return `${this.fontSource.size}px ${this.fontSource.family}`;\n  }\n  /**\n   * A dynamic font map renders single glyphs at a time into the resource rather than preloads.\n   */\n  dynamic: boolean = false;\n  /** The metrics of the font rendered to this font map */\n  fontSource: FontMapSource;\n  /**\n   * The number of glyphs successfully registered with this font map. This is used to determine the\n   * position of the next glyph for the font map.\n   */\n  glyphCount: number;\n  /**\n   * This maps all of the glyphs this resource provides for to the SubTexture where the glyph is rendered\n   * on the resource.\n   */\n  glyphMap: { [char: string]: SubTexture } = {};\n  /**\n   * These  are the calculated kerning pairs available for this font map. If a pair does not\n   * exist here, then the map may not have the character or the pair may not have been calculated\n   * for the font map yet.\n   */\n  kerning: KerningPairs = {};\n  /** This is the manager storing the Font Map */\n  manager: FontManager;\n  /** Tracks how the glyphs are packed into the map */\n  packing: PackNode<SubTexture>;\n  /** This is the calculated width of a space for the font map */\n  spaceWidth: number = 0;\n  /** The base texture where the font map is stored */\n  texture: Texture;\n  /**\n   * The settings applied to the texture object itself. This is managed by the type of glyph in use.\n   */\n  private textureSettings: TextureOptions;\n  /**\n   * This finishes establishing this font map as a resource that is a IFontMapResourceOptions\n   */\n  type: ResourceType.FONT = ResourceType.FONT;\n\n  constructor(options: IFontMapOptions) {\n    super(options);\n\n    this.dynamic = options.dynamic || false;\n    this.fontSource = options.fontSource;\n\n    if (options.characters) {\n      options.characters.forEach(pair => {\n        this.doRegisterGlyph(pair[0], pair[1]);\n      });\n    }\n\n    const fontMapSize: Size = options.fontMapSize\n      ? options.fontMapSize\n      : [TextureSize._1024, TextureSize._1024];\n\n    this.makeGlyphTypeTextureSettings(options.glyphType);\n    this.createTexture(fontMapSize);\n\n    // Initialize the packing layout for the texture\n    this.packing = new PackNode(0, 0, fontMapSize[0], fontMapSize[1]);\n    // If allowed, load the cached kerning from the system\n    this.addCachedKerning();\n  }\n\n  private getKerningCacheName() {\n    return `__deltav_kerning_cache_${this.fontSource.family}__`;\n  }\n\n  /**\n   * Loads the stored cached kerning if it's available.\n   */\n  private addCachedKerning() {\n    if (this.fontSource.localKerningCache) {\n      const cachedKerningStr = localStorage.getItem(this.getKerningCacheName());\n\n      if (cachedKerningStr) {\n        debug(\"Loading cached kerning items:\", this.getKerningCacheName());\n\n        try {\n          const cachedKerning = JSON.parse(cachedKerningStr);\n          let totalKernsLoaded = 0;\n\n          for (const left in cachedKerning) {\n            let isValid: boolean =\n              typeof left === \"string\" && left.length === 1;\n            if (!isValid) continue;\n\n            const rights = cachedKerning[left];\n            const rightKerning = this.kerning[left] || {};\n            this.kerning[left] = rightKerning;\n\n            for (const right in rights) {\n              isValid = typeof left === \"string\" && left.length === 1;\n              if (!isValid) continue;\n              rightKerning[right] = rights[right];\n              totalKernsLoaded++;\n            }\n          }\n\n          debug(\n            \"Found kerning items in the cache!\",\n            \"Count:\",\n            totalKernsLoaded\n          );\n        } catch (err) {\n          /** do nothing as the kerning info is not valid */\n        }\n      }\n    }\n  }\n\n  /**\n   * Applies additional kerning pair information to the map.\n   */\n  addKerning(kerning: KerningPairs) {\n    let hasNew = false;\n\n    for (const left in kerning) {\n      const rights = kerning[left];\n      const rightKerning = this.kerning[left] || {};\n      if (!this.kerning[left]) hasNew = true;\n      this.kerning[left] = rightKerning;\n\n      for (const right in rights) {\n        if (!rightKerning[right]) hasNew = true;\n        rightKerning[right] = rights[right];\n      }\n    }\n\n    // If new kerning pairs applied, then we should update the cache\n    if (hasNew && this.fontSource.localKerningCache) {\n      try {\n        debug(\"Storing kerning info in cache...\");\n        const kerningCache = JSON.stringify(this.kerning);\n        localStorage.setItem(this.getKerningCacheName(), kerningCache);\n      } catch (err) {\n        // Failures just silently fail\n        debug(\"Could not cache kerning info\");\n      }\n    }\n  }\n\n  /**\n   * Generates the texture for the font map which makes it ready for utilization and ready\n   * for updates.\n   */\n  private createTexture(size: Size) {\n    if (this.texture) return;\n\n    // Establish the settings to be applied to the Texture\n    let textureSettings;\n\n    if (this.textureSettings) {\n      textureSettings = {\n        generateMipMaps: true,\n        premultiplyAlpha: true,\n        ...this.textureSettings\n      };\n    } else {\n      textureSettings = {\n        generateMipMaps: true,\n        premultiplyAlpha: true\n      };\n    }\n\n    // Generate the texture\n    this.texture = new Texture({\n      data: {\n        width: size[0],\n        height: size[1],\n        buffer: null\n      },\n      ...textureSettings\n    });\n  }\n\n  /**\n   * Free resources for this manager\n   */\n  destroy() {\n    this.texture.destroy();\n  }\n\n  /**\n   * Performs the internal glyph registration.\n   */\n  private doRegisterGlyph(char: string, tex: SubTexture) {\n    const oneChar = char[0];\n\n    if (!this.glyphMap[oneChar]) {\n      this.glyphMap[oneChar] = tex;\n    } else {\n      console.warn(\"A Glyph is already registered with a rendering\");\n    }\n  }\n\n  /**\n   * This returns which characters are not included in this font map.\n   */\n  findMissingCharacters(newCharacters: string) {\n    const missing = new Set<string>();\n    let allMissing: string = \"\";\n\n    for (let i = 0, iMax = newCharacters.length; i < iMax; ++i) {\n      const char = newCharacters[i];\n\n      if (!this.glyphMap[char] && !missing.has(char)) {\n        missing.add(char);\n        allMissing += char;\n      }\n    }\n\n    return allMissing;\n  }\n\n  /**\n   * This retrieves the glyph texture information from the FontMap.\n   */\n  getGlyphTexture(char: string): SubTexture | null {\n    return this.glyphMap[char[0]] || null;\n  }\n\n  /**\n   * This provides the expected vector from the top left corner of the left vector\n   * to the top left corner of the right vector.\n   */\n  getGlyphKerning(leftChar: string, rightChar: string): Vec2 {\n    const right = this.kerning[leftChar];\n    // If not pairs for the provided left character, just provide 0\n    if (!right) return [0, 0];\n\n    // Produce the kerning value or zero if none exists\n    return right[rightChar] || [0, 0];\n  }\n\n  /**\n   * This looks at the glyphs directly from a layout and provides the width of the glyphs.\n   *\n   * This differs from getStringWidth as the indices reference GLYPHS (not white space) while\n   * the parameters on the other reference the text.\n   *\n   * This method is a little less intuitive but can perform faster.\n   */\n  getGlyphWidth(stringLayout: KernedLayout, start: number, end: number) {\n    const startOffset = stringLayout.positions[start];\n    const endOffset = stringLayout.positions[end];\n    // The indices must be valid to work\n    if (!start || !end) return 0;\n    // Get the width of the final glyph\n    const image = this.glyphMap[stringLayout.glyphs[end]];\n    if (!image) return 0;\n\n    // Now we can output the rendered width\n    return endOffset[0] + image.pixelWidth - startOffset[0];\n  }\n\n  /**\n   * This looks at a string layout and provides a layout that reflects the layout bounded\n   * by a max width. This accounts for including\n   */\n  async getTruncatedLayout(\n    layout: KernedLayout,\n    truncation: string,\n    maxWidth: number,\n    fontSize: number,\n    letterSpacing: number,\n    fontRenderer: FontRenderer\n  ) {\n    // If the label exceeds the specified maxWidth then truncation must take places\n    if (layout.size[0] > maxWidth) {\n      let truncatedText = \"\";\n      let truncationWidth = 0;\n\n      // We'll get a rough and dirty truncation character width estimate by simply adding the width of\n      // all the glyphs\n      for (let i = 0, iMax = truncation.length; i < iMax; ++i) {\n        truncationWidth += this.glyphMap[truncation[i]].pixelWidth;\n      }\n\n      // Now find a width of glyphs + the width of the truncation that will fit within the maxWidth\n      // If the truncation width is wider than the max width, then we truncate to no text at all.\n      if (truncationWidth > maxWidth) {\n        return {\n          fontScale: 1,\n          glyphs: \"\",\n          positions: [],\n          size: [0, 0],\n          text: \"\"\n        } as KernedLayout;\n      }\n\n      // Otherwise, let's do the search for the correct glyphs to show that will fit properly.\n      // We will use a simple binary search to find the appropriate length to use.\n      let left = 0;\n      let right = layout.positions.length;\n      let cursor = 0;\n      let check = 0;\n      let char = \"\";\n\n      while (left !== right) {\n        cursor = Math.floor((right - left) / 2) + left;\n        char = layout.glyphs[cursor];\n        check =\n          layout.positions[cursor][0] +\n          this.glyphMap[char].pixelWidth +\n          truncationWidth;\n\n        if (check > maxWidth) right = cursor;\n        else if (check < maxWidth) left = cursor;\n        else break;\n\n        if (Math.abs(left - right) <= 1) {\n          if (check < maxWidth) break;\n\n          while (check > maxWidth && cursor >= 0) {\n            cursor--;\n            check =\n              layout.positions[cursor][0] +\n              this.glyphMap[char].pixelWidth +\n              truncationWidth;\n          }\n\n          break;\n        }\n      }\n\n      // Our cursor should now be pointing to the letter that will be our truncation point\n      // We must make sure with the characters specified it does fit, if not, we only render\n      // the truncation glyphs\n      check =\n        layout.positions[cursor][0] +\n        this.glyphMap[char].pixelWidth +\n        truncationWidth;\n\n      if (check < maxWidth) {\n        // Loop through the text and find the glyph matching to the actual text with glyphs\n        let glyphIndex = 0;\n        let charIndex = 0;\n\n        for (\n          let i = 0, iMax = layout.text.length;\n          i < iMax && glyphIndex <= cursor;\n          ++i\n        ) {\n          const char = layout.text[i];\n\n          charIndex++;\n          if (!isWhiteSpace(char)) glyphIndex++;\n        }\n\n        // Make sure the last character attached to the first truncated letter has kerning info\n        const lastChar = layout.text[charIndex - 1];\n        let firstTruncChar;\n\n        for (let i = 0, iMax = truncation.length; i < iMax; ++i) {\n          if (!isWhiteSpace(truncation[i])) {\n            firstTruncChar = truncation[i];\n            break;\n          }\n        }\n\n        if (\n          lastChar &&\n          firstTruncChar &&\n          !this.kerning[lastChar][firstTruncChar]\n        ) {\n          const kerning = await fontRenderer.estimateKerning(\n            [lastChar + firstTruncChar],\n            this.fontString,\n            this.fontSource.size,\n            this.kerning,\n            false\n          );\n\n          this.addKerning(kerning.pairs);\n        }\n\n        truncatedText = `${layout.text.substr(0, charIndex)}${truncation}`;\n      } else {\n        truncatedText = truncation;\n      }\n\n      // Caculate the layout of the truncated text\n      return this.getStringLayout(truncatedText, fontSize, letterSpacing);\n    }\n\n    return layout;\n  }\n\n  /**\n   * Get the width of a set of characters within a string layout.\n   *\n   * To use this, first use the getStringLayout() method to get the KernedLayout then insert\n   * the the range of characters the width should be calculated for.\n   *\n   * [start, end)\n   */\n  getStringWidth(\n    stringLayout: KernedLayout,\n    start: number,\n    end: number\n  ): number;\n  /**\n   * Get the width of a substring from a string layout.\n   *\n   * To use this, first use the getStringLayout() method to get the KernedLayout then insert\n   * the substring of text desired for calculating the width.\n   */\n  getStringWidth(stringLayout: KernedLayout, substr: string): number;\n  /**\n   * Calculates the width of a chunk of characters within a calculated KernedLayout.\n   * To use this, first use the getStringLayout() method to get the KernedLayout then insert\n   * the substring of text desired for calculating the width.\n   */\n  getStringWidth(\n    stringLayout: KernedLayout,\n    param1: string | number,\n    param2?: number\n  ): number {\n    const text = stringLayout.text;\n    let firstChar = 0;\n    let lastChar = text.length;\n\n    // String param means we look for a substring\n    if (typeof param1 === \"string\") {\n      const index = text.indexOf(param1);\n      // No found sub string means the examined text does not exist\n      if (index < 0) return 0;\n      // Now we have the letter within the text we begin with.\n      firstChar = index;\n      // Last character is the first + length of sub string\n      lastChar = firstChar + param1.length;\n    } else {\n      firstChar = param1;\n    }\n\n    // Set the explicit last character to use\n    if (param2 !== undefined) {\n      lastChar = param2;\n    }\n\n    // We now trim out white space from our indices to get the actual glyph indices that match our search\n    let i = 0;\n    const endOfFirst = Math.min(text.length, firstChar);\n    const endOfLast = Math.min(text.length, lastChar);\n\n    for (; i < endOfFirst; ++i) {\n      if (isWhiteSpace(text[i])) {\n        firstChar--;\n        lastChar--;\n      }\n    }\n\n    for (; i < endOfLast; ++i) {\n      if (isWhiteSpace(text[i])) lastChar--;\n    }\n\n    // We now have the indices of the first and last glyph's position information in our text.\n    // We can use these two to determine the width of the text.\n    const lastGlyph = this.glyphMap[stringLayout.text[lastChar] || \"\"];\n    if (!lastGlyph) return 0;\n\n    return (\n      (stringLayout.positions[lastChar] || [0, 0])[0] -\n      (stringLayout.positions[firstChar] || [0, 0])[0] +\n      lastGlyph.pixelWidth\n    );\n  }\n\n  /**\n   * This processes a string and lays it out by the kerning rules available to this font map.\n   *\n   * NOTE: This ONLY processes a SINGLE LINE!! ALL whitespace characters will be considered a single\n   * space.\n   */\n  getStringLayout(\n    text: string,\n    fontSize: number,\n    letterSpacing: number\n  ): KernedLayout {\n    // The output positions for each letter in the text\n    const positions: Vec2[] = [];\n    // The output of each character found that is provided a position (the string without the whitespace)\n    let glyphs: string = \"\";\n    // Calculate the scaling of the font which would be the font map's rendered glyph size\n    // as a ratio to the label's desired font size.\n    const fontScale = fontSize / this.fontSource.size;\n\n    // Start with the initial glyph dimensions as the min and max y the label will have\n    let minY = Number.MAX_SAFE_INTEGER;\n    let maxY = 0;\n    let currentWidth = 0;\n    // The current offset for the current letter to be rendered properly\n    let offset: Vec2 = [0, 0];\n    // The amount each white space moves the text forward\n    const whiteSpacing = this.spaceWidth;\n    // Number of found whitespace characters since last character\n    let whiteSpaceCount = 0;\n    // The current character found to the left of the current one being processed\n    let leftChar = \"\";\n    // Holder for the found kerning of the character pair\n    let kern: Vec2;\n    // The image of the glyph that was rendered\n    let image: SubTexture;\n\n    // Loop through the text and calculate the offsets of each non-whitespace character\n    for (let i = 0, iMax = text.length; i < iMax; ++i) {\n      const char = text[i];\n\n      // White space merely moves the offset forward by the amount of a space\n      if (isWhiteSpace(char)) {\n        whiteSpaceCount++;\n        continue;\n      }\n\n      kern = [0, 0];\n\n      if (leftChar) {\n        kern = this.kerning[leftChar][char] || [0, 0];\n      }\n\n      offset = add2(add2(offset, scale2(kern, fontScale)), [\n        whiteSpaceCount * whiteSpacing * fontScale +\n          (i === 0 ? 0 : letterSpacing),\n        0\n      ]);\n\n      // Copy the offset to our output positions for the character\n      positions.push([offset[0], offset[1]]);\n      glyphs += char;\n\n      // Get the glyph rendering from the font map\n      image = this.glyphMap[char];\n      // Use the offset and the rendering height to determine the top and bottom of the glyph\n      minY = Math.min(offset[1], minY);\n      maxY = Math.max(offset[1] + image.pixelHeight * fontScale, maxY);\n      // Make this processed glyph the next glyph that is 'to the left' for the next glyph\n      leftChar = char;\n      // Calculate the width of the label as we lay out\n      currentWidth = offset[0] + image.pixelWidth * fontScale;\n      // Reset the whitespace count so we can see whitespaces to next character\n      whiteSpaceCount = 0;\n    }\n\n    // Now we have positioned all of our glyphs with relative kerning.\n    // We can now get a width and height of the total label\n    const height = maxY - minY;\n    // Update the instance with the calculated width of the label\n    const size: Size = [currentWidth, height];\n\n    // Move all of the glyphs by -minY. This will effectively frame the label where the\n    // top left is 0,0 relative to all of the contents of the label.\n    // We also apply the calculated anchor at this time for the label\n    for (let i = 0, iMax = positions.length; i < iMax; ++i) {\n      offset = positions[i];\n      offset[1] -= minY;\n    }\n\n    return {\n      fontScale,\n      glyphs,\n      positions,\n      size,\n      text\n    };\n  }\n\n  /**\n   * This generates the necessary texture settings for the font map based on it's glyph type.\n   */\n  private makeGlyphTypeTextureSettings(type: FontMapGlyphType) {\n    switch (type) {\n      // Simple bitmap glyphs. Just need luminance and alpha value for the glyph\n      case FontMapGlyphType.BITMAP:\n        this.textureSettings = {\n          magFilter: GLSettings.Texture.TextureMagFilter.Linear,\n          minFilter: GLSettings.Texture.TextureMinFilter.LinearMipMapLinear,\n          internalFormat: GLSettings.Texture.TexelDataType.LuminanceAlpha,\n          format: GLSettings.Texture.TexelDataType.LuminanceAlpha\n        };\n        break;\n\n      // Only a single channel is needed for SDF\n      case FontMapGlyphType.SDF:\n        this.textureSettings = {\n          magFilter: GLSettings.Texture.TextureMagFilter.Linear,\n          minFilter: GLSettings.Texture.TextureMinFilter.Linear,\n          internalFormat: GLSettings.Texture.TexelDataType.Luminance,\n          format: GLSettings.Texture.TexelDataType.Luminance\n        };\n        break;\n\n      // The MSDF strategy uses all RGB channels for the algorithm. Heavier data use\n      // better quality results.\n      case FontMapGlyphType.MSDF:\n        this.textureSettings = {\n          magFilter: GLSettings.Texture.TextureMagFilter.Linear,\n          minFilter: GLSettings.Texture.TextureMinFilter.Linear,\n          internalFormat: GLSettings.Texture.TexelDataType.RGB,\n          format: GLSettings.Texture.TexelDataType.RGB\n        };\n        break;\n    }\n  }\n\n  /**\n   * Registers a glyph with it's location on the map.\n   */\n  registerGlyph(char: string, tex: SubTexture) {\n    if (this.dynamic) {\n      this.doRegisterGlyph(char, tex);\n    } else {\n      console.warn(\n        \"Attempted to register a new glyph with a non-dynamic FontMap\"\n      );\n    }\n  }\n\n  /**\n   * Validates if all the kerning specified is ready for the text\n   */\n  supportsKerning(text: string) {\n    // Loop through the characters in the text and see if all pairs of glyphs\n    // have their kerning determined and calculated.\n    for (let i = 1, iMax = text.length; i < iMax; ++i) {\n      const char = text[i];\n      const leftChar = text[i - 1];\n\n      // If the left or the right character is not found properly, then this text is not supported\n      // by the font map kerning yet.\n      if (this.kerning[leftChar]) {\n        if (!this.kerning[leftChar][char]) {\n          return false;\n        }\n      } else return false;\n    }\n\n    return true;\n  }\n}\n","/**\n * The purpose of this file is to provide a means to render glyphs to a grid and to provide\n * an approach to estimating kerning values for characters utilizing any custom embedded font\n * in a web page.\n */\nimport { WebGLStat } from \"../../gl/webgl-stat\";\nimport { scale2, Vec2 } from \"../../math\";\nimport { IResourceType, ResourceType } from \"../../types\";\nimport { IdentifyByKey } from \"../../util/identify-by-key\";\nimport { renderGlyph } from \"./glyph-renderer\";\nimport { svgToData } from \"./svg-to-data\";\n\nconst debug = require(\"debug\")(\"performance\");\nconst { floor } = Math;\n\ntype IGlyphRenderMetrics = {\n  [key: string]: { glyph: ImageData; glyphIndex: number };\n};\n\nexport type KerningPairs = {\n  [leftLetter: string]: { [rightLtter: string]: Vec2 };\n};\n\nexport type KerningInfo = {\n  all: string[];\n  pairs: KerningPairs;\n  spaceWidth: number;\n};\n\n/**\n * This function is calculate the offset of adjacent letters\n */\nasync function renderEachPair(\n  fontString: string,\n  fontSize: number,\n  pairs: KerningInfo,\n  calculateSpace: boolean\n) {\n  // Make the svg namespace to dynamically construct an svg\n  const svgNS = \"http://www.w3.org/2000/svg\";\n  // Calculate the max width the system can reliably handle. It can be considered that the WebGL texture limit would\n  // be the limit a canvas context could handle. It would make little sense for a browser to behave otherwise.\n  const contextWidth = WebGLStat.MAX_TEXTURE_SIZE / window.devicePixelRatio;\n  // Create the table\n  const cellWidth = fontSize * 2;\n  const cellHeight = fontSize * 1.3;\n  const maxColumns = floor(contextWidth / cellWidth);\n  // Generate the svg wrapper that will hold all of our elements\n  const table = document.createElementNS(svgNS, \"svg\");\n  table.setAttribute(\"width\", `${contextWidth}px`);\n  table.style.font = fontString;\n  table.style.position = \"relative\";\n  table.style.left = \"0px\";\n  table.style.top = `0px`;\n  // We will store the rows discovered so we can render them in batches to accommodate systems with smaller canvas limits\n  const rows = [];\n  const rowsPerBatch = Math.floor(contextWidth / cellHeight);\n  let currentBatch = 0;\n\n  let currentPair = 0;\n  let columnIndex = 0;\n  let currentRow;\n  let rowSpacer;\n  let remainingSpace = 0;\n\n  // Render each pair to cell of the table\n  while (currentPair < pairs.all.length) {\n    const tr = document.createElementNS(svgNS, \"g\");\n    currentRow = tr;\n    currentBatch = Math.floor(rows.length / rowsPerBatch);\n    tr.setAttribute(\n      \"transform\",\n      `translate(0, ${(rows.length - currentBatch * rowsPerBatch) *\n        cellHeight})`\n    );\n    rows.push(tr);\n\n    // We track how much room is remaining so we can inject an empty cell at the end to ensure\n    // the table doesn't stretch to fill\n    let remaining = contextWidth;\n\n    // Render each tr with col number of td\n    for (\n      columnIndex = 0;\n      columnIndex < maxColumns && currentPair < pairs.all.length;\n      columnIndex++\n    ) {\n      const td = document.createElementNS(svgNS, \"text\");\n      td.setAttribute(\"x\", `${columnIndex * cellWidth}`);\n      td.setAttribute(\"dy\", \"1em\");\n\n      const pair = pairs.all[currentPair];\n      currentPair++;\n      const leftStr = pair[0];\n      const rightStr = pair[1];\n\n      // Each td has two spans\n      const leftSpan = document.createElementNS(svgNS, \"tspan\");\n      const rightSpan = document.createElementNS(svgNS, \"tspan\");\n      leftSpan.setAttribute(\"fill\", \"#ff0000\");\n      rightSpan.setAttribute(\"fill\", \"#0000ff\");\n\n      leftSpan.textContent = leftStr;\n      rightSpan.textContent = rightStr;\n\n      td.appendChild(leftSpan);\n      td.appendChild(rightSpan);\n      tr.appendChild(td);\n\n      remaining -= cellWidth;\n    }\n\n    if (remaining >= 0) {\n      const td = document.createElementNS(svgNS, \"text\");\n      td.setAttribute(\"width\", `${remaining}px`);\n      tr.appendChild(td);\n      rowSpacer = td;\n    } else {\n      rowSpacer = null;\n    }\n\n    remainingSpace = remaining;\n  }\n\n  // Init the array for left-top corners for each letter in a pair\n  // [leftLetter->left, leftLetter->top, rightLetter->left, rightLetter->top]\n  const mins: [number, number, number, number][] = [];\n  for (let i = 0; i < pairs.all.length; i++) {\n    mins.push([\n      Number.MAX_SAFE_INTEGER,\n      Number.MAX_SAFE_INTEGER,\n      Number.MAX_SAFE_INTEGER,\n      Number.MAX_SAFE_INTEGER\n    ]);\n  }\n\n  // This stores how large the test character's rendering is that will be used for analyzing\n  // how large a space between characters is.\n  let testSpaceCharacterWidth = 0;\n  let doSpaceCheck = false;\n\n  // If the distance of a space is required, then we add in one more additional cell\n  if (calculateSpace) {\n    const testChar = \"M\";\n    const td = document.createElementNS(svgNS, \"text\");\n    td.setAttribute(\"dy\", \"1em\");\n    // td.style.display = \"table-cell\";\n    td.style.width = `${cellWidth}`;\n    td.style.height = `${cellHeight}`;\n    td.setAttribute(\"x\", `${cellWidth * columnIndex}`);\n    // td.style.overflow = \"hidden\";\n    td.style.font = fontString;\n\n    // The test character for the spacing will be the first character in the pairs we\n    // wanted to render.\n    const render = await renderGlyph(testChar, 128, 128, fontString);\n\n    if (render) {\n      // Keep how wide the test character is for after the kerning calculation so we can accurately\n      // determine how large a space is by subtracting the width of the character from the kerning distance.\n      testSpaceCharacterWidth = render.size[0];\n      // We create two of the test characters and place a space between them.\n      const leftSpan = document.createElementNS(svgNS, \"tspan\");\n      const spaceSpan = document.createElementNS(svgNS, \"tspan\");\n      const rightSpan = document.createElementNS(svgNS, \"tspan\");\n      leftSpan.setAttribute(\"fill\", \"#ff0000\");\n      rightSpan.setAttribute(\"fill\", \"#0000ff\");\n      leftSpan.textContent = testChar;\n      rightSpan.textContent = testChar;\n      spaceSpan.textContent = \" \";\n      td.appendChild(leftSpan);\n      td.appendChild(spaceSpan);\n      td.appendChild(rightSpan);\n\n      // If the last row has room for the rendering, then we just add to it\n      if (columnIndex < maxColumns && currentRow) {\n        currentRow.appendChild(td);\n        remainingSpace -= cellWidth;\n\n        // If a spacer at the end of the row is present, it should be adjusted to the size needed\n        // It should also be moved to the end of the child list\n        if (rowSpacer) {\n          rowSpacer.remove();\n\n          if (remainingSpace > 0) {\n            currentRow.style.width = `${remainingSpace}px`;\n            currentRow.appendChild(rowSpacer);\n          }\n        }\n      }\n\n      // Otherwise, we make a new row to inject into\n      else {\n        const tr = document.createElement(\"g\");\n        currentBatch = Math.floor(rows.length / rowsPerBatch);\n        tr.setAttribute(\n          \"transform\",\n          `translate(0, ${(rows.length - currentBatch * rowsPerBatch) *\n            cellHeight})`\n        );\n        currentRow = tr;\n        currentRow.appendChild(td);\n        rows.push(tr);\n\n        // Inject a spacer to fill the remaining space\n        rowSpacer = document.createElementNS(svgNS, \"text\");\n        tr.appendChild(rowSpacer);\n      }\n\n      // Add an additional min tracker for the check\n      mins.push([\n        Number.MAX_SAFE_INTEGER,\n        Number.MAX_SAFE_INTEGER,\n        Number.MAX_SAFE_INTEGER,\n        Number.MAX_SAFE_INTEGER\n      ]);\n\n      // Indicate the space check is indeed happening\n      doSpaceCheck = true;\n    }\n  }\n\n  // We now have all of the rows calculated and prepared. We now batch the rows together to fit within the max allowed\n  // canvas size and stitch the results together at the end.\n  const totalHeight = rows.length * cellHeight;\n  const totalCanvasBatches = Math.ceil(totalHeight / contextWidth);\n  let result: ImageData | null = null;\n\n  debug(\n    \"Rendering table canvas batches for font kerning analysis\",\n    pairs,\n    rows\n  );\n\n  for (let i = 0; i < totalCanvasBatches; ++i) {\n    // Gather the next batch to render\n    const rowBatch = rows.splice(0, rowsPerBatch);\n    const batchHeight = rowBatch.length * cellHeight;\n    // Adjust the height of the svg to cover allrows added\n    table.setAttribute(\"height\", `${batchHeight}px`);\n\n    // Clear out the table children\n    while (table.lastElementChild) table.lastElementChild.remove();\n\n    // Add the next row batch to the table\n    for (let k = 0, kMax = rowBatch.length; k < kMax; ++k) {\n      const row = rowBatch[k];\n      table.appendChild(row);\n    }\n\n    // Start the results with the first found result\n    if (!result) {\n      result = await svgToData(table);\n    }\n\n    // Additional results will need their results stitched into the initial result\n    else {\n      const stitchResult = await svgToData(table);\n\n      if (!stitchResult) {\n        console.warn(\n          \"Font Renderer: Could not generate image data for analyzing font kerning\"\n        );\n        continue;\n      }\n\n      const newBuffer: Uint8ClampedArray = new Uint8ClampedArray(\n        result.data.length + stitchResult.data.length\n      );\n\n      newBuffer.set(result.data);\n      newBuffer.set(stitchResult.data, result.data.length);\n      result = new ImageData(\n        newBuffer,\n        contextWidth * window.devicePixelRatio,\n        result.height + stitchResult.height\n      );\n    }\n  }\n\n  debug(\"Analyzing rendered data\", result);\n\n  // Width and height of each cell\n  const w = cellWidth * window.devicePixelRatio;\n  const h = cellHeight * window.devicePixelRatio;\n\n  if (result) {\n    // const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n    const data = result.data;\n    let pixel, r, g, b, min, index;\n\n    for (let y = 0, canvasHeight = result.height; y < canvasHeight; y++) {\n      for (let x = 0, canvasWidth = result.width; x < canvasWidth; x++) {\n        pixel = (canvasWidth * y + x) * 4;\n        r = data[pixel + 0];\n        g = data[pixel + 1];\n        b = data[pixel + 2];\n\n        // Get the index of the pair by the position of pixel\n        index = floor(y / h) * maxColumns + floor(x / w);\n\n        if (index < mins.length) {\n          min = mins[index];\n\n          // Red pixel is for left letter\n          if (r > 0 && g === 0 && b === 0) {\n            if (x < min[0]) min[0] = x;\n            if (y < min[1]) min[1] = y;\n          }\n\n          // Blue pixel is for right letter\n          if (r === 0 && g === 0 && b > 0) {\n            if (x < min[2]) min[2] = x;\n            if (y < min[3]) min[3] = y;\n          }\n        }\n      }\n    }\n\n    // Before letter processing, remove and analyze processing for the 'space' character\n    if (doSpaceCheck) {\n      const min = mins.pop();\n      if (min) {\n        const vec: Vec2 = [min[2] - min[0], 0];\n        const exact = scale2(vec, 1 / window.devicePixelRatio);\n        pairs.spaceWidth = Math.ceil(exact[0]) - testSpaceCharacterWidth;\n      }\n    }\n\n    // Set pairs map based on mins array\n    for (let i = 0, iMax = mins.length; i < iMax; i++) {\n      const pair = pairs.all[i];\n      const left = pair[0];\n      const right = pair[1];\n      const min = mins[i];\n      const vec: Vec2 = [min[2] - min[0], min[3] - min[1]];\n      const rightLetters = pairs.pairs[left];\n\n      if (rightLetters) {\n        // The calculations done on the space are in a devices pixel ratio. So we must\n        // adjust by that ratio to make it normal world space coordinates.\n        const exact = scale2(vec, 1 / window.devicePixelRatio);\n        rightLetters[right] = [Math.ceil(exact[0]), exact[1]];\n      }\n    }\n  } else {\n    console.warn(\n      \"html2canvas did not produce a valid canvas context to analyze\"\n    );\n  }\n\n  // table.remove();\n  debug(\"Kerning rendering analysis complete\", pairs.pairs);\n}\n\n/**\n * This function takes a string to return a map with next letters of each letter\n */\nfunction stringToPairs(\n  str: string,\n  existing: KerningPairs,\n  out?: KerningInfo\n): KerningInfo {\n  // Remove all the whitespace\n  str = str.replace(/\\s/g, \"\");\n  const all: string[] = (out && out.all) || [];\n  const pairs: KerningPairs = (out && out.pairs) || {};\n\n  for (let i = 0; i < str.length - 1; i++) {\n    const left = str[i];\n    const right = str[i + 1];\n    let neighbors = pairs[left];\n\n    if (!neighbors) {\n      neighbors = pairs[left] = {};\n    }\n\n    // Don't remake a pair for already existing pairs\n    if ((!existing[left] || !existing[left][right]) && !neighbors[right]) {\n      neighbors[right] = [0, 0];\n      all.push(`${left}${right}`);\n    }\n  }\n\n  return {\n    all,\n    pairs,\n    spaceWidth: 0\n  };\n}\n\nexport interface IFontOptions extends IdentifyByKey, IResourceType {\n  /** This resource must have it's type explcitly be set to a Font */\n  type: ResourceType.FONT;\n}\n\nexport class FontRenderer {\n  /**\n   * This function takes a sentence and grid info\n   * Returns a canvas with a list of glyphs where each glyph fits cnetered within each grid cell\n   */\n  makeBitmapGlyphs(\n    glyphs: string,\n    fontString: string,\n    fontSize: number\n  ): IGlyphRenderMetrics {\n    // It is used to store the metrics of each glyph\n    const map: IGlyphRenderMetrics = {};\n    // Get all unique glyphs provided\n    const uniqueGlyphs = new Set<string>();\n\n    for (let i = 0, iMax = glyphs.length; i < iMax; ++i) {\n      uniqueGlyphs.add(glyphs[i]);\n    }\n\n    // Get the characters to be rendered\n    const chars = Array.from(uniqueGlyphs.values());\n\n    for (let i = 0, iMax = chars.length; i < iMax; ++i) {\n      const char = chars[i];\n      const glyph = renderGlyph(char, fontSize * 2, fontSize * 2, fontString);\n\n      if (glyph) {\n        map[char] = {\n          glyph: glyph.data,\n          glyphIndex: i\n        };\n      } else {\n        console.warn(\n          \"Unable to render character\",\n          char,\n          \"to font map for rendering.\"\n        );\n      }\n    }\n\n    return map;\n  }\n\n  /**\n   * This performs a special rendering to guess kerning of letters of embedded fonts (fonts we don't\n   * have access to their raw font files). This will provide kerning information of a letter by providing\n   * the distance from a 'left' letter's top left  corner to the 'right' letter's topleft corner.\n   */\n  async estimateKerning(\n    str: string[],\n    fontString: string,\n    fontSize: number,\n    existing: KerningPairs,\n    includeSpace: boolean\n  ) {\n    // Get all of the new pairs of letters that need kerning infoz\n    const pairInfo: KerningInfo = {\n      all: [],\n      pairs: {},\n      spaceWidth: 0\n    };\n\n    debug(\"Estimating Kerning for\", str);\n\n    for (let i = 0, iMax = str.length; i < iMax; ++i) {\n      const s = str[i];\n      stringToPairs(s, existing, pairInfo);\n    }\n\n    // Only if there are new kerning needs do we actually need to run this method\n    if (pairInfo.all.length > 0 || includeSpace) {\n      await renderEachPair(fontString, fontSize, pairInfo, includeSpace);\n    }\n\n    return pairInfo;\n  }\n}\n","/**\n * This provides the methods needed to render single glyphs and receive the image data\n * for the rendering. The glyphs will be rendered within a given dimension range and centered.\n */\n\nconst { min, max } = Math;\nconst canvas = document.createElement(\"canvas\");\nlet ctx: CanvasRenderingContext2D;\n\n/**\n * Measures the contents of a canvas based on the canvas havinga pure black\n * background with rendered elements as white.\n */\nfunction measureBlackWhiteCanvasContents(canvas: CanvasRenderingContext2D) {\n  const { width, height } = canvas.canvas;\n  const imageData = canvas.getImageData(0, 0, width, height).data;\n  let r;\n\n  let found = false;\n  let minY = Number.MAX_SAFE_INTEGER;\n  let minX = Number.MAX_SAFE_INTEGER;\n  let maxX = Number.MIN_SAFE_INTEGER;\n  let maxY = Number.MIN_SAFE_INTEGER;\n\n  for (let i = 0; i < width; ++i) {\n    for (let k = 0; k < height; ++k) {\n      const redIndex = k * (width * 4) + i * 4;\n      r = imageData[redIndex];\n\n      if (r > 0.0) {\n        found = true;\n        minY = min(minY, k);\n        minX = min(minX, i);\n        maxX = max(maxX, i);\n        maxY = max(maxY, k);\n      }\n    }\n  }\n\n  if (!found) {\n    return null;\n  }\n\n  // The identified pixel needs to be encased and not a direct target\n  minY -= 1;\n  maxY += 2;\n  maxX += 2;\n  minX -= 1;\n\n  minY = max(minY, 0);\n  minX = max(minX, 0);\n\n  return { minX, minY, maxX, maxY };\n}\n\n/**\n * Renders a glyph centered within the provided rectangle size. This also provides the size of the\n * rendered glyph along with a vector pointing to the topleft of the glyph within then rectangle.\n * This vector can be used to find any corner of the glyph as the glyph is centered within the\n * rectangle's space.\n */\nexport function renderGlyph(\n  glyph: string,\n  width: number,\n  height: number,\n  font: string\n) {\n  // Ensure we're rendering a single characters\n  glyph = glyph[0];\n\n  if (canvas.width < width || canvas.height < height) {\n    canvas.width = width;\n    canvas.height = height;\n  }\n\n  if (!ctx) {\n    const context = canvas.getContext(\"2d\");\n    if (context) ctx = context;\n    else return null;\n  }\n\n  // Draw the glyph\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.font = font;\n  ctx.fillStyle = \"white\";\n  ctx.fillText(glyph, width / 2, height / 2);\n\n  // Get the metrics of the glyph within the rendering\n  const dimensions = measureBlackWhiteCanvasContents(ctx);\n\n  if (!dimensions) {\n    const data = ctx.getImageData(0, 0, 1, 1);\n\n    return {\n      data,\n      size: [0, 0]\n    };\n  }\n\n  // Copy the data from the rendering\n  const glyphWidth = dimensions.maxX - dimensions.minX;\n  const glyphHeight = dimensions.maxY - dimensions.minY;\n\n  const data = ctx.getImageData(\n    dimensions.minX,\n    dimensions.minY,\n    glyphWidth,\n    glyphHeight\n  );\n\n  return {\n    data,\n    size: [glyphWidth, glyphHeight]\n  };\n}\n","export * from \"./atlas-manager\";\nexport * from \"./atlas-resource-manager\";\nexport * from \"./atlas-resource-request\";\nexport * from \"./atlas\";\nexport * from \"./image-rasterizer\";\nexport * from \"./pack-node\";\nexport * from \"./sub-texture\";\nexport * from \"./texture-io-expansion\";\nexport * from \"./render-texture\";\nexport * from \"./render-texture-resource-manager\";\nexport * from \"./render-texture-resource-request\";\n","import {\n  Attribute,\n  Geometry,\n  GLSettings,\n  Material,\n  MaterialUniformType,\n  Model,\n  RenderTarget,\n  Scene,\n  Texture,\n  WebGLRenderer\n} from \"../../gl\";\nimport { Bounds } from \"../../math/primitives/bounds\";\nimport { ImageRasterizer } from \"../../resources/texture/image-rasterizer\";\nimport { VideoTextureMonitor } from \"../../resources/texture/video-texture-monitor\";\nimport { isString } from \"../../types\";\nimport { Atlas, IAtlasResource } from \"./atlas\";\nimport { IAtlasResourceRequest } from \"./atlas-resource-request\";\nimport { IPackNodeDimensions, PackNode } from \"./pack-node\";\nimport { SubTexture } from \"./sub-texture\";\n\nconst debug = require(\"debug\")(\"performance\");\n\nconst ZERO_IMAGE: SubTexture = new SubTexture({\n  aspectRatio: 0,\n  atlasBL: [0, 0],\n  atlasBR: [0, 0],\n  texture: null,\n  atlasTL: [0, 0],\n  atlasTR: [0, 0],\n  heightOnAtlas: 0,\n  isValid: false,\n  pixelHeight: 0,\n  pixelWidth: 0,\n  widthOnAtlas: 0\n});\n\n/**\n * Determines if a SubTexture is a valid SubTexture for rendering\n */\nfunction isValidImage(image?: SubTexture): image is SubTexture {\n  if (image && image.isValid) {\n    if (image.pixelWidth && image.pixelHeight) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Defines a manager of atlas', which includes generating the atlas and\n * producing textures defining those pieces of atlas.\n */\nexport class AtlasManager {\n  /** Stores all of the generated atlas' in a lookup by name */\n  allAtlas = new Map<string, Atlas>();\n  /**\n   * This will be the renderer this manager is acting on behalf. This is used\n   * internally to perform some GL actions without messing up the sync state of\n   * the gl context with the renderer.\n   */\n  renderer?: WebGLRenderer;\n\n  /**\n   * Creates a new atlas that resources can be loaded into.\n   *\n   * @param resources The images with their image path set to be loaded into the\n   *               atlas. Images that keep an atlas ID of null indicates the\n   *               image did not load correctly\n   *\n   * @return {Texture} The texture that is created as our atlas. The images\n   *                   injected into the texture will be populated with the\n   *                   atlas'\n   */\n  async createAtlas(options: IAtlasResource) {\n    // Create the new Atlas object that tracks all of our atlas' metrics\n    const atlas = new Atlas(options);\n    // Make the atlas identifiable by it's name\n    this.allAtlas.set(atlas.id, atlas);\n\n    debug(\"Atlas Created-> %o\", atlas);\n\n    return atlas;\n  }\n\n  /**\n   * Free ALL resources under this manager\n   */\n  destroy() {\n    this.allAtlas.forEach(value => value.destroy());\n  }\n\n  /**\n   * Disposes of the resources the atlas held and makes the atlas invalid for\n   * use\n   *\n   * @param atlasName\n   */\n  destroyAtlas(atlasName: string) {\n    const atlas = this.allAtlas.get(atlasName);\n\n    if (atlas) {\n      atlas.destroy();\n    }\n  }\n\n  private setDefaultImage(image: SubTexture, atlasName: string) {\n    image = Object.assign(image, ZERO_IMAGE, { atlasReferenceID: atlasName });\n    return image;\n  }\n\n  /**\n   * This loads, packs, and draws the indicated image into the specified canvas\n   * using the metrics that exists for the specified atlas.\n   *\n   * @param request The image who should have it's image path loaded\n   * @param atlasName The name of the atlas to make the packing work\n   * @param canvas The canvas we will be drawing into to generate the complete\n   * image\n   *\n   * @return {Promise<boolean>} Promise that resolves to if the image\n   * successfully was drawn or not\n   */\n  private async draw(\n    atlas: Atlas,\n    request: IAtlasResourceRequest\n  ): Promise<boolean> {\n    const atlasName = atlas.id;\n\n    // We don't draw or process requests to resources being disposed.\n    if (request.disposeResource) {\n      return true;\n    }\n\n    // First ensure the atlas does not have this resource referenced yet\n    const existing = atlas.resourceReferences.get(request.source);\n\n    // If the resource still has it's reference, we exit immediately to prevent\n    // drawing the resource into the atlas twice\n    if (existing) {\n      // Ensure the request is referring to the correct subtexture for the\n      // request\n      request.texture = existing.subtexture;\n      return true;\n    }\n\n    // Immediately register the resource with a subtexture to prevent duplicate\n    // processing.\n    request.texture = new SubTexture();\n    request.texture.isValid = true;\n    atlas.resourceReferences.set(request.source, {\n      subtexture: request.texture,\n      count: 0\n    });\n\n    // First we must load the image\n    // Make a buffer to hold our new image\n    // Load the image into memory, default to keeping the alpha channel\n    const loadedImage: TexImageSource | null = await this.loadImage(request);\n    // Get the sub texture that is going to be applied to the atlas\n    const texture = request.texture;\n\n    // Only a non-null image means the image loaded correctly\n    if (loadedImage && isValidImage(texture)) {\n      // Now we create a Rectangle to store the image dimensions\n      const rect: Bounds<never> = new Bounds({\n        bottom: texture.pixelHeight,\n        left: 0,\n        right: texture.pixelWidth,\n        top: 0\n      });\n\n      // Create ImageDimension to insert into our atlas mapper\n      const dimensions: IPackNodeDimensions<SubTexture> = {\n        data: texture,\n        bounds: rect\n      };\n\n      // Auto add a buffer in\n      dimensions.bounds.width += 0;\n      dimensions.bounds.height += 0;\n      // Get the atlas map node\n      let packing: PackNode<SubTexture> = atlas.packing;\n      // Store the node resulting from the insert operation\n      let insertedNode: PackNode<SubTexture> | null = packing.insert(\n        dimensions\n      );\n\n      // If we failed to insert the image, let's repack the atlas and attempt a\n      // second round of packing. We can only repack if the system has provided\n      // the manager a renderer to work with.\n      if (!insertedNode) {\n        // Repack the atlas\n        const success = this.repackResources(atlas);\n\n        if (!success) {\n          console.error(\n            \"Repacking the atlas failed. Some resources may be in an undefined state. Consider making another atlas.\"\n          );\n          return false;\n        }\n\n        // Attempt to insert the item again\n        packing = atlas.packing;\n        insertedNode = packing.insert(dimensions);\n      }\n\n      // If the result was NULL we did not successfully insert the image into\n      // any atlas\n      if (insertedNode) {\n        // Apply the image to the node\n        insertedNode.data = texture;\n\n        // Set our image's atlas properties\n        PackNode.applyToSubTexture(packing, insertedNode, texture, {\n          top: 0.5,\n          left: 0.5,\n          right: 0.5,\n          bottom: 0.5\n        });\n\n        // Track the subtexture with the source that created it.\n        texture.texture = atlas.texture;\n        texture.source = loadedImage;\n        texture.atlasRegion = {\n          ...insertedNode.bounds,\n          y: atlas.height - insertedNode.bounds.y - insertedNode.bounds.height\n        };\n\n        // Now specify the update region to be applied to the texture\n        atlas.texture.update(loadedImage, texture.atlasRegion);\n\n        // If this is a video element, we must make a monitor for it to keep the\n        // texture in sync with the videos time location\n        if (loadedImage instanceof HTMLVideoElement) {\n          texture.video = {\n            monitor: new VideoTextureMonitor(loadedImage, texture)\n          };\n        }\n\n        // We have finished inserting\n        return true;\n      } else {\n        // Log an error\n        console.error(`Could not fit resource into atlas`, request);\n        request.texture = this.setDefaultImage(texture, atlasName);\n        return false;\n      }\n    }\n\n    // Since the image did not fit, we now get the atlas to consolidate all of\n    // it's existing resources by removing unused images that were placed in the\n    // atlas but were flagged as no longer used.\n    else {\n      if (texture && !texture.isValid) {\n        debug(\"Resource was invalidated during load:\", request);\n      } else {\n        // Log an error and load a default sub texture\n        console.error(`Could not load resource:`, request);\n      }\n\n      if (request.texture) {\n        request.texture = this.setDefaultImage(request.texture, atlasName);\n      }\n\n      return false;\n    }\n  }\n\n  /**\n   * Retrieves the actual Atlas object for a given resource id\n   */\n  getAtlasTexture(resourceId: string): Atlas | undefined {\n    return this.allAtlas.get(resourceId);\n  }\n\n  /**\n   * This takes in any atlas resource and ensures the image is available and\n   * ready to render.\n   */\n  private async loadImage(\n    resource: IAtlasResourceRequest\n  ): Promise<TexImageSource | null> {\n    const subTexture = resource.texture || new SubTexture();\n    const source = resource.source;\n    resource.texture = subTexture;\n    if (resource.texture.isValid === false) return null;\n\n    if (source instanceof HTMLImageElement) {\n      let image = await new Promise<TexImageSource | null>(resolve => {\n        if (!(source instanceof HTMLImageElement)) return;\n        const image: HTMLImageElement | undefined = source;\n\n        if (image.width && image.height) {\n          ImageRasterizer.calculateImageSize(image);\n          subTexture.pixelWidth = image.width;\n          subTexture.pixelHeight = image.height;\n          subTexture.aspectRatio = image.width / image.height;\n          resolve(image);\n          return;\n        }\n\n        if (image) {\n          image.onload = function() {\n            subTexture.pixelWidth = image.width;\n            subTexture.pixelHeight = image.height;\n            subTexture.aspectRatio = image.width / image.height;\n            image.onload = null;\n            resolve(image);\n          };\n\n          image.onerror = function() {\n            console.error(\"Error generating Image element for source:\", source);\n            image.onload = null;\n            resolve(null);\n          };\n        } else {\n          resolve(null);\n        }\n      });\n\n      if (\n        image &&\n        resource.rasterizationScale !== undefined &&\n        resource.rasterizationScale !== 1\n      ) {\n        image = await ImageRasterizer.resizeImage(\n          image,\n          resource.rasterizationScale || 1\n        );\n      }\n\n      return image;\n    } else if (source instanceof HTMLVideoElement) {\n      if (source.videoHeight === 0 || source.videoWidth === 0) {\n        console.warn(\n          \"Video requests to the atlas manager MUST have the video completely loaded and ready for loading\",\n          \"There are too many caveats to automate video loading at this low of a level to have it prepped properly for\",\n          \"use in the texture for all browsers. Consider handling video resources at the layer level to have them\",\n          \"prepped for use.\"\n        );\n        return null;\n      }\n\n      // At this point, the video width and height should definitely be established and can be applied to the texture\n      subTexture.pixelWidth = source.videoWidth;\n      subTexture.pixelHeight = source.videoHeight;\n      subTexture.aspectRatio = source.videoWidth / source.videoHeight;\n\n      // Return the video here to indicate a successful load\n      return source;\n    } else if (isString(source)) {\n      const dataURL = source;\n\n      let image = await new Promise<TexImageSource | null>(resolve => {\n        const generatingImage = new Image();\n\n        generatingImage.onload = function() {\n          subTexture.pixelWidth = generatingImage.width;\n          subTexture.pixelHeight = generatingImage.height;\n          subTexture.aspectRatio =\n            generatingImage.width / generatingImage.height;\n          generatingImage.onload = null;\n          resolve(generatingImage);\n        };\n\n        generatingImage.onerror = function() {\n          console.error(\"Error generating Image element for source:\", source);\n          resolve(null);\n        };\n\n        generatingImage.src = dataURL;\n      });\n\n      if (\n        image &&\n        resource.rasterizationScale !== undefined &&\n        resource.rasterizationScale !== 1\n      ) {\n        image = await ImageRasterizer.resizeImage(\n          image,\n          resource.rasterizationScale || 1\n        );\n      }\n\n      return image;\n    } else {\n      let image: TexImageSource = source;\n\n      if (\n        image &&\n        resource.rasterizationScale !== undefined &&\n        resource.rasterizationScale !== 1\n      ) {\n        image = await ImageRasterizer.resizeImage(\n          image,\n          resource.rasterizationScale || 1\n        );\n      }\n\n      return image;\n    }\n  }\n\n  /**\n   * When this is triggered, the atlas will examine all of it's packing and\n   * repack it's resources on the texture for the atlas thus eliminating any\n   * dead space from resources that have been disposed.\n   *\n   * This process will cause the atlas to generate a new Texture to utilize and\n   * dispose of the old texture to allow for the atlas to redraw it's texture\n   * using GPU operations which is much faster than a CPU operation of\n   * generating the texture.\n   */\n  private repackResources(atlas: Atlas) {\n    if (!this.renderer) {\n      console.warn(\n        \"Attempted to repack resources for an atlas, but no renderer has been specified for this manager yet.\"\n      );\n      return false;\n    }\n\n    // Flatten the nodes into a list to make them easier to work with\n    const toProcess = [atlas.packing];\n    const allNodes = [];\n    let index = 0;\n    // Track the old bounds position information. Will be able to look up via the node's bounds object as it will get\n    // reused for the remapping.\n    const oldBounds = new Map<Bounds<any>, Bounds<any>>();\n\n    // We process all of the nodes in the current atlas and flatten out the tree to merely the bounds of each node\n    while (index < toProcess.length) {\n      const next = toProcess[index];\n      index++;\n\n      // Only gather nodes that have not been invalidated.\n      if (next.data && next.data.texture) {\n        allNodes.push(next);\n        oldBounds.set(next.bounds, new Bounds<any>(next.bounds));\n      }\n\n      if (next.child[0]) toProcess.push(next.child[0]);\n      if (next.child[1]) toProcess.push(next.child[1]);\n    }\n\n    // Place the nodes with the largest features first\n    allNodes.sort(\n      (a, b) =>\n        Math.max(b.bounds.width, b.bounds.height) -\n        Math.max(a.bounds.width, a.bounds.height)\n    );\n\n    // If there are no valid nodes left, then we simply clear out the root pack node and let the texture repack anew.\n    if (allNodes.length <= 0) {\n      atlas.packing = new PackNode<SubTexture>(0, 0, atlas.width, atlas.height);\n      return true;\n    }\n\n    // We now know at this point a new texture will be needed to render the newly packed layout\n    // Simply copy all of the settings of the existing texture\n    const newAtlasTexture = new Texture(atlas.texture);\n    // Initialize the texture with blank information\n    newAtlasTexture.data = {\n      buffer: new Uint8Array(atlas.width * atlas.height * 4),\n      width: atlas.width,\n      height: atlas.height\n    };\n\n    // We now have all of the valid nodes and their respective original bounds. We will now repack these nodes to\n    // get the new locations of them all.\n    const rootNode = new PackNode<SubTexture>(0, 0, atlas.width, atlas.height);\n    let failedRepack = false;\n\n    for (let i = 0, iMax = allNodes.length; i < iMax; ++i) {\n      const node = allNodes[i];\n\n      if (!node.data) {\n        console.warn(\"Attempted to repack a node with no valid data.\");\n        continue;\n      }\n\n      node.bounds.x = 0;\n      node.bounds.y = 0;\n\n      const newNode = rootNode.insert({\n        bounds: node.bounds,\n        data: node.data\n      });\n\n      if (!newNode) {\n        console.warn(\n          \"When repacking the atlas, an existing node was unable to be repacked\",\n          node\n        );\n        failedRepack = true;\n        continue;\n      }\n\n      // Apply the node to the subtexture to let the subtexture know it's new coordinates in the render space. This\n      // sub texture should be the same subtexture object the node originally was associated with. This way all\n      // references using this subtexture object will immediately have the new subtexture information.\n      PackNode.applyToSubTexture(rootNode, newNode, node.data);\n    }\n\n    if (failedRepack) {\n      return false;\n    }\n\n    // Now we can map all of the nodes to quads\n    // Positions = Total nodes * Vec2 for xy coords * 6 vertices per quad\n    const positions = new Float32Array(allNodes.length * 2 * 6);\n    // Texture coordinates = Total nodes * Vec2 for xy coord positions * 6 vertices per quad\n    const texCoords = new Float32Array(allNodes.length * 2 * 6);\n    // We now produce the geometry that will render the old texture atlas elements to the new texture atlas. The texture\n    // coordinates will be the coordinates located on the old texture. The position of the vertices will be the new pack\n    // location to be rendered on the new texture.\n    const tempTexture = new SubTexture();\n\n    for (let i = 0, iMax = allNodes.length; i < iMax; ++i) {\n      const node = allNodes[i];\n      const previousBounds = oldBounds.get(node.bounds);\n      const nextTexture = node.data;\n\n      if (!previousBounds || !nextTexture) {\n        console.warn(\n          \"While repacking there was an issue finding the previous bounds and the next texture to use\",\n          previousBounds,\n          nextTexture\n        );\n        continue;\n      }\n\n      // We need the atlas coordinates of the previous bounds so we can make sure we keep the coordinate system\n      // consistent with the new packing\n      PackNode.applyToSubTexture(rootNode, previousBounds, tempTexture);\n      // Get the index of data for the first vertex for the quad for the node we want to render\n      const startIndex = i * 2 * 6;\n\n      // The position is the location within clip space the new packing will occur. We must convert the coords to clip\n      // space simply by x * 2 - 1 as clip space is [-1, 1] so it's '2' wide while tex coords are 0 - 1.\n      // Set the xy coordinate within the new texture\n      positions[startIndex] = nextTexture.atlasTL[0] * 2 - 1;\n      positions[startIndex + 1] = nextTexture.atlasTL[1] * 2 - 1;\n      positions[startIndex + 2] = nextTexture.atlasTR[0] * 2 - 1;\n      positions[startIndex + 3] = nextTexture.atlasTR[1] * 2 - 1;\n      positions[startIndex + 4] = nextTexture.atlasBL[0] * 2 - 1;\n      positions[startIndex + 5] = nextTexture.atlasBL[1] * 2 - 1;\n\n      // Bottom triangle\n      positions[startIndex + 6] = nextTexture.atlasTR[0] * 2 - 1;\n      positions[startIndex + 7] = nextTexture.atlasTR[1] * 2 - 1;\n      positions[startIndex + 8] = nextTexture.atlasBR[0] * 2 - 1;\n      positions[startIndex + 9] = nextTexture.atlasBR[1] * 2 - 1;\n      positions[startIndex + 10] = nextTexture.atlasBL[0] * 2 - 1;\n      positions[startIndex + 11] = nextTexture.atlasBL[1] * 2 - 1;\n\n      // The Tex coordinate is the tex coords within the previous position\n      // Top triangle\n      texCoords[startIndex] = tempTexture.atlasTL[0];\n      texCoords[startIndex + 1] = tempTexture.atlasTL[1];\n      texCoords[startIndex + 2] = tempTexture.atlasTR[0];\n      texCoords[startIndex + 3] = tempTexture.atlasTR[1];\n      texCoords[startIndex + 4] = tempTexture.atlasBL[0];\n      texCoords[startIndex + 5] = tempTexture.atlasBL[1];\n\n      // Bottom triangle\n      texCoords[startIndex + 6] = tempTexture.atlasTR[0];\n      texCoords[startIndex + 7] = tempTexture.atlasTR[1];\n      texCoords[startIndex + 8] = tempTexture.atlasBR[0];\n      texCoords[startIndex + 9] = tempTexture.atlasBR[1];\n      texCoords[startIndex + 10] = tempTexture.atlasBL[0];\n      texCoords[startIndex + 11] = tempTexture.atlasBL[1];\n\n      // Set the subtexture's texture to the new texture\n      nextTexture.texture = newAtlasTexture;\n    }\n\n    // Create a model to render our newly specified geometry. Our vertices will already be in clip\n    // space so no camera transforms will be needed.\n    const geometry = new Geometry();\n    const positionAttr = new Attribute(positions, 2);\n    const texAttr = new Attribute(texCoords, 2);\n    geometry.addAttribute(\"position\", positionAttr);\n    geometry.addAttribute(\"texCoord\", texAttr);\n\n    // Now we create a render target that will render to our new texture\n    const renderTarget = new RenderTarget({\n      buffers: {\n        color: { buffer: newAtlasTexture, outputType: 0 }\n      },\n      retainTextureTargets: true\n    });\n\n    // Make a simple material that will handle the\n    const material = new Material({\n      culling: GLSettings.Material.CullSide.NONE,\n      uniforms: {\n        texture: { type: MaterialUniformType.TEXTURE, value: atlas.texture }\n      },\n      fragmentShader: new Map([\n        [\n          renderTarget,\n          {\n            outputNames: [],\n            outputTypes: [0],\n            source: `\n          precision highp float;\n\n          uniform sampler2D texture;\n          varying vec2 _texCoord;\n\n          void main() {\n            gl_FragColor = texture2D(texture, _texCoord);\n          }\n        `\n          }\n        ]\n      ]),\n      vertexShader: `\n        precision highp float;\n\n        attribute vec2 position;\n        attribute vec2 texCoord;\n        varying vec2 _texCoord;\n\n        void main() {\n          _texCoord = texCoord;\n          gl_Position = vec4(position, 0.0, 1.0);\n        }\n      `\n    });\n\n    const model = new Model(geometry, material);\n    model.vertexCount = allNodes.length * 6;\n    model.drawMode = GLSettings.Model.DrawMode.TRIANGLES;\n\n    // Make a dummy scene to cram our model into\n    const scene = new Scene();\n    scene.add(model);\n    // Now perform the rendering to our new texture. This should effectively make our new texture the newly packed\n    // version of the previous atlas texture.\n    this.renderer.setRenderTarget(renderTarget);\n    this.renderer.setViewport(this.renderer.getFullViewport());\n    this.renderer.setScissor(this.renderer.getFullViewport());\n    this.renderer.render(scene, renderTarget);\n    // Clean up anything that will try to retain GPU resources\n    material.dispose();\n    geometry.destroy();\n    renderTarget.dispose();\n    // The old texture is no longer needed now!\n    atlas.texture.destroy();\n    // Apply the new texture to our atlas. The texture should already be applied to all of the valid\n    // subtextures already.\n    atlas.texture = newAtlasTexture;\n    // Set the new packing node as the packing scheme for the texture since it was recalculated. This will allow\n    // new nodes to use the new pack layout.\n    atlas.packing = rootNode;\n\n    return true;\n  }\n\n  /**\n   * This targets an existing atlas and attempts to update it with the provided\n   * atlas resources.\n   */\n  async updateAtlas(atlasName: string, requests: IAtlasResourceRequest[]) {\n    const atlas = this.allAtlas.get(atlasName);\n\n    if (atlas) {\n      for (const request of requests) {\n        if (!request.disposeResource) {\n          await this.draw(atlas, request);\n        }\n      }\n\n      // Now that all of the requests have been processed, we can now update\n      // reference counting for the underlying resources.\n      for (let i = 0, iMax = requests.length; i < iMax; ++i) {\n        const request = requests[i];\n\n        if (request.disposeResource) atlas.stopUsingResource(request);\n        else atlas.useResource(request);\n      }\n\n      // Now resolve the reference counting with the atlas so the atlas can\n      // invalidate textures and flag space on the atlas as available for\n      // rendering again.\n      atlas.resolveResources();\n    } else {\n      console.warn(\n        \"Can not update non-existing atlas:\",\n        atlasName,\n        \"These resources will not be loaded:\",\n        requests\n      );\n    }\n\n    return atlas;\n  }\n}\n","let canvas: CanvasRenderingContext2D | null;\n\nexport interface IImageRasterizedMetrics {\n  canvas: HTMLCanvasElement;\n  height: number;\n  width: number;\n}\n\nexport class ImageRasterizer {\n  /**\n   * This loops until our canvas context is available\n   */\n  static async awaitContext() {\n    // Iterate till the browser provides a valid canvas to render elements into\n    while (!canvas) {\n      this.getContext();\n      await new Promise(resolve => setTimeout(resolve, 10));\n    }\n  }\n\n  /**\n   * Attempts to populate the 'canvas' context for rendering images offscreen.\n   */\n  static getContext() {\n    if (!canvas) {\n      canvas = document.createElement(\"canvas\").getContext(\"2d\");\n    }\n  }\n\n  /**\n   * This ensures an image is renderable at the current moment. This draws the\n   * image to a canvas partially to help the image 'warm up' within some browser\n   * contexts to ensure the image can be used as a drawable item.\n   */\n  static async calculateImageSize(image: HTMLImageElement) {\n    await this.awaitContext();\n\n    if (!canvas) {\n      console.warn(\n        \"The Image rasterizer was unable to establish a valid canvas context. Please ensure the system supports contexts and ensure the document is ready first.\"\n      );\n      return;\n    }\n\n    if (image.width === 0 || image.height === 0) {\n      console.warn(\n        \"Images provided shoud have valid dimensions! Please ensure the image is loaded first.\"\n      );\n      return;\n    }\n\n    // Just make sure th canvas is available\n    canvas.canvas.width = 100;\n    canvas.canvas.height = 100;\n    // Render the image into our canvas merely to ensure the image can be\n    // rendered This action often 'warms up' images such as images that have a\n    // data URL instead of a path\n    canvas.drawImage(image, 0, 0, 1, 1);\n\n    return [image.width, image.height];\n  }\n\n  /**\n   * This resizes the input image by the provided scale.\n   */\n  static async resizeImage(image: TexImageSource, scale: number) {\n    await this.awaitContext();\n\n    if (!canvas) {\n      console.warn(\n        \"The Image rasterizer was unable to establish a valid canvas context. Please ensure the system supports contexts and ensure the document is ready first.\"\n      );\n\n      return image;\n    }\n\n    if (image.width === 0 || image.height === 0) {\n      console.warn(\n        \"Images provided shoud have valid dimensions! Please ensure the image is loaded first.\"\n      );\n\n      return image;\n    }\n\n    // Make the canvas the proper size to render the resized image\n    canvas.canvas.width = Math.floor(image.width * scale);\n    canvas.canvas.height = Math.floor(image.height * scale);\n\n    // Render the image into our canvas with the resizing taking place\n    if (image instanceof ImageData) {\n      canvas.putImageData(\n        image,\n        0,\n        0,\n        0,\n        0,\n        canvas.canvas.width,\n        canvas.canvas.height\n      );\n    } else {\n      canvas.drawImage(image, 0, 0, canvas.canvas.width, canvas.canvas.height);\n    }\n\n    // Make our canvas a data url for another image to become\n    const out = new Image();\n    out.src = canvas.canvas.toDataURL(\"image/png\");\n    // Ensure the image is renderable at this moment\n    await ImageRasterizer.calculateImageSize(out);\n\n    return out;\n  }\n}\n","import { WebGLRenderer } from \"../../gl\";\nimport { Texture } from \"../../gl/texture\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport { ILayerProps, Layer } from \"../../surface\";\nimport { BaseIOExpansion } from \"../../surface/layer-processing/base-io-expansion\";\nimport { InstanceIOValue, IResourceContext, ResourceType } from \"../../types\";\nimport { nextFrame } from \"../../util\";\nimport {\n  BaseResourceManager,\n  BaseResourceOptions\n} from \"../base-resource-manager\";\nimport { Atlas, IAtlasResource, isAtlasResource } from \"./atlas\";\nimport { AtlasManager } from \"./atlas-manager\";\nimport { IAtlasResourceRequest } from \"./atlas-resource-request\";\nimport { subTextureIOValue } from \"./sub-texture\";\nimport { TextureIOExpansion } from \"./texture-io-expansion\";\n\nexport interface IAtlasResourceManagerOptions {\n  /** This is the atlas manager that handles operations with our atlas' */\n  atlasManager?: AtlasManager;\n}\n\n/**\n * This class is responsible for tracking resources requested to be placed on an Atlas.\n * This makes sure the resource is uploaded and then properly cached so similar requests\n * return already existing resources. This also manages instances waiting for the resource\n * to be made available.\n */\nexport class AtlasResourceManager extends BaseResourceManager<\n  IAtlasResource,\n  IAtlasResourceRequest\n> {\n  /** This is the resources generated by this manager */\n  resources = new Map<string, Atlas>();\n  /** This is the atlas manager that handles operations with our atlas' */\n  atlasManager: AtlasManager;\n  /** This stores all of the requests awaiting dequeueing */\n  private requestQueue = new Map<string, IAtlasResourceRequest[]>();\n  /**\n   * This tracks if a resource is already in the request queue. This also stores ALL instances awaiting the resource.\n   */\n  private requestLookup = new Map<\n    string,\n    Map<IAtlasResourceRequest, [Layer<any, any>, Instance][]>\n  >();\n\n  /** Override the get and set of the webgl renderer so we can also apply it to the atlas manager object */\n  get webGLRenderer() {\n    return this._webGLRenderer;\n  }\n  set webGLRenderer(val: WebGLRenderer | undefined) {\n    this._webGLRenderer = val;\n    this.atlasManager.renderer = val;\n  }\n  private _webGLRenderer?: WebGLRenderer;\n\n  constructor(options?: IAtlasResourceManagerOptions) {\n    super();\n    this.atlasManager = (options && options.atlasManager) || new AtlasManager();\n  }\n\n  /**\n   * This dequeues all instance requests for a resource and processes the request which will\n   * inevitably make the instance active\n   */\n  async dequeueRequests() {\n    // This flag will be modified to reflect if a dequeue operation has occurred\n    let didDequeue = false;\n    const resourceRequestsWithKey: [string, IAtlasResourceRequest[]][] = [];\n\n    this.requestQueue.forEach((requests, resourceKey) => {\n      resourceRequestsWithKey.push([resourceKey, requests]);\n    });\n\n    this.requestQueue.clear();\n\n    for (const [targetAtlas, requests] of resourceRequestsWithKey) {\n      if (requests.length > 0) {\n        // We did dequeue\n        didDequeue = true;\n        // Pull out all of the requests into a new array and empty the existing queue to allow the queue to register\n        // New requests while this dequeue is being processed\n        const allRequests = requests.slice(0);\n        // Empty the queue to begin taking in new requests as needed\n        requests.length = 0;\n        // Tell the atlas manager to update with all of the requested resources\n        await this.atlasManager.updateAtlas(targetAtlas, allRequests);\n        // Get the requests for the given atlas\n        const atlasRequests = this.requestLookup.get(targetAtlas);\n\n        if (atlasRequests) {\n          // We will gather all unique instances for triggering next frame\n          const toTrigger = new Set<Instance>();\n\n          // Once the manager has been updated, we can now flag all of the instances waiting for the resources\n          // As active, which should thus trigger an update to the layers to perform a diff for each instance\n          allRequests.forEach(request => {\n            const requesters = atlasRequests.get(request);\n            atlasRequests.delete(request);\n\n            if (requesters && !request.disposeResource) {\n              for (let i = 0, iMax = requesters.length; i < iMax; ++i) {\n                const [layer, instance] = requesters[i];\n                // If the instance is still associated with buffer locations, then the instance can be activated. Having\n                // A buffer location is indicative the instance has not been deleted.\n                if (layer.managesInstance(instance)) {\n                  // Make sure the instance is active\n                  instance.active = true;\n                }\n\n                toTrigger.add(instance);\n              }\n            }\n          });\n\n          // Do a delay to next frame before we do our resource trigger so we can see any lingering updates get\n          // applied to the instance's rendering\n          nextFrame(() => {\n            toTrigger.forEach(instance => {\n              instance.active = true;\n              instance.resourceTrigger();\n            });\n          });\n        }\n      }\n    }\n\n    return didDequeue;\n  }\n\n  /**\n   * Free ALL resources managed under this resource manager\n   */\n  destroy() {\n    this.atlasManager.destroy();\n  }\n\n  /**\n   * System requests a resource get's destroyed here\n   */\n  destroyResource(init: BaseResourceOptions) {\n    const resource = this.resources.get(init.key);\n    if (!resource) return;\n    this.atlasManager.destroyAtlas(init.key);\n    this.resources.delete(init.key);\n  }\n\n  /**\n   * This retrieves the actual atlas texture that should be applied to a uniform's\n   * value.\n   */\n  getAtlasTexture(key: string): Texture | null {\n    const atlas = this.atlasManager.getAtlasTexture(key);\n\n    if (atlas) {\n      return atlas.texture;\n    }\n\n    return null;\n  }\n\n  /**\n   * Get generated resources from this manager\n   */\n  getResource(resourceKey: string) {\n    return this.resources.get(resourceKey) || null;\n  }\n\n  /**\n   * Return the IO Expander necessary to handle the resurce type this manager is attempting to provide for layers.\n   */\n  getIOExpansion(): BaseIOExpansion[] {\n    return [new TextureIOExpansion(ResourceType.ATLAS, this)];\n  }\n\n  /**\n   * Initialize the atlas resources requested for construction\n   */\n  async initResource(resource: BaseResourceOptions) {\n    if (isAtlasResource(resource)) {\n      const atlas = await this.atlasManager.createAtlas(resource);\n      this.resources.set(resource.key, atlas);\n    }\n  }\n\n  /**\n   * This is a request for atlas texture resources. It will produce either the coordinates needed to\n   * make valid texture lookups, or it will trigger a loading of resources to an atlas and cause an\n   * automated deactivation and reactivation of the instance.\n   */\n  request<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>,\n    instance: Instance,\n    request: IAtlasResourceRequest,\n    _context?: IResourceContext\n  ): InstanceIOValue {\n    const resourceContext = request.key || \"\";\n    const texture = request.texture;\n\n    // If the texture is ready and available, then we simply return the IO values\n    if (texture) {\n      return subTextureIOValue(texture);\n    }\n\n    // If a request is already made, then we must save the instance making the request for deactivation and\n    // Reactivation but without any additional atlas loading\n    let atlasRequests = this.requestLookup.get(resourceContext);\n\n    if (atlasRequests) {\n      const existingRequests = atlasRequests.get(request);\n\n      if (existingRequests) {\n        existingRequests.push([layer, instance]);\n        instance.active = false;\n        // request.texture = EMPTY_SUBTEXTURE;\n\n        return subTextureIOValue(request.texture);\n      }\n    } else {\n      atlasRequests = new Map();\n      this.requestLookup.set(resourceContext, atlasRequests);\n    }\n\n    // If the texture is not available, then we must load the resource, deactivate the instance\n    // And wait for the resource to become available. Once the resource is available, the system\n    // Must activate the instance to render the resource.\n    if (!request.disposeResource) {\n      instance.active = false;\n    }\n\n    let requests = this.requestQueue.get(resourceContext);\n\n    if (!requests) {\n      requests = [];\n      this.requestQueue.set(resourceContext, requests);\n    }\n\n    // request.texture = EMPTY_SUBTEXTURE;\n    requests.push(request);\n    atlasRequests.set(request, [[layer, instance]]);\n\n    // This returns essentially returns blank values for the resource lookup\n    return subTextureIOValue(texture);\n  }\n\n  /**\n   * System is requesting properties for a resource to be updated.\n   */\n  updateResource(options: BaseResourceOptions) {\n    if (!isAtlasResource(options)) return;\n  }\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport { ILayerProps, Layer } from \"../../surface/layer\";\nimport {\n  InstanceIOValue,\n  IResourceContext,\n  ResourceType,\n  TextureSize\n} from \"../../types\";\nimport { BaseResourceManager } from \"../base-resource-manager\";\nimport { IRenderTextureResource, RenderTexture } from \"./render-texture\";\nimport { IRenderTextureResourceRequest } from \"./render-texture-resource-request\";\nimport { TextureIOExpansion } from \"./texture-io-expansion\";\n\n/**\n * This manager handles creation and destruction of simple Texture Resources.\n * Render Textures are more used on a higher level with the Surface\n * configuration, so we don't need robust memeory handling for it.\n */\nexport class RenderTextureResourceManager extends BaseResourceManager<\n  IRenderTextureResource,\n  IRenderTextureResourceRequest\n> {\n  /** These are the generated resources this manager collects and monitors */\n  resources = new Map<string, RenderTexture>();\n\n  /**\n   * This manager does not need to dequeue requests as all requests will be\n   * immediately resolved with no asynchronous requirements.\n   */\n  async dequeueRequests() {\n    // Do nothing. We do not need to trigger a dequeue update as requests will\n    // be able to be processed immediately from this manager.\n    return false;\n  }\n\n  /**\n   * This frees up resources when the system indictates this manager is no\n   * longer needed.\n   */\n  destroy() {\n    this.resources.forEach(r => r.destroy());\n    this.resources.clear();\n  }\n\n  /**\n   * We make an expander for when an attribute requests a TEXTURE resource. This\n   * will ensure attributes that require a TEXTURE type resource will have the\n   * resource added as a uniform.\n   */\n  getIOExpansion() {\n    return [new TextureIOExpansion(ResourceType.TEXTURE, this)];\n  }\n\n  /**\n   * This retrieves the generated resources this manager tracks.\n   */\n  getResource(resourceKey: string) {\n    return this.resources.get(resourceKey) || null;\n  }\n\n  /**\n   * The system will inform this manager when a resource is no longer needed and\n   * should be disposed.\n   */\n  destroyResource(options: IRenderTextureResource) {\n    const resource = this.resources.get(options.key);\n    if (!resource) return;\n    resource.destroy();\n    this.resources.delete(options.key);\n  }\n\n  /**\n   * The system will inform this manager when a resource should be built.\n   */\n  async initResource(options: IRenderTextureResource) {\n    let resource = this.resources.get(options.key);\n\n    if (resource) {\n      console.warn(\n        \"Attempted to generate a RenderTexture that already exists for key\",\n        options.key\n      );\n      return;\n    }\n\n    resource = new RenderTexture(options, this.webGLRenderer);\n    this.resources.set(options.key, resource);\n  }\n\n  /**\n   * Handle requests that stream in from instances requesting metrics for a\n   * specific resource.\n   */\n  request<U extends Instance, V extends ILayerProps<U>>(\n    _layer: Layer<U, V>,\n    _instance: Instance,\n    resourceRequest: IRenderTextureResourceRequest,\n    _context?: IResourceContext\n  ): InstanceIOValue {\n    const resource = this.resources.get(resourceRequest.key);\n    if (!resource) return [0, 0, 0, 0];\n    resourceRequest.texture = resource.texture;\n\n    return [0, 0, 1, 1];\n  }\n\n  /**\n   * Trigger that executes when the rendering context resizes. For this manager,\n   * we will update all textures with dimensions that are tied to the screen.\n   */\n  resize() {\n    const toUpdate = new Map<string, RenderTexture>();\n\n    this.resources.forEach((resource, key) => {\n      // Only do a resize of a texture if any of it's dimensions are tied to the\n      // screen.\n      if (\n        resource.width > TextureSize.SCREEN &&\n        resource.height > TextureSize.SCREEN\n      ) {\n        return;\n      }\n\n      // Remove the old texture\n      resource.texture.destroy();\n      // Regenerate the resource with the new dimensions\n      resource = new RenderTexture(resource, this.webGLRenderer);\n      toUpdate.set(key, resource);\n    });\n\n    toUpdate.forEach((resource, key) => this.resources.set(key, resource));\n  }\n\n  /**\n   * This targets the specified resource and attempts to update it's settings.\n   */\n  updateResource(options: IRenderTextureResource) {\n    const resource = this.resources.get(options.key);\n    if (!resource) return;\n    console.warn(\"UPDATING AN EXISTING RENDER TEXTURE IS NOT SUPPORTED YET\");\n  }\n}\n","import { QueuedEventHandler } from \"../../event-management/queued-event-handler\";\nimport {\n  IEventInteraction,\n  IMouseInteraction,\n  ITouchInteraction\n} from \"../../event-management/types\";\nimport { FragmentOutputType, PickType } from \"../../types\";\nimport {\n  isDefined,\n  mapGetWithDefault,\n  mapInjectDefault,\n  PromiseResolver\n} from \"../../util\";\nimport { Layer } from \"../layer\";\nimport { LayerScene } from \"../layer-scene\";\nimport { IViewProps, View } from \"../view\";\n\n/**\n * This class is an injected event manager for the surface, it specifically\n * handles taking in mouse events intended for view interactions and broadcasts\n * them to the layers that have picking enabled, thus allowing the layers to\n * respond to mouse view locations and broadcast Instance interactions based on\n * the interaction with the View the layer is a part of.\n *\n * In Summary: This is an adapter that takes in interactions to the views and\n * injects those events into the layers associated with the views so that the\n * layers can translate the events to gestures.\n */\nexport class LayerMouseEvents extends QueuedEventHandler {\n  /** This tracks which views have the mouse over them so we can properly broadcast view is out events */\n  private isOver = new Set<View<IViewProps>>();\n  /** This tracks which views have touches over them */\n  private isTouchOver = new Map<number, Set<View<IViewProps>>>();\n  /** This is the surface this manager is aiding with broadcasting events to layers */\n  private get scenes(): LayerScene[] {\n    if (!this.surface || !this.surface.sceneDiffs) return [];\n    return this.surface.sceneDiffs.items;\n  }\n  /**\n   * This promise waits for the render to complete. Color picking has a\n   * complicated process of needing an event to determine which colors to pick\n   * from a view resource. The event needs to provide information for processing\n   * colors, then the colors need to be processed, then the processed\n   * information needs to be used in the same event flow to the Layer handlers.\n   *\n   * In addition to this: we want to allow for pipeline controlled processing of\n   * the colors!\n   *\n   * So, this new event management solves all of these problems: We dequeue\n   * events before render. We process the color picking position, then we wait\n   * for rendering to complete so commands can run, then we continue with the\n   * broadcast post render.\n   */\n  private willRenderResolver: PromiseResolver<void>;\n  private didRenderResolver: PromiseResolver<void>;\n\n  constructor() {\n    super({\n      handleClick: async (e: IMouseInteraction) => {\n        // Enable picking, then wait for next render\n        this.enablePicking();\n        await this.willRenderResolver.promise;\n        // Enable picking again, then wait for end of this frame\n        this.enablePicking();\n        await this.didRenderResolver.promise;\n\n        // Broadcast interactions\n        this.handleInteraction(e, (layer, view) => {\n          layer.interactions.handleMouseClick(view, e);\n        });\n      },\n\n      handleTap: async (e: ITouchInteraction) => {\n        // Enable picking, then wait for next render\n        this.enablePicking();\n        await this.willRenderResolver.promise;\n        // Enable picking again, then wait for end of this frame\n        this.enablePicking();\n        await this.didRenderResolver.promise;\n\n        e.touches.forEach(interaction => {\n          this.handleInteraction(interaction, (layer, view) => {\n            layer.interactions.handleTap(view, e, interaction);\n          });\n        });\n      },\n\n      handleDrag: async (e: IMouseInteraction) => {\n        await this.willRenderResolver.promise;\n\n        this.handleInteraction(e, (layer, view) => {\n          layer.interactions.handleMouseDrag(view, e);\n        });\n      },\n\n      handleMouseDown: async (e: IMouseInteraction) => {\n        this.enablePicking();\n        await this.willRenderResolver.promise;\n\n        this.handleInteraction(e, (layer, view) =>\n          layer.interactions.handleMouseDown(view, e)\n        );\n      },\n\n      handleTouchDown: async (e: ITouchInteraction) => {\n        this.enablePicking();\n        await this.willRenderResolver.promise;\n\n        e.touches.forEach(interaction => {\n          this.handleInteraction(interaction, (layer, view) =>\n            layer.interactions.handleTouchDown(view, e, interaction)\n          );\n        });\n      },\n\n      handleMouseUp: async (e: IMouseInteraction) => {\n        await this.willRenderResolver.promise;\n\n        this.handleInteraction(e, (layer, view) =>\n          layer.interactions.handleMouseUp(view, e)\n        );\n      },\n\n      handleTouchUp: async (e: ITouchInteraction) => {\n        await this.willRenderResolver.promise;\n\n        e.touches.forEach(interaction => {\n          this.handleInteraction(interaction, (layer, projection) =>\n            layer.interactions.handleTouchUp(projection, e, interaction)\n          );\n        });\n      },\n\n      handleMouseOut: async (e: IMouseInteraction) => {\n        await this.willRenderResolver.promise;\n\n        // All views that are moused over should no longer be considered over and broadcast a mouse out\n        this.isOver.forEach(view => {\n          this.handleView(view, (layer, projection) =>\n            layer.interactions.handleMouseOut(projection, e)\n          );\n        });\n\n        // Nothing is over anymore\n        this.isOver.clear();\n      },\n\n      handleTouchOut: async (e: ITouchInteraction) => {\n        await this.willRenderResolver.promise;\n\n        e.touches.forEach(interaction => {\n          const isTouchOver = mapGetWithDefault(\n            this.isTouchOver,\n            interaction.touch.touch.identifier,\n            new Set()\n          );\n\n          // All views that are moused over should no longer be considered over and broadcast a mouse out\n          isTouchOver.forEach(view => {\n            this.handleView(view, (layer, projection) =>\n              layer.interactions.handleTouchOut(projection, e, interaction)\n            );\n          });\n\n          // Nothing is over anymore\n          this.isOver.clear();\n        });\n      },\n\n      handleMouseMove: async (e: IMouseInteraction) => {\n        this.enablePicking();\n        await this.willRenderResolver.promise;\n\n        // Get all of the scenes we have interacted with, and broadcast a move event for each\n        const allSceneViews = this.handleInteraction(e, (layer, view) =>\n          layer.interactions.handleMouseMove(view, e)\n        );\n\n        // For quick lookups map all of the current SceneViews that are over\n        const currentSceneViews = new Set<View<IViewProps>>();\n        allSceneViews.forEach(v => currentSceneViews.add(v));\n\n        // Detect which of the views are no longer over\n        this.isOver.forEach(view => {\n          if (!currentSceneViews.has(view)) {\n            this.handleView(view, (layer, projection) =>\n              layer.interactions.handleMouseOut(projection, e)\n            );\n          }\n        });\n\n        // Detect which of the views are newly over\n        currentSceneViews.forEach(sceneView => {\n          if (!this.isOver.has(sceneView)) {\n            this.handleView(sceneView, (layer, projection) =>\n              layer.interactions.handleMouseOver(projection, e)\n            );\n          }\n        });\n\n        // Update the current views that are over to the currently over views for next event\n        this.isOver = currentSceneViews;\n      },\n\n      /**\n       * Touch dragging is essentially touch moving as it's the only way to make a touch glide across the screen\n       */\n      handleTouchDrag: async (e: ITouchInteraction) => {\n        this.enablePicking();\n        await this.willRenderResolver.promise;\n\n        e.touches.forEach(interaction => {\n          // Get all of the scenes we have interacted with, and broadcast a move event for each\n          const allSceneViews = this.handleInteraction(\n            interaction,\n            (layer, view) =>\n              layer.interactions.handleTouchMove(view, e, interaction)\n          );\n\n          // For quick lookups map all of the current SceneViews that are over\n          const currentSceneViews = new Set<View<IViewProps>>();\n          allSceneViews.forEach(v => currentSceneViews.add(v));\n          const isTouchOver = mapInjectDefault(\n            this.isTouchOver,\n            interaction.touch.touch.identifier,\n            new Set()\n          );\n\n          // Detect which of the views are no longer over\n          isTouchOver.forEach(view => {\n            if (!currentSceneViews.has(view)) {\n              this.handleView(view, (layer, projection) =>\n                layer.interactions.handleTouchOut(projection, e, interaction)\n              );\n            }\n          });\n\n          // Detect which of the views are newly over\n          currentSceneViews.forEach(sceneView => {\n            if (!isTouchOver.has(sceneView)) {\n              this.handleView(sceneView, (layer, projection) =>\n                layer.interactions.handleTouchOver(projection, e, interaction)\n              );\n            }\n          });\n\n          // Update the current views that are over to the currently over views for next event\n          this.isTouchOver.set(\n            interaction.touch.touch.identifier,\n            currentSceneViews\n          );\n        });\n      }\n    });\n  }\n\n  private enablePicking() {\n    if (this.surface) {\n      this.surface.enableOptimizedOutput(FragmentOutputType.PICKING);\n    }\n  }\n\n  /**\n   * We want to dequeue the events after a render has taken place.\n   */\n  willRender() {\n    // Clean up the picking information as it's only valid per event\n    for (let i = 0, iMax = this.scenes.length; i < iMax; ++i) {\n      const scene = this.scenes[i];\n\n      for (let k = 0, kMax = scene.layers.length; k < kMax; ++k) {\n        const layer = scene.layers[k];\n        delete layer.interactions.colorPicking;\n      }\n    }\n\n    // Resolve our previous frame's events that were waiting for a render to\n    // complete after enabling picking\n    if (this.willRenderResolver) this.willRenderResolver.resolve();\n    // Reload the resolver\n    this.willRenderResolver = new PromiseResolver<void>();\n    // Broadcast all events to the layers\n    this.dequeue();\n  }\n\n  /**\n   * After rendering has completed, we release all handlers waiting for\n   * completion.\n   */\n  async didRender() {\n    if (this.didRenderResolver) this.didRenderResolver.resolve();\n    this.didRenderResolver = new PromiseResolver<void>();\n  }\n\n  private getSceneViewsUnderMouse(e: IEventInteraction) {\n    const viewByViewId = new Map<string, View<IViewProps>>();\n\n    // Map the scenes to SceneViews\n    for (let i = 0, iMax = this.scenes.length; i < iMax; ++i) {\n      const scene = this.scenes[i];\n\n      for (let k = 0, kMax = scene.views.length; k < kMax; ++k) {\n        const view = scene.views[k];\n        viewByViewId.set(view.id, view);\n      }\n    }\n\n    // Now retrieve and convert each view under the mouse to the scene view it coincides with\n    return e.target.views\n      .map(viewItem => viewByViewId.get(viewItem.view.id))\n      .filter(isDefined);\n  }\n\n  private handleInteraction(\n    e: IEventInteraction,\n    callback: (layer: Layer<any, any>, view: View<any>) => void\n  ) {\n    // Get all of the scenes under the mouse\n    const views = this.getSceneViewsUnderMouse(e);\n\n    // For every view of every scene, we must tell it's layers it's world space is receiving mouse interactions\n    for (let i = 0, iMax = views.length; i < iMax; ++i) {\n      const view = views[i];\n      this.handleView(view, callback);\n    }\n\n    return views;\n  }\n\n  private handleView(\n    view: View<IViewProps>,\n    callback: (layer: Layer<any, any>, view: View<any>) => void\n  ) {\n    for (let i = 0, iMax = view.scene.layers.length; i < iMax; ++i) {\n      const layer = view.scene.layers[i];\n\n      if (layer.picking && layer.picking.type !== PickType.NONE) {\n        callback(layer, view);\n      }\n    }\n  }\n}\n","module.exports = \"vec3 cameraSpace(vec3 world) {\\nreturn (world + cameraOffset) * cameraScale2D;\\n}\\nvec3 cameraSpaceSize(vec3 worldSize) {\\nreturn worldSize * cameraScale2D;\\n}\\nvec4 clipSpace(vec3 world) {\\nreturn (viewProjection) * vec4(cameraSpace(world), 1.0);\\n}\\nvec4 clipSpaceSize(vec3 worldSize) {\\nreturn (viewProjection) * vec4(cameraSpaceSize(worldSize), 0.0);\\n}\"","export * from \"./basic-camera-2d-controller\";\nexport * from \"./camera-2d\";\nexport * from \"./control-2d\";\nexport * from \"./layer-2d\";\nexport * from \"./reference-camera-2d\";\nexport * from \"./view-2d\";\n","export enum EdgeScaleType {\n  /** All dimensions are within world space */\n  NONE,\n  /**\n   * The control points are a delta from the end points within screen space, and the line thickness is within\n   * screen space as well all measured in pixels. The scaleFactor scales both thickness and control delta values.\n   * The endpoints remain in world space\n   */\n  SCREEN_CURVE\n}\n\nexport enum EdgeType {\n  /** Makes a straight edge with no curve */\n  LINE,\n  /** Makes a single control point Bezier curve */\n  BEZIER,\n  /** Makes a two control point bezier curve */\n  BEZIER2\n}\n\n/**\n * This is the broadphase control for edges to help handle quad tree adjustments for picking. If the edge scale type\n * is NONE, you don't need to utilize this. If you use screen space and have camera distortions along an axis, this\n * can help greatly.\n */\nexport enum EdgeBroadphase {\n  /** Use this if the broad phase detection should use both width and height of the edge's bounds */\n  ALL,\n  /** Use this to ensure a test against the edge is performed if the mouse aligns with it on the x-axis */\n  PASS_Y,\n  /** Use this to ensure a test against the edge is performed if the mouse aligns with it on the y axis */\n  PASS_X\n}\n","import { InstanceProvider } from \"../../../instance-provider/instance-provider\";\nimport { IAutoEasingMethod } from \"../../../math/auto-easing-method\";\nimport { copy2, copy4, dot2, scale2, Vec, Vec2 } from \"../../../math/vector\";\nimport { fontRequest, IFontResourceRequest } from \"../../../resources\";\nimport { KernedLayout } from \"../../../resources/text/font-map\";\nimport {\n  ILayerConstructionClass,\n  LayerInitializer\n} from \"../../../surface/layer\";\nimport { InstanceDiffType, IPickInfo, ResourceType } from \"../../../types\";\nimport { createLayer, isDefined } from \"../../../util\";\nimport { Anchor, AnchorType, ScaleMode } from \"../../types\";\nimport { ILayer2DProps, Layer2D } from \"../../view/layer-2d\";\nimport { GlyphInstance } from \"./glyph-instance\";\nimport { GlyphLayer, IGlyphLayerOptions } from \"./glyph-layer\";\nimport { LabelInstance } from \"./label-instance\";\n\n/**\n * Default characters for truncating a label.\n */\nconst DEFAULT_TRUNCATION = \"...\";\n\n/**\n * This is a lookup to quickly find the proper calculation for setting the correct anchor\n * position based on the anchor type.\n */\nconst anchorCalculator: {\n  [key: number]: (anchor: Anchor, label: LabelInstance) => void;\n} = {\n  [AnchorType.TopLeft]: (anchor: Anchor, _label: LabelInstance) => {\n    anchor.x = 0;\n    anchor.y = 0;\n  },\n  [AnchorType.TopMiddle]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.size[0] / 2.0;\n    anchor.y = 0;\n  },\n  [AnchorType.TopRight]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.size[0];\n    anchor.y = 0;\n  },\n  [AnchorType.MiddleLeft]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = 0;\n    anchor.y = label.size[1] / 2;\n  },\n  [AnchorType.Middle]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.size[0] / 2.0;\n    anchor.y = label.size[1] / 2.0;\n  },\n  [AnchorType.MiddleRight]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.size[0];\n    anchor.y = label.size[1] / 2.0;\n  },\n  [AnchorType.BottomLeft]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = 0;\n    anchor.y = label.size[1];\n  },\n  [AnchorType.BottomMiddle]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.size[0] / 2.0;\n    anchor.y = label.size[1];\n  },\n  [AnchorType.BottomRight]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.size[0];\n    anchor.y = label.size[1];\n  },\n  [AnchorType.Custom]: (anchor: Anchor, _label: LabelInstance) => {\n    anchor.x = anchor.x || 0;\n    anchor.y = anchor.y || 0;\n  }\n};\n\nconst directions: Vec2[] = [\n  [-1, -1],\n  [0, -1],\n  [1, -1],\n  [-1, 0],\n  [0, 0],\n  [1, 0],\n  [-1, 1],\n  [0, 1],\n  [1, 1]\n].map((dir: Vec2) => {\n  const mag = Math.sqrt(dot2(dir, dir));\n  return scale2(dir, 1 / -mag);\n});\n\n/**\n * Lookup to quickly calculate the padding direction based on the the provided anchor type.\n */\nconst paddingCalculator: {\n  [key: number]: (anchor: Anchor) => void;\n} = {\n  [AnchorType.TopLeft]: (anchor: Anchor) => {\n    anchor.paddingDirection = scale2(directions[0], anchor.padding);\n  },\n  [AnchorType.TopMiddle]: (anchor: Anchor) => {\n    anchor.paddingDirection = scale2(directions[1], anchor.padding);\n  },\n  [AnchorType.TopRight]: (anchor: Anchor) => {\n    anchor.paddingDirection = scale2(directions[2], anchor.padding);\n  },\n  [AnchorType.MiddleLeft]: (anchor: Anchor) => {\n    anchor.paddingDirection = scale2(directions[3], anchor.padding);\n  },\n  [AnchorType.Middle]: (anchor: Anchor) => {\n    anchor.paddingDirection = [0, 0];\n  },\n  [AnchorType.MiddleRight]: (anchor: Anchor) => {\n    anchor.paddingDirection = scale2(directions[5], anchor.padding);\n  },\n  [AnchorType.BottomLeft]: (anchor: Anchor) => {\n    anchor.paddingDirection = scale2(directions[6], anchor.padding);\n  },\n  [AnchorType.BottomMiddle]: (anchor: Anchor) => {\n    anchor.paddingDirection = scale2(directions[7], anchor.padding);\n  },\n  [AnchorType.BottomRight]: (anchor: Anchor) => {\n    anchor.paddingDirection = scale2(directions[8], anchor.padding);\n  },\n  [AnchorType.Custom]: (anchor: Anchor) => {\n    anchor.paddingDirection = anchor.paddingDirection;\n  }\n};\n\n/**\n * Converts a Glyph interaction event to a Label interaction event\n */\nfunction mapHandler(handler?: (info: IPickInfo<LabelInstance>) => void) {\n  if (!handler) return undefined;\n  return (info: IPickInfo<GlyphInstance>) => {\n    handler({\n      ...info,\n      instances: info.instances.map(g => g.parentLabel).filter(isDefined)\n    } as IPickInfo<LabelInstance>);\n  };\n}\n\n/**\n * Constructor props for making a new label layer\n */\nexport interface ILabelLayerProps<TInstance extends LabelInstance>\n  extends ILayer2DProps<TInstance> {\n  /** Animation methods for various properties of the glyphs */\n  animate?: {\n    anchor?: IAutoEasingMethod<Vec>;\n    color?: IAutoEasingMethod<Vec>;\n    offset?: IAutoEasingMethod<Vec>;\n    origin?: IAutoEasingMethod<Vec>;\n  };\n  /** A custom layer to handle rendering glyph instances */\n  customGlyphLayer?: ILayerConstructionClass<\n    GlyphInstance,\n    IGlyphLayerOptions<GlyphInstance>\n  >;\n  /** String identifier of the resource font to use for the layer */\n  resourceKey?: string;\n  /** The scaling strategy the labels will use wheh scaling the scene up and down */\n  scaleMode?: ScaleMode;\n  /**\n   * This defines what characters to use to indicate truncation of labels when needed. This\n   * defaults to ellipses or three periods '...'\n   */\n  truncation?: string;\n  /** This indicates whether a label is in a textarea */\n  inTextArea?: boolean;\n\n  onMouseClick?(info: IPickInfo<TInstance>): void;\n}\n\n/**\n * This is a composite layer that will take in and manage Label Instances. The true instance\n * that will be rendered as a result of a Label Instance will simply be Glyph Instances. Hence\n * this is a composite layer that is merely a manager to split up the label's requested string\n * into Glyphs to render.\n */\nexport class LabelLayer<\n  TInstance extends LabelInstance,\n  TProps extends ILabelLayerProps<TInstance>\n> extends Layer2D<TInstance, TProps> {\n  static defaultProps: ILabelLayerProps<LabelInstance> = {\n    key: \"\",\n    data: new InstanceProvider<LabelInstance>()\n  };\n\n  /**\n   * When this is flagged, we must do a complete recomputation of all our label's glyphs positions and kernings.\n   * This event really only takes place when the font resource changes.\n   */\n  fullUpdate: boolean = false;\n  /** Provider for the glyph layer this layer manages */\n  glyphProvider = new InstanceProvider<GlyphInstance>();\n  /**\n   * Tracks all assigned glyphs for the given label.\n   */\n  labelToGlyphs = new Map<LabelInstance, GlyphInstance[]>();\n  /**\n   * This maps a label to it's request made for all of the kerning information needed for the label.\n   */\n  labelToKerningRequest = new Map<LabelInstance, IFontResourceRequest>();\n  /**\n   * This stores all of the glyphs the label is waiting on to fire the onReady event.\n   */\n  labelWaitingOnGlyph = new Map<LabelInstance, Set<GlyphInstance>>();\n  /**\n   * These are the property ids for the instances that we need to know when they changed so we can adjust\n   * the underlying glyphs.\n   */\n  propertyIds: { [key: string]: number } | undefined;\n  /**\n   * This stores the kerning request for the truncation characters.\n   */\n  truncationKerningRequest?: IFontResourceRequest;\n  /**\n   * This is the width of the truncation glyphs.\n   */\n  truncationWidth: number = -1;\n\n  /**\n   * This provides the child layers that will render on behalf of this layer.\n   *\n   * For Labels, a label is simply a group of well placed glyphs. So we defer all of\n   * the labels changes by converting the label into glyphs and applying the changes to\n   * it's set of glyphs.\n   */\n  childLayers(): LayerInitializer[] {\n    return [\n      createLayer(this.props.customGlyphLayer || GlyphLayer, {\n        animate: this.props.animate,\n        data: this.glyphProvider,\n        key: `${this.id}.glyphs`,\n        resourceKey: this.props.resourceKey,\n        scaleMode: this.props.scaleMode || ScaleMode.BOUND_MAX,\n        inTextArea: this.props.inTextArea,\n\n        picking: this.props.picking,\n        onMouseClick: mapHandler(this.props.onMouseClick),\n        onMouseUp: mapHandler(this.props.onMouseUp),\n        onMouseDown: mapHandler(this.props.onMouseDown),\n        onMouseOut: mapHandler(this.props.onMouseOut),\n        onMouseOver: mapHandler(this.props.onMouseOver),\n        onMouseMove: mapHandler(this.props.onMouseMove),\n        onMouseUpOutside: mapHandler(this.props.onMouseUpOutside),\n        onTap: mapHandler(this.props.onTap),\n        onTouchDown: mapHandler(this.props.onTouchDown),\n        onTouchUp: mapHandler(this.props.onTouchUp),\n        onTouchUpOutside: mapHandler(this.props.onTouchUpOutside),\n        onTouchMove: mapHandler(this.props.onTouchMove),\n        onTouchOut: mapHandler(this.props.onTouchOut),\n        onTouchOver: mapHandler(this.props.onTouchOver),\n        onTouchAllEnd: mapHandler(this.props.onTouchAllEnd),\n        onTouchAllOut: mapHandler(this.props.onTouchAllOut)\n      })\n    ];\n  }\n\n  /**\n   * We override the draw method of the layer to handle the diffs of the provider in a\n   * custom fashion by delegating the changes of the provider to the child layers.\n   */\n  draw() {\n    // Retrieve changes properly\n    const changes = this.resolveChanges();\n    // No changes, nothing to be done\n    if (changes.length <= 0) return;\n\n    // Make sure our instance property ids are established for the instance type involved\n    // We want only the ids of changes that causes us to\n    if (!this.propertyIds) {\n      const instance = changes[0][0];\n      this.propertyIds = this.getInstanceObservableIds(instance, [\n        \"text\",\n        \"active\",\n        \"anchor\",\n        \"color\",\n        \"origin\",\n        \"fontSize\",\n        \"maxWidth\",\n        \"maxScale\",\n        \"letterSpacing\"\n      ]);\n    }\n\n    const {\n      text: textId,\n      active: activeId,\n      anchor: anchorId,\n      color: colorId,\n      origin: originId,\n      fontSize: fontSizeId,\n      maxWidth: maxWidthId,\n      maxScale: maxScaleId,\n      letterSpacing: letterSpacingId\n    } = this.propertyIds;\n\n    for (let i = 0, iMax = changes.length; i < iMax; ++i) {\n      const [instance, diffType, changed] = changes[i];\n\n      switch (diffType) {\n        case InstanceDiffType.CHANGE:\n          // Perform the insert action instead of the change if the label has never been registered\n          if (!this.labelToGlyphs.get(instance)) {\n            this.insert(instance);\n            continue;\n          }\n\n          // If text was changed, the glyphs all need updating of their characters and\n          // possibly have glyphs added or removed to handle the issue.\n          if (changed[textId] !== undefined) {\n            this.invalidateRequest(instance);\n            this.layoutGlyphs(instance);\n          } else if (changed[activeId] !== undefined) {\n            if (instance.active) {\n              this.layoutGlyphs(instance);\n              this.showGlyphs(instance);\n            } else {\n              this.hideGlyphs(instance);\n            }\n          }\n\n          if (changed[anchorId]) {\n            this.updateAnchor(instance);\n          }\n\n          if (changed[colorId] !== undefined) {\n            this.updateGlyphColors(instance);\n          }\n\n          if (changed[originId] !== undefined) {\n            this.updateGlyphOrigins(instance);\n          }\n\n          if (changed[maxScaleId] !== undefined) {\n            this.updateGlyphMaxScales(instance);\n          }\n\n          if (changed[fontSizeId] !== undefined) {\n            this.invalidateRequest(instance);\n            this.layoutGlyphs(instance);\n          }\n\n          if (changed[maxWidthId] !== undefined) {\n            this.invalidateRequest(instance);\n            this.layoutGlyphs(instance);\n          }\n\n          if (changed[letterSpacingId] !== undefined) {\n            this.invalidateRequest(instance);\n            this.layoutGlyphs(instance);\n          }\n          break;\n\n        case InstanceDiffType.INSERT:\n          this.insert(instance);\n          break;\n\n        case InstanceDiffType.REMOVE:\n          const glyphs = this.labelToGlyphs.get(instance);\n\n          if (glyphs) {\n            for (let i = 0, iMax = glyphs.length; i < iMax; ++i) {\n              this.glyphProvider.remove(glyphs[i]);\n            }\n\n            this.labelToGlyphs.delete(instance);\n            this.labelToKerningRequest.delete(instance);\n            this.labelWaitingOnGlyph.delete(instance);\n          }\n          break;\n      }\n    }\n  }\n\n  /**\n   * Handles first insertion operation for the label\n   */\n  private insert(instance: TInstance) {\n    // Our management flag is dependent on if the label has glyph storage or not\n    if (!instance.preload) {\n      const storage = this.labelToGlyphs.get(instance);\n      if (!storage) this.labelToGlyphs.set(instance, []);\n    }\n\n    // Make sure the instance is removed from the provider for preloads\n    else {\n      this.props.data.remove(instance);\n    }\n\n    // Insertions force a full update of all glyphs for the label\n    this.layoutGlyphs(instance);\n  }\n\n  /**\n   * When the glyph is ready to render this executes.\n   */\n  handleGlyphReady = (glyph: GlyphInstance) => {\n    // The glyph must be associated to have this work\n    if (!glyph.parentLabel) {\n      // If no parent label, we should not have this glyph returningfalse alarms to this method\n      delete glyph.onReady;\n\n      return;\n    }\n\n    // Get the label this glyph is a part of\n    const label = glyph.parentLabel;\n    // Get the list of glyphs the label is waiting on.\n    const waiting = this.labelWaitingOnGlyph.get(glyph.parentLabel);\n\n    if (!waiting) {\n      return;\n    }\n\n    // Clear this glyph from the waiting list\n    if (waiting.has(glyph)) {\n      waiting.delete(glyph);\n\n      if (waiting.size <= 0) {\n        // If the waiting list is empty we can get the label to execute it's ready handler\n        const onReady = label.onReady;\n        // Execute the callback if present\n        if (onReady) onReady(label);\n      }\n    }\n  };\n\n  /**\n   * Unmounts all of the glyphs that make the lable\n   */\n  hideGlyphs(instance: TInstance) {\n    const glyphs = this.labelToGlyphs.get(instance);\n    if (!glyphs) return;\n\n    for (let i = 0, iMax = glyphs.length; i < iMax; ++i) {\n      this.glyphProvider.remove(glyphs[i]);\n    }\n  }\n\n  /**\n   * Tell the system this layer is not providing any rendering IO information for the GPU to render.\n   */\n  initShader() {\n    return null;\n  }\n\n  /**\n   * This invalidates the request for the instance thus requiring a new request to be made\n   * to trigger the layout of the label.\n   */\n  invalidateRequest(instance: TInstance) {\n    this.labelToKerningRequest.delete(instance);\n  }\n\n  /**\n   * This uses calculated kerning information to place the glyph relative to it's left character neighbor.\n   * The first glyph will use metrics of the glyphs drop down amount to determine where the glyph\n   * will be placed.\n   */\n  layoutGlyphs(instance: TInstance) {\n    // Make sure the kerning is ready\n    if (!this.updateKerning(instance)) return;\n    // Instance must be active\n    if (!instance.active) return;\n    // Get the kerning request for the instance\n    const kerningRequest = this.labelToKerningRequest.get(instance);\n    // We must have kerning calculated for the instance to be valid for laying out the glyphs\n    if (!kerningRequest || !kerningRequest.fontMap) return;\n    // See if our request provided the metrics for the text yet\n    const requestMetrics = kerningRequest.metrics;\n    if (!requestMetrics || !requestMetrics.layout) return;\n\n    // Get the layout that will be used for the request\n    const layout = requestMetrics.layout;\n    // Update the glyphs based on the provided layout\n    this.updateGlyphs(instance, layout);\n    // Get the glyphs of the label\n    const glyphs = instance.glyphs;\n    // Store the calculated size of the label\n    instance.size = layout.size;\n    // Update the calculated anchor for the label now that size is determined\n    anchorCalculator[instance.anchor.type](instance.anchor, instance);\n    paddingCalculator[instance.anchor.type](instance.anchor);\n\n    const anchor = instance.anchor;\n    const padding = instance.anchor.paddingDirection;\n\n    // Apply the offsets calculated to each glyph\n    for (\n      let i = 0, iMax = Math.min(layout.positions.length, glyphs.length);\n      i < iMax;\n      ++i\n    ) {\n      const offset = layout.positions[i];\n      const glyph = glyphs[i];\n      glyph.offset = offset;\n      glyph.fontScale = layout.fontScale;\n      glyph.anchor = [anchor.x || 0, anchor.y || 0];\n      glyph.origin = copy2(instance.origin);\n      glyph.padding = padding || [0, 0];\n\n      glyph.maxScale = instance.maxScale;\n    }\n  }\n\n  /**\n   * This layer does not have or use a buffer manager thus it must track management of an instance\n   * in it's own way.\n   */\n  managesInstance(instance: TInstance) {\n    return Boolean(this.labelToGlyphs.get(instance));\n  }\n\n  /**\n   * This makes a label's glyphs visible by adding them to the glyph layer rendering the glyphs.\n   */\n  showGlyphs(instance: TInstance) {\n    const glyphs = this.labelToGlyphs.get(instance);\n    if (!glyphs) return;\n\n    for (let i = 0, iMax = glyphs.length; i < iMax; ++i) {\n      this.glyphProvider.add(glyphs[i]);\n    }\n  }\n\n  /**\n   * Updates the anchor position of the instance when set\n   */\n  updateAnchor(instance: TInstance) {\n    const glyphs = instance.glyphs;\n    if (!glyphs) return;\n\n    anchorCalculator[instance.anchor.type](instance.anchor, instance);\n    paddingCalculator[instance.anchor.type](instance.anchor);\n\n    const anchor = instance.anchor;\n    const padding = instance.anchor.paddingDirection;\n\n    for (let i = 0, iMax = glyphs.length; i < iMax; ++i) {\n      glyphs[i].anchor = [anchor.x || 0, anchor.y || 0];\n      glyphs[i].padding = padding || [0, 0];\n    }\n  }\n\n  /**\n   * This ensures the correct number of glyphs is being provided for the label indicated.\n   */\n  updateGlyphs(instance: TInstance, layout: KernedLayout) {\n    // Get the current glyphs rendering for the label\n    let currentGlyphs = this.labelToGlyphs.get(instance);\n\n    // Make sure we have glyph storage\n    if (!currentGlyphs) {\n      currentGlyphs = [];\n      this.labelToGlyphs.set(instance, currentGlyphs);\n    }\n\n    // Get the current list of glyphs in the waiting queue\n    let waiting = this.labelWaitingOnGlyph.get(instance);\n\n    if (!waiting) {\n      waiting = new Set();\n      this.labelWaitingOnGlyph.set(instance, waiting);\n    }\n\n    // Update the character used by existing glyphs\n    for (\n      let i = 0, iMax = Math.min(currentGlyphs.length, layout.glyphs.length);\n      i < iMax;\n      ++i\n    ) {\n      const glyph = currentGlyphs[i];\n\n      if (glyph.character !== layout.glyphs[i]) {\n        glyph.character = layout.glyphs[i];\n\n        if (\n          !glyph.request ||\n          !glyph.request.fontMap ||\n          !glyph.request.fontMap.glyphMap[glyph.character]\n        ) {\n          waiting.add(glyph);\n        }\n      }\n    }\n\n    // Make any missing glyphs\n    if (currentGlyphs.length < layout.glyphs.length) {\n      let sourceIndex = 0;\n\n      for (\n        let i = currentGlyphs.length, iMax = layout.glyphs.length;\n        i < iMax;\n        ++i, ++sourceIndex\n      ) {\n        const char = layout.glyphs[i];\n        const glyph = new GlyphInstance({\n          character: char,\n          color: instance.color,\n          origin: instance.origin,\n          maxScale: instance.maxScale,\n          onReady: this.handleGlyphReady\n        });\n\n        glyph.parentLabel = instance;\n        currentGlyphs.push(glyph);\n\n        if (instance.active) {\n          this.glyphProvider.add(glyph);\n        }\n\n        waiting.add(glyph);\n      }\n    }\n\n    // Remove excess glyphs\n    else if (currentGlyphs.length > layout.glyphs.length) {\n      for (\n        let i = layout.glyphs.length, iMax = currentGlyphs.length;\n        i < iMax;\n        ++i\n      ) {\n        const glyph = currentGlyphs[i];\n        this.glyphProvider.remove(glyph);\n      }\n\n      // Remove the glyphs from the list the label utilizes\n      while (currentGlyphs.length > layout.glyphs.length) currentGlyphs.pop();\n    }\n\n    // Update the list of glyphs that are utilized for the label's rendering\n    instance.glyphs = currentGlyphs;\n  }\n\n  /**\n   * Updates the glyph colors to match the label's glyph colors\n   */\n  updateGlyphColors(instance: TInstance) {\n    const glyphs = instance.glyphs;\n    if (!glyphs) return;\n\n    for (let i = 0, iMax = glyphs.length; i < iMax; ++i) {\n      glyphs[i].color = copy4(instance.color);\n    }\n  }\n\n  /**\n   * This updates all of the glyphs for the label to have the same position\n   * as the label.\n   */\n  updateGlyphOrigins(instance: TInstance) {\n    const glyphs = instance.glyphs;\n    if (!glyphs) return;\n    const origin = instance.origin;\n\n    for (let i = 0, iMax = glyphs.length; i < iMax; ++i) {\n      glyphs[i].origin = [origin[0], origin[1]];\n    }\n  }\n\n  /**\n   * This updates all of the glyphs for the label to have the same position\n   * as the label.\n   */\n  updateGlyphMaxScales(instance: TInstance) {\n    const glyphs = instance.glyphs;\n    if (!glyphs) return;\n    const maxScale = instance.maxScale;\n\n    for (let i = 0, iMax = glyphs.length; i < iMax; ++i) {\n      glyphs[i].maxScale = maxScale;\n    }\n  }\n\n  /**\n   * Checks the label to ensure calculated kerning supports the text specified.\n   *\n   * Returns true when the kerning information is already available\n   */\n  updateKerning(instance: TInstance) {\n    // A change in glyphs requires a potential kerning request\n    let labelKerningRequest = this.labelToKerningRequest.get(instance);\n    // This is the text the label will be making for the request\n    const checkText = instance.text;\n\n    // If we have the label kerning request, we should check to see if the font map\n    // supports the contents of the label.\n    if (labelKerningRequest) {\n      // If the request already embodies the request for the text, we just see if the\n      // font map has been provided yet to indicate if the kerning information is ready\n      if (\n        labelKerningRequest.kerningPairs &&\n        labelKerningRequest.kerningPairs.indexOf(checkText) > -1\n      ) {\n        return Boolean(labelKerningRequest.fontMap);\n      }\n\n      // If the request exists for a different text, and the font map does not support\n      // the kerning needs of the text, then we must make a new request.\n      if (\n        labelKerningRequest.fontMap &&\n        !labelKerningRequest.fontMap.supportsKerning(\n          checkText.replace(/\\s/g, \"\")\n        )\n      ) {\n        this.labelToKerningRequest.delete(instance);\n        labelKerningRequest = undefined;\n      }\n\n      // Otherwise, nothing needs to happen and we can use the font map for kerning information\n      else {\n        return true;\n      }\n    }\n\n    // If no request is present we must make one\n    if (!labelKerningRequest) {\n      const metrics: IFontResourceRequest[\"metrics\"] = {\n        // We want the request to return all of the metrics for the text as well\n        fontSize: instance.fontSize,\n        text: instance.text,\n        letterSpacing: instance.letterSpacing\n      };\n\n      // Include truncation metrics if the text needs it\n      if (instance.maxWidth > 0) {\n        metrics.maxWidth = instance.maxWidth;\n        metrics.truncation = this.props.truncation || DEFAULT_TRUNCATION;\n      }\n\n      // Make the request for retrieving the kerning information.\n      labelKerningRequest = fontRequest({\n        key: this.props.resourceKey || \"\",\n        character: \"\",\n        kerningPairs: [checkText],\n        metrics\n      });\n\n      // In order for the glyphs to be laid out, we need the font map to get the kerning information.\n      // So we send out a request to the font manager for the resource.\n      // Once the kerning information has been retrieved, the label active property will be triggered\n      // to true.\n      if (!instance.preload) {\n        this.resource.request(this, instance, labelKerningRequest, {\n          resource: {\n            type: ResourceType.FONT,\n            key: this.props.resourceKey || \"\"\n          }\n        });\n\n        this.labelToKerningRequest.set(instance, labelKerningRequest);\n      }\n\n      // For preload labels, simply make the request, but modify the resource trigger to fire off the ready\n      // event for the label\n      else {\n        instance.resourceTrigger = () => {\n          if (instance.onReady) instance.onReady(instance);\n        };\n\n        this.resource.request(this, instance, labelKerningRequest);\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * If our resource changes, we need a full update of all instances.\n   * If our provider changes, we probably want to ensure our property identifiers are correct.\n   */\n  willUpdateProps(newProps: TProps) {\n    if (newProps.data !== this.props.data) {\n      delete this.propertyIds;\n    }\n\n    // Scale mode change changes the shader needs of the underlying glyphs\n    if (newProps.scaleMode !== this.props.scaleMode) {\n      this.rebuildLayer();\n    }\n\n    if (newProps.resourceKey !== this.props.resourceKey) {\n      this.fullUpdate = true;\n    }\n  }\n}\n","import {\n  IInstanceOptions,\n  Instance,\n  observable\n} from \"../../../instance-provider\";\nimport { Vec2, Vec4 } from \"../../../math/vector\";\nimport { IFontResourceRequest } from \"../../../resources\";\nimport { Omit } from \"../../../types\";\nimport { LabelInstance } from \"./label-instance\";\n\nexport type GlyphInstanceOptions = Omit<\n  Partial<GlyphInstance>,\n  \"resourceTrigger\" | keyof Instance | \"parentLabel\" | \"request\"\n> &\n  IInstanceOptions;\n\n/**\n * Instance representing a single glyph being rendered.\n */\nexport class GlyphInstance extends Instance {\n  /** Adjustment to position the glyph relative to an anchor location on an overrarching label */\n  @observable anchor: Vec2 = [0, 0];\n  /** This is the character the glyph will render. */\n  @observable character: string = \"a\";\n  /** The color to tint the glyph */\n  @observable color: Vec4 = [1, 1, 1, 1];\n  /** Z distance of the glyph */\n  @observable depth: number = 0;\n  /**\n   * This is the scale of the glyph compared to the font resource's rendering. If the font resource\n   * is rendered at 32px, then this needs to be 20 / 32 to render the glyph at a font size of 20.\n   */\n  @observable fontScale: number = 1;\n  /** When in BOUND_MAX mode, this controls how much scaling is allowed up to the base font size */\n  @observable maxScale: number = 1;\n  /** The top left location of this glyph's offset from it's origin */\n  @observable offset: Vec2 = [0, 0];\n  /** This is the anchor point of the glyph to which the glyph scales and rotates about and is positioned */\n  @observable origin: Vec2 = [0, 0];\n  /** This is the amount of padding from the origin position to the anchor position */\n  @observable padding: Vec2 = [0, 0];\n\n  /** The label this glyph is associated with (may NOT be associated at all) */\n  parentLabel?: LabelInstance;\n  /** Fires when this instance is ready for rendering */\n  onReady?: (glyph: GlyphInstance) => void;\n  /** This is populated as a result of character updates */\n  request: IFontResourceRequest;\n\n  constructor(options: GlyphInstanceOptions) {\n    super(options);\n\n    this.origin = options.origin || this.origin;\n    this.offset = options.offset || this.offset;\n    this.character = options.character || this.character;\n    this.color = options.color || this.color;\n    this.maxScale = options.maxScale || this.maxScale;\n    this.padding = options.padding || this.padding;\n    this.anchor = options.anchor || this.anchor;\n    this.onReady = options.onReady;\n  }\n\n  /**\n   * Make a duplicate of this glyph\n   */\n  clone() {\n    const glyph = new GlyphInstance(this);\n    glyph.onReady = this.onReady;\n    glyph.request = this.request;\n  }\n\n  /**\n   * This will trigger when the resource nmanager is ready to render this glyph.\n   */\n  resourceTrigger() {\n    this.offset = this.offset;\n    this.origin = this.origin;\n    this.character = this.character;\n    this.color = this.color;\n\n    // Indicate this glyph is getting ready to render to the screen\n    if (this.onReady) this.onReady(this);\n  }\n}\n","import { InstanceProvider } from \"../../../instance-provider\";\nimport { IAutoEasingMethod, Vec, Vec2 } from \"../../../math\";\nimport {\n  fontRequest,\n  FontResourceRequestFetch,\n  IFontResourceRequest\n} from \"../../../resources\";\nimport {\n  createMaterialOptions,\n  IInstanceAttribute,\n  ILayerMaterialOptions,\n  InstanceAttributeSize,\n  IShaderInitialization,\n  VertexAttributeSize\n} from \"../../../types\";\nimport { CommonMaterialOptions } from \"../../../util\";\nimport { ScaleMode } from \"../../types\";\nimport { ILayer2DProps, Layer2D } from \"../../view/layer-2d\";\nimport { GlyphInstance } from \"./glyph-instance\";\n\n/**\n * Options available to this layer as props.\n */\nexport interface IGlyphLayerOptions<T extends GlyphInstance>\n  extends ILayer2DProps<T> {\n  /** Specifies which attributes to animate */\n  animate?: {\n    anchor?: IAutoEasingMethod<Vec>;\n    color?: IAutoEasingMethod<Vec>;\n    offset?: IAutoEasingMethod<Vec>;\n    origin?: IAutoEasingMethod<Vec>;\n  };\n  /** This is the font resource this pulls from in order to render the glyphs */\n  resourceKey?: string;\n  /** This is the scaling strategy the glyph will use when text is involved. */\n  scaleMode?: ScaleMode;\n  /** This indicates whether a glyph is in a textArea */\n  inTextArea?: boolean;\n}\n\n/**\n * Handles rendering single character glyphs using SDF and MSDF techniques\n */\nexport class GlyphLayer<\n  T extends GlyphInstance,\n  U extends IGlyphLayerOptions<T>\n> extends Layer2D<T, U> {\n  /** Set up the default props so our auto complete is a happier place */\n  static defaultProps: IGlyphLayerOptions<GlyphInstance> = {\n    key: \"\",\n    data: new InstanceProvider<GlyphInstance>(),\n    resourceKey: \"No resource specified\"\n  };\n\n  /**\n   * Easy access names of each attribute to make easing controls easier\n   */\n  static attributeNames = {\n    color: \"color\",\n    depth: \"depth\",\n    anchor: \"anchor\",\n    origin: \"origin\",\n    offset: \"offset\"\n  };\n\n  /**\n   * These are all of the requests the glyphs have generated for each character. This let's us\n   * recycle requests for same glyphs.\n   */\n  glyphRequests: { [key: string]: IFontResourceRequest } = {};\n\n  /**\n   * Create the Shader IO needed to tie our instances and the GPU together.\n   */\n  initShader(): IShaderInitialization<T> {\n    const animate = this.props.animate || {};\n    const {\n      anchor: animateAnchor,\n      color: animateColor,\n      offset: animateOffset,\n      origin: animateOrigin\n    } = animate;\n\n    const vertexInfo: { [key: number]: Vec2 } = {\n      0: [0, 0],\n      1: [0, 0],\n      2: [1, 0],\n      3: [0, 1],\n      4: [1, 1],\n      5: [1, 1]\n    };\n\n    const glyphTextureAttr: IInstanceAttribute<T> = {\n      name: \"texture\",\n      resource: {\n        key: () => this.props.resourceKey || \"\",\n        name: \"fontMap\"\n      },\n      update: o => {\n        const char = o.character;\n\n        if (!o.request || o.character !== o.request.character) {\n          if (this.glyphRequests[o.character]) {\n            o.request = this.glyphRequests[o.character];\n          } else {\n            o.request = fontRequest({\n              key: this.props.resourceKey || \"\",\n              character: char\n            });\n\n            this.glyphRequests[o.character] = o.request;\n          }\n\n          // Do a check to see if the request has been resolved. If so, the glyph is ready.\n          if (o.request.fontMap) {\n            if (o.onReady) o.onReady(o);\n          }\n        }\n\n        o.request.fetch = FontResourceRequestFetch.TEXCOORDS;\n        return this.resource.request(this, o, o.request);\n      }\n    };\n\n    /**\n     * We must make this attribute a child attribute as it is based on the exact same property\n     * as another attribute from an instance. This ensures that the change on the instance property\n     * triggers this attribute as well.\n     */\n    const glyphSizeAttr: IInstanceAttribute<T> = {\n      name: \"glyphSize\",\n      parentAttribute: glyphTextureAttr,\n      resource: {\n        key: () => this.props.resourceKey || \"\",\n        name: \"fontMap\"\n      },\n      size: InstanceAttributeSize.TWO,\n      update: o => {\n        const char = o.character;\n\n        if (!o.request || o.character !== o.request.character) {\n          if (this.glyphRequests[o.character]) {\n            o.request = this.glyphRequests[o.character];\n          } else {\n            o.request = fontRequest({\n              key: this.props.resourceKey || \"\",\n              character: char\n            });\n\n            this.glyphRequests[o.character] = o.request;\n          }\n\n          // Do a check to see if the request has been resolved. If so, the glyph is ready.\n          if (o.request.fontMap) {\n            if (o.onReady) o.onReady(o);\n          }\n        }\n\n        o.request.fetch = FontResourceRequestFetch.IMAGE_SIZE;\n        return this.resource.request(this, o, o.request);\n      }\n    };\n\n    glyphTextureAttr.childAttributes = [glyphSizeAttr];\n\n    let fs: string, vs: string;\n    const scaleMode = this.props.scaleMode || ScaleMode.ALWAYS;\n\n    switch (scaleMode) {\n      case ScaleMode.BOUND_MAX: {\n        fs = this.props.inTextArea\n          ? require(\"./text-area-layer-bound-max.fs\")\n          : require(\"./glyph-layer-bound-max.fs\");\n        vs = this.props.inTextArea\n          ? require(\"./text-area-layer-bound-max.vs\")\n          : require(\"./glyph-layer-bound-max.vs\");\n        break;\n      }\n\n      case ScaleMode.NEVER: {\n        fs = this.props.inTextArea\n          ? require(\"./glyph-layer-never.fs\")\n          : require(\"./text-area-layer-never.fs\");\n        vs = this.props.inTextArea\n          ? require(\"./text-area-layer-never.vs\")\n          : require(\"./glyph-layer-never.vs\");\n        break;\n      }\n\n      case ScaleMode.ALWAYS: {\n        fs = this.props.inTextArea\n          ? require(\"./text-area-layer-always.fs\")\n          : require(\"./glyph-layer-always.fs\");\n        vs = this.props.inTextArea\n          ? require(\"./text-area-layer-always.vs\")\n          : require(\"./glyph-layer-always.vs\");\n        break;\n      }\n\n      default: {\n        fs = require(\"./glyph-layer-always.fs\");\n        vs = require(\"./glyph-layer-always.vs\");\n        break;\n      }\n    }\n\n    return {\n      fs,\n      instanceAttributes: [\n        {\n          easing: animateColor,\n          name: GlyphLayer.attributeNames.color,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.color\n        },\n        {\n          name: GlyphLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        {\n          name: \"fontScale\",\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.fontScale]\n        },\n        {\n          easing: animateAnchor,\n          name: GlyphLayer.attributeNames.anchor,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.anchor\n        },\n        {\n          easing: animateOrigin,\n          name: GlyphLayer.attributeNames.origin,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.origin\n        },\n        {\n          easing: animateOffset,\n          name: GlyphLayer.attributeNames.offset,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.offset\n        },\n        {\n          name: \"padding\",\n          size: InstanceAttributeSize.TWO,\n          update: o => o.padding\n        },\n        {\n          name: \"maxScale\",\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.maxScale]\n        },\n        glyphSizeAttr,\n        glyphTextureAttr\n      ],\n      uniforms: [],\n      vertexAttributes: [\n        {\n          name: \"normals\",\n          size: VertexAttributeSize.TWO,\n          update: (vertex: number) =>\n            // Quad vertex side information\n            vertexInfo[vertex]\n        }\n      ],\n      vertexCount: 6,\n      vs\n    };\n  }\n\n  draw() {\n    super.draw();\n  }\n\n  /**\n   * Set up material options for the layer\n   */\n  getMaterialOptions(): ILayerMaterialOptions {\n    return Object.assign(\n      {},\n      CommonMaterialOptions.transparentImageBlending,\n      createMaterialOptions({\n        depthTest: false\n      })\n    );\n  }\n\n  /**\n   * Handle changes that need special handling\n   */\n  willUpdateProps(nextProps: U) {\n    // If the target resource changes, then we must make all of the requests re-process their requests for the new\n    // resource.\n    if (nextProps.resourceKey !== this.props.resourceKey) {\n      Object.values(this.glyphRequests).forEach(req => {\n        delete req.fontMap;\n        req.key = nextProps.resourceKey || \"\";\n      });\n      this.rebuildLayer();\n    }\n  }\n}\n","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec4 texColor = texture2D(fontMap, texCoord);\\nif (texColor.r <= 0.0) discard;\\ntexColor.a = texColor.r;\\ngl_FragColor = texColor * vertexColor;\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec2 pushOut = normals * glyphSize * fontScale;\\nvec3 position = vec3(origin + padding - anchor + offset + pushOut, depth);\\ngl_Position = clipSpace(position);\\ntexCoord = texture.xy + (texture.zw - texture.xy) * normals;\\nvertexColor = color * color.a;\\n}\"","import { observable } from \"../../../instance-provider/observable\";\nimport { Vec1Compat } from \"../../../math\";\nimport { BorderInstance } from \"./border-instance\";\nimport { ILabelInstanceOptions, LabelInstance } from \"./label-instance\";\n\n/**\n * Alignment mode for text within a region.\n */\nexport enum TextAlignment {\n  LEFT,\n  RIGHT,\n  CENTERED\n}\n\n/**\n * WordWrap mode\n * */\nexport enum WordWrap {\n  /**\n   * NONE: New lines ONLY happen when an explicit newline character ('\\n', '\\r', '\\n\\r') occurs.\n   * Lines that exceed the maxWidth will be truncated.\n   */\n  NONE,\n  /**\n   * CHARACTER: Newlines happen on newline characters OR they happen when the row exceeds maxWidth\n   * and some characters stay in this line while the rest continue on the next line.\n   */\n  CHARACTER,\n  /**\n   * WORD: Newlines happen on newline characters OR they happen when the row exceeds maxWidth\n   * and the whole word continues on the next line.\n   */\n  WORD\n}\n\n/** This is used to mark the specialLetter when divide the textArea into several labels */\nexport enum NewLineCharacterMode {\n  /** When the scanner meets a new line sign (\"/n\", \"/r\", \"/n/r\") */\n  NEWLINE\n}\n\nexport type TextAreaLabel = LabelInstance | NewLineCharacterMode;\n\n/**\n * Options for customaizing a TextAreaInstance\n * */\nexport interface ITextAreaInstanceOptions extends ILabelInstanceOptions {\n  /* This sets the alignment of TextArea */\n  alignment?: TextAlignment;\n  /* This sets thickness of border if included */\n  borderWidth?: number;\n  /* This decides whehter the border of textArea is included */\n  hasBorder?: boolean;\n  /* This sets the distance between letters in a word */\n  letterSpacing?: number;\n  /* This sets the distance from line to next line of text */\n  lineHeight?: number;\n  /**\n   * This sets max height the text area can render. Any text beyond this point will not be rendered\n   * This also establishes the borders' height to be rendered if included\n   */\n  maxHeight?: number;\n  /* This sets distance from top, left, right, bottom of border to content of text */\n  padding?: Vec1Compat;\n  /* This decides the way to wrap a word whether this word exceeds maxWidth */\n  wordWrap?: WordWrap;\n}\n\n/**\n * This defines a multi-line area that renders text. This is essentially a label\n * with added properties to handle multi-lining.\n */\nexport class TextAreaInstance extends LabelInstance {\n  /**\n   * Specifies how tall the text area can become. If this is exceeded, the final line\n   * in the text area will end with ellipses.\n   */\n  @observable maxHeight: number = 0;\n\n  /**\n   * This specifies how tall a line should be for each line.\n   */\n  @observable lineHeight: number = 0;\n  /**\n   * This indicates if a single line of text should wrap or not. If not, the first word that goes\n   * out of bounds will be removed and replaced with ellipses. If true, excess words in a single line\n   * will wrap down to the next line to stay within the space allowed.\n   */\n  @observable wordWrap: WordWrap = WordWrap.NONE;\n  /**\n   * This changes how the alignment for the text within the region will appear.\n   */\n  @observable alignment: TextAlignment = TextAlignment.LEFT;\n  /**\n   * When onReady is called, this will be populated with all of the labels used to compose this text area\n   * SpecialLetter will be used when layouting labels, it may indicates a new line\n   */\n  labels: TextAreaLabel[] = [];\n  /** This will be used to hold new labels when a label should be divided into two labels because label is at the end a line */\n  newLabels: LabelInstance[] = [];\n  /** This holds the borders of textArea */\n  borders: BorderInstance[] = [];\n  /** This stores the old origin which is used to calculate the new positions of labels */\n  oldOrigin: [number, number];\n  /** Stores paddings for the text area, [top, right, bottom, left] */\n  @observable padding: Vec1Compat = [0, 0, 0, 0];\n  /** Border width */\n  @observable borderWidth: number = 6;\n  /** Whether the textArea has border */\n  @observable hasBorder: boolean = true;\n  /** Width of space in a textArea */\n  spaceWidth: number = 0;\n\n  constructor(options: ITextAreaInstanceOptions) {\n    super(options);\n\n    this.color = options.color;\n    this.origin = options.origin;\n    this.oldOrigin = options.origin;\n    this.text = options.text;\n    this.fontSize = options.fontSize || this.fontSize;\n    this.maxWidth = options.maxWidth || this.maxWidth;\n    this.maxHeight = options.maxHeight || this.maxHeight;\n    this.lineHeight = options.lineHeight || this.lineHeight;\n    this.wordWrap = options.wordWrap || this.wordWrap;\n    this.alignment = options.alignment || this.alignment;\n    this.padding = options.padding || this.padding;\n    this.borderWidth = options.borderWidth || this.borderWidth;\n    this.hasBorder =\n      options.hasBorder !== undefined ? options.hasBorder : this.hasBorder;\n    this.letterSpacing = options.letterSpacing || this.letterSpacing;\n  }\n}\n","import { observable } from \"../../../instance-provider\";\nimport {\n  IInstanceOptions,\n  Instance\n} from \"../../../instance-provider/instance\";\nimport { Vec2 } from \"../../../math/vector\";\nimport { Anchor, AnchorType, ScaleMode } from \"../../types\";\n\nexport interface IRectangleInstanceOptions extends IInstanceOptions {\n  /**\n   * The point on the rectangle which will be placed in world space via the x, y coords. This is also the point\n   * which the rectangle will be scaled around.\n   */\n  anchor?: Anchor;\n  /** Depth sorting of the rectangle (or the z value of the box) */\n  depth?: number;\n  /** Sets the way the rectangle scales with the world */\n  scaling?: ScaleMode;\n  /** The color the rectangle should render as */\n  color?: [number, number, number, number];\n  /** The coordinate where the rectangle will be anchored to in world space */\n  position?: Vec2;\n  /** The size of the rectangle as it is to be rendered in world space */\n  size?: Vec2;\n}\n\n/**\n * This is a lookup to quickly find the proper calculation for setting the correct anchor\n * position based on the anchor type.\n */\nconst anchorCalculator: {\n  [key: number]: (anchor: Anchor, rectangle: RectangleInstance) => void;\n} = {\n  [AnchorType.TopLeft]: (anchor: Anchor, _rectangle: RectangleInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopMiddle]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.size[0] / 2.0;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopRight]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.size[0] + anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.MiddleLeft]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = rectangle.size[1] / 2;\n  },\n  [AnchorType.Middle]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.size[0] / 2.0;\n    anchor.y = rectangle.size[1] / 2.0;\n  },\n  [AnchorType.MiddleRight]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.size[0] + anchor.padding;\n    anchor.y = rectangle.size[1] / 2.0;\n  },\n  [AnchorType.BottomLeft]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = rectangle.size[1] + anchor.padding;\n  },\n  [AnchorType.BottomMiddle]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.size[0] / 2.0;\n    anchor.y = rectangle.size[1] + anchor.padding;\n  },\n  [AnchorType.BottomRight]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.size[0] + anchor.padding;\n    anchor.y = rectangle.size[1] + anchor.padding;\n  },\n  [AnchorType.Custom]: (anchor: Anchor, _rectangle: RectangleInstance) => {\n    anchor.x = anchor.x || 0;\n    anchor.y = anchor.y || 0;\n  }\n};\n\n/**\n * This generates a new rectangle instance which will render a single line of text for a given layer.\n * There are restrictions surrounding rectangles due to texture sizes and rendering limitations.\n *\n * Currently, we only support rendering a rectangle via canvas, then rendering it to an Atlas texture\n * which is used to render to cards in the world for rendering. This is highly performant, but means:\n *\n * - Rectangles should only be so long.\n * - Multiline is not supported inherently\n * - Once a rectangle is constructed, only SOME properties can be altered thereafter\n *\n * A rectangle that is constructed can only have some properties set upon creating the rectangle and are locked\n * thereafter. The only way to modify them would be to destroy the rectangle, then construct a new rectangle\n * with the modifications. This has to deal with performance regarding rasterizing the rectangle\n */\nexport class RectangleInstance extends Instance {\n  /** This is the rendered color of the rectangle */\n  @observable color: [number, number, number, number] = [0, 0, 0, 1];\n  /** Depth sorting of the rectangle (or the z value of the rectangle) */\n  @observable depth: number = 0;\n  /** When in BOUND_MAX mode, this allows the rectangle to scale up beyond it's max size */\n  @observable maxScale: number = 1;\n  /** Scales the rectangle uniformly */\n  @observable scale: number = 1;\n  /** Sets the way the rectangle scales with the world */\n  @observable scaling: ScaleMode = ScaleMode.BOUND_MAX;\n  /** The size of the rectangle as it is to be rendered in world space */\n  @observable size: Vec2 = [1, 1];\n  /** The coordinate where the rectangle will be anchored to in world space */\n  @observable position: Vec2 = [0, 0];\n\n  // These are properties that can be altered, but have side effects from being changed\n\n  /** This is the anchor location on the  */\n  @observable\n  private _anchor: Anchor = {\n    padding: 0,\n    type: AnchorType.TopLeft,\n    x: 0,\n    y: 0\n  };\n\n  constructor(options: IRectangleInstanceOptions) {\n    super(options);\n\n    this.depth = options.depth || this.depth;\n    this.color = options.color || this.color;\n    this.scaling = options.scaling || this.scaling;\n    this.position = options.position || this.position;\n    this.size = options.size || this.size;\n\n    // Make sure the anchor is set to the appropriate location\n    options.anchor && this.setAnchor(options.anchor);\n  }\n\n  get anchor() {\n    return this._anchor;\n  }\n\n  /**\n   * This applies a new anchor to this rectangle and properly determines it's anchor position on the rectangle\n   */\n  setAnchor(anchor: Anchor) {\n    const newAnchor = {\n      padding: anchor.padding || 0,\n      type: anchor.type,\n      x: anchor.x || 0,\n      y: anchor.y || 0\n    };\n\n    // Calculate the new anchors position values\n    anchorCalculator[newAnchor.type](newAnchor, this);\n    // Apply the anchor\n    this._anchor = newAnchor;\n  }\n}\n","import { Bounds } from \"../../math/primitives/bounds\";\nimport { IViewProps, View } from \"../../surface\";\nimport { LayerScene } from \"../../surface/layer-scene\";\nimport { Camera, CameraProjectionType, isPerspective } from \"../../util/camera\";\nimport { Projection3D } from \"./projection-3d\";\n\n/**\n * Defines the input metrics of a view for a scene.\n */\nexport interface IView3DProps extends IViewProps {\n  preventCameraAdjustment?: boolean;\n}\n\n/**\n * Type guard to ensure the camera type is orthographic\n */\nfunction isOrthographic(val: Camera): val is Camera {\n  return val.projectionType === CameraProjectionType.ORTHOGRAPHIC;\n}\n\n/**\n * A View renders a perspective of a scene to a given surface or surfaces. The\n * 3D view system assumes a y-axis up system. The view also assumes the camera\n * is located in the middle of the viewport.\n */\nexport class View3D<TViewProps extends IView3DProps> extends View<TViewProps> {\n  static defaultProps: IView3DProps = {\n    key: \"\",\n    camera: new Camera({\n      type: CameraProjectionType.PERSPECTIVE,\n      width: 100,\n      height: 100,\n      fov: Math.PI / 2,\n      far: 100000,\n      near: 1\n    }),\n    viewport: {\n      left: 0,\n      right: 0,\n      bottom: 0,\n      top: 0\n    }\n  };\n\n  projection: Projection3D;\n\n  constructor(scene: LayerScene, options: TViewProps) {\n    super(scene, options);\n    this.projection = new Projection3D();\n    this.projection.camera = options.camera;\n    this.projection.pixelRatio = this.pixelRatio;\n  }\n\n  /**\n   * This operation makes sure we have the view camera adjusted to the new\n   * viewport's needs.\n   */\n  fitViewtoViewport(\n    _surfaceDimensions: Bounds<never>,\n    viewBounds: Bounds<View<IViewProps>>\n  ) {\n    if (isPerspective(this.props.camera)) {\n      const width = viewBounds.width;\n      const height = viewBounds.height;\n      const camera = this.props.camera;\n\n      const viewport = {\n        near: camera.projectionOptions.near,\n        far: camera.projectionOptions.far,\n        width,\n        height\n      };\n\n      if (!this.props.preventCameraAdjustment) {\n        camera.projectionOptions = Object.assign(\n          camera.projectionOptions,\n          viewport\n        );\n\n        camera.update();\n      }\n\n      this.projection.pixelRatio = this.pixelRatio;\n      this.projection.viewBounds = viewBounds;\n      this.projection.viewBounds.d = this;\n      this.projection.screenBounds = new Bounds<View<TViewProps>>({\n        height: this.projection.viewBounds.height / this.pixelRatio,\n        width: this.projection.viewBounds.width / this.pixelRatio,\n        x: this.projection.viewBounds.x / this.pixelRatio,\n        y: this.projection.viewBounds.y / this.pixelRatio\n      });\n      this.projection.screenBounds.d = this;\n    } else if (isOrthographic(this.props.camera)) {\n      const width = viewBounds.width;\n      const height = viewBounds.height;\n      const camera = this.props.camera;\n\n      const viewport = {\n        near: camera.projectionOptions.near,\n        far: camera.projectionOptions.far,\n        left: -width / 2,\n        right: width / 2,\n        top: height / 2,\n        bottom: -height / 2\n      };\n\n      if (!this.props.preventCameraAdjustment) {\n        camera.projectionOptions = Object.assign(\n          camera.projectionOptions,\n          viewport\n        );\n\n        camera.update();\n      }\n\n      this.projection.pixelRatio = this.pixelRatio;\n      this.projection.viewBounds = viewBounds;\n      this.projection.viewBounds.d = this;\n      this.projection.screenBounds = new Bounds<View<TViewProps>>({\n        height: this.projection.viewBounds.height / this.pixelRatio,\n        width: this.projection.viewBounds.width / this.pixelRatio,\n        x: this.projection.viewBounds.x / this.pixelRatio,\n        y: this.projection.viewBounds.y / this.pixelRatio\n      });\n      this.projection.screenBounds.d = this;\n    }\n  }\n\n  willUpdateProps(newProps: IView3DProps) {\n    this.projection.camera = newProps.camera;\n  }\n}\n","import {\n  Mat4x4,\n  multiply4x4,\n  project3As4ToScreen,\n  ray,\n  Ray,\n  rayFromPoints,\n  transform4\n} from \"../../math\";\nimport { BaseProjection } from \"../../math/base-projection\";\nimport {\n  apply2,\n  apply3,\n  scale2,\n  subtract2,\n  Vec2,\n  Vec3,\n  vec3,\n  vec4\n} from \"../../math/vector\";\nimport { Camera, CameraProjectionType } from \"../../util/camera\";\n\nexport class Projection3D extends BaseProjection<any> {\n  /** Camera used for the 3d view. */\n  camera: Camera;\n\n  /**\n   * Maps a coordinate relative to the screen to the pixel's location within the 3D world. Remember that a camera with\n   * a view creates a frustum to work within the 3D world. This frustum has a near clipping plane and a far clipping\n   * plane.\n   *\n   * This method provides a point located in front of the camera that would be located on a ray eminating from the\n   * camera to the world. See screenRay\n   *\n   * For a perspective camera:\n   * - To make a ray from this point simply:\n   *\n   * `const ray = rayFromPoints(camera.position, screenToWorld([x, y]))`\n   *\n   * For an orthographic camera:\n   * - To make a ray from this point:\n   *\n   * `const ray = ray(screenToWorld([x, y]), camera.forward)`\n   */\n  screenToWorld(point: Vec2, out?: Vec3): Vec3 {\n    out = out || [0, 0, 0];\n    // Make sure the point is relative to the view then use the view to world projection\n    this.viewToWorld(this.screenToView(point), out);\n\n    return out;\n  }\n\n  /**\n   * Generates a ray from screen coordinates that emanates out into the 3D world\n   * space.\n   */\n  screenRay(point: Vec2): Ray {\n    if (this.camera.projectionType === CameraProjectionType.ORTHOGRAPHIC) {\n      const world: Vec3 = vec3(this.screenToWorld(point));\n\n      return ray(world, this.camera.transform.forward);\n    } else {\n      const world: Vec3 = vec3(this.screenToWorld(point));\n\n      return rayFromPoints(vec3(this.camera.transform.position), world);\n    }\n  }\n\n  /**\n   * Maps a coordinate found within the world to a relative coordinate within the screen space.\n   */\n  worldToScreen(point: Vec3, out?: Vec2) {\n    out = out || [0, 0];\n\n    const viewProjection: Mat4x4 = multiply4x4(\n      this.camera.projection,\n      this.camera.view\n    );\n\n    const screen = project3As4ToScreen(\n      viewProjection,\n      point,\n      this.viewBounds.width,\n      this.viewBounds.height\n    );\n\n    return apply2(\n      out,\n      screen[0] / this.pixelRatio,\n      screen[1] / this.pixelRatio\n    );\n  }\n\n  /**\n   * Maps a coordinate relative to the view to the pixel's location within the\n   * 3D world. Remember that a camera with a view creates a frustum to work\n   * within the 3D world. This frustum has a near clipping plane and a far\n   * clipping plane.\n   *\n   * This method provides a point located in front of the camera that would be\n   * located on a ray eminating from the camera to the world in such a way, that\n   * the ray traveling to infinity would appear, from the screen's perspective,\n   * to stay on the same pixel.\n   *\n   * See screenRay\n   *\n   * For a perspective camera:\n   * - To make a ray from this point simply:\n   *\n   * `const ray = rayFromPoints(camera.position, screenToWorld([x, y]))`\n   *\n   * For an orthographic camera:\n   * - To make a ray from this point:\n   *\n   * `const ray = ray(screenToWorld([x, y]), camera.forward)`\n   */\n  viewToWorld(point: Vec2, out?: Vec3) {\n    out = out || [0, 0, 0];\n    const { width, height } = this.viewBounds;\n    const { projectionOptions } = this.camera;\n    const renderSpace = scale2(point, this.pixelRatio);\n    const { tan } = Math;\n\n    // We here analyze the point specified and calculate a ray that would\n    // project out into the world such that it eminates where the ray would\n    // appear as a dot flying away from the screen.\n    if (projectionOptions.type === CameraProjectionType.PERSPECTIVE) {\n      const { fov, near } = projectionOptions;\n      let Px, Py;\n\n      const aspect = height / width;\n      const r = tan(fov / 2) * near;\n\n      // We assume z = 1 and algebraically reverse the projection operation to\n      // solve for the vector input instead of the screen.\n      Px = (2 * ((renderSpace[0] + 0.5) / width) - 1) * r;\n      Py = (1 - 2 * ((renderSpace[1] + 0.5) / height)) * r * aspect;\n\n      const rayReference: Vec3 = [Px, Py, -1];\n      const world = transform4(\n        this.camera.transform.matrix,\n        vec4(rayReference, 1)\n      );\n      apply3(out, world[0], world[1], world[2]);\n    } else {\n      const middleToPoint = subtract2(renderSpace, [width / 2, height / 2]);\n      const world = transform4(\n        this.camera.transform.viewMatrix,\n        vec4(middleToPoint, -projectionOptions.near)\n      );\n      apply3(out, world[0], -world[1], world[2]);\n    }\n\n    return out;\n  }\n\n  /**\n   * Maps a coordinate found within the world to a relative coordinate within\n   * the view's viewport.\n   */\n  worldToView(point: Vec3, out?: Vec2) {\n    out = out || [0, 0];\n\n    const viewProjection: Mat4x4 = multiply4x4(\n      this.camera.projection,\n      this.camera.view\n    );\n\n    const screen = project3As4ToScreen(\n      viewProjection,\n      point,\n      this.viewBounds.width,\n      this.viewBounds.height\n    );\n\n    return apply2(\n      out,\n      screen[0] / this.pixelRatio,\n      screen[1] / this.pixelRatio\n    );\n  }\n}\n","import \"./parent-transform.shader\";\nexport * from \"./transform-base\";\nexport * from \"./transform\";\nexport * from \"./scene-graph-layer\";\nexport * from \"./tree-node\";\nexport * from \"./instance-3d\";\nexport * from \"./transform-2d\";\n","import { Instance } from \"../../instance-provider\";\nimport { Mat4x4 } from \"../../math/matrix\";\nimport { ILayerProps, Layer } from \"../../surface\";\nimport { IShaderInitialization } from \"../../types\";\n\nexport interface ISceneGraphLayerProps<TInstance extends Instance>\n  extends ILayerProps<TInstance> {\n  /**\n   * If this is sepcified, this will be the parent transform this layer\n   * renders it's objects relative to.\n   */\n  parent?: { matrix: Mat4x4 };\n}\n\n/**\n * If you wish to support a scene graph in a more optimal fashion where\n * Transforms are parented by other Transforms, then your rendering layers\n * should probably extend this layer.\n *\n * This layer will automatically split your defined Layer into numerous child\n * layers, such that each layer will render with a specific parent Transform set\n * into the child's uniforms.\n *\n * This way, each child can render based on local properties instead of using\n * the heavier world properties.\n */\nexport class SceneGraphLayer<\n  TInstance extends Instance,\n  TProps extends ISceneGraphLayerProps<TInstance>\n> extends Layer<TInstance, TProps> {\n  /**\n   * Ensure the shaders utilizing this framework has easy access to the\n   * parentTransform property.\n   */\n  baseShaderModules(shaderIO: IShaderInitialization<TInstance>) {\n    const baseModules = super.baseShaderModules(shaderIO);\n    baseModules.vs.push(\"parent-transform\");\n\n    return baseModules;\n  }\n}\n","import {\n  IInstanceOptions,\n  Instance,\n  observable\n} from \"../../instance-provider\";\nimport { Mat4x4, Quaternion, Vec3 } from \"../../math\";\nimport { Transform } from \"./transform\";\n\nexport interface IInstance3DOptions extends IInstanceOptions {\n  /** The transform object that will manage this instance */\n  transform?: Transform;\n  /** A parent Instance or Transform to this instance */\n  parent?: Transform | Instance3D;\n}\n\n/**\n * Basic properties of an instance that exists within a 3D world.\n */\nexport class Instance3D extends Instance {\n  /** Flag indicates local space properties are retrieved from this instance */\n  needsLocalUpdate: boolean = false;\n  /** Flag indicates world space properties are retrieved from this instance */\n  needsWorldUpdate: boolean = false;\n\n  /**\n   * This is the 3D transform that will place this object within the 3D world.\n   */\n  get transform() {\n    return this._transform;\n  }\n  set transform(val: Transform) {\n    if (!this._transform) {\n      this._position = val.position;\n      this._rotation = val.rotation;\n      this._scale = val.scale;\n      this._localPosition = val.localPosition;\n      this._localRotation = val.localRotation;\n      this._localScale = val.localScale;\n      this._matrix = val.matrix;\n      this._localMatrix = val.localMatrix;\n    }\n\n    val.instance = this;\n    this._transform = val;\n  }\n  private _transform: Transform;\n\n  /**\n   * Matrix representing the transform needed to put this instance into world\n   * space. Should never edit this directly. Use the transform property or the\n   * orientation properties to mutate this transform.\n   */\n  get matrix(): Mat4x4 {\n    this._transform.update();\n    return this._matrix;\n  }\n  @observable private _matrix: Mat4x4;\n\n  /**\n   * Matrix used to represent the transform this object places on itself.\n   * Anything using this matrix as it's basis\n   */\n  get localMatrix(): Mat4x4 {\n    this._transform.update();\n    return this._localMatrix;\n  }\n  @observable private _localMatrix: Mat4x4;\n\n  /** Local position of the Instance */\n  get localPosition() {\n    this.needsLocalUpdate = true;\n    return this._localPosition;\n  }\n  set localPosition(val: Vec3) {\n    this.transform.localPosition = val;\n  }\n  @observable private _localPosition: Vec3;\n\n  /** Local space rotation of the Instance */\n  get localRotation() {\n    this.needsLocalUpdate = true;\n    return this._localRotation;\n  }\n  set localRotation(val: Quaternion) {\n    this.transform.localRotation = val;\n  }\n  @observable private _localRotation: Quaternion;\n\n  /** Local axis scale of the instance */\n  get localScale() {\n    this.needsLocalUpdate = true;\n    return this._localScale;\n  }\n  set localScale(val: Vec3) {\n    this.transform.localScale = val;\n  }\n  @observable private _localScale: Vec3;\n\n  /** World position of the Instance */\n  get position() {\n    this.needsWorldUpdate = true;\n    this.transform.update();\n    return this._position;\n  }\n  set position(val: Vec3) {\n    this.transform.position = val;\n  }\n  @observable private _position: Vec3;\n\n  /** World space rotation of the Instance */\n  get rotation() {\n    this.needsWorldUpdate = true;\n    this.transform.update();\n    return this._rotation;\n  }\n  set rotation(val: Quaternion) {\n    this.transform.rotation = val;\n  }\n  @observable private _rotation: Quaternion;\n\n  /** Axis scale of the instance */\n  get scale() {\n    this.needsWorldUpdate = true;\n    this.transform.update();\n    return this._scale;\n  }\n  set scale(val: Vec3) {\n    this.transform.scale = val;\n  }\n  @observable private _scale: Vec3;\n\n  /**\n   * Quick way to work with parent transforms. This is just syntactic sugar so\n   * you don't have to instance.transform.parent all the time.\n   */\n  set parent(val: Instance3D) {\n    this.transform.parent = val.transform;\n  }\n\n  constructor(options: IInstance3DOptions) {\n    super(options);\n    const transform = options.transform || new Transform();\n    this.transform = transform;\n\n    if (options.parent) {\n      if (options.parent instanceof Instance3D) {\n        this.parent = options.parent;\n      } else {\n        this.transform.parent = options.parent;\n      }\n    }\n  }\n\n  /**\n   * This is an ambiguous but simple method that attempts to re-optimize this\n   * instance. If you have maybe a one time analysis of an instance over the\n   * course of a lengthy period of time, consider calling this.\n   *\n   * Instances and transforms take the approach of \"shifting gears\" toward world\n   * decomposition after world orientations are queried. However, you may not\n   * always need or rarely need a specific world orientation. Thus calling this\n   * method will make the instance and transform assume it no longer needs world\n   * orientations once again until something queries for it.\n   */\n  optimize() {\n    this.needsWorldUpdate = false;\n    this.needsLocalUpdate = false;\n    this.transform.optimize();\n  }\n}\n","import { BaseProjection, Ray, Vec2 } from \"../../math\";\n\nexport class ProjectionScreen extends BaseProjection<any> {\n  /**\n   * Maps a coordinate relative to the screen to a coordinate found within the world space.\n   */\n  screenToWorld(point: Vec2, out?: Vec2) {\n    const view = this.screenToView(point);\n\n    const world = out || [0, 0];\n    world[0] = view[0];\n    world[1] = view[1];\n\n    return world;\n  }\n\n  /**\n   * Makes a ray from the provided point that emanates into 3D space straight\n   * into the screen. Since our spaces have 3D tendencies, this can have some\n   * useful applications for interacting with the 2D elements in interesting and\n   * new ways.\n   */\n  screenRay(point: Vec2): Ray {\n    const world = this.screenToWorld(point);\n\n    return [\n      [world[0], world[1], 0],\n      [world[0], world[1], -1]\n    ];\n  }\n\n  /**\n   * Maps a coordinate found within the world to a relative coordinate within the screen space.\n   */\n  worldToScreen(point: Vec2, out?: Vec2) {\n    const screen: Vec2 = [0, 0];\n\n    // Calculate from the camera to view space\n    screen[0] = point[0];\n    screen[1] = point[1];\n\n    // Convert from view to screen space\n    return this.viewToScreen(screen, out);\n  }\n\n  /**\n   * Maps a coordinate relative to the view's viewport to a coordinate found within the world.\n   */\n  viewToWorld(point: Vec2, out?: Vec2) {\n    const world = out || [0, 0];\n\n    const screen = point;\n    world[0] = screen[0];\n    world[1] = screen[1];\n\n    return world;\n  }\n\n  /**\n   * Maps a coordinate found within the world to a relative coordinate within the view's viewport.\n   */\n  worldToView(point: Vec2, out?: Vec2) {\n    const screen = out || [0, 0];\n\n    // Calculate from the camera to view space\n    screen[0] = point[0];\n    screen[1] = point[1];\n\n    return screen;\n  }\n}\n","import { IColorBufferResource } from \"../../../resources/color-buffer\";\nimport { IRenderTextureResource } from \"../../../resources/texture/render-texture\";\nimport { UniformSize } from \"../../../types\";\nimport { postProcess } from \"../../post-process\";\n\nexport interface IGaussHorizontalBlur {\n  /** Specifies the resource taken in that will be blurred for the output */\n  input: IRenderTextureResource;\n  /** Specifies an output resource key to send the results to */\n  output?: Record<number, IRenderTextureResource | IColorBufferResource>;\n  /** For debugging only. Prints generated shader to the console. */\n  printShader?: boolean;\n}\n\n/**\n * Performs a gaussian horizontal blur on a resource and outputs to a specified\n * resource.\n */\nexport function gaussHorizontalBlur(options: IGaussHorizontalBlur) {\n  const { output, input } = options;\n\n  return postProcess({\n    printShader: options.printShader,\n    view: output ? { output: { buffers: output, depth: false } } : void 0,\n    buffers: { color: input },\n    shader: require(\"./gauss-horizontal-blur.fs\"),\n    uniforms: [\n      {\n        name: \"weight\",\n        size: UniformSize.FLOAT_ARRAY,\n        update: () => [\n          0.299478,\n          0.22598,\n          0.097046,\n          0.023687,\n          0.003279,\n          0.000257,\n          0.000011\n        ]\n      }\n    ]\n  });\n}\n","import { IColorBufferResource } from \"../../../resources/color-buffer\";\nimport { IRenderTextureResource } from \"../../../resources/texture/render-texture\";\nimport { UniformSize } from \"../../../types\";\nimport { postProcess } from \"../../post-process\";\n\nexport interface IGaussVerticalBlur {\n  /** Specifies the resource taken in that will be blurred for the output */\n  input: IRenderTextureResource;\n  /** Specifies an output resource key to send the results to */\n  output?: Record<number, IRenderTextureResource | IColorBufferResource>;\n  /** For debugging only. Prints generated shader to the console. */\n  printShader?: boolean;\n}\n\n/**\n * Performs a gaussian vertical blur on a resource and outputs to a specified\n * resource.\n */\nexport function gaussVerticalBlur(options: IGaussVerticalBlur) {\n  const { output, input } = options;\n\n  return postProcess({\n    printShader: options.printShader,\n    view: output ? { output: { buffers: output, depth: false } } : void 0,\n    buffers: { color: input },\n    shader: require(\"./gauss-vertical-blur.fs\"),\n    uniforms: [\n      {\n        name: \"weight\",\n        size: UniformSize.FLOAT_ARRAY,\n        update: () => [\n          0.299478,\n          0.22598,\n          0.097046,\n          0.023687,\n          0.003279,\n          0.000257,\n          0.000011\n        ]\n      }\n    ]\n  });\n}\n","import { IView2DProps } from \"../../../2d\";\nimport { GLSettings } from \"../../../gl/gl-settings\";\nimport { IRenderTextureResource } from \"../../../resources/texture/render-texture\";\nimport { FragmentOutputType, ILayerMaterialOptions } from \"../../../types\";\nimport { postProcess } from \"../../post-process\";\nimport { boxSample, BoxSampleDirection } from \"../box-sample/box-sample\";\n\nexport interface IBloom {\n  /**\n   * Number of downsamples used for the bloom effect. This MUST be at least 1\n   * for any effect to take place.\n   */\n  samples: number;\n  /**\n   * Specify resources in this order for the effect to work:\n   * [\n   *   glow colors,\n   *   half of glow resource (RGB),\n   *   quarter of glow (RGB),\n   *   eigth of glow (RGB),\n   *   ...,\n   *   # of steps\n   * ]\n   * This bloom effect down samples then up samples the results, thus the need\n   * for all of the resource specifications.\n   */\n  resources: IRenderTextureResource[];\n  /**\n   * Specifies the output image the bloom effect will be composed with. If this\n   * is not specified, this will not do a final composition and just leave the\n   * result of the glow filter portion within the top level resource key\n   * provided.\n   */\n  compose?: IRenderTextureResource;\n  /**\n   * This specifies an alternative output to target with the results. If not\n   * specified the output will render to the screen.\n   */\n  output?: IRenderTextureResource;\n  /** For debugging only. Prints generated shader to the console. */\n  printShader?: boolean;\n  /** Options to send to the view */\n  view?: Partial<IView2DProps>;\n  /**\n   * Allows you to control material options such as blend modes of the post\n   * process effect.\n   */\n  material?: ILayerMaterialOptions;\n}\n\n/**\n * Performs a gaussian horizontal blur on a resource and outputs to a specified\n * resource.\n */\nexport function bloom(options: IBloom) {\n  const { compose, output, resources } = options;\n\n  const addBlend = {\n    blending: {\n      blendDst: GLSettings.Material.BlendingDstFactor.One,\n      blendSrc: GLSettings.Material.BlendingSrcFactor.One,\n      blendEquation: GLSettings.Material.BlendingEquations.Add\n    }\n  };\n\n  const process: Record<string, any> = {};\n\n  // Generate down samples\n  for (let i = 0, iMax = options.samples; i < iMax; ++i) {\n    const sample = boxSample({\n      printShader: options.printShader,\n      input: resources[i],\n      output: resources[i + 1],\n      direction: BoxSampleDirection.DOWN,\n      material: {\n        blending: void 0\n      }\n    });\n\n    process[`downSample${i}`] = sample;\n  }\n\n  // Generate up samples\n  for (let i = options.samples - 1; i > 0; --i) {\n    const sample = boxSample({\n      printShader: options.printShader,\n      input: resources[i + 1],\n      output: resources[i],\n      direction: BoxSampleDirection.UP,\n      material: addBlend\n    });\n\n    process[`upSample${i}`] = sample;\n  }\n\n  // Generate the composition process\n  if (compose) {\n    process.compose = postProcess({\n      printShader: options.printShader,\n      // Set the buffers we want to composite\n      buffers: {\n        color: compose,\n        glow: resources[1]\n      },\n      // Turn off blending\n      material: {\n        blending: null\n      },\n      // Render to the screen, or to a potentially specified target\n      view: output\n        ? {\n            output: {\n              buffers: { [FragmentOutputType.COLOR]: output },\n              depth: false\n            }\n          }\n        : void 0,\n      // Utilize our composition shader\n      shader: require(\"./bloom.fs\")\n    });\n  }\n\n  return process;\n}\n","import { IView2DProps } from \"../../../2d\";\nimport { IRenderTextureResource } from \"../../../resources/texture/render-texture\";\nimport { ILayerMaterialOptions } from \"../../../types\";\nimport { postProcess } from \"../../post-process\";\n\nconst debug = require(\"debug\")(\"performance\");\n\nexport interface IDrawOptions {\n  /**\n   * Specifies the resource taken in that will be blurred for the output.\n   *\n   * NOTE: Probably should disable mipmaps if you aren't seeing an output.\n   */\n  input: IRenderTextureResource;\n  /** Specifies an output resource key to send the results to */\n  output?: IRenderTextureResource;\n  /** For debugging only. Prints generated shader to the console. */\n  printShader?: boolean;\n  /** Options to send to the view */\n  view?: Partial<IView2DProps>;\n  /**\n   * Allows you to control material options such as blend modes of the post\n   * process effect.\n   */\n  material?: ILayerMaterialOptions;\n  /** If specified, will only draw a single channel from the target */\n  channel?: \"r\" | \"g\" | \"b\" | \"a\";\n  /**\n   * If channel AND this are set, the channel selected will be rendered in gray\n   * scale\n   */\n  grayScale?: boolean;\n}\n\n/**\n * Simply renders in the input target resource to the screen as a full screen\n * quad.\n */\nexport function draw(options: IDrawOptions) {\n  const { output, input, channel, grayScale } = options;\n\n  if (!input.textureSettings || input.textureSettings.generateMipMaps) {\n    debug(\n      \"POSSIBLE ERROR: for the draw post effect,\",\n      \"it is a common mistale to leave mipmaps enabled on the input texture.\",\n      \"Often the mipmaps are not available in the target resource and thus\",\n      \"you will get a blank output when rendering in certain scenarios.\"\n    );\n  }\n\n  return postProcess({\n    printShader: options.printShader,\n    view: Object.assign(\n      output ? { output: { buffers: output, depth: false } } : {},\n      options.view\n    ),\n    buffers: { color: input },\n    shader:\n      grayScale && channel\n        ? `\n      varying vec2 texCoord;\n\n      void main() {\n        gl_FragColor = vec4(texture2D(color, texCoord).${channel}${channel}${channel}, 1.);\n      }\n    `\n        : channel\n        ? `\n      varying vec2 texCoord;\n\n      void main() {\n        gl_FragColor = vec4(texture2D(color, texCoord).${channel}, 0., 0., 1.);\n      }\n    `\n        : `\n      varying vec2 texCoord;\n\n      void main() {\n        gl_FragColor = texture2D(color, texCoord);\n      }\n    `,\n    material: options.material\n  });\n}\n","import \"./util/webgl2-type-shim\";\n\nexport * from \"./event-management\";\nexport * from \"./2d\";\nexport * from \"./3d\";\nexport * from \"./instance-provider\";\nexport * from \"./surface\";\nexport * from \"./types\";\nexport * from \"./util\";\nexport * from \"./shaders\";\nexport * from \"./resources\";\nexport * from \"./gl\";\nexport * from \"./base-surfaces\";\nexport * from \"./util-layers\";\nexport * from \"./math\";\nexport * from \"./processing\";\n","/**\n * This provides a WebGL2RenderingContext class object for the system to check instanceof so\n * type checking for WebGL2RenderingContext does not break the system\n * when the target device does not have any notion of WebGL2 within it's environment.\n *\n * This does not attempt to mimic ANY behavior, it merely makes:\n *\n * foo instanceof WebGL2RenderingContext\n *\n * return false instead of break and error the system.\n */\n(window as any).WebGL2RenderingContext =\n  (window as any).WebGL2RenderingContext ||\n  function WebGL2RenderingContext() {\n    /** Do nothing */\n  };\n","export * from \"./event-manager\";\nexport * from \"./simple-event-handler\";\nexport * from \"./types\";\nexport * from \"./user-input-event-manager\";\nexport * from \"./queued-event-handler\";\n","import { Vec2 } from \"../math/vector\";\nimport { IViewProps, View } from \"../surface/view\";\n\nexport enum MouseButton {\n  /** No button detected */\n  NONE = -1,\n  /** Mouse click left */\n  LEFT = 0,\n  /** Usually mouse wheel click */\n  AUX = 1,\n  /** Mosue right click */\n  RIGHT = 2,\n  /** Usually side left mouse button (will cause 'browser back' in some cases) */\n  FOURTH = 3,\n  /** Usually side right mouse button (will cause 'browser forward' in some cases) */\n  FIFTH = 4\n}\n\nexport interface IEventInteraction {\n  /**\n   * This is the root canvas element the events are related to. This allows us\n   * to have some additional information and unsafe controls over our context we\n   * are working with.\n   */\n  canvas?: HTMLCanvasElement;\n  /** Metrics of the interaction in screen space */\n  screen: {\n    position: Vec2;\n  };\n  /**\n   * The View the event was 'down' on. The position stored is the screen\n   * position relative to the view.\n   */\n  start: {\n    /** Position the event started relative to the view */\n    position: Vec2;\n    /** The immediate view beneath the event when the event started */\n    view: View<IViewProps>;\n    /** All of the views beneath the event when the event started */\n    views: {\n      /** The position of the event where it started relative to the view */\n      position: Vec2;\n      /**\n       * A view beneath the start position of the event, but possibly not the\n       * immediate view\n       */\n      view: View<IViewProps>;\n    }[];\n  };\n  /**\n   * The View Immediately underneath the event. The position stored is the\n   * screen position relative to the view.\n   */\n  target: {\n    /** The position of the event relative to the target */\n    position: Vec2;\n    /** The view imeediately beneath the event */\n    view: View<IViewProps>;\n    /**\n     * All views beneath the event (views that may be overlapping within the\n     * area)\n     */\n    views: {\n      /** The position of the event relative to the view indicated */\n      position: Vec2;\n      /** One of the view's beneath the event currently. */\n      view: View<IViewProps>;\n    }[];\n  };\n}\n\n/**\n * This represents an interaction with the Layer Surface. It provides mouse metrics with how the mouse\n * interacts with the views below it.\n */\nexport interface IMouseInteraction extends IEventInteraction {\n  /** The metrics associated with the mouse during this interaction */\n  mouse: IMouseMetrics;\n}\n\nexport interface IWheelMetrics {\n  delta: [number, number];\n}\n\n/**\n * This is metrics measured between two touches\n */\nexport interface ITouchRelation {\n  /** The direction to the other touch */\n  direction: Vec2;\n  /** The current distance to the other touch */\n  distance: number;\n  /** The id of the other touch */\n  id: number;\n}\n\n/**\n * This is the information of a touch for a given frame.\n */\nexport interface ITouchFrame {\n  /** This is the location or delta location of the touch for this frame */\n  location: Vec2;\n  /** This is the direction from the start touch frame */\n  direction: Vec2;\n  /** This is the metrics or delta metrics of the touch relative to the other touches for the frame */\n  relations: Map<number, ITouchRelation>;\n}\n\nexport interface IInteractionMetrics {\n  /** The current position of the touch on the screen */\n  currentPosition: Vec2;\n  /** The change in position the touch has experienced from last event to this event */\n  deltaPosition: Vec2;\n  /** The location of the touch from it's previous event */\n  previousPosition: Vec2;\n  /** The time stamp this touch began */\n  startTime: number;\n  /** The position this touch started */\n  start: Vec2;\n  /** The beginning view of the touch */\n  startView: View<IViewProps> | undefined;\n}\n\n/**\n * Metrics calculated and stored for the mouse\n */\nexport interface IMouseMetrics extends IInteractionMetrics {\n  /** The mouse button pressed */\n  button: MouseButton;\n  /** Flag for storing whether a mouse event is still eligible to register a click event */\n  canClick: boolean;\n  /** The latest event object associated with this mouse event */\n  event: MouseEvent;\n  /** Information derived for the wheel */\n  wheel: IWheelMetrics;\n}\n\n/**\n * Metrics calculated and stored per touch\n */\nexport interface ITouchMetrics extends IInteractionMetrics {\n  /** Flag storing whether a touch is still eligible to register a tap event */\n  canTap: boolean;\n  /**\n   * The start position of the touch relative to other touches. When a new touch is down, all of the other touches\n   * register their current position as a new starting position relative to when that touch was down.\n   */\n  startRelative: Map<ITouchMetrics, Vec2>;\n  /** The base touch object making this metric */\n  touch: Touch;\n}\n\n/**\n * Metrics calculated for multitouch information\n */\nexport interface IMultiTouchMetrics {\n  /**\n   * The average distance increase/decrease all touches are from the center present from spreading or pinching gesture\n   * from previous event to this event.\n   */\n  averageSpreadDelta: number;\n  /**\n   * The change in the central point as all fingers migrate from one location to another from previous event to\n   * this event.\n   */\n  centerDelta: Vec2;\n  /** The central point between all current touches for the current event */\n  currentCenter: Vec2;\n  /** Stores the current rotation the touches have on average exhibited around the central point */\n  currentRotation: number;\n  /**\n   * The change in rotation of the touches around the central point as the touches move from previous event to\n   * this event.\n   */\n  rotationDelta: number;\n  /** The central point between all current touches when all of the touches began */\n  startCenter: Vec2;\n  /** All of the touch metrics that makes this multitouch information */\n  touches: ITouchMetrics[];\n}\n\n/**\n * Metrics calculated for all touches to be broadcasted to the event managers\n */\nexport interface ITouchInteraction {\n  /** Contains ALL of the touch interactions with the screen that currently exists */\n  allTouches: ISingleTouchInteraction[];\n  /**\n   * Stores multitouch interaction information. All multitouch information is query based\n   */\n  multitouch: IMultiTouchInteraction;\n  /** Contains all of the touch interactions with the screen for the given event */\n  touches: ISingleTouchInteraction[];\n}\n\n/**\n * Metrics calculated for a single touch on the screen\n */\nexport interface ISingleTouchInteraction extends IEventInteraction {\n  /** The source touch metrics for the touch */\n  touch: ITouchMetrics;\n}\n\n/**\n * This is multitouch information. This stores multitouch metrics between every touch and every permutation of every\n * touch. This means if you have four touches on the screen, you can query multitouch information between any of the\n * touches.\n */\nexport interface IMultiTouchInteraction {\n  /**\n   * Produces an identifier for the set of touches that will always be the same identifier for the same touches.\n   */\n  id(touches: ISingleTouchInteraction[]): string;\n  /**\n   * The average distance all touches are from the center for the current event.\n   */\n  spread(touches: ISingleTouchInteraction[]): number;\n  /**\n   * The average distance increase/decrease all touches are from the center present from spreading or pinching gesture.\n   */\n  spreadDelta(touches: ISingleTouchInteraction[]): number;\n  /**\n   * The average distance all touches are from the center when the touches first became present on the context.\n   */\n  spreadStart(touches: ISingleTouchInteraction[]): number;\n  /** This is the calculated center of all the touches queried */\n  center(touches: ISingleTouchInteraction[]): Vec2;\n  /** This is the position change of the center of the touches */\n  centerDelta(touches: ISingleTouchInteraction[]): Vec2;\n  /** Gets the starting center point of the touches */\n  centerStart(touches: ISingleTouchInteraction[]): Vec2;\n  /** Gets the current rotation orientation of the touches around their center point */\n  rotation(touches: ISingleTouchInteraction[]): number;\n  /** This is the change in rotation of the touches around their perceived center. */\n  rotationDelta(touches: ISingleTouchInteraction[]): number;\n  /** Gets the starting touch rotation orientation */\n  rotationStart(touches: ISingleTouchInteraction[]): number;\n}\n","import { GLProxy } from \"./gl-proxy\";\n\n/**\n * Defines an attribute applied to a geometry object. This keeps track of a buffer associated\n * with the attribute to bind to attributes within the shader program.\n */\nexport class Attribute {\n  /**\n   * The data buffer that is applied to the GPU. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData\n   */\n  data: Float32Array;\n  /**\n   * Anything specific to gl state is stored here for this object.\n   * Modifying anything in here outside of the framework probably will\n   * break everything.\n   */\n  gl?: {\n    /** Stores the buffer id for the attribute */\n    bufferId: WebGLBuffer;\n    /** Stores the buffer type (typically gl.ARRAY_BUFFER) */\n    type: number;\n    /** Stores the locations of each attribute discovered for each program identified */\n    locations?: Map<WebGLProgram, number>;\n    /** Proxy communication with the GL context */\n    proxy: GLProxy;\n  };\n  /**\n   * The optimization state for frequently changing buffers. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData\n   */\n  get isDynamic() {\n    return this._isDynamic;\n  }\n  private _isDynamic: boolean;\n  /**\n   * Indicates the data in this attribute is structured per instance rather than per vertex.\n   */\n  get isInstanced() {\n    return this._isInstanced;\n  }\n  private _isInstanced: boolean = false;\n  /** Indicates a full update of the buffer will happen. This is managed internally to determine when needed */\n  get fullUpdate() {\n    return this._fullUpdate;\n  }\n  private _fullUpdate: boolean = false;\n  /** Indicates if the data should be normalized when provided to the shader. */\n  normalize: boolean = false;\n  /** This flags the attribute as needing to commit updates to it's buffer */\n  get needsUpdate() {\n    return this._needsUpdate;\n  }\n  private _needsUpdate: boolean;\n  /**\n   * The packing size of the vertex attribute (how many floats per attribute). See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enableVertexAttribArray\n   */\n  size: number;\n  /**\n   * Defines a range to update for the buffer object. Getting the range object is a copy of the object.\n   * Setting the updateRange triggers an update.\n   *\n   * Although these properties represent vertex indicies it directly ties to all implications of:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferSubData\n   */\n  get updateRange() {\n    return this._updateRange;\n  }\n  set updateRange(val: Attribute[\"_updateRange\"]) {\n    this._updateRange = val;\n    this._needsUpdate = true;\n  }\n  private _updateRange = {\n    /** Number of vertices to update */\n    count: -1,\n    /** Offset to the first vertex to begin updating */\n    offset: -1\n  };\n\n  /**\n   * The data provided is the array that holds all of the information that should be pushed to\n   * the GPU. The size defines how large the vertex attribute is defined in the shader.\n   */\n  constructor(\n    data: Float32Array,\n    size: number,\n    isDynamic: boolean = false,\n    isInstanced: boolean = false\n  ) {\n    this.data = data;\n    this.size = size;\n    this._isDynamic = isDynamic;\n    this._isInstanced = isInstanced;\n  }\n\n  /**\n   * Destroys this resource and frees resources it consumes on the GPU.\n   */\n  destroy() {\n    if (this.gl) {\n      this.gl.proxy.disposeAttribute(this);\n    }\n  }\n\n  /**\n   * Flags this attribute as completely resolved in it's needs for updates\n   */\n  resolve() {\n    this._needsUpdate = false;\n    this._fullUpdate = false;\n  }\n\n  /**\n   * Flags the buffer as dynamic. This is a performance optimization that some GPUs can use for\n   * buffers that change their contents frequently. Toggling this\n   */\n  setDynamic(isDynmaic: boolean) {\n    this._isDynamic = isDynmaic;\n    this._needsUpdate = true;\n    this._fullUpdate = true;\n  }\n}\n","import { Attribute } from \"./attribute\";\nimport { GLProxy } from \"./gl-proxy\";\n\n/**\n * This represents a buffer of data that is expressed as attributes to be placed\n * within a scene. This is generally paired with a Material in a Model to\n * indicate the configuration for how the buffer should be rendered.\n */\nexport class Geometry {\n  /** The attributes bound to this geometry.  */\n  private _attributes: { [key: string]: Attribute } = {};\n  get attributes() {\n    return new Map(Object.entries(this._attributes));\n  }\n  /** This contains any gl specific state associated with this object */\n  gl?: {\n    /**\n     * Potentially generated VAO for the attributes beneath this geometry. If\n     * available this can greatly speed up set up and rendering for each draw\n     * call. Hardware must support it for WebGL 2 or via extension.\n     */\n    vao?: WebGLVertexArrayObject;\n    /** Proxy communication with the GL context */\n    proxy: GLProxy;\n  };\n  /** Number of instances this geometry covers */\n  maxInstancedCount: number = 0;\n  /**\n   * If all attributes added are instanced or not instanced, then this geometry\n   * is not instanced\n   */\n  isInstanced: boolean = false;\n\n  /**\n   * Adds an attribute to this geometry. This will associate the attribute's\n   * buffer to an attribute with the same name used within the shader program.\n   */\n  addAttribute(name: string, attribute: Attribute) {\n    this._attributes[name] = attribute;\n    this.isInstanced = false;\n    let didChange: number | undefined;\n\n    // Check to see if the attributes are uniform or not in instancing\n    Object.values(this._attributes).forEach(attr => {\n      const check = attr.isInstanced ? 1 : 0;\n      // Initialize the check value if it has not been yet\n      if (didChange === undefined) didChange = check;\n      // If a change occurs then we have dynamic and instanced attributes,\n      // which means this geometry is instanced drawing\n      if ((didChange ^ check) === 1) this.isInstanced = true;\n    });\n  }\n\n  /**\n   * Removes any attributes associated with the specified identifying name.\n   */\n  removeAttribute(name: string) {\n    delete this._attributes[name];\n  }\n\n  /**\n   * Destroys this resource and frees resources it consumes on the GPU.\n   */\n  destroy() {\n    this.attributes.forEach(attribute => attribute.destroy());\n\n    if (this.gl) {\n      this.gl.proxy.disposeGeometry(this);\n    }\n  }\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","import { MapValueType, Omit, OutputFragmentShader, TypeVec } from \"../types\";\nimport { GLProxy } from \"./gl-proxy\";\nimport { GLSettings } from \"./gl-settings\";\nimport { RenderTarget } from \"./render-target\";\nimport { IMaterialUniform, MaterialUniformType } from \"./types\";\n\nexport type MaterialOptions = Omit<\n  Partial<Material>,\n  \"clone\" | \"dispose\" | \"gl\"\n>;\n\n/**\n * For materials, we narrow the definition of a fragment shader mapping. It\n * specifically maps RenderTargets (provided from the view) to the output\n * fragment shader. This helps decouple our GL layer from the deltav constructs.\n */\nexport type MaterialFragmentShader = Map<\n  RenderTarget | null,\n  MapValueType<OutputFragmentShader>\n>;\n\n/**\n * This represents a Shader configuration and a state for the configuration to\n * be applied when a model is rendered.\n */\nexport class Material {\n  /** This is the computed blend mode state. Set to null to deactivate */\n  blending: {\n    blendDst: GLSettings.Material.BlendingDstFactor;\n    blendEquation: GLSettings.Material.BlendingEquations;\n    blendSrc: GLSettings.Material.BlendingSrcFactor;\n  } | null = {\n    blendDst: GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha,\n    blendEquation: GLSettings.Material.BlendingEquations.Add,\n    blendSrc: GLSettings.Material.BlendingSrcFactor.SrcAlpha\n  };\n  /**\n   * The write mask to the color buffer. Each channel can be toggled on or off\n   * as the color buffer is written to. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/colorMask\n   */\n  colorWrite: TypeVec<boolean> = [true, true, true, true];\n  /** Sets the cull mode of GL for the polygons */\n  culling: GLSettings.Material.CullSide = GLSettings.Material.CullSide.CCW;\n  /** The comparator used to classify when a fragment will be rendered vs\n   * discarded when tested against the depth buffer */\n  depthFunc: GLSettings.Material.DepthFunctions =\n    GLSettings.Material.DepthFunctions.LESS_OR_EQUAL;\n  /**\n   * Enable / disable depth test (determines if the fragment depth is compared\n   * to the depth buffer before writing). See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enable\n   */\n  depthTest: boolean = true;\n  /**\n   * Enable / disable depth mask (determines if fragments write to the depth\n   * buffer). See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/depthMask\n   */\n  depthWrite: boolean = true;\n  /**\n   * Sets whether or not GL should use it's dithering routine. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enable\n   */\n  dithering: boolean = true;\n  /**\n   * The fragment shader in raw text format that will be compiled to run as the\n   * program to use when this material is used.\n   *\n   * This is more complex than just a simple raw text format. Fragment shaders\n   * can output to multiple targets or be divided into multiple fragments for\n   * the sake of outputting to multiple targets.\n   *\n   * Thus, each fragment is asociated with one or more outputTypes to indicate\n   * the type of information the fragments can offer. This works in conjunction\n   * with RenderTargets who have expected information types to be written to\n   * them.\n   *\n   * The system will examine the current render target (which can be a custom\n   * target OR can be the SCREEN) and look at these fragment shader style\n   * outputs and determine which shader is most efficient and appropriate for\n   * rendering to the current RenderTarget.\n   */\n  fragmentShader: MaterialFragmentShader;\n  /**\n   * Stores any gl state associated with this object. Modifying this outside the\n   * framework is almost guaranteed to break something.\n   */\n  gl?: {\n    fsId: { id: WebGLShader; outputTypes: number[] }[];\n    vsId: WebGLShader;\n    /**\n     * We create a program PER vertex + fragment shader combo. Thus a program is\n     * tied to output capabilities just as much as a fragment shader.\n     */\n    programId: { id: WebGLProgram; outputTypes: number[] }[];\n    /**\n     * This is a lookup reference for finding a program that best matches a\n     * render target. This is a weak reference so it will only help speed up\n     * lookups but won't require any additional clean up.\n     */\n    programByTarget: WeakMap<RenderTarget, WebGLProgram>;\n    /**\n     * Easy lookup to find the output types of a given program. Used to help\n     * quickly determine our drawBuffers to utilize for MRT.\n     */\n    outputsByProgram: WeakMap<WebGLProgram, number[]>;\n    /**\n     * Reference to the glProxy so this object can properly call the correct\n     * context to manage this resource.\n     */\n    proxy: GLProxy;\n  };\n  /**\n   * A name for the material. Helps with identifying the material and aids in\n   * debugging\n   */\n  name: string = \"\";\n  /**\n   * TODO: This is NOT IN USE YET\n   *\n   * GL Polygon offset settings. When set, enables polygon offset modes within\n   * the gl state. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enable\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/polygonOffset\n   */\n  polygonOffset?: {\n    polygonOffsetFactor?: number;\n    polygonOffsetUnits?: number;\n  };\n\n  /** Uniforms that will be synced with the GPU when this material is used */\n  uniforms: { [key: string]: IMaterialUniform<MaterialUniformType> } = {};\n  /**\n   * The vertex shader that will be compiled to run as the program to use when\n   * this material is used.\n   */\n  vertexShader: string = \"\";\n\n  constructor(options: MaterialOptions) {\n    // Take in the properties\n    Object.assign(this, options);\n    // Ensure the gl property did not get copied in if using the copy\n    // constructor new Material(Material)\n    delete this.gl;\n  }\n\n  /**\n   * Makes a duplicate material with identical settings as this material. It\n   * provides the benefit of being able to adjust uniform values for the new\n   * material while sharing the same programs and shaders.\n   */\n  clone() {\n    // Make a new copy material container and copy over the properties (shallow\n    // copy)\n    const copy = new Material(this);\n    // Now we deeper copy any sub objects\n    copy.blending = Object.assign({}, this.blending);\n    copy.polygonOffset = Object.assign({}, this.polygonOffset);\n    // And last we need a deep copy of uniforms, such that we get new uniform\n    // objects\n    copy.uniforms = Object.assign({}, this.uniforms);\n\n    // Deeper copy objects We DO NOT copy the data object as it is expected to\n    // be able to share data buffers between uniforms.\n    for (const name in copy.uniforms) {\n      const uniform: IMaterialUniform<MaterialUniformType> =\n        copy.uniforms[name];\n\n      // Make sure the gl references are the same but their own object\n      if (uniform.gl) {\n        const newLocations = new Map();\n        uniform.gl.forEach((location, program) => {\n          newLocations.set(program, Object.assign({}, location));\n        });\n      }\n    }\n\n    return copy;\n  }\n\n  /**\n   * This frees up all GL resources utilized by this material.\n   */\n  dispose() {\n    if (this.gl) {\n      this.gl.proxy.disposeMaterial(this);\n    }\n  }\n}\n","import { Vec2 } from \"../math\";\nimport { Geometry } from \"./geometry\";\nimport { GLSettings } from \"./gl-settings\";\nimport { Material } from \"./material\";\n\n/**\n * This represents a Geometry with a Material as a paired configuration to be rendered\n * within a scene.\n */\nexport class Model {\n  /** Specifies how the system will utilize the geometry applied */\n  drawMode: GLSettings.Model.DrawMode = GLSettings.Model.DrawMode.TRIANGLES;\n  /** Specifies the vertices to render within the Model */\n  vertexDrawRange?: Vec2 = [-1, -1];\n  /** This specifies how many instances to draw of this model */\n  drawInstances: number = -1;\n  /** The vertex information of the Model */\n  geometry: Geometry;\n  /** The material associated with the model */\n  material: Material;\n  /** Specifies the number of vertices available to the underlying geometry */\n  vertexCount: number = 0;\n\n  constructor(geometry: Geometry, material: Material) {\n    this.geometry = geometry;\n    this.material = material;\n  }\n}\n","import { Instance } from \"./instance\";\n\n/**\n * This is an instance that is basically an instance stub that won't throw any implementation\n * errors when used, but will effectively do nothing.\n */\nexport class BasicInstance extends Instance {\n  resourceTrigger() {\n    // NO -OP\n  }\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport { ILayerProps, Layer } from \"../../surface/layer\";\nimport { InstanceIOValue, IResourceContext, TextureSize } from \"../../types\";\nimport { BaseResourceManager } from \"../base-resource-manager\";\nimport {\n  ColorBufferResource,\n  IColorBufferResource\n} from \"./color-buffer-resource\";\nimport { IColorBufferResourceRequest } from \"./color-buffer-resource-request\";\n\n/**\n * This manager handles creation and destruction of simple Texture Resources.\n * Render Textures are more used on a higher level with the Surface\n * configuration, so we don't need robust memeory handling for it.\n */\nexport class ColorBufferResourceManager extends BaseResourceManager<\n  IColorBufferResource,\n  IColorBufferResourceRequest\n> {\n  /** These are the generated resources this manager collects and monitors */\n  resources = new Map<string, ColorBufferResource>();\n\n  /**\n   * This manager does not need to dequeue requests as all requests will be\n   * immediately resolved with no asynchronous requirements.\n   */\n  async dequeueRequests() {\n    // Do nothing. We do not need to trigger a dequeue update as requests will\n    // be able to be processed immediately from this manager.\n    return false;\n  }\n\n  /**\n   * This frees up resources when the system indictates this manager is no\n   * longer needed.\n   */\n  destroy() {\n    this.resources.forEach(r => r.destroy());\n    this.resources.clear();\n  }\n\n  /**\n   * This resource has no special IO expansion as it can not be used within a\n   * shader's context. It can only be an output target.\n   */\n  getIOExpansion() {\n    return [];\n  }\n\n  /**\n   * This retrieves the generated resources this manager tracks.\n   */\n  getResource(resourceKey: string) {\n    return this.resources.get(resourceKey) || null;\n  }\n\n  /**\n   * The system will inform this manager when a resource is no longer needed and\n   * should be disposed.\n   */\n  destroyResource(options: IColorBufferResource) {\n    const resource = this.resources.get(options.key);\n    if (!resource) return;\n    resource.destroy();\n    this.resources.delete(options.key);\n  }\n\n  /**\n   * The system will inform this manager when a resource should be built.\n   */\n  async initResource(options: IColorBufferResource) {\n    let resource = this.resources.get(options.key);\n\n    if (resource) {\n      console.warn(\n        \"Attempted to generate a RenderTexture that already exists for key\",\n        options.key\n      );\n      return;\n    }\n\n    resource = new ColorBufferResource(options, this.webGLRenderer);\n    this.resources.set(options.key, resource);\n  }\n\n  /**\n   * Handle requests that stream in from instances requesting metrics for a\n   * specific resource.\n   */\n  request<U extends Instance, V extends ILayerProps<U>>(\n    _layer: Layer<U, V>,\n    _instance: Instance,\n    resourceRequest: IColorBufferResourceRequest,\n    _context?: IResourceContext\n  ): InstanceIOValue {\n    const resource = this.resources.get(resourceRequest.key);\n    if (!resource) return [0, 0, 0, 0];\n    resourceRequest.colorBuffer = resource.colorBuffer;\n\n    return [0, 0, 1, 1];\n  }\n\n  /**\n   * Trigger that executes when the rendering context resizes. For this manager,\n   * we will update all textures with dimensions that are tied to the screen.\n   */\n  resize() {\n    const toUpdate = new Map<string, ColorBufferResource>();\n\n    this.resources.forEach((resource, key) => {\n      // Only do a resize of a texture if any of it's dimensions are tied to the\n      // screen.\n      if (\n        resource.width > TextureSize.SCREEN &&\n        resource.height > TextureSize.SCREEN\n      ) {\n        return;\n      }\n\n      // Remove the old texture\n      resource.colorBuffer.destroy();\n      // Regenerate the resource with the new dimensions\n      resource = new ColorBufferResource(resource, this.webGLRenderer);\n      toUpdate.set(key, resource);\n    });\n\n    toUpdate.forEach((resource, key) => this.resources.set(key, resource));\n  }\n\n  /**\n   * This targets the specified resource and attempts to update it's settings.\n   */\n  updateResource(options: IColorBufferResource) {\n    const resource = this.resources.get(options.key);\n    if (!resource) return;\n    console.warn(\"UPDATING AN EXISTING COLOR BUFFER IS NOT SUPPORTED YET\");\n  }\n}\n","import { ColorBuffer } from \"../../gl/color-buffer\";\nimport { Omit, ResourceType } from \"../../types\";\nimport { BaseResourceRequest } from \"../base-resource-manager\";\n\n/**\n * Base information an RenderTexture resource can provide.\n */\nexport interface IColorBufferResourceRequest extends BaseResourceRequest {\n  /**\n   * This is the key of the resource to be used for the request. Resources are\n   * defined in the pipeline.\n   */\n  key: string;\n  /**\n   * Once loaded into the texture, this will be populated revealing the\n   * informaion needed to sample the image from the RenderTexture.\n   */\n  colorBuffer?: ColorBuffer;\n  /** Set the type of this resource for categorization by resource managers */\n  type: ResourceType.COLOR_BUFFER;\n}\n\n/**\n * Simple wrapper to make autocomplete easier for making an RenderTexture\n * request.\n */\nexport function colorBufferRequest(\n  options: Omit<Partial<IColorBufferResourceRequest>, \"type\"> &\n    Pick<IColorBufferResourceRequest, \"key\">\n): IColorBufferResourceRequest {\n  return {\n    type: ResourceType.COLOR_BUFFER,\n    ...options\n  };\n}\n","import { WebGLStat } from \"../../gl\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport { ILayerProps, Layer } from \"../../surface/layer\";\nimport { BaseIOExpansion } from \"../../surface/layer-processing/base-io-expansion\";\nimport {\n  FragmentOutputType,\n  IInstanceAttribute,\n  IInstancingUniform,\n  IShaderInitialization,\n  isString,\n  IUniformInternal,\n  IVertexAttributeInternal,\n  MapValueType,\n  OutputFragmentShader,\n  OutputFragmentShaderSource,\n  OutputFragmentShaderTarget,\n  ShaderInjectionTarget\n} from \"../../types\";\nimport { removeComments } from \"../../util/remove-comments\";\nimport { shaderTemplate } from \"../../util/shader-templating\";\nimport { templateVars } from \"../template-vars\";\nimport { BaseIOSorting } from \"./base-io-sorting\";\nimport {\n  ShaderDeclarationStatementLookup,\n  ShaderDeclarationStatements,\n  ShaderIOHeaderInjectionResult\n} from \"./base-shader-io-injection\";\nimport { BaseShaderTransform } from \"./base-shader-transform\";\nimport { injectShaderIO } from \"./inject-shader-io\";\nimport { MetricsProcessing } from \"./metrics-processing\";\nimport { ShaderModule } from \"./shader-module\";\nimport { ShaderModuleUnit } from \"./shader-module-unit\";\n\n/**\n * This is the expected results from processing the shader and it's layer's attributes.\n */\nexport interface IShaderProcessingResults<T extends Instance> {\n  /** The resulting fragment shaders from processing the module */\n  fs: OutputFragmentShader;\n  /** Any additional system uniforms that arose from the processing */\n  materialUniforms: IInstancingUniform[];\n  /** Calculated max instances per buffer (mostly for uniform packing procedures) */\n  maxInstancesPerBuffer: number;\n  /** The modules that were included within the module processing */\n  modules: ShaderModuleUnit[];\n  /** The resulting vertex shader from processing the module */\n  vs: string;\n  /** All instance attributes that arise from module processing */\n  instanceAttributes: IInstanceAttribute<T>[];\n  /** All vertex attributes that arise from module processing */\n  vertexAttributes: IVertexAttributeInternal[];\n  /** All uniform attributes that arise from module processing */\n  uniforms: IUniformInternal[];\n}\n\n/** Expected results from processing shader imports */\nexport type ProcessShaderImportResults = {\n  fs: OutputFragmentShader;\n  vs: string;\n  shaderModuleUnits: Set<ShaderModuleUnit>;\n} | null;\n\n/**\n * This is the expected token to be found within the shader content to indicate\n * a fragment output.\n */\nconst OUT_TOKEN: string = \"out\";\n/**\n * Seperator token between an out token and the variable name it's supposed to\n * become.\n */\nconst OUT_DELIMITER: string = \":\";\n\n/**\n * The intent of this processor is to analyze a layer's Shader IO elements and produce a functional\n * shader from those elements. This includes supporting a layer's capabilties with the client systems\n * capabilities and matching compatibilities.\n *\n * This inlcudes:\n *\n * Injecting needed module imports based on the layers specifications\n * Resolving Module imports and handling errors\n * Utilizing layer information to create attributes and uniforms based on attribute packing strategies\n * Destructuring attributes based on easing requirements or if attributes were packed\n * Swapping out miscellaneous template variables\n */\nexport class ShaderProcessor {\n  /** Processor that calculates shared metrics across all processors */\n  metricsProcessing: MetricsProcessing = new MetricsProcessing();\n\n  /**\n   * This takes in multiple fragment shaders and merges them together based on\n   * their main() methods. All elements outside of the main() method will be\n   * merged as header information in the order they are discovered.\n   *\n   * All contents of the main's will be merged together as well in the order\n   * they are discovered.\n   *\n   * Additionally, this discovers outputs declared in the shader in the form of\n   * ${out: <name>} tokens. These will be used to aid in making a shader that\n   * will be compatible with ES 3.0 AND 2.0 shaders.\n   */\n  static mergeFragmentOutputsForMRT(\n    _declarationsVS: ShaderDeclarationStatements,\n    declarationsFS: ShaderDeclarationStatements,\n    layerOutputs: { source: string; outputType: number }[],\n    viewOutputs: number[],\n    typeFilter?: number[],\n    singleOutput?: boolean\n  ) {\n    let headers = \"\";\n    let bodies = \"\";\n    let fragmentOutput = \"\";\n    const outputNames = new Set<string>();\n    const outputTypes: number[] = [];\n    const usedTypes = new Set<number>();\n\n    // When MRT isn't enabled at all, then our fragment output simply writes\n    // directly to gl_FragColor (Our ES 3.0 converter will properly handle\n    // gl_FragColor later)\n    if (!WebGLStat.MRT) {\n      fragmentOutput = \" = gl_FragColor\";\n    }\n\n    layerOutputs.forEach((layerOutput, i) => {\n      // If output is not allowed, then the found output in the shader will\n      // simply map to a locally scoped variable instead of a specialized output\n      // variable.\n      let allowOutput = true;\n      // We can only have one token per each shader. Declaring multiple ${out}\n      // tokens will be considered an error and unsupported.\n      let foundOutputToken = false;\n\n      if (typeFilter && typeFilter.indexOf(layerOutput.outputType) < 0) {\n        allowOutput = false;\n      }\n\n      if (singleOutput && i < layerOutputs.length - 1) {\n        allowOutput = false;\n      }\n\n      if (!singleOutput && viewOutputs.indexOf(layerOutput.outputType) < 0) {\n        allowOutput = false;\n      }\n\n      if (usedTypes.has(layerOutput.outputType)) {\n        throw new Error(\n          \"Can not use the same Output Fragment type multiple times\"\n        );\n      }\n\n      usedTypes.add(layerOutput.outputType);\n\n      // The view is going to only have a single render target to render against\n      // so we will only output against that given render target which will have\n      // a specific layout\n      // [COLOR_ATTACHMENT0, COLOR_ATTACHMENT1, ..., COLOR_ATTACHMENTN]\n      // And this will be in alignment with 'viewOutputs' so we need to make the\n      // layout target according to this.\n      const layoutOutputIndex = viewOutputs.indexOf(layerOutput.outputType);\n\n      shaderTemplate({\n        shader: removeComments(layerOutput.source),\n\n        /**\n         * Analyze each token for \"out\" tokens indicating output\n         */\n        onToken(token) {\n          const trimmedToken = token.trim();\n\n          if (trimmedToken.indexOf(OUT_TOKEN) === 0) {\n            if (foundOutputToken) {\n              console.error(\n                \"Found multiple ${out} tokens in a single fragment shader. This is not supported nor logical\",\n                \"If you need to use the declared output multiple times, use the assigned name\",\n                \"and don't wrap it repeatedly in the shader.\",\n                \"eg-\",\n                \"void main() {\",\n                \"  ${out: myOutput} = value;\",\n                \"  vec4 somethingElse = myOutput;\",\n                \"}\"\n              );\n              throw new Error(\"Invalid Shader Format\");\n            }\n\n            // Flag the token as discovered so we can make sure we don't have\n            // too many tokens show up.\n            foundOutputToken = true;\n            // Analyze the remainder of the token to find the necessary colon to\n            // be the NEXT Non-whitespace character\n            const afterToken = trimmedToken.substr(OUT_TOKEN.length).trim();\n\n            // Make sure the character IS a colon\n            if (afterToken[0] === OUT_DELIMITER) {\n              // At this point, ANYTHING after the colon is the output property\n              // being requested (with white space trimmed). If the name isn't\n              // valid, that's not our fault.\n              const outputName = afterToken.substr(OUT_DELIMITER.length).trim();\n\n              if (!outputName) {\n                throw new Error(\n                  \"Output in a shader requires an identifier ${out: <name required>}\"\n                );\n              }\n\n              if (outputNames.has(outputName)) {\n                throw new Error(\n                  \"You can not declare the same output name in subsequent fragment shader outputs\"\n                );\n              }\n\n              if (outputName === \"gl_FragColor\") {\n                throw new Error(\n                  \"DO not use gl_FragColor as an identifier for an out. Choose something not used by the WebGL spec.\"\n                );\n              }\n\n              // Check our type filter. If the current outputType of the shader\n              // is NOT in the filter, then we have to exclude the name from the\n              // output names AND we have to ensure the name specified has a\n              // declaration as it will never be declared in the header.\n              let declare = \"\";\n              if (allowOutput) {\n                // We now have the output name this output will utilize\n                outputNames.add(outputName);\n                outputTypes.push(layerOutput.outputType);\n\n                // Handle the special case of the MRT extension where we output\n                // to the special case of gl_FragData\n                if (WebGLStat.MRT_EXTENSION) {\n                  fragmentOutput = ` = gl_FragData[${layoutOutputIndex}]`;\n                  declare = \"vec4 \";\n                }\n\n                // Handle the MRT extension case where we have to create an\n                // 'out' declaration for the decalred output name.\n                else if (WebGLStat.MRT && WebGLStat.SHADERS_3_0) {\n                  declarationsFS.set(\n                    outputName,\n                    `layout(location = ${layoutOutputIndex}) out vec4 ${outputName};\\n`\n                  );\n                } else {\n                  throw new Error(\n                    `Could not generate a proper output declaration for the fragment shader output: ${outputName}`\n                  );\n                }\n              } else {\n                declare = \"vec4 \";\n              }\n\n              // Replace the token with just the name of the variable being\n              // declared with the proper type sizing.\n              return `${declare}${outputName}${fragmentOutput}`;\n            } else {\n              throw new Error(\n                \"Output in a shader requires an identifier ${out: <name required>}\"\n              );\n            }\n          }\n\n          // Leave unprocessed tokens alone\n          return `$\\{${token}}`;\n        },\n\n        /**\n         * We use this to aggregate all of our main bodies and headers together\n         */\n        onMain(body, header) {\n          // In the event no output token was discovered, we look for\n          // gl_FragColor from our es 1.0 style shaders. If that is present,\n          // that is the output and it is mapped to FragmentOutputType.COLOR\n          if (!foundOutputToken && body) {\n            const findFragColor = body.match(\"gl_FragColor\");\n\n            if (findFragColor) {\n              outputTypes.push(layerOutput.outputType);\n\n              if (WebGLStat.MRT) {\n                if (WebGLStat.SHADERS_3_0) {\n                  declarationsFS.set(\n                    \"_FragColor\",\n                    `layout(location = ${layoutOutputIndex}) out vec4 _FragColor;\\n`\n                  );\n\n                  body = body.replace(/gl_FragColor/g, `_FragColor`);\n                } else {\n                  // Do first replacement with declaration\n                  body = body.replace(\n                    /gl_FragColor\\s+=/,\n                    `vec4 _FragColor = gl_FragData[${layoutOutputIndex}] =`\n                  );\n\n                  // Do subsequent replacements without declaration\n                  body = body.replace(\n                    /gl_FragColor\\s+=/g,\n                    `_FragColor = gl_FragData[${layoutOutputIndex}] =`\n                  );\n\n                  // Replace any useage of gl_FragColor that does not assign to\n                  // it\n                  body = body.replace(/gl_FragColor/g, `_FragColor`);\n                }\n              }\n\n              outputNames.add(\"_FragColor\");\n            } else {\n              outputTypes.push(FragmentOutputType.NONE);\n            }\n          }\n\n          headers += `\\n${(header || \"\").trim()}`;\n          bodies += `\\n  ${(body || \"\").trim()}`;\n          return (body || \"\").trim();\n        }\n      });\n    });\n\n    return {\n      output: `${headers}\\nvoid main() {\\n${bodies}\\n}`,\n      outputNames: Array.from(outputNames.values()),\n      outputTypes: outputTypes\n    };\n  }\n\n  /**\n   * This merges output for the fragment shader when we are simply outputting to\n   * a single COLOR target the view specifies. This means we look for an output\n   * from the layer that is a COLOR output and merge all fragments up to that\n   * output, we clear out any templating variables, and for WebGL1 we make it\n   * output to gl_FragColor and for WebGL2 we output to _FragColor and make an\n   * out declarartion for it.\n   */\n  static mergeOutputFragmentShaderForColor(\n    layerOutputs: OutputFragmentShaderSource,\n    viewOutputs: number[]\n  ) {\n    // Our view output MUST only be a string or a single color target for this\n    // to be valid.\n    if (viewOutputs.length > 1 || viewOutputs[0] !== FragmentOutputType.COLOR) {\n      throw new Error(\n        \"Merging fragment shaders for only COLOR output is only valid when the view has a single COLOR output target.\"\n      );\n    }\n\n    // If this output is just a string, we have our simple COLOR output.\n    if (isString(layerOutputs)) {\n      layerOutputs = [\n        {\n          outputType: FragmentOutputType.COLOR,\n          source: layerOutputs\n        }\n      ];\n    }\n\n    let bodies = \"\";\n    let headers = \"\";\n    const outputNames = new Set<string>();\n    const outputTypes: number[] = [];\n\n    layerOutputs.some(layerOutput => {\n      const isColor = layerOutput.outputType === FragmentOutputType.COLOR;\n      let foundOutputToken = false;\n\n      if (isColor) {\n        outputTypes.push(FragmentOutputType.COLOR);\n      }\n\n      shaderTemplate({\n        shader: removeComments(layerOutput.source),\n\n        /**\n         * Analyze each token for \"out\" tokens indicating output\n         */\n        onToken(token) {\n          const trimmedToken = token.trim();\n\n          if (trimmedToken.indexOf(OUT_TOKEN) === 0) {\n            if (foundOutputToken) {\n              console.error(\n                \"Found multiple ${out} tokens in a single fragment shader. This is not supported nor logical\",\n                \"If you need to use the declared output multiple times, use the assigned name\",\n                \"and don't wrap it repeatedly in the shader.\",\n                \"eg-\",\n                \"void main() {\",\n                \"  ${out: myOutput} = value;\",\n                \"  vec4 somethingElse = myOutput;\",\n                \"}\"\n              );\n              throw new Error(\"Invalid Shader Format\");\n            }\n\n            // Flag the token as discovered so we can make sure we don't have\n            // too many tokens show up.\n            foundOutputToken = true;\n            // Analyze the remainder of the token to find the necessary colon to\n            // be the NEXT Non-whitespace character\n            const afterToken = trimmedToken.substr(OUT_TOKEN.length).trim();\n\n            // Make sure the character IS a colon\n            if (afterToken[0] === OUT_DELIMITER) {\n              // At this point, ANYTHING after the colon is the output property\n              // being requested (with white space trimmed). If the name isn't\n              // valid, that's not our fault.\n              const outputName = afterToken.substr(OUT_DELIMITER.length).trim();\n\n              if (!outputName) {\n                throw new Error(\n                  \"Output in a shader requires an identifier ${out: <name required>}\"\n                );\n              }\n\n              if (outputNames.has(outputName)) {\n                throw new Error(\n                  \"You can not declare the same output name in subsequent fragment shader outputs\"\n                );\n              }\n\n              if (outputName === \"gl_FragColor\") {\n                throw new Error(\n                  \"DO not use gl_FragColor as an identifier for an out. Choose something not used by the WebGL spec.\"\n                );\n              }\n\n              // If this is the color output of the layer, then we take the\n              // output token and simply map it to the proper ES version\n              // fragment output. Since we have an ES 3 transform later in the\n              // process we can ALWAYS set this to gl_FragColor, BUT we must\n              // make sure the token specified is properly declared so it is\n              // available in the rest of the exisitng program.\n              if (isColor) {\n                outputNames.add(\"gl_FragColor\");\n\n                if (outputName !== \"gl_FragColor\") {\n                  return `vec4 ${outputName} = gl_FragColor`;\n                }\n\n                return \"gl_FragColor\";\n              }\n\n              // Replace the token with just the name of the variable being\n              // declared with the proper type sizing.\n              return `vec4 ${outputName}`;\n            }\n          }\n\n          // Leave unprocessed tokens alone\n          return `$\\{${token}}`;\n        },\n\n        onMain(body, header) {\n          headers += `\\n${(header || \"\").trim()}`;\n          bodies += `\\n  ${(body || \"\").trim()}`;\n          return (body || \"\").trim();\n        }\n      });\n\n      // Stop when we find a COLOR output\n      if (isColor) return true;\n      return false;\n    });\n\n    return {\n      output: `${headers}\\nvoid main() {\\n${bodies}\\n}`,\n      outputNames: Array.from(outputNames.values()),\n      outputTypes: outputTypes\n    };\n  }\n\n  /**\n   * This analyzes desired target outputs and available outputs that output to\n   * certain output types. This will match the targets with the available\n   * outputs and produce shaders that reflect the capabilities\n   * available of both target and provided outputs.\n   *\n   * This also takes into account the capabilities of the hardware. If MRT is\n   * supported, the generated shaders will be combined as best as possible. If\n   * MRT is NOT supported, this will generate MULTIPLE SHADERS, a shader for\n   * each output capable of delivering the targetted output specified.\n   */\n  static makeOutputFragmentShader(\n    declarationsVS: ShaderDeclarationStatements,\n    declarationsFS: ShaderDeclarationStatements,\n    viewOutputs?: OutputFragmentShaderTarget | null,\n    layerOutputs?: OutputFragmentShaderSource\n  ): MapValueType<OutputFragmentShader> | null {\n    // If the layer output only is a simple string, then we assume the COLOR\n    // output of the layer. If the layer does not specify a specific COLOR\n    // output, then we assume the culminated output of all outputs of the layer\n    // is the target.\n    //\n    // NOTE: All results under this branch will be for SINGLE\n    // TARGET outputs, so we don't need to worry about MRT here. The final\n    // fragment output IS the only output.\n    if (!viewOutputs || isString(viewOutputs)) {\n      // View expects a color output, layer only outputs a color, we are good\n      // to simply output the layer to the view.\n      if (isString(layerOutputs)) {\n        const processed = this.mergeOutputFragmentShaderForColor(\n          [\n            {\n              source: layerOutputs,\n              outputType: FragmentOutputType.COLOR\n            }\n          ],\n          [FragmentOutputType.COLOR]\n        );\n\n        return {\n          source: processed.output,\n          outputTypes: [FragmentOutputType.COLOR],\n          outputNames: processed.outputNames\n        };\n      }\n\n      // Look through the layer's fragment outputs for something that is\n      // labeled as a color. We prioritize that.\n      else if (Array.isArray(layerOutputs)) {\n        const colorOutput = layerOutputs.find(\n          s => s.outputType === FragmentOutputType.COLOR\n        );\n\n        let outputIndex = -1;\n\n        // If our layer outputs a color, this is the output element that will\n        // output for our COLOR target.\n        if (colorOutput) {\n          outputIndex = layerOutputs.indexOf(colorOutput);\n        }\n\n        // With no specified color, we render the final output of the layer as\n        // the output to the view but we dub it as a COLOR anyways.\n        else {\n          outputIndex = layerOutputs.length - 1;\n        }\n\n        // We take the found index of the output we need to output for our COLOR\n        // target and aggregate all of the preceding outputs as the dependencies\n        // needed for this output to work properly.\n        const processed = this.mergeOutputFragmentShaderForColor(\n          layerOutputs.slice(0, outputIndex + 1),\n          [FragmentOutputType.COLOR]\n        );\n\n        return {\n          source: processed.output,\n          outputNames: processed.outputNames,\n          outputTypes: [FragmentOutputType.COLOR]\n        };\n      }\n\n      // It's invalid to not have output sources so we just return a null object\n      // to indicate there is no fragment shader that can be inferred for the\n      // targets specified.\n      else {\n        return null;\n      }\n    }\n\n    // If the targets SPECIFIES any EXPECTED output types, then the outputs will\n    // be filtered based on ONLY outputting IFF they have outputs that match the\n    // target outputs.\n    // NOTE: The outputs for this branch are expected to be MRT related. So,\n    // this will produce a merged output if MRT is supported or it will produce\n    // multiple shader outputs to support each individual target output if MRT\n    // is not available.\n    else if (Array.isArray(viewOutputs)) {\n      if (!WebGLStat.MRT) {\n        throw new Error(\n          \"Multiple Render Targets were specified, but are not natively supported by user's hardware! MRT also does not have a fallback in deltav yet!\"\n        );\n      }\n\n      // Gather all of the actual output types in a list so we know the ordering\n      // and the mapping of types to specific outputs.\n      const viewOutputTypes = viewOutputs.map(target => target.outputType);\n\n      // If we have multiple outputs, let's find indices of each output that\n      // matches a target and create our shader(s) with that\n      if (Array.isArray(layerOutputs)) {\n        const typeToIndex = new Map<number, number>();\n\n        for (let i = 0, iMax = viewOutputs.length; i < iMax; ++i) {\n          const target = viewOutputs[i];\n\n          // Find the index of an output that supports this target\n          for (let k = 0, kMax = layerOutputs.length; k < kMax; ++k) {\n            const output = layerOutputs[k];\n\n            if (output.outputType === target.outputType) {\n              typeToIndex.set(target.outputType, k);\n              break;\n            }\n          }\n        }\n\n        // After we have discovered an index for types. We see which combination\n        // method we are allowed to do based on our system's hardware.\n        // For MRT capable hardware, we take in the largest index we found and\n        // combine all dependencies before it and declare that shader output as\n        // capable of handling all target outputs\n        if (WebGLStat.MRT) {\n          let maxIndex = -1;\n          const types: number[] = [];\n          typeToIndex.forEach((index, type) => {\n            types.push(type);\n            maxIndex = Math.max(index, maxIndex);\n          });\n\n          // No valid index found is considered an error\n          if (maxIndex === -1) return null;\n\n          const processed = this.mergeFragmentOutputsForMRT(\n            declarationsVS,\n            declarationsFS,\n            layerOutputs.slice(0, maxIndex + 1),\n            viewOutputTypes,\n            types\n          );\n\n          return {\n            source: processed.output,\n            outputNames: processed.outputNames,\n            outputTypes: processed.outputTypes\n          };\n        }\n\n        // For non-MRT capable hardware, we need to generate a shader per each\n        // output type we matched on\n        else {\n          throw new Error(\n            \"Fragment shader generation not supported for MRT systems on non MRT hardware...yet\"\n          );\n          // const generated: MapValueType<OutputFragmentShader> = [];\n          // typeToIndex.forEach((index, type) => {\n          //   // Merge in the shaders to one shader, but only mark a single type\n          //   // as the output.\n          //   const processed = this.mergeFragmentOutputsForMRT(\n          //     declarations,\n          //     layerOutputs.slice(0, index + 1),\n          //     [type],\n          //     undefined,\n          //     true\n          //   );\n\n          //   generated.push({\n          //     source: processed.output,\n          //     outputNames: processed.outputNames,\n          //     outputTypes: processed.outputTypes\n          //   });\n          // });\n\n          // return generated;\n        }\n      }\n\n      // If we have a single output, then we only look for a target that wants\n      // COLOR and map it to that. If no target wants COLOR, then we don't need\n      // any shaders for this configuration.\n      else {\n        const targetColor = viewOutputs.find(\n          t => t.outputType === FragmentOutputType.COLOR\n        );\n\n        if (targetColor && layerOutputs) {\n          const processed = this.mergeFragmentOutputsForMRT(\n            declarationsVS,\n            declarationsFS,\n            [\n              {\n                source: layerOutputs,\n                outputType: FragmentOutputType.COLOR\n              }\n            ],\n            viewOutputTypes\n          );\n\n          return {\n            source: processed.output,\n            outputNames: processed.outputNames,\n            outputTypes: processed.outputTypes\n          };\n        }\n      }\n    }\n\n    // If this is reached, nothing was a valid output for the\n    return null;\n  }\n\n  /**\n   * This processes a layer, it's Shader IO requirements, and it's shaders to\n   * produce a fully functional shader that is compatible with the client's\n   * system.\n   */\n  process<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>,\n    shaderIO: IShaderInitialization<T>,\n    fragmentShaders: OutputFragmentShader,\n    shaderDeclarations: ShaderDeclarationStatementLookup,\n    ioExpansion: BaseIOExpansion[],\n    transforms: BaseShaderTransform[],\n    sortIO: BaseIOSorting\n  ): IShaderProcessingResults<T> | null {\n    try {\n      // Process imports to retrieve the requested IO the shader modules would\n      // be requiring\n      const shadersWithImports = this.processImports(\n        layer,\n        shaderIO,\n        fragmentShaders\n      );\n      if (!shadersWithImports) return null;\n\n      // After processing our imports, we can now fully aggregate the needed\n      // shader IO to make our layer operate properly. Process all of the\n      // attributes and apply IO expansion to all of the discovered shader IO\n      // the layer will need to execute.\n      const { vertexAttributes, instanceAttributes, uniforms } = injectShaderIO(\n        layer.surface.gl,\n        layer,\n        shaderIO,\n        ioExpansion,\n        sortIO,\n        shadersWithImports\n      );\n      // After all of the shader IO is established, let's calculate the\n      // appropriate buffering strategy For the layer.\n      layer.getLayerBufferType(\n        layer.surface.gl,\n        vertexAttributes,\n        instanceAttributes\n      );\n\n      // Calculate needed metrics that may be used by any of the processors\n      // These metrics include information regarding block allotments reltive to\n      // each instance.\n      this.metricsProcessing.process(instanceAttributes, uniforms);\n\n      // We are going to gather headers for both vertex and fragment from our\n      // processors\n      let vsHeader = \"\";\n      let fsHeader = \"\";\n      // We will also gather the destructuring structure for the attributes from\n      // our processor\n      let destructuring = \"\";\n      // In processing, this may generate changes to the Material to accommodate\n      // features required\n      const materialChanges: ShaderIOHeaderInjectionResult[\"material\"] = {\n        uniforms: []\n      };\n\n      const vsHeaderDeclarations: ShaderDeclarationStatements =\n        shaderDeclarations.vs || new Map();\n      const fsHeaderDeclarations: ShaderDeclarationStatementLookup[\"fs\"] =\n        shaderDeclarations.fs || new Map();\n      const destructureDeclarations: ShaderDeclarationStatements =\n        shaderDeclarations.destructure || new Map();\n\n      // Loop through all of our processors that handle expanding all IO into\n      // headers for the shader\n      for (let i = 0, iMax = ioExpansion.length; i < iMax; ++i) {\n        const processor = ioExpansion[i];\n\n        // Generate vertex header declarations\n        const vsHeaderInfo = processor.processHeaderInjection(\n          ShaderInjectionTarget.VERTEX,\n          vsHeaderDeclarations,\n          layer,\n          this.metricsProcessing,\n          vertexAttributes,\n          instanceAttributes,\n          uniforms\n        );\n\n        vsHeader += vsHeaderInfo.injection;\n\n        if (vsHeaderInfo.material) {\n          materialChanges.uniforms = materialChanges.uniforms.concat(\n            vsHeaderInfo.material.uniforms || []\n          );\n        }\n\n        // Destructure the elements\n        destructuring += processor.processAttributeDestructuring(\n          layer,\n          destructureDeclarations,\n          this.metricsProcessing,\n          vertexAttributes,\n          instanceAttributes,\n          uniforms\n        );\n      }\n\n      // After we have aggregated all of our declarations, we now piece them\n      // together\n      let declarations = \"\";\n\n      vsHeaderDeclarations.forEach(declaration => {\n        declarations += declaration;\n      });\n\n      vsHeader = declarations + vsHeader;\n      declarations = \"\";\n\n      destructureDeclarations.forEach(declaration => {\n        declarations += declaration;\n      });\n\n      destructuring = declarations + destructuring;\n\n      // Establish all extensions to be applied to the shader. Extensions are\n      // essentially any directive that looks like:\n      // ```#directive and stuff```\n      const extensions = this.processExtensions();\n      // Create a default precision modifier for now\n      const precision = \"precision highp float;\\n\\n\";\n      // Now we concatenate the shader pieces into one glorious shader of\n      // compatibility and happiness\n      const fullShaderVS =\n        extensions + precision + vsHeader + shadersWithImports.vs;\n\n      // Last we replace any templating variables with their relevant values\n      let templateOptions: { [key: string]: string } = {\n        [templateVars.attributes]: destructuring\n      };\n\n      // This flag will determine if the attributes are manually placed in the\n      // shader. If this is not true, then the attributes will get injected into\n      // the main() method.\n      let hasAttributes = false;\n\n      const processedShaderVS = shaderTemplate({\n        options: templateOptions,\n        required: undefined,\n        shader: fullShaderVS,\n\n        onToken(token: string, replace: string) {\n          if (token === templateVars.attributes) {\n            hasAttributes = true;\n          }\n\n          return replace;\n        },\n\n        onMain(body: string | null) {\n          if (hasAttributes) return body || \"\";\n\n          if (body === null) {\n            console.warn(\"The body of void main() could not be determined.\");\n            return \"\";\n          }\n\n          return `${destructuring}\\n${body}`;\n        }\n      });\n\n      // We process the Fragment shader as well, currently with nothing to\n      // replace aside from removing any superfluous template requests\n      shadersWithImports.fs.forEach((fsShader, view) => {\n        templateOptions = {};\n        fsHeader = \"\";\n        declarations = \"\";\n        const fsDeclarations: ShaderDeclarationStatements =\n          fsHeaderDeclarations.get(view) || new Map();\n\n        for (let i = 0, iMax = ioExpansion.length; i < iMax; ++i) {\n          const processor = ioExpansion[i];\n          // Generate fragment header declarations\n          const fsHeaderInfo = processor.processHeaderInjection(\n            ShaderInjectionTarget.FRAGMENT,\n            fsDeclarations,\n            layer,\n            this.metricsProcessing,\n            vertexAttributes,\n            instanceAttributes,\n            uniforms\n          );\n\n          fsHeader += fsHeaderInfo.injection;\n\n          if (fsHeaderInfo.material) {\n            const currentUniformNames = new Set();\n            materialChanges.uniforms.forEach(uniform =>\n              currentUniformNames.add(uniform.name)\n            );\n            materialChanges.uniforms.forEach(uniform => {\n              if (!currentUniformNames.has(uniform.name)) {\n                materialChanges.uniforms.push(uniform);\n              }\n            });\n          }\n        }\n\n        fsDeclarations.forEach(declaration => {\n          declarations += declaration;\n        });\n\n        fsHeader = declarations + fsHeader;\n\n        // Loop through all of the fragment shaders and perform the final\n        // aggregation of changes on all the fragments involved.\n        const fullShaderFS =\n          extensions + precision + fsHeader + fsShader.source;\n\n        const processShaderFS = shaderTemplate({\n          options: templateOptions,\n          required: undefined,\n          shader: fullShaderFS\n        });\n\n        fsShader.source = processShaderFS.shader.trim();\n\n        // The final step: apply all shader transforms to the content\n        for (let i = 0, iMax = transforms.length; i < iMax; ++i) {\n          const transform = transforms[i];\n          processedShaderVS.shader = transform.vertex(processedShaderVS.shader);\n\n          fsShader.source = transform.fragment(fsShader.source);\n        }\n      });\n\n      const results = {\n        fs: shadersWithImports.fs,\n        materialUniforms: materialChanges.uniforms,\n        maxInstancesPerBuffer: this.metricsProcessing\n          .maxInstancesPerUniformBuffer,\n        modules: Array.from(shadersWithImports.shaderModuleUnits),\n        vs: processedShaderVS.shader.trim(),\n        vertexAttributes,\n        instanceAttributes,\n        uniforms\n      };\n\n      return results;\n    } catch (err) {\n      console.warn(\n        \"An unknown error occurred while processing the shaders for layer:\",\n        layer.id\n      );\n      console.warn(\"Error:\");\n      console.warn(err && (err.stack || err.message));\n      return null;\n    }\n  }\n\n  /**\n   * This processes all information available about the shader to determine\n   * which extensions must be available for the shader to work.\n   */\n  private processExtensions(): string {\n    let extensions = \"\";\n\n    // This MUST be the absolute FIRST item in the shader for it to work\n    if (WebGLStat.SHADERS_3_0) {\n      extensions += \"#version 300 es\";\n    }\n\n    // When MRT is implemented as an extension, we need the extension header in\n    // the shader, and the outputs are mapped to gl_FragData[]\n    if (WebGLStat.MRT_EXTENSION) {\n      extensions += \"#extension GL_EXT_draw_buffers : require\";\n    }\n\n    // Add some buffer for readability\n    if (extensions) extensions += \"\\n\\n\";\n\n    return extensions;\n  }\n\n  /**\n   * This applies the imports for the specified layer and generates the\n   * appropriate shaders from the output. Upon failure, this will just return\n   * null.\n   *\n   * This also does some additional work to add in some modules based on the\n   * layer's preferences\n   */\n  private processImports<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>,\n    shaders: IShaderInitialization<T>,\n    fragmentShaders: OutputFragmentShader\n  ): ProcessShaderImportResults {\n    const shaderModuleUnits = new Set<ShaderModuleUnit>();\n    let baseModules = layer.baseShaderModules(shaders);\n\n    if (layer.props.baseShaderModules) {\n      baseModules = layer.props.baseShaderModules(shaders, baseModules);\n    }\n\n    // Process imports for the vertex shader\n    const vsResult = ShaderModule.process(\n      layer.id,\n      shaders.vs,\n      ShaderInjectionTarget.VERTEX,\n      baseModules.vs\n    );\n\n    if (vsResult.errors.length > 0) {\n      console.warn(\n        \"Error processing imports for the vertex shader of layer:\",\n        layer.id,\n        \"Errors\",\n        ...vsResult.errors.reverse()\n      );\n\n      return null;\n    }\n\n    const processedFragmentShaders: OutputFragmentShader = new Map();\n\n    // Process imports for the fragment shaders\n    fragmentShaders.forEach((shader, view) => {\n      const fsResult = ShaderModule.process(\n        layer.id,\n        shader.source,\n        ShaderInjectionTarget.FRAGMENT,\n        baseModules.fs\n      );\n\n      if (fsResult.errors.length > 0) {\n        console.warn(\n          \"Error processing imports for the fragment shader of layer:\",\n          layer.id,\n          \"Errors\",\n          ...fsResult.errors.reverse()\n        );\n\n        return;\n      }\n\n      fsResult.shaderModuleUnits.forEach(moduleUnit =>\n        shaderModuleUnits.add(moduleUnit)\n      );\n\n      const fs = {\n        source: fsResult.shader || \"\",\n        outputTypes: shader.outputTypes,\n        outputNames: shader.outputNames\n      };\n\n      processedFragmentShaders.set(view, fs);\n    });\n\n    // Gather all discovered Shader Module Units\n    vsResult.shaderModuleUnits.forEach(moduleUnit =>\n      shaderModuleUnits.add(moduleUnit)\n    );\n\n    return {\n      fs: processedFragmentShaders,\n      vs: vsResult.shader || \"\",\n      shaderModuleUnits\n    };\n  }\n}\n","export const templateVars = {\n  attributes: \"attributes\",\n  easingMethod: \"easingMethod\",\n  extend: \"extend\",\n  extendHeader: \"extendHeader\",\n  T: \"T\"\n};\n","import { WebGLStat } from \"../../gl/webgl-stat\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport { IInstanceAttribute, IUniform } from \"../../types\";\n\n/**\n * This handles processing some metrics that are commonly needed by other processors.\n */\nexport class MetricsProcessing {\n  /** This is an instance's max listed block */\n  instanceMaxBlock: number;\n  /** This is the number of blocks each instance will use */\n  blocksPerInstance: number;\n  /** This is how many uniform blocks the current device can utilize in a shader */\n  maxUniforms: number;\n  /** This reflects how many uniform blocks are available for instancing */\n  maxUniformsForInstancing: number;\n  /** Get the number of instances the client's system supports specifically for uniform instancing */\n  maxInstancesPerUniformBuffer: number;\n  /** This is the total blocks to be used in our uniform buffer for handling instances */\n  totalInstanceUniformBlocks: number;\n\n  /**\n   * This calculates how many uniform blocks are utilized based on the input uniforms\n   */\n  static calculateUniformBlockUseage(uniforms: IUniform[]) {\n    let count = 0;\n\n    for (let i = 0, end = uniforms.length; i < end; ++i) {\n      count += Math.ceil(uniforms[i].size / 4);\n    }\n\n    return count;\n  }\n\n  /**\n   * Calculates all of the metrics that will be needed in this processor.\n   */\n  process<T extends Instance>(\n    instanceAttributes: IInstanceAttribute<T>[],\n    uniforms: IUniform[]\n  ) {\n    this.instanceMaxBlock = 0;\n\n    // First find the max block to be utilized\n    instanceAttributes.forEach(attribute => {\n      this.instanceMaxBlock = Math.max(\n        this.instanceMaxBlock,\n        attribute.block || 0\n      );\n    });\n\n    this.blocksPerInstance = this.instanceMaxBlock + 1;\n    this.maxUniforms = WebGLStat.MAX_VERTEX_UNIFORMS;\n    this.maxUniformsForInstancing =\n      this.maxUniforms -\n      MetricsProcessing.calculateUniformBlockUseage(uniforms);\n    this.maxInstancesPerUniformBuffer = Math.floor(\n      this.maxUniformsForInstancing / this.blocksPerInstance\n    );\n    this.totalInstanceUniformBlocks =\n      this.maxInstancesPerUniformBuffer * this.blocksPerInstance;\n  }\n}\n","import {\n  Material,\n  MaterialFragmentShader,\n  MaterialOptions,\n  MaterialUniformType\n} from \"../../gl\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport {\n  IInstancingUniform,\n  IUniform,\n  OutputFragmentShader,\n  UniformSize\n} from \"../../types\";\nimport { ILayerProps, Layer } from \"../layer\";\n\nconst UNIFORM_SIZE_TO_MATERIAL_TYPE: { [key: number]: MaterialUniformType } = {\n  [UniformSize.ONE]: MaterialUniformType.FLOAT,\n  [UniformSize.TWO]: MaterialUniformType.VEC2,\n  [UniformSize.THREE]: MaterialUniformType.VEC3,\n  [UniformSize.FOUR]: MaterialUniformType.VEC4,\n  [UniformSize.MATRIX3]: MaterialUniformType.MATRIX3x3,\n  [UniformSize.MATRIX4]: MaterialUniformType.MATRIX4x4,\n  [UniformSize.FLOAT_ARRAY]: MaterialUniformType.FLOAT_ARRAY,\n  [UniformSize.TEXTURE]: MaterialUniformType.TEXTURE\n};\n\nconst DEFAULT_UNIFORM_VALUE: { [key: number]: number[] } = {\n  [UniformSize.ONE]: [0],\n  [UniformSize.TWO]: [0, 0],\n  [UniformSize.THREE]: [0, 0, 0],\n  [UniformSize.FOUR]: [0, 0, 0, 0],\n  [UniformSize.MATRIX3]: [0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [UniformSize.MATRIX4]: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n};\n\nfunction toMaterialUniform(uniform: IUniform) {\n  return {\n    type: UNIFORM_SIZE_TO_MATERIAL_TYPE[uniform.size],\n    value: DEFAULT_UNIFORM_VALUE[uniform.size]\n  };\n}\n\nexport function generateLayerMaterial<\n  T extends Instance,\n  U extends ILayerProps<T>\n>(\n  layer: Layer<T, U>,\n  vs: string,\n  fs: OutputFragmentShader,\n  layerUniforms: IUniform[],\n  instancingUniforms: IInstancingUniform[]\n): Material {\n  // We now need to establish the material for the layer\n  const materialParams: MaterialOptions = layer.getMaterialOptions();\n  const materialFS: MaterialFragmentShader = new Map();\n\n  fs.forEach((output, view) => {\n    materialFS.set(view.renderTarget || null, output);\n  });\n\n  // The props applied to the layer has a material option declaration as well\n  // these settings take priority over all settings\n  Object.assign(materialParams, layer.props.materialOptions || {});\n\n  materialParams.vertexShader = vs;\n  materialParams.fragmentShader = materialFS;\n  materialParams.name = layer.id;\n\n  // We must convert all of the uniforms to actual GL material initialization uniforms\n  materialParams.uniforms = {};\n\n  // Convert our non-instancing uniforms to our material uniforms\n  for (let i = 0, end = layerUniforms.length; i < end; ++i) {\n    const uniform = layerUniforms[i];\n    const materialUniform = toMaterialUniform(uniform);\n    materialParams.uniforms[uniform.name] = materialUniform;\n  }\n\n  // Add in the generated instancing uniforms\n  for (let i = 0, end = instancingUniforms.length; i < end; ++i) {\n    const generatedUniform = instancingUniforms[i];\n    materialParams.uniforms[generatedUniform.name] = {\n      type: generatedUniform.type,\n      value: generatedUniform.value\n    };\n  }\n\n  return new Material(materialParams);\n}\n","import { Attribute, Geometry } from \"../../gl\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport {\n  IVertexAttribute,\n  IVertexAttributeInternal,\n  LayerBufferType,\n  ShaderIOValue\n} from \"../../types\";\nimport { Layer } from \"../layer\";\n\nfunction isNumberCluster(\n  val: ShaderIOValue\n): val is\n  | [number]\n  | [number, number]\n  | [number, number, number]\n  | [number, number, number, number] {\n  return !Array.isArray(val[0]);\n}\n\nexport function generateLayerGeometry<T extends Instance>(\n  layer: Layer<T, any>,\n  maxInstancesPerBuffer: number,\n  vertexAttributes: IVertexAttributeInternal[],\n  vertexCount: number\n): Geometry {\n  // Make the new buffers to be updated\n  const vertexBuffers = [];\n\n  // Certain buffer strategies only need one instance buffered in\n  if (\n    layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE ||\n    layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE_PACKING\n  ) {\n    maxInstancesPerBuffer = 1;\n  }\n\n  for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n    const attribute = vertexAttributes[i];\n    vertexBuffers.push(\n      new Float32Array(attribute.size * vertexCount * maxInstancesPerBuffer)\n    );\n  }\n\n  // Let's now fill in the baseline geometry with the instances we will be generating\n  // First we ask the layer for a single instance's buffer setup\n  const endk = vertexAttributes.length;\n  let buffer: Float32Array;\n  let attribute: IVertexAttribute;\n  let value: ShaderIOValue;\n  let formatError: boolean = false;\n\n  for (let i = 0, end = vertexCount; i < end; ++i) {\n    for (let k = 0; k < endk; ++k) {\n      attribute = vertexAttributes[k];\n      buffer = vertexBuffers[k];\n      value = attribute.update(i);\n\n      if (isNumberCluster(value)) {\n        for (\n          let j = i * attribute.size, endj = j + attribute.size, index = 0;\n          j < endj;\n          ++j, ++index\n        ) {\n          buffer[j] = value[index];\n        }\n      } else {\n        formatError = true;\n      }\n    }\n  }\n\n  if (formatError) {\n    console.warn(\n      \"A vertex buffer updating method should not use arrays of arrays of numbers.\"\n    );\n  }\n\n  // After getting the geometry for a single instance, we can now copy paste\n  // For subsequent instances using very fast FLoat32 methods\n  // NOTE: This is ONLY for certain buffering strategies. This is essentially a noop when the\n  // maxInstances is set to one.\n  for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n    const attribute = vertexAttributes[i];\n    const instanceSize = attribute.size * vertexCount;\n\n    // Copy the first buffer set into the rest of the buffer\n    for (let k = 1, endk = maxInstancesPerBuffer; k < endk; ++k) {\n      vertexBuffers[i].copyWithin(instanceSize * k, 0, instanceSize);\n    }\n  }\n\n  // Lastly, we make the instance attribute reflect correctly so each instance\n  // Can have varied information. This is only appropriate for the uniform buffer strategy\n  if (layer.bufferType === LayerBufferType.UNIFORM) {\n    const instancingBuffer = vertexBuffers[0];\n\n    for (let i = 0, end = maxInstancesPerBuffer; i < end; ++i) {\n      const instanceStartIndex = i * vertexCount;\n\n      for (let k = 0; k < vertexCount; ++k) {\n        instancingBuffer[k + instanceStartIndex] = i;\n      }\n    }\n  }\n\n  // Now we can generate the attributes and apply them to a geometry object\n  const geometry = new Geometry();\n\n  // Generate the attributes, they are all Vertex attributes, thus instancing does not get flagged on them.\n  for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n    const attribute = vertexAttributes[i];\n    const materialAttribute = new Attribute(vertexBuffers[i], attribute.size);\n    attribute.materialAttribute = materialAttribute;\n    geometry.addAttribute(attribute.name, materialAttribute);\n  }\n\n  return geometry;\n}\n","export * from \"./easing-io-expansion\";\nexport * from \"./basic-io-expansion\";\nexport * from \"./active-io-expansion\";\n","module.exports = \"if (_active < 0.5) {\\ngl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\nreturn;\\n}\"","\"use strict\";\n\nimport { Attribute, Geometry, Material, Model } from \"../../../gl\";\nimport { Instance, ObservableMonitoring } from \"../../../instance-provider\";\nimport {\n  IInstanceAttribute,\n  IInstanceAttributeInternal,\n  InstanceDiffType\n} from \"../../../types\";\nimport { emitOnce, flushEmitOnce } from \"../../../util/emit-once\";\nimport { uid } from \"../../../util/uid\";\nimport { Layer } from \"../../layer\";\nimport { generateLayerModel } from \"../../layer-processing/generate-layer-model\";\nimport { LayerScene } from \"../../layer-scene\";\nimport {\n  BufferManagerBase,\n  IBufferLocation,\n  IBufferLocationGroup\n} from \"../buffer-manager-base\";\n\nconst debug = require(\"debug\")(\"performance\");\nconst { max } = Math;\n\n/**\n * This represents the location of data for an instance's property to the piece of attribute buffer\n * it will update when it changes.\n */\nexport interface IInstanceAttributeBufferLocation extends IBufferLocation {\n  /** We narrow the buffer type for instance attributes down to just array buffers */\n  buffer: {\n    value: Float32Array | Uint8Array;\n  };\n\n  /** We narrow the chaild locations to be the same as this buffer location */\n  childLocations?: IInstanceAttributeBufferLocation[];\n}\n\n/** Represents the Location Groupings for Instance attribute Buffer locations */\nexport type IInstanceAttributeBufferLocationGroup = IBufferLocationGroup<\n  IInstanceAttributeBufferLocation\n>;\n\n/**\n * Typeguard for the instance attribute buffer location.\n */\nexport function isInstanceAttributeBufferLocation(\n  val: IBufferLocation\n): val is IInstanceAttributeBufferLocation {\n  return Boolean(val && val.buffer && val.buffer.value);\n}\n\n/**\n * This manages instances in how they associate with buffer data for an instanced attribute strategy.\n */\nexport class InstanceAttributeBufferManager<\n  T extends Instance\n> extends BufferManagerBase<T, IInstanceAttributeBufferLocation> {\n  /** This stores an attribute's name to the buffer locations generated for it */\n  private allBufferLocations: { [key: string]: IBufferLocation[] } = {};\n  /** This contains the buffer locations the system will have available */\n  private availableLocations: IInstanceAttributeBufferLocationGroup[] = [];\n  /** This is the number of instances the buffer draws currently */\n  currentInstancedCount = 0;\n  /** This is the mapped buffer location to the provided Instance */\n  private instanceToBufferLocation: {\n    [key: number]: IInstanceAttributeBufferLocationGroup;\n  } = {};\n  /** This is the number of instances the buffer currently supports */\n  private maxInstancedCount: number = 0;\n\n  // These are the only GL objects that must be monitored for disposal\n  private geometry?: Geometry;\n  private material?: Material;\n  private model?: Model;\n  private attributes?: IInstanceAttributeInternal<T>[];\n\n  /** This is a mapping of all attributes to their associated property ids that, when the property changes, the attribute will be updated */\n  private attributeToPropertyIds = new Map<IInstanceAttribute<T>, number[]>();\n  /**\n   * This is a trimmed listing of minimum property ids needed to trigger an update on all properties.\n   * This is used by the diffing process mostly to handle adding a new instance.\n   */\n  private updateAllPropertyIdList: number[] = [];\n  /**\n   * This is the discovered property id of the active attribute for the instance type this manager manages.\n   * This is used by the diffing process to target updates related to deactivating an instance.\n   */\n  private activePropertyId: number = -1;\n  /**\n   * As changes are processed, instances will be added into the buffers. As they are added in, the instance\n   * will take over available locations within the buffer. Normally we would have these available locations\n   * in a queue and we would push and shift into that queue to retrieve the locations; however, shifting queues\n   * when done in VERY large quantities causes javascript to lag horrendously. Thus we instead have this index\n   * to monitor the next available item to pull during processing changes. AFTER changes have been processed\n   * we perform a one time operation splice to delete any list of available locations that have been used. This\n   * GREATLY improves performance for these types of operations.\n   */\n  private currentAvailableLocation: number = -1;\n\n  constructor(layer: Layer<T, any>, scene: LayerScene) {\n    super(layer, scene);\n    // Start our add method as a registration step.\n    this.add = this.doAddWithRegistration;\n  }\n\n  /**\n   * This is the tail end of processing changes and lets us clean up anything that might have been used to aid in the\n   * processing.\n   */\n  changesProcessed() {\n    super.changesProcessed();\n    // Clean out available locations that have been consumed during processing changes\n    this.availableLocations.splice(0, this.currentAvailableLocation + 1);\n    // All elements in the availableLocations buffer are now valid locations so we reset this index back to the\n    // beginning which is -1 since our loop iterates with it using ++currentAvailableLocation.\n    this.currentAvailableLocation = -1;\n  }\n\n  /**\n   * First instance to be added to this manager will be heavily analyzed for used observables per attribute.\n   */\n  private doAddWithRegistration(instance: T) {\n    // Activate monitoring of ids, this also resets the monitor's list\n    ObservableMonitoring.setObservableMonitor(true);\n\n    // We need to find out how an instance interacts with the attributes, so we will\n    // loop through the instances, call their updates and get feedback\n    this.layer.shaderIOInfo.instanceAttributes.forEach(attribute => {\n      // We don't need to register child attributes as they get updated as a consequence to parent attributes\n      if (attribute.parentAttribute) return;\n      // Access the update which accesses an instances properties (usually)\n      attribute.update(instance);\n      // We now have all of the ids of the properties that were used in updating the attributes\n      const propertyIdsForAttribute = ObservableMonitoring.getObservableMonitorIds(\n        true\n      );\n      // Store the mapping of the property ids\n      // TODO: We currently only support ONE property id per change\n      this.attributeToPropertyIds.set(attribute, [\n        propertyIdsForAttribute[propertyIdsForAttribute.length - 1]\n      ]);\n\n      if (propertyIdsForAttribute.length > 1) {\n        debug(\n          \"Property has multiple observables. Only the last trigger will be retained as the feature is not complete yet\"\n        );\n      }\n\n      // If this is the active attribute, then we track the property id that modifies it\n      // for handling internal instance management.\n      if (attribute === this.layer.shaderIOInfo.activeAttribute) {\n        this.activePropertyId = propertyIdsForAttribute[0];\n      }\n    });\n\n    // SUPER IMPORTANT to deactivate this here. Leaving this turned on causes memory to be chewed up\n    // for every property getter.\n    ObservableMonitoring.setObservableMonitor(false);\n    // This analyzes the properties and how they affect the attributes. It determines the smallest\n    // list possible of property ids needed to trigger an update on all of the attributes.\n    this.makeUpdateAllPropertyIdList();\n    // Do the first resize which creates the buffer and makes all of the initial buffer locations\n    const locationInfo = this.resizeBuffer();\n    // After all of the property id to attribute associations are made, we must break down the buffers\n    // into locations and then group those locations which will become our instance to buffer location\n    // slots\n    this.gatherLocationsIntoGroups(\n      locationInfo.newLocations,\n      locationInfo.growth\n    );\n    // After the first registration add, we gear shift to a more efficient add method.\n    this.add = this.doAdd;\n\n    // Perform the add after all of the registration process is complete\n    return this.doAdd(instance);\n  }\n\n  /**\n   * After the registration add happens, we gear shift over to this add method which will only pair instances\n   * with their appropriate buffer location.\n   */\n  private doAdd(instance: T) {\n    // Ensure we have buffer locations available\n    if (\n      this.availableLocations.length <= 0 ||\n      this.currentAvailableLocation >= this.availableLocations.length - 1\n    ) {\n      // Resice the buffer to accommodate more instances\n      const locationInfo = this.resizeBuffer();\n      // Break down the newly generated buffers into property groupings for the instances\n      this.gatherLocationsIntoGroups(\n        locationInfo.newLocations,\n        locationInfo.growth\n      );\n    }\n\n    // Get the next available location\n    const bufferLocations = this.availableLocations[\n      ++this.currentAvailableLocation\n    ];\n\n    // Pair up the instance with it's buffer location\n    if (bufferLocations && this.geometry) {\n      this.instanceToBufferLocation[instance.uid] = bufferLocations;\n      this.currentInstancedCount = this.geometry.maxInstancedCount = max(\n        this.currentInstancedCount,\n        // Instance index + 1 because the indices are zero indexed and the maxInstancedCount is a count value\n        bufferLocations.instanceIndex + 1\n      );\n\n      if (this.model) {\n        this.model.vertexDrawRange = [\n          0,\n          this.layer.shaderIOInfo.instanceVertexCount\n        ];\n        this.model.drawInstances = this.currentInstancedCount;\n\n        if (this.layer.shaderIOInfo.instanceVertexCount === 0) {\n          this.model.vertexDrawRange[1] = this.model.drawInstances;\n        }\n      }\n    } else {\n      console.error(\n        \"Add Error: Instance Attribute Buffer Manager failed to pair an instance with a buffer location\"\n      );\n    }\n\n    return bufferLocations;\n  }\n\n  /**\n   * Free any buffer and material resources this is managing.\n   */\n  destroy() {\n    if (this.geometry) this.geometry.destroy();\n    if (this.material) this.material.dispose();\n\n    if (this.scene && this.scene.container && this.model) {\n      this.scene.container.remove(this.model);\n    }\n  }\n\n  /**\n   * This retireves the buffer locations associated with an instance, or returns nothing\n   * if the instance has not been associated yet.\n   */\n  getBufferLocations(instance: T) {\n    return this.instanceToBufferLocation[instance.uid];\n  }\n\n  /**\n   * This is the property id of the active attribute.\n   */\n  getActiveAttributePropertyId() {\n    return this.activePropertyId;\n  }\n\n  /**\n   * This is the bare minimum property ids that, when triggered for update, will update ALL of the attribute buffers\n   * for the managed layer.\n   */\n  getUpdateAllPropertyIdList() {\n    return this.updateAllPropertyIdList;\n  }\n\n  /**\n   * Checks to see if an instance is managed by this manager.\n   */\n  managesInstance(instance: T) {\n    // We know this instance is managed if the instance has buffer location real estate assigned to it\n    return this.instanceToBufferLocation[instance.uid] !== void 0;\n  }\n\n  /**\n   * Analyzes the list of attributes to the property ids that affects them. This populates the list\n   * of minimal property ids needed to trigger updates on all of the attributes.\n   */\n  private makeUpdateAllPropertyIdList() {\n    // Make a deduping list of ids\n    const updateAllPropertyIdList: { [key: number]: number } = {};\n\n    // Get unique ids that will target all attributes\n    this.attributeToPropertyIds.forEach(ids => {\n      updateAllPropertyIdList[ids[0]] = ids[0];\n    });\n\n    // Store the list for the diffing process to utilize\n    this.updateAllPropertyIdList = Object.values(\n      updateAllPropertyIdList\n    ).filter(Boolean);\n  }\n\n  /**\n   * Disassociates an instance with a buffer\n   */\n  remove = (instance: T) => {\n    const location = this.instanceToBufferLocation[instance.uid];\n\n    if (location) {\n      delete this.instanceToBufferLocation[instance.uid];\n      this.availableLocations.push(location);\n    }\n\n    return instance;\n  };\n\n  /**\n   * Clears all elements of this manager from the current scene it was in.\n   */\n  removeFromScene() {\n    if (this.scene && this.scene.container && this.model) {\n      this.scene.container.remove(this.model);\n    }\n\n    delete this.scene;\n  }\n\n  /**\n   * This generates a new buffer of uniforms to associate instances with.\n   */\n  private resizeBuffer() {\n    debug(\"Gathering resize growth amount...\");\n    // Get the shader io information from the layer to reduce deep references\n    const shaderIOInfo = this.layer.shaderIOInfo;\n    // This stores how much the buffer will be able to regrow\n    let growth = 0;\n    // Each attribute will generate lists of new buffer locations after being created or expanded\n    const attributeToNewBufferLocations = new Map<\n      string,\n      IInstanceAttributeBufferLocation[]\n    >();\n\n    // As an optimization to guarantee the buffer is resized only a single time for a single changelist\n    // we  will calculate the necessary growth of the buffer by finding all of the insertions the changelist\n    // will cause.\n    if (this.changeListContext) {\n      // We will always grow beyond a 1000 units. That way there is room to prevent immediate resize operations\n      // from happening too frequently.\n      growth = 1000;\n\n      // We loop through all of the changes to find which operations will result in an additional unit\n      for (let i = 0, iMax = this.changeListContext.length; i < iMax; ++i) {\n        const diff = this.changeListContext[i];\n\n        switch (diff[1]) {\n          case InstanceDiffType.CHANGE:\n          case InstanceDiffType.INSERT:\n            // If the instance is not managed, it is a buffer growth\n            if (!this.instanceToBufferLocation[diff[0].uid]) growth++;\n            break;\n\n          default:\n            break;\n        }\n      }\n    }\n\n    debug(\"BEGIN: Resizing unpacked attribute buffer by %d instances\", growth);\n\n    // If our geometry is not created yet, then it need be made\n    if (!this.geometry) {\n      // The buffer grows from 0 to our initial instance count\n      this.maxInstancedCount += growth;\n      // We generate a new geometry object for the buffer as the geometry\n      // Needs to have it's own unique draw range per buffer for optimal\n      // Performance.\n      this.geometry = new Geometry();\n\n      // The geometry needs the vertex information (which should be shared amongst all instances of the layer)\n      for (const attribute of shaderIOInfo.vertexAttributes) {\n        if (attribute.materialAttribute) {\n          this.geometry.addAttribute(\n            attribute.name,\n            attribute.materialAttribute\n          );\n        }\n      }\n\n      this.attributes = [];\n\n      // We now take the instance attributes and add them as Instanced Attributes to our geometry\n      for (const attribute of shaderIOInfo.instanceAttributes) {\n        // We start with enough data in the buffer to accommodate 1024 instances\n        const size: number = attribute.size || 0;\n        const buffer = new Float32Array(size * this.maxInstancedCount);\n        const bufferAttribute = new Attribute(buffer, size, true, true);\n        bufferAttribute.setDynamic(true);\n        this.geometry.addAttribute(attribute.name, bufferAttribute);\n        let newBufferLocations = attributeToNewBufferLocations.get(\n          attribute.name\n        );\n\n        if (!newBufferLocations) {\n          newBufferLocations = [];\n          attributeToNewBufferLocations.set(attribute.name, newBufferLocations);\n        }\n\n        const allLocations = this.allBufferLocations[attribute.name] || [];\n        this.allBufferLocations[attribute.name] = allLocations;\n\n        const internalAttribute: IInstanceAttributeInternal<T> = Object.assign(\n          {},\n          attribute,\n          { uid: uid(), bufferAttribute: bufferAttribute }\n        );\n\n        for (let i = 0; i < this.maxInstancedCount; ++i) {\n          const newLocation: IInstanceAttributeBufferLocation = {\n            attribute: internalAttribute,\n            buffer: {\n              value: buffer\n            },\n            instanceIndex: i,\n            range: [i * size, i * size + size]\n          };\n\n          newBufferLocations.push(newLocation);\n          allLocations.push(newLocation);\n        }\n\n        // Make an internal instance attribute for tracking\n        this.attributes.push(internalAttribute);\n      }\n\n      // Ensure the draw range covers every instance in the geometry.\n      this.geometry.maxInstancedCount = 0;\n      // This is the material that is generated for the layer that utilizes all of the generated and\n      // Injected shader IO and shader fragments\n      this.material = this.makeLayerMaterial();\n\n      // Grab the global uniforms from the material and add it to the uniform's materialUniform list so that\n      // We can keep uniforms consistent across all Instances\n      for (let i = 0, end = shaderIOInfo.uniforms.length; i < end; ++i) {\n        const uniform = shaderIOInfo.uniforms[i];\n        uniform.materialUniforms.push(this.material.uniforms[uniform.name]);\n      }\n    } else {\n      // If the geometry is already created, then we will expand each instanced attribute to the next growth\n      // level and generate the new buffer locations based on the expansion\n      // Since were are resizing the buffer, let's destroy the old buffer and make one anew\n      this.geometry.destroy();\n      this.geometry = new Geometry();\n      const previousInstanceAmount = this.maxInstancedCount;\n\n      // The geometry needs the vertex information (which should be shared amongst all instances of the layer)\n      for (const attribute of shaderIOInfo.vertexAttributes) {\n        if (attribute.materialAttribute) {\n          this.geometry.addAttribute(\n            attribute.name,\n            attribute.materialAttribute\n          );\n        }\n      }\n\n      this.maxInstancedCount += growth;\n\n      // Ensure attributes is still defined\n      this.attributes = this.attributes || [];\n\n      for (const attribute of this.attributes) {\n        const bufferAttribute = attribute.bufferAttribute;\n        const size: number = attribute.size || 0;\n\n        if (bufferAttribute.data instanceof Float32Array) {\n          // Make a new buffer that is the proper size\n          let buffer: Float32Array = bufferAttribute.data;\n\n          // OPTIMIZATION:\n          // Sneaky trick. We do buffer doubling behind the scenes to reduce\n          // these mass allocations and destructions. The background buffer gets\n          // double space, but everything else in JS land operates as though\n          // it's a tightly fitted buffer.\n          if (buffer.length < this.maxInstancedCount * size) {\n            buffer = new Float32Array(this.maxInstancedCount * size * 2);\n            // Retain all of the information in the previous buffer\n            buffer.set(bufferAttribute.data, 0);\n          }\n\n          // Make our new attribute based on the grown buffer\n          const newAttribute = new Attribute(buffer, size, true, true);\n          // Set the attribute to dynamic so we can update ranges within it\n          newAttribute.setDynamic(true);\n          // Make sure our attribute is updated with the newly made attribute\n          attribute.bufferAttribute = newAttribute;\n          // Add the new attribute to our new geometry object\n          this.geometry.addAttribute(attribute.name, newAttribute);\n          // Get the temp storage for new buffer locations\n          let newBufferLocations = attributeToNewBufferLocations.get(\n            attribute.name\n          );\n\n          // Since we have a new buffer object we are working with, we must update all of the existing buffer\n          // locations to utilize this new buffer. The locations keep everything else the same, but the buffer\n          // object itself should be updated\n          const allLocations = this.allBufferLocations[attribute.name] || [];\n          this.allBufferLocations[attribute.name] = allLocations;\n\n          for (let k = 0, endk = allLocations.length; k < endk; ++k) {\n            allLocations[k].buffer.value = buffer;\n          }\n\n          if (!newBufferLocations) {\n            newBufferLocations = [];\n            attributeToNewBufferLocations.set(\n              attribute.name,\n              newBufferLocations\n            );\n          }\n\n          // Set up some optimizations for this loop\n          let newLocation: IInstanceAttributeBufferLocation;\n          let index = newBufferLocations.length;\n          const added = this.maxInstancedCount - previousInstanceAmount;\n          newBufferLocations.length += added;\n          allLocations.length += added;\n\n          for (\n            let i = previousInstanceAmount, end = this.maxInstancedCount;\n            i < end;\n            ++i, ++index\n          ) {\n            newLocation = {\n              attribute,\n              buffer: {\n                value: buffer\n              },\n              instanceIndex: i,\n              range: [i * size, i * size + size]\n            };\n\n            newBufferLocations[index] = newLocation;\n            allLocations[i] = newLocation;\n          }\n        }\n      }\n\n      if (this.scene.container && this.model) {\n        this.scene.container.remove(this.model);\n      }\n    }\n\n    if (this.scene && this.model && this.scene.container) {\n      this.scene.container.remove(this.model);\n    }\n\n    // Ensure material is defined\n    this.material = this.material || this.makeLayerMaterial();\n    // Remake the model with the generated geometry\n    this.model = generateLayerModel(\n      this.geometry,\n      this.material,\n      shaderIOInfo.drawMode\n    );\n\n    // Now that we are ready to utilize the buffer, let's add it to the scene so it may be rendered.\n    // Each new buffer equates to one draw call.\n    if (this.scene && this.scene.container && this.model) {\n      this.scene.container.add(this.model);\n    }\n\n    debug(\"COMPLETE: Resizing unpacked attribute buffer\");\n\n    return {\n      growth,\n      newLocations: attributeToNewBufferLocations\n    };\n  }\n\n  /**\n   * This takes newly created buffer locations and groups them by the property ids identified by the\n   * registration phase.\n   */\n  private gatherLocationsIntoGroups(\n    attributeToNewBufferLocations: Map<\n      string,\n      IInstanceAttributeBufferLocation[]\n    >,\n    totalNewInstances: number\n  ) {\n    if (this.attributeToPropertyIds.size === 0) return;\n\n    debug(\"BEGIN: Unpacked attribute manager grouping new buffer locations\");\n\n    // Optimize inner loops by pre-fetching lookups by names\n    const attributesBufferLocations: {\n      attribute: IInstanceAttribute<T>;\n      bufferLocationsForAttribute: IInstanceAttributeBufferLocation[];\n      childBufferLocations: {\n        location: IInstanceAttributeBufferLocation[];\n        // This is one of those odd but extremely necessary optimizations. Normally while assigning these buffers to\n        // groups, one would simply use the available items and shift() those items out into the group; however,\n        // shift() or pop() is VERY ineffecient in mass quantities in that it causes massive amounts of memory\n        // allocation and movement. So instead of shifting the buffer, we simply keep an index to move to the next\n        // buffer to use. It makes the mental works a lot harder to envision, but the gains are immense doing this.\n        bufferIndex: number;\n      }[];\n      ids: number[];\n      bufferIndex: number;\n    }[] = [];\n\n    this.attributeToPropertyIds.forEach((ids, attribute) => {\n      attributesBufferLocations.push({\n        attribute,\n        bufferLocationsForAttribute:\n          attributeToNewBufferLocations.get(attribute.name) || [],\n        childBufferLocations: (attribute.childAttributes || []).map(attr => ({\n          location: attributeToNewBufferLocations.get(attr.name) || [],\n          bufferIndex: -1\n        })),\n        ids,\n        bufferIndex: -1\n      });\n    });\n\n    let allLocations,\n      attribute: IInstanceAttribute<T>,\n      ids: number[],\n      bufferLocationsForAttribute: IInstanceAttributeBufferLocation[],\n      bufferLocation: IInstanceAttributeBufferLocation | undefined,\n      childAttribute: IInstanceAttribute<T>;\n\n    // Loop through all of the new instances available and gather all of the buffer locations\n    for (let i = 0; i < totalNewInstances; ++i) {\n      const group: IInstanceAttributeBufferLocationGroup = {\n        instanceIndex: -1,\n        propertyToBufferLocation: {}\n      };\n\n      // Loop through all of the property ids that affect specific attributes. Each of these ids\n      // needs an association with the buffer location they modify.\n      for (let j = 0, endj = attributesBufferLocations.length; j < endj; ++j) {\n        allLocations = attributesBufferLocations[j];\n        attribute = allLocations.attribute;\n        ids = allLocations.ids;\n        bufferLocationsForAttribute = allLocations.bufferLocationsForAttribute;\n\n        if (!bufferLocationsForAttribute) {\n          emitOnce(\n            \"Instance Attribute Buffer Error\",\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: There is an error in forming buffer location groups in InstanceAttributeBufferManager. Error count: ${count}`\n              );\n            }\n          );\n          continue;\n        }\n\n        bufferLocation =\n          bufferLocationsForAttribute[++allLocations.bufferIndex];\n\n        if (!bufferLocation) {\n          emitOnce(\n            \"Instance Attribute Buffer Error\",\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: There is an error in forming buffer location groups in InstanceAttributeBufferManager. Error count: ${count}`\n              );\n            }\n          );\n          continue;\n        }\n\n        if (group.instanceIndex === -1) {\n          group.instanceIndex = bufferLocation.instanceIndex;\n        } else if (bufferLocation.instanceIndex !== group.instanceIndex) {\n          emitOnce(\n            \"Instance Attribute Parallelism Error\",\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: A buffer location does not have a matching instance index which means the buffer locations are not in parallel with each other somehow. Error count: ${count}`\n              );\n              console.warn(attribute.name, bufferLocation);\n            }\n          );\n          continue;\n        }\n\n        // If the attribute has children attributes. Then when the attribute is updated, the child attributes should\n        // be updated as well. Thus the buffer location needs the child attribute buffer locations.\n        if (attribute.childAttributes) {\n          bufferLocation.childLocations = [];\n\n          for (\n            let k = 0, endk = attribute.childAttributes.length;\n            k < endk;\n            ++k\n          ) {\n            const bufferLocationsForChildAttribute =\n              allLocations.childBufferLocations[k];\n\n            if (bufferLocationsForChildAttribute) {\n              const childBufferLocation =\n                bufferLocationsForChildAttribute.location[\n                  ++bufferLocationsForChildAttribute.bufferIndex\n                ];\n              // count++;\n              if (childBufferLocation) {\n                bufferLocation.childLocations.push(childBufferLocation);\n              } else {\n                childAttribute = attribute.childAttributes[k];\n                emitOnce(\n                  \"Instance Attribute Child Attribute Error\",\n                  (count: number, id: string) => {\n                    console.warn(\n                      `${id}: A child attribute does not have a buffer location available. Error count: ${count}`\n                    );\n                    console.warn(\n                      `Parent Attribute: ${attribute.name} Child Attribute: ${childAttribute.name}`\n                    );\n                  }\n                );\n              }\n            }\n          }\n        }\n\n        // In the group, associate the property ids that affect a buffer location WITH the buffer location they affect\n        for (let k = 0, endk = ids.length; k < endk; ++k) {\n          group.propertyToBufferLocation[ids[k]] = bufferLocation;\n        }\n      }\n\n      // Store this group as a group that is ready to be associated with an instance\n      this.availableLocations.push(group);\n    }\n\n    debug(\n      \"COMPLETE: Unpacked attribute buffer manager buffer location grouping\"\n    );\n    // This helps ensure errors get reported in a timely fashion in case this triggers some massive looping\n    flushEmitOnce();\n  }\n\n  /**\n   * Returns the total instances this buffer manages.\n   */\n  getInstanceCount() {\n    return this.maxInstancedCount;\n  }\n}\n","import { Attribute, Geometry, Material, Model } from \"../../../gl\";\nimport { Instance, ObservableMonitoring } from \"../../../instance-provider\";\nimport {\n  IInstanceAttribute,\n  IInstanceAttributeInternal,\n  InstanceDiffType\n} from \"../../../types\";\nimport { emitOnce, flushEmitOnce } from \"../../../util/emit-once\";\nimport { uid } from \"../../../util/uid\";\nimport { Layer } from \"../../layer\";\nimport { generateLayerModel } from \"../../layer-processing/generate-layer-model\";\nimport { LayerScene } from \"../../layer-scene\";\nimport {\n  BufferManagerBase,\n  IBufferLocation,\n  IBufferLocationGroup\n} from \"../buffer-manager-base\";\n\nconst { max } = Math;\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * This represents the location of data for an instance's property to the piece of attribute buffer\n * it will update when it changes.\n */\nexport interface IInstanceAttributePackingBufferLocation\n  extends IBufferLocation {}\n\n/** Represents the Location Groupings for Instance attribute Buffer locations */\nexport type IInstanceAttributePackingBufferLocationGroup = IBufferLocationGroup<\n  IInstanceAttributePackingBufferLocation\n>;\n\n/**\n * This manages instances in how they associate with buffer data for an instanced attribute strategy that is\n * packed tightly.\n */\nexport class InstanceAttributePackingBufferManager<\n  T extends Instance\n> extends BufferManagerBase<T, IInstanceAttributePackingBufferLocation> {\n  /** This stores an attribute's name to the buffer locations generated for it */\n  private allBufferLocations: { [key: string]: IBufferLocation[] } = {};\n  /** This contains the buffer locations the system will have available */\n  private availableLocations: IInstanceAttributePackingBufferLocationGroup[] = [];\n  /** This is the number of instances the buffer draws currently */\n  currentInstancedCount = 0;\n  /** This is the mapped buffer location to the provided Instance */\n  private instanceToBufferLocation: {\n    [key: number]: IInstanceAttributePackingBufferLocationGroup;\n  } = {};\n  /** This is the number of instances the buffer currently supports */\n  private maxInstancedCount: number = 1000;\n\n  // These are the only GL objects that must be monitored for disposal\n  private geometry?: Geometry;\n  private material?: Material;\n  private model?: Model;\n  private attributes?: IInstanceAttributeInternal<T>[];\n  private blockAttributes?: IInstanceAttributeInternal<T>[];\n  private blockSubAttributesLookup = new Map<number, IInstanceAttribute<T>[]>();\n\n  /** This is a mapping of all attributes to their associated property ids that, when the property changes, the attribute will be updated */\n  private attributeToPropertyIds = new Map<IInstanceAttribute<T>, number[]>();\n  /**\n   * This is a trimmed listing of minimum property ids needed to trigger an update on all properties.\n   * This is used by the diffing process mostly to handle adding a new instance.\n   */\n  private updateAllPropertyIdList: number[] = [];\n  /**\n   * This is the discovered property id of the active attribute for the instance type this manager manages.\n   * This is used by the diffing process to target updates related to deactivating an instance.\n   */\n  private activePropertyId: number = -1;\n  /**\n   * As changes are processed, instances will be added into the buffers. As they are added in, the instance\n   * will take over available locations within the buffer. Normally we would have these available locations\n   * in a queue and we would push and shift into that queue to retrieve the locations; however, shifting queues\n   * when done in VERY large quantities causes javascript to lag horrendously. Thus we instead have this index\n   * to monitor the next available item to pull during processing changes. AFTER changes have been processed\n   * we perform a one time operation splice to delete any list of available locations that have been used. This\n   * GREATLY improves performance for these types of operations.\n   */\n  private currentAvailableLocation: number = -1;\n\n  constructor(layer: Layer<T, any>, scene: LayerScene) {\n    super(layer, scene);\n    // Start our add method as a registration step.\n    this.add = this.doAddWithRegistration;\n  }\n\n  /**\n   * This is the tail end of processing changes and lets us clean up anything that might have been used to aid in the\n   * processing.\n   */\n  changesProcessed() {\n    super.changesProcessed();\n    // Clean out available locations that have been consumed during processing changes\n    this.availableLocations.splice(0, this.currentAvailableLocation + 1);\n    // All elements in the availableLocations buffer are now valid locations so we reset this index back to the\n    // beginning which is -1 since our loop iterates with it using ++currentAvailableLocation.\n    this.currentAvailableLocation = -1;\n  }\n\n  /**\n   * First instance to be added to this manager will be heavily analyzed for used observables per attribute.\n   */\n  private doAddWithRegistration(instance: T) {\n    // We need to find out how an instance interacts with the attributes, so we will\n    // loop through the instances, call their updates and get feedback\n    this.layer.shaderIOInfo.instanceAttributes.forEach(attribute => {\n      // We don't need to register child attributes as they get updated as a consequence to parent attributes\n      if (attribute.parentAttribute) return;\n      // Activate monitoring of ids, this also resets the monitor's list\n      ObservableMonitoring.setObservableMonitor(true);\n      // Access the update which accesses an instance's properties (usually)\n      attribute.update(instance);\n      // We now have all of the ids of the properties that were used in updating the attributes\n      const propertyIdsForAttribute = ObservableMonitoring.getObservableMonitorIds(\n        true\n      );\n      // Store the mapping of the property ids\n      // TODO: We currently only support ONE property id per change\n      this.attributeToPropertyIds.set(attribute, [\n        propertyIdsForAttribute[propertyIdsForAttribute.length - 1]\n      ]);\n\n      if (propertyIdsForAttribute.length > 1) {\n        debug(\n          \"Property has multiple observables. Only the last trigger will be retained as the feature is not complete yet\"\n        );\n      }\n\n      // If this is the active attribute, then we track the property id that modifies it\n      // for handling internal instance management.\n      if (attribute === this.layer.shaderIOInfo.activeAttribute) {\n        this.activePropertyId = propertyIdsForAttribute[0];\n      }\n    });\n\n    // SUPER IMPORTANT to deactivate this here. Leaving this turned on causes memory to be chewed up\n    // for every property getter.\n    ObservableMonitoring.setObservableMonitor(false);\n    // This analyzes the properties and how they affect the attributes. It determines the smallest\n    // list possible of property ids needed to trigger an update on all of the attributes.\n    this.makeUpdateAllPropertyIdList();\n    // Do the first resize which creates the buffer and makes all of the initial buffer locations\n    const locationInfo = this.resizeBuffer();\n    // After all of the property id to attribute associations are made, we must break down the buffers\n    // into locations and then group those locations which will become our instance to buffer location\n    // slots\n    this.gatherLocationsIntoGroups(\n      locationInfo.newLocations,\n      locationInfo.growth\n    );\n    // After the first registration add, we gear shift to a more efficient add method.\n    this.add = this.doAdd;\n\n    // Perform the add after all of the registration process is complete\n    return this.doAdd(instance);\n  }\n\n  /**\n   * After the registration add happens, we gear shift over to this add method which will only pair instances\n   * with their appropriate buffer location.\n   */\n  private doAdd(instance: T) {\n    // Ensure we have buffer locations available\n    if (\n      this.availableLocations.length <= 0 ||\n      this.currentAvailableLocation >= this.availableLocations.length - 1\n    ) {\n      // Resice the buffer to accommodate more instances\n      const locationInfo = this.resizeBuffer();\n      // Break down the newly generated buffers into property groupings for the instances\n      this.gatherLocationsIntoGroups(\n        locationInfo.newLocations,\n        locationInfo.growth\n      );\n    }\n\n    // Get the next available location\n    const bufferLocations = this.availableLocations[\n      ++this.currentAvailableLocation\n    ];\n\n    // Pair up the instance with it's buffer location\n    if (bufferLocations && this.geometry) {\n      this.instanceToBufferLocation[instance.uid] = bufferLocations;\n      this.currentInstancedCount = this.geometry.maxInstancedCount = max(\n        this.currentInstancedCount,\n        // Instance index + 1 because the indices are zero indexed and the maxInstancedCount is a count value\n        bufferLocations.instanceIndex + 1\n      );\n\n      if (this.model) {\n        this.model.vertexDrawRange = [\n          0,\n          this.layer.shaderIOInfo.instanceVertexCount\n        ];\n        this.model.drawInstances = this.currentInstancedCount;\n\n        if (this.layer.shaderIOInfo.instanceVertexCount === 0) {\n          this.model.vertexDrawRange[1] = this.model.drawInstances;\n        }\n      }\n    } else {\n      console.error(\n        \"Add Error: Instance Attribute Buffer Manager failed to pair an instance with a buffer location\"\n      );\n    }\n\n    return bufferLocations;\n  }\n\n  /**\n   * Destroy this manager and clear out all elements utilized within the scene.\n   */\n  destroy() {\n    if (this.geometry) this.geometry.destroy();\n    if (this.material) this.material.dispose();\n\n    if (this.scene && this.scene.container && this.model) {\n      this.scene.container.remove(this.model);\n    }\n  }\n\n  /**\n   * This retireves the buffer locations associated with an instance, or returns nothing\n   * if the instance has not been associated yet.\n   */\n  getBufferLocations(instance: T) {\n    return this.instanceToBufferLocation[instance.uid];\n  }\n\n  /**\n   * This is the property id of the active attribute.\n   */\n  getActiveAttributePropertyId() {\n    return this.activePropertyId;\n  }\n\n  /**\n   * This is the bare minimum property ids that, when triggered for update, will update ALL of the attribute buffers\n   * for the managed layer.\n   */\n  getUpdateAllPropertyIdList() {\n    return this.updateAllPropertyIdList;\n  }\n\n  /**\n   * Checks to see if this buffer manager manages the indicated instance\n   */\n  managesInstance(instance: T) {\n    return this.instanceToBufferLocation[instance.uid] !== undefined;\n  }\n\n  /**\n   * Analyzes the list of attributes to the property ids that affects them. This populates the list\n   * of minimal property ids needed to trigger updates on all of the attributes.\n   */\n  private makeUpdateAllPropertyIdList() {\n    // Make a deduping list of ids\n    const updateAllPropertyIdList: { [key: number]: number } = {};\n\n    // Get unique ids that will target all attributes\n    this.attributeToPropertyIds.forEach(ids => {\n      updateAllPropertyIdList[ids[0]] = ids[0];\n    });\n\n    // Store the list for the diffing process to utilize\n    this.updateAllPropertyIdList = Object.values(\n      updateAllPropertyIdList\n    ).filter(Boolean);\n  }\n\n  /**\n   * Disassociates an instance with a buffer\n   */\n  remove = (instance: T) => {\n    const location = this.instanceToBufferLocation[instance.uid];\n\n    if (location) {\n      delete this.instanceToBufferLocation[instance.uid];\n      this.availableLocations.push(location);\n    }\n\n    return instance;\n  };\n\n  /**\n   * Clears all elements of this manager from the current scene it was in.\n   */\n  removeFromScene() {\n    if (this.scene && this.scene.container && this.model) {\n      this.scene.container.remove(this.model);\n    }\n\n    delete this.scene;\n  }\n\n  /**\n   * This generates a new buffer of attributes to associate instances with.\n   *\n   * This method for the attribute packing strategy creates a vertex attribute for each block required.\n   * The individual properties are then packed into each of these blocks.\n   */\n  private resizeBuffer() {\n    // Get the shader io information from the layer to reduce deep references\n    const shaderIOInfo = this.layer.shaderIOInfo;\n    // This stores how much the buffer will be able to regrow\n    let growth = 0;\n    // Each attribute will generate lists of new buffer locations after being created or expanded\n    const attributeToNewBufferLocations = new Map<\n      string,\n      IInstanceAttributePackingBufferLocation[]\n    >();\n\n    // As an optimization to guarantee the buffer is resized only a single time for a single changelist\n    // we  will calculate the necessary growth of the buffer by finding all of the insertions the changelist\n    // will cause.\n    if (this.changeListContext) {\n      // We will always grow beyond a 1000 units. That way there is room to prevent immediate resize operations\n      // from happening too frequently.\n      growth = 1000;\n\n      // We loop through all of the changes to find which operations will result in an additional unit\n      for (let i = 0, iMax = this.changeListContext.length; i < iMax; ++i) {\n        const diff = this.changeListContext[i];\n\n        switch (diff[1]) {\n          case InstanceDiffType.CHANGE:\n          case InstanceDiffType.INSERT:\n            // If the instance is not managed, it is a buffer growth\n            if (!this.instanceToBufferLocation[diff[0].uid]) growth++;\n            break;\n\n          default:\n            break;\n        }\n      }\n    }\n\n    debug(\"BEGIN: Resizing packed attribute buffer by %d instances\", growth);\n\n    // If our geometry is not created yet, then it need be made\n    if (!this.geometry) {\n      // The buffer grows from 0 to our initial instance count\n      this.maxInstancedCount += growth;\n      // We generate a new geometry object for the buffer as the geometry\n      // Needs to have it's own unique draw range per buffer for optimal\n      // Performance.\n      this.geometry = new Geometry();\n\n      // The geometry needs the vertex information (which should be shared amongst all instances of the layer)\n      // These are static non-dynamic buffers for the instance.\n      for (const attribute of shaderIOInfo.vertexAttributes) {\n        if (attribute.materialAttribute) {\n          this.geometry.addAttribute(\n            attribute.name,\n            attribute.materialAttribute\n          );\n        }\n      }\n\n      this.attributes = [];\n      this.blockAttributes = [];\n\n      // We have to determine how many blocks will be used to cram all of our\n      // instance properties into. So we calculate how big each block will be.\n      // The number of sizes calculated will be how many blocks need to be\n      // generated.\n      const blockSizes = new Map<number, number>();\n      const blockSubAttributesLookup = new Map<\n        number,\n        IInstanceAttribute<T>[]\n      >();\n      this.blockSubAttributesLookup = blockSubAttributesLookup;\n\n      for (\n        let i = 0, iMax = shaderIOInfo.instanceAttributes.length;\n        i < iMax;\n        ++i\n      ) {\n        const attribute = shaderIOInfo.instanceAttributes[i];\n        const block = attribute.block || 0;\n        let blockSize = blockSizes.get(block) || 0;\n        // Determine the bigger of the block sizes (incoming attribute or\n        // previously checked attribute)\n        blockSize = Math.max(\n          blockSize,\n          (attribute.blockIndex || 0) + (attribute.size || 0)\n        );\n        // Store the larger size for the block\n        blockSizes.set(block, blockSize);\n        // We need to store all of the attributes associated with a block\n        let blockAttributes = blockSubAttributesLookup.get(block);\n\n        if (!blockAttributes) {\n          blockAttributes = [];\n          blockSubAttributesLookup.set(block, blockAttributes);\n        }\n\n        blockAttributes.push(attribute);\n      }\n\n      // Let's sort all of the attributes associated with each block by their\n      // index in the block so from here on out we can assume they are in\n      // ascending order\n      blockSubAttributesLookup.forEach(attributes =>\n        attributes.sort((a, b) => (a.blockIndex || 0) - (b.blockIndex || 0))\n      );\n\n      // Now that we have the blocks that will be needed to accommodate the\n      // attributes, we will create these blocks as attributes attached to the\n      // geometry.\n      for (let block = 0, iMax = blockSizes.size; block < iMax; ++block) {\n        // Get the size each attribute will be for the block\n        const blockSize: number = blockSizes.get(block) || 0;\n        // This is an interesting case, the attributes that are generated are\n        // packed into other attributes for optimal use of the vertex attributes\n        // allotted for a systems resources.\n        const blockAttributeUID = uid();\n\n        if (!blockSize) {\n          console.warn(\n            \"Instance Attribute Packing Error: The system tried to build an attribute with a size of zero.\",\n            \"These are the attributes used:\",\n            shaderIOInfo.instanceAttributes,\n            \"These are the block sizes calculated\",\n            blockSizes,\n            \"This is the block to attribute lookup generated\",\n            blockSubAttributesLookup\n          );\n        }\n\n        // Make our attribute buffer to accommodate all of the instances to be rendered.\n        const buffer = new Float32Array(blockSize * this.maxInstancedCount);\n        // Make an instanced buffer to take advantage of hardware instancing\n        const bufferAttribute = new Attribute(buffer, blockSize, true, true);\n\n        // Add the attribute to our geometry labeled as a block like the uniform block packing strategy\n        this.geometry.addAttribute(`block${block}`, bufferAttribute);\n\n        // Get all of the attributes that will be applied to this block\n        const blockSubAttributes = blockSubAttributesLookup.get(block);\n\n        if (blockSubAttributes) {\n          for (let k = 0, kMax = blockSubAttributes.length; k < kMax; ++k) {\n            const attribute = blockSubAttributes[k];\n\n            let newBufferLocations = attributeToNewBufferLocations.get(\n              attribute.name\n            );\n\n            if (!newBufferLocations) {\n              newBufferLocations = [];\n              attributeToNewBufferLocations.set(\n                attribute.name,\n                newBufferLocations\n              );\n            }\n\n            const allLocations = this.allBufferLocations[attribute.name] || [];\n            this.allBufferLocations[attribute.name] = allLocations;\n\n            const internalAttribute: IInstanceAttributeInternal<T> = Object.assign(\n              {},\n              attribute,\n              {\n                uid: block,\n                packUID: blockAttributeUID,\n                bufferAttribute,\n                size: blockSize\n              }\n            );\n\n            const startAttributeIndex = attribute.blockIndex || 0;\n            const attributeSize = attribute.size || 1;\n\n            for (let i = 0; i < this.maxInstancedCount; ++i) {\n              const newLocation: IBufferLocation = {\n                attribute: internalAttribute,\n                block,\n                buffer: {\n                  value: buffer\n                },\n                instanceIndex: i,\n                range: [\n                  i * blockSize + startAttributeIndex,\n                  i * blockSize + startAttributeIndex + attributeSize\n                ]\n              };\n\n              newBufferLocations.push(newLocation);\n              allLocations.push(newLocation);\n            }\n\n            this.attributes.push(internalAttribute);\n          }\n\n          // Make an internal instance attribute for tracking\n          this.blockAttributes.push({\n            uid: uid(),\n            packUID: blockAttributeUID,\n            bufferAttribute,\n            name: `block${block}`,\n            size: blockSize,\n            update: () => [0]\n          });\n        } else {\n          console.warn(\n            \"Instance Attribute Packing Buffer Error: Somehow there are no attributes associated with a block.\",\n            \"These are the attributes used:\",\n            shaderIOInfo.instanceAttributes,\n            \"These are the block sizes calculated\",\n            blockSizes,\n            \"This is the block to attribute lookup generated\",\n            blockSubAttributesLookup\n          );\n        }\n      }\n\n      // Ensure the draw range covers every instance in the geometry.\n      this.geometry.maxInstancedCount = 0;\n      // This is the material that is generated for the layer that utilizes all\n      // of the generated and Injected shader IO and shader fragments\n      this.material = this.makeLayerMaterial();\n\n      // Grab the global uniforms from the material and add it to the uniform's\n      // materialUniform list so that We can keep uniforms consistent across all\n      // Instances\n      for (let i = 0, end = shaderIOInfo.uniforms.length; i < end; ++i) {\n        const uniform = shaderIOInfo.uniforms[i];\n        uniform.materialUniforms.push(this.material.uniforms[uniform.name]);\n      }\n    } else {\n      debug(\n        `Info: Vertex packing buffer is being resized for layer ${this.layer.id}`\n      );\n      // If the geometry is already created, then we will expand each instanced\n      // attribute to the next growth level and generate the new buffer\n      // locations based on the expansion Since were are resizing the buffer,\n      // let's destroy the old buffer and make one anew\n      this.geometry.destroy();\n      this.geometry = new Geometry();\n      const previousInstanceAmount = this.maxInstancedCount;\n\n      // The geometry needs the vertex information (which should be shared\n      // amongst all instances of the layer)\n      for (const attribute of shaderIOInfo.vertexAttributes) {\n        if (attribute.materialAttribute) {\n          this.geometry.addAttribute(\n            attribute.name,\n            attribute.materialAttribute\n          );\n        }\n      }\n\n      this.maxInstancedCount += growth;\n\n      // Ensure attributes are still defined\n      this.attributes = this.attributes || [];\n      this.blockAttributes = this.blockAttributes || [];\n\n      for (\n        let block = 0, iMax = this.blockAttributes.length;\n        block < iMax;\n        ++block\n      ) {\n        const attribute = this.blockAttributes[block];\n        let bufferAttribute = attribute.bufferAttribute;\n        const size: number = attribute.size || 0;\n\n        if (bufferAttribute.data instanceof Float32Array) {\n          // Make a new buffer that is the proper size\n          let buffer: Float32Array = bufferAttribute.data;\n\n          // OPTIMIZATION:\n          // Sneaky trick. We do buffer doubling behind the scenes to reduce\n          // these mass allocations and destructions. The background buffer gets\n          // double space, but everything else in JS land operates as though\n          // it's a tightly fitted buffer.\n          if (buffer.length < this.maxInstancedCount * size) {\n            buffer = new Float32Array(this.maxInstancedCount * size * 2);\n            // Retain all of the information in the previous buffer\n            buffer.set(bufferAttribute.data, 0);\n          }\n\n          // Retain all of the information in the previous buffer\n          buffer.set(bufferAttribute.data, 0);\n          // Make our new attribute based on the grown buffer\n          const newAttribute = new Attribute(buffer, size, true, true);\n          // Make sure our attribute is updated with the newly made attribute\n          attribute.bufferAttribute = bufferAttribute = newAttribute;\n          // Add the new attribute to our new geometry object\n          this.geometry.addAttribute(attribute.name, newAttribute);\n\n          // Since we have a new buffer object we are working with, we must update all of the existing buffer\n          // locations to utilize this new buffer. The locations keep everything else the same, but the buffer\n          // object itself should be updated\n          // Get all of the attributes that will be applied to this block\n          const blockSubAttributes = this.blockSubAttributesLookup.get(block);\n          const blockSize = attribute.size || 0;\n\n          if (blockSubAttributes) {\n            for (let k = 0, kMax = blockSubAttributes.length; k < kMax; ++k) {\n              const subAttribute = blockSubAttributes[k];\n\n              let newBufferLocations = attributeToNewBufferLocations.get(\n                subAttribute.name\n              );\n\n              if (!newBufferLocations) {\n                newBufferLocations = [];\n                attributeToNewBufferLocations.set(\n                  subAttribute.name,\n                  newBufferLocations\n                );\n              }\n\n              const allLocations =\n                this.allBufferLocations[subAttribute.name] || [];\n              this.allBufferLocations[subAttribute.name] = allLocations;\n\n              const internalAttribute: IInstanceAttributeInternal<T> = Object.assign(\n                {},\n                subAttribute,\n                {\n                  uid: uid(),\n                  packUID: attribute.packUID,\n                  bufferAttribute\n                }\n              );\n\n              const startAttributeIndex = subAttribute.blockIndex || 0;\n              const attributeSize = subAttribute.size || 1;\n\n              // Update all existing attribute locations with the new internal\n              // attribute and new buffer\n              // let location;\n              let location;\n              for (let j = 0, jMax = allLocations.length; j < jMax; ++j) {\n                location = allLocations[j];\n                location.attribute = internalAttribute;\n                location.buffer.value = buffer;\n              }\n\n              // Set up some optimizations for this loop\n              let newLocation: IBufferLocation;\n              let index = newBufferLocations.length;\n              const added = this.maxInstancedCount - previousInstanceAmount;\n              newBufferLocations.length += added;\n              allLocations.length += added;\n\n              // Create new locations for each new instance we will cover\n              for (\n                let i = previousInstanceAmount;\n                i < this.maxInstancedCount;\n                ++i, ++index\n              ) {\n                newLocation = {\n                  attribute: internalAttribute,\n                  block,\n                  buffer: {\n                    value: buffer\n                  },\n                  instanceIndex: i,\n                  range: [\n                    i * blockSize + startAttributeIndex,\n                    i * blockSize + startAttributeIndex + attributeSize\n                  ]\n                };\n\n                newBufferLocations[index] = newLocation;\n                allLocations[i] = newLocation;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Remove any existing model\n    if (this.scene && this.model && this.scene.container) {\n      this.scene.container.remove(this.model);\n    }\n\n    // Ensure material is defined\n    this.material = this.material || this.makeLayerMaterial();\n    // Remake the model with the generated geometry\n    this.model = generateLayerModel(\n      this.geometry,\n      this.material,\n      this.layer.shaderIOInfo.drawMode\n    );\n\n    // Now that we are ready to utilize the buffer, let's add it to the scene so it may be rendered.\n    // Each new buffer equates to one draw call.\n    if (this.scene && this.scene.container && this.model) {\n      this.scene.container.add(this.model);\n    }\n\n    debug(\"COMPLETE: Resizing unpacked attribute buffer\");\n\n    return {\n      growth,\n      newLocations: attributeToNewBufferLocations\n    };\n  }\n\n  /**\n   * This takes newly created buffer locations and groups them by the property ids identified by the\n   * registration phase.\n   */\n  private gatherLocationsIntoGroups(\n    attributeToNewBufferLocations: Map<\n      string,\n      IInstanceAttributePackingBufferLocation[]\n    >,\n    totalNewInstances: number\n  ) {\n    if (this.attributeToPropertyIds.size === 0) return;\n\n    debug(\"BEGIN: Packed attribute manager grouping new buffer locations\");\n\n    // Optimize inner loops by pre-fetching lookups by names\n    const attributesBufferLocations: {\n      attribute: IInstanceAttribute<T>;\n      bufferLocationsForAttribute: IInstanceAttributePackingBufferLocation[];\n      childBufferLocations: {\n        location: IInstanceAttributePackingBufferLocation[];\n        // This is one of those odd but extremely necessary optimizations. Normally while assigning these buffers to\n        // groups, one would simply use the available items and shift() those items out into the group; however,\n        // shift() or pop() is VERY ineffecient in mass quantities in that it causes massive amounts of memory\n        // allocation and movement. So instead of shifting the buffer, we simply keep an index to move to the next\n        // buffer to use. It makes the mental works a lot harder to envision, but the gains are immense doing this.\n        bufferIndex: number;\n      }[];\n      ids: number[];\n      // This is one of those odd but extremely necessary optimizations. Normally while assigning these buffers to\n      // groups, one would simply use the available items and shift() those items out into the group; however,\n      // shift() or pop() is VERY ineffecient in mass quantities in that it causes massive amounts of memory\n      // allocation and movement. So instead of shifting the buffer, we simply keep an index to move to the next\n      // buffer to use. It makes the mental works a lot harder to envision, but the gains are immense doing this.\n      bufferIndex: number;\n    }[] = [];\n\n    this.attributeToPropertyIds.forEach((ids, attribute) => {\n      attributesBufferLocations.push({\n        attribute,\n        bufferLocationsForAttribute:\n          attributeToNewBufferLocations.get(attribute.name) || [],\n        childBufferLocations: (attribute.childAttributes || []).map(attr => ({\n          location: attributeToNewBufferLocations.get(attr.name) || [],\n          bufferIndex: -1\n        })),\n        ids,\n        bufferIndex: -1\n      });\n    });\n\n    // Loop through all of the new instances available and gather all of the buffer locations\n    for (let i = 0; i < totalNewInstances; ++i) {\n      const group: IInstanceAttributePackingBufferLocationGroup = {\n        instanceIndex: -1,\n        propertyToBufferLocation: {}\n      };\n\n      // Loop through all of the property ids that affect specific attributes. Each of these ids\n      // needs an association with the buffer location they modify.\n      for (let j = 0, endj = attributesBufferLocations.length; j < endj; ++j) {\n        const allLocations = attributesBufferLocations[j];\n        const attribute = allLocations.attribute;\n        const ids = allLocations.ids;\n        const bufferLocationsForAttribute =\n          allLocations.bufferLocationsForAttribute;\n\n        if (!bufferLocationsForAttribute) {\n          emitOnce(\n            \"Instance Attribute Buffer Error\",\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: There is an error in forming buffer location groups in InstanceAttributePackingBufferManager. Error count: ${count}`\n              );\n            }\n          );\n          continue;\n        }\n\n        const bufferLocation =\n          bufferLocationsForAttribute[++allLocations.bufferIndex];\n\n        if (!bufferLocation) {\n          emitOnce(\n            \"Instance Attribute Buffer Error\",\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: There is an error in forming buffer location groups in InstanceAttributePackingBufferManager. Error count: ${count}`\n              );\n            }\n          );\n          continue;\n        }\n\n        if (group.instanceIndex === -1) {\n          group.instanceIndex = bufferLocation.instanceIndex;\n        } else if (bufferLocation.instanceIndex !== group.instanceIndex) {\n          emitOnce(\n            \"Instance Attribute Parallelism Error\",\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: A buffer location does not have a matching instance index which means the buffer locations are not in parallel with each other somehow. Error count: ${count}`\n              );\n              console.warn(attribute.name, bufferLocation);\n            }\n          );\n          continue;\n        }\n\n        // If the attribute has children attributes. Then when the attribute is updated, the child attributes should\n        // be updated as well. Thus the buffer location needs the child attribute buffer locations.\n        if (attribute.childAttributes) {\n          const childLocations = [];\n\n          for (\n            let k = 0, endk = attribute.childAttributes.length;\n            k < endk;\n            ++k\n          ) {\n            const childAttribute = attribute.childAttributes[k];\n            const bufferLocationsForChildAttribute =\n              allLocations.childBufferLocations[k];\n\n            if (bufferLocationsForChildAttribute) {\n              const childBufferLocation =\n                bufferLocationsForChildAttribute.location[\n                  ++bufferLocationsForChildAttribute.bufferIndex\n                ];\n              if (childBufferLocation) {\n                childLocations.push(childBufferLocation);\n              } else {\n                emitOnce(\n                  \"Instance Attribute Child Attribute Error\",\n                  (count: number, id: string) => {\n                    console.warn(\n                      `${id}: A child attribute does not have a buffer location available. Error count: ${count}`\n                    );\n                    console.warn(\n                      `Parent Attribute: ${attribute.name} Child Attribute: ${childAttribute.name}`\n                    );\n                  }\n                );\n              }\n            }\n          }\n\n          bufferLocation.childLocations = childLocations;\n        }\n\n        // In the group, associate the property ids that affect a buffer location WITH the buffer location they affect\n        for (let k = 0, endk = ids.length; k < endk; ++k) {\n          const id = ids[k];\n          group.propertyToBufferLocation[id] = bufferLocation;\n        }\n      }\n\n      // Store this group as a group that is ready to be associated with an instance\n      this.availableLocations.push(group);\n    }\n\n    debug(\"COMPLETE: Packed attribute buffer manager buffer location grouping\");\n\n    // This helps ensure errors get reported in a timely fashion in case this triggers some massive looping\n    flushEmitOnce();\n  }\n\n  /**\n   * Returns the total instances this buffer manages.\n   */\n  getInstanceCount() {\n    return this.maxInstancedCount;\n  }\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport { ResourceRouter } from \"../../resources\";\nimport {\n  INonePickingMetrics,\n  ISinglePickingMetrics,\n  LayerBufferType\n} from \"../../types\";\nimport { ILayerShaderIOInfo } from \"../layer\";\nimport { BaseDiffProcessor } from \"./base-diff-processor\";\nimport { IBufferLocationGroup } from \"./buffer-manager-base\";\nimport { BufferManagerBase, IBufferLocation } from \"./buffer-manager-base\";\nimport { InstanceAttributeDiffProcessor } from \"./instance-attribute-buffering/instance-attribute-diff-processor\";\nimport { UniformDiffProcessor } from \"./uniform-buffering/uniform-diff-processor\";\n\n/** Signature of a method that handles a diff */\nexport type DiffHandler<T extends Instance> = (\n  manager: BaseDiffProcessor<T>,\n  instance: T,\n  propIds: number[],\n  bufferLocations?: IBufferLocation | IBufferLocationGroup<IBufferLocation>\n) => void;\n/** A set of diff handling methods in this order [change, add, remove] */\nexport type DiffLookup<T extends Instance> = DiffHandler<T>[];\n\n/**\n * This interface is the bare minimum properties needed for this diff manager to map instance updates to\n * uniform changes. We don't use a Layer as a target explicitly to avoid circular/hard dependencies\n */\nexport interface IInstanceDiffManagerTarget<T extends Instance> {\n  /** Contains the shader IO information available in the target */\n  shaderIOInfo: ILayerShaderIOInfo<T>;\n  /** This is the picking metrics for how Instances are picked with the mouse */\n  picking: ISinglePickingMetrics<T> | INonePickingMetrics;\n  /** This is the resource manager for the target which let's us fetch information from an atlas for an instance */\n  resource: ResourceRouter;\n  /** This is the manager that links an instance to it's uniform cluster for populating the uniform buffer */\n  bufferManager: BufferManagerBase<T, IBufferLocation>;\n  /** This is the buffering strategy being used */\n  bufferType: LayerBufferType;\n\n  /**\n   * This is a hook for the layer to respond to an instance being added via the diff manager. This is a simple\n   * opportunity to set some expectations of the instance and tie it directly to the layer it is processing under.\n   *\n   * For example: the primary case this arose was from instances needing the easing id mapping to allow for retrieval\n   * of the instance's easing information for a given layer association.\n   *\n   * WARNING: This is tied into a MAJOR performance sensitive portion of the framework. This should involve VERY simple\n   * assignments at best. Do NOT perform any logic in this callback or your application WILL suffer.\n   */\n  onDiffAdd?(instance: T): void;\n\n  /**\n   * This is an opportunity to clean up any instance's association with the layer it was originally a part of.\n   *\n   * WARNING: This is tied into a MAJOR performance sensitive portion of the framework. This should involve VERY simple\n   * assignments at best. Do NOT perform any logic in this callback or your application WILL suffer.\n   *\n   * EXTRA WARNING: You better make sure you instantiate this if you instantiated onDiffManagerAdd so you can clean out\n   * any bad memory allocation choices you made.\n   */\n  onDiffRemove?(instance: T): void;\n}\n\n/**\n * This is a simple organizational class that generates a diff processor and provides a processing tuple that is used\n * in processing the diffs.\n */\nexport class InstanceDiffManager<T extends Instance> {\n  processor: BaseDiffProcessor<T>;\n  processing: DiffLookup<T>;\n\n  /**\n   * This returns the proper diff processor for handling diffs\n   */\n  makeProcessor(\n    layer: IInstanceDiffManagerTarget<T>,\n    bufferManager: BufferManagerBase<T, IBufferLocation>\n  ): DiffLookup<T> {\n    // If this manager has already figured out which processor to use. Just return that processor.\n    if (this.processing) return this.processing;\n\n    if (\n      layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE ||\n      layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE_PACKING\n    ) {\n      this.processor = new InstanceAttributeDiffProcessor(layer, bufferManager);\n    } else {\n      this.processor = new UniformDiffProcessor(layer, bufferManager);\n    }\n\n    this.processing = [\n      this.processor.changeInstance,\n      this.processor.addInstance,\n      this.processor.removeInstance\n    ];\n\n    return this.processing;\n  }\n}\n","import { Instance } from \"../../../instance-provider/instance\";\nimport { Mat4x4, Vec } from \"../../../math\";\nimport { IInstanceAttributeInternal, InstanceDiff } from \"../../../types\";\nimport { BaseDiffProcessor } from \"../base-diff-processor\";\nimport {\n  IBufferLocation,\n  IBufferLocationGroup,\n  isBufferLocationGroup\n} from \"../buffer-manager-base\";\nimport { IInstanceDiffManagerTarget } from \"../instance-diff-manager\";\nimport {\n  IInstanceAttributeBufferLocation,\n  IInstanceAttributeBufferLocationGroup\n} from \"./instance-attribute-buffer-manager\";\n\nconst EMPTY: number[] = [];\nconst { min, max } = Math;\n\nenum DiffMode {\n  /** This mode will analyze incoming buffer location changes and only update the range of changed buffer */\n  PARTIAL,\n  /** This mode will not spend time figuring out what has changed for a buffer, rather the whole buffer will get an update */\n  FULL\n}\n\n/**\n * Manages diffs for layers that are utilizing the base uniform instancing buffer strategy.\n */\nexport class InstanceAttributeDiffProcessor<\n  T extends Instance\n> extends BaseDiffProcessor<T> {\n  /** This is the processor's current diff mode for consuming instance updates. */\n  private diffMode: DiffMode = DiffMode.PARTIAL;\n\n  /** This tracks a buffer attribute's uid to the range of data that it should update */\n  bufferAttributeUpdateRange: {\n    [key: number]: [IInstanceAttributeInternal<T>, number, number];\n  } = {};\n\n  /** This tracks a buffer attribute's uid that will perform a complete update */\n  bufferAttributeWillUpdate: {\n    [key: number]: IInstanceAttributeInternal<T>;\n  } = {};\n\n  /**\n   * The instance updating is a property instead of a method as we will want to be able to gear shift it for varying levels\n   * of adjustments.\n   */\n  updateInstance: (\n    layer: IInstanceDiffManagerTarget<T>,\n    instance: T,\n    propIds: number[],\n    bufferLocations: IBufferLocationGroup<IBufferLocation>\n  ) => void = this.updateInstancePartial;\n\n  /**\n   * This processes add operations from changes in the instancing data\n   */\n  addInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    bufferLocations?: IInstanceAttributeBufferLocationGroup\n  ) {\n    // If the uniform cluster already exists, then we swap over to a change update\n    if (bufferLocations) {\n      manager.changeInstance(manager, instance, EMPTY, bufferLocations);\n    } else {\n      // Otherwise, we DO need to perform an add and we link a Uniform cluster to our instance\n      const newBufferLocations = manager.layer.bufferManager.add(instance);\n\n      if (isBufferLocationGroup(newBufferLocations)) {\n        instance.active = true;\n\n        if (manager.layer.onDiffAdd) {\n          manager.layer.onDiffAdd(instance);\n        }\n\n        manager.updateInstance(\n          manager.layer,\n          instance,\n          EMPTY,\n          newBufferLocations\n        );\n      }\n    }\n  }\n\n  /**\n   * This processes change operations from changes in the instancing data\n   */\n  changeInstance(\n    manager: this,\n    instance: T,\n    propIds: number[],\n    bufferLocations?: IInstanceAttributeBufferLocationGroup\n  ) {\n    // If there is an existing uniform cluster for this instance, then we can update the bufferLocations\n    if (bufferLocations) {\n      manager.updateInstance(manager.layer, instance, propIds, bufferLocations);\n    } else {\n      // If we don't have existing bufferLocations, then we must add the instance\n      manager.addInstance(manager, instance, EMPTY, bufferLocations);\n    }\n  }\n\n  /**\n   * This processes remove operations from changes in the instancing data\n   */\n  removeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    bufferLocations?: IInstanceAttributeBufferLocationGroup\n  ) {\n    if (bufferLocations) {\n      // We deactivate the instance so it does not render anymore\n      instance.active = false;\n\n      // Execute the remove hook for the instance on behalf of the layer\n      if (manager.layer.onDiffRemove) {\n        manager.layer.onDiffRemove(instance);\n      }\n\n      // We do one last update on the instance to update to it's deactivated state\n      manager.updateInstance(manager.layer, instance, EMPTY, bufferLocations);\n      // Unlink the instance from the uniform cluster\n      manager.layer.bufferManager.remove(instance);\n    }\n  }\n\n  /**\n   * This performs the actual updating of buffers the instance needs to update\n   */\n  updateInstancePartial(\n    _layer: IInstanceDiffManagerTarget<T>,\n    instance: T,\n    propIds: number[],\n    bufferLocations: IBufferLocationGroup<IInstanceAttributeBufferLocation>\n  ) {\n    const propertyToLocation = bufferLocations.propertyToBufferLocation;\n    const bufferAttributeUpdateRange = this.bufferAttributeUpdateRange;\n\n    let location: IInstanceAttributeBufferLocation;\n    let updateValue: Vec | Mat4x4;\n    let updateRange;\n    let childLocations: IInstanceAttributeBufferLocation[];\n    let attribute: IInstanceAttributeInternal<T>;\n    let attributeChangeUID;\n\n    if (instance.active) {\n      // If no prop ids provided, then we perform a complete instance property update\n      if (propIds.length === 0 || instance.reactivate) {\n        propIds = this.bufferManager.getUpdateAllPropertyIdList();\n      }\n\n      for (let i = 0, end = propIds.length; i < end; ++i) {\n        // First update for the instance attribute itself\n        location = propertyToLocation[propIds[i]];\n        // Not finding a location can indicate an observable property changed on the instance that is not used by the\n        // layer\n        if (!location) continue;\n        attribute = location.attribute;\n        attributeChangeUID = attribute.packUID || attribute.uid;\n        updateValue = attribute.update(instance);\n        location.buffer.value.set(updateValue, location.range[0]);\n        updateRange = bufferAttributeUpdateRange[attributeChangeUID] || [\n          null,\n          Number.MAX_SAFE_INTEGER,\n          Number.MIN_SAFE_INTEGER\n        ];\n        updateRange[0] = attribute;\n        updateRange[1] = min(location.range[0], updateRange[1]);\n        updateRange[2] = max(location.range[1], updateRange[2]);\n        bufferAttributeUpdateRange[attributeChangeUID] = updateRange;\n\n        // Now update any child attributes that would need updating based on the parent attribute changing\n        if (location.childLocations) {\n          childLocations = location.childLocations;\n\n          for (let k = 0, endk = childLocations.length; k < endk; ++k) {\n            location = childLocations[k];\n            // Not finding a location can indicate an observable property changed on the instance that is not used by\n            // the layer\n            if (!location) continue;\n            attributeChangeUID =\n              location.attribute.packUID || location.attribute.uid;\n            updateValue = location.attribute.update(instance);\n            location.buffer.value.set(updateValue, location.range[0]);\n            updateRange = bufferAttributeUpdateRange[attributeChangeUID] || [\n              null,\n              Number.MAX_SAFE_INTEGER,\n              Number.MIN_SAFE_INTEGER\n            ];\n            updateRange[0] = location.attribute;\n            updateRange[1] = min(location.range[0], updateRange[1]);\n            updateRange[2] = max(location.range[1], updateRange[2]);\n            bufferAttributeUpdateRange[attributeChangeUID] = updateRange;\n          }\n        }\n      }\n    } else {\n      // When the instance is inactive all we update is the active attribute to false\n      location =\n        propertyToLocation[this.bufferManager.getActiveAttributePropertyId()];\n      attribute = location.attribute;\n      attributeChangeUID = attribute.packUID || attribute.uid;\n      updateValue = attribute.update(instance);\n      location.buffer.value.set(updateValue, location.range[0]);\n      updateRange = bufferAttributeUpdateRange[attributeChangeUID] || [\n        null,\n        Number.MAX_SAFE_INTEGER,\n        Number.MIN_SAFE_INTEGER\n      ];\n      updateRange[0] = attribute;\n      updateRange[1] = min(location.range[0], updateRange[1]);\n      updateRange[2] = max(location.range[1], updateRange[2]);\n      bufferAttributeUpdateRange[attributeChangeUID] = updateRange;\n    }\n\n    // Make sure the instance reactivation process is not executed again\n    instance.reactivate = false;\n  }\n\n  /**\n   * This performs an update on the buffers with the intent the entire buffer is going to update\n   * rather than a chunk of it.\n   */\n  updateInstanceFull(\n    _layer: IInstanceDiffManagerTarget<T>,\n    instance: T,\n    propIds: number[],\n    bufferLocations: IBufferLocationGroup<IInstanceAttributeBufferLocation>\n  ) {\n    const propertyToLocation = bufferLocations.propertyToBufferLocation;\n    const bufferAttributeWillUpdate = this.bufferAttributeWillUpdate;\n\n    let location: IInstanceAttributeBufferLocation;\n    let updateValue: Vec | Mat4x4;\n    let childLocations: IInstanceAttributeBufferLocation[];\n    let attribute: IInstanceAttributeInternal<T>;\n\n    if (instance.active) {\n      // If no prop ids provided, then we perform a complete instance property update\n      if (propIds.length === 0 || instance.reactivate) {\n        propIds = this.bufferManager.getUpdateAllPropertyIdList();\n      }\n\n      for (let i = 0, end = propIds.length; i < end; ++i) {\n        // First update for the instance attribute itself\n        location = propertyToLocation[propIds[i]];\n        // Not finding a location can indicate an observable property changed on the instance that is not used by the\n        // layer\n        if (!location) continue;\n        attribute = location.attribute;\n        updateValue = attribute.update(instance);\n        location.buffer.value.set(updateValue, location.range[0]);\n        bufferAttributeWillUpdate[\n          attribute.packUID || attribute.uid\n        ] = attribute;\n\n        // Now update any child attributes that would need updating based on the parent attribute changing\n        if (location.childLocations) {\n          childLocations = location.childLocations;\n\n          for (let k = 0, endk = childLocations.length; k < endk; ++k) {\n            location = childLocations[k];\n            // Not finding a location can indicate an observable property changed on the instance that is not used by the\n            // layer\n            if (!location) continue;\n            attribute = location.attribute;\n            updateValue = attribute.update(instance);\n            location.buffer.value.set(updateValue, location.range[0]);\n            bufferAttributeWillUpdate[\n              attribute.packUID || attribute.uid\n            ] = attribute;\n          }\n        }\n      }\n    } else {\n      // When the instance is inactive all we update is the active attribute to false\n      location =\n        propertyToLocation[this.bufferManager.getActiveAttributePropertyId()];\n      attribute = location.attribute;\n      updateValue = attribute.update(instance);\n      location.buffer.value.set(updateValue, location.range[0]);\n      bufferAttributeWillUpdate[attribute.packUID || attribute.uid] = attribute;\n    }\n\n    // Make sure the instance reactivation process is not executed again\n    instance.reactivate = false;\n  }\n\n  /**\n   * Finalize all of the buffer changes and apply the correct update ranges\n   */\n  commit() {\n    // If we're in a partial mode: just update the portion of the buffer that needs updating.\n    if (this.diffMode === DiffMode.PARTIAL) {\n      // We now grab all of the attributes and set their update ranges\n      const updates = Object.values(this.bufferAttributeUpdateRange);\n\n      for (let i = 0, end = updates.length; i < end; ++i) {\n        const update = updates[i];\n        const attribute = update[0].bufferAttribute;\n        attribute.updateRange = {\n          count: update[2] - update[1],\n          offset: update[1]\n        };\n      }\n    } else {\n      // Otherwise just update the full buffer\n      // We now grab all of the attributes and set their update ranges\n      const updates = Object.values(this.bufferAttributeWillUpdate);\n\n      for (let i = 0, end = updates.length; i < end; ++i) {\n        const attribute = updates[i].bufferAttribute;\n        attribute.updateRange = {\n          count: -1,\n          offset: 0\n        };\n      }\n    }\n\n    // Clear the attribute update metrics\n    this.bufferAttributeUpdateRange = {};\n  }\n\n  /**\n   * This will optimize the update method used. If there are enough instances being updated, we will\n   * cause the entire attribute buffer to update. If there are not enough, then we will update with\n   * additional steps to only update the chunks of the buffer that are affected by the changelist.\n   */\n  incomingChangeList(changes: InstanceDiff<T>[]) {\n    if (changes.length === 0) {\n      this.diffMode = DiffMode.PARTIAL;\n    } else if (changes.length > this.bufferManager.getInstanceCount() * 0.7) {\n      this.diffMode = DiffMode.FULL;\n    } else {\n      this.diffMode = DiffMode.PARTIAL;\n    }\n\n    if (this.diffMode === DiffMode.PARTIAL) {\n      this.updateInstance = this.updateInstancePartial;\n    } else {\n      this.updateInstance = this.updateInstanceFull;\n    }\n  }\n}\n","import { Instance } from \"../../../instance-provider\";\nimport { Vec4 } from \"../../../math/vector\";\nimport { InstanceDiff } from \"../../../types\";\nimport { BaseDiffProcessor } from \"../base-diff-processor\";\nimport { IInstanceDiffManagerTarget } from \"../instance-diff-manager\";\nimport {\n  isUniformBufferLocation,\n  IUniformBufferLocation\n} from \"./uniform-buffer-manager\";\n\n// This is a mapping of the vector properties as they relate to an array order\nconst EMPTY: number[] = [];\n\n/**\n * Manages diffs for layers that are utilizing the base uniform instancing buffer strategy.\n */\nexport class UniformDiffProcessor<T extends Instance> extends BaseDiffProcessor<\n  T\n> {\n  /**\n   * This processes add operations from changes in the instancing data\n   */\n  addInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster?: IUniformBufferLocation\n  ) {\n    // If the uniform cluster already exists, then we swap over to a change update\n    if (uniformCluster) {\n      manager.changeInstance(manager, instance, EMPTY, uniformCluster);\n    } else {\n      // Otherwise, we DO need to perform an add and we link a Uniform cluster to our instance\n      const uniforms = manager.layer.bufferManager.add(instance);\n\n      if (isUniformBufferLocation(uniforms)) {\n        instance.active = true;\n\n        if (manager.layer.onDiffAdd) {\n          manager.layer.onDiffAdd(instance);\n        }\n\n        manager.updateInstance(manager.layer, instance, uniforms);\n      }\n    }\n  }\n\n  /**\n   * This processes change operations from changes in the instancing data\n   */\n  changeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster?: IUniformBufferLocation\n  ) {\n    // If there is an existing uniform cluster for this instance, then we can update the uniforms\n    if (uniformCluster) {\n      manager.updateInstance(manager.layer, instance, uniformCluster);\n    } else {\n      // If we don't have existing uniforms, then we must remove the instance\n      manager.addInstance(manager, instance, EMPTY, uniformCluster);\n    }\n  }\n\n  /**\n   * This processes remove operations from changes in the instancing data\n   */\n  removeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster?: IUniformBufferLocation\n  ) {\n    if (uniformCluster) {\n      // We deactivate the instance so it does not render anymore\n      instance.active = false;\n\n      // Execute the remove hook for the instance on behalf of the layer\n      if (manager.layer.onDiffRemove) {\n        manager.layer.onDiffRemove(instance);\n      }\n\n      // We do one last update on the instance to update to it's deactivated state\n      manager.updateInstance(manager.layer, instance, uniformCluster);\n      // Unlink the instance from the uniform cluster\n      manager.layer.bufferManager.remove(instance);\n    }\n  }\n\n  /**\n   * TODO: We should be updating based on prop ids instead of always updating all props for every change.\n   *\n   * This performs the actual updating of buffers the instance needs to update\n   */\n  updateInstance(\n    layer: IInstanceDiffManagerTarget<T>,\n    instance: T,\n    uniformCluster: IUniformBufferLocation\n  ) {\n    if (instance.active) {\n      const uniforms = uniformCluster.buffer;\n      const uniformRangeStart = uniformCluster.range[0];\n      const instanceData: Vec4[] = uniforms.value;\n      let instanceUniform, value, block, start;\n      let k: number, endk;\n\n      // Loop through the instance attributes and update the uniform cluster with the values\n      // Calculated for the instance\n      for (\n        let i = 0, end = layer.shaderIOInfo.instanceAttributes.length;\n        i < end;\n        ++i\n      ) {\n        instanceUniform = layer.shaderIOInfo.instanceAttributes[i];\n        value = instanceUniform.update(instance);\n        block = instanceData[uniformRangeStart + (instanceUniform.block || 0)];\n        start = instanceUniform.blockIndex;\n\n        if (start === undefined) {\n          continue;\n        }\n\n        // Vec4 updating routine. Makes sure the correct components are updated for the provided values\n        for (k = start, endk = value.length + start; k < endk; ++k) {\n          block[k] = value[k - start];\n        }\n      }\n\n      uniforms.value = instanceData;\n    } else {\n      const uniforms = uniformCluster.buffer;\n      const uniformRangeStart = uniformCluster.range[0];\n      const instanceData: Vec4[] = uniforms.value;\n      let instanceUniform, value, block, start;\n\n      // Only update the _active attribute to ensure it is false. When it is false, there is no\n      // Point to updating any other uniform\n      instanceUniform = layer.shaderIOInfo.activeAttribute;\n      value = instanceUniform.update(instance);\n      block = instanceData[uniformRangeStart + (instanceUniform.block || 0)];\n      start = instanceUniform.blockIndex;\n\n      if (start !== undefined) {\n        // Hyper optimized vector filling routine. It uses properties that are globally scoped\n        // To greatly reduce overhead\n        for (\n          let k: number = start, endk = value.length + start;\n          k < endk;\n          ++k\n        ) {\n          block[k] = value[k - start];\n        }\n      }\n\n      uniforms.value = instanceData;\n    }\n  }\n\n  /**\n   * Right now there is no operations for committing for the uniform manager.\n   */\n  commit() {\n    /** no-op */\n  }\n\n  /**\n   * There are no optimizations available for this processor yet.\n   */\n  incomingChangeList(_changes: InstanceDiff<T>[]) {\n    /** no-op */\n  }\n}\n","module.exports = \"varying highp vec4 _picking_color_pass_;\\nvoid main() {\\n${out: _picking_fragment_} = _picking_color_pass_;\\n}\"","import { normalizeWheel } from \"./normalizeWheel\";\n\nexport { normalizeWheel };\n","/**\n  BSD License\n\n  Copyright (c) 2015, Facebook, Inc. All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without modification,\n  are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n  * Neither the name Facebook nor the names of its contributors may be used to\n    endorse or promote products derived from this software without specific\n    prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\"use strict\";\n\nconst UserAgent_DEPRECATED = require(\"./UserAgent_DEPRECATED\");\n\nconst isEventSupported = require(\"./isEventSupported\");\n\n// Reasonable defaults\nconst PIXEL_STEP = 10;\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\n\n/**\n * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is\n * complicated, thus this doc is long and (hopefully) detailed enough to answer\n * your questions.\n *\n * If you need to react to the mouse wheel in a predictable way, this code is\n * like your bestest friend. * hugs *\n *\n * As of today, there are 4 DOM event types you can listen to:\n *\n *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)\n *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari\n *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!\n *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003\n *\n * So what to do?  The is the best:\n *\n *   normalizeWheel.getEventType();\n *\n * In your event callback, use this code to get sane interpretation of the\n * deltas.  This code will return an object with properties:\n *\n *   spinX   -- normalized spin speed (use for zoom) - x plane\n *   spinY   -- \" - y plane\n *   pixelX  -- normalized distance (to pixels) - x plane\n *   pixelY  -- \" - y plane\n *\n * Wheel values are provided by the browser assuming you are using the wheel to\n * scroll a web page by a number of lines or pixels (or pages).  Values can vary\n * significantly on different platforms and browsers, forgetting that you can\n * scroll at different speeds.  Some devices (like trackpads) emit more events\n * at smaller increments with fine granularity, and some emit massive jumps with\n * linear speed or acceleration.\n *\n * This code does its best to normalize the deltas for you:\n *\n *   - spin is trying to normalize how far the wheel was spun (or trackpad\n *     dragged).  This is super useful for zoom support where you want to\n *     throw away the chunky scroll steps on the PC and make those equal to\n *     the slow and smooth tiny steps on the Mac. Key data: This code tries to\n *     resolve a single slow step on a wheel to 1.\n *\n *   - pixel is normalizing the desired scroll delta in pixel units.  You'll\n *     get the crazy differences between browsers, but at least it'll be in\n *     pixels!\n *\n *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This\n *     should translate to positive value zooming IN, negative zooming OUT.\n *     This matches the newer 'wheel' event.\n *\n * Why are there spinX, spinY (or pixels)?\n *\n *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn\n *     with a mouse.  It results in side-scrolling in the browser by default.\n *\n *   - spinY is what you expect -- it's the classic axis of a mouse wheel.\n *\n *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and\n *     probably is by browsers in conjunction with fancy 3D controllers .. but\n *     you know.\n *\n * Implementation info:\n *\n * Examples of 'wheel' event if you scroll slowly (down) by one step with an\n * average mouse:\n *\n *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)\n *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)\n *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)\n *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)\n *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)\n *\n * On the trackpad:\n *\n *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)\n *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)\n *\n * On other/older browsers.. it's more complicated as there can be multiple and\n * also missing delta values.\n *\n * The 'wheel' event is more standard:\n *\n * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents\n *\n * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and\n * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain\n * backward compatibility with older events.  Those other values help us\n * better normalize spin speed.  Example of what the browsers provide:\n *\n *                          | event.wheelDelta | event.detail\n *        ------------------+------------------+--------------\n *          Safari v5/OS X  |       -120       |       0\n *          Safari v5/Win7  |       -120       |       0\n *         Chrome v17/OS X  |       -120       |       0\n *         Chrome v17/Win7  |       -120       |       0\n *                IE9/Win7  |       -120       |   undefined\n *         Firefox v4/OS X  |     undefined    |       1\n *         Firefox v4/Win7  |     undefined    |       3\n *\n */\nexport function normalizeWheel(/*object*/ event: any) /*object*/ {\n  let sX = 0,\n    sY = 0, // spinX, spinY\n    pX = 0,\n    pY = 0; // pixelX, pixelY\n\n  // Legacy\n  if (\"detail\" in event) {\n    sY = event.detail;\n  }\n  if (\"wheelDelta\" in event) {\n    sY = -event.wheelDelta / 120;\n  }\n  if (\"wheelDeltaY\" in event) {\n    sY = -event.wheelDeltaY / 120;\n  }\n  if (\"wheelDeltaX\" in event) {\n    sX = -event.wheelDeltaX / 120;\n  }\n\n  // side scrolling on FF with DOMMouseScroll\n  if (\"axis\" in event && event.axis === event.HORIZONTAL_AXIS) {\n    sX = sY;\n    sY = 0;\n  }\n\n  pX = sX * PIXEL_STEP;\n  pY = sY * PIXEL_STEP;\n\n  if (\"deltaY\" in event) {\n    pY = event.deltaY;\n  }\n  if (\"deltaX\" in event) {\n    pX = event.deltaX;\n  }\n\n  if ((pX || pY) && event.deltaMode) {\n    if (event.deltaMode === 1) {\n      // delta in LINE units\n      pX *= LINE_HEIGHT;\n      pY *= LINE_HEIGHT;\n    } else {\n      // delta in PAGE units\n      pX *= PAGE_HEIGHT;\n      pY *= PAGE_HEIGHT;\n    }\n  }\n\n  // Fall-back if spin cannot be determined\n  if (pX && !sX) {\n    sX = pX < 1 ? -1 : 1;\n  }\n  if (pY && !sY) {\n    sY = pY < 1 ? -1 : 1;\n  }\n\n  return {\n    spinX: sX,\n    spinY: -sY,\n    pixelX: pX,\n    pixelY: -pY\n  };\n}\n\n/**\n * The best combination if you prefer spinX + spinY normalization.  It favors\n * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with\n * 'wheel' event, making spin speed determination impossible.\n */\nnormalizeWheel.getEventType = function() /*string*/ {\n  return UserAgent_DEPRECATED.firefox()\n    ? \"DOMMouseScroll\"\n    : isEventSupported(\"wheel\")\n    ? \"wheel\"\n    : \"mousewheel\";\n};\n","/**\n  BSD License\n\n  Copyright (c) 2015, Facebook, Inc. All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without modification,\n  are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n  * Neither the name Facebook nor the names of its contributors may be used to\n    endorse or promote products derived from this software without specific\n    prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n *  Provides entirely client-side User Agent and OS detection. You should prefer\n *  the non-deprecated UserAgent module when possible, which exposes our\n *  authoritative server-side PHP-based detection to the client.\n *\n *  Usage is straightforward:\n *\n *    if (UserAgent_DEPRECATED.ie()) {\n *      //  IE\n *    }\n *\n *  You can also do version checks:\n *\n *    if (UserAgent_DEPRECATED.ie() >= 7) {\n *      //  IE7 or better\n *    }\n *\n *  The browser functions will return NaN if the browser does not match, so\n *  you can also do version compares the other way:\n *\n *    if (UserAgent_DEPRECATED.ie() < 7) {\n *      //  IE6 or worse\n *    }\n *\n *  Note that the version is a float and may include a minor version number,\n *  so you should always use range operators to perform comparisons, not\n *  strict equality.\n *\n *  **Note:** You should **strongly** prefer capability detection to browser\n *  version detection where it's reasonable:\n *\n *    http://www.quirksmode.org/js/support.html\n *\n *  Further, we have a large number of mature wrapper functions and classes\n *  which abstract away many browser irregularities. Check the documentation,\n *  grep for things, or ask on javascript@lists.facebook.com before writing yet\n *  another copy of \"event || window.event\".\n *\n */\n\nvar _populated = false;\n\n// Browsers\nvar _ie, _firefox, _opera, _webkit, _chrome;\n\n// Actual IE browser for compatibility mode\nvar _ie_real_version;\n\n// Platforms\nvar _osx, _windows, _linux, _android;\n\n// Architectures\nvar _win64;\n\n// Devices\nvar _iphone, _ipad, _native;\n\nvar _mobile;\n\nfunction _populate() {\n  if (_populated) {\n    return;\n  }\n\n  _populated = true;\n\n  // To work around buggy JS libraries that can't handle multi-digit\n  // version numbers, Opera 10's user agent string claims it's Opera\n  // 9, then later includes a Version/X.Y field:\n  //\n  // Opera/9.80 (foo) Presto/2.2.15 Version/10.10\n  var uas = navigator.userAgent;\n  var agent = /(?:MSIE.(\\d+\\.\\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\\d+\\.\\d+))|(?:Opera(?:.+Version.|.)(\\d+\\.\\d+))|(?:AppleWebKit.(\\d+(?:\\.\\d+)?))|(?:Trident\\/\\d+\\.\\d+.*rv:(\\d+\\.\\d+))/.exec(\n    uas\n  );\n  var os = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);\n\n  _iphone = /\\b(iPhone|iP[ao]d)/.exec(uas);\n  _ipad = /\\b(iP[ao]d)/.exec(uas);\n  _android = /Android/i.exec(uas);\n  _native = /FBAN\\/\\w+;/i.exec(uas);\n  _mobile = /Mobile/i.exec(uas);\n\n  // Note that the IE team blog would have you believe you should be checking\n  // for 'Win64; x64'.  But MSDN then reveals that you can actually be coming\n  // from either x64 or ia64;  so ultimately, you should just check for Win64\n  // as in indicator of whether you're in 64-bit IE.  32-bit IE on 64-bit\n  // Windows will send 'WOW64' instead.\n  _win64 = !!/Win64/.exec(uas);\n\n  if (agent) {\n    _ie = agent[1]\n      ? parseFloat(agent[1])\n      : agent[5]\n        ? parseFloat(agent[5])\n        : NaN;\n    // IE compatibility mode\n    if (_ie && document && document.documentMode) {\n      _ie = document.documentMode;\n    }\n    // grab the \"true\" ie version from the trident token if available\n    var trident = /(?:Trident\\/(\\d+.\\d+))/.exec(uas);\n    _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;\n\n    _firefox = agent[2] ? parseFloat(agent[2]) : NaN;\n    _opera = agent[3] ? parseFloat(agent[3]) : NaN;\n    _webkit = agent[4] ? parseFloat(agent[4]) : NaN;\n    if (_webkit) {\n      // We do not add the regexp to the above test, because it will always\n      // match 'safari' only since 'AppleWebKit' appears before 'Chrome' in\n      // the userAgent string.\n      agent = /(?:Chrome\\/(\\d+\\.\\d+))/.exec(uas);\n      _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;\n    } else {\n      _chrome = NaN;\n    }\n  } else {\n    _ie = _firefox = _opera = _chrome = _webkit = NaN;\n  }\n\n  if (os) {\n    if (os[1]) {\n      // Detect OS X version.  If no version number matches, set _osx to true.\n      // Version examples:  10, 10_6_1, 10.7\n      // Parses version number as a float, taking only first two sets of\n      // digits.  If only one set of digits is found, returns just the major\n      // version number.\n      var ver = /(?:Mac OS X (\\d+(?:[._]\\d+)?))/.exec(uas);\n\n      _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;\n    } else {\n      _osx = false;\n    }\n    _windows = !!os[2];\n    _linux = !!os[3];\n  } else {\n    _osx = _windows = _linux = false;\n  }\n}\n\nvar UserAgent_DEPRECATED = {\n  /**\n   *  Check if the UA is Internet Explorer.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  ie: function() {\n    return _populate() || _ie;\n  },\n\n  /**\n   * Check if we're in Internet Explorer compatibility mode.\n   *\n   * @return bool true if in compatibility mode, false if\n   * not compatibility mode or not ie\n   */\n  ieCompatibilityMode: function() {\n    return _populate() || _ie_real_version > _ie;\n  },\n\n  /**\n   * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we\n   * only need this because Skype can't handle 64-bit IE yet.  We need to remove\n   * this when we don't need it -- tracked by #601957.\n   */\n  ie64: function() {\n    return UserAgent_DEPRECATED.ie() && _win64;\n  },\n\n  /**\n   *  Check if the UA is Firefox.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  firefox: function() {\n    return _populate() || _firefox;\n  },\n\n  /**\n   *  Check if the UA is Opera.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  opera: function() {\n    return _populate() || _opera;\n  },\n\n  /**\n   *  Check if the UA is WebKit.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  webkit: function() {\n    return _populate() || _webkit;\n  },\n\n  /**\n   *  For Push\n   *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit\n   */\n  safari: function() {\n    return UserAgent_DEPRECATED.webkit();\n  },\n\n  /**\n   *  Check if the UA is a Chrome browser.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  chrome: function() {\n    return _populate() || _chrome;\n  },\n\n  /**\n   *  Check if the user is running Windows.\n   *\n   *  @return bool `true' if the user's OS is Windows.\n   */\n  windows: function() {\n    return _populate() || _windows;\n  },\n\n  /**\n   *  Check if the user is running Mac OS X.\n   *\n   *  @return float|bool   Returns a float if a version number is detected,\n   *                       otherwise true/false.\n   */\n  osx: function() {\n    return _populate() || _osx;\n  },\n\n  /**\n   * Check if the user is running Linux.\n   *\n   * @return bool `true' if the user's OS is some flavor of Linux.\n   */\n  linux: function() {\n    return _populate() || _linux;\n  },\n\n  /**\n   * Check if the user is running on an iPhone or iPod platform.\n   *\n   * @return bool `true' if the user is running some flavor of the\n   *    iPhone OS.\n   */\n  iphone: function() {\n    return _populate() || _iphone;\n  },\n\n  mobile: function() {\n    return _populate() || (_iphone || _ipad || _android || _mobile);\n  },\n\n  nativeApp: function() {\n    // webviews inside of the native apps\n    return _populate() || _native;\n  },\n\n  android: function() {\n    return _populate() || _android;\n  },\n\n  ipad: function() {\n    return _populate() || _ipad;\n  },\n};\n\nmodule.exports = UserAgent_DEPRECATED;\n","/**\n  BSD License\n\n  Copyright (c) 2015, Facebook, Inc. All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without modification,\n  are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n  * Neither the name Facebook nor the names of its contributors may be used to\n    endorse or promote products derived from this software without specific\n    prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n'use strict';\n\nvar ExecutionEnvironment = require('./ExecutionEnvironment');\n\nvar useHasFeature;\nif (ExecutionEnvironment.canUseDOM) {\n  useHasFeature =\n    document.implementation &&\n    document.implementation.hasFeature &&\n    // always returns true in newer browsers as per the standard.\n    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n    document.implementation.hasFeature('', '') !== true;\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @param {?boolean} capture Check if the capture phase is supported.\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nfunction isEventSupported(eventNameSuffix, capture) {\n  if (\n    !ExecutionEnvironment.canUseDOM ||\n    (capture && !('addEventListener' in document))\n  ) {\n    return false;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = eventName in document;\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\n\nmodule.exports = isEventSupported;\n","/**\n  BSD License\n\n  Copyright (c) 2015, Facebook, Inc. All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without modification,\n  are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n  * Neither the name Facebook nor the names of its contributors may be used to\n    endorse or promote products derived from this software without specific\n    prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n'use strict';\n\nvar canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners:\n    canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM, // For now, this is true - might change in the future.\n};\n\nmodule.exports = ExecutionEnvironment;\n","// Shader mdoules have no exports and should simply be imported to execute their registration\nimport \"./world-2d.shader\";\n","import { ShaderModule } from \"../../shaders/processing\";\nimport { Layer } from \"../../surface\";\nimport { ShaderInjectionTarget, UniformSize } from \"../../types\";\nimport { Camera2D } from \"../view/camera-2d\";\nimport { Layer2D } from \"../view/layer-2d\";\n\nconst doc = `\nThese are projection methods and camera\nrelated constants associated with a\nView2D.\n\nMethods:\nvec3 cameraSpace(vec3 world);\nvec3 cameraSpaceSize(vec3 worldSize);\nvec4 clipSpace(vec3 world);\nvec4 clipSpaceSize(vec3 worldSize);\n\nConstants:\nmat4 projection;\nmat4 view;\nmat4 viewProjection;\nvec3 cameraOffset;\nvec3 cameraPosition;\nvec3 cameraScale;\nvec3 cameraScale2D;\nvec3 cameraRotation;\nvec2 viewSize;\nfloat pixelRatio;\n`;\n\n/**\n * This module provides uniforms for retrieving camera propeerties within the shader.\n */\nShaderModule.register([\n  {\n    moduleId: \"world2D\",\n    description: doc,\n    content: require(\"./shader-fragments/world-2d-projection.vs\"),\n    compatibility: ShaderInjectionTarget.ALL,\n\n    uniforms: (layer: Layer<any, any>) => {\n      if (!(layer instanceof Layer2D)) {\n        console.warn(\n          \"A shader requested the module world2D; however, the layer the shader comes from is NOT a Layer2D which is\",\n          \"required for the module to work.\"\n        );\n        return [];\n      }\n\n      return [\n        // This injects the projection matrix from the view camera\n        {\n          name: \"projection\",\n          size: UniformSize.MATRIX4,\n          update: () => layer.view.props.camera.projection\n        },\n        // This injects the model view matrix from the view camera\n        {\n          name: \"view\",\n          size: UniformSize.MATRIX4,\n          update: () => layer.view.props.camera.view\n        },\n        {\n          name: \"viewProjection\",\n          size: UniformSize.MATRIX4,\n          update: () => layer.view.props.camera.viewProjection\n        },\n        // This injects a 2D camera's offset\n        {\n          name: \"cameraOffset\",\n          size: UniformSize.THREE,\n          update: () =>\n            layer.view.props.camera instanceof Camera2D\n              ? layer.view.props.camera.control2D.offset\n              : [0, 0, 0]\n        },\n        // This injects the camera's current position\n        {\n          name: \"cameraPosition\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.position\n        },\n        // This injects the camera's current scale\n        {\n          name: \"cameraScale\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.scale\n        },\n        // This injects the camera's 2D current scale\n        {\n          name: \"cameraScale2D\",\n          size: UniformSize.THREE,\n          update: () =>\n            layer.view.props.camera instanceof Camera2D\n              ? layer.view.props.camera.scale2D\n              : [1, 1, 1]\n        },\n        // This injects the camera's Euler rotation\n        {\n          name: \"cameraRotation\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.scale\n        },\n        // This injects the pixel width and height of the view\n        {\n          name: \"viewSize\",\n          size: UniformSize.TWO,\n          update: () => [\n            layer.view.viewBounds.width,\n            layer.view.viewBounds.height\n          ]\n        },\n        // This injects the current layer's pixel ratio so pixel ratio dependent\n        // items can react to it Things like gl_PointSize will need this metric\n        // if not working in clip space\n        {\n          name: \"pixelRatio\",\n          size: UniformSize.ONE,\n          update: () => [layer.view.pixelRatio]\n        }\n      ];\n    }\n  }\n]);\n","import { EventManager } from \"../event-management/event-manager\";\nimport { UserInputEventManager } from \"../event-management/user-input-event-manager\";\nimport { isOffscreenCanvas, RenderTarget, Scene } from \"../gl\";\nimport { WebGLRenderer } from \"../gl/webgl-renderer\";\nimport { Instance } from \"../instance-provider/instance\";\nimport { BaseProjection } from \"../math\";\nimport { getAbsolutePositionBounds } from \"../math/primitives/absolute-position\";\nimport { Bounds } from \"../math/primitives/bounds\";\nimport { Vec4 } from \"../math/vector\";\nimport {\n  BaseResourceManager,\n  BaseResourceOptions,\n  BaseResourceRequest,\n  FontResourceManager,\n  ResourceRouter\n} from \"../resources\";\nimport { ColorBufferResourceManager } from \"../resources/color-buffer\";\nimport { AtlasResourceManager } from \"../resources/texture/atlas-resource-manager\";\nimport { RenderTextureResourceManager } from \"../resources/texture/render-texture-resource-manager\";\nimport { BaseIOSorting } from \"../shaders/processing/base-io-sorting\";\nimport { BaseShaderTransform } from \"../shaders/processing/base-shader-transform\";\nimport { ActiveIOExpansion } from \"../surface/layer-processing/base-io-expanders/active-io-expansion\";\nimport {\n  FragmentOutputType,\n  FrameMetrics,\n  ResourceType,\n  SurfaceErrorType\n} from \"../types\";\nimport {\n  IdentifiableById,\n  IInstanceAttribute,\n  IPipeline,\n  IResourceType\n} from \"../types\";\nimport { onFrame, PromiseResolver } from \"../util\";\nimport { ReactiveDiff } from \"../util/reactive-diff\";\nimport { LayerMouseEvents } from \"./event-managers/layer-mouse-events\";\nimport { Layer } from \"./layer\";\nimport { BasicIOExpansion } from \"./layer-processing/base-io-expanders/basic-io-expansion\";\nimport { EasingIOExpansion } from \"./layer-processing/base-io-expanders/easing-io-expansion\";\nimport { BaseIOExpansion } from \"./layer-processing/base-io-expansion\";\nimport { Shaders30CompatibilityTransform } from \"./layer-processing/base-shader-transforms/shaders-30-compatibility-transform\";\nimport { ISceneOptions, LayerScene } from \"./layer-scene\";\nimport { SurfaceCommands } from \"./surface-commands\";\nimport { ClearFlags, IViewProps, View } from \"./view\";\n\n/**\n * Default IO expansion controllers applied to the system when explicit settings\n * are not provided.\n */\nexport const DEFAULT_IO_EXPANSION: BaseIOExpansion[] = [\n  // Basic expansion to handle writing attributes and uniforms to the shader\n  new BasicIOExpansion(),\n  // Expansion to write in the active attribute handler. Any expansion injected AFTER\n  // this expander will have it's processes canceled out for the destructuring portion\n  // of the expansion when an instance is not active (if the instance has an\n  // active\n  // attribute).\n  new ActiveIOExpansion(),\n  // Expansion to handle easing IO attributes and write AutoEasingMethods to the\n  // shaders\n  new EasingIOExpansion()\n];\n\n/**\n * Default resource managers the system will utilize to handle default / basic resources.\n */\nexport const DEFAULT_RESOURCE_MANAGEMENT: ISurfaceOptions[\"resourceManagers\"] = [\n  {\n    type: ResourceType.COLOR_BUFFER,\n    manager: new ColorBufferResourceManager()\n  },\n  {\n    type: ResourceType.TEXTURE,\n    manager: new RenderTextureResourceManager()\n  },\n  {\n    type: ResourceType.ATLAS,\n    manager: new AtlasResourceManager({})\n  },\n  {\n    type: ResourceType.FONT,\n    manager: new FontResourceManager()\n  }\n];\n\nexport const DEFAULT_SHADER_TRANSFORM: BaseShaderTransform[] = [\n  // Transform that handles odds and ends of 3.0 and 2.0 inconsistencies and\n  // attempts tp unify them as best as possible depending on the current\n  // system's operating mode.\n  new Shaders30CompatibilityTransform()\n];\n\n/**\n * Options for generating a new layer surface.\n */\nexport interface ISurfaceOptions {\n  /**\n   * Provides the context the surface will use while rendering\n   */\n  context?: HTMLCanvasElement;\n  /**\n   * This is the event managers to respond to the mouse events.\n   */\n  eventManagers?: EventManager[];\n  /**\n   * Set to true to allow this surface to absorb and handle wheel events from\n   * the mouse.\n   */\n  handlesWheelEvents?: boolean;\n  /**\n   * Provides additional expansion controllers that will contribute to our\n   * Shader IO configuration for the layers. If this is not provided, this\n   * defaults to default system behaviors.\n   *\n   * To add additional Expansion controllers and keep default system controllers\n   * utilize a Function instead:\n   *\n   * ioExpansion: (defaultExpanders: BaseIOExpansion) => [...defaultExpanders,\n   * <your own expanders>]\n   *\n   * For instance: easing properties on attributes requires the attribute to be\n   * expanded to additional attributes + modified behavior of the base\n   * attribute. Thus the system by default adds in the EasinggIOExpansion\n   * controller when this is not provided to make those property types work.\n   */\n  ioExpansion?:\n    | BaseIOExpansion[]\n    | ((defaultExpanders: BaseIOExpansion[]) => BaseIOExpansion[]);\n  /**\n   * If this is defined, this causes the specified targets to NOT render UNLESS\n   * expressly told to render utilizing enableOutput\n   */\n  optimizedOutputTargets?: number[];\n  /**\n   * This specifies the density of rendering in the surface. The default value\n   * is window.devicePixelRatio to match the monitor for optimal clarity. Using\n   * a value of 1 will be acceptable, will not get high density renders, but\n   * will have better performance if needed.\n   */\n  pixelRatio?: number;\n  /**\n   * Sets some options for the renderer which deals with top level settings that\n   * can only be set when the context is retrieved\n   */\n  rendererOptions?: {\n    /**\n     * This indicates the back buffer for the webgl context will have an alpha\n     * channel. This affects performance some, but is mainly for the DOM\n     * compositing the canvas with the other DOM elements.\n     */\n    alpha?: boolean;\n    /**\n     * Hardware antialiasing. Disabled by default. Enabled makes things\n     * prettier but slower.\n     */\n    antialias?: boolean;\n    /**\n     * This tells the browser what to expect from the colors rendered into the\n     * canvas. This will affect how compositing the canvas with the rest of the\n     * DOM will be accomplished. This should match the color values being\n     * written to the final FBO target (render target null). If incorrect,\n     * bizarre color blending with the DOM can occur.\n     */\n    premultipliedAlpha?: boolean;\n    /**\n     * This sets what the browser will do with the target frame buffer object\n     * after it's done using it for compositing. If you wish to take a snap shot\n     * of the canvas being rendered into, this must be true. This has the\n     * potential to hurt performance, thus it is disabled by default.\n     */\n    preserveDrawingBuffer?: boolean;\n  };\n  /**\n   * This specifies the resource managers that will be applied to the surface.\n   * If this is not provided, this will default to DEFAULT_RESOURCE_MANAGEMENT.\n   *\n   * To add additional managers to the default framework:\n   * [\n   *   ...DEFAULT_RESOURCE_MANAGEMENT, <your own resource managers>\n   * ]\n   *\n   * Resource managers handle a layer's requests for a resource\n   * (this.resource.request(layer, instance, requestObject)) during update\n   * cycles of the attributes.\n   */\n  resourceManagers?: {\n    type: number;\n    manager: BaseResourceManager<IResourceType, BaseResourceRequest>;\n  }[];\n  /**\n   * Provides last step processing of shaders after all system adjustments and\n   * settings have been applied to the Shader.\n   *\n   * This is a raw string processing transformation and will NOT provide any\n   * insights into the settings of the Surface down to the layer that built this\n   * shader.\n   */\n  shaderTransforms?:\n    | BaseShaderTransform[]\n    | ((defaultExpanders: BaseShaderTransform[]) => BaseShaderTransform[]);\n}\n\n/**\n * If a view does not specify a background color, this is the color that will be cleared to\n * when the color buffer is cleared for the view\n */\nconst DEFAULT_BACKGROUND_COLOR: Vec4 = [0.0, 0.0, 0.0, 0.0];\n\n/**\n * Helper enum to select which method to broadcast.\n */\nenum EventManagerBroadcastCycle {\n  WILL_RENDER,\n  DID_RENDER\n}\n\n/**\n * Sort method for any object with an 'order' property\n */\nfunction sortByOrder<T extends { order?: number }>(a: T, b: T) {\n  return (\n    (a.order || Number.MAX_SAFE_INTEGER) - (b.order || Number.MAX_SAFE_INTEGER)\n  );\n}\n\n/**\n * This is a render controller for managing GPU rendering techniques via a layering system. This is the entry object\n * that contains and monitors all resources for performing the GPU actions.\n */\nexport class Surface {\n  /** This is the gl context this surface is rendering to */\n  private context: WebGLRenderingContext;\n  /**\n   * Available commands from the surface that triggers events or triggers\n   * direct GPU operations.\n   */\n  commands = new SurfaceCommands({ surface: this });\n  /**\n   * This is the metrics of the current running frame\n   */\n  frameMetrics: FrameMetrics = {\n    currentFrame: 0,\n    currentTime: Date.now() | 0,\n    frameDuration: 1000 / 60,\n    previousTime: Date.now() | 0\n  };\n  /**\n   * This is used to help resolve concurrent draws and resolving resource\n   * request dequeue operations.\n   */\n  private isBufferingResources = false;\n  /** These are the registered expanders of Shader IO configuration */\n  private ioExpanders: BaseIOExpansion[] = [];\n  /** These are the registered transforms for shaders */\n  private shaderTransforms: BaseShaderTransform[] = [];\n  /**\n   * These are the registered output targets that get disabled by default. They\n   * must be explicitly enabled with the method enableOptimizedOutput.\n   */\n  private optimizedOutputs = new Set<number>([FragmentOutputType.PICKING]);\n  /**\n   * This is the sorting controller for sorting attributes/uniforms of a layer\n   * after all the attributes have been generated that are needed\n   */\n  ioSorting = new BaseIOSorting();\n  /** This manages the mouse events for the current canvas context */\n  userInputManager: UserInputEventManager;\n  /** This is the density the rendering renders for the surface */\n  pixelRatio: number = window.devicePixelRatio;\n  /** This is the GL render system we use to render scenes with views */\n  renderer: WebGLRenderer;\n  /**\n   * This is the resource manager that handles resource requests for instances\n   */\n  resourceManager: ResourceRouter;\n  /**\n   * When defined, the next render will make sure color picking is updated\n   * for layer interactions\n   */\n  private enabledOptimizedOutputs = new Set<number>();\n  /**\n   * This map is a quick look up for a view to determine other views that\n   * would need to be redrawn as a consequence of the key view needing a redraw.\n   */\n  private viewDrawDependencies = new Map<\n    View<IViewProps>,\n    View<IViewProps>[]\n  >();\n  /**\n   * This is used to indicate the surface has loaded it's initial systems. This\n   * is complete after init has executed successfully for this surface.\n   */\n  ready: Promise<Surface>;\n  /** This is used to reolve this surface as ready */\n  private readyResolver: PromiseResolver<Surface>;\n\n  /** Diff manager to handle diffing resource objects for the pipeline */\n  resourceDiffs: ReactiveDiff<\n    IdentifiableById,\n    BaseResourceOptions\n  > = new ReactiveDiff({\n    buildItem: async (initializer: BaseResourceOptions) => {\n      await this.resourceManager.initResource(initializer);\n\n      return {\n        id: initializer.key\n      };\n    },\n\n    destroyItem: async (\n      initializer: BaseResourceOptions,\n      _item: IdentifiableById\n    ) => {\n      await this.resourceManager.destroyResource(initializer);\n\n      return true;\n    },\n\n    updateItem: async (\n      initializer: BaseResourceOptions,\n      _item: IdentifiableById\n    ) => {\n      await this.resourceManager.updateResource(initializer);\n    }\n  });\n\n  /** Diff manager to handle diffing scene objects for the pipeline */\n  sceneDiffs: ReactiveDiff<LayerScene, ISceneOptions> = new ReactiveDiff({\n    buildItem: async (initializer: ISceneOptions) => {\n      const scene = new LayerScene(this, {\n        key: initializer.key,\n        views: initializer.views,\n        layers: initializer.layers\n      });\n\n      return scene;\n    },\n\n    destroyItem: async (_initializer: ISceneOptions, item: LayerScene) => {\n      item.destroy();\n      return true;\n    },\n\n    updateItem: async (initializer: ISceneOptions, item: LayerScene) => {\n      await item.update(initializer);\n    }\n  });\n\n  constructor(options?: ISurfaceOptions) {\n    this.readyResolver = new PromiseResolver();\n    this.ready = this.readyResolver.promise;\n\n    if (options) {\n      this.init(options);\n    }\n  }\n\n  /** Read only getter for the gl context */\n  get gl() {\n    return this.context;\n  }\n\n  /** Get all of the scenes for this surface */\n  get scenes() {\n    return this.sceneDiffs.items;\n  }\n\n  /**\n   * Broadcasts a cycle event to all event managers.\n   */\n  private broadcastEventManagerCycle(event: EventManagerBroadcastCycle) {\n    // Resolve event managers reaction cycles\n    for (\n      let i = 0, iMax = this.userInputManager.eventManagers.length;\n      i < iMax;\n      ++i\n    ) {\n      const eventManager = this.userInputManager.eventManagers[i];\n\n      switch (event) {\n        case EventManagerBroadcastCycle.DID_RENDER:\n          eventManager.didRender();\n          break;\n\n        case EventManagerBroadcastCycle.WILL_RENDER:\n          eventManager.willRender();\n          break;\n      }\n    }\n  }\n\n  /**\n   * The performs all of the needed updates that layers need to commit to the scene and buffers\n   * to be ready for a draw pass. This is callable outside of the draw loop to allow for specialized\n   * procedures or optimizations to take place, where incremental updates to the buffers would make\n   * the most sense.\n   *\n   * @param time The start time of the given frame\n   * @param frameIncrement When true, the frame count for the frame metrics will increment\n   * @param onViewReady Callback for when all of the layers of a scene view have been committed\n   *                    and are thus potentially ready to be rendered.\n   */\n  async commit(\n    time?: number,\n    frameIncrement?: boolean,\n    onViewReady?: (\n      needsDraw: boolean,\n      scene: LayerScene,\n      view: View<IViewProps>\n    ) => void\n  ) {\n    if (!this.gl) return;\n\n    // For now, while certain mysteries remain, we will track only if any view needs to be redrawn.\n    // Any view that needs to be redrawn will trigger a redraw of the entire surface for now until\n    // we can optimize down to only drawing a single view without erasing views that were not redrawn.\n    let needsDraw = false;\n\n    // We are rendering a new frame so increment our frame count\n    if (frameIncrement) this.frameMetrics.currentFrame++;\n    this.frameMetrics.frameDuration =\n      this.frameMetrics.currentTime - this.frameMetrics.previousTime;\n    this.frameMetrics.previousTime = this.frameMetrics.currentTime;\n\n    // If no manual time was provided, we shall use Date.now in 32 bit format\n    if (time === undefined) {\n      this.frameMetrics.currentTime = Date.now() | 0;\n    } else {\n      // If this is our first frame and we have a manual time entry, then we first need to sync up\n      // The manual time as our previous timing.\n      if (this.frameMetrics.previousTime === this.frameMetrics.currentTime) {\n        this.frameMetrics.previousTime = time;\n      }\n\n      this.frameMetrics.currentTime = time;\n    }\n\n    // Now that we have established what the time should be, let's swap our input parameter to reflect\n    // the time we will be using for this frame\n    time = this.frameMetrics.currentTime;\n\n    // Get the scenes in their added order\n    const scenes = this.sceneDiffs.items;\n    scenes.sort(sortByOrder);\n    const erroredLayers: { [key: string]: [Layer<any, any>, Error] } = {};\n\n    // Loop through scenes\n    for (let i = 0, end = scenes.length; i < end; ++i) {\n      const scene = scenes[i];\n      const views = scene.views;\n      const layers = scene.layers;\n\n      // Make sure the views and layers are ordered such that they render in the\n      // appropriate order\n      views.sort(sortByOrder);\n      layers.sort(sortByOrder);\n\n      // Loop through the views\n      for (let k = 0, endk = views.length; k < endk; ++k) {\n        const view = views[k];\n        const validLayers: { [key: string]: Layer<any, any> } = {};\n\n        // If this view has information to use, then we should perform steps to\n        // prepare the view for use.\n        if (layers.length > 0) {\n          // Prepare to use the view\n          view.willUseView();\n        }\n\n        // Get the bounds of the current rendering target to aid in calculating\n        // the correct viewport.\n        const rendererSize = this.renderer.getRenderSize();\n\n        let renderTargetBounds = new Bounds<never>({\n          width: rendererSize[0],\n          height: rendererSize[1],\n          x: 0,\n          y: 0\n        });\n\n        // If the view is outputting to target output buffers, then our render\n        // target bounds is that of the buffer and NOT the renderer's size.\n        if (view.renderTarget) {\n          const target = Array.isArray(view.renderTarget)\n            ? view.renderTarget[0]\n            : view.renderTarget;\n          const size = target.getSize();\n\n          renderTargetBounds = new Bounds<never>({\n            width: size[0],\n            height: size[1],\n            x: 0,\n            y: 0\n          });\n        }\n\n        // Calculate the bounds of the viewport relative to the screen\n        const viewportBounds = getAbsolutePositionBounds<View<IViewProps>>(\n          view.props.viewport,\n          renderTargetBounds,\n          this.pixelRatio\n        );\n\n        // We must perform any operations necessary to make the view camera fit\n        // the viewport Correctly\n        view.fitViewtoViewport(renderTargetBounds, viewportBounds);\n\n        // Let the layers update their uniforms before the draw\n        for (let j = 0, endj = layers.length; j < endj; ++j) {\n          // Get the layer to be rendered in the scene\n          const layer = layers[j];\n          // Update the layer with the view it is about to be rendered with\n          layer.view = view;\n\n          // Make sure the layer is given the opportunity to update all of it's\n          // uniforms To match the view state and update any unresolved diffs\n          // internally\n          try {\n            // Update uniforms, resolve diff changes\n            layer.draw();\n            // If any of the layers under the view need a redraw\n            // Then the view needs a redraw\n            if (layer.needsViewDrawn || layer.isAnimationContinuous) {\n              view.needsDraw = true;\n            }\n            // Flag the layer as valid\n            validLayers[layer.id] = layer;\n            // The view's animationEndTime is the largest end time found on one\n            // of the view's child layers.\n            view.animationEndTime = Math.max(\n              view.animationEndTime,\n              layer.animationEndTime,\n              view.props.camera.animationEndTime\n            );\n            // Indicate this layer is being rendered at the current time frame\n            layer.lastFrameTime = time;\n          } catch (err) {\n            if (!erroredLayers[layer.id]) {\n              erroredLayers[layer.id] = [layer, err];\n            }\n          }\n        }\n\n        // Analyze the view's animation end timings and the camera to see if\n        // there are view changes that will trigger a redraw outside of our\n        // layer changes\n        if (\n          view.needsDraw ||\n          (time && time < view.lastFrameTime) ||\n          (time && time < view.animationEndTime) ||\n          view.props.camera.needsViewDrawn\n        ) {\n          view.needsDraw = true;\n          needsDraw = true;\n\n          // Get all of the dependent views for that view\n          const overlapViews = this.viewDrawDependencies.get(view);\n\n          // And make all of them need a redraw.\n          if (overlapViews) {\n            overlapViews.forEach(view => {\n              view.needsDraw = true;\n            });\n          }\n        }\n\n        // Only include non-errored layers for the scene. We filter the scenes\n        // layer PER view because context can change with a given view thus\n        // making it possible for a layer to error within each view's context.\n        // We render each view after completion of updates, thus the scene needs\n        // to be cleared of errored layers immediately after the view context\n        // has updated.\n        const keepLayers = Object.values(validLayers);\n        if (layers.length !== keepLayers.length) {\n          scene.layerDiffs.diff(keepLayers.map(layer => layer.initializer));\n        }\n\n        // Our scene must have a valid container to operate\n        if (!scene.container) continue;\n\n        // Now perform the rendering for the view.\n        // WHY WE RENDER NOW:\n        // Each layer has a single material representing it. This means uniforms\n        // based on view only get updated when the layer performs it's draw in\n        // the context of each view. So, we have to render the view immediately\n        // after the layer draws in context of it's view and has it's uniforms\n        // updated in that context.\n        if (onViewReady) {\n          onViewReady(needsDraw, scene, view);\n        }\n      }\n    }\n\n    // Get the layers with errors flagged for them and output the issues to the\n    // console.\n    const errors = Object.values(erroredLayers);\n    this.printLayerErrors(errors);\n  }\n\n  /**\n   * Free all resources consumed by this surface that gets applied to the GPU.\n   */\n  destroy() {\n    this.resourceManager.destroy();\n    this.userInputManager.destroy();\n    this.sceneDiffs.destroy();\n    this.renderer.dispose();\n    delete this.context;\n  }\n\n  /**\n   * This is the draw loop that must be called per frame for updates to take\n   * effect and display.\n   *\n   * @param time This is an optional time flag so one can manually control the\n   *             time flag for the frame. This will affect animations and other\n   *             automated gpu processes.\n   */\n  async draw(time?: number) {\n    if (!this.gl) return;\n\n    // Update all event managers with the current cycle event.\n    this.broadcastEventManagerCycle(EventManagerBroadcastCycle.WILL_RENDER);\n\n    // Before we draw the frame, we must have every camera resolve broadcasting\n    // changes so everything can respond to the change before all of the drawing\n    // operations take place.\n    for (let i = 0, iMax = this.sceneDiffs.items.length; i < iMax; ++i) {\n      const scene = this.sceneDiffs.items[i];\n\n      for (let k = 0, kMax = scene.views.length; k < kMax; ++k) {\n        const view = scene.views[k];\n        view.props.camera.broadcast(view.id);\n      }\n    }\n\n    // Make the layers commit their changes to the buffers then draw each scene\n    // view on Completion.\n    await this.commit(time, true, (needsDraw, scene, view) => {\n      // Our scene must have a valid container to operate\n      if (!scene.container) return;\n\n      if (needsDraw) {\n        // Now perform the rendering\n        this.drawSceneView(scene.container, view);\n      }\n    });\n\n    // After we have drawn our views of our scenes, we can now ensure all of the\n    // bounds Are updated in the interactions and flag our interactions ready\n    // for mouse input\n    if (this.userInputManager.waitingForRender) {\n      this.userInputManager.waitingForRender = false;\n    }\n\n    // Now that all of our layers have performed updates to everything, we can\n    // now dequeue All resource requests We create this gate in case multiple\n    // draw calls flow through before a buffer operation is completed\n    if (!this.isBufferingResources) {\n      this.isBufferingResources = true;\n      const didBuffer = await this.resourceManager.dequeueRequests();\n      this.isBufferingResources = false;\n\n      // If buffering did occur and completed, then we should be performing a\n      // draw to ensure all of the Changes are committed and pushed out.\n      if (didBuffer) {\n        this.draw(await onFrame());\n      }\n    }\n\n    // Each frame needs to analyze if draws are needed or not. Thus we reset all\n    // draw needs so they will be considered resolved for the current set of\n    // changes. Set draw needs of cameras and views back to false\n    for (let i = 0, iMax = this.sceneDiffs.items.length; i < iMax; ++i) {\n      const scene = this.sceneDiffs.items[i];\n\n      // Resolve view renders\n      for (let i = 0, iMax = scene.views.length; i < iMax; ++i) {\n        const view = scene.views[i];\n        view.needsDraw = false;\n        view.props.camera.resolve();\n      }\n\n      // Resolve layer renders\n      for (let i = 0, iMax = scene.layers.length; i < iMax; ++i) {\n        const layer = scene.layers[i];\n        layer.needsViewDrawn = false;\n      }\n    }\n\n    // Update all event managers with the current cycle event.\n    this.broadcastEventManagerCycle(EventManagerBroadcastCycle.DID_RENDER);\n    // Clear out the flag requesting a pick pass so we don't perform a pick\n    // render pass unless we have another requested from mouse interactions\n    this.enabledOptimizedOutputs.clear();\n  }\n\n  /**\n   * This finalizes everything and sets up viewports and clears colors and\n   * performs the actual render step\n   */\n  private drawSceneView(\n    scene: Scene,\n    view: View<IViewProps>,\n    renderer?: WebGLRenderer,\n    target?: RenderTarget\n  ) {\n    renderer = renderer || this.renderer;\n    const offset = { x: view.viewBounds.left, y: view.viewBounds.top };\n    const size = view.viewBounds;\n    const background = view.props.background || DEFAULT_BACKGROUND_COLOR;\n    const willClearColorBuffer = view.clearFlags.indexOf(ClearFlags.COLOR) > -1;\n    const renderTarget = target || view.renderTarget || null;\n\n    // If the update color pick is flagged, we make sure the view's picking\n    // output type is enabled.\n    if (view.renderTarget) {\n      // Disable all optimized output targets\n      const targets = view.getRenderTargets();\n      targets.forEach(target =>\n        this.optimizedOutputs.forEach(outputTarget =>\n          target.disabledTargets.add(outputTarget)\n        )\n      );\n\n      // Enable any targets that were specified\n      if (this.enabledOptimizedOutputs.size > 0) {\n        const targets = view.getRenderTargets();\n        targets.forEach(target =>\n          this.enabledOptimizedOutputs.forEach(outputTarget =>\n            target.disabledTargets.delete(outputTarget)\n          )\n        );\n      }\n    }\n\n    // If the view has an output target to render into, then we shift our target\n    // focus to that target Make sure the correct render target is applied\n    renderer.setRenderTarget(renderTarget);\n\n    // Set the scissor rectangle.\n    renderer.setScissor(\n      {\n        x: offset.x,\n        y: offset.y,\n        width: size.width,\n        height: size.height\n      },\n      renderTarget\n    );\n    // If a background is established, we should clear the background color\n    // Specified for this context\n    if (willClearColorBuffer) {\n      // Clear the rect of color and depth so the region is totally it's own\n      renderer.clearColor([\n        background[0],\n        background[1],\n        background[2],\n        background[3]\n      ]);\n    }\n\n    // Make sure the viewport is set properly for the next render\n    renderer.setViewport({\n      x: offset.x,\n      y: offset.y,\n      width: size.width,\n      height: size.height\n    });\n\n    // Get the view's clearing preferences\n    if (view.clearFlags && view.clearFlags.length > 0) {\n      renderer.clear(\n        willClearColorBuffer,\n        view.clearFlags.indexOf(ClearFlags.DEPTH) > -1,\n        view.clearFlags.indexOf(ClearFlags.STENCIL) > -1\n      );\n    } else {\n      renderer.clear(false);\n    }\n\n    // Render the scene with the provided view metrics\n    renderer.render(scene, renderTarget);\n    // Indicate this view has been rendered for the given time allottment\n    view.lastFrameTime = this.frameMetrics.currentTime;\n  }\n\n  /**\n   * This must be executed when the canvas changes size so that we can\n   * re-calculate the scenes and views dimensions for handling all of our\n   * rendered elements.\n   */\n  fitContainer(_pixelRatio?: number) {\n    if (isOffscreenCanvas(this.context.canvas)) return;\n    const container = this.context.canvas.parentElement;\n\n    if (container) {\n      const canvas = this.context.canvas;\n      canvas.className = \"\";\n      canvas.setAttribute(\"style\", \"\");\n      container.style.position = \"relative\";\n      canvas.style.position = \"absolute\";\n      canvas.style.left = \"0xp\";\n      canvas.style.top = \"0xp\";\n      canvas.style.width = \"100%\";\n      canvas.style.height = \"100%\";\n      canvas.setAttribute(\"width\", \"\");\n      canvas.setAttribute(\"height\", \"\");\n      const containerBox = container.getBoundingClientRect();\n      const box = canvas.getBoundingClientRect();\n\n      this.resize(box.width || 100, containerBox.height || 100);\n    }\n  }\n\n  /**\n   * This gathers all the overlap views of every view\n   */\n  private gatherViewDrawDependencies() {\n    if (!this.sceneDiffs) return;\n    this.viewDrawDependencies.clear();\n    const scenes = this.sceneDiffs.items;\n    const rendererSize = this.renderer.getRenderSize();\n\n    // Fit all views to viewport\n    for (let i = 0, endi = scenes.length; i < endi; i++) {\n      const scene = scenes[i];\n\n      for (let k = 0, kMax = scene.views.length; k < kMax; ++k) {\n        const view = scene.views[k];\n        view.willUseView();\n\n        // To look for the overlaps of the view in screen space, we must\n        // calculate the view's viewport bounds relative to the screenspace.\n        let renderTargetBounds = new Bounds<never>({\n          width: rendererSize[0],\n          height: rendererSize[1],\n          x: 0,\n          y: 0\n        });\n\n        // If the view is outputting to target output buffers, then our render\n        // target bounds is that of the buffer and NOT the renderer's size.\n        if (view.renderTarget) {\n          const target = Array.isArray(view.renderTarget)\n            ? view.renderTarget[0]\n            : view.renderTarget;\n          const size = target.getSize();\n\n          renderTargetBounds = new Bounds<never>({\n            width: size[0],\n            height: size[1],\n            x: 0,\n            y: 0\n          });\n        }\n\n        // Calculate the bounds the viewport will occupy relative to the screen\n        // space\n        const viewportBounds = getAbsolutePositionBounds<View<IViewProps>>(\n          view.props.viewport,\n          renderTargetBounds,\n          this.pixelRatio\n        );\n\n        view.fitViewtoViewport(renderTargetBounds, viewportBounds);\n        view.props.camera.update(true);\n      }\n    }\n\n    // Set viewDrawDependencies\n    for (let i = 0, endi = scenes.length; i < endi; i++) {\n      const scene = scenes[i];\n\n      for (let k = 0, kMax = scene.views.length; k < kMax; ++k) {\n        const sourceView = scene.views[k];\n        const overlapViews: View<IViewProps>[] = [];\n\n        for (let j = 0, endj = scenes.length; j < endj; j++) {\n          if (j !== i) {\n            const scene = scenes[j];\n\n            for (let l = 0, lMax = scene.views.length; l < lMax; ++l) {\n              const targetView = scene.views[l];\n\n              if (sourceView.viewBounds.hitBounds(targetView.viewBounds)) {\n                overlapViews.push(targetView);\n              }\n            }\n          }\n        }\n\n        this.viewDrawDependencies.set(sourceView, overlapViews);\n      }\n    }\n  }\n\n  /**\n   * As users interact with the surface, this provides a quick way to view the\n   * latest interaction that occurred from User events.\n   */\n  getCurrentInteraction() {\n    return this.userInputManager.currentInteraction;\n  }\n\n  /**\n   * Retrieves all IO Expanders applied to this surface\n   */\n  getIOExpanders() {\n    return this.ioExpanders;\n  }\n\n  /**\n   * Retrieves the controller for sorting the IO for the layers.\n   */\n  getIOSorting() {\n    return this.ioSorting;\n  }\n\n  /**\n   * Retrieves all shader transforms applied to this surface.\n   */\n  getShaderTransforms() {\n    return this.shaderTransforms;\n  }\n\n  /**\n   * Retrieves all outputs the surface\n   */\n  getOptimizedOutputs() {\n    return this.enabledOptimizedOutputs;\n  }\n\n  /**\n   * This allws for querying a view's screen bounds. Null i;s returned if the\n   * view id specified does not exist.\n   */\n  getViewSize(viewId: string): Bounds<View<IViewProps>> | null {\n    for (let i = 0, iMax = this.sceneDiffs.items.length; i < iMax; ++i) {\n      const scene = this.sceneDiffs.items[i];\n      const view = scene.viewDiffs.getByKey(viewId);\n\n      if (view) {\n        if (view.renderTarget) return view.viewBounds;\n        return view.screenBounds;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * This queries a view's window into a world's space.\n   */\n  getViewWorldBounds(viewId: string): Bounds<never> | null {\n    for (let i = 0, iMax = this.sceneDiffs.items.length; i < iMax; ++i) {\n      const scene = this.sceneDiffs.items[i];\n      const view = scene.viewDiffs.getByKey(viewId);\n\n      if (view) {\n        if (view.screenBounds) {\n          const topLeft = view.projection.viewToWorld([0, 0]);\n          const bottomRight = view.projection.screenToWorld([\n            view.screenBounds.right,\n            view.screenBounds.bottom\n          ]);\n\n          return new Bounds({\n            bottom: bottomRight[1],\n            left: topLeft[0],\n            right: bottomRight[0],\n            top: topLeft[1]\n          });\n        } else {\n          return null;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Retrieves the projection methods for a given view, null if the view id does\n   * not exist in the surface\n   */\n  getProjections(viewId: string): BaseProjection<any> | null {\n    for (let i = 0, iMax = this.sceneDiffs.items.length; i < iMax; ++i) {\n      const scene = this.sceneDiffs.items[i];\n      const view = scene.viewDiffs.getByKey(viewId);\n\n      if (view) return view.projection;\n    }\n\n    return null;\n  }\n\n  /**\n   * This is the beginning of the system. This should be called immediately\n   * after the surface is constructed. We make this mandatory outside of the\n   * constructor so we can make it follow an async pattern.\n   */\n  async init(options: ISurfaceOptions) {\n    // If this already has initialized it's context, then there's nothing to be\n    // done\n    if (this.context) return this;\n    // Make sure our desired pixel ratio is set up\n    this.pixelRatio = options.pixelRatio || this.pixelRatio;\n\n    if (this.pixelRatio < 1.0) {\n      this.pixelRatio = 1.0;\n    }\n\n    // Initialize our GL needs that set the basis for rendering\n    const context = this.initGL(options);\n\n    if (!context) {\n      this.readyResolver.reject({\n        error: SurfaceErrorType.NO_WEBGL_CONTEXT,\n        message:\n          \"Could not establish a webgl context. Surface is being destroyed to free resources.\"\n      });\n      this.destroy();\n      return this;\n    }\n\n    this.context = context;\n\n    if (this.gl) {\n      // Add in the specified optimized output targets\n      options.optimizedOutputTargets?.forEach(target =>\n        this.optimizedOutputs.add(target)\n      );\n      // Initialize our event manager that handles mouse interactions/gestures\n      // with the canvas\n      this.initUserInputManager(options);\n      // Initialize any resources requested or needed, such as textures or\n      // rendering surfaces\n      await this.initResources(options);\n      // Initialize any io expanders requested or needed. This must happen after\n      // resource initialization as resource managers can produce their own\n      // expanders.\n      await this.initIOExpanders(options);\n      // Initialize the shader transformations requested or needed.\n      await this.initShaderTransforms(options);\n    } else {\n      console.warn(\n        \"Could not establish a GL context. Layer Surface will be unable to render\"\n      );\n    }\n\n    this.readyResolver.resolve(this);\n\n    return this;\n  }\n\n  /**\n   * This initializes the Canvas GL contexts needed for rendering.\n   */\n  private initGL(options: ISurfaceOptions) {\n    // Get the canvas of our context to set up our GL settings\n    const canvas = options.context;\n    if (!canvas) return null;\n\n    // Apply the deltav version to the attributes of the canvas so we have more\n    // debugging information available\n    try {\n      canvas.setAttribute(\"data-deltav\", require(\"../release\").version);\n    } catch (err) {\n      // NOOP - We want the application of the version to happen, but it is not\n      // application critical\n    }\n\n    // Get the starting width and height so adjustments don't affect it\n    const width = canvas.width;\n    const height = canvas.height;\n    let hasContext = true;\n\n    const rendererOptions: ISurfaceOptions[\"rendererOptions\"] = Object.assign(\n      {\n        alpha: false,\n        antialias: false,\n        preserveDrawingBuffer: false,\n        premultiplyAlpha: false\n      },\n      options.rendererOptions\n    );\n\n    // Generate the renderer along with it's properties\n    this.renderer = new WebGLRenderer({\n      // Context supports rendering to an alpha canvas only if the background\n      // color has a transparent Alpha value.\n      alpha: rendererOptions.alpha,\n      // Yes to antialias! Make it preeeeetty!\n      antialias: rendererOptions.antialias,\n      // Make the GL use an existing canvas rather than generate another\n      canvas,\n      // If it's true it allows us to snapshot the rendering in the canvas\n      // But we dont' always want it as it makes performance drop a bit.\n      preserveDrawingBuffer: rendererOptions.preserveDrawingBuffer,\n      // This indicates if the information written to the canvas is going to be\n      // written as premultiplied values or if they will be standard rgba\n      // values. Helps with compositing with the DOM.\n      premultipliedAlpha: rendererOptions.premultipliedAlpha,\n\n      // Let's us know if there is no valid webgl context to work with or not\n      onNoContext: () => {\n        hasContext = false;\n      }\n    });\n\n    if (!hasContext || !this.renderer.gl) return null;\n    this.context = this.renderer.gl;\n\n    if (this.resourceManager) {\n      this.resourceManager.setWebGLRenderer(this.renderer);\n    }\n\n    // This sets the pixel ratio to handle differing pixel densities in screens\n    this.setRendererSize(width, height);\n    // Set the pixel ratio to match the pixel density of the monitor in use\n    this.renderer.setPixelRatio(this.pixelRatio);\n\n    return this.renderer.gl;\n  }\n\n  /**\n   * Initializes the expanders that should be applied to the surface for layer\n   * processing.\n   */\n  private initIOExpanders(options: ISurfaceOptions) {\n    // Handle expanders passed in as an array or blank\n    if (\n      Array.isArray(options.ioExpansion) ||\n      options.ioExpansion === undefined\n    ) {\n      // Initialize the Shader IO expansion objects\n      this.ioExpanders =\n        (options.ioExpansion && options.ioExpansion.slice(0)) ||\n        (DEFAULT_IO_EXPANSION && DEFAULT_IO_EXPANSION.slice(0)) ||\n        [];\n    }\n\n    // Handle expanders passed in as a method\n    else if (options.ioExpansion instanceof Function) {\n      this.ioExpanders = options.ioExpansion(DEFAULT_IO_EXPANSION);\n    }\n\n    // Retrieve any expansion objects the resource managers may provide\n    const managerIOExpanders = this.resourceManager.getIOExpansion();\n    // Add the expanders to our current handled list.\n    this.ioExpanders = this.ioExpanders.concat(managerIOExpanders);\n  }\n\n  /**\n   * Initializes the shader transforms that will be applied to every shader\n   * rendered with this surface.\n   */\n  private initShaderTransforms(options: ISurfaceOptions) {\n    // Handle transforms passed in as an array or blank\n    if (\n      Array.isArray(options.shaderTransforms) ||\n      options.shaderTransforms === undefined\n    ) {\n      // Initialize the Shader IO expansion objects\n      this.shaderTransforms =\n        (options.shaderTransforms && options.shaderTransforms.slice(0)) ||\n        (DEFAULT_SHADER_TRANSFORM && DEFAULT_SHADER_TRANSFORM.slice(0)) ||\n        [];\n    }\n\n    // Handle expanders passed in as a method\n    else if (options.shaderTransforms instanceof Function) {\n      this.shaderTransforms = options.shaderTransforms(\n        DEFAULT_SHADER_TRANSFORM\n      );\n    }\n  }\n\n  /**\n   * Initializes elements for handling mouse interactions with the canvas.\n   */\n  private initUserInputManager(options: ISurfaceOptions) {\n    // We must inject an event manager to broadcast events through the layers\n    // themselves\n    const eventManagers: EventManager[] = ([\n      new LayerMouseEvents()\n    ] as EventManager[]).concat(options.eventManagers || []);\n\n    // Generate the mouse manager for the layer\n    this.userInputManager = new UserInputEventManager(\n      this.context.canvas,\n      this,\n      eventManagers,\n      options.handlesWheelEvents\n    );\n  }\n\n  /**\n   * This initializes resources needed or requested such as textures or render\n   * surfaces.\n   */\n  private async initResources(options: ISurfaceOptions) {\n    // Create the controller for handling all resource managers\n    this.resourceManager = new ResourceRouter();\n    // Set the GL renderer to the\n    this.resourceManager.setWebGLRenderer(this.renderer);\n\n    // Get the managers requested by the configuration\n    const managers =\n      (options.resourceManagers && options.resourceManagers.slice(0)) ||\n      (DEFAULT_RESOURCE_MANAGEMENT && DEFAULT_RESOURCE_MANAGEMENT.slice(0)) ||\n      [];\n\n    // Register all of the managers for use by their type.\n    managers.forEach(manager => {\n      this.resourceManager.setManager(manager.type, manager.manager);\n    });\n  }\n\n  /**\n   * Use this to establish the rendering pipeline the application should be\n   * using at the current time.\n   *\n   * NOTE: If you update the pipeline on a loop of any sort, you will want to\n   * await the pipeline to complete it's diff before you issue a draw command.\n   * Failure to do so invites undefined behavior which often causes elements\n   * tobe comepltely not rendered at all in many cases.\n   */\n  async pipeline(pipeline: IPipeline) {\n    if (pipeline.resources) {\n      await this.resourceDiffs.diff(pipeline.resources);\n    }\n\n    if (pipeline.scenes) {\n      await this.sceneDiffs.diff(pipeline.scenes);\n    }\n\n    // This gathers the draw dependencies of the views (which views overlap\n    // other views.) This will let the system know when a view is needing\n    // re-rendering how it can preserve other views and prevent them from\n    // needing a redraw\n    this.gatherViewDrawDependencies();\n  }\n\n  /**\n   * Handles printing discovered issues with layers to the console to help with\n   * transparency for developing and debugging.\n   */\n  private printLayerErrors(errors: [Layer<any, any>, Error][]) {\n    if (errors.length > 0) {\n      console.warn(\n        \"Some layers errored during their draw update. These layers will be removed. They can be re-added if render() is called again:\",\n        errors.map(err => err[0].id)\n      );\n\n      // Output each layer and why it errored\n      errors.forEach(err => {\n        console.warn(`Layer ${err[0].id} removed for the following error:`);\n\n        if (err[1]) {\n          const message = err[1].stack || err[1].message;\n          console.error(message);\n\n          // This is a specific error to instances updating an attribute but\n          // returning a value that is larger than the attribute size. The only\n          // way to debug this is to run every instance in the layer and\n          // retrieve it's update value and compare the return to the expected\n          // size.\n          if (\n            message.indexOf(\"RangeError\") > -1 ||\n            message.indexOf(\"Source is too large\") > -1\n          ) {\n            const layer = err[0];\n            const changes = layer.bufferManager.changeListContext;\n            let singleMessage:\n              | [string, Instance, IInstanceAttribute<Instance>]\n              | undefined;\n            let errorCount = 0;\n\n            for (let i = 0, iMax = changes.length; i < iMax; ++i) {\n              const [instance] = changes[i];\n              layer.shaderIOInfo.instanceAttributes.forEach(attr => {\n                const check = attr.update(instance);\n                if (check.length !== attr.size) {\n                  if (!singleMessage) {\n                    singleMessage = [\n                      \"Example instance returned the wrong sized value for an attribute:\",\n                      instance,\n                      attr\n                    ];\n                  }\n\n                  errorCount++;\n                }\n              });\n            }\n\n            if (singleMessage) {\n              console.error(\n                \"The following output shows discovered issues related to the specified error\"\n              );\n              console.error(\n                \"Instances are returning too large IO for an attribute\\n\",\n                singleMessage[0],\n                singleMessage[1],\n                singleMessage[2],\n                \"Total errors for too large IO values\",\n                errorCount\n              );\n            }\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * This resizes the canvas and retains pixel ratios amongst all of the\n   * resources involved.\n   */\n  resize(width: number, height: number, pixelRatio?: number) {\n    this.pixelRatio = pixelRatio || this.pixelRatio;\n\n    if (this.pixelRatio < 1.0) {\n      this.pixelRatio = 1.0;\n    }\n\n    this.setRendererSize(width, height);\n    this.renderer.setPixelRatio(this.pixelRatio);\n    this.userInputManager.resize();\n    this.resourceManager.resize();\n\n    if (this.sceneDiffs) {\n      const scenes = this.sceneDiffs.items;\n      for (let i = 0, iMax = scenes.length; i < iMax; ++i) {\n        const scene = scenes[i];\n\n        for (let k = 0, kMax = scene.views.length; k < kMax; ++k) {\n          const view = scene.views[k];\n          view.pixelRatio = this.pixelRatio;\n          view.props.camera.update(true);\n        }\n      }\n    }\n\n    // After the resize happens, the view draw dependencies may change as the\n    // views will cover different region sizes\n    this.gatherViewDrawDependencies();\n  }\n\n  /**\n   * This flags all views to fully re-render\n   */\n  redraw() {\n    for (let i = 0, iMax = this.sceneDiffs.items.length; i < iMax; ++i) {\n      const viewLayers = this.sceneDiffs.items[i];\n\n      for (let k = 0, kMax = viewLayers.views.length; k < kMax; ++k) {\n        const view = viewLayers.views[k];\n        view.needsDraw = true;\n      }\n    }\n  }\n\n  /**\n   * This applies a new size to the renderer and resizes any additional\n   * resources that requires being sized along with the renderer.\n   */\n  private setRendererSize(width: number, height: number) {\n    width = width || 100;\n    height = height || 100;\n\n    // Set the canvas size for the renderer\n    this.renderer.setSize(width, height);\n  }\n\n  /**\n   * This allows a specified optimized output target to render next draw.\n   */\n  enableOptimizedOutput(output: number) {\n    // We will flag the color range as needing an update\n    this.enabledOptimizedOutputs.add(output);\n  }\n}\n","import { dot2, subtract2, Vec2 } from \"../../math/vector\";\n\nconst { ceil, max, log2, pow, sqrt } = Math;\n\n/** This is the pixel that  */\nconst NO_DATA: Vec2 = [-1, -1];\n\n/**\n * Gets the seed array for the JFA\n */\nfunction getSeed(canvas: HTMLCanvasElement, imageData: Uint8ClampedArray) {\n  const { width, height } = canvas;\n  let a;\n  const buffer: Vec2[][] = [];\n  const inverse: Vec2[][] = [];\n\n  for (let i = 0; i < width; ++i) {\n    buffer[i] = [];\n    inverse[i] = [];\n\n    for (let k = 0; k < height; ++k) {\n      const redIndex = k * (width * 4) + i * 4;\n      a = imageData[redIndex + 3];\n\n      // Any non-transparent pixel is a seed\n      if (a) {\n        buffer[i][k] = [i, k];\n        inverse[i][k] = NO_DATA;\n      } else {\n        buffer[i][k] = NO_DATA;\n        inverse[i][k] = [i, k];\n      }\n    }\n  }\n\n  return {\n    seed: buffer,\n    inverse\n  };\n}\n\n/**\n * Makes a buffer the same size as the input buffer. This assumes that the\n * input buffer is N x M in size, meaning each row is the same size.\n */\nfunction makeEmptyBuffer(buffer: Vec2[][]) {\n  const newBuffer: Vec2[][] = [];\n\n  for (let i = 0, iMax = buffer.length; i < iMax; ++i) {\n    newBuffer[i] = [];\n  }\n\n  return newBuffer;\n}\n\n/**\n * Takes a positional buffer and converts it to a distance field that is normalized to 0 - 255\n */\nfunction normalizedDistanceField(\n  buffer: Vec2[][],\n  noData: Vec2,\n  negate: boolean = false\n) {\n  const sign = negate ? -1 : 1;\n  let position: Vec2, current: Vec2, direction: Vec2;\n  let distance;\n  const distanceBuffer: number[][] = [];\n  let maxDistance: number = -1;\n\n  // Calculate the distances and get the max distance so we can normalize the output\n  for (let x = 0, xMax = buffer.length; x < xMax; ++x) {\n    const col = buffer[x];\n    distanceBuffer[x] = [];\n\n    for (let y = 0, yMax = col.length; y < yMax; ++y) {\n      position = col[y];\n\n      if (position === noData) {\n        distance = 256;\n      } else {\n        current = [x, y];\n        direction = subtract2(position, current);\n        distance = sqrt(dot2(direction, direction));\n      }\n\n      // Store the distance in our buffer for when we generate the canvas rendering\n      distanceBuffer[x][y] = distance;\n      // Update our max distance found so we can normalize the values\n      maxDistance = max(distance, maxDistance);\n    }\n  }\n\n  // Convert our distance buffer to our canvas buffer\n  for (let x = 0, xMax = buffer.length; x < xMax; ++x) {\n    const col = buffer[x];\n\n    for (let y = 0, yMax = col.length; y < yMax; ++y) {\n      distance = distanceBuffer[x][y];\n      distanceBuffer[x][y] = (distance / maxDistance) * 255 * sign;\n    }\n  }\n\n  return distanceBuffer;\n}\n\n/**\n * Takes the positional buffer of JFA and maps it to an Image Data buffer to be rendered as the canvas\n */\nfunction mapToDistanceField(\n  toSeedBuffer: Vec2[][],\n  fromSeedBuffer: Vec2[][],\n  noData: Vec2,\n  outBuffer: Uint8ClampedArray\n) {\n  let outColor;\n  // This is the distance field repsenting our distance to the seed values\n  const toSeedDistance = normalizedDistanceField(toSeedBuffer, noData, true);\n  // This is the negated distance field from the seed to the nearest non-seed slot\n  const fromSeedDistance = normalizedDistanceField(\n    fromSeedBuffer,\n    noData,\n    false\n  );\n\n  const width = toSeedDistance.length;\n  const outputDistance = toSeedDistance;\n\n  // Combine the buffers to get our font SDF\n  for (let x = 0, xMax = toSeedDistance.length; x < xMax; ++x) {\n    const toSeedCol = toSeedDistance[x];\n    const fromSeedCol = fromSeedDistance[x];\n\n    for (let y = 0, yMax = toSeedCol.length; y < yMax; ++y) {\n      const toSeed = toSeedCol[y];\n      const fromSeed = fromSeedCol[y];\n\n      toSeedCol[y] = toSeed + fromSeed;\n    }\n  }\n\n  for (let x = 0, xMax = outputDistance.length; x < xMax; ++x) {\n    const toSeedCol = outputDistance[x];\n\n    for (let y = 0, yMax = toSeedCol.length; y < yMax; ++y) {\n      outColor = toSeedCol[y];\n      // We use the 1 - signed distance (images are more human happy and algo happy)\n      outColor = outColor;\n\n      const redIndex = y * (width * 4) + x * 4;\n      outBuffer[redIndex] = outColor;\n      outBuffer[redIndex + 1] = outColor;\n      outBuffer[redIndex + 2] = outColor;\n      outBuffer[redIndex + 3] = 255;\n    }\n  }\n}\n\n/**\n * This contains the JFA pass logic portion of the algorithm. This requires the seedBuffer\n * and the number of passes to execute.\n */\nfunction jfaPasses(seedBuffer: Vec2[][], passes: number) {\n  const width = seedBuffer.length;\n  const height = seedBuffer[0].length;\n  // Set the current out to the seed as the each pass places the out into the read as the first step\n  let readBuffer: Vec2[][] = makeEmptyBuffer(seedBuffer);\n  let outBuffer: Vec2[][] = seedBuffer;\n  let c: Vec2;\n  let delta: Vec2;\n  let samples: Vec2[];\n  let nearestValue: number;\n  let nearestIndex: number;\n  let distance;\n  let x, y, i;\n\n  // We run the JFA passes over the buffers until complete\n  for (let pass = 0; pass < passes; ++pass) {\n    // We dont want to destroy the old read buffer as we will just write over the old data\n    // so we don't allocate a new buffer for each pass.\n    const temp = readBuffer;\n    // Swap the out buffer from last pass to the read buffer of this pass\n    readBuffer = outBuffer;\n    // We now write to the other buffer\n    outBuffer = temp;\n    // Next make a new out buffer to write into\n    const offset = pow(2, passes - pass - 1);\n\n    // Now loop through all of the buffer 'pixels' and take the JFA sampling\n    for (x = 0; x < width; ++x) {\n      for (y = 0; y < height; ++y) {\n        c = [x, y];\n        samples = [\n          (readBuffer[x - offset] || [])[y - offset] || NO_DATA,\n          (readBuffer[x] || [])[y - offset] || NO_DATA,\n          (readBuffer[x + offset] || [])[y - offset] || NO_DATA,\n          (readBuffer[x - offset] || [])[y] || NO_DATA,\n          (readBuffer[x] || [])[y] || NO_DATA,\n          (readBuffer[x + offset] || [])[y] || NO_DATA,\n          (readBuffer[x - offset] || [])[y + offset] || NO_DATA,\n          (readBuffer[x] || [])[y + offset] || NO_DATA,\n          (readBuffer[x + offset] || [])[y + offset] || NO_DATA\n        ];\n\n        nearestIndex = 0;\n        nearestValue = Number.MAX_VALUE;\n\n        for (i = 0; i < 9; ++i) {\n          const s = samples[i];\n\n          // NO_DATA does not require analysis\n          if (s !== NO_DATA) {\n            delta = subtract2(s, c);\n            distance = dot2(delta, delta);\n\n            if (distance < nearestValue) {\n              nearestValue = distance;\n              nearestIndex = i;\n            }\n          }\n        }\n\n        // We write to the buffer with our result which will either be NO_DATA or a pixel location\n        outBuffer[x][y] = samples[nearestIndex];\n      }\n    }\n  }\n\n  return outBuffer;\n}\n\n/**\n * Redraws the contents of the provided canvas as a signed distance field.\n * Signed distance fields are great for many techniques.\n *\n * As of right now this SDF merely represents distance to nearest occupied\n * pixel.\n *\n * This  particular SDF calculation utilizes JFA\n *\n * This algortihm follows the following:\n * Make a buffer that is the size of the canvas and seed it with values equal to the pixel position of filled pixels\n * Next calculate how many passes JFA will need to run based on the size of the canvas: log_2(max dimension of the canvas)\n * Next sample the buffer in a 3x3 grid with each having an offset that is 2^(number of passes - current pass - 1). The center\n * sample is the current pixel.\n * Each sample will contain either NO DATA or will contain the pixel position of the nearest filled pixel.\n * Each sample will calculate the distance of the sample to the current pixel position, the nearest sample will fill the buffer at\n * that position.\n *\n * After all passes, the buffer should be filled with the nearest pixel positions. You can take that and map it to either distances\n * or use other techniques desired.\n */\nexport function convertToSDF(\n  canvas: HTMLCanvasElement,\n  mapMethod: (\n    toSeedBuffer: Vec2[][],\n    fromSeedBuffer: Vec2[][],\n    noDataObject: Vec2,\n    outData: Uint8ClampedArray\n  ) => void = mapToDistanceField\n) {\n  const { width, height } = canvas;\n  const context = canvas.getContext(\"2d\");\n  if (!context) return;\n\n  const imageData = context.getImageData(0, 0, width, height).data;\n\n  // This gets the dimension to use as our max dimension for the JFA algorithm pass calculation\n  const maxDimension = max(width, height);\n  // Determine how many passes to execute\n  const passes = ceil(log2(maxDimension));\n  // This is the initial seed buffer for the JFA\n  const seedBuffer = getSeed(canvas, imageData);\n  // Runt he passes on the initial seed buffer to make the positional buffer\n  const positionBuffer = jfaPasses(seedBuffer.seed, passes);\n  const inversePositionBuffer = jfaPasses(seedBuffer.inverse, passes);\n  // Make an image data object that we can manipulate and apply to the canvas\n  const outImageData = new ImageData(width, height);\n  // Map the positional buffer to something that can be rendered to a canvas. By default, this will\n  // be a distance field.\n  mapMethod(positionBuffer, inversePositionBuffer, NO_DATA, outImageData.data);\n  // Render the out data to the input canvas\n  context.putImageData(outImageData, 0, 0);\n}\n\n/**\n * Makes a SDF of the input font specified\n */\nexport function makeFontSDF(_canvas: HTMLCanvasElement) {\n  // TODO\n}\n","import { Instance } from \"../instance-provider\";\nimport { IEasingControl, NOOP } from \"../types\";\nimport { onFrame } from \"./frame\";\n\n/** Handler type for discovered easing controls using the all() method */\nexport type EasingUtilAllHandler<T extends Instance> = (\n  easing: IEasingControl,\n  instance: T,\n  instanceIndex: number,\n  attrIndex: number\n) => void;\n\n/**\n * This contains helper methods to make setting easing values easier to instances that are a part of animated layers\n */\nexport class EasingUtil {\n  /**\n   * This retrieves all easing metrics for every instance for every specified eased attribute.\n   */\n  static async modify<T extends Instance>(\n    instances: T[],\n    layerAttributes: string[],\n    adjust: EasingUtilAllHandler<T>\n  ) {\n    for (let i = 0, iMax = layerAttributes.length; i < iMax; ++i) {\n      const attr = layerAttributes[i];\n\n      for (let k = 0, kMax = instances.length; k < kMax; ++k) {\n        const instance = instances[k];\n        const easing = instance.getEasing(attr);\n\n        if (easing) {\n          adjust(easing, instance, k, i);\n        }\n      }\n    }\n  }\n\n  /**\n   * This finds all easing controls requested for all instances.\n   *\n   * If wait is true, then this method's returned promise will resolve AFTER the time\n   * of all discovered easing objects has passed.\n   */\n  static async all<T extends Instance>(\n    wait: boolean,\n    instances: T[],\n    layerAttributes: string[],\n    adjust?: EasingUtilAllHandler<T>\n  ) {\n    let resolver: Function = NOOP;\n    const promise = new Promise(resolve => (resolver = resolve));\n    let finishedTime = 0;\n\n    for (let i = 0, iMax = layerAttributes.length; i < iMax; ++i) {\n      const attr = layerAttributes[i];\n\n      for (let k = 0, kMax = instances.length; k < kMax; ++k) {\n        const instance = instances[k];\n        const easing = instance.getEasing(attr);\n\n        if (easing) {\n          if (adjust) adjust(easing, instance, k, i);\n          finishedTime = Math.max(\n            (easing.delay || 0) + easing.duration,\n            finishedTime\n          );\n        }\n      }\n    }\n\n    // Keep looking at next frame until the animations are complete\n    const checkNextFrame = (t: number) => {\n      if (t < finishedTime) {\n        onFrame(checkNextFrame);\n      } else resolver();\n    };\n\n    if (wait) {\n      onFrame(t => {\n        finishedTime += t;\n        checkNextFrame(t);\n      });\n    } else {\n      resolver();\n    }\n\n    return promise;\n  }\n}\n","/**\n * Promise based wait wrapper for setTimeout\n */\nexport function wait(t: number) {\n  return new Promise(resolve => setTimeout(resolve, t));\n}\n","/**\n * This file contains all of the utilities for creating common object types\n */\nimport { createView } from \"../surface/view\";\nimport { createAttribute } from \"./create-attribute\";\nimport { createLayer } from \"./create-layer\";\nimport { createUniform } from \"./create-uniform\";\nimport { createVertex } from \"./create-vertex\";\n\n/**\n * Quick reference to the creation methods commonly used.\n */\nexport const create = {\n  layer: createLayer,\n  view: createView,\n  vertex: createVertex,\n  uniform: createUniform,\n  attribute: createAttribute\n};\n","import { PromiseResolver } from \"../../util\";\n\nconst img = document.createElement(\"img\");\nconst canvas = document.createElement(\"canvas\");\n\n/**\n * This takes a very simple svg and converts it to a data object for pixel examination.\n */\nexport async function svgToData(svg: SVGSVGElement) {\n  const resolver = new PromiseResolver<ImageData | null>();\n  if (!img || !canvas) return null;\n\n  // Get svg data\n  const xml = new XMLSerializer().serializeToString(svg);\n  // Make it base64\n  const svg64 = btoa(xml);\n  const b64Start = \"data:image/svg+xml;base64,\";\n  // Prepend the base64 \"header\"\n  const image64 = b64Start + svg64;\n  let didDraw = false;\n\n  // Method for rendering to the canvas once the svg image is ready\n  const draw = () => {\n    // Ensure we only draw once\n    if (didDraw) return;\n    didDraw = true;\n    // Make sure the canvas accommodates your monitor density!\n    canvas.width = img.width * window.devicePixelRatio;\n    canvas.height = img.height * window.devicePixelRatio;\n    const ctx = canvas.getContext(\"2d\");\n\n    if (!ctx) {\n      resolver.resolve(null);\n      return;\n    }\n\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    (ctx as any).mozImageSmoothingEnabled = false;\n    (ctx as any).webkitImageSmoothingEnabled = false;\n    (ctx as any).msImageSmoothingEnabled = false;\n    ctx.imageSmoothingEnabled = false;\n\n    ctx.drawImage(\n      img,\n      0,\n      0,\n      img.width * window.devicePixelRatio,\n      img.height * window.devicePixelRatio\n    );\n\n    resolver.resolve(ctx.getImageData(0, 0, canvas.width, canvas.height));\n\n    // Clean up used RAM useage for the image and canvas context\n    img.src = \"\";\n    // To debug this, simply uncomment this line and comment out the width/height change\n    // document.body.appendChild(canvas);\n    canvas.width = 0;\n    canvas.height = 0;\n    canvas.style.position = \"absolute\";\n    canvas.style.top = \"0px\";\n    canvas.style.zIndex = \"9999\";\n  };\n\n  img.onload = draw;\n  img.src = image64;\n\n  // If the width is already set then the image already has rendered it's contents and is ready to render to the\n  // canvas context.\n  if (img.width > 0 && img.height > 0) {\n    draw();\n  }\n\n  const result = await resolver.promise;\n  return result;\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport {\n  SubTexture,\n  subTextureIOValue\n} from \"../../resources/texture/sub-texture\";\nimport { ILayerProps, Layer } from \"../../surface/layer\";\nimport { BaseIOExpansion } from \"../../surface/layer-processing/base-io-expansion\";\nimport {\n  InstanceIOValue,\n  IResourceContext,\n  IResourceInstanceAttribute,\n  ResourceType\n} from \"../../types\";\nimport { nextFrame, shallowCompare } from \"../../util\";\nimport {\n  BaseResourceManager,\n  BaseResourceOptions\n} from \"../base-resource-manager\";\nimport { TextureIOExpansion } from \"../texture/texture-io-expansion\";\nimport {\n  FontManager,\n  IFontResourceOptions,\n  isFontResource\n} from \"./font-manager\";\nimport { FontMap } from \"./font-map\";\nimport {\n  FontResourceRequestFetch,\n  IFontResourceRequest\n} from \"./font-resource-request\";\n\nconst debug = require(\"debug\")(\"performance\");\n\nexport interface IFontResourceRequestInternal extends IFontResourceRequest {\n  /**\n   * This is used to flag a request object as requested so that the same request object can be used for\n   * similar resources without generating two request lifecycles.\n   */\n  isRequested?: boolean;\n}\n\n/**\n * This manager controls and manages Font type resources that are requested for generation. This manager\n * will utilize the request given to it to provide the best possible solution in both load times and\n * run time performance available to the manager.\n *\n * This manager will have the ability to handle resources\n */\nexport class FontResourceManager extends BaseResourceManager<\n  IFontResourceOptions,\n  IFontResourceRequest\n> {\n  /** The current attribute that is making request calls */\n  currentAttribute: IResourceInstanceAttribute<Instance>;\n  /**\n   * This tracks if a resource is already in the request queue. This also stores ALL instances awaiting the resource.\n   */\n  private requestLookup = new Map<\n    string,\n    Map<IFontResourceRequest, [Layer<any, any>, Instance][]>\n  >();\n\n  /** This stores all of the requests awaiting dequeueing */\n  private requestQueue = new Map<string, IFontResourceRequest[]>();\n  /** This is the lookup for generated font map resources */\n  private resourceLookup = new Map<string, FontMap>();\n  /** This is the manager that is used to create and update font resources */\n  private fontManager = new FontManager();\n\n  /**\n   * This is so the system can control when requests are made so this manager has the opportunity\n   * to verify and generate the resources the request requires.\n   */\n  async dequeueRequests(): Promise<boolean> {\n    // This flag will be modified to reflect if a dequeue operation has occurred\n    let didDequeue = false;\n    const resourceRequestsWithKey: [string, IFontResourceRequest[]][] = [];\n\n    this.requestQueue.forEach((requests, resourceKey) => {\n      resourceRequestsWithKey.push([resourceKey, requests]);\n    });\n\n    this.requestQueue.clear();\n\n    // Loop through all requests paired with their resource key context\n    for (let i = 0, iMax = resourceRequestsWithKey.length; i < iMax; ++i) {\n      const [fontResource, allRequests] = resourceRequestsWithKey[i];\n\n      if (allRequests.length > 0) {\n        // We did dequeue\n        didDequeue = true;\n        // Pull out all of the requests into a new array and empty the existing queue to allow the queue to register\n        // New requests while this dequeue is being processed\n        const requests = allRequests.slice(0);\n        // Empty the queue to begin taking in new requests as needed\n        allRequests.length = 0;\n\n        debug(\"Processing requests for resource '%s'\", fontResource);\n\n        // Tell the font manager to update with all of the requested resources\n        await this.fontManager.updateFontMap(fontResource, requests);\n        // Tell the manager to process all of the metrics requests for the text\n        await this.fontManager.calculateMetrics(fontResource, requests);\n        // Get the requests for the given font\n        const glyphRequests = this.requestLookup.get(fontResource);\n\n        if (glyphRequests) {\n          // Once the manager has been updated, we can now flag all of the instances waiting for the resources\n          // As active, which should thus trigger an update to the layers to perform a diff for each instance\n          requests.forEach(resource => {\n            const request = glyphRequests.get(resource);\n            glyphRequests.delete(resource);\n\n            if (request) {\n              for (let i = 0, iMax = request.length; i < iMax; ++i) {\n                const [layer, instance] = request[i];\n                // If the instance is still associated with buffer locations, then the instance can be activated. Having\n                // A buffer location is indicative the instance has not been deleted.\n                if (layer.managesInstance(instance)) {\n                  // Make sure the instance is active\n                  instance.active = true;\n                }\n              }\n\n              // Do a delay to next frame before we do our resource trigger so we can see any lingering updates get\n              // applied to the instance's rendering\n              nextFrame(() => {\n                const triggered = new Set();\n\n                for (let i = 0, iMax = request.length; i < iMax; ++i) {\n                  const instance = request[i][1];\n\n                  if (!triggered.has(instance)) {\n                    triggered.add(instance);\n                    instance.resourceTrigger();\n                  }\n                }\n              });\n            }\n          });\n\n          debug(\"All requests for resource '%s' are processed\", fontResource);\n        } else {\n          debug(\n            \"There were no Font requests waiting for completion for resource\",\n            fontResource\n          );\n        }\n      }\n    }\n\n    return didDequeue;\n  }\n\n  /**\n   * This will force this manager to free all of it's beloved resources that it manages should\n   * it be holding onto resources that can not be freed by lack of references.\n   */\n  destroy(): void {\n    this.fontManager.destroy();\n  }\n\n  /**\n   * Destroy a single resource if the system deems it's time for it to go\n   */\n  destroyResource(init: BaseResourceOptions) {\n    const resource = this.resourceLookup.get(init.key);\n    if (!resource) return;\n    this.fontManager.destroyFontMap(resource.id);\n    this.resourceLookup.delete(init.key);\n  }\n\n  /**\n   * This will provide the resource generated from the initResource operation.\n   */\n  getResource(resourceKey: string) {\n    return this.resourceLookup.get(resourceKey) || null;\n  }\n\n  /**\n   * Make the expander to handle making the attribute changes necessary to have the texture applied\n   * to a uniform when the attribute places a resource request with a key.\n   */\n  getIOExpansion(): BaseIOExpansion[] {\n    return [new TextureIOExpansion(ResourceType.FONT, this)];\n  }\n\n  /**\n   * This is a request to intiialize a resource by this manager.\n   */\n  async initResource(options: BaseResourceOptions) {\n    if (isFontResource(options)) {\n      const fontMap = await this.fontManager.createFontMap(options);\n\n      if (fontMap) {\n        this.resourceLookup.set(options.key, fontMap);\n      }\n\n      debug(\"Font map created->\", fontMap);\n    }\n  }\n\n  /**\n   * This is for attributes making a request for a resource of this type to create shader compatible info\n   * regarding the requests properties.\n   */\n  request<U extends Instance, V extends ILayerProps<U>>(\n    layer: Layer<U, V>,\n    instance: Instance,\n    req: IFontResourceRequest,\n    _context?: IResourceContext\n  ): InstanceIOValue {\n    const request: IFontResourceRequestInternal = req;\n    const fontMap = request.fontMap;\n    let texture: SubTexture | null = null;\n\n    // If the texture is ready and available, then we simply return the IO values\n    if (fontMap) {\n      // If this is a character request, then we output the texture desired. Kerning requests only needs\n      // the font map populated in the request.\n      if (request.character) {\n        texture = fontMap.getGlyphTexture(request.character);\n      }\n\n      if (texture) {\n        if (request.fetch === FontResourceRequestFetch.IMAGE_SIZE) {\n          return [texture.pixelWidth, texture.pixelHeight];\n        }\n\n        return subTextureIOValue(texture);\n      }\n\n      if (request.fetch === FontResourceRequestFetch.IMAGE_SIZE) {\n        return [0, 0];\n      }\n\n      return subTextureIOValue(null);\n    }\n\n    // This is the attributes resource key being requested\n    const resourceKey = req.key;\n    // If a request is already made, then we must save the instance making the request for deactivation and\n    // Reactivation but without any additional atlas loading\n    let fontRequests = this.requestLookup.get(resourceKey);\n\n    if (fontRequests) {\n      const existingRequests = fontRequests.get(request);\n\n      if (existingRequests) {\n        existingRequests.push([layer, instance]);\n        instance.active = false;\n\n        if (request.fetch === FontResourceRequestFetch.IMAGE_SIZE) {\n          return [0, 0];\n        }\n\n        return subTextureIOValue(texture);\n      }\n    } else {\n      fontRequests = new Map();\n      this.requestLookup.set(resourceKey, fontRequests);\n    }\n\n    // If the texture is not available, then we must load the resource, deactivate the instance\n    // And wait for the resource to become available. Once the resource is available, the system\n    // Must activate the instance to render the resource.\n    instance.active = false;\n    let requests = this.requestQueue.get(resourceKey);\n\n    if (!requests) {\n      requests = [];\n      this.requestQueue.set(resourceKey, requests);\n    }\n\n    requests.push(request);\n    fontRequests.set(request, [[layer, instance]]);\n\n    // This returns essentially returns blank values for the resource lookup\n    if (request.fetch) {\n      return [0, 0];\n    }\n\n    return subTextureIOValue(texture);\n  }\n\n  /**\n   * Responds to the system detecting properties for a resource need updating.\n   */\n  updateResource(options: BaseResourceOptions) {\n    if (!isFontResource(options)) return;\n    const resource = this.resourceLookup.get(options.key);\n    if (!resource) return;\n    if (shallowCompare(options.fontSource, resource.fontSource)) return;\n\n    debug(\n      \"Font resources currently do not update. To update their properties simply destroy and recreate for now.\"\n    );\n  }\n}\n","import { onFrame } from \"../../util\";\nimport { SubTexture } from \"./sub-texture\";\n\n/**\n * This object monitors a video and it's corresponding texture it is rendered to. This will ensure the video and the\n * texture are in sync with each other.\n */\nexport class VideoTextureMonitor {\n  /** Indictaes if this resource is valid or not */\n  private isDestroyed: boolean = false;\n  /** This is the current rendered time frame that is applied to the subtexture */\n  private renderedTime: number = -1;\n\n  previousTime: number = -1;\n  playedFrames: number = 0;\n  caughtFrames: number = 0;\n  timeFrame: number = 0;\n\n  constructor(public video: HTMLVideoElement, public subTexture: SubTexture) {\n    this.addEventListeners();\n  }\n\n  /**\n   * Applies all of the necessary listeners to the video object\n   */\n  private async addEventListeners() {\n    if (this.isDestroyed) return;\n    this.loop(await onFrame());\n  }\n\n  /**\n   * Allows all resources to be freed.\n   */\n  destroy() {\n    this.video.pause();\n    this.isDestroyed = true;\n    this.removeEventListeners();\n  }\n\n  /**\n   * Performs the update operation no matter which event it  comes from\n   */\n  private doUpdate = () => {\n    // Only a change in time from what was currently rendered will require a render update\n    if (Math.abs(this.video.currentTime - this.renderedTime) < 0.015) {\n      return;\n    }\n\n    // Make sure we don't trigger duplicate updates by tracking the time we have rendered\n    this.renderedTime = this.video.currentTime;\n    // Tell the sub texture to update from it's source again which will grab the newest and bestest pixels\n    this.subTexture.update();\n  };\n\n  /**\n   * Render loop. We utilize this loop as all video playback events are inconsistent across browsers and have no truly\n   * perfect callback\n   */\n  private loop = (_t: number) => {\n    this.doUpdate();\n    if (!this.isDestroyed) onFrame(this.loop);\n  };\n\n  /**\n   * Cleans up any listeners this may have registered to ensure the video does not get retained\n   */\n  private removeEventListeners() {\n    // No listeners needed yet\n  }\n}\n","import { Omit, ResourceType } from \"../../types\";\nimport { BaseResourceRequest } from \"../base-resource-manager\";\nimport { SubTexture } from \"./sub-texture\";\n\nexport type AtlasVideoResource = {\n  videoSrc: string;\n};\n\nexport type AtlasResource = string | TexImageSource;\n\nconst EMPTY_IMAGE = new Image();\n\n/**\n * Base information an atlas resource can provide\n */\nexport interface IAtlasResourceRequest extends BaseResourceRequest {\n  /**\n   * When this is set in conjunction with the resource requested, this will cause the resource to be\n   * removed from the resource manager, thus allowing the resource's space to be used at a later\n   * time.\n   */\n  disposeResource?: boolean;\n  /**\n   * This is the key of the resource to be used for the request. Resources are defined in the pipeline.\n   */\n  key: string;\n  /**\n   * This scales the image to be rendered to the texture. A value of 1 means the image will be\n   * rendered full size to the texture. A value of .5 means it will be rendered half size to\n   * the texture.\n   */\n  rasterizationScale?: number;\n  /** This is the requested resource to be loaded into the manager system */\n  source: AtlasResource;\n  /**\n   * Once loaded into the texture, this will be populated revealing the informaion needed to sample the image\n   * from the atlas.\n   */\n  texture?: SubTexture;\n  /** Set the type of this resource for categorization by resource managers */\n  type: ResourceType.ATLAS;\n}\n\n/**\n * Simple wrapper to make autocomplete easier for making an atlas request.\n */\nexport function atlasRequest(\n  options: Omit<Partial<IAtlasResourceRequest>, \"type\"> &\n    Pick<IAtlasResourceRequest, \"key\">\n): IAtlasResourceRequest {\n  return {\n    type: ResourceType.ATLAS,\n    source: EMPTY_IMAGE,\n    ...options\n  };\n}\n","import { WebGLRenderer } from \"../gl\";\nimport { Instance } from \"../instance-provider/instance\";\nimport { ILayerProps, Layer } from \"../surface/layer\";\nimport { BaseIOExpansion } from \"../surface/layer-processing/base-io-expansion\";\nimport { InstanceIOValue, IResourceContext, IResourceType } from \"../types\";\nimport {\n  BaseResourceManager,\n  INVALID_RESOURCE_MANAGER\n} from \"./base-resource-manager\";\n\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * This is the manager of all Resource Managers. This handles registering managers for various resource types\n * and delegates resource requests to the appropriate manager.\n */\nexport class ResourceRouter {\n  /** This is the list of managers for handling resource requests */\n  managers = new Map<number, BaseResourceManager<any, any>>();\n  /**\n   * This tracks a resource's identifier to the type of resource it is. This allows for less information to be\n   * required of Layer attributes by making the resource key the identifier of the resource.s\n   */\n  resourceKeyToType = new Map<string, number>();\n  /** This is the webgl renderer that is passed to the resource managers */\n  webGLRenderer?: WebGLRenderer;\n\n  /**\n   * This is called by the system to cause the managers to dequeue their requests in an asynchronous fashion\n   */\n  async dequeueRequests() {\n    let didUpdate = false;\n    const managers = Array.from(this.managers.values());\n\n    for (let i = 0, iMax = managers.length; i < iMax; ++i) {\n      const manager = managers[i];\n      const update = await manager.dequeueRequests();\n      didUpdate = didUpdate || update;\n    }\n\n    return didUpdate;\n  }\n\n  /**\n   * Destroys all managers managed by this manager.\n   */\n  destroy() {\n    this.managers.forEach(manager => manager.destroy());\n    this.resourceKeyToType.clear();\n    this.managers.clear();\n    delete this.webGLRenderer;\n  }\n\n  /**\n   * This hands the destruction of a resource to the correct Resource Manager.\n   */\n  async destroyResource<T extends IResourceType>(\n    resource: T & { key: string }\n  ) {\n    const manager = this.managers.get(resource.type);\n\n    if (!manager) {\n      console.warn(\n        `A Resource is trying to be destroyed but has no manager to facilitate the operation: ${resource.type}`\n      );\n\n      return;\n    }\n\n    // Clear the key of the resource from it's registered type\n    this.resourceKeyToType.delete(resource.key);\n\n    return await manager.destroyResource(resource);\n  }\n\n  /**\n   * Retrieves the Shader IO Expansion controllers that may be provided by resource managers.\n   */\n  getIOExpansion() {\n    let all: BaseIOExpansion[] = [];\n\n    this.managers.forEach(manager => {\n      all = all.concat(manager.getIOExpansion());\n    });\n\n    return all;\n  }\n\n  /**\n   * Gets the manager for the provided resource type\n   */\n  getManager(resourceType: number): BaseResourceManager<any, any> {\n    const manager = this.managers.get(resourceType);\n\n    if (!manager) {\n      console.warn(\n        `A manager was requested that does not exist for type ${resourceType}`\n      );\n      return INVALID_RESOURCE_MANAGER;\n    }\n\n    return manager;\n  }\n\n  /**\n   * Retrieves the resource type that a resource key is associated with. This is undefined if the key does\n   * not exist.\n   */\n  getResourceType(resourceKey: string): number | undefined {\n    return this.resourceKeyToType.get(resourceKey);\n  }\n\n  /**\n   * This hands the initialization of a resource to the correct Resource Manager.\n   */\n  async initResource<T extends IResourceType>(resource: T & { key: string }) {\n    const manager = this.managers.get(resource.type);\n\n    if (!manager) {\n      console.warn(\n        `A Resource is trying to be created but has no manager to facilitate the operation: ${resource.type}`\n      );\n\n      return;\n    }\n\n    if (this.resourceKeyToType.has(resource.key)) {\n      console.warn(\n        \"Detected two resources with identical keys. The duplicate resource will not be generated:\",\n        resource.key\n      );\n\n      return;\n    }\n\n    // Store the key of the resource to the type it is.\n    this.resourceKeyToType.set(resource.key, resource.type);\n\n    return await manager.initResource(resource);\n  }\n\n  /**\n   * This is called by layers to request resources being generated.\n   */\n  request<\n    T extends Instance,\n    U extends ILayerProps<T>,\n    V extends IResourceType\n  >(\n    layer: Layer<T, U>,\n    instance: Instance,\n    resource: V,\n    context?: IResourceContext\n  ): InstanceIOValue {\n    const manager = this.managers.get(resource.type);\n\n    if (!manager) {\n      console.warn(\n        `A Layer is requesting a resource for which there is no manager set. Please make sure a Resource Manager is set for resource of type: ${resource.type}`\n      );\n      return [-1, -1, -1, -1];\n    }\n\n    return manager.request(layer, instance, resource, context);\n  }\n\n  /**\n   * Triggers when the context we are rendering into has resized. This simply\n   * passes the resize trigger down to the managers so they can adjust context\n   * specific resources for the adjustment.\n   */\n  resize() {\n    this.managers.forEach(manager => manager.resize());\n  }\n\n  /**\n   * Every resource type needs a manager associated with it so it can have requests processed. This\n   * allows a manager to be set for a resource type.\n   */\n  setManager(resourceType: number, manager: BaseResourceManager<any, any>) {\n    const currentManager = this.managers.get(resourceType);\n\n    if (currentManager) {\n      debug(\n        `A manager was assigned to a resource type: ${resourceType} that overrides another manager already set to that type.`\n      );\n    }\n\n    manager.router = this;\n    this.managers.set(resourceType, manager);\n    manager.webGLRenderer = this.webGLRenderer;\n  }\n\n  /**\n   * This sets the current gl renderer used for handling GL operations.\n   */\n  setWebGLRenderer(renderer: WebGLRenderer) {\n    this.webGLRenderer = renderer;\n    this.managers.forEach(manager => (manager.webGLRenderer = renderer));\n  }\n\n  /**\n   * This hands the update of a resource to the correct Resource Manager.\n   */\n  async updateResource<T extends IResourceType>(resource: T & { key: string }) {\n    const manager = this.managers.get(resource.type);\n\n    if (!manager) {\n      console.warn(\n        `A Resource is trying to be updated but has no manager to facilitate the operation: ${resource.type}`\n      );\n\n      return;\n    }\n\n    return await manager.updateResource(resource);\n  }\n}\n","import { WebGLStat } from \"../../../gl/webgl-stat\";\nimport { BaseShaderTransform } from \"../../../shaders/processing/base-shader-transform\";\nimport { removeComments } from \"../../../util/remove-comments\";\n\n/**\n * This transform is a last pass to resolve odds and ends differences that can\n * slip in from the way a shader is written. This will attempt it's best to\n * resolve a shader into the proper shader version that is appropriate for the\n * current hardware.\n */\nexport class Shaders30CompatibilityTransform extends BaseShaderTransform {\n  /**\n   * For es 3.0 shaders:\n   *   - we make sure all varying is converted to outs.\n   *   - texture2D sampling is now texture\n   * For es 2.0 shaders:\n   *   - we make sure the version header is removed\n   *   - Ensure out's are changed to varying\n   */\n  vertex(shader: string): string {\n    // Clearing out the comments removes a plethora of inherent issues\n    let out = removeComments(shader);\n\n    if (WebGLStat.SHADERS_3_0) {\n      out = out.replace(/\\s+varying\\s+/g, \"\\nout \");\n      out = out.replace(/(texture2D(\\s+)\\(|texture2D\\()/g, \"texture(\");\n    } else {\n      out = out.replace(/^#version 300 es/g, \"\");\n      out = out.replace(/\\s+out\\s+/g, \"\\nvarying \");\n    }\n\n    return out;\n  }\n\n  /**\n   * For es 3.0 shaders:\n   *   - we make sure all varying is converted to in's.\n   *   - if gl_FragColor is present, we need to generate an out for it\n   * For es 2.0 shaders:\n   *   - we make sure the version header is removed\n   *   - Ensure in's are changed to varying\n   */\n  fragment(shader: string): string {\n    // Clearing out the comments removes a plethora of inherent issues\n    let out = removeComments(shader);\n\n    if (WebGLStat.SHADERS_3_0) {\n      out = out.replace(/\\s+varying\\s+/g, \"\\nin \");\n      out = out.replace(/(texture2D(\\s+)\\(|texture2D\\()/g, \"texture(\");\n\n      if (out.match(/gl_FragColor/g)) {\n        out = out.replace(/gl_FragColor/g, \"_FragColor\");\n\n        // If no declaration was made for the frag color identifier, we must add\n        // one in as a special case.\n        if (!out.match(\"out vec4 _FragColor\")) {\n          const elements = out.split(\"\\n\");\n          elements.splice(3, 0, \"layout(location = 0) out vec4 _FragColor;\");\n          out = elements.join(\"\\n\");\n        }\n      }\n    } else {\n      out = out.replace(/^#version 300 es/g, \"\");\n      out = out.replace(/\\s+in\\s+/g, \"\\nvarying \");\n    }\n\n    return out;\n  }\n}\n","/**\n * This defines a transform that is allowed to analyze the final product of a\n * shader and make whatever last changes it wants to on that shader.\n *\n * This is a step that is intended to operate WITHOUT all of the information\n * available from the layers\n */\nexport abstract class BaseShaderTransform {\n  /** Implement to transform the vertex shader */\n  abstract vertex(shader: string): string;\n  /** Implement to transform the fragment shader */\n  abstract fragment(shader: string): string;\n}\n","import { RenderTarget } from \"../gl/render-target\";\nimport { Texture } from \"../gl/texture\";\nimport { divide2, scale2, Vec2, Vec4 } from \"../math/vector\";\nimport { FragmentOutputType, IColorPickingData, PickType } from \"../types\";\nimport { Surface } from \"./surface\";\nimport { IViewProps, View } from \"./view\";\n\nexport interface ISurfaceCommandsOptions {\n  surface: Surface;\n}\n\nfunction analyzeColorPickingRendering(\n  view: View<IViewProps>,\n  mouse: Vec2,\n  data: Uint8Array,\n  width: number,\n  height: number\n) {\n  const pickingData: IColorPickingData = {\n    view,\n    allColors: [],\n    colorData: data,\n    dataHeight: height,\n    dataWidth: width,\n    mouse,\n    nearestColor: 0,\n    nearestColorBytes: [0, 0, 0, 0]\n  };\n\n  const uniqueColors = new Map<number, boolean>();\n  let pixelIndex = 0;\n  const colors: number[][] = [];\n  const mouseX: number = width / 2;\n  const mouseY: number = height / 2;\n\n  let nearestColor = 0x000000;\n  let nearestColorBytes: Vec4 = [0, 0, 0, 0];\n  let distance = Number.MAX_SAFE_INTEGER;\n\n  for (let i = 0; i < height; ++i) {\n    const row: number[] = [];\n    colors.push(row);\n\n    for (let k = 0; k < width; ++k) {\n      const r = data[pixelIndex];\n      const g = data[pixelIndex + 1];\n      const b = data[pixelIndex + 2];\n      pixelIndex += 4;\n\n      const color = (r << 16) | (g << 8) | b;\n      uniqueColors.set(color, true);\n      row.push(color);\n\n      // If the color is not black, let's test the distance against currnet nearest color\n      if (color !== 0x000000) {\n        const dx = k - mouseX;\n        const dy = i - mouseY;\n        const testDistance = dx * dx + dy * dy;\n\n        if (testDistance < distance) {\n          distance = testDistance;\n          nearestColor = color;\n          nearestColorBytes = [r, g, b, 255];\n        }\n      }\n    }\n  }\n\n  // Apply all of the unique colors that were discovered within the rendering\n  pickingData.allColors = Array.from(uniqueColors.keys());\n  // The nearest color will be the element in the middle of the array of colors\n  pickingData.nearestColor = nearestColor;\n  // The nearest color in byte components\n  pickingData.nearestColorBytes = nearestColorBytes;\n\n  return pickingData;\n}\n\n/**\n * These are deeply integrated commands that are available but made convenient\n * through surface features. These commands are designed to be ran either pre or\n * post render and may involve blocking CPU to GPU commands such as\n * computational feedback or pixel reading from a texture.\n */\nexport class SurfaceCommands {\n  surface: Surface;\n  pickingRenderTargets = new Map<View<any>, RenderTarget>();\n\n  constructor(options: ISurfaceCommandsOptions) {\n    this.surface = options.surface;\n  }\n\n  private analyzePickedPixels(location: Vec2, view: View<any>) {\n    // Optimized rendering of the view will make the view discard picking\n    // rendering\n    if (view.optimizeRendering) {\n      return;\n    }\n\n    const position = divide2(\n      // Our location is relative to the screen, so we must scale it by the\n      // surface's pixel ratio to match the actual pixel space of the original\n      // screen dimensions\n      scale2(location, this.surface.pixelRatio),\n      // We then have to scale down the location based on the scaling of the\n      // view relative to the view's scaling relative to the screen.\n      view.projection.screenScale\n    );\n\n    // Make our metrics for how much of the image we wish to analyze\n    const pickWidth = 5;\n    const pickHeight = 5;\n    const numBytesPerColor = 4;\n    const out = new Uint8Array(pickWidth * pickHeight * numBytesPerColor);\n\n    // Read the pixels out\n    this.surface.renderer.readPixels(\n      Math.floor(position[0] - pickWidth / 2),\n      Math.floor(position[1] - pickHeight / 2),\n      pickWidth,\n      pickHeight,\n      out\n    );\n\n    // Analyze the rendered color data for the picking routine\n    const pickingData = analyzeColorPickingRendering(\n      view,\n      [position[0] - view.screenBounds.x, position[1] - view.screenBounds.y],\n      out,\n      pickWidth,\n      pickHeight\n    );\n\n    // Apply the interaction picing information to the layers related to the\n    // view.\n    for (let j = 0, endj = view.scene.layers.length; j < endj; ++j) {\n      const layer = view.scene.layers[j];\n\n      if (layer.picking.type === PickType.SINGLE) {\n        layer.interactions.colorPicking = pickingData;\n      }\n    }\n  }\n\n  /**\n   * This causes picking operations to get dequeued and have the textures\n   * associated with the picking have their pixels read for interpretation for\n   * instance interaction.\n   *\n   * This is a BLOCKING operation and it will block until ALL GPU operations\n   * have been completed by the GPU. Thus, it is recommended to perform this\n   * command at the beginning of the pipeline to allow for the previous frame to\n   * completely\n   */\n  decodePicking() {\n    const interaction = this.surface.getCurrentInteraction();\n    if (!interaction) return;\n\n    const position = interaction.screen.position;\n    const views = interaction.target.views.map(v => v.view);\n\n    // Clean out any render targets that have no valid texture to read from.\n    const toRemove = new Set<View<any>>();\n\n    this.pickingRenderTargets.forEach((target, view) => {\n      const buffer = target.getBuffers()[0].buffer;\n      if (buffer instanceof Texture) {\n        if (!buffer.gl || buffer.destroyed) {\n          target.dispose();\n          toRemove.add(view);\n        }\n      }\n    });\n\n    toRemove.forEach(view => this.pickingRenderTargets.delete(view));\n\n    // Loop through each potential view and seek an output buffer with type\n    // picking for it\n    views.forEach(view => {\n      let pickingTarget = this.pickingRenderTargets.get(view);\n\n      // Ensure our view has a render target created for reading from the\n      // picking output of the view.\n      if (!pickingTarget) {\n        view.getRenderTargets().forEach(renderTarget => {\n          // We do not consider the render target for valid buffers unless it's\n          // been compiled.\n          if (!renderTarget.gl) return;\n\n          // Find the target that outputs for picking\n          renderTarget.getBuffers().forEach(buffer => {\n            if (buffer.outputType === FragmentOutputType.PICKING) {\n              // Generate our single render buffer target so our read pixels\n              // will for sure target the right buffer\n              pickingTarget = new RenderTarget({\n                buffers: {\n                  color: buffer\n                }\n              });\n\n              // If the target was not able to specify valid dimensions, then we\n              // skip for now.\n              if (pickingTarget.width === 0 || pickingTarget.height === 0) {\n                pickingTarget = void 0;\n                return;\n              }\n\n              this.pickingRenderTargets.set(view, pickingTarget);\n            }\n          });\n        });\n      }\n\n      if (!pickingTarget) return;\n\n      const currentTarget = this.surface.renderer.state.currentRenderTarget;\n      let doSwitch = false;\n\n      if (!currentTarget) doSwitch = true;\n      else if (Array.isArray(currentTarget)) doSwitch = true;\n      else if (\n        currentTarget.getBuffers()[0].buffer !==\n        pickingTarget.getBuffers()[0].buffer\n      ) {\n        doSwitch = true;\n      }\n\n      if (doSwitch) {\n        this.surface.renderer.setRenderTarget(pickingTarget);\n      }\n\n      // After we have established a proper target to set for our view for\n      // picking, we go ahead and read pixels from the provided location.\n      this.analyzePickedPixels(position, view);\n    });\n  }\n}\n","export * from \"./layer-mouse-events\";\n","import { Instance } from \"../instance-provider/instance\";\nimport { InstanceProvider } from \"../instance-provider/instance-provider\";\nimport { ILayerProps, Layer } from \"./layer\";\nimport { Surface } from \"./surface\";\n\nexport type CommandCallback = (surface: Surface) => void;\n\nexport interface ICommandLayerProps<T extends Instance> extends ILayerProps<T> {\n  commands: CommandCallback;\n}\n\n/**\n * This is a layer that lets you inject commands into the pipeline. Most\n * commands are from the Surface.commands property that you will need, but this\n * opens up the opportunity to make any GL related commands as well.\n *\n * Custom GL is VERY ADVANCED useage. You should stick to using Surface.commands\n * AND read the documentation on those commands.\n */\nexport class CommandLayer<\n  T extends Instance,\n  U extends ICommandLayerProps<T>\n> extends Layer<T, U> {\n  static defaultProps: ICommandLayerProps<Instance> = {\n    data: new InstanceProvider<Instance>(),\n    key: \"\",\n    commands: () => {\n      /** NOOP */\n    }\n  };\n\n  draw() {\n    this.props.commands(this.surface);\n  }\n\n  /** The layer renders nothing, thus does not need a shader object */\n  initShader() {\n    return null;\n  }\n}\n","import { SimpleEventHandler } from \"../../event-management/simple-event-handler\";\nimport {\n  IMouseInteraction,\n  ISingleTouchInteraction,\n  ITouchInteraction\n} from \"../../event-management/types\";\nimport {\n  add3,\n  AutoEasingMethod,\n  BaseProjection,\n  copy3,\n  divide2,\n  divide3,\n  length2,\n  max3,\n  min3,\n  scale3,\n  subtract2,\n  subtract3,\n  Vec2,\n  Vec3,\n  vec3\n} from \"../../math\";\nimport { Bounds } from \"../../math/primitives/bounds\";\nimport { IViewProps, View } from \"../../surface/view\";\nimport { touchesContainsStartView, touchesHasStartView, uid } from \"../../util\";\nimport { Camera2D } from \"./camera-2d\";\n\n/**\n * Anchor options for the controller\n */\nexport enum CameraBoundsAnchor {\n  TOP_LEFT,\n  TOP_MIDDLE,\n  TOP_RIGHT,\n  MIDDLE_LEFT,\n  MIDDLE,\n  MIDDLE_RIGHT,\n  BOTTOM_LEFT,\n  BOTTOM_MIDDLE,\n  BOTTOM_RIGHT\n}\n\n/**\n * This represents how the camera should be bounded in the world space. This gives enough information\n * to handle all cases of bounding, including screen padding and anchoring for cases where the viewed space\n * is smaller than the view.\n */\nexport interface ICameraBoundsOptions {\n  /** How the bounded world space should anchor itself within the view when the projected world space to the screen is smaller than the view */\n  anchor: CameraBoundsAnchor;\n  /** Minimum settings the camera can scale to */\n  scaleMin?: Vec3;\n  /** Maximum settings the camera can scale to */\n  scaleMax?: Vec3;\n  /** The actual screen pixels the bounds can exceed when the camera's view has reached the bounds of the world */\n  screenPadding: { left: number; right: number; top: number; bottom: number };\n  /** This is the view for which the bounds applies towards */\n  view: string;\n  /** The area the camera is bound inside */\n  worldBounds: Bounds<any>;\n}\n\nexport interface IBasicCamera2DControllerOptions {\n  /** Takes in the options to be used for creating a new ViewBounds object on this controller. */\n  bounds?: ICameraBoundsOptions;\n  /** This is the camera this controller will manipulate */\n  camera: Camera2D;\n  /** When this is set to true, the start view can be targetted even when behind other views */\n  ignoreCoverViews?: boolean;\n  /**\n   * This is a handler for when the camera has applied changes to the visible range of what is seen.\n   * Which most likely means offset or scale has been altered.\n   */\n  onRangeChanged?(camera: Camera2D, projections: BaseProjection<any>): void;\n  /**\n   * This provides a control to filter panning that will be applied to the camera. The input and\n   * output of this will be the delta value to be applied.\n   */\n  panFilter?(\n    offset: [number, number, number],\n    view: View<IViewProps>,\n    allViews: View<IViewProps>[]\n  ): [number, number, number];\n  /**\n   * This adjusts how fast scaling is applied from the mouse wheel\n   */\n  scaleFactor?: number;\n  /**\n   * This provides a control to filter scaling that will be applied to the camera. The input and\n   * output of this will be the delta value to be applied.\n   */\n  scaleFilter?(\n    scale: [number, number, number],\n    view: View<IViewProps>,\n    allViews: View<IViewProps>[]\n  ): [number, number, number];\n  /**\n   * This is the view that MUST be the start view from the events.\n   * If not provided, then dragging anywhere will adjust the camera.\n   * This MUST be set for onRangeChange to broadcast animated camera movements.\n   */\n  startView?: string | string[];\n  /** When this is set, it will require two fingers to be down at minimum to pan the camera */\n  twoFingerPan?: boolean;\n  /**\n   * This specifies whether a view can be scrolled by wheel\n   * If this is not specified or set false, the view can be zoomed by wheel\n   */\n  wheelShouldScroll?: boolean;\n}\n\n/**\n * This provides some very basic common needs for a camera control system. This is not a total solution\n * for every scenario. This should just often handle most basic needs.\n */\nexport class BasicCamera2DController extends SimpleEventHandler {\n  /** Unique identifier of this controller */\n  get uid() {\n    return this._uid;\n  }\n  private _uid = uid();\n  /**\n   * If total bounds of worldbounds + screenpadding is smaller\n   * than width or height of view, anchor dictates placement.\n   */\n  bounds?: ICameraBoundsOptions;\n  /** This is the camera that this controller will manipulate */\n  get camera() {\n    return this._camera;\n  }\n  private _camera: Camera2D;\n  /** When this is set to true, the start view can be targetted even when behind other views */\n  ignoreCoverViews?: boolean;\n  /** Informative property indicating the controller is panning the chart or not */\n  isPanning: boolean = false;\n  /** Informative property indicationt he controller is scaling via touch gesture */\n  isScaling: boolean = false;\n  /** This is the filter applied to panning operations */\n  private panFilter = (\n    offset: [number, number, number],\n    _view: View<IViewProps>,\n    _allViews: View<IViewProps>[]\n  ) => offset;\n  /** The rate scale is adjusted with the mouse wheel */\n  scaleFactor: number;\n  /** This is the filter applied to tscaling operations */\n  private scaleFilter = (\n    scale: [number, number, number],\n    _view: View<IViewProps>,\n    _allViews: View<IViewProps>[]\n  ) => scale;\n  /** The view that must be the start or focus of the interactions in order for the interactions to occur */\n  startViews: string[] = [];\n  /** Whether a view can be scrolled by wheel */\n  wheelShouldScroll: boolean;\n  /** Indicates if panning will happen with two or more fingers down instead of one */\n  twoFingerPan: boolean;\n  /** Stores the views this controller has flagged for optimizing */\n  private optimizedViews = new Set<View<IViewProps>>();\n  /** The animation used to immediately position the camera */\n  private cameraImmediateAnimation = AutoEasingMethod.immediate<Vec3>(0);\n  /** This is the identifier of the primary touch controlling panning */\n  private targetTouches = new Set<number>();\n\n  /**\n   * If an unconvered start view is not available, this is the next available covered view, if present\n   */\n  private coveredStartView: View<IViewProps>;\n  /**\n   * Callback for when the range has changed for the camera in a view\n   */\n  private onRangeChanged = (\n    _camera: Camera2D,\n    _targetView: BaseProjection<any>\n  ) => {\n    /* no-op */\n  };\n\n  /**\n   * This flag is set to true when a start view is targetted on mouse down even if it is not\n   * the top most view.\n   */\n  private startViewDidStart: boolean = false;\n\n  constructor(options: IBasicCamera2DControllerOptions) {\n    super({});\n\n    if (options.bounds) {\n      this.setBounds(options.bounds);\n    }\n\n    this._camera = options.camera;\n    this.scaleFactor = options.scaleFactor || 1000.0;\n    this.ignoreCoverViews = options.ignoreCoverViews || false;\n    this.twoFingerPan = options.twoFingerPan || false;\n\n    if (options.startView) {\n      if (Array.isArray(options.startView)) {\n        this.startViews = options.startView;\n        this._camera.control2D.setViewChangeHandler(\n          this.handleCameraViewChange\n        );\n      } else {\n        this.startViews = [options.startView];\n        this._camera.control2D.setViewChangeHandler(\n          this.handleCameraViewChange\n        );\n      }\n    }\n\n    this.panFilter = options.panFilter || this.panFilter;\n    this.scaleFilter = options.scaleFilter || this.scaleFilter;\n    this.onRangeChanged = options.onRangeChanged || this.onRangeChanged;\n\n    if (options.wheelShouldScroll) {\n      this.wheelShouldScroll = options.wheelShouldScroll;\n    }\n  }\n\n  /**\n   * Corrects camera offset to respect the current bounds and anchor.\n   */\n  applyBounds = () => {\n    if (this.bounds && this.camera) {\n      const targetView = this.getView(this.bounds.view);\n      this.applyScaleBounds();\n\n      // Next bound the positioning\n      if (targetView) {\n        this.camera.control2D.getOffset()[0] = this.boundsHorizontalOffset(\n          targetView,\n          this.bounds\n        );\n\n        this.camera.control2D.getOffset()[1] = this.boundsVerticalOffset(\n          targetView,\n          this.bounds\n        );\n      }\n    }\n  };\n\n  /**\n   * Corrects camera scale to respect the current bounds and anchor.\n   */\n  applyScaleBounds = () => {\n    if (this.camera && this.bounds) {\n      // First bound the scaling\n      if (this.bounds.scaleMin) {\n        this.camera.control2D.setScale(\n          max3(this.camera.control2D.getScale(), this.bounds.scaleMin)\n        );\n      }\n\n      if (this.bounds.scaleMax) {\n        this.camera.control2D.setScale(\n          min3(this.camera.control2D.getScale(), this.bounds.scaleMax)\n        );\n      }\n    }\n  };\n\n  /**\n   * Calculation for adhering to an anchor - x-axis offset only.\n   */\n  anchoredByBoundsHorizontal(\n    targetView: View<IViewProps>,\n    bounds: ICameraBoundsOptions\n  ) {\n    switch (bounds.anchor) {\n      case CameraBoundsAnchor.TOP_LEFT:\n      case CameraBoundsAnchor.MIDDLE_LEFT:\n      case CameraBoundsAnchor.BOTTOM_LEFT:\n        return -(\n          bounds.worldBounds.left -\n          bounds.screenPadding.left / this.camera.control2D.getScale()[0]\n        );\n\n      case CameraBoundsAnchor.TOP_MIDDLE:\n      case CameraBoundsAnchor.MIDDLE:\n      case CameraBoundsAnchor.BOTTOM_MIDDLE:\n        return -(\n          bounds.worldBounds.right -\n          bounds.worldBounds.width / 2 -\n          0.5 *\n            ((targetView.screenBounds.width + bounds.screenPadding.right) /\n              this.camera.control2D.getScale()[0])\n        );\n\n      case CameraBoundsAnchor.TOP_RIGHT:\n      case CameraBoundsAnchor.MIDDLE_RIGHT:\n      case CameraBoundsAnchor.BOTTOM_RIGHT:\n        return -(\n          bounds.worldBounds.right -\n          (targetView.screenBounds.width - bounds.screenPadding.right) /\n            this.camera.control2D.getScale()[0]\n        );\n    }\n  }\n\n  /**\n   * Calculation for adhering to an anchor - y-axis offset only.\n   */\n  anchoredByBoundsVertical(\n    targetView: View<IViewProps>,\n    bounds: ICameraBoundsOptions\n  ) {\n    switch (bounds.anchor) {\n      case CameraBoundsAnchor.TOP_LEFT:\n      case CameraBoundsAnchor.TOP_MIDDLE:\n      case CameraBoundsAnchor.TOP_RIGHT:\n        return -(\n          bounds.worldBounds.top -\n          bounds.screenPadding.top / this.camera.control2D.getScale()[1]\n        );\n\n      case CameraBoundsAnchor.MIDDLE_LEFT:\n      case CameraBoundsAnchor.MIDDLE:\n      case CameraBoundsAnchor.MIDDLE_RIGHT:\n        return -(\n          bounds.worldBounds.bottom -\n          bounds.worldBounds.height / 2 -\n          0.5 *\n            ((targetView.screenBounds.height + bounds.screenPadding.bottom) /\n              this.camera.control2D.getScale()[1])\n        );\n\n      case CameraBoundsAnchor.BOTTOM_LEFT:\n      case CameraBoundsAnchor.BOTTOM_MIDDLE:\n      case CameraBoundsAnchor.BOTTOM_RIGHT:\n        return -(\n          bounds.worldBounds.bottom -\n          (targetView.screenBounds.height - bounds.screenPadding.bottom) /\n            this.camera.control2D.getScale()[1]\n        );\n    }\n  }\n\n  /**\n   * Returns offset on x-axis due to current bounds and anchor.\n   */\n  boundsHorizontalOffset(\n    targetView: View<IViewProps>,\n    bounds: ICameraBoundsOptions\n  ) {\n    const worldTLinScreenSpace = targetView.projection.worldToScreen([\n      bounds.worldBounds.left,\n      bounds.worldBounds.top\n    ]);\n    const worldBRinScreenSpace = targetView.projection.worldToScreen([\n      bounds.worldBounds.right,\n      bounds.worldBounds.bottom\n    ]);\n\n    const widthDifference =\n      worldBRinScreenSpace[0] -\n      worldTLinScreenSpace[0] +\n      bounds.screenPadding.left +\n      bounds.screenPadding.right -\n      targetView.screenBounds.width;\n\n    // If the worldBounds are smaller than the screenBounds,\n    // We offset according to the anchoring\n    if (widthDifference < 0) {\n      return this.anchoredByBoundsHorizontal(targetView, bounds);\n    }\n\n    if (\n      worldBRinScreenSpace[0] <\n      targetView.screenBounds.right - bounds.screenPadding.right\n    ) {\n      return (\n        -bounds.worldBounds.right +\n        (targetView.screenBounds.width - bounds.screenPadding.right) /\n          this.camera.control2D.getScale()[0]\n      );\n    }\n\n    if (\n      worldTLinScreenSpace[0] >\n      targetView.screenBounds.left + bounds.screenPadding.left\n    ) {\n      return (\n        -bounds.worldBounds.left +\n        bounds.screenPadding.left / this.camera.control2D.getScale()[0]\n      );\n    }\n\n    return this.camera.control2D.getOffset()[0];\n  }\n\n  /**\n   * Returns offset on y-axis due to current bounds and anchor.\n   */\n  boundsVerticalOffset(\n    targetView: View<IViewProps>,\n    bounds: ICameraBoundsOptions\n  ) {\n    const worldTLinScreenSpace = targetView.projection.worldToScreen([\n      bounds.worldBounds.left,\n      bounds.worldBounds.top\n    ]);\n    const worldBRinScreenSpace = targetView.projection.worldToScreen([\n      bounds.worldBounds.right,\n      bounds.worldBounds.bottom\n    ]);\n\n    const heightDifference =\n      worldBRinScreenSpace[1] -\n      worldTLinScreenSpace[1] +\n      bounds.screenPadding.top +\n      bounds.screenPadding.bottom -\n      targetView.screenBounds.height;\n\n    // If the viewBounds are larger than the screenBounds,\n    // We offset according to the anchoring\n    if (heightDifference < 0) {\n      return this.anchoredByBoundsVertical(targetView, bounds);\n    }\n\n    if (\n      worldBRinScreenSpace[1] <\n      targetView.screenBounds.bottom - bounds.screenPadding.bottom\n    ) {\n      return (\n        -bounds.worldBounds.bottom +\n        (targetView.screenBounds.height - bounds.screenPadding.bottom) /\n          this.camera.control2D.getScale()[1]\n      );\n    }\n\n    if (\n      worldTLinScreenSpace[1] >\n      targetView.screenBounds.top + bounds.screenPadding.top\n    ) {\n      return (\n        -bounds.worldBounds.top +\n        bounds.screenPadding.top / this.camera.control2D.getScale()[0]\n      );\n    }\n\n    return this.camera.control2D.getOffset()[1];\n  }\n\n  private canStart(viewId: string) {\n    return (\n      this.startViews.length === 0 ||\n      (this.startViews && this.startViews.indexOf(viewId) > -1) ||\n      (this.startViewDidStart && this.ignoreCoverViews)\n    );\n  }\n\n  /**\n   * Centers the camera on a position. Must provide a reference view.\n   */\n  centerOn(viewId: string, position: Vec3) {\n    if (!this.camera.control2D.surface) return;\n\n    const viewBounds = this.camera.control2D.surface.getViewSize(viewId);\n    if (!viewBounds) return;\n    const midScreen: Vec3 = [viewBounds.width / 2, viewBounds.height / 2, 0];\n    const fromScreenCenter: Vec3 = subtract3(\n      position,\n      divide3(midScreen, this.camera.control2D.getScale())\n    );\n\n    const newOffset = scale3(fromScreenCenter, -1);\n\n    this.setOffset(viewId, newOffset);\n  }\n\n  /**\n   * Performs the panning operation for the camera\n   *\n   * @param allViews This is all of the related views under the event interactions\n   * @param relativeView This is the view that performs the projections related to the operation\n   * @param allViews All the views associated with the operation or event interaction\n   * @param delta This is the amount of panning being requested to happen\n   */\n  private doPan(\n    allViews: View<IViewProps>[],\n    relativeView: View<IViewProps>,\n    delta: [number, number]\n  ) {\n    let pan: Vec3 = vec3(divide2(delta, this.camera.control2D.getScale()), 0);\n\n    if (this.panFilter) {\n      pan = this.panFilter(pan, relativeView, allViews);\n    }\n\n    this.camera.control2D.getOffset()[0] += pan[0];\n    this.camera.control2D.getOffset()[1] += pan[1];\n\n    // Add additional correction for bounds\n    this.applyBounds();\n    // Broadcast the change occurred\n    this.onRangeChanged(this.camera, relativeView.projection);\n    // Add additional correction for bounds\n    this.applyBounds();\n    // Indicate the camera needs a refresh\n    this.camera.control2D.update();\n  }\n\n  /**\n   * Scales the camera relative to a point and a view.\n   *\n   * @param focalPoint The point the scaling happens around\n   * @param targetView The relative view this operation happens in relation to\n   * @param deltaScale The amount of scaling per axis that should happen\n   */\n  private doScale(\n    focalPoint: Vec2,\n    targetView: View<IViewProps>,\n    allViews: View<IViewProps>[],\n    deltaScale: Vec3\n  ) {\n    const beforeZoom = targetView.projection.screenToWorld(focalPoint);\n    const currentZoomX = this.camera.control2D.getScale()[0] || 1.0;\n    const currentZoomY = this.camera.control2D.getScale()[1] || 1.0;\n\n    if (this.scaleFilter) {\n      deltaScale = this.scaleFilter(deltaScale, targetView, allViews);\n    }\n\n    this.camera.control2D.getScale()[0] = currentZoomX + deltaScale[0];\n    this.camera.control2D.getScale()[1] = currentZoomY + deltaScale[1];\n\n    // Ensure the new scale values are within bounds before attempting to correct offsets\n    this.applyScaleBounds();\n\n    const afterZoom = targetView.projection.screenToWorld(focalPoint);\n    const deltaZoom = subtract2(beforeZoom, afterZoom);\n    this.camera.control2D.getOffset()[0] -= deltaZoom[0];\n    this.camera.control2D.getOffset()[1] -= deltaZoom[1];\n\n    // Add additional correction for bounds\n    this.applyBounds();\n    // Broadcast the change occurred\n    this.onRangeChanged(this.camera, targetView.projection);\n    // Add additional correction for bounds\n    this.applyBounds();\n\n    // Make sure the camera updates\n    this.camera.control2D.update();\n    // Set the immediate animation AFTER setting so we don't get the offset to immediately jump\n    // to the end\n    this.camera.control2D.animation = this.cameraImmediateAnimation;\n  }\n\n  /**\n   * This filters a set of touches to be touches that had a valid starting view interaction.\n   */\n  filterTouchesByValidStart(touches: ISingleTouchInteraction[]) {\n    // If we ignore cover views, then the touches only have to contain a start view upon touch down\n    if (this.ignoreCoverViews) {\n      return touches.filter(touchesContainsStartView(this.startViews));\n    }\n\n    // Otherwise, the start touch has to be the primary start view\n    else {\n      return touches.filter(touchesHasStartView(this.startViews));\n    }\n  }\n\n  /**\n   * Finds a view within the event that matches a start view even if the view is covered by other views at the event's\n   * interaction point.\n   */\n  private findCoveredStartView(e: IMouseInteraction) {\n    const found = e.target.views.find(\n      under => this.startViews.indexOf(under.view.id) > -1\n    );\n    this.startViewDidStart = Boolean(found);\n\n    if (found) {\n      this.coveredStartView = found.view;\n    }\n  }\n\n  /**\n   * Evaluates the world bounds the specified view is observing\n   *\n   * @param viewId The id of the view when the view was generated when the surface was made\n   */\n  getRange(viewId: string): Bounds<never> {\n    /** Get the projections for the provided view */\n    const projection = this.getProjection(viewId);\n    /** Get the bounds on the screen for the indicated view */\n    const screenBounds = this.getViewScreenBounds(viewId);\n\n    // Make sure we have a valid projection and screen bounds to make the adjustment\n    if (projection && screenBounds) {\n      /** Get the current viewed world bounds of the view */\n      const topLeft = projection.screenToWorld([\n        screenBounds.x,\n        screenBounds.y\n      ]);\n      const bottomRight = projection.screenToWorld([\n        screenBounds.right,\n        screenBounds.bottom\n      ]);\n\n      return new Bounds({\n        height: bottomRight[1] - topLeft[1],\n        width: bottomRight[0] - topLeft[0],\n        x: topLeft[0],\n        y: topLeft[1]\n      });\n    }\n\n    return new Bounds({ x: 0, y: 0, width: 1, height: 1 });\n  }\n\n  private getTargetView(e: IMouseInteraction) {\n    // If we have a start view and we do not ignore covering views,\n    // Then our target view is the view we started with\n    if (this.startViews && !this.ignoreCoverViews) {\n      return e.target.view;\n    } else {\n      // Otherwise, we use the covered start view\n      return this.coveredStartView;\n    }\n  }\n\n  /**\n   * Used to aid in handling the pan effect and determine the contextual view targetted.\n   */\n  handleMouseDown(e: IMouseInteraction) {\n    if (this.startViews) {\n      // We look for valid covered views on mouse down so dragging will work\n      this.findCoveredStartView(e);\n\n      // If this is a valid start view, then we enter a panning state with the mouse down\n      if (e.start) {\n        this.isPanning = this.canStart(e.start.view.id) || this.isPanning;\n      }\n    }\n  }\n\n  /**\n   * Aids in understanding how the user is interacting with the views. If a single touch is present, we're panning.\n   * If multiple touches are present, we're panning and we're zooming\n   */\n  handleTouchDown(e: ITouchInteraction) {\n    if (this.startViews) {\n      const validTouches = this.filterTouchesByValidStart(e.allTouches);\n\n      if (this.twoFingerPan) {\n        if (validTouches.length > 1) {\n          this.isPanning = true;\n        }\n      } else {\n        if (validTouches.length > 0) {\n          this.isPanning = true;\n        }\n      }\n\n      if (validTouches.length > 1) {\n        this.isScaling = true;\n      }\n\n      for (let i = 0, iMax = validTouches.length; i < iMax; ++i) {\n        const touch = validTouches[i];\n        this.targetTouches.add(touch.touch.touch.identifier);\n      }\n    }\n  }\n\n  /**\n   * Used to aid in handling the pan effect. Stops panning operations when mouse is up.\n   */\n  handleMouseUp(_e: IMouseInteraction) {\n    this.startViewDidStart = false;\n    this.isPanning = false;\n    this.optimizedViews.forEach(view => (view.optimizeRendering = false));\n    this.optimizedViews.clear();\n  }\n\n  /**\n   * Used to stop panning and scaling effects\n   */\n  handleTouchUp(e: ITouchInteraction) {\n    e.touches.forEach(touch => {\n      this.targetTouches.delete(touch.touch.touch.identifier);\n\n      if (this.targetTouches.size <= 0) {\n        this.startViewDidStart = false;\n        this.isPanning = false;\n        this.optimizedViews.forEach(view => (view.optimizeRendering = false));\n        this.optimizedViews.clear();\n      }\n    });\n\n    this.isPanning = false;\n    this.isScaling = false;\n\n    if (this.targetTouches.size > 0) {\n      this.isPanning = true;\n    }\n\n    if (this.targetTouches.size > 1) {\n      this.isScaling = true;\n    }\n  }\n\n  /**\n   * Used to stop panning and scaling effects when touches are forcibly ejected from existence.\n   */\n  handleTouchCancelled(e: ITouchInteraction) {\n    e.touches.forEach(touch => {\n      this.targetTouches.delete(touch.touch.touch.identifier);\n\n      if (this.targetTouches.size <= 0) {\n        this.startViewDidStart = false;\n        this.isPanning = false;\n        this.optimizedViews.forEach(view => (view.optimizeRendering = false));\n        this.optimizedViews.clear();\n      }\n    });\n\n    this.isPanning = false;\n    this.isScaling = false;\n\n    if (this.targetTouches.size > 0) {\n      this.isPanning = true;\n    }\n\n    if (this.targetTouches.size > 1) {\n      this.isScaling = true;\n    }\n  }\n\n  /**\n   * Applies a panning effect by adjusting the camera's offset.\n   */\n  handleDrag(e: IMouseInteraction) {\n    if (e.start) {\n      if (this.canStart(e.start.view.id)) {\n        e.target.views.forEach(view => {\n          view.view.optimizeRendering = true;\n          this.optimizedViews.add(view.view);\n        });\n\n        // Panning the camera will always be immediate\n        this.doPan(\n          e.target.views.map(v => v.view),\n          e.start.view,\n          e.mouse.deltaPosition\n        );\n        // Set the immediate animation AFTER setting so we don't get the offset to immediately jump\n        // to the end\n        this.camera.control2D.animation = this.cameraImmediateAnimation;\n      }\n    }\n  }\n\n  /**\n   * Applies panning effect from single or multitouch interaction.\n   */\n  handleTouchDrag(e: ITouchInteraction) {\n    const validTouches = this.filterTouchesByValidStart(e.allTouches);\n\n    if (validTouches.length > 0 && this.isPanning) {\n      for (let i = 0, iMax = validTouches.length; i < iMax; ++i) {\n        const targetTouch = validTouches[i];\n\n        targetTouch.target.views.forEach(view => {\n          view.view.optimizeRendering = true;\n          this.optimizedViews.add(view.view);\n        });\n      }\n\n      // The relative view will be the view that was touched first.\n      // We also gather all relatedviews during this search.\n      const allViews = new Set<View<IViewProps>>();\n      const firstTouch = validTouches.reduce((p, n) => {\n        for (let i = 0, iMax = n.target.views.length; i < iMax; ++i) {\n          const v = n.target.views[i];\n          allViews.add(v.view);\n        }\n\n        return n.touch.startTime < p.touch.startTime ? n : p;\n      }, validTouches[0]);\n\n      const relativeView = firstTouch.start.view;\n\n      if (this.isPanning) {\n        // Panning the camera will always be immediate\n        this.doPan(\n          Array.from(allViews.values()),\n          relativeView,\n          e.multitouch.centerDelta(validTouches)\n        );\n        // Set the immediate animation AFTER setting so we don't get the offset to immediately jump\n        // to the end\n        this.camera.control2D.animation = this.cameraImmediateAnimation;\n      }\n\n      // Now we handle the magic of pinch to zoom. To make this 'feel' right the gesture needs to scale the surface so\n      // that (in the case of two fingers) the fingers will remain on the world coordinates of what they were touching\n      // throughout the scaling experience.\n      if (this.isScaling) {\n        // We must get the centroid of the touches for the current event\n        const currentWorldCenter = e.multitouch.center(validTouches);\n\n        // We must also calculate the current frame's distance from the centroid to compare against the previous frame's\n        const currentCenterToTouch = subtract2(\n          validTouches[0].touch.currentPosition,\n          currentWorldCenter\n        );\n\n        // We must get the centroid of the touches for the previous known event\n        const previousWorldCenter = subtract2(\n          currentWorldCenter,\n          e.multitouch.centerDelta(validTouches)\n        );\n\n        // We must now calculate how far our touch in the previous frame was from our current frame\n        const previousCenterToTouch = subtract2(\n          validTouches[0].touch.previousPosition,\n          previousWorldCenter\n        );\n\n        // This is how much scaling it takes to get from the previous touch to the current touch relative to the vectors\n        // per axis\n        const scaleToCurrentTouch =\n          length2(currentCenterToTouch) / length2(previousCenterToTouch);\n\n        const deltaScale: Vec3 = [\n          scaleToCurrentTouch * this.camera.scale2D[0] - this.camera.scale2D[0],\n          scaleToCurrentTouch * this.camera.scale2D[1] - this.camera.scale2D[1],\n          0\n        ];\n\n        if (scaleToCurrentTouch !== 1) {\n          this.doScale(\n            currentWorldCenter,\n            relativeView,\n            Array.from(allViews.values()),\n            deltaScale\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Applies a scaling effect to the camera for mouse wheel events\n   */\n  handleWheel(e: IMouseInteraction) {\n    // Every mouse wheel event must look to see if it's over a valid covered start view\n    this.findCoveredStartView(e);\n\n    if (this.canStart(e.target.view.id)) {\n      if (this.wheelShouldScroll) {\n        const deltaPosition: [number, number] = [\n          -e.mouse.wheel.delta[0],\n          e.mouse.wheel.delta[1]\n        ];\n\n        if (e.start) {\n          this.doPan(\n            e.target.views.map(v => v.view),\n            e.start.view,\n            deltaPosition\n          );\n        }\n      } else {\n        const currentZoomX = this.camera.control2D.getScale()[0] || 1.0;\n        const currentZoomY = this.camera.control2D.getScale()[1] || 1.0;\n        const targetView = this.getTargetView(e);\n\n        const deltaScale: [number, number, number] = [\n          (e.mouse.wheel.delta[1] / this.scaleFactor) * currentZoomX,\n          (e.mouse.wheel.delta[1] / this.scaleFactor) * currentZoomY,\n          1\n        ];\n\n        this.doScale(\n          e.screen.position,\n          targetView,\n          e.target.views.map(v => v.view),\n          deltaScale\n        );\n      }\n    }\n  }\n\n  /**\n   * Handles changes broadcasted by the camera\n   */\n  private handleCameraViewChange = (cam: Camera2D, viewId: string) => {\n    if (viewId !== this.startViews[0]) return;\n    const projections = this.surface.getProjections(viewId);\n    if (!projections) return;\n    this.onRangeChanged(cam, projections);\n  };\n\n  /**\n   * Retrieves the current pan of the controlled camera\n   */\n  get pan(): Vec3 {\n    return this.camera.control2D.offset;\n  }\n\n  /**\n   * Retrieves the current scale of the camera\n   */\n  get scale(): Vec3 {\n    return this.camera.control2D.getScale();\n  }\n\n  /**\n   * Sets bounds applicable to the supplied view.\n   * If no view is supplied, it uses the first in the startViews array\n   */\n  setBounds(bounds: ICameraBoundsOptions) {\n    this.bounds = bounds;\n    this.applyBounds();\n  }\n\n  /**\n   * Tells the controller to set an explicit offset for the camera.\n   * Must provide a reference view.\n   */\n  setOffset(viewId: string, offset: Vec3) {\n    const startOffset = copy3(this.camera.control2D.offset);\n\n    this.camera.control2D.getOffset()[0] = offset[0];\n    this.camera.control2D.getOffset()[1] = offset[1];\n    this.camera.control2D.getOffset()[2] = offset[2];\n\n    // Add additional correction for bounds\n    this.applyBounds();\n\n    // Broadcast the change occurred\n    if (this.camera.control2D.surface) {\n      const projections = this.camera.control2D.surface.getProjections(viewId);\n\n      if (projections) {\n        this.onRangeChanged(this.camera, projections);\n      }\n    }\n\n    // Add additional correction for bounds\n    this.applyBounds();\n    const newOffset = copy3(this.camera.control2D.getOffset());\n\n    const currentAnimation = this.camera.control2D.animation;\n    this.camera.control2D.setOffset(startOffset);\n    this.camera.control2D.animation = this.cameraImmediateAnimation;\n    this.camera.control2D.setOffset(newOffset);\n    this.camera.control2D.animation = currentAnimation;\n  }\n\n  /**\n   * This lets you set the visible range of a view based on the view's camera. This will probably not work\n   * as expected if the view indicated and this controller do not share the same camera.\n   *\n   * @param viewId The id of the view when the view was generated when the surface was made\n   */\n  setRange(newWorld: Bounds<{}>, viewId: string) {\n    /** Get the projections for the provided view */\n    const projection = this.getProjection(viewId);\n    /** Get the bounds on the screen for the indicated view */\n    const screenBounds = this.getViewScreenBounds(viewId);\n    /** Get the view the range is being applied towards */\n    const view = this.getView(viewId);\n\n    // Make sure we have a valid projection and screen bounds to make the adjustment\n    if (projection && screenBounds && view) {\n      const deltaScale = subtract3(\n        [\n          screenBounds.width / newWorld.width,\n          screenBounds.height / newWorld.height,\n          1\n        ],\n        this.camera.control2D.getScale()\n      );\n\n      this.camera.control2D.setScale(\n        add3(\n          this.camera.control2D.getScale(),\n          this.scaleFilter(deltaScale, view, [view])\n        )\n      );\n\n      const deltaPan = subtract3(\n        [-newWorld.x, -newWorld.y, 0],\n        this.camera.control2D.offset\n      );\n\n      this.camera.control2D.setOffset(\n        add3(\n          this.camera.control2D.offset,\n          this.scaleFilter(deltaPan, view, [view])\n        )\n      );\n\n      // Bound the camera to the specified bounding range\n      this.applyBounds();\n      // Broadcast the change occurred\n      this.onRangeChanged(this.camera, view.projection);\n      // Bound the camera to the specified bounding range\n      this.applyBounds();\n    }\n  }\n\n  /**\n   * Applies a handler for the range changing.\n   */\n  setRangeChangeHandler(handler: BasicCamera2DController[\"onRangeChanged\"]) {\n    this.onRangeChanged = handler;\n  }\n}\n","import { Camera2D } from \"./camera-2d\";\nimport { Control2D } from \"./control-2d\";\n\nexport interface IReferenceControl2DOptions {\n  /** This is the base camera to monitor */\n  base: Control2D;\n  /**\n   * This is a filter applied to the offset that comes from the chart camera.\n   */\n  offsetFilter?(offset: [number, number, number]): [number, number, number];\n  /**\n   * This is a filter applied to the scale that comes from the chart camera.\n   */\n  scaleFilter?(scale: [number, number, number]): [number, number, number];\n}\n\nclass ReferenceControl2D extends Control2D {\n  base: Control2D;\n  private offsetFilter = (offset: [number, number, number]) => offset;\n  private scaleFilter = (scale: [number, number, number]) => scale;\n\n  set offset(_val: any) {\n    /** no-op */\n  }\n\n  get offset() {\n    return this.offsetFilter(this.base.offset);\n  }\n\n  set scale(_val: any) {\n    /** no-op */\n  }\n\n  get scale() {\n    return this.scaleFilter(this.base.scale);\n  }\n\n  constructor(camera: Camera2D, options: IReferenceControl2DOptions) {\n    super(camera);\n    this.base = options.base;\n    this.offsetFilter = options.offsetFilter || this.offsetFilter;\n    this.scaleFilter = options.scaleFilter || this.scaleFilter;\n  }\n}\n\nexport interface IReferenceCamera2DOptions {\n  /** This is the base camera to monitor */\n  base: Camera2D;\n  /**\n   * This is a filter applied to the offset that comes from the chart camera.\n   */\n  offsetFilter?(offset: [number, number, number]): [number, number, number];\n  /**\n   * This is a filter applied to the scale that comes from the chart camera.\n   */\n  scaleFilter?(scale: [number, number, number]): [number, number, number];\n}\n\n/**\n * This is a camera that is based on another camera. This can apply filters\n * to the information provided from the base camera.\n *\n * Useful for situations such as a chart having a chart area and a list on the\n * left. This can use the same camera the chart area uses, but filter the response\n * to only track the y offset of the base camera.\n *\n * That would allow easy tracking of the left list to track with elements in the\n * chart and only manipulate a single camera instead of managing many cameras and\n * tie them together with lots of events.\n */\nexport class ReferenceCamera2D extends Camera2D {\n  private base: Camera2D;\n  private _control2D: ReferenceControl2D;\n\n  set control2D(_val: Control2D) {\n    /** Noop */\n  }\n  get control2D() {\n    return this._control2D;\n  }\n\n  constructor(options: IReferenceCamera2DOptions) {\n    super();\n    this.base = options.base;\n\n    this._control2D = new ReferenceControl2D(this.base, {\n      base: this.base.control2D,\n      offsetFilter: options.offsetFilter,\n      scaleFilter: options.scaleFilter\n    });\n  }\n}\n","import { Bounds } from \"../../math/primitives/bounds\";\nimport { add3 } from \"../../math/vector\";\nimport { IViewProps, View } from \"../../surface\";\nimport { LayerScene } from \"../../surface/layer-scene\";\nimport { Camera, CameraProjectionType } from \"../../util/camera\";\nimport { Camera2D } from \"./camera-2d\";\nimport { Projection2D } from \"./projection-2d\";\n\n/**\n * Defines the input metrics of a view for a scene.\n */\nexport interface IView2DProps extends IViewProps {\n  /** Redefine the camera applied to this view to ensure it's a 2D camera. */\n  camera: Camera2D;\n}\n\n/**s\n * Type guard to ensure the camera type is orthographic\n */\nfunction isOrthographic(val: Camera): val is Camera {\n  return val.projectionType === CameraProjectionType.ORTHOGRAPHIC;\n}\n\n/**\n * A View renders a perspective of a scene to a given surface or surfaces.\n */\nexport class View2D<TViewProps extends IView2DProps> extends View<TViewProps> {\n  static defaultProps: IView2DProps = {\n    key: \"\",\n    camera: new Camera2D(),\n    viewport: {\n      left: 0,\n      right: 0,\n      bottom: 0,\n      top: 0\n    }\n  };\n\n  /** These are the projection methods specific to rendering with this 2D system. */\n  projection: Projection2D = new Projection2D();\n\n  constructor(scene: LayerScene, options: TViewProps) {\n    super(scene, options);\n    this.projection.camera = options.camera || new Camera2D();\n  }\n\n  /**\n   * This operation makes sure we have the view camera adjusted to the new viewport's needs.\n   * For default behavior this ensures that the coordinate system has no distortion or perspective, orthographic,\n   * top left as 0,0 with +y axis pointing down.\n   */\n  fitViewtoViewport(\n    _surfaceDimensions: Bounds<never>,\n    viewBounds: Bounds<View<IViewProps>>\n  ) {\n    if (isOrthographic(this.props.camera)) {\n      const width = viewBounds.width;\n      const height = viewBounds.height;\n\n      const viewport = {\n        bottom: -height / 2,\n        far: 10000000,\n        left: -width / 2,\n        near: -100,\n        right: width / 2,\n        top: height / 2\n      };\n\n      const scaleX = 1 / this.pixelRatio;\n      const scaleY = 1 / this.pixelRatio;\n      const camera = this.props.camera;\n\n      camera.projectionOptions = Object.assign(\n        camera.projectionOptions,\n        viewport\n      );\n      camera.position = [\n        viewBounds.width / (2.0 * this.pixelRatio),\n        viewBounds.height / (2.0 * this.pixelRatio),\n        camera.position[2]\n      ];\n      camera.scale = [scaleX, -scaleY, 1.0];\n      // Always face the -z direction\n      camera.lookAt(add3(camera.position, [0, 0, -1]), [0, 1, 0]);\n      camera.update();\n\n      this.projection.viewBounds = viewBounds;\n      viewBounds.d = this;\n      this.projection.screenBounds = new Bounds<View<TViewProps>>({\n        height: this.viewBounds.height / this.pixelRatio,\n        width: this.viewBounds.width / this.pixelRatio,\n        x: this.viewBounds.x / this.pixelRatio,\n        y: this.viewBounds.y / this.pixelRatio\n      });\n      this.screenBounds.d = this;\n    } else if (!isOrthographic(this.props.camera)) {\n      console.warn(\"View2D does not support non-orthographic cameras.\");\n    }\n  }\n\n  willUpdateProps(newProps: IView2DProps) {\n    this.projection.camera = newProps.camera;\n  }\n}\n","import { BaseProjection, Ray, Vec2 } from \"../../math\";\nimport { Camera2D } from \"./camera-2d\";\n\nexport class Projection2D extends BaseProjection<any> {\n  camera: Camera2D;\n\n  /**\n   * Maps a coordinate relative to the screen to a coordinate found within the world space.\n   */\n  screenToWorld(point: Vec2, out?: Vec2) {\n    const view = this.screenToView(point);\n\n    const world = out || [0, 0];\n    world[0] =\n      (view[0] - this.camera.control2D.offset[0] * this.camera.scale2D[0]) /\n      this.camera.scale2D[0];\n    world[1] =\n      (view[1] - this.camera.control2D.offset[1] * this.camera.scale2D[1]) /\n      this.camera.scale2D[1];\n\n    return world;\n  }\n\n  /**\n   * Makes a ray from the provided point that emanates into 3D space straight\n   * into the screen. Since our spaces have 3D tendencies, this can have some\n   * useful applications for interacting with the 2D elements in interesting and\n   * new ways.\n   */\n  screenRay(point: Vec2): Ray {\n    const world = this.screenToWorld(point);\n\n    return [\n      [world[0], world[1], 0],\n      [world[0], world[1], -1]\n    ];\n  }\n\n  /**\n   * Maps a coordinate found within the world to a relative coordinate within the screen space.\n   */\n  worldToScreen(point: Vec2, out?: Vec2) {\n    const screen: Vec2 = [0, 0];\n\n    // Calculate from the camera to view space\n    screen[0] =\n      (point[0] * this.camera.scale2D[0] +\n        this.camera.control2D.offset[0] * this.camera.scale2D[0]) *\n      this.pixelRatio;\n    screen[1] =\n      (point[1] * this.camera.scale2D[1] +\n        this.camera.control2D.offset[1] * this.camera.scale2D[1]) *\n      this.pixelRatio;\n\n    // Convert from view to screen space\n    return this.viewToScreen(screen, out);\n  }\n\n  /**\n   * Maps a coordinate relative to the view's viewport to a coordinate found within the world.\n   */\n  viewToWorld(point: Vec2, out?: Vec2) {\n    const world = out || [0, 0];\n\n    const screen = point;\n    world[0] =\n      (screen[0] - this.camera.control2D.offset[0] * this.camera.scale2D[0]) /\n      this.camera.scale2D[0];\n    world[1] =\n      (screen[1] - this.camera.control2D.offset[1] * this.camera.scale2D[1]) /\n      this.camera.scale2D[1];\n\n    return world;\n  }\n\n  /**\n   * Maps a coordinate found within the world to a relative coordinate within the view's viewport.\n   */\n  worldToView(point: Vec2, out?: Vec2) {\n    const screen = out || [0, 0];\n\n    // Calculate from the camera to view space\n    screen[0] =\n      point[0] * this.camera.scale2D[0] +\n      this.camera.control2D.offset[0] * this.camera.scale2D[0];\n    screen[1] =\n      point[1] * this.camera.scale2D[1] +\n      this.camera.control2D.offset[1] * this.camera.scale2D[1];\n\n    return screen;\n  }\n}\n","export * from \"./arcs\";\nexport * from \"./circles\";\nexport * from \"./edges\";\nexport * from \"./images\";\nexport * from \"./labels\";\nexport * from \"./rectangle\";\nexport * from \"./rings\";\n","export * from \"./arc-layer\";\nexport * from \"./arc-instance\";\n","import { GLSettings } from \"../../../gl\";\nimport { InstanceProvider } from \"../../../instance-provider\";\nimport { IAutoEasingMethod, Vec } from \"../../../math\";\nimport {\n  ILayerMaterialOptions,\n  InstanceAttributeSize,\n  IShaderInitialization,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../../types\";\nimport { CommonMaterialOptions } from \"../../../util\";\nimport { ILayer2DProps, Layer2D } from \"../../view/layer-2d\";\nimport { ArcInstance } from \"./arc-instance\";\n\nexport enum ArcScaleType {\n  /** All dimensions are within world space */\n  NONE,\n  /**\n   * The thickness of the arc is in screen space. Thus, camera zoom changes will not affect it and\n   * must be controlled by scaleFactor alone.\n   */\n  SCREEN_CURVE\n}\n\nexport interface IArcLayerProps<T extends ArcInstance>\n  extends ILayer2DProps<T> {\n  scaleType?: ArcScaleType;\n  animate?: {\n    angle?: IAutoEasingMethod<Vec>;\n    angleOffset?: IAutoEasingMethod<Vec>;\n    center?: IAutoEasingMethod<Vec>;\n    colorEnd?: IAutoEasingMethod<Vec>;\n    colorStart?: IAutoEasingMethod<Vec>;\n    radius?: IAutoEasingMethod<Vec>;\n    thickness?: IAutoEasingMethod<Vec>;\n  };\n}\n\n/**\n * This layer displays Arcs and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class ArcLayer<\n  T extends ArcInstance,\n  U extends IArcLayerProps<T>\n> extends Layer2D<T, U> {\n  static defaultProps: IArcLayerProps<ArcInstance> = {\n    data: new InstanceProvider<ArcInstance>(),\n    key: \"\",\n    scaleType: ArcScaleType.NONE\n  };\n\n  /** Easy lookup of all attribute names for the layer */\n  static attributeNames = {\n    angle: \"angle\",\n    angleOffset: \"angleOffset\",\n    center: \"center\",\n    colorEnd: \"colorEnd\",\n    colorStart: \"colorStart\",\n    depth: \"depth\",\n    radius: \"radius\",\n    thickness: \"thickness\"\n  };\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<ArcInstance> {\n    const { scaleType } = this.props;\n    const animations = this.props.animate || {};\n    const {\n      angle: animateAngle,\n      angleOffset: animateAngleOffset,\n      center: animateCenter,\n      radius: animateRadius,\n      thickness: animateThickness,\n      colorStart: animateColorStart,\n      colorEnd: animateColorEnd\n    } = animations;\n\n    const MAX_SEGMENTS = 150;\n\n    // Calculate the normals and interpolations for our vertices\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      [MAX_SEGMENTS * 2 + 2]: -1\n    };\n\n    const vertexInterpolation: { [key: number]: number } = {\n      0: 0,\n      [MAX_SEGMENTS * 2 + 2]: 1\n    };\n\n    let sign = 1;\n    for (let i = 0; i < MAX_SEGMENTS * 2; ++i) {\n      vertexToNormal[i + 1] = sign;\n      vertexInterpolation[i + 1] = Math.floor(i / 2) / (MAX_SEGMENTS - 1);\n      sign *= -1;\n    }\n\n    const vs =\n      scaleType === ArcScaleType.NONE\n        ? require(\"./arc-layer.vs\")\n        : require(\"./arc-layer-screen-space.vs\");\n\n    return {\n      fs: require(\"./arc-layer.fs\"),\n      instanceAttributes: [\n        {\n          easing: animateCenter,\n          name: ArcLayer.attributeNames.center,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.center\n        },\n        {\n          easing: animateRadius,\n          name: ArcLayer.attributeNames.radius,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.radius]\n        },\n        {\n          name: ArcLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        {\n          easing: animateThickness,\n          name: ArcLayer.attributeNames.thickness,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.thickness\n        },\n        {\n          easing: animateAngle,\n          name: ArcLayer.attributeNames.angle,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.angle\n        },\n        {\n          easing: animateAngleOffset,\n          name: ArcLayer.attributeNames.angleOffset,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.angleOffset]\n        },\n        {\n          easing: animateColorStart,\n          name: ArcLayer.attributeNames.colorStart,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.colorStart\n        },\n        {\n          easing: animateColorEnd,\n          name: ArcLayer.attributeNames.colorEnd,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.colorEnd\n        }\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: _u => [1]\n        }\n      ],\n      vertexAttributes: [\n        {\n          name: \"vertex\",\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexInterpolation[vertex],\n            // The number of vertices\n            MAX_SEGMENTS * 2\n          ]\n        }\n      ],\n      vertexCount: MAX_SEGMENTS * 2 + 2,\n      vs\n    };\n  }\n\n  getMaterialOptions(): ILayerMaterialOptions {\n    return Object.assign({}, CommonMaterialOptions.transparentShapeBlending, {\n      culling: GLSettings.Material.CullSide.NONE\n    } as ILayerMaterialOptions);\n  }\n}\n","module.exports = \"${import: arc}\\nprecision highp float;\\nvarying vec4 vertexColor;\\nvoid main() {\\nfloat startAngle = angle.x + angleOffset;\\nfloat endAngle = angle.y + angleOffset;\\nfloat widthStart = thickness.x;\\nfloat widthEnd = thickness.y;\\nfloat normal = vertex.x;\\nfloat interpolationTime = vertex.y;\\nfloat interpolationIncrement = 1.0 / vertex.z;\\nvec2 currentPosition = arc(interpolationTime, center, radius, startAngle, endAngle);\\nvec2 currentNormal = normalize(currentPosition - center);\\nfloat lineThickness = mix(widthStart, widthEnd, interpolationTime) / 2.0;\\nvec2 vertex = currentPosition + currentNormal * (normal * lineThickness);\\nvertexColor = mix(colorStart, colorEnd, interpolationTime);\\ngl_Position = clipSpace(vec3(vertex, depth));\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvec2 interpolation(float t, vec2 center, float radius, float start, float end) {\\nfloat angle = (end - start) * t + start;\\nreturn center + vec2(cos(angle) * radius, sin(angle) * radius);\\n}\\nvoid main() {\\nfloat startAngle = angle.x;\\nfloat endAngle = angle.y;\\nfloat widthStart = thickness.x;\\nfloat widthEnd = thickness.y;\\nvec4 centerClip = clipSpace(vec3(center, depth));\\nvec2 centerScreen = (centerClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\nfloat normal = position.x;\\nfloat interpolationTime = position.y;\\nfloat interpolationIncrement = 1.0 / position.z;\\nvec2 currentPosition = interpolation(interpolationTime, centerScreen, radius, startAngle, endAngle);\\nvec2 currentNormal = normalize(currentPosition - centerScreen);\\nfloat lineThickness = mix(widthStart, widthEnd, interpolationTime) / 2.0;\\nvec2 vertex = currentPosition + currentNormal * (normal * lineThickness);\\nvertexColor = mix(colorStart, colorEnd, interpolationTime);\\nvertexColor *= vertexColor.a;\\ngl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), centerClip.zw);\\ngl_PointSize = 5.0;\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvoid main() {\\ngl_FragColor = vertexColor;\\n}\"","import { observable } from \"../../../instance-provider\";\nimport {\n  IInstanceOptions,\n  Instance\n} from \"../../../instance-provider/instance\";\nimport { Vec2, Vec4 } from \"../../../math\";\n\nexport interface IArcInstanceOptions extends IInstanceOptions {\n  /** The start and end angle of the arc */\n  angle: Vec2;\n  /** The center point where the arc wraps around */\n  center: Vec2;\n  /** This is the end color of the arc */\n  colorEnd?: Vec4;\n  /** This is the start color of the arc */\n  colorStart?: Vec4;\n  /** Depth sorting of the arc (or the z value of the arc) */\n  depth?: number;\n  /** The radius of how far the middle of the arc is from the center point */\n  radius: number;\n  /** The start to end thickness of the arc */\n  thickness?: Vec2;\n}\n\n/**\n * This generates a new arc instance. An arc is a shape with a center and an angle that\n * is spans. This effectively can be used for a 'pie slice' or just the edge line on the pie\n * slice.\n */\nexport class ArcInstance extends Instance {\n  /** The start and end angle of the arc */\n  @observable angle: Vec2 = [0, Math.PI];\n  /** This is the end color of the arc */\n  @observable colorEnd: Vec4 = [1, 1, 1, 1];\n  /** This is the start color of the arc */\n  @observable colorStart: Vec4 = [1, 1, 1, 1];\n  /** The center point where the arc wraps around */\n  @observable center: Vec2 = [0, 0];\n  /** Depth sorting of the arc (or the z value of the arc) */\n  @observable depth: number = 0;\n  /** An offset to apply to the angle. This makes it easy to animate the arc or set a point of reference for angle 0 */\n  @observable angleOffset: number = 0;\n  /** The radius of how far the middle of the arc is from the center point */\n  @observable radius: number = 1;\n  /** The start to end thickness of the arc */\n  @observable thickness: Vec2 = [5, 5];\n\n  constructor(options: IArcInstanceOptions) {\n    super(options);\n\n    this.angle = options.angle || this.angle;\n    this.colorEnd = options.colorEnd || this.colorEnd;\n    this.colorStart = options.colorStart || this.colorStart;\n    this.center = options.center || this.center;\n    this.depth = options.depth || this.depth;\n    this.radius = options.radius || this.radius;\n    this.thickness = options.thickness || this.thickness;\n  }\n}\n","export * from \"./circle-layer\";\nexport * from \"./circle-instance\";\n","import { GLSettings } from \"../../../gl\";\nimport { InstanceProvider } from \"../../../instance-provider\";\nimport { Vec } from \"../../../math\";\nimport { IAutoEasingMethod } from \"../../../math/auto-easing-method\";\nimport {\n  FragmentOutputType,\n  ILayerMaterialOptions,\n  InstanceAttributeSize,\n  IShaderInitialization,\n  IUniform,\n  IVertexAttribute,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../../types\";\nimport { CommonMaterialOptions } from \"../../../util\";\nimport { ILayer2DProps, Layer2D } from \"../../view/layer-2d\";\nimport { CircleInstance } from \"./circle-instance\";\n\nexport interface ICircleLayerProps<T extends CircleInstance>\n  extends ILayer2DProps<T> {\n  /**\n   * This is the properties that can toggle on animations.\n   *\n   * NOTE: The more properties declared as animated will reduce the performance of the layer.\n   * if animated properties are created, it can be beneficial to have other layers with no\n   * animations be available for the Instances to 'rest' in when not moving.\n   */\n  animate?: {\n    center?: IAutoEasingMethod<Vec>;\n    radius?: IAutoEasingMethod<Vec>;\n    color?: IAutoEasingMethod<Vec>;\n  };\n  /** Opacity of the layer as a whole */\n  opacity?(): number;\n  /**\n   * When set, this causes the circles to be rendered utilizing the hardware POINTS mode. POINTS mode has limitations:\n   * Different GPUs have different MAX POINT SIZE values, so the points can only be rendered up to a certain size. Also\n   * points can have unexpected culling that occurs at the edge of the viewport.\n   *\n   * However, this mode has GREATLY improved performance when utilized correctly. So use for the correct situation, but\n   * beware it's weak 'points' <- this is a pun in the comments of this code base. <- this is me being over zealous in\n   * clarifying so the apostraphes don't lead to unecessary conclusions.\n   */\n  usePoints?: boolean;\n}\n\n/**\n * This layer displays circles and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class CircleLayer<\n  T extends CircleInstance,\n  U extends ICircleLayerProps<T>\n> extends Layer2D<T, U> {\n  static defaultProps: ICircleLayerProps<CircleInstance> = {\n    data: new InstanceProvider<CircleInstance>(),\n    key: \"\"\n  };\n\n  static attributeNames = {\n    center: \"center\",\n    color: \"color\",\n    depth: \"depth\",\n    radius: \"radius\"\n  };\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<CircleInstance> {\n    const { animate = {}, usePoints = false, opacity = () => 1 } = this.props;\n\n    const {\n      center: animateCenter,\n      radius: animateRadius,\n      color: animateColor\n    } = animate;\n\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: -1,\n      1: -1,\n      2: -1,\n      3: 1,\n      4: 1,\n      5: 1\n    };\n\n    const vertexAttributes: IVertexAttribute[] = [\n      {\n        name: \"normals\",\n        size: VertexAttributeSize.TWO,\n        update: (vertex: number) => [\n          // Normal\n          vertexToNormal[vertex],\n          // The side of the quad\n          vertexToSide[vertex]\n        ]\n      }\n    ];\n\n    const vertexCount = 6;\n\n    return {\n      drawMode: usePoints\n        ? GLSettings.Model.DrawMode.POINTS\n        : GLSettings.Model.DrawMode.TRIANGLE_STRIP,\n      fs: usePoints\n        ? [\n            {\n              outputType: FragmentOutputType.COLOR,\n              source: require(\"./circle-layer-points.fs\")\n            },\n            {\n              outputType: FragmentOutputType.GLOW,\n              source: `\n              void main() {\n                $\\{out: glow} = color;\n              }\n              `\n            }\n          ]\n        : [\n            {\n              outputType: FragmentOutputType.COLOR,\n              source: require(\"./circle-layer.fs\")\n            },\n            {\n              outputType: FragmentOutputType.GLOW,\n              source: `\n              void main() {\n                $\\{out: glow} = color;\n              }\n              `\n            }\n          ],\n      instanceAttributes: [\n        {\n          easing: animateCenter,\n          name: CircleLayer.attributeNames.center,\n          size: InstanceAttributeSize.TWO,\n          update: circle => circle.center\n        },\n        {\n          easing: animateRadius,\n          name: CircleLayer.attributeNames.radius,\n          size: InstanceAttributeSize.ONE,\n          update: circle => [circle.radius]\n        },\n        {\n          name: CircleLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: circle => [circle.depth]\n        },\n        {\n          easing: animateColor,\n          name: CircleLayer.attributeNames.color,\n          size: InstanceAttributeSize.FOUR,\n          update: circle => circle.color\n        }\n      ],\n      uniforms: [\n        {\n          name: \"layerOpacity\",\n          size: UniformSize.ONE,\n          update: (_uniform: IUniform) => [opacity()]\n        }\n      ],\n      vertexAttributes: usePoints ? undefined : vertexAttributes,\n      vertexCount: usePoints ? 0 : vertexCount,\n      vs: usePoints\n        ? require(\"./circle-layer-points.vs\")\n        : require(\"./circle-layer.vs\")\n    };\n  }\n\n  getMaterialOptions(): ILayerMaterialOptions {\n    return CommonMaterialOptions.transparentShapeBlending;\n  }\n}\n","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvarying float edgeSharpness;\\nvarying float edgeSharpnessBase;\\nfloat circle(vec2 coord, float radius){\\nvec2 dist = coord - vec2(0.5);\\nreturn 1.0 - smoothstep(\\nradius - (radius * edgeSharpness),\\nradius + (radius * edgeSharpnessBase),\\ndot(dist, dist) * 4.0\\n);\\n}\\nvoid main() {\\nfloat step_factor = circle(gl_PointCoord, 1.0);\\n${out: color} = mix(\\nvec4(0.0, 0.0, 0.0, 0.0),\\nvertexColor,\\nstep_factor\\n);\\nif (color.a == 0.0) discard;\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvarying float edgeSharpness;\\nvarying float edgeSharpnessBase;\\nvarying vec2 pointCoord;\\nfloat circle(vec2 coord, float radius){\\nvec2 dist = coord - vec2(0.5);\\nreturn 1.0 - smoothstep(\\nradius - (radius * edgeSharpness),\\nradius + (radius * edgeSharpnessBase),\\ndot(dist, dist) * 4.0\\n);\\n}\\nvoid main() {\\nfloat step_factor = circle(pointCoord, 1.0);\\n${out: color} = mix(\\nvec4(0.0, 0.0, 0.0, 0.0),\\nvertexColor,\\nstep_factor\\n);\\nif (color.a == 0.0) discard;\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvarying float edgeSharpness;\\nvarying float edgeSharpnessBase;\\nvoid main() {\\nvertexColor = color;\\nvertexColor.a *= layerOpacity;\\nfloat size = radius * cameraScale2D.x;\\nedgeSharpness = mix(0.8, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));\\nedgeSharpnessBase = mix(0.1, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));\\ngl_Position = clipSpace(vec3(center, depth));\\ngl_PointSize = size * 2.0 * pixelRatio;\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvarying float edgeSharpness;\\nvarying float edgeSharpnessBase;\\nvarying vec2 pointCoord;\\nvoid main() {\\nvertexColor = color;\\nvertexColor.a *= layerOpacity;\\nfloat size = radius * cameraScale2D.x * pixelRatio;\\nedgeSharpness = mix(0.8, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));\\nedgeSharpnessBase = mix(0.1, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));\\npointCoord = (normals.xy + vec2(1.0, 1.0)) / 2.0;\\nvec4 clipCenter = clipSpace(vec3(center, depth));\\nvec2 screenCenter = (clipCenter.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\nvec2 vertex = (normals.xy * size) + screenCenter;\\ngl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), clipCenter.zw);\\n}\"","import { observable } from \"../../../instance-provider\";\nimport {\n  IInstanceOptions,\n  Instance\n} from \"../../../instance-provider/instance\";\nimport { Vec2 } from \"../../../math\";\n\nexport interface ICircleInstanceOptions extends IInstanceOptions {\n  /** Center position of the circle */\n  center: Vec2;\n  /** The radius of the circle */\n  radius: number;\n  /** The color of this circle */\n  color?: [number, number, number, number];\n  /** The z depth of the circle (for draw ordering) */\n  depth?: number;\n}\n\nexport class CircleInstance extends Instance {\n  /** The color of this circle */\n  @observable color: [number, number, number, number] = [1.0, 1.0, 1.0, 1.0];\n  /** The z depth of the circle (for draw ordering) */\n  @observable depth: number = 0;\n  /** The radius of the circle */\n  @observable radius: number = 0;\n  /** Center position of the circle */\n  @observable center: Vec2 = [0, 0];\n\n  constructor(options: ICircleInstanceOptions) {\n    super(options);\n\n    this.color = options.color || this.color;\n    this.radius = options.radius || this.radius;\n    this.center = options.center || this.center;\n    this.depth = options.depth || this.depth;\n  }\n\n  get width() {\n    return this.radius * 2;\n  }\n\n  get height() {\n    return this.radius * 2;\n  }\n}\n","export * from \"./edge-layer\";\nexport * from \"./edge-instance\";\nexport * from \"./types\";\n","import { InstanceProvider } from \"../../../instance-provider\";\nimport { IAutoEasingMethod, Vec } from \"../../../math\";\nimport {\n  ILayerMaterialOptions,\n  InstanceAttributeSize,\n  InstanceIOValue,\n  IShaderInitialization,\n  IUniform,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../../types\";\nimport { CommonMaterialOptions, shaderTemplate } from \"../../../util\";\nimport { ILayer2DProps, Layer2D } from \"../../view/layer-2d\";\nimport { EdgeInstance } from \"./edge-instance\";\nimport { EdgeBroadphase, EdgeScaleType, EdgeType } from \"./types\";\n\nexport interface IEdgeLayerProps<T extends EdgeInstance>\n  extends ILayer2DProps<T> {\n  /** Properties for animating attributes */\n  animate?: {\n    end?: IAutoEasingMethod<Vec>;\n    start?: IAutoEasingMethod<Vec>;\n    startColor?: IAutoEasingMethod<Vec>;\n    endColor?: IAutoEasingMethod<Vec>;\n    control?: IAutoEasingMethod<Vec>;\n    thickness?: IAutoEasingMethod<Vec>;\n  };\n  /** Allows adjustments for broadphase interactions for an edge */\n  broadphase?: EdgeBroadphase;\n  /** Any distance to the mouse from an edge that is less than this distance will be picked */\n  minPickDistance?: number;\n  /** The transparency of the layer as a whole. (Makes for very efficient fading of all elements) */\n  opacity?: number;\n  /** This sets a scaling factor for the edge's line width and curve  */\n  scaleFactor?(): number;\n  /**\n   * If this is set, then the thickness of the line and the curvature of the line exists in screen space\n   * rather than world space.\n   */\n  scaleType?: EdgeScaleType;\n  /** Specifies how the edge is formed */\n  type: EdgeType;\n}\n\nexport interface IEdgeLayerState {}\n\n/** Converts a control list to an IO value */\nfunction toInstanceIOValue(value: [number, number][]): InstanceIOValue {\n  return [value[0][0], value[0][1], value[1][0], value[1][1]];\n}\n\n/** This picks the appropriate shader for the edge type desired */\nconst pickVS = {\n  [EdgeType.LINE]: require(\"./shader/edge-layer-line.vs\"),\n  [EdgeType.BEZIER]: require(\"./shader/edge-layer-bezier.vs\"),\n  [EdgeType.BEZIER2]: require(\"./shader/edge-layer-bezier2.vs\")\n};\n\n/** This is the base edge layer which is a template that can be filled with the needed specifics for a given line type */\nconst baseVS = require(\"./shader/edge-layer.vs\");\nconst screenVS = require(\"./shader/edge-layer-screen-curve.vs\");\nconst edgeFS = require(\"./shader/edge-layer.fs\");\n\n/**\n * This layer displays edges and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class EdgeLayer<\n  T extends EdgeInstance,\n  U extends IEdgeLayerProps<T>\n> extends Layer2D<T, U> {\n  // Set default props for the layer\n  static defaultProps: IEdgeLayerProps<EdgeInstance> = {\n    broadphase: EdgeBroadphase.ALL,\n    data: new InstanceProvider<EdgeInstance>(),\n    key: \"none\",\n    scaleType: EdgeScaleType.NONE,\n    type: EdgeType.LINE\n  };\n\n  static attributeNames = {\n    control: \"control\",\n    depth: \"depth\",\n    end: \"end\",\n    endColor: \"endColor\",\n    start: \"start\",\n    startColor: \"startColor\",\n    thickness: \"thickness\"\n  };\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<EdgeInstance> {\n    const {\n      animate = {},\n      scaleFactor = () => 1,\n      type,\n      scaleType = EdgeScaleType.NONE\n    } = this.props;\n\n    const {\n      end: animateEnd,\n      start: animateStart,\n      startColor: animateColorStart,\n      endColor: animateColorEnd,\n      control: animateControl,\n      thickness: animateThickness\n    } = animate;\n\n    const MAX_SEGMENTS = type === EdgeType.LINE ? 2 : 50;\n\n    // Calculate the normals and interpolations for our vertices\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      [MAX_SEGMENTS * 2 + 2]: -1\n    };\n\n    const vertexInterpolation: { [key: number]: number } = {\n      0: 0,\n      [MAX_SEGMENTS * 2 + 2]: 1\n    };\n\n    let sign = 1;\n    for (let i = 0; i < MAX_SEGMENTS * 2; ++i) {\n      vertexToNormal[i + 1] = sign;\n      vertexInterpolation[i + 1] = Math.floor(i / 2) / (MAX_SEGMENTS - 1);\n      sign *= -1;\n    }\n\n    const templateOptions = {\n      interpolation: pickVS[type]\n    };\n\n    const vs = shaderTemplate({\n      options: templateOptions,\n      required: {\n        name: \"Edge Layer\",\n        values: [\"interpolation\"]\n      },\n      shader: scaleType === EdgeScaleType.NONE ? baseVS : screenVS,\n\n      // We do not want to remove any other templating options present\n      onToken: (token, replace) => {\n        if (!(token in templateOptions)) {\n          return `$\\{${token}}`;\n        }\n\n        return replace;\n      }\n    });\n\n    return {\n      fs: edgeFS,\n      instanceAttributes: [\n        {\n          easing: animateColorStart,\n          name: EdgeLayer.attributeNames.startColor,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.startColor\n        },\n        {\n          easing: animateColorEnd,\n          name: EdgeLayer.attributeNames.endColor,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.endColor\n        },\n        {\n          easing: animateStart,\n          name: EdgeLayer.attributeNames.start,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.start\n        },\n        {\n          easing: animateEnd,\n          name: EdgeLayer.attributeNames.end,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.end\n        },\n        {\n          easing: animateThickness,\n          name: EdgeLayer.attributeNames.thickness,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.thickness\n        },\n        {\n          name: EdgeLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        type === EdgeType.LINE\n          ? {\n              easing: animateControl,\n              name: EdgeLayer.attributeNames.control,\n              size: InstanceAttributeSize.FOUR,\n              update: _o => [0, 0, 0, 0]\n            }\n          : null,\n        type === EdgeType.BEZIER\n          ? {\n              easing: animateControl,\n              name: EdgeLayer.attributeNames.control,\n              size: InstanceAttributeSize.FOUR,\n              update: o => [o.control[0][0], o.control[0][1], 0, 0]\n            }\n          : null,\n        type === EdgeType.BEZIER2\n          ? {\n              easing: animateControl,\n              name: EdgeLayer.attributeNames.control,\n              size: InstanceAttributeSize.FOUR,\n              update: o => toInstanceIOValue(o.control)\n            }\n          : null\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: (_uniform: IUniform) => [scaleFactor()]\n        },\n        {\n          name: \"layerOpacity\",\n          size: UniformSize.ONE,\n          update: (_uniform: IUniform) => [\n            this.props.opacity === undefined ? 1.0 : this.props.opacity\n          ]\n        }\n      ],\n      vertexAttributes: [\n        {\n          name: \"vertex\",\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexInterpolation[vertex],\n            // The number of vertices\n            MAX_SEGMENTS * 2\n          ]\n        }\n      ],\n      vertexCount: MAX_SEGMENTS * 2 + 2,\n      vs: vs.shader\n    };\n  }\n\n  getMaterialOptions(): ILayerMaterialOptions {\n    return CommonMaterialOptions.transparentShapeBlending;\n  }\n}\n","module.exports = \"vec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {\\nreturn p1 + (p2 - p1) * t;\\n}\"","module.exports = \"vec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {\\nreturn (1.0 - t) * (1.0 - t) * p1 + 2.0 * t * (1.0 - t) * c1 + t * t * p2;\\n}\"","module.exports = \"vec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {\\nfloat t1 = 1.0 - t;\\nreturn pow(t1, 3.0) * p1 + 3.0 * t * pow(t1, 2.0) * c1 + 3.0 * pow(t, 2.0) * t1 * c2 + pow(t, 3.0) * p2;\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\n${interpolation}\\nvoid main() {\\nfloat normal = vertex.x;\\nfloat interpolationTime = vertex.y;\\nfloat interpolationIncrement = 1.0 / vertex.z;\\nvec2 currentPosition = interpolation(interpolationTime, start, end, control.xy, control.zw);\\nvec2 prePosition = interpolation(interpolationTime - interpolationIncrement, start, end, control.xy, control.zw);\\nvec2 nextPosition = interpolation(interpolationTime + interpolationIncrement, start, end, control.xy, control.zw);\\nvec2 preLine = prePosition - currentPosition;\\nvec2 nextLine = nextPosition - currentPosition;\\nvec2 currentNormal = mix(\\nnormalize(vec2(preLine.y, -preLine.x)),\\nmix(\\nnormalize(vec2(preLine.y, -preLine.x) + vec2(-nextLine.y, nextLine.x)),\\nnormalize(vec2(-nextLine.y, nextLine.x)),\\nfloat(vertex.x >= 1.0)\\n),\\nfloat(vertex.x > 0.0)\\n);\\nfloat lineThickness = mix(thickness.x, thickness.y, interpolationTime) / 2.0;\\nvec2 vertexPos = currentPosition + currentNormal * (normal * lineThickness);\\nvertexColor = mix(startColor, endColor, interpolationTime);\\ngl_Position = clipSpace(vec3(vertexPos, depth));\\ngl_PointSize = 5.0;\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\n${interpolation}\\nvoid main() {\\nfloat normal = vertex.x;\\nfloat interpolationTime = vertex.y;\\nfloat interpolationIncrement = 1.0 / vertex.z;\\nvec4 startClip = clipSpace(vec3(start, depth));\\nvec4 endClip = clipSpace(vec3(end, depth));\\nvec2 startScreen = (startClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\nvec2 endScreen = (endClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\nvec2 control1 = startScreen + vec2(control.x, -control.y) * scaleFactor;\\nvec2 control2 = endScreen + vec2(control.z, -control.w) * scaleFactor;\\nvec2 currentPosition = interpolation(interpolationTime, startScreen, endScreen, control1, control2);\\nvec2 prePosition = interpolation(interpolationTime - interpolationIncrement, startScreen, endScreen, control1, control2);\\nvec2 nextPosition = interpolation(interpolationTime + interpolationIncrement, startScreen, endScreen, control1, control2);\\nvec2 preLine = prePosition - currentPosition;\\nvec2 nextLine = nextPosition - currentPosition;\\nvec2 currentNormal = mix(\\nnormalize(vec2(preLine.y, -preLine.x)),\\nmix(\\nnormalize(vec2(preLine.y, -preLine.x) + vec2(-nextLine.y, nextLine.x)),\\nnormalize(vec2(-nextLine.y, nextLine.x)),\\nfloat(vertex.x >= 1.0)\\n),\\nfloat(vertex.x > 0.0)\\n);\\nfloat lineThickness = mix(thickness.x, thickness.y, interpolationTime) / 2.0;\\nvec2 vertexPos = currentPosition + currentNormal * (-normal * lineThickness * scaleFactor);\\nvertexColor = mix(startColor, endColor, interpolationTime);\\ngl_Position = vec4((vertexPos / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), startClip.zw);\\ngl_PointSize = 5.0;\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvoid main() {\\ngl_FragColor = vertexColor;\\n}\"","import {\n  IInstanceOptions,\n  Instance\n} from \"../../../instance-provider/instance\";\nimport { observable } from \"../../../instance-provider/observable\";\nimport { copy4, Vec2, Vec4 } from \"../../../math\";\n\nexport interface IEdgeInstanceOptions extends IInstanceOptions {\n  /** This is the list of control points  */\n  control?: Vec2[];\n  /** The z depth of the edge (for draw ordering) */\n  depth?: number;\n  /** End point of the edge. */\n  end: Vec2;\n  /** End color of the edge */\n  endColor?: Vec4;\n  /** Beginning point of the edge. */\n  start: Vec2;\n  /** Start color of the edge */\n  startColor?: Vec4;\n  /** Start width of the edge. */\n  thickness?: Vec2;\n}\n\nexport class EdgeInstance extends Instance {\n  @observable control: Vec2[] = [\n    [0, 0],\n    [0, 0]\n  ];\n  @observable depth: number = 0;\n  @observable end: Vec2 = [0, 0];\n  @observable endColor: Vec4 = [1.0, 1.0, 1.0, 1.0];\n  @observable start: Vec2 = [0, 0];\n  @observable startColor: Vec4 = [1.0, 1.0, 1.0, 1.0];\n  @observable thickness: Vec2 = [1.0, 1.0];\n\n  /**\n   * Calculates length from beginning point to end point\n   */\n  get length() {\n    const delta = [this.end[0] - this.start[0], this.end[1] - this.start[1]];\n\n    return Math.sqrt(delta[0] * delta[0] + delta[1] * delta[1]);\n  }\n\n  /**\n   * Calculates the midpoint of the edge\n   */\n  get midpoint() {\n    return 0;\n  }\n\n  /**\n   * Calculates a perpendicular direction vector to the edge\n   */\n  get perpendicular(): Vec2 {\n    const length = this.length;\n\n    return [\n      (this.end[1] - this.start[1]) / length,\n      -(this.end[0] - this.start[0]) / length\n    ];\n  }\n\n  /**\n   * Applies the edge width to the start and end\n   */\n  setEdgeThickness(thickness: number) {\n    this.thickness = [thickness, thickness];\n  }\n\n  /**\n   * Applies the color to the start and end\n   */\n  setColor(color: Vec4) {\n    this.startColor = copy4(color);\n    this.endColor = copy4(color);\n  }\n\n  constructor(options: IEdgeInstanceOptions) {\n    super(options);\n    this.startColor = options.startColor || this.startColor;\n    this.endColor = options.endColor || this.endColor;\n    this.control = options.control || this.control;\n    this.depth = options.depth || this.depth;\n    this.end = options.end || this.end;\n    this.thickness = options.thickness || this.thickness;\n    this.start = options.start || this.start;\n  }\n}\n","export * from \"./image-layer\";\nexport * from \"./image-instance\";\n","import { InstanceProvider } from \"../../../instance-provider\";\nimport {\n  atlasRequest,\n  AtlasResource,\n  IAtlasResourceRequest\n} from \"../../../resources\";\nimport { LayerInitializer } from \"../../../surface/layer\";\nimport { InstanceDiffType } from \"../../../types\";\nimport { createLayer, mapInjectDefault } from \"../../../util\";\nimport { PromiseResolver } from \"../../../util/promise-resolver\";\nimport { Layer2D } from \"../../view/layer-2d\";\nimport { debugVideoEvents } from \"./debug-video\";\nimport { ImageInstance } from \"./image-instance\";\nimport { IImageRenderLayerProps, ImageRenderLayer } from \"./image-render-layer\";\n\nexport interface IImageLayerProps<T extends ImageInstance>\n  extends IImageRenderLayerProps<T> {}\n\nexport type ImageVideoResource = {\n  /**\n   * IF AND ONLY IF the browser supports it. This will cause the video to begin playing immediately when ready and\n   * loaded. This merely prevents the need to add video.play() to something after onReady has been called. All other\n   * expected video patterns are expected to apply.\n   */\n  autoPlay?: boolean;\n  /**\n   * This is the source the video will load.\n   */\n  videoSrc: string;\n};\n\nexport type ImageInstanceResource =\n  | string\n  | ImageBitmap\n  | ImageData\n  | HTMLImageElement\n  | HTMLCanvasElement\n  | ImageVideoResource;\n\n/**\n * Typeguard for video resource requests\n */\nexport function isVideoResource(val: any): val is ImageVideoResource {\n  return val && val.videoSrc;\n}\n\n/** Simple image source to be used for waiting elements */\nconst WHITE_PIXEL = new Image();\nWHITE_PIXEL.src =\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\";\n\n/**\n * This layer displays Images and provides as many controls as possible for displaying\n * them in interesting ways. This is the primary handler for image instances.\n */\nexport class ImageLayer<\n  T extends ImageInstance,\n  U extends IImageLayerProps<T>\n> extends Layer2D<T, U> {\n  static defaultProps: IImageLayerProps<any> = {\n    atlas: \"default\",\n    key: \"\",\n    data: new InstanceProvider<ImageInstance>()\n  };\n\n  /** Internal provider for child layers for this layer to hand off to */\n  childProvider = new InstanceProvider<ImageInstance>();\n  /**\n   * This tracks which resource this image is associated with This allows us to know what resource an image\n   * moves on from, thus allowing us to dispatch a disposal request of the resource.\n   */\n  imageToResource = new Map<ImageInstance, IAtlasResourceRequest[\"source\"]>();\n  /** The cached property ids of the instances so they are not processed every draw */\n  propertyIds?: { [key: string]: number };\n  /** We can consolidate requests at this layer level to reduce memory footprint of requests */\n  sourceToRequest = new Map<AtlasResource, IAtlasResourceRequest>();\n  /** Map video resource requests to their corresponding video element */\n  sourceToVideo = new Map<string, HTMLVideoElement>();\n  /**\n   * Stores a lookup to see which instances are using a video source. This helps track when the video source is no\n   * longer in use and can be disposed.\n   */\n  usingVideo = new Map<string, Set<ImageInstance>>();\n  /**\n   * These are the instances waiting for a video source to finish loading and have valid dimensions to be used by the\n   * resource manager.\n   */\n  waitingForVideo = new Map<string, Set<ImageInstance>>();\n  /**\n   * Instance lookup to see which video source the instance is waiting on.\n   */\n  waitForVideoSource = new Map<ImageInstance, string>();\n  /**\n   * In cases where the image has a special case loading procedure like videos, the image will have it's onReady\n   */\n  originalOnReadyCallbacks = new Map<\n    ImageInstance,\n    ImageInstance[\"onReady\"] | undefined\n  >();\n\n  /**\n   * The image layer will manage the resources for the images, and the child layer will concern itself\n   * with rendering.\n   */\n  childLayers(): LayerInitializer[] {\n    return [\n      createLayer(ImageRenderLayer, {\n        ...this.props,\n        key: `${this.props.key}.image-render-layer`\n      })\n    ];\n  }\n\n  destroy() {\n    super.destroy();\n    this.sourceToVideo.forEach(video => {\n      video.pause();\n      this.sourceToVideo.clear();\n      this.waitingForVideo.clear();\n      this.waitForVideoSource.clear();\n    });\n  }\n\n  /**\n   * Hijack the draw method to control changes to the source so we can send the manager dispose requests\n   * of a given image.\n   */\n  draw() {\n    // Get the changes we need to handle. We make sure the provider's changes remain in tact for\n    // the child layer to process them.\n    const changes = this.resolveChanges(true);\n    // Make sure we are triggering redraws appropriately\n    this.updateAnimationState();\n    // No changes, do nadda\n    if (changes.length <= 0) return;\n\n    if (!this.propertyIds) {\n      this.propertyIds = this.getInstanceObservableIds(changes[0][0], [\n        \"source\"\n      ]);\n    }\n\n    // Destructure the ids to work with\n    const { source: sourceId } = this.propertyIds;\n\n    for (let i = 0, iMax = changes.length; i < iMax; ++i) {\n      const [instance, diffType, changed] = changes[i];\n\n      switch (diffType) {\n        case InstanceDiffType.CHANGE:\n          // Indicates changes took place\n          if (changed[sourceId] !== undefined) {\n            // We get the previously stored resource\n            const previous = this.imageToResource.get(instance);\n            // Make sure we get the atlas appropriate resource for the instance\n            let resource = this.getAtlasSource(instance);\n            // Nothing needs to happen if the resource didn't change\n            if (resource === previous) break;\n\n            // If the previous is a video source we need to clear the instance out from utilizing the video\n            if (previous instanceof HTMLVideoElement) {\n              // Remove the potentially existing 'waiting on the video' references\n              const waitingOnSource = this.waitForVideoSource.get(instance);\n\n              if (waitingOnSource) {\n                this.waitForVideoSource.delete(instance);\n                const instancesWaiting = this.waitingForVideo.get(\n                  waitingOnSource\n                );\n\n                if (instancesWaiting) {\n                  instancesWaiting.delete(instance);\n                }\n              }\n\n              // Remove the instance from 'using' the video source\n              let instancesUsing = this.usingVideo.get(\n                previous.getAttribute(\"data-source\") || \"\"\n              );\n\n              if (!instancesUsing) {\n                instancesUsing = new Set();\n              }\n\n              instancesUsing.delete(instance);\n\n              if (instancesUsing.size <= 0) {\n                this.sourceToVideo.delete(\n                  previous.getAttribute(\"data-source\") || \"\"\n                );\n              }\n\n              // Revert the instance's onReady back to what it originally was\n              instance.onReady = this.originalOnReadyCallbacks.get(instance);\n            }\n\n            // Video resources must be prepped to handle special circumstances\n            if (isVideoResource(instance.source)) {\n              this.prepareVideo(instance, instance.source);\n              // Prepping the video can potentially temp swap the source of the image\n              resource = this.getAtlasSource(instance);\n              // Add the video to the video's use list\n              const usingList = mapInjectDefault(\n                this.usingVideo,\n                instance.source.videoSrc,\n                new Set()\n              );\n              usingList.add(instance);\n            }\n\n            // We set the new resource\n            this.imageToResource.set(instance, resource);\n            // We make a disposal request to the resource manager\n            this.resource.request(\n              this,\n              instance,\n              atlasRequest({\n                key: this.props.atlas || \"\",\n                disposeResource: true,\n                source: previous\n              })\n            );\n\n            // Look for similar requests for resources and consolidate\n            if (resource) {\n              let request = this.sourceToRequest.get(resource);\n\n              if (!request || (request.texture && !request.texture.isValid)) {\n                request = atlasRequest({\n                  key: this.props.atlas || \"\",\n                  source: resource,\n                  rasterizationScale: this.props.rasterizationScale\n                });\n\n                this.sourceToRequest.set(resource, request);\n              }\n\n              instance.request = request;\n              this.resource.request(this, instance, request);\n            }\n          }\n          break;\n\n        case InstanceDiffType.INSERT:\n          // Look for similar requests for resources and consolidate\n          if (instance.source) {\n            // Make sure we get the atlas appropriate resource for the instance\n            let resource = this.getAtlasSource(instance);\n\n            if (isVideoResource(instance.source)) {\n              this.prepareVideo(instance, instance.source);\n              // Prepping the video can potentially temp swap the source of the image\n              resource = this.getAtlasSource(instance);\n              // Add the video to the video's use list\n              const usingList = mapInjectDefault(\n                this.usingVideo,\n                instance.source.videoSrc,\n                new Set()\n              );\n              usingList.add(instance);\n            }\n\n            // See if we have an existing request for this resource\n            let request = this.sourceToRequest.get(resource);\n\n            if (!request || (request.texture && !request.texture.isValid)) {\n              request = atlasRequest({\n                key: this.props.atlas || \"\",\n                source: resource,\n                rasterizationScale: this.props.rasterizationScale\n              });\n\n              this.sourceToRequest.set(resource, request);\n            }\n\n            instance.request = request;\n          }\n\n          break;\n\n        case InstanceDiffType.REMOVE:\n          // Make sure we get the atlas appropriate resource for the instance\n          const resource = this.getAtlasSource(instance);\n          // Clear out any state the instance may have retained in this layer\n          this.imageToResource.delete(instance);\n\n          // Clear out video useage\n          if (isVideoResource(instance.source)) {\n            const waitingOnSource = this.waitForVideoSource.get(instance);\n\n            if (waitingOnSource) {\n              this.waitForVideoSource.delete(instance);\n              const instancesWaiting = this.waitingForVideo.get(\n                waitingOnSource\n              );\n\n              if (instancesWaiting) {\n                instancesWaiting.delete(instance);\n              }\n            }\n\n            let instancesUsing = this.usingVideo.get(instance.source.videoSrc);\n\n            if (!instancesUsing) {\n              instancesUsing = new Set();\n            }\n\n            instancesUsing.delete(instance);\n\n            if (instancesUsing.size <= 0) {\n              this.sourceToVideo.delete(instance.source.videoSrc);\n            }\n\n            this.originalOnReadyCallbacks.delete(instance);\n          }\n\n          // We make a disposal request here\n          this.resource.request(\n            this,\n            instance,\n            atlasRequest({\n              key: this.props.atlas || \"\",\n              disposeResource: true,\n              source: resource\n            })\n          );\n          break;\n      }\n    }\n\n    // After all changes are processed, we need to check to see if any video sources are no longer in use and clear out\n    // any remaining references to the video.\n    const toRemoveVideoSources: string[] = [];\n\n    this.usingVideo.forEach((usingVideoSet, videoSrc) => {\n      if (usingVideoSet.size <= 0) {\n        toRemoveVideoSources.push(videoSrc);\n      }\n    });\n\n    for (let i = 0, iMax = toRemoveVideoSources.length; i < iMax; ++i) {\n      const source = toRemoveVideoSources[i];\n      this.usingVideo.delete(source);\n      this.sourceToVideo.delete(source);\n    }\n  }\n\n  /**\n   * Gets the source that is atlas reques compatible.\n   */\n  private getAtlasSource(image: ImageInstance) {\n    if (isVideoResource(image.source)) {\n      return this.sourceToVideo.get(image.source.videoSrc) || WHITE_PIXEL;\n    }\n\n    return image.source;\n  }\n\n  /**\n   * This handles creating the video object from the source. It then queues up the waiting needs and temporarily\n   * converts the video Image to a simple white image that will take on the tint of the ImageInstance.\n   */\n  private prepareVideo(image: ImageInstance, source: ImageVideoResource) {\n    const check = this.sourceToVideo.get(source.videoSrc);\n    const checkCallback = this.originalOnReadyCallbacks.get(image);\n\n    if (!checkCallback) {\n      this.originalOnReadyCallbacks.set(image, image.onReady);\n    }\n\n    // Let's first see if the source provided already is being monitored by this layer.\n    if (check) {\n      const waitingInstances = this.waitingForVideo.get(source.videoSrc);\n\n      // If waiting instances exists, then the video has not loaded yet and this becomes an additional instance waiting\n      // for the video to be ready.\n      if (waitingInstances) {\n        waitingInstances.add(image);\n        this.waitForVideoSource.set(image, source.videoSrc);\n        image.onReady = undefined;\n        image.source = WHITE_PIXEL;\n\n        image.videoLoad = () => {\n          check.load();\n\n          if (source.autoPlay) {\n            check.play();\n          }\n        };\n      }\n\n      // Otherwise, the video IS ready and the instance can carry on as a normal instance\n      else {\n        const onReady =\n          this.originalOnReadyCallbacks.get(image) || image.onReady;\n        if (!onReady) return;\n\n        // Replace the onReady that the resource manager will fire with an onReady that will execute with the video\n        // that is prepped and ready included.\n        image.onReady = (image: ImageInstance) => {\n          onReady(image, check);\n        };\n      }\n\n      return;\n    }\n\n    // Create the physical video element to use.\n    const video = document.createElement(\"video\");\n    this.sourceToVideo.set(source.videoSrc, video);\n    // Store the exact source path on the element (the src attribute gets resolved to relative http request)\n    video.setAttribute(\"data-source\", source.videoSrc);\n\n    debugVideoEvents(video);\n\n    // We must load the video properly to make it compatible with the texture and have all of it's properties\n    // set in an appropriate fashion to not violate current video playback standards.\n    const metaResolver = new PromiseResolver<void>();\n    const dataResolver = new PromiseResolver<void>();\n\n    const removeListeners = () => {\n      video.removeEventListener(\"loadedmetadata\", waitForMetaData);\n      video.removeEventListener(\"loadeddata\", waitForData);\n      video.removeEventListener(\"error\", waitForError);\n\n      this.waitingForVideo.delete(source.videoSrc);\n      this.waitForVideoSource.delete(image);\n    };\n\n    const waitForData = () => {\n      dataResolver.resolve();\n    };\n\n    const waitForMetaData = () => {\n      metaResolver.resolve();\n    };\n\n    const waitForError = (event: any) => {\n      let error;\n\n      // Chrome v60\n      if (event.path && event.path[0]) {\n        error = event.path[0].error;\n      }\n\n      // Firefox v55\n      if (event.originalTarget) {\n        error = event.originalTarget.error;\n      }\n\n      // Broadcast the error\n      console.warn(\n        \"There was an error loading the video resource to the atlas texture context\"\n      );\n      console.warn(error);\n\n      // Reject the blocking promises\n      metaResolver.reject({});\n      dataResolver.reject({});\n    };\n\n    // We must ensure the source has it's meta data and first frame available. The meta data ensures a\n    // videoWidth and height are available and the first frame ensures WebGL does not throw an error in some\n    // browsers like chrome that will think the video is initially invalid.\n    video.addEventListener(\"loadedmetadata\", waitForMetaData);\n    video.addEventListener(\"loadeddata\", waitForData);\n    video.addEventListener(\"error\", waitForError);\n\n    // We now initialize the image as waiting on the video\n    // The image may have a custom onReady set awaiting the video's completion. We must not allow it to happen for\n    // loading the placeholder white image. So we replace it with a NOOP until the video itself is actually ready to\n    // be loaded into the resource manager.\n    image.onReady = undefined;\n    // We must also register the video source as waiting\n    const waitingInstances = mapInjectDefault(\n      this.waitingForVideo,\n      source.videoSrc,\n      new Set()\n    );\n    waitingInstances.add(image);\n    this.waitForVideoSource.set(image, source.videoSrc);\n    // Make the video's source point to the empty white image\n    image.source = WHITE_PIXEL;\n    // Lastly, make the image videoLoad method actually be a valid video operation.\n    image.videoLoad = () => {\n      video.load();\n\n      if (source.autoPlay) {\n        video.play();\n      }\n    };\n\n    // Current standard declares unmuted videos CAN NOT be auto played via javascript and must play in the context of\n    // a user event\n    video.muted = true;\n    // Set the video source after the events have been assigned so we can wait for the video to begin playback\n    video.src = source.videoSrc;\n\n    Promise.all([metaResolver.promise, dataResolver.promise])\n      // This executes when the video is officially ready and will be loaded into the resource manager for play back\n      .then(() => {\n        // Make sure the video start from the beginning\n        video.currentTime = 0;\n\n        // Check the video source preferences to see if the video should play immediately upon loading.\n        if (source.autoPlay) {\n          video.play();\n        }\n\n        // Retrieve all of the instances waiting for this video to be ready\n        const waitingInstances = this.waitingForVideo.get(source.videoSrc);\n\n        if (waitingInstances) {\n          waitingInstances.forEach(instance => {\n            // Set the instance's source back to the video. Since this is asynchronous, it should trigger the change and\n            // flow through the provider\n            instance.source = source;\n            instance.onReady = this.originalOnReadyCallbacks.get(instance);\n          });\n        }\n\n        removeListeners();\n      })\n      .catch(() => {\n        removeListeners();\n      });\n  }\n\n  /**\n   * This asserts whether or not the layer should be triggering redraws or not.\n   */\n  private updateAnimationState() {\n    // We should check to see if any of the video sources are playing or not\n    let isVideoPlaying = false;\n\n    this.sourceToVideo.forEach(video => {\n      if (!video.paused) {\n        isVideoPlaying = true;\n      }\n    });\n\n    // When videos are in use AND playing, this layer should be on continuous redraws to ensure the video renders continuously.\n    this.isAnimationContinuous = this.usingVideo.size > 0 && isVideoPlaying;\n  }\n\n  /**\n   * Parent layer has no rendering needs\n   */\n  initShader() {\n    return null;\n  }\n}\n","const debug = require(\"debug\")(\"video\");\n\n/**\n * This logs ALL events a video will fire. To see the logs simply open the console in the browser, then execute:\n * localStorage.debug = 'video';\n */\nexport function debugVideoEvents(video: HTMLVideoElement) {\n  if (debug.enabled) {\n    video.addEventListener(\"abort\", () => debug(\"abort\"));\n    video.addEventListener(\"canplay\", () => debug(\"canplay\"));\n    video.addEventListener(\"canplaythrough\", () => debug(\"canplaythrough\"));\n    video.addEventListener(\"durationchange\", () => debug(\"durationchange\"));\n    video.addEventListener(\"emptied\", () => debug(\"emptied\"));\n    video.addEventListener(\"ended\", () => debug(\"ended\"));\n    video.addEventListener(\"error\", () => debug(\"error\"));\n    video.addEventListener(\"loadeddata\", () => debug(\"loadeddata\"));\n    video.addEventListener(\"loadedmetadata\", () => debug(\"loadedmetadata\"));\n    video.addEventListener(\"loadstart\", () => debug(\"loadstart\"));\n    video.addEventListener(\"pause\", () => debug(\"pause\"));\n    video.addEventListener(\"play\", () => debug(\"play\"));\n    video.addEventListener(\"playing\", () => debug(\"playing\"));\n    video.addEventListener(\"progress\", () => debug(\"progress\"));\n    video.addEventListener(\"ratechange\", () => debug(\"ratechange\"));\n    video.addEventListener(\"seeked\", () => debug(\"seeked\"));\n    video.addEventListener(\"seeking\", () => debug(\"seeking\"));\n    video.addEventListener(\"stalled\", () => debug(\"stalled\"));\n    video.addEventListener(\"suspend\", () => debug(\"suspend\"));\n    video.addEventListener(\"timeupdate\", () => debug(\"timeupdate\"));\n    video.addEventListener(\"volumechange\", () => debug(\"volumechange\"));\n    video.addEventListener(\"waiting\", () => debug(\"waiting\"));\n  }\n}\n","import { InstanceProvider } from \"../../../instance-provider\";\nimport { IAutoEasingMethod, Vec } from \"../../../math\";\nimport {\n  ILayerMaterialOptions,\n  InstanceAttributeSize,\n  IShaderInitialization,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../../types\";\nimport { CommonMaterialOptions } from \"../../../util/common-options\";\nimport { ILayer2DProps, Layer2D } from \"../../view/layer-2d\";\nimport { ImageInstance } from \"./image-instance\";\n\nexport interface IImageRenderLayerProps<T extends ImageInstance>\n  extends ILayer2DProps<T> {\n  /** The id of the atlas to load resources into */\n  atlas?: string;\n  /** The properties we wish to animate for the image */\n  animate?: {\n    tint?: IAutoEasingMethod<Vec>;\n    location?: IAutoEasingMethod<Vec>;\n    size?: IAutoEasingMethod<Vec>;\n  };\n  /**\n   * This is the scale resources for the images will be loaded into the atlas. A value of\n   * 0.5 will cause images to load at 50% their source size to the atlas.\n   */\n  rasterizationScale?: number;\n}\n\n/**\n * This layer displays Images and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class ImageRenderLayer<\n  T extends ImageInstance,\n  U extends IImageRenderLayerProps<T>\n> extends Layer2D<T, U> {\n  static defaultProps: IImageRenderLayerProps<any> = {\n    key: \"\",\n    data: new InstanceProvider<ImageInstance>()\n  };\n\n  /** Easy lookup of attribute names to aid in modifications to be applied to elements */\n  static attributeNames = {\n    location: \"location\",\n    anchor: \"anchor\",\n    size: \"size\",\n    depth: \"depth\",\n    scaling: \"scaling\",\n    texture: \"texture\",\n    tint: \"tint\"\n  };\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<ImageInstance> {\n    const animations = this.props.animate || {};\n    const {\n      tint: animateTint,\n      location: animateLocation,\n      size: animateSize\n    } = animations;\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: 0,\n      1: 0,\n      2: 0,\n      3: 1,\n      4: 1,\n      5: 1\n    };\n\n    return {\n      fs: require(\"./image-layer.fs\"),\n      instanceAttributes: [\n        {\n          easing: animateLocation,\n          name: ImageRenderLayer.attributeNames.location,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.origin\n        },\n        {\n          name: ImageRenderLayer.attributeNames.anchor,\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.anchor.x || 0, o.anchor.y || 0]\n        },\n        {\n          easing: animateSize,\n          name: ImageRenderLayer.attributeNames.size,\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.width, o.height]\n        },\n        {\n          name: ImageRenderLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        {\n          name: ImageRenderLayer.attributeNames.scaling,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scaling]\n        },\n        {\n          name: ImageRenderLayer.attributeNames.texture,\n          resource: {\n            key: () => this.props.atlas || \"\",\n            name: \"imageAtlas\"\n          },\n          update: o => {\n            o.source;\n\n            if (!o.request) {\n              console.warn(\n                \"An image utilizing the image-render-layer does not have its request specified yet.\",\n                \"The image-render-layer does NOT manage requests and should be handled before this layer deals with the instance\"\n              );\n\n              return [0, 0, 0, 0];\n            }\n\n            return this.resource.request(this, o, o.request);\n          }\n        },\n        {\n          easing: animateTint,\n          name: ImageRenderLayer.attributeNames.tint,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.tint\n        }\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: _u => [1]\n        }\n      ],\n      vertexAttributes: [\n        {\n          name: \"normals\",\n          size: VertexAttributeSize.TWO,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexToSide[vertex]\n          ]\n        }\n      ],\n      vertexCount: 6,\n      vs: require(\"./image-layer.vs\")\n    };\n  }\n\n  getMaterialOptions(): ILayerMaterialOptions {\n    return CommonMaterialOptions.transparentImageBlending;\n  }\n}\n","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\ngl_FragColor = texture2D(imageAtlas, texCoord) * vertexColor;\\ngl_FragColor = gl_FragColor * gl_FragColor.a;\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec3 screenSize = cameraSpaceSize(vec3(size, 1.0));\\nbool largerOnScreen = screenSize.y > size.y;\\nfloat useScaleMode = float(\\n(\\nscaling == 3.0 ||\\n(largerOnScreen && scaling == 2.0)\\n) &&\\nscaling != 1.0\\n);\\nfloat unequalZooms = float(cameraScale2D.x != cameraScale2D.y);\\nfloat normal = normals.x;\\nfloat side = normals.y;\\nvec2 worldAnchor = location + anchor;\\ntexCoord = texture.xy + ((texture.zw - texture.xy) * vec2(side, float(normal == -1.0)));\\nvertexColor = tint;\\nvec2 adjustedSize = mix(\\nsize,\\n(size * cameraScale2D.yx),\\nunequalZooms\\n);\\nvec2 adjustedAnchor = mix(\\nanchor,\\n(anchor * cameraScale2D.yx),\\nunequalZooms\\n);\\nvec2 vertex = vec2(side, float(normal == 1.0)) * adjustedSize + location - adjustedAnchor;\\nfloat imageScreenScale = mix(\\nscreenSize.y / adjustedSize.y,\\nscreenSize.x / adjustedSize.x,\\nfloat((cameraScale2D.x < 1.0) || (cameraScale2D.x > 1.0))\\n);\\nvec2 anchorToVertex = vertex - location;\\nvertex = mix(\\nvertex,\\n(anchorToVertex / imageScreenScale) + location,\\nuseScaleMode\\n);\\ngl_Position = clipSpace(vec3(vertex, depth));\\n}\"","import { observable } from \"../../../instance-provider\";\nimport {\n  IInstanceOptions,\n  Instance\n} from \"../../../instance-provider/instance\";\nimport { Vec2 } from \"../../../math/vector\";\nimport { IAtlasResourceRequest } from \"../../../resources\";\nimport { NOOP } from \"../../../types\";\nimport { Anchor, AnchorType, ScaleMode } from \"../../types\";\nimport { ImageInstanceResource } from \"./image-layer\";\n\nconst { max } = Math;\n\nexport interface IImageInstanceOptions extends IInstanceOptions {\n  /**\n   * The point on the image which will be placed in world space via the x, y coords. This is also the point\n   * which the image will be scaled around.\n   */\n  anchor?: Anchor;\n  /** Depth sorting of the image (or the z value of the image) */\n  depth?: number;\n  /** This is the HTMLImageElement that the image is to render. This element MUST be loaded completely before this instance is created. */\n  source: ImageInstanceResource;\n  /** The height of the image as it is to be rendered in world space */\n  height?: number;\n  /** The coordinate where the image will be anchored to in world space */\n  origin?: Vec2;\n  /** Sets the way the image scales with the world */\n  scaling?: ScaleMode;\n  /** The color the image should render as */\n  tint: [number, number, number, number];\n  /** The width of the image as it is to be rendered in world space */\n  width?: number;\n\n  /** Triggered when it's detected that the image will never render correctly */\n  onError?(): void;\n  /** Triggered when the image has fully loaded it's resources */\n  onReady?(image: ImageInstance, video?: HTMLVideoElement): void;\n}\n\n/**\n * This is a lookup to quickly find the proper calculation for setting the correct anchor\n * position based on the anchor type.\n */\nconst anchorCalculator: {\n  [key: number]: (anchor: Anchor, image: ImageInstance) => void;\n} = {\n  [AnchorType.TopLeft]: (anchor: Anchor, _image: ImageInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopMiddle]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width / 2.0;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopRight]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width + anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.MiddleLeft]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = image.height / 2;\n  },\n  [AnchorType.Middle]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width / 2.0;\n    anchor.y = image.height / 2.0;\n  },\n  [AnchorType.MiddleRight]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width + anchor.padding;\n    anchor.y = image.height / 2.0;\n  },\n  [AnchorType.BottomLeft]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = image.height + anchor.padding;\n  },\n  [AnchorType.BottomMiddle]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width / 2.0;\n    anchor.y = image.height + anchor.padding;\n  },\n  [AnchorType.BottomRight]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width + anchor.padding;\n    anchor.y = image.height + anchor.padding;\n  },\n  [AnchorType.Custom]: (anchor: Anchor, _image: ImageInstance) => {\n    anchor.x = anchor.x || 0;\n    anchor.y = anchor.y || 0;\n  }\n};\n\n/**\n * This generates a new image instance.\n * There are restrictions surrounding images due to texture sizes and rendering limitations.\n *\n * Currently, we only support rendering a image via canvas, then rendering it to an Atlas texture\n * which is used to render to cards in the world for rendering. This is highly performant, but means:\n *\n * - Images should only be so large.\n * - Once a image is constructed, only SOME properties can be altered thereafter\n *\n * An image that is constructed can only have some properties set upon creating the image and are locked\n * thereafter. The only way to modify them would be to destroy the image, then construct a new image\n * with the modifications. This has to deal with performance regarding rasterizing the image.\n */\nexport class ImageInstance extends Instance {\n  /** This is the rendered color of the image */\n  @observable tint: [number, number, number, number] = [0, 0, 0, 1];\n  /** Depth sorting of the image (or the z value of the image) */\n  @observable depth: number = 0;\n  /**\n   * The height of the image as it is to be rendered in world space.\n   * After onReady: this is immediately populated with the width and height of the image as it\n   * appears in the atlas.\n   */\n  @observable height: number = 1;\n  /** The coordinate where the image will be located in world space */\n  @observable origin: Vec2 = [0, 0];\n  /** Sets the way the image scales with the world */\n  @observable scaling: ScaleMode = ScaleMode.BOUND_MAX;\n  /** This is where the source of the image will come from */\n  @observable source: ImageInstanceResource;\n  /**\n   * The width of the image as it is to be rendered in world space.\n   * After onReady: this is immediately populated with the width and height of the image as it\n   * appears in the atlas.\n   */\n  @observable width: number = 1;\n\n  /**\n   * This property reflects the maximum size a single dimension of the image will take up.\n   * This means if you set this value to 100 at least the width or the height will be 100\n   * depending on the aspect ratio of the image.\n   */\n  get maxSize() {\n    return max(this.width, this.height);\n  }\n  set maxSize(value: number) {\n    const aspect = this.width / this.height;\n    this.width = value * aspect;\n    this.height = value;\n  }\n\n  /** Event called when there is an error attempting to load and render the image */\n  onError?: IImageInstanceOptions[\"onError\"];\n  /** Event called when the instance has it's resource loaded and ready for use */\n  onReady?: IImageInstanceOptions[\"onReady\"];\n  /** This is the request generated for the instance to retrieve the correct resource */\n  request?: IAtlasResourceRequest;\n  /** After onReady: This is populated with the width of the source image loaded into the Atlas */\n  sourceWidth: number = 0;\n  /** After onReady: This is populated with the height of the source image loaded into the Atlas */\n  sourceHeight: number = 0;\n\n  /**\n   * This is a position relative to the image. This will align the image such that the anchor point on\n   * the image will be located at the origin in world space.\n   */\n  @observable\n  private _anchor: Anchor = {\n    padding: 0,\n    type: AnchorType.TopLeft,\n    x: 0,\n    y: 0\n  };\n\n  constructor(options: IImageInstanceOptions) {\n    super(options);\n\n    this.depth = options.depth || this.depth;\n    this.tint = options.tint || this.tint;\n    this.scaling = options.scaling || this.scaling;\n    this.origin = options.origin || this.origin;\n    this.width = options.width || 1;\n    this.height = options.height || 1;\n    this.source = options.source;\n    this.onReady = options.onReady;\n\n    // Make sure the anchor is set to the appropriate location\n    options.anchor && this.setAnchor(options.anchor);\n  }\n\n  get anchor() {\n    return this._anchor;\n  }\n\n  /**\n   * In the event that video auto play is not permitted, one may have to respond to a user input gesture to begin\n   * loading and playing the video. While your video is not ready to play, the ImageInstance will NOT fire the onReady\n   * callback. Instead it will wait idle as an image that is merely the 'tint color' provided. Once this is called\n   * (within a user gesture) the video will for sure start loading, the onReady will call back once the video has\n   * properly prepped.\n   */\n  videoLoad: Function = NOOP;\n\n  /** This is triggered after the request has been completed */\n  resourceTrigger() {\n    // Only the source needs to be triggered to get the texture info to update from the request\n    this.source = this.source;\n\n    if (this.request && this.request.texture) {\n      this.sourceWidth = this.request.texture.pixelWidth;\n      this.sourceHeight = this.request.texture.pixelHeight;\n    }\n\n    if (this.onReady) this.onReady(this);\n  }\n\n  /**\n   * This applies a new anchor to this image and properly determines it's anchor position on the image\n   */\n  setAnchor(anchor: Anchor) {\n    const newAnchor = {\n      padding: anchor.padding || 0,\n      type: anchor.type,\n      x: anchor.x || 0,\n      y: anchor.y || 0\n    };\n\n    // Calculate the new anchors position values\n    anchorCalculator[newAnchor.type](newAnchor, this);\n    // Apply the anchor\n    this._anchor = newAnchor;\n  }\n}\n","export * from \"./label-layer\";\nexport * from \"./label-instance\";\nexport * from \"./glyph-instance\";\nexport * from \"./glyph-layer\";\nexport * from \"./text-area-instance\";\nexport * from \"./text-area-layer\";\n","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec4 texColor = texture2D(fontMap, texCoord);\\nif (texColor.r <= 0.0) discard;\\ntexColor.a = texColor.r;\\ngl_FragColor = texColor * vertexColor;\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec4 texColor = texture2D(fontMap, texCoord);\\nif (texColor.r <= 0.0) discard;\\ntexColor.a = texColor.r;\\ngl_FragColor = texColor * vertexColor;\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec2 scale = fontScale * cameraScale2D.xy;\\nfloat scaleBy = max(scale.x, scale.y) / maxScale;\\nvec2 pushOut = normals * glyphSize * fontScale;\\nfloat vx = mix(\\n(origin.x + padding.x + offset.x + pushOut.x),\\norigin.x + anchor.x + (padding.x - anchor.x + offset.x + pushOut.x) / scaleBy,\\nfloat(scale.x >= maxScale)\\n);\\nfloat vy = mix(\\n(origin.y + padding.y + offset.y + pushOut.y),\\norigin.y + anchor.y + (padding.y - anchor.y + offset.y + pushOut.y) / scaleBy,\\nfloat(scale.y >= maxScale)\\n);\\nvec3 position = vec3(vec2(vx, vy), depth);\\ngl_Position = clipSpace(position);\\ntexCoord = texture.xy + (texture.zw - texture.xy) * normals;\\nvertexColor = color * color.a;\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec2 scale = fontScale * cameraScale2D.xy;\\nfloat scaleBy = max(scale.x, scale.y) / maxScale;\\nvec2 pushOut = normals * glyphSize * fontScale;\\nfloat vx = mix(\\n(-anchor.x + offset.x + pushOut.x),\\n(-anchor.x + offset.x + pushOut.x) / scaleBy,\\nfloat(scale.x >= maxScale)\\n);\\nfloat vy = mix(\\n(-anchor.y + offset.y + pushOut.y),\\n(-anchor.y + offset.y + pushOut.y) / scaleBy,\\nfloat(scale.y >= maxScale)\\n);\\nvec3 position = vec3(origin + padding + vec2(vx, vy), depth);\\ngl_Position = clipSpace(position);\\ntexCoord = texture.xy + (texture.zw - texture.xy) * normals;\\nvertexColor = color * color.a;\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec4 texColor = texture2D(fontMap, texCoord);\\nif (texColor.r <= 0.0) discard;\\ntexColor.a = texColor.r;\\ngl_FragColor = texColor * vertexColor;\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec4 texColor = texture2D(fontMap, texCoord);\\nif (texColor.r <= 0.0) discard;\\ntexColor.a = texColor.r;\\ngl_FragColor = texColor * vertexColor;\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec2 pushOut = normals * glyphSize * fontScale;\\nvec3 position = vec3(origin + anchor + (padding - anchor + offset + pushOut) / cameraScale2D.xy , depth);\\ngl_Position = clipSpace(position);\\ntexCoord = texture.xy + (texture.zw - texture.xy) * normals;\\nvertexColor = color * color.a;\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec2 pushOut = normals * glyphSize * fontScale;\\nvec3 position = vec3(origin + padding + (-anchor + offset + pushOut) / cameraScale2D.xy, depth);\\ngl_Position = clipSpace(position);\\ntexCoord = texture.xy + (texture.zw - texture.xy) * normals;\\nvertexColor = color * color.a;\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec4 texColor = texture2D(fontMap, texCoord);\\nif (texColor.r <= 0.0) discard;\\ntexColor.a = texColor.r;\\ngl_FragColor = texColor * vertexColor;\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec2 pushOut = normals * glyphSize * fontScale;\\nvec3 position = vec3(origin + padding + offset + pushOut, depth);\\ngl_Position = clipSpace(position);\\ntexCoord = texture.xy + (texture.zw - texture.xy) * normals;\\nvertexColor = color * color.a;\\n}\"","import { InstanceProvider } from \"../../../instance-provider/instance-provider\";\nimport { IAutoEasingMethod } from \"../../../math/auto-easing-method\";\nimport { add2, copy4, scale2, Vec, Vec2 } from \"../../../math/vector\";\nimport { fontRequest, IFontResourceRequest } from \"../../../resources\";\nimport {\n  ILayerConstructionClass,\n  LayerInitializer\n} from \"../../../surface/layer\";\nimport { InstanceDiffType, newLineRegEx } from \"../../../types\";\nimport { createLayer } from \"../../../util/create-layer\";\nimport { AnchorType, ScaleMode } from \"../../types\";\nimport { ILayer2DProps, Layer2D } from \"../../view/layer-2d\";\nimport { BorderInstance } from \"./border-instance\";\nimport { BorderLayer } from \"./border-layer\";\nimport { GlyphInstance } from \"./glyph-instance\";\nimport { IGlyphLayerOptions } from \"./glyph-layer\";\nimport { LabelInstance } from \"./label-instance\";\nimport { LabelLayer } from \"./label-layer\";\nimport {\n  NewLineCharacterMode,\n  TextAlignment,\n  TextAreaInstance,\n  TextAreaLabel,\n  WordWrap\n} from \"./text-area-instance\";\n\n/** CalculatesanchorCalulater the ancho position of a textArea based on AnchorType */\nconst anchorCalulater: {\n  [key: number]: (textArea: TextAreaInstance) => Vec2;\n} = {\n  [AnchorType.TopLeft]: (_textArea: TextAreaInstance) => [0, 0],\n  [AnchorType.TopMiddle]: (textArea: TextAreaInstance) => [\n    textArea.maxWidth / 2.0,\n    0.0\n  ],\n  [AnchorType.TopRight]: (textArea: TextAreaInstance) => [\n    textArea.maxWidth,\n    0.0\n  ],\n  [AnchorType.MiddleLeft]: (textArea: TextAreaInstance) => [\n    0.0,\n    textArea.maxHeight / 2.0\n  ],\n  [AnchorType.Middle]: (textArea: TextAreaInstance) => [\n    textArea.maxWidth / 2.0,\n    textArea.maxHeight / 2.0\n  ],\n  [AnchorType.MiddleRight]: (textArea: TextAreaInstance) => [\n    textArea.maxWidth,\n    textArea.maxHeight / 2.0\n  ],\n  [AnchorType.BottomLeft]: (textArea: TextAreaInstance) => [\n    0.0,\n    textArea.maxHeight\n  ],\n  [AnchorType.BottomMiddle]: (textArea: TextAreaInstance) => [\n    textArea.maxWidth / 2.0,\n    textArea.maxHeight\n  ],\n  [AnchorType.BottomRight]: (textArea: TextAreaInstance) => [\n    textArea.maxWidth,\n    textArea.maxHeight\n  ],\n  [AnchorType.Custom]: (textArea: TextAreaInstance) => [\n    textArea.anchor.x || 0.0,\n    textArea.anchor.y || 0.0\n  ]\n};\n\n/**\n * Get the offsetY of a word by comparing offsetYs of all its letters. So we can put the word to the\n * the right position.\n */\nfunction getOffsetY(text: string, map: Map<string, number>) {\n  let offsetY = Number.MAX_SAFE_INTEGER;\n\n  for (let i = 0, endi = text.length; i < endi; i++) {\n    const c = text[i];\n    const height = map.get(c);\n\n    if (height === 0) {\n      offsetY = 0;\n    } else if (height && height < offsetY) {\n      offsetY = height;\n    }\n  }\n\n  return offsetY === Number.MAX_SAFE_INTEGER ? 0 : offsetY;\n}\n\n/**\n * Split words from a text by space and new line sign\n */\nfunction generateWords(text: string): string[] {\n  const wordsToLayout: string[] = [];\n  const lines: string[] = text.split(newLineRegEx);\n\n  for (let i = 0, endi = lines.length - 1; i < endi; i++) {\n    const line = lines[i];\n    const wordsInLine = line.split(\" \");\n\n    wordsInLine.forEach(word => {\n      if (word !== \"\") {\n        wordsToLayout.push(word);\n      }\n    });\n\n    // Create an element with text \"\\n\" to indicate a new line will be created\n    wordsToLayout.push(\"\\n\");\n  }\n\n  const lastLine = lines[lines.length - 1];\n  const wordsInLine = lastLine.split(\" \");\n\n  wordsInLine.forEach(word => {\n    if (word !== \"\") {\n      wordsToLayout.push(word);\n    }\n  });\n\n  return wordsToLayout;\n}\n\n/**\n * Generate the map for every glyph to offsetY, then we can use info to get correct offsetY for\n * every label by checking all the letters' offsetY of a label.\n */\nfunction generateGlyphOffsetYMap(\n  instance: TextAreaInstance,\n  kerningRequest: IFontResourceRequest\n) {\n  const glyphToOffsetY = new Map<string, number>();\n\n  if (kerningRequest.fontMap) {\n    const sourceFontSize = kerningRequest.fontMap.fontSource.size;\n    const fontScale = instance.fontSize / sourceFontSize;\n    const fontMap = kerningRequest.fontMap;\n    const checkText = instance.text.replace(/\\s/g, \"\");\n    let minY = Number.MAX_SAFE_INTEGER;\n    let offsetY = 0;\n    let kernY;\n    let leftChar = \"\";\n\n    for (let i = 0, iMax = checkText.length; i < iMax; ++i) {\n      const char = checkText[i];\n      kernY = 0;\n\n      if (leftChar) {\n        kernY = fontMap.kerning[leftChar][char][1] || 0;\n      }\n\n      offsetY = offsetY + kernY * fontScale;\n      glyphToOffsetY.set(char, offsetY);\n      minY = Math.min(offsetY, minY);\n      leftChar = char;\n    }\n\n    glyphToOffsetY.forEach((value, key) => {\n      glyphToOffsetY.set(key, value - minY);\n    });\n  }\n\n  return glyphToOffsetY;\n}\n\n/**\n * Generate glyphWidths for a label in a TextAreaInstance. It stores the widths of the first letter,\n * width of the first two letters, width of the first three letters untill the width of the label.\n * It will help to know where to wrap a word in character wordwrap mode.\n */\nfunction getGlyphWidths(\n  label: LabelInstance,\n  instance: TextAreaInstance,\n  kerningRequest: IFontResourceRequest\n) {\n  const glyphWidths = [];\n  const sourceFontSize = kerningRequest.fontMap\n    ? kerningRequest.fontMap.fontSource.size\n    : instance.fontSize;\n\n  const fontScale = instance.fontSize / sourceFontSize;\n\n  let leftChar = \"\";\n  let currentWidth = 0;\n  let offset: Vec2 = [0, 0];\n\n  for (let i = 0, iMax = label.text.length; i < iMax; i++) {\n    const char = label.text[i];\n\n    if (kerningRequest.fontMap) {\n      let kern: Vec2 = [0, 0];\n\n      if (leftChar) {\n        kern = kerningRequest.fontMap.kerning[leftChar][char] || [0, 0];\n      }\n\n      offset = add2(offset, scale2(kern, fontScale));\n      if (i !== 0) offset = add2(offset, [instance.letterSpacing, 0]);\n      const image = kerningRequest.fontMap.glyphMap[char];\n      currentWidth = offset[0] + image.pixelWidth * fontScale;\n      glyphWidths.push(currentWidth);\n      leftChar = char;\n    }\n  }\n\n  return glyphWidths;\n}\n\n/**\n * Constructor props for making a new label layer\n */\nexport interface ITextAreaLayerProps<T extends LabelInstance>\n  extends ILayer2DProps<T> {\n  /** Animation methods for various properties of the glyphs */\n  animateLabel?: {\n    anchor?: IAutoEasingMethod<Vec>;\n    color?: IAutoEasingMethod<Vec>;\n    offset?: IAutoEasingMethod<Vec>;\n    origin?: IAutoEasingMethod<Vec>;\n  };\n  /** Animation methods fro various properties of the borders */\n  animateBorder?: {\n    color?: IAutoEasingMethod<Vec>;\n    location?: IAutoEasingMethod<Vec>;\n  };\n  /** A custom layer to handle rendering glyph instances */\n  customGlyphLayer?: ILayerConstructionClass<\n    GlyphInstance,\n    IGlyphLayerOptions<GlyphInstance>\n  >;\n  /** String identifier of the resource font to use for the layer */\n  resourceKey?: string;\n  /** This number represents how much space each whitespace character represents */\n  whiteSpaceKerning?: number;\n  /** This sets the scaling mode of textArea, cound be ALWAYS, BOUND_MAX or NEVER */\n  scaling?: ScaleMode;\n}\n\n/**\n * This is a composite layer that will take in and manage Label Instances. The true instance\n * that will be rendered as a result of a Label Instance will simply be Glyph Instances. Hence\n * this is a composite layer that is merely a manager to split up the label's requested string\n * into Glyphs to render.\n */\nexport class TextAreaLayer<\n  T extends TextAreaInstance,\n  U extends ITextAreaLayerProps<T>\n> extends Layer2D<T, U> {\n  static defaultProps: ITextAreaLayerProps<TextAreaInstance> = {\n    key: \"\",\n    data: new InstanceProvider<TextAreaInstance>(),\n    scaling: ScaleMode.ALWAYS\n  };\n\n  providers = {\n    /** Provider for the label layer this layer manages */\n    labels: new InstanceProvider<LabelInstance>(),\n    /** Provider for the border layer that renders the border of text area */\n    borders: new InstanceProvider<BorderInstance>()\n  };\n\n  /**\n   * These are the property ids for the instances that we need to know when they changed so we can adjust\n   * the underlying glyphs.\n   */\n  propertyIds: { [key: string]: number } | undefined;\n  /**\n   * When this is flagged, we must do a complete recomputation of all our label's glyphs positions and kernings.\n   * This event really only takes place when the font resource changes.\n   */\n  fullUpdate: boolean = false;\n  /** Tracks all assigned labels to the text area */\n  areaToLabels = new Map<TextAreaInstance, TextAreaLabel[]>();\n  /** Tracks the labels assigned to an area and are grouped by the line they appear within */\n  areaToLines = new Map<TextAreaInstance, LabelInstance[][]>();\n  /** This stores all of the glyphs the label is waiting on to fire the onReady event. */\n  areaWaitingOnLabel = new Map<TextAreaInstance, Set<LabelInstance>>();\n  /** This stores kerningRequest of TextAreaInstance */\n  areaTokerningRequest = new Map<TextAreaInstance, IFontResourceRequest>();\n  /** This stores splited words of a textArea */\n  areaToWords = new Map<TextAreaInstance, string[]>();\n\n  labelsInLine: LabelInstance[] = [];\n\n  /**\n   * This provides the child layers that will render on behalf of this layer.\n   *\n   * For Labels, a label is simply a group of well placed glyphs. So we defer all of\n   * the labels changes by converting the label into glyphs and applying the changes to\n   * it's set of glyphs.\n   */\n  childLayers(): LayerInitializer[] {\n    const animateLabel = this.props.animateLabel || {};\n    const animateBorder = this.props.animateBorder || {};\n    const labelScaling = this.props.scaling;\n\n    return [\n      createLayer(LabelLayer, {\n        animate: animateLabel,\n        customGlyphLayer: this.props.customGlyphLayer,\n        data: this.providers.labels,\n        key: `${this.id}.labels`,\n        resourceKey: this.props.resourceKey,\n        scaleMode: labelScaling,\n        inTextArea: true\n      }),\n      createLayer(BorderLayer, {\n        animate: {\n          color: animateBorder.color,\n          location: animateBorder.location\n        },\n        data: this.providers.borders,\n        key: `${this.id}.border`\n      })\n    ];\n  }\n\n  /**\n   * We override the draw method of the layer to handle the diffs of the provider in a\n   * custom fashion by delegating the changes of the provider to the child layers.\n   */\n  draw() {\n    // Retrieve changes properly\n    const changes = this.resolveChanges();\n    // No changes, nothing to be done\n    if (changes.length <= 0) return;\n    // Make sure our instance property ids are established for the instance type involved\n    // We want only the ids of changes that causes us to\n    if (!this.propertyIds) {\n      const instance = changes[0][0];\n      this.propertyIds = this.getInstanceObservableIds(instance, [\n        \"active\",\n        \"alignment\",\n        \"borderWidth\",\n        \"color\",\n        \"fontSize\",\n        \"hasBorder\",\n        \"letterSpacing\",\n        \"lineHeight\",\n        \"maxHeight\",\n        \"maxWidth\",\n        \"origin\",\n        \"padding\",\n        \"text\",\n        \"wordWrap\"\n      ]);\n    }\n\n    const {\n      active: activeId,\n      alignment: alignmentId,\n      borderWidth: borderWidthId,\n      color: colorId,\n      fontSize: fontSizeId,\n      hasBorder: hasBorderId,\n      letterSpacing: letterSpacingId,\n      lineHeight: lineHeightId,\n      maxHeight: maxHeightId,\n      maxWidth: maxWidthId,\n      origin: originId,\n      padding: paddingId,\n      text: textId,\n      wordWrap: wordWrapId\n    } = this.propertyIds;\n\n    for (let i = 0, iMax = changes.length; i < iMax; ++i) {\n      const [instance, diffType, changed] = changes[i];\n\n      switch (diffType) {\n        case InstanceDiffType.CHANGE:\n          // Perform the insert action instead of the change if the textArea has never been registered\n          if (!this.areaToLabels.get(instance)) {\n            this.insert(instance);\n            continue;\n          }\n          // If text was changed, the glyphs all need updating of their characters and\n          // possibly have glyphs added or removed to handle the issue.\n          if (changed[textId] !== undefined) {\n            this.clear(instance);\n            this.updateLabels(instance);\n            this.layout(instance);\n          } else if (changed[activeId] !== undefined) {\n            if (instance.active) {\n              this.layout(instance);\n              this.showLabels(instance);\n            } else {\n              this.hideLabels(instance);\n            }\n          }\n\n          if (changed[alignmentId] !== undefined) {\n            this.clear(instance);\n            this.updateLabels(instance);\n            this.layoutLabels(instance);\n          }\n\n          if (changed[colorId] !== undefined) {\n            this.updateLabelColors(instance);\n          }\n\n          if (changed[originId] !== undefined) {\n            this.updateLabelOrigins(instance);\n          }\n\n          if (changed[fontSizeId] !== undefined) {\n            this.updateLabelFontSizes(instance);\n          }\n\n          if (changed[wordWrapId] !== undefined) {\n            this.updateLabelLineWrap(instance);\n          }\n\n          if (changed[lineHeightId] !== undefined) {\n            this.updateLabelLineHeight(instance);\n          }\n\n          if (changed[maxWidthId] !== undefined) {\n            this.updateTextAreaSize(instance);\n          }\n\n          if (changed[maxHeightId] !== undefined) {\n            this.updateTextAreaSize(instance);\n          }\n\n          if (changed[paddingId] !== undefined) {\n            this.updateTextAreaSize(instance);\n          }\n\n          if (changed[borderWidthId] !== undefined) {\n            this.updateBorderWidth(instance);\n          }\n\n          if (changed[hasBorderId] !== undefined) {\n            this.updateBorder(instance);\n          }\n\n          if (changed[letterSpacingId] !== undefined) {\n            this.updateLetterSpacing(instance);\n          }\n\n          break;\n\n        case InstanceDiffType.INSERT:\n          // Insertions force a full update of all labels for the text-area\n          this.insert(instance);\n          break;\n\n        case InstanceDiffType.REMOVE:\n          const labels = this.areaToLabels.get(instance);\n\n          if (labels) {\n            for (let i = 0, iMax = labels.length; i < iMax; ++i) {\n              const label = labels[i];\n              if (label instanceof LabelInstance) {\n                this.providers.labels.remove(label);\n              }\n            }\n\n            this.areaToLabels.delete(instance);\n            this.areaWaitingOnLabel.delete(instance);\n          }\n          break;\n      }\n    }\n  }\n\n  /**\n   * Handles insertion operation for the textArea\n   */\n  private insert(instance: T) {\n    this.layout(instance);\n    this.updateLabels(instance);\n  }\n\n  /**\n   * When the glyph is ready to render this executes.\n   */\n  handleLabelReady = (label: LabelInstance) => {\n    // The glyph must be associated to have this work\n    if (!label.parentTextArea) {\n      // If no parent text area, we should not have this glyph returning false alarms to this method\n      delete label.onReady;\n\n      return;\n    }\n\n    // Get the text area this label is a part of\n    const textArea = label.parentTextArea;\n    // Get the list of glyphs the label is waiting on.\n    const waiting = this.areaWaitingOnLabel.get(textArea);\n\n    if (!waiting) {\n      return;\n    }\n\n    // Clear this label from the waiting list\n    if (waiting.has(label)) {\n      waiting.delete(label);\n\n      if (waiting.size <= 0) {\n        textArea.active = true;\n        // If the waiting list is empty we can get the label to execute it's ready handler\n        const onReady = textArea.onReady;\n        // Execute the callback if present\n        if (onReady) onReady(textArea);\n      }\n    }\n  };\n\n  /**\n   * Unmount all of the glyphs that make the label\n   */\n  hideLabels(instance: T) {\n    const labels = this.areaToLabels.get(instance);\n    if (!labels) return;\n\n    for (let i = 0, iMax = labels.length; i < iMax; ++i) {\n      const label = labels[i];\n      if (label instanceof LabelInstance) {\n        this.providers.labels.remove(label);\n      }\n    }\n  }\n\n  /**\n   * Tell the system this layer is not providing any rendering IO information for the GPU to render.\n   */\n  initShader() {\n    return null;\n  }\n\n  /** When text is changed, labels should be clear in order to generate new labels */\n  clear(instance: T) {\n    const labels = instance.labels;\n\n    for (let i = 0, iMax = labels.length; i < iMax; i++) {\n      const label = labels[i];\n      if (label instanceof LabelInstance) {\n        this.providers.labels.remove(label);\n      }\n    }\n\n    instance.labels = [];\n    const newLabels = instance.newLabels;\n\n    for (let i = 0, iMax = newLabels.length; i < iMax; i++) {\n      const label = newLabels[i];\n      if (label instanceof LabelInstance) {\n        this.providers.labels.remove(label);\n      }\n    }\n\n    instance.newLabels = [];\n    this.areaToLabels.delete(instance);\n    this.areaWaitingOnLabel.delete(instance);\n    this.areaToWords.delete(instance);\n  }\n\n  /** When a label exceeds the maxWidth of a textArea, sperate it into several parts */\n  seperateLabel(\n    instance: TextAreaInstance,\n    label: LabelInstance,\n    glyphToHeight: Map<string, number>,\n    word: string,\n    index: number,\n    currentX: number,\n    currentY: number,\n    spaceWidth: number,\n    glyphWidths: number[]\n  ): [number, number] {\n    const topPadding = instance.padding[0];\n    const rightPadding = instance.padding[1] || 0;\n    const bottomPadding = instance.padding[2] || 0;\n    const leftPadding = instance.padding[3] || 0;\n    const maxWidth = instance.maxWidth - leftPadding - rightPadding;\n    const maxHeight = instance.maxHeight - topPadding - bottomPadding;\n    const originX = instance.origin[0];\n    const originY = instance.origin[1];\n\n    label.active = false;\n\n    // Label1\n    const text1 = word.substring(0, index + 1);\n    const offsetY1 = getOffsetY(text1, glyphToHeight);\n    const textAreaAnchor = anchorCalulater[instance.anchor.type](instance);\n\n    const label1 = new LabelInstance({\n      anchor: {\n        padding: 0,\n        type: AnchorType.Custom,\n        paddingDirection: [\n          currentX + leftPadding,\n          currentY + topPadding + offsetY1\n        ],\n        x: textAreaAnchor[0],\n        y: textAreaAnchor[1]\n      },\n      color: instance.color,\n      fontSize: instance.fontSize,\n      letterSpacing: instance.letterSpacing,\n      origin: [originX, originY],\n      text: text1\n    });\n\n    label1.size = [glyphWidths[index], label.size[1]];\n    this.providers.labels.add(label1);\n    instance.newLabels.push(label1);\n\n    this.labelsInLine.push(label1);\n    currentX += label1.getWidth() + spaceWidth;\n\n    // New Line if word wrap mode is normal\n    if (\n      instance.wordWrap === WordWrap.CHARACTER ||\n      instance.wordWrap === WordWrap.WORD\n    ) {\n      this.setTextAlignment(\n        currentX,\n        currentY,\n        spaceWidth,\n        maxWidth,\n        instance.alignment\n      );\n\n      currentX = 0;\n      currentY += instance.lineHeight;\n\n      // Label2\n      if (currentY + instance.lineHeight <= maxHeight) {\n        let widthLeft =\n          glyphWidths[glyphWidths.length - 1] - glyphWidths[index];\n\n        while (\n          widthLeft > maxWidth &&\n          currentY + instance.lineHeight <= maxHeight\n        ) {\n          let lastIndexOfLine = glyphWidths.length - 1;\n\n          // Get the lastIndex in a label that stay in current line\n          while (glyphWidths[lastIndexOfLine] - glyphWidths[index] > maxWidth) {\n            lastIndexOfLine--;\n          }\n\n          const text = word.substring(index + 1, lastIndexOfLine + 1);\n          const offsetY = getOffsetY(text, glyphToHeight);\n          const label3 = new LabelInstance({\n            anchor: {\n              padding: 0,\n              type: AnchorType.Custom,\n              paddingDirection: [\n                currentX + leftPadding,\n                currentY + topPadding + offsetY\n              ],\n              x: textAreaAnchor[0],\n              y: textAreaAnchor[1]\n            },\n            color: instance.color,\n            fontSize: instance.fontSize,\n            letterSpacing: instance.letterSpacing,\n            origin: [originX, originY],\n            text\n          });\n\n          label3.size = [\n            glyphWidths[lastIndexOfLine] - glyphWidths[index],\n            label.size[1]\n          ];\n\n          currentX += label3.getWidth() + spaceWidth;\n\n          this.labelsInLine.push(label3);\n\n          this.providers.labels.add(label3);\n          instance.newLabels.push(label3);\n\n          this.setTextAlignment(\n            currentX,\n            currentY,\n            spaceWidth,\n            maxWidth,\n            instance.alignment\n          );\n\n          currentX = 0;\n          currentY += instance.lineHeight;\n          index = lastIndexOfLine;\n          widthLeft = glyphWidths[glyphWidths.length - 1] - glyphWidths[index];\n        }\n\n        if (currentY + instance.lineHeight <= maxHeight) {\n          const text2 = word.substring(index + 1);\n          const offsetY2 = getOffsetY(text2, glyphToHeight);\n          const label2 = new LabelInstance({\n            anchor: {\n              padding: 0,\n              type: AnchorType.Custom,\n              paddingDirection: [\n                currentX + leftPadding,\n                currentY + topPadding + offsetY2\n              ],\n              x: textAreaAnchor[0],\n              y: textAreaAnchor[1]\n            },\n            color: instance.color,\n            fontSize: instance.fontSize,\n            letterSpacing: instance.letterSpacing,\n            origin: [originX, originY],\n            text: text2\n          });\n\n          label2.size = [\n            glyphWidths[glyphWidths.length - 1] - glyphWidths[index],\n            label.size[1]\n          ];\n\n          this.labelsInLine.push(label2);\n\n          const widths: number[] = [];\n\n          for (let i = index + 1; i < glyphWidths.length; i++) {\n            widths.push(glyphWidths[i] - glyphWidths[index]);\n          }\n\n          this.providers.labels.add(label2);\n          instance.newLabels.push(label2);\n\n          currentX += label2.getWidth() + spaceWidth;\n        }\n      }\n    }\n\n    // If wordWrap is NONE, stay in the line\n    else if (instance.wordWrap === WordWrap.NONE) {\n      currentX += label1.getWidth() + spaceWidth;\n    }\n\n    return [currentX, currentY];\n  }\n\n  /**\n   * This updates textAreaInstance after lineWrap is changed\n   */\n  updateLabelLineWrap(instance: T) {\n    const labels = this.areaToLabels.get(instance);\n    if (!labels) return;\n\n    // Set active of all labels to be true in order to awake those hidden labels when wrapping word\n    for (let i = 0, iMax = labels.length; i < iMax; ++i) {\n      const label = labels[i];\n      if (label instanceof LabelInstance) {\n        label.active = true;\n      }\n    }\n\n    // Clear all new labels\n    for (let i = 0, iMax = instance.newLabels.length; i < iMax; ++i) {\n      const label = instance.newLabels[i];\n      this.providers.labels.remove(label);\n    }\n\n    instance.newLabels = [];\n    this.layoutLabels(instance);\n  }\n\n  /**\n   * This updates textAreaInstance after lineHeight is changed\n   */\n  updateLabelLineHeight(instance: T) {\n    const labels = this.areaToLabels.get(instance);\n    if (!labels) return;\n\n    // Set active of all labels to be true in order to awake those hidden labels when wrapping word\n    for (let i = 0, iMax = labels.length; i < iMax; ++i) {\n      const label = labels[i];\n      if (label instanceof LabelInstance) {\n        label.active = true;\n      }\n    }\n\n    // Clear all new labels\n    for (let i = 0, iMax = instance.newLabels.length; i < iMax; ++i) {\n      const label = instance.newLabels[i];\n      this.providers.labels.remove(label);\n    }\n\n    instance.newLabels = [];\n    this.layoutLabels(instance);\n  }\n\n  /**\n   * This updates textAreaInstance after textArea width or height is changed\n   */\n  updateTextAreaSize(instance: T) {\n    const labels = this.areaToLabels.get(instance);\n    if (!labels) return;\n\n    // Set active of all labels to be true in order to awake those hidden labels when wrapping word\n    for (let i = 0, iMax = labels.length; i < iMax; ++i) {\n      const label = labels[i];\n      if (label instanceof LabelInstance) {\n        label.active = true;\n      }\n    }\n\n    // Clear all new labels\n    for (let i = 0, iMax = instance.newLabels.length; i < iMax; ++i) {\n      const label = instance.newLabels[i];\n      this.providers.labels.remove(label);\n    }\n\n    instance.newLabels = [];\n\n    // Clear all borders\n    for (let i = 0, iMax = instance.borders.length; i < iMax; ++i) {\n      const border = instance.borders[i];\n      this.providers.borders.remove(border);\n    }\n\n    instance.borders = [];\n    this.layoutBorder(instance);\n    this.layoutLabels(instance);\n  }\n\n  /**\n   * Update thickness of border\n   */\n  updateBorderWidth(instance: T) {\n    // Clear all borders\n    for (let i = 0, iMax = instance.borders.length; i < iMax; ++i) {\n      const border = instance.borders[i];\n      this.providers.borders.remove(border);\n    }\n\n    instance.borders = [];\n    this.layoutBorder(instance);\n  }\n\n  /**\n   * Update the border of textArea to remove border or add border\n   */\n  updateBorder(instance: T) {\n    if (instance.hasBorder) {\n      this.layoutBorder(instance);\n    } else {\n      for (let i = 0, iMax = instance.borders.length; i < iMax; ++i) {\n        const border = instance.borders[i];\n        this.providers.borders.remove(border);\n      }\n\n      instance.borders = [];\n    }\n  }\n\n  /**\n   * Update letterSpacing of all labels in textArea\n   */\n  updateLetterSpacing(instance: T) {\n    this.clear(instance);\n    this.updateLabels(instance);\n    this.layout(instance);\n  }\n\n  /**\n   * Sets the alignment of TextArea by adjusting all the labels' origin\n   */\n  setTextAlignment(\n    currentX: number,\n    currentY: number,\n    spaceWidth: number,\n    maxWidth: number,\n    alignment: TextAlignment\n  ) {\n    if (currentX - spaceWidth < maxWidth) {\n      if (alignment !== TextAlignment.LEFT) {\n        const offset = maxWidth - currentX + spaceWidth;\n        const toMove = alignment === TextAlignment.RIGHT ? offset : offset / 2;\n\n        this.labelsInLine.forEach(label => {\n          const oldAnchor = label.anchor;\n\n          label.anchor = {\n            padding: oldAnchor.padding,\n            type: AnchorType.Custom,\n            paddingDirection: [\n              (oldAnchor.paddingDirection ? oldAnchor.paddingDirection[0] : 0) +\n                toMove,\n              oldAnchor.paddingDirection\n                ? oldAnchor.paddingDirection[1]\n                : currentY\n            ],\n            x: oldAnchor.x,\n            y: oldAnchor.y\n          };\n        });\n      }\n    }\n\n    // Empty the labels array\n    this.labelsInLine = [];\n  }\n\n  /**\n   * Layout the border of textAreaInstance\n   */\n  layoutBorder(instance: T) {\n    if (instance.hasBorder) {\n      const kerningRequest = this.areaTokerningRequest.get(instance);\n      if (!kerningRequest) return;\n\n      const fontSourceSize = kerningRequest.fontMap\n        ? kerningRequest.fontMap.fontSource.size\n        : instance.fontSize;\n      const fontScale = instance.fontSize / fontSourceSize;\n      const scaling = this.props.scaling;\n      const borderWidth = instance.borderWidth;\n\n      const topBorder: BorderInstance = new BorderInstance({\n        color: instance.color,\n        fontScale,\n        scaling,\n        size: [instance.maxWidth + 2 * borderWidth, borderWidth],\n        textAreaOrigin: instance.origin,\n        textAreaAnchor: anchorCalulater[instance.anchor.type](instance),\n        position: [-borderWidth, -borderWidth]\n      });\n\n      const leftBorder: BorderInstance = new BorderInstance({\n        color: instance.color,\n        fontScale,\n        scaling,\n        size: [borderWidth, instance.maxHeight + 2 * borderWidth],\n        textAreaOrigin: instance.origin,\n        textAreaAnchor: anchorCalulater[instance.anchor.type](instance),\n        position: [-borderWidth, -borderWidth]\n      });\n\n      const rightBorder: BorderInstance = new BorderInstance({\n        color: instance.color,\n        fontScale,\n        scaling,\n        size: [borderWidth, instance.maxHeight + 2 * borderWidth],\n        textAreaOrigin: instance.origin,\n        textAreaAnchor: anchorCalulater[instance.anchor.type](instance),\n        position: [instance.maxWidth, -borderWidth]\n      });\n\n      const bottomBorder: BorderInstance = new BorderInstance({\n        color: instance.color,\n        fontScale,\n        scaling,\n        size: [instance.maxWidth + 2 * borderWidth, borderWidth],\n        textAreaOrigin: instance.origin,\n        textAreaAnchor: anchorCalulater[instance.anchor.type](instance),\n        position: [-borderWidth, instance.maxHeight]\n      });\n\n      this.providers.borders.add(topBorder);\n      this.providers.borders.add(leftBorder);\n      this.providers.borders.add(rightBorder);\n      this.providers.borders.add(bottomBorder);\n\n      instance.borders.push(topBorder);\n      instance.borders.push(leftBorder);\n      instance.borders.push(rightBorder);\n      instance.borders.push(bottomBorder);\n    }\n  }\n\n  /**\n   * Calculate the positions of labels\n   */\n  layoutLabels(instance: T) {\n    const kerningRequest = this.areaTokerningRequest.get(instance);\n    if (!kerningRequest) return;\n\n    const topPadding = instance.padding[0];\n    const rightPadding = instance.padding[1] || 0;\n    const bottomPadding = instance.padding[2] || 0;\n    const leftPadding = instance.padding[3] || 0;\n    const maxWidth = instance.maxWidth - leftPadding - rightPadding;\n    const maxHeight = instance.maxHeight - topPadding - bottomPadding;\n\n    const originX = instance.origin[0];\n    const originY = instance.origin[1];\n\n    let spaceWidth = 0;\n\n    if (instance.spaceWidth) {\n      spaceWidth = instance.spaceWidth;\n    } else {\n      if (kerningRequest.fontMap) {\n        const fontSourceSize = kerningRequest.fontMap.fontSource.size;\n        const fontScale = instance.fontSize / fontSourceSize;\n        spaceWidth = kerningRequest.fontMap.spaceWidth * fontScale;\n      } else {\n        spaceWidth = this.props.whiteSpaceKerning || instance.fontSize / 2;\n      }\n\n      instance.spaceWidth = spaceWidth;\n    }\n\n    const glyphToOffsetY = generateGlyphOffsetYMap(instance, kerningRequest);\n    let currentX = 0;\n    let currentY = 0;\n\n    this.labelsInLine = [];\n\n    // Layout labels within maxWidth and maxHeight one after one, line after line.\n    // Labels which exceed maxHeight will be hidden, labels which exceed maxWidth will be wrap,\n    // hidden to move to next line based on wordWrap mode.\n    for (let i = 0, endi = instance.labels.length; i < endi; ++i) {\n      const label = instance.labels[i];\n\n      if (label instanceof LabelInstance) {\n        const width = label.getWidth();\n        const offsetY = getOffsetY(label.text, glyphToOffsetY);\n        const glyphWidths = getGlyphWidths(label, instance, kerningRequest);\n\n        // label.textAreaOrigin = [originX, originY];\n        // Make sure all the labels are within maxHeight and first letter is not bigger than maxWidth\n        if (\n          currentY + instance.lineHeight <= maxHeight &&\n          glyphWidths[0] <= maxWidth\n        ) {\n          // Whole label can be put within maxWidth\n          if (currentX + width <= maxWidth) {\n            label.origin = [originX, originY];\n            const textAreaAnchor = anchorCalulater[instance.anchor.type](\n              instance\n            );\n\n            label.anchor = {\n              padding: 0,\n              paddingDirection: [\n                currentX + leftPadding,\n                currentY + topPadding + offsetY\n              ],\n              type: AnchorType.Custom,\n              x: textAreaAnchor[0],\n              y: textAreaAnchor[1]\n            };\n\n            currentX += width + spaceWidth;\n            this.labelsInLine.push(label);\n\n            if (currentX >= maxWidth) {\n              // If next label is not NEWLINE, no need to move to next line\n              if (\n                instance.wordWrap === WordWrap.CHARACTER &&\n                i + 1 < endi &&\n                instance.labels[i + 1] !== NewLineCharacterMode.NEWLINE\n              ) {\n                this.setTextAlignment(\n                  currentX,\n                  currentY,\n                  spaceWidth,\n                  maxWidth,\n                  instance.alignment\n                );\n\n                currentX = 0;\n                currentY += instance.lineHeight;\n              }\n            }\n          } else {\n            // A label which will just put to next line if it exceeds the maxWidth when in WORD mode\n            // The label's width should be smaller than maxWidth\n            if (\n              instance.wordWrap === WordWrap.WORD &&\n              label.getWidth() <= instance.maxWidth\n            ) {\n              this.setTextAlignment(\n                currentX,\n                currentY,\n                spaceWidth,\n                maxWidth,\n                instance.alignment\n              );\n\n              currentX = 0;\n              currentY += instance.lineHeight;\n\n              if (currentY + instance.lineHeight <= maxHeight) {\n                label.origin = [originX, originY];\n                const textAreaAnchor = anchorCalulater[instance.anchor.type](\n                  instance\n                );\n                label.anchor = {\n                  padding: 0,\n                  paddingDirection: [\n                    currentX + leftPadding,\n                    currentY + topPadding + offsetY\n                  ],\n                  type: AnchorType.Custom,\n                  x: textAreaAnchor[0],\n                  y: textAreaAnchor[1]\n                };\n\n                this.labelsInLine.push(label);\n\n                currentX += label.getWidth() + spaceWidth;\n              } else {\n                label.active = false;\n              }\n            }\n            // A label will be cut into two parts if label's width exceeds maxwidth\n            else {\n              const spaceLeft = maxWidth - currentX;\n              let index = glyphWidths.length - 1;\n              const word = label.text;\n\n              // Find the index to retrieve the part of word that stay in this line\n              while (glyphWidths[index] > spaceLeft) {\n                index--;\n              }\n\n              // Some part of label stay in this line\n              if (index >= 0) {\n                const sizes = this.seperateLabel(\n                  instance,\n                  label,\n                  glyphToOffsetY,\n                  word,\n                  index,\n                  currentX,\n                  currentY,\n                  spaceWidth,\n                  glyphWidths\n                );\n\n                currentX = sizes[0];\n                currentY = sizes[1];\n              }\n              // The whole word moves to next line or set active false if index < 0\n              else {\n                if (\n                  instance.wordWrap === WordWrap.CHARACTER ||\n                  instance.wordWrap === WordWrap.WORD\n                ) {\n                  this.setTextAlignment(\n                    currentX,\n                    currentY,\n                    spaceWidth,\n                    maxWidth,\n                    instance.alignment\n                  );\n\n                  // Move position to next line\n                  currentY += instance.lineHeight;\n                  currentX = 0;\n\n                  if (currentY + instance.lineHeight < maxHeight) {\n                    // Put label with in the line\n                    if (currentX + label.getWidth() <= maxWidth) {\n                      label.origin = [originX, originY];\n                      const textAreaAnchor = anchorCalulater[\n                        instance.anchor.type\n                      ](instance);\n\n                      label.anchor = {\n                        padding: 0,\n                        paddingDirection: [\n                          currentX + leftPadding,\n                          currentY + topPadding + offsetY\n                        ],\n                        type: AnchorType.Custom,\n                        x: textAreaAnchor[0],\n                        y: textAreaAnchor[1]\n                      };\n\n                      this.labelsInLine.push(label);\n\n                      currentX += label.getWidth() + spaceWidth;\n\n                      if (\n                        currentX >= maxWidth &&\n                        i + 1 < endi &&\n                        instance.labels[i + 1] !== NewLineCharacterMode.NEWLINE\n                      ) {\n                        this.setTextAlignment(\n                          currentX,\n                          currentY,\n                          spaceWidth,\n                          maxWidth,\n                          instance.alignment\n                        );\n\n                        currentX = 0;\n                        currentY += instance.lineHeight;\n                      }\n                    }\n                    // Put part of label in this line, move other part to following lines\n                    else {\n                      const spaceLeft = maxWidth - currentX;\n                      let index = glyphWidths.length - 1;\n                      const word = label.text;\n\n                      while (glyphWidths[index] > spaceLeft) {\n                        index--;\n                      }\n\n                      if (index >= 0) {\n                        const sizes = this.seperateLabel(\n                          instance,\n                          label,\n                          glyphToOffsetY,\n                          word,\n                          index,\n                          currentX,\n                          currentY,\n                          spaceWidth,\n                          glyphWidths\n                        );\n\n                        currentX = sizes[0];\n                        currentY = sizes[1];\n                      }\n                    }\n                  }\n                  // Exceeds maxHeight\n                  else {\n                    label.active = false;\n                  }\n                }\n                // Word which is supposed to put to next line set false when lineWrap is none\n                else if (instance.wordWrap === WordWrap.NONE) {\n                  label.active = false;\n                }\n              }\n            }\n          }\n        }\n\n        // Exceeds maxHeight\n        else {\n          label.active = false;\n        }\n      }\n\n      // New line\n      else if (label === NewLineCharacterMode.NEWLINE) {\n        this.setTextAlignment(\n          currentX,\n          currentY,\n          spaceWidth,\n          maxWidth,\n          instance.alignment\n        );\n\n        currentX = 0;\n        currentY += instance.lineHeight;\n      }\n    }\n\n    this.setTextAlignment(\n      currentX,\n      currentY,\n      spaceWidth,\n      maxWidth,\n      instance.alignment\n    );\n  }\n\n  /**\n   * This uses calculated kerning information to place the glyph relative to it's left character neighbor.\n   * The first glyph will use metrics of the glyphs drop down amount to determine where the glyph\n   * will be placed.\n   */\n  layout(instance: T) {\n    this.updateKerning(instance);\n    const kerningRequest = this.areaTokerningRequest.get(instance);\n    if (!kerningRequest || !kerningRequest.fontMap) return;\n\n    // Make sure the labels are all rendered\n    const waiting = this.areaWaitingOnLabel.get(instance);\n    if (waiting && waiting.size > 0) return;\n    // Instance must be active\n    if (!instance.active) return;\n    // Glyphs must be established for the label to continue\n    const labels = this.areaToLabels.get(instance);\n    if (!labels || labels.length === 0) return;\n\n    this.updateLabels(instance);\n    this.layoutBorder(instance);\n    this.layoutLabels(instance);\n  }\n\n  /**\n   * Update kerning of textArea Instance, retrieve kerning request from map or create a new one\n   */\n  updateKerning(instance: T) {\n    let labelKerningRequest = this.areaTokerningRequest.get(instance);\n    const checkText = instance.text;\n\n    if (labelKerningRequest) {\n      if (\n        labelKerningRequest.kerningPairs &&\n        labelKerningRequest.kerningPairs.indexOf(checkText) > -1\n      ) {\n        return Boolean(labelKerningRequest.fontMap);\n      }\n\n      if (\n        labelKerningRequest.fontMap &&\n        !labelKerningRequest.fontMap.supportsKerning(checkText)\n      ) {\n        this.areaTokerningRequest.delete(instance);\n        labelKerningRequest = undefined;\n      } else {\n        return false;\n      }\n    } else {\n      const metrics: IFontResourceRequest[\"metrics\"] = {\n        fontSize: instance.fontSize,\n        text: instance.text,\n        letterSpacing: instance.letterSpacing\n      };\n\n      labelKerningRequest = fontRequest({\n        character: \"\",\n        key: this.props.resourceKey || \"\",\n        kerningPairs: [checkText],\n        metrics\n      });\n\n      if (!instance.preload) {\n        this.resource.request(this, instance, labelKerningRequest);\n        this.areaTokerningRequest.set(instance, labelKerningRequest);\n      } else {\n        instance.resourceTrigger = () => {\n          if (instance.onReady) instance.onReady(instance);\n        };\n\n        this.resource.request(this, instance, labelKerningRequest);\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * This layer does not have or use a buffer manager thus it must track management of an instance\n   * in it's own way.\n   */\n  managesInstance(instance: T) {\n    return Boolean(this.areaToLabels.get(instance));\n  }\n\n  /**\n   * This makes a label's glyphs visible by adding them to the glyph layer rendering the glyphs.\n   */\n  showLabels(instance: T) {\n    const labels = this.areaToLabels.get(instance);\n    if (!labels) return;\n\n    for (let i = 0, iMax = labels.length; i < iMax; ++i) {\n      const label = labels[i];\n      if (label instanceof LabelInstance) {\n        this.providers.labels.add(label);\n      }\n    }\n  }\n\n  /**\n   * This ensures the correct number of glyphs is being provided for the label indicated.\n   */\n  updateLabels(instance: T) {\n    let currentLabels = this.areaToLabels.get(instance);\n    const topPadding = instance.padding[0];\n    const leftPadding = instance.padding[3] || 0;\n    const originX = instance.origin[0] + leftPadding;\n    const originY = instance.origin[1] + topPadding;\n\n    if (!currentLabels) {\n      currentLabels = [];\n      this.areaToLabels.set(instance, currentLabels);\n    }\n\n    let waiting = this.areaWaitingOnLabel.get(instance);\n\n    if (!waiting) {\n      waiting = new Set();\n      this.areaWaitingOnLabel.set(instance, waiting);\n    }\n\n    let wordsToLayout = this.areaToWords.get(instance);\n\n    if (!wordsToLayout) {\n      wordsToLayout = generateWords(instance.text);\n    }\n\n    if (currentLabels.length < wordsToLayout.length) {\n      for (\n        let i = currentLabels.length, iMax = wordsToLayout.length;\n        i < iMax;\n        ++i\n      ) {\n        const word = wordsToLayout[i];\n\n        if (word === \"\\n\") {\n          currentLabels.push(NewLineCharacterMode.NEWLINE);\n        } else {\n          const label = new LabelInstance({\n            active: false,\n            color: instance.color,\n            fontSize: instance.fontSize,\n            letterSpacing: instance.letterSpacing,\n            text: word,\n            origin: [originX, originY],\n            onReady: this.handleLabelReady\n          });\n\n          label.parentTextArea = instance;\n          currentLabels.push(label);\n          this.providers.labels.add(label);\n          waiting.add(label);\n        }\n      }\n    }\n\n    instance.labels = currentLabels;\n  }\n\n  /**\n   * Updates the label colors to match the label's label colors\n   */\n  updateLabelColors(instance: T) {\n    const labels = this.areaToLabels.get(instance);\n    if (!labels) return;\n\n    for (let i = 0, iMax = labels.length; i < iMax; ++i) {\n      const label = labels[i];\n      if (label instanceof LabelInstance) {\n        label.color = copy4(instance.color);\n      }\n    }\n\n    for (let i = 0, endi = instance.newLabels.length; i < endi; ++i) {\n      instance.newLabels[i].color = copy4(instance.color);\n    }\n\n    for (let i = 0, endi = instance.borders.length; i < endi; ++i) {\n      instance.borders[i].color = copy4(instance.color);\n    }\n  }\n\n  /**\n   * Updates fontsize of all labels\n   */\n  updateLabelFontSizes(instance: T) {\n    this.clear(instance);\n    this.updateLabels(instance);\n    this.areaTokerningRequest.delete(instance);\n    this.layout(instance);\n  }\n\n  /**\n   * This updates all of the labels for the label to have the same position\n   * as the label.\n   */\n  updateLabelOrigins(instance: T) {\n    const labels = this.areaToLabels.get(instance);\n    if (!labels) return;\n    const origin = instance.origin;\n    const oldOrigin = instance.oldOrigin;\n\n    // Update new origins of all labels\n    for (let i = 0, iMax = labels.length; i < iMax; ++i) {\n      const label = labels[i];\n      if (label instanceof LabelInstance) {\n        const labelOrigin = label.origin;\n        label.origin = [\n          labelOrigin[0] + origin[0] - oldOrigin[0],\n          labelOrigin[1] + origin[1] - oldOrigin[1]\n        ];\n      }\n    }\n\n    // Update new origins of all new labels\n    for (let i = 0, iMax = instance.newLabels.length; i < iMax; ++i) {\n      const label = instance.newLabels[i];\n      if (label instanceof LabelInstance) {\n        const labelOrigin = label.origin;\n        label.origin = [\n          labelOrigin[0] + origin[0] - oldOrigin[0],\n          labelOrigin[1] + origin[1] - oldOrigin[1]\n        ];\n      }\n    }\n\n    // Update all borders new location\n    for (let i = 0, iMax = instance.borders.length; i < iMax; ++i) {\n      const border = instance.borders[i];\n      border.position = [\n        border.position[0] + origin[0] - oldOrigin[0],\n        border.position[1] + origin[1] - oldOrigin[1]\n      ];\n    }\n\n    instance.oldOrigin = instance.origin;\n  }\n\n  /**\n   * If our resource changes, we need a full update of all instances.\n   * If our provider changes, we probably want to ensure our property identifiers are correct.\n   */\n  willUpdateProps(newProps: U) {\n    if (newProps.data !== this.props.data) {\n      delete this.propertyIds;\n    }\n\n    if (newProps.resourceKey !== this.props.resourceKey) {\n      this.fullUpdate = true;\n    }\n  }\n}\n","import { observable } from \"../../../instance-provider\";\nimport { Vec2 } from \"../../../math\";\nimport {\n  IRectangleInstanceOptions,\n  RectangleInstance\n} from \"../rectangle/rectangle-instance\";\n\nexport interface IBorderInstanceOptions extends IRectangleInstanceOptions {\n  /** Sets the fontScale of textArea the border locates */\n  fontScale?: number;\n  /** Sets the textArea's origin where the border is in */\n  textAreaOrigin?: Vec2;\n  /** Set the textArea's anchor where the border is in */\n  textAreaAnchor?: Vec2;\n}\n\nexport class BorderInstance extends RectangleInstance {\n  /** FontScale is used to help the scaling of border in a right amount */\n  @observable fontScale: number = 1;\n  /** TextArea's origin where the border is in */\n  @observable textAreaOrigin: Vec2 = [0, 0];\n  /** TextArea's anchor where the border is in */\n  @observable textAreaAnchor: Vec2 = [0, 0];\n\n  constructor(options: IBorderInstanceOptions) {\n    super(options);\n    this.fontScale = options.fontScale || this.fontScale;\n    this.textAreaOrigin = options.textAreaOrigin || this.textAreaOrigin;\n    this.textAreaAnchor = options.textAreaAnchor || this.textAreaAnchor;\n  }\n}\n","import { InstanceProvider } from \"../../../instance-provider\";\nimport { IAutoEasingMethod, Vec } from \"../../../math\";\nimport {\n  ILayerMaterialOptions,\n  InstanceAttributeSize,\n  IShaderInitialization,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../../types\";\nimport { CommonMaterialOptions } from \"../../../util/common-options\";\nimport { ILayer2DProps, Layer2D } from \"../../view\";\nimport { BorderInstance } from \"./border-instance\";\n\nexport interface IBorderLayerProps<T extends BorderInstance>\n  extends ILayer2DProps<T> {\n  animate?: {\n    color?: IAutoEasingMethod<Vec>;\n    location?: IAutoEasingMethod<Vec>;\n  };\n  atlas?: string;\n  /** Scale factor determining the scale size of the border */\n  scaleFactor?(): number;\n}\n\n/**\n * This layer displays Borders and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class BorderLayer<\n  T extends BorderInstance,\n  U extends IBorderLayerProps<T>\n> extends Layer2D<T, U> {\n  static defaultProps: IBorderLayerProps<BorderInstance> = {\n    key: \"\",\n    data: new InstanceProvider<BorderInstance>()\n  };\n\n  static attributeNames = {\n    anchor: \"anchor\",\n    color: \"color\",\n    depth: \"depth\",\n    fontScale: \"fontScale\",\n    location: \"location\",\n    maxScale: \"maxScale\",\n    scale: \"scale\",\n    scaling: \"scaling\",\n    size: \"size\"\n  };\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<BorderInstance> {\n    const animate = this.props.animate || {};\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: 0,\n      1: 0,\n      2: 0,\n      3: 1,\n      4: 1,\n      5: 1\n    };\n\n    const { scaleFactor = () => 1 } = this.props;\n\n    return {\n      fs: require(\"./border-layer.fs\"),\n      instanceAttributes: [\n        {\n          easing: animate.location,\n          name: BorderLayer.attributeNames.location,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.position\n        },\n        {\n          name: BorderLayer.attributeNames.anchor,\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.anchor.x || 0, o.anchor.y || 0]\n        },\n        {\n          name: BorderLayer.attributeNames.size,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.size\n        },\n        {\n          name: BorderLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        {\n          name: BorderLayer.attributeNames.scaling,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scaling]\n        },\n        {\n          easing: animate.color,\n          name: BorderLayer.attributeNames.color,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.color\n        },\n        {\n          name: BorderLayer.attributeNames.scale,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scale]\n        },\n        {\n          name: BorderLayer.attributeNames.maxScale,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.maxScale]\n        },\n        {\n          name: BorderLayer.attributeNames.fontScale,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.fontScale]\n        },\n        {\n          name: \"textAreaOrigin\",\n          size: InstanceAttributeSize.TWO,\n          update: o => o.textAreaOrigin\n        },\n        {\n          name: \"textAreaAnchor\",\n          size: InstanceAttributeSize.TWO,\n          update: o => o.textAreaAnchor\n        }\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: _u => [scaleFactor()]\n        }\n      ],\n      vertexAttributes: [\n        {\n          name: \"normals\",\n          size: VertexAttributeSize.TWO,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexToSide[vertex]\n          ]\n        }\n      ],\n      vertexCount: 6,\n      vs: require(\"./border-layer.vs\")\n    };\n  }\n\n  getMaterialOptions(): ILayerMaterialOptions {\n    return CommonMaterialOptions.transparentShapeBlending;\n  }\n}\n","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvoid main() {\\ngl_FragColor = vertexColor;\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvoid main() {\\nfloat borderScale = mix(fontScale, 1.0, float(scaling == 3.0));\\nvec3 screenSize = cameraSpaceSize(vec3(size * scale * borderScale / scaleFactor / maxScale, 1.0));\\nbool largerOnScreen = screenSize.y > size.y || screenSize.x > size.x;\\nfloat useScaleMode = float(\\n(\\nscaling == 3.0 ||\\n(largerOnScreen && scaling == 2.0)\\n) &&\\nscaling != 1.0\\n);\\nfloat unequalZooms = float(cameraScale2D.x != cameraScale2D.y);\\nvec2 adjustedSize = mix(\\nsize,\\n(size * cameraScale2D.yx),\\nunequalZooms\\n);\\nfloat normal = normals.x;\\nfloat side = normals.y;\\nvec2 scaledAnchor = anchor * scale;\\nvec2 worldAnchor = location + scaledAnchor;\\nvec2 adjustedAnchor = mix(\\nscaledAnchor,\\n(scaledAnchor * cameraScale2D.yx),\\nunequalZooms\\n);\\nvec2 vertex = vec2(side, float(normal == 1.0)) * scale * adjustedSize + location - adjustedAnchor;\\nfloat labelScreenScale = mix(\\nscreenSize.y / adjustedSize.y,\\nscreenSize.x / adjustedSize.x,\\nfloat((cameraScale2D.x != 1.0))\\n);\\nfloat currentScale = labelScreenScale * scale;\\nvec2 anchorToVertex = vertex - location;\\nvertex = mix(\\nvertex + textAreaOrigin,\\n(anchorToVertex + location - textAreaAnchor) / labelScreenScale + textAreaOrigin + textAreaAnchor,\\nuseScaleMode\\n);\\nvertexColor = color;\\ngl_Position = clipSpace(vec3(vertex, depth));\\n}\"","export * from \"./rectangle-layer\";\nexport * from \"./rectangle-instance\";\n","import { InstanceProvider } from \"../../../instance-provider\";\nimport { IAutoEasingMethod, Vec } from \"../../../math\";\nimport {\n  ILayerMaterialOptions,\n  InstanceAttributeSize,\n  IShaderInitialization,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../../types\";\nimport { CommonMaterialOptions } from \"../../../util\";\nimport { ILayer2DProps, Layer2D } from \"../../view/layer-2d\";\nimport { RectangleInstance } from \"./rectangle-instance\";\n\nexport interface IRectangleLayerProps<T extends RectangleInstance>\n  extends ILayer2DProps<T> {\n  animate?: {\n    color?: IAutoEasingMethod<Vec>;\n    location?: IAutoEasingMethod<Vec>;\n  };\n  /** Scale factor determining the scale size of the rectangle */\n  scaleFactor?(): number;\n}\n\n/**\n * This layer displays Rectangles and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class RectangleLayer<\n  T extends RectangleInstance,\n  U extends IRectangleLayerProps<T>\n> extends Layer2D<T, U> {\n  static defaultProps: IRectangleLayerProps<RectangleInstance> = {\n    key: \"\",\n    data: new InstanceProvider<RectangleInstance>()\n  };\n\n  static attributeNames = {\n    anchor: \"anchor\",\n    color: \"color\",\n    depth: \"depth\",\n    location: \"location\",\n    maxScale: \"maxScale\",\n    scale: \"scale\",\n    scaling: \"scaling\",\n    size: \"size\"\n  };\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<RectangleInstance> {\n    const animate = this.props.animate || {};\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: 0,\n      1: 0,\n      2: 0,\n      3: 1,\n      4: 1,\n      5: 1\n    };\n\n    const { scaleFactor = () => 1 } = this.props;\n\n    return {\n      fs: require(\"./rectangle-layer.fs\"),\n      instanceAttributes: [\n        {\n          easing: animate.location,\n          name: RectangleLayer.attributeNames.location,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.position\n        },\n        {\n          name: RectangleLayer.attributeNames.anchor,\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.anchor.x || 0, o.anchor.y || 0]\n        },\n        {\n          name: RectangleLayer.attributeNames.size,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.size\n        },\n        {\n          name: RectangleLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        {\n          name: RectangleLayer.attributeNames.scaling,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scaling]\n        },\n        {\n          easing: animate.color,\n          name: RectangleLayer.attributeNames.color,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.color\n        },\n        {\n          name: RectangleLayer.attributeNames.scale,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scale]\n        },\n        {\n          name: RectangleLayer.attributeNames.maxScale,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.maxScale]\n        }\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: _u => [scaleFactor()]\n        }\n      ],\n      vertexAttributes: [\n        {\n          name: \"normals\",\n          size: VertexAttributeSize.TWO,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexToSide[vertex]\n          ]\n        }\n      ],\n      vertexCount: 6,\n      vs: require(\"./rectangle-layer.vs\")\n    };\n  }\n\n  getMaterialOptions(): ILayerMaterialOptions {\n    return CommonMaterialOptions.transparentShapeBlending;\n  }\n}\n","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvoid main() {\\ngl_FragColor = vertexColor;\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvoid main() {\\nvec3 screenSize = cameraSpaceSize(vec3(size * scale / scaleFactor / maxScale, 1.0));\\nbool largerOnScreen = screenSize.y > size.y || screenSize.x > size.x;\\nfloat useScaleMode = float(\\n(\\nscaling == 3.0 ||\\n(largerOnScreen && scaling == 2.0)\\n) &&\\nscaling != 1.0\\n);\\nfloat unequalZooms = float(cameraScale2D.x != cameraScale2D.y);\\nvec2 adjustedSize = mix(\\nsize,\\n(size * cameraScale2D.yx),\\nunequalZooms\\n);\\nfloat normal = normals.x;\\nfloat side = normals.y;\\nvec2 scaledAnchor = anchor * scale;\\nvec2 worldAnchor = location + scaledAnchor;\\nvec2 adjustedAnchor = mix(\\nscaledAnchor,\\n(scaledAnchor * cameraScale2D.yx),\\nunequalZooms\\n);\\nvec2 vertex = vec2(side, float(normal == 1.0)) * scale * adjustedSize + location - adjustedAnchor;\\nfloat labelScreenScale = mix(\\nscreenSize.y / adjustedSize.y,\\nscreenSize.x / adjustedSize.x,\\nfloat((cameraScale2D.x != 1.0))\\n);\\nfloat currentScale = labelScreenScale * scale;\\nvec2 anchorToVertex = vertex - location;\\nvertex = mix(\\nvertex,\\n(anchorToVertex / labelScreenScale) + location,\\nuseScaleMode\\n);\\nvertexColor = color;\\ngl_Position = clipSpace(vec3(vertex, depth));\\n}\"","export * from \"./ring-instance\";\nexport * from \"./ring-layer\";\n","import {\n  IInstanceOptions,\n  Instance\n} from \"../../../instance-provider/instance\";\nimport { observable } from \"../../../instance-provider/observable\";\nimport { Vec2 } from \"../../../math\";\n\nexport interface IRingInstanceOptions extends IInstanceOptions {\n  /** The center of the ring */\n  center?: Vec2;\n  /** The color of this ring */\n  color?: [number, number, number, number];\n  /** The z depth of the ring (for draw ordering) */\n  depth?: number;\n  /** The outer radius of the ring */\n  radius?: number;\n  /** The thickness of the ring */\n  thickness?: number;\n}\n\nexport class RingInstance extends Instance {\n  @observable color: [number, number, number, number] = [1.0, 1.0, 1.0, 1.0];\n  @observable depth: number = 0;\n  @observable radius: number = 0;\n  @observable thickness: number = 1;\n  @observable center: Vec2 = [0, 0];\n\n  constructor(options: IRingInstanceOptions) {\n    super(options);\n\n    this.color = options.color || this.color;\n    this.depth = options.depth || this.depth;\n    this.radius = options.radius || this.radius;\n    this.thickness = options.thickness || this.thickness;\n    this.center = options.center || this.center;\n  }\n\n  get width() {\n    return this.radius * 2;\n  }\n\n  get height() {\n    return this.radius * 2;\n  }\n\n  get innerRadius() {\n    return this.radius - this.thickness;\n  }\n}\n","import { InstanceProvider } from \"../../../instance-provider\";\nimport { IAutoEasingMethod, Vec } from \"../../../math\";\nimport {\n  ILayerMaterialOptions,\n  InstanceAttributeSize,\n  IShaderInitialization,\n  IUniform,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../../types\";\nimport { CommonMaterialOptions } from \"../../../util\";\nimport { ILayer2DProps, Layer2D } from \"../../view/layer-2d\";\nimport { RingInstance } from \"./ring-instance\";\n\nexport interface IRingLayerProps<T extends RingInstance>\n  extends ILayer2DProps<T> {\n  /** This sets a scaling factor for the circle's radius */\n  scaleFactor?(): number;\n  animate?: {\n    color?: IAutoEasingMethod<Vec>;\n    center?: IAutoEasingMethod<Vec>;\n    radius?: IAutoEasingMethod<Vec>;\n  };\n}\n\n/**\n * This layer displays circles and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class RingLayer<\n  T extends RingInstance,\n  U extends IRingLayerProps<T>\n> extends Layer2D<T, U> {\n  static defaultProps: IRingLayerProps<RingInstance> = {\n    key: \"\",\n    data: new InstanceProvider<RingInstance>()\n  };\n\n  static attributeNames = {\n    center: \"center\",\n    radius: \"radius\",\n    depth: \"depth\",\n    color: \"color\",\n    thickness: \"thickness\"\n  };\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<RingInstance> {\n    const scaleFactor = this.props.scaleFactor || (() => 1);\n    const animations = this.props.animate || {};\n    const {\n      color: animateColor,\n      center: animateCenter,\n      radius: animateRadius\n    } = animations;\n\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: -1,\n      1: -1,\n      2: -1,\n      3: 1,\n      4: 1,\n      5: 1\n    };\n\n    return {\n      fs: require(\"./ring-layer.fs\"),\n      instanceAttributes: [\n        {\n          easing: animateCenter,\n          name: RingLayer.attributeNames.center,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.center\n        },\n        {\n          easing: animateRadius,\n          name: RingLayer.attributeNames.radius,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.radius]\n        },\n        {\n          name: RingLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        {\n          easing: animateColor,\n          name: RingLayer.attributeNames.color,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.color\n        },\n        {\n          name: RingLayer.attributeNames.thickness,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.thickness]\n        }\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: (_: IUniform) => [scaleFactor()]\n        }\n      ],\n      vertexAttributes: [\n        {\n          name: \"normals\",\n          size: VertexAttributeSize.TWO,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexToSide[vertex]\n          ]\n        }\n      ],\n      vertexCount: 6,\n      vs: require(\"./ring-layer.vs\")\n    };\n  }\n\n  getMaterialOptions(): ILayerMaterialOptions {\n    return CommonMaterialOptions.transparentShapeBlending;\n  }\n}\n","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvarying float edgeSharpness;\\nvarying float borderSize;\\nvarying vec2 pointCoord;\\nvarying float scale;\\nfloat circle(vec2 coord, float radius){\\nvec2 dist = coord - vec2(0.5);\\nreturn 1.0 - smoothstep(\\nradius - (radius * edgeSharpness),\\nradius,\\ndot(dist, dist) * 4.0\\n);\\n}\\nvoid main() {\\nfloat outer_step_factor = circle(pointCoord, 1.0);\\nfloat inner_step_factor = circle(pointCoord, 1.0 - borderSize * scale);\\ngl_FragColor = mix(\\nmix(\\nvec4(0.0, 0.0, 0.0, 0.0),\\nvertexColor,\\nouter_step_factor\\n),\\nvec4(0.0, 0.0, 0.0, 0.0),\\ninner_step_factor\\n);\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvarying float edgeSharpness;\\nvarying float borderSize;\\nvarying vec2 pointCoord;\\nvarying float scale;\\nvoid main() {\\nscale = scaleFactor;\\nvertexColor = color;\\nfloat size = radius * scaleFactor * pixelRatio;\\nfloat ringWidth = mix(2.0 , thickness, float(thickness > 2.0));\\nborderSize = mix(\\n(ringWidth) / size,\\n((ringWidth * pixelRatio) / size),\\nfloat(pixelRatio > 1.0)\\n);\\nedgeSharpness = min(0.2 / (ringWidth * scale), 0.1);\\npointCoord = (normals.xy + vec2(1.0, 1.0)) / 2.0;\\nvec4 clipCenter = clipSpace(vec3(center, depth));\\nvec2 screenCenter = (clipCenter.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\nvec2 vertex = (normals.xy * size) + screenCenter;\\ngl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), clipCenter.zw);\\n}\"","import \"./shader-modules\";\n\nexport * from \"./view\";\nexport * from \"./scene-graph\";\nexport * from \"./layers\";\n","import \"./world-2d-xy.shader\";\nimport \"./world-2d-xz.shader\";\nimport \"./world-2d-yz.shader\";\n","import { Control2D } from \"../../2d\";\nimport { Layer2D } from \"../../2d/view/layer-2d\";\nimport { ShaderModule } from \"../../shaders\";\nimport { Layer } from \"../../surface/layer\";\nimport { ShaderInjectionTarget, UniformSize } from \"../../types\";\n\nconst doc = `\nThis is a special helper module used by\nthe system to map View2D content into\na 3D world space. The system utilizes\nthis module automatically for you when\nyou utilize createLayer2Din3D.\n`;\n\n/**\n * This module changes the projections for Layer2D style layers to map [x, y] -> [x, z]\n */\nShaderModule.register([\n  {\n    moduleId: \"world2DXY\",\n    description: doc,\n    content: require(\"../../2d/shader-modules/shader-fragments/world-2d-projection.vs\"),\n    compatibility: ShaderInjectionTarget.ALL,\n    uniforms: (layer: Layer<any, any>) => {\n      if (!(layer instanceof Layer2D)) {\n        console.warn(\n          \"A shader requested the module world2DXZ; however, the layer the shader comes from is NOT a Layer2D which is\",\n          \"required for the module to work.\"\n        );\n        return [];\n      }\n\n      if (!layer.props.control2D) {\n        console.warn(\n          \"For a layer 2D to be compatible with a 3D View, the layer requires an additional prop of control2D\"\n        );\n        return [];\n      }\n\n      return [\n        // This injects the projection matrix from the view camera\n        {\n          name: \"projection\",\n          size: UniformSize.MATRIX4,\n          update: () => layer.view.props.camera.projection\n        },\n        // This injects the model view matrix from the view camera\n        {\n          name: \"view\",\n          size: UniformSize.MATRIX4,\n          update: () => layer.view.props.camera.view\n        },\n        // This injects a 2D camera's offset\n        {\n          name: \"cameraOffset\",\n          size: UniformSize.THREE,\n          update: () =>\n            layer.props.control2D instanceof Control2D\n              ? layer.props.control2D.offset\n              : [0, 0, 0]\n        },\n        // This injects the camera's current position\n        {\n          name: \"cameraPosition\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.position\n        },\n        // This injects the camera's current scale\n        {\n          name: \"cameraScale\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.scale\n        },\n        // This injects the camera's 2D current scale\n        {\n          name: \"cameraScale2D\",\n          size: UniformSize.THREE,\n          update: () =>\n            layer.props.control2D instanceof Control2D\n              ? layer.props.control2D.scale\n              : [1, 1, 1]\n        },\n        // This injects the camera's Euler rotation\n        {\n          name: \"cameraRotation\",\n          size: UniformSize.FOUR,\n          update: () => layer.view.props.camera.transform.rotation\n        },\n        // This injects the pixel width and height of the view\n        {\n          name: \"viewSize\",\n          size: UniformSize.TWO,\n          update: () => [\n            layer.view.viewBounds.width,\n            layer.view.viewBounds.height\n          ]\n        },\n        // This injects the current layer's pixel ratio so pixel ratio dependent items can react to it\n        // Things like gl_PointSize will need this metric if not working in clip space\n        {\n          name: \"pixelRatio\",\n          size: UniformSize.ONE,\n          update: () => [layer.view.pixelRatio]\n        }\n      ];\n    }\n  }\n]);\n","import \"./camera-metrics.shader\";\nimport \"./frame-metrics.shader\";\nimport \"./hsv.shader\";\nimport \"./instancing.shader\";\nimport \"./math.shader\";\nimport \"./matrix.shader\";\nimport \"./pack-float\";\nimport \"./picking.shader\";\nimport \"./util.shader\";\n","import { Layer } from \"../../surface/layer\";\nimport { ShaderInjectionTarget, UniformSize } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\nconst doc = `\nThese are properties injected from the\ncurrent camera applied to the view.\n\nConstants:\nmat4 projection;\nmat4 view;\nmat4 viewProjection;\nvec3 cameraOffset;\nvec3 cameraPosition;\nvec3 cameraScale;\nvec3 cameraRotation;\nvec2 viewSize;\nfloat pixelRatio;\n`;\n\n/**\n * This module provides uniforms for retrieving camera propeerties within the shader.\n */\nShaderModule.register([\n  {\n    moduleId: \"camera\",\n    description: doc,\n    // No explicit functional content is required, we will only use the uniforms for injecting information for this\n    // module.\n    content: \"\",\n    compatibility: ShaderInjectionTarget.ALL,\n    uniforms: (layer: Layer<any, any>) => [\n      // This injects the projection matrix from the view camera\n      {\n        name: \"projection\",\n        size: UniformSize.MATRIX4,\n        update: () => layer.view.props.camera.projection\n      },\n      {\n        name: \"viewProjection\",\n        size: UniformSize.MATRIX4,\n        update: () => layer.view.props.camera.viewProjection\n      },\n      // This injects the model view matrix from the view camera\n      {\n        name: \"view\",\n        size: UniformSize.MATRIX4,\n        update: () => layer.view.props.camera.view\n      },\n      // This injects the camera's current position\n      {\n        name: \"cameraPosition\",\n        size: UniformSize.THREE,\n        update: () => layer.view.props.camera.position\n      },\n      // This injects the camera's current scale\n      {\n        name: \"cameraScale\",\n        size: UniformSize.THREE,\n        update: () => layer.view.props.camera.scale\n      },\n      // This injects the camera's Euler rotation\n      {\n        name: \"cameraRotation\",\n        size: UniformSize.THREE,\n        update: () => layer.view.props.camera.scale\n      },\n      // This injects the pixel width and height of the view\n      {\n        shaderInjection: ShaderInjectionTarget.ALL,\n        name: \"viewSize\",\n        size: UniformSize.TWO,\n        update: () => [\n          layer.view.viewBounds.width,\n          layer.view.viewBounds.height\n        ]\n      },\n      // This injects the current layer's pixel ratio so pixel ratio dependent items can react to it\n      // Things like gl_PointSize will need this metric if not working in clip space\n      {\n        shaderInjection: ShaderInjectionTarget.ALL,\n        name: \"pixelRatio\",\n        size: UniformSize.ONE,\n        update: () => [layer.view.pixelRatio]\n      }\n    ]\n  },\n  {\n    moduleId: \"projection\",\n    content: require(\"./shader-fragments/projection.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  }\n]);\n","module.exports = \"${import: camera}\\nvec3 cameraSpace(vec3 world) {\\nreturn (view * vec4(world, 1.0)).xyz;\\n}\\nvec3 cameraSpace(vec4 world) {\\nreturn (view * world).xyz;\\n}\\nvec3 cameraSpaceDirection(vec3 world) {\\nreturn (view * vec4(world, 0.0)).xyz;\\n}\\nvec3 cameraSpaceDirection(vec4 world) {\\nreturn (view * world).xyz;\\n}\\nvec3 cameraSpaceSize(vec3 worldSize) {\\nreturn (view * vec4(worldSize, 0.0)).xyz;\\n}\\nvec4 clipSpace(vec3 world) {\\nreturn (viewProjection) * vec4(world, 1.0);\\n}\\nvec4 clipSpace(vec4 world) {\\nreturn (viewProjection) * world;\\n}\\nvec4 clipSpaceDirection(vec3 worldSize) {\\nreturn (viewProjection) * vec4(worldSize, 0.0);\\n}\\nvec4 clipSpaceDirection(vec4 worldSize) {\\nreturn (viewProjection) * worldSize;\\n}\\nvec4 clipSpaceSize(vec3 worldSize) {\\nreturn (viewProjection) * vec4(worldSize, 0.0);\\n}\"","import { Layer } from \"../../surface/layer\";\nimport { ShaderInjectionTarget, UniformSize } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\nconst doc = `\nThis provides frame timing information\nor how many frames have been rendered.\n\nConstants:\nfloat currentTime;\nfloat currentFrame;\n`;\n\n/**\n * This module provides uniforms for retrieving camera propeerties within the shader.\n */\nShaderModule.register({\n  moduleId: \"frame\",\n  description: doc,\n  content: \"\",\n  compatibility: ShaderInjectionTarget.ALL,\n  uniforms: (layer: Layer<any, any>) => [\n    // This will be the current frame's current time which is updated in the layer's surface draw call\n    {\n      name: \"currentTime\",\n      size: UniformSize.ONE,\n      update: () => [layer.surface.frameMetrics.currentTime]\n    },\n    {\n      name: \"currentFrame\",\n      size: UniformSize.ONE,\n      update: () => [layer.surface.frameMetrics.currentFrame]\n    }\n  ]\n});\n","import { ShaderInjectionTarget } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\nconst doc = `\nProvides methods that converts colors to\nHSV values and back. This makes it\neasier to deal with hue saturation and\nlightness levels.\n\nMethods:\nvec3 rgb2hsv(vec3 c);\nvec3 hsv2rgb(vec3 c);\n`;\n\n/**\n * This module provides uniforms for retrieving camera propeerties within the shader.\n */\nShaderModule.register({\n  moduleId: \"hsv\",\n  description: doc,\n  content: require(\"./shader-fragments/hsv.vs\"),\n  compatibility: ShaderInjectionTarget.ALL\n});\n","module.exports = \"vec3 rgb2hsv(vec3 c) {\\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\nvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\nvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\nfloat d = q.x - min(q.w, q.y);\\nfloat e = 1.0e-10;\\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\\nvec3 hsv2rgb(vec3 c) {\\nvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\"","import { Instance } from \"../../instance-provider/instance\";\nimport {\n  IInstanceAttribute,\n  InstanceAttributeSize,\n  LayerBufferType,\n  ShaderInjectionTarget,\n  VertexAttributeSize\n} from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\nconst doc = `\nThis is an internal shader module that\nhelps establish the instancing system.\nNot recommended for use unless you\nreally know how to utilize it properly.\n\nAttributes:\nfloat _active;\nfloat instance;\n`;\n\n/**\n * This module contains the basic needs required to facilitate instancing for our shaders\n */\nShaderModule.register({\n  moduleId: \"instancing\",\n  description: doc,\n  content: \"\",\n  compatibility: ShaderInjectionTarget.ALL,\n\n  instanceAttributes: layer => {\n    // This is injected so the system can control when an instance should not be rendered.\n    // This allows for holes to be in the buffer without having to correct them immediately\n    const activeAttribute: IInstanceAttribute<Instance> = {\n      name: \"_active\",\n      size: InstanceAttributeSize.ONE,\n      update: o => [o.active ? 1 : 0]\n    };\n\n    // Set the active attribute to the layer for quick reference\n    layer.shaderIOInfo.activeAttribute = activeAttribute;\n\n    return [activeAttribute];\n  },\n\n  vertexAttributes: layer => {\n    // Only the uniform buffering strategy requires instance information in it's vertex attributes\n    if (layer.bufferType === LayerBufferType.UNIFORM) {\n      return [\n        // We add an inherent instance attribute to our vertices so they can determine the instancing\n        // Data to retrieve.\n        {\n          name: \"instance\",\n          size: VertexAttributeSize.ONE,\n          // We no op this as our geometry generating routine will establish the values needed here\n          update: () => [0]\n        }\n      ];\n    }\n\n    return [];\n  }\n});\n","import { ShaderInjectionTarget } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\n// All of the constants fragments\nconst constants = [\n  {\n    moduleId: \"PI_INV\",\n    description: \"Provides: float PI_INV = 1.0 / pi\",\n    content: require(\"./shader-fragments/constants/pi_inv.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"PI2_INV\",\n    description: \"Provides:\\nfloat PI2_INV = 1.0 / (pi * 2.0)\",\n    content: require(\"./shader-fragments/constants/pi2_inv.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"PI_2\",\n    description: \"Provides: float PI_2 = pi / 2.0\",\n    content: require(\"./shader-fragments/constants/pi_2.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"PI_4\",\n    description: \"Provides: float PI_4 = pi / 4.0\",\n    content: require(\"./shader-fragments/constants/pi_4.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"PI\",\n    description: \"Provides: float PI = pi\",\n    content: require(\"./shader-fragments/constants/pi.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"PI2\",\n    description: \"Provides: float PI2 = pi * 2.0\",\n    content: require(\"./shader-fragments/constants/pi2.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"toDegrees\",\n    description:\n      \"Provides: float toDegrees;\\nCan be used to convert radians to degrees:\\nradians * toDegrees\",\n    content: require(\"./shader-fragments/constants/to-degrees.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"toRadians\",\n    description:\n      \"Provides: float toRadians;\\nCan be used to convert degrees to radians:\\ndegress * toRadians\",\n    content: require(\"./shader-fragments/constants/to-radians.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  }\n];\n\nconst doc = `\nProvides all the math constants you may\nneed as convenience. It's probably\nbetter to include them individually, but\nconvenience sometimes beats practicality\n\nConstants:\n${constants.map(c => c.moduleId).join(\"\\n\")}\n`;\n\n// A bin import that let's you add all common constants to your shader\nconst allConstants = {\n  moduleId: \"constants\",\n  description: doc,\n  content: `$\\{import: ${constants.map(c => c.moduleId).join(\", \")}}`,\n  compatibility: ShaderInjectionTarget.ALL\n};\n\n// All of the mathematical methods\nconst methods = [\n  {\n    moduleId: \"bezier1\",\n    description:\n      \"Provides the 2D single control\\npoint bezier method:\\nvec2 bezier1(float t, vec2 p1, vec2 p2, vec2 c1)\",\n    content: require(\"./shader-fragments/bezier1.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"bezier2\",\n    description:\n      \"Provides the 2D single control\\npoint bezier method:\\nvec2 bezier2(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2)\",\n    content: require(\"./shader-fragments/bezier2.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"arc\",\n    description:\n      \"Provides the 2D\\narc interpolation method:\\nvec2 arc(float t,\\n\\tvec2 center,\\n\\tfloat radius,\\n\\tfloat start,\\n\\tfloat end\\n)\",\n    content: require(\"./shader-fragments/arc.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"fmod\",\n    description:\n      \"Provides the floating point\\nmodulus method:\\nfloat fmod(float x, float m, float m_inv)\",\n    content: require(\"./shader-fragments/fmod.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"wrap\",\n    description:\n      \"Provides a method that wraps\\nvalue overflows:\\nfloat wrap(float value, float start, float end)\",\n    content: require(\"./shader-fragments/wrap.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"fcos\",\n    description:\n      \"Provides a fcos method that also\\nhas a higher precision than\\nsome hardware cos implementations:\\nfloat fcos(float x)\",\n    content: require(\"./shader-fragments/fcos.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"fsin\",\n    description:\n      \"Provides a fsin method that also\\nhas a higher precision than\\nsome hardware sin implementations:\\nfloat fsin(float x)\",\n    content: require(\"./shader-fragments/fsin.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  }\n];\n\n// Register all modules\nShaderModule.register([...methods, ...constants, allConstants]);\n","module.exports = \"float PI_INV = 0.3183098862;\"","module.exports = \"float PI2_INV = 0.1591549431;\"","module.exports = \"float PI_2 = 1.5707963268;\"","module.exports = \"float PI_4 = 0.7853981634;\"","module.exports = \"float PI = 3.14159265;\"","module.exports = \"float PI2 = 6.2831853;\"","module.exports = \"float toDegrees = 57.2957795131;\"","module.exports = \"float toRadians = 0.01745329252;\"","module.exports = \"vec2 bezier1(float t, vec2 p1, vec2 p2, vec2 c1) {\\nreturn (1.0 - t) * (1.0 - t) * p1 + 2.0 * t * (1.0 - t) * c1 + t * t * p2;\\n}\"","module.exports = \"vec2 bezier2(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {\\nfloat t1 = 1.0 - t;\\nreturn pow(t1, 3.0) * p1 + 3.0 * t * pow(t1, 2.0) * c1 + 3.0 * pow(t, 2.0) * t1 * c2 + pow(t, 3.0) * p2;\\n}\"","module.exports = \"${import: PI, PI2, fsin, fcos, wrap}\\nvec2 arc(float t, vec2 center, float radius, float start, float end) {\\nfloat angle = wrap((end - start) * t + start, 0.0, PI2);\\nreturn center + vec2(fcos(angle), fsin(angle)) * radius;\\n}\"","module.exports = \"float fmod(float x, float m, float m_inv) {\\nreturn x - m * floor(x * m_inv);\\n}\"","module.exports = \"float wrap(float value, float start, float end) {\\nfloat width = end - start;\\nfloat offsetValue = value - start;\\nreturn (offsetValue - (floor(offsetValue / width) * width)) + start;\\n}\"","module.exports = \"${import: PI, PI2, PI_2}\\nfloat fcos(float x) {\\nfloat sine;\\nx += PI_2;\\nx += mix(\\nmix(\\n0.0,\\n-PI2, float(x > PI)\\n),\\nPI2, float(x < -PI)\\n);\\nsine = 1.27323954 * x;\\nsine += mix(-1.0, 1.0, float(x < 0.0)) * 0.405284735 * x * x;\\nsine = 0.225 * (sine * (mix(1.0, -1.0, float(sine < 0.0)) * sine) - sine) + sine;\\nreturn sine;\\n}\"","module.exports = \"${import: PI, PI2}\\nfloat fsin(float x) {\\nfloat sine;\\nx += mix(\\nmix(\\n0.0,\\n-PI2, float(x > PI)\\n),\\nPI2, float(x < -PI)\\n);\\nsine = 1.27323954 * x;\\nsine += mix(-1.0, 1.0, float(x < 0.0)) * 0.405284735 * x * x;\\nsine = 0.225 * (sine * (mix(1.0, -1.0, float(sine < 0.0)) * sine) - sine) + sine;\\nreturn sine;\\n}\"","import { ShaderInjectionTarget } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\nShaderModule.register([\n  {\n    moduleId: \"translation\",\n    description:\n      \"Generates a translation matrix\\nfrom a vec3:\\nmat4 transform(vec3 s, vec4 r, vec3 t)\",\n    compatibility: ShaderInjectionTarget.ALL,\n    content: require(\"./shader-fragments/matrix/translation.vs\")\n  },\n  {\n    moduleId: \"rotation\",\n    description:\n      \"Generates a rotation matrix\\nfrom a quaternion:\\nmat4 rotationFromQuaternion(vec4 q)\",\n    compatibility: ShaderInjectionTarget.ALL,\n    content: require(\"./shader-fragments/matrix/rotation.vs\")\n  },\n  {\n    moduleId: \"scale\",\n    description: \"Generates a scale matrix\\nfrom a vec3:\\nmat4 scale(vec3 s)\",\n    compatibility: ShaderInjectionTarget.ALL,\n    content: require(\"./shader-fragments/matrix/scale.vs\")\n  },\n  {\n    moduleId: \"transform\",\n    description:\n      \"Generates a full transform matrix\\nfrom a scale, quaternion, translation:\\nmat4 transform(vec3 s, vec4 r, vec3 t)\",\n    compatibility: ShaderInjectionTarget.ALL,\n    content: require(\"./shader-fragments/matrix/transform.vs\")\n  }\n]);\n","module.exports = \"mat4 translation(vec3 t) {\\nreturn mat4(\\n1, 0, 0, 0,\\n0, 1, 0, 0,\\n0, 0, 1, 0,\\nt.x, t.y, t.z, 1\\n);\\n}\"","module.exports = \"mat4 rotationFromQuaternion(vec4 q) {\\nfloat x2 = q.y + q.y;\\nfloat y2 = q.z + q.z;\\nfloat z2 = q.w + q.w;\\nfloat xx = q.y * x2;\\nfloat xy = q.y * y2;\\nfloat xz = q.y * z2;\\nfloat yy = q.z * y2;\\nfloat yz = q.z * z2;\\nfloat zz = q.w * z2;\\nfloat wx = q.x * x2;\\nfloat wy = q.x * y2;\\nfloat wz = q.x * z2;\\nreturn mat4(\\n1.0 - (yy + zz), xy - wz, xz + wy, 0.0,\\nxy + wz, 1.0 - (xx + zz), yz - wx, 0.0,\\nxz - wy, yz + wx, 1.0 - (xx + yy), 0.0,\\n0, 0, 0, 1\\n);\\n}\"","module.exports = \"mat4 scale(vec3 s) {\\nreturn mat4(\\ns.x, 0, 0, 0,\\n0, s.y, 0, 0,\\n0, 0, s.z, 0,\\n0, 0, 0, 1\\n);\\n}\"","module.exports = \"${import: translation, rotation, scale}\\nmat4 transform(vec3 s, vec4 r, vec3 t) {\\nreturn translation(t) * rotationFromQuaternion(r) * scale(s);\\n}\"","import { ShaderInjectionTarget } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\nconst doc = `\nThis provides the ability to pack\na float value into a color RGBA\nvalue. This is used to bypass the\nlack of support for float textures.\n\nConstants:\nfloat currentTime;\nfloat currentFrame;\n`;\n\n/**\n * This module provides uniforms for retrieving camera propeerties within the shader.\n */\nShaderModule.register({\n  moduleId: \"packFloat\",\n  description: doc,\n  content: require(\"./shader-fragments/pack-float.vs\"),\n  compatibility: ShaderInjectionTarget.ALL\n});\n","module.exports = \"vec4 bitSh = vec4(16777216., 65536., 256., 1.);\\nvec4 bitMsk = vec4(0., vec3(1. / 256.0));\\nvec4 bitShifts = vec4(1.) / vec4(16777216., 65536., 256., 1.);\\nvec4 packFloat(float value, float range) {\\nvalue = (value + range) / (range * 2.);\\nvec4 comp = fract(value * bitSh);\\ncomp -= comp.xxyz * bitMsk;\\nreturn comp;\\n}\\nfloat unpackFloat(vec4 color, float range) {\\nreturn dot(color , bitShifts) * (range * 2.) - range;\\n}\"","import { Layer } from \"../../surface/layer\";\nimport { InstanceAttributeSize, ShaderInjectionTarget } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\nShaderModule.register([\n  {\n    moduleId: \"picking\",\n    description:\n      \"Internal use only. Provides methods\\nand constants to make the picking processes work.\",\n    content: require(\"./shader-fragments/picking.vs\"),\n    compatibility: ShaderInjectionTarget.VERTEX,\n\n    instanceAttributes: (_layer: Layer<any, any>) => [\n      {\n        name: \"_pickingColor\",\n        size: InstanceAttributeSize.FOUR,\n        update: o => {\n          // We start from white and move down so the colors are more visible\n          // For debugging\n          const color = 0xffffff - o.uid;\n\n          // Do bit maths to get float components out of the int color\n          return [\n            ((color & 0xff0000) >> 16) / 255.0,\n            ((color & 0x00ff00) >> 8) / 255.0,\n            (color & 0x0000ff) / 255.0,\n            1\n          ];\n        }\n      }\n    ]\n  }\n]);\n","module.exports = \"varying highp vec4 _picking_color_pass_;\"","import { ShaderInjectionTarget } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\nconst doc = `\nMakes a no-op shader where gl_Position\nis [0, 0, 0, 0] and gl_FragColor is\n[0, 0, 0, 0].\n\nYou can not import this if you specify\nyour own main() method.\n`;\n\nShaderModule.register([\n  {\n    moduleId: \"no-op\",\n    description: doc,\n    content: require(\"./shader-fragments/no-op.vs\"),\n    compatibility: ShaderInjectionTarget.VERTEX\n  },\n  {\n    moduleId: \"no-op\",\n    description: doc,\n    content: require(\"./shader-fragments/no-op.fs\"),\n    compatibility: ShaderInjectionTarget.FRAGMENT\n  }\n]);\n","module.exports = \"void main() {\\ngl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n}\"","module.exports = \"void main() {\\ngl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\\n}\"","import { Control2D } from \"../../2d\";\nimport { Layer2D } from \"../../2d/view/layer-2d\";\nimport { ShaderModule } from \"../../shaders\";\nimport { Layer } from \"../../surface/layer\";\nimport { ShaderInjectionTarget, UniformSize } from \"../../types\";\n\nconst doc = `\nThis is a special helper module used by\nthe system to map View2D content into\na 3D world space. The system utilizes\nthis module automatically for you when\nyou utilize createLayer2Din3D.\n`;\n\n/**\n * This module changes the projections for Layer2D style layers to map [x, y] -> [x, z]\n */\nShaderModule.register([\n  {\n    moduleId: \"world2DXZ\",\n    description: doc,\n    content: require(\"./shader-fragments/world-2d-xz-projection.vs\"),\n    compatibility: ShaderInjectionTarget.ALL,\n    uniforms: (layer: Layer<any, any>) => {\n      if (!(layer instanceof Layer2D)) {\n        console.warn(\n          \"A shader requesed the module world2DXZ; however, the layer the shader comes from is NOT a Layer2D which is\",\n          \"required for the module to work.\"\n        );\n        return [];\n      }\n\n      if (!layer.props.control2D) {\n        console.warn(\n          \"For a layer 2D to be compatible with a 3D View, the layer requires an additional prop of control2D\"\n        );\n        return [];\n      }\n\n      return [\n        // This injects the projection matrix from the view camera\n        {\n          name: \"projection\",\n          size: UniformSize.MATRIX4,\n          update: () => layer.view.props.camera.projection\n        },\n        // This injects the model view matrix from the view camera\n        {\n          name: \"view\",\n          size: UniformSize.MATRIX4,\n          update: () => layer.view.props.camera.view\n        },\n        // This injects a 2D camera's offset\n        {\n          name: \"cameraOffset\",\n          size: UniformSize.THREE,\n          update: () =>\n            layer.props.control2D instanceof Control2D\n              ? layer.props.control2D.offset\n              : [0, 0, 0]\n        },\n        // This injects the camera's current position\n        {\n          name: \"cameraPosition\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.position\n        },\n        // This injects the camera's current scale\n        {\n          name: \"cameraScale\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.scale\n        },\n        // This injects the camera's 2D current scale\n        {\n          name: \"cameraScale2D\",\n          size: UniformSize.THREE,\n          update: () =>\n            layer.props.control2D instanceof Control2D\n              ? layer.props.control2D.scale\n              : [1, 1, 1]\n        },\n        // This injects the camera's Euler rotation\n        {\n          name: \"cameraRotation\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.scale\n        },\n        // This injects the pixel width and height of the view\n        {\n          name: \"viewSize\",\n          size: UniformSize.TWO,\n          update: () => [\n            layer.view.viewBounds.width,\n            layer.view.viewBounds.height\n          ]\n        },\n        // This injects the current layer's pixel ratio so pixel ratio dependent items can react to it\n        // Things like gl_PointSize will need this metric if not working in clip space\n        {\n          name: \"pixelRatio\",\n          size: UniformSize.ONE,\n          update: () => [layer.view.pixelRatio]\n        }\n      ];\n    }\n  }\n]);\n","module.exports = \"vec3 cameraSpace(vec3 world) {\\nreturn (world + cameraOffset) * cameraScale2D;\\n}\\nvec3 cameraSpaceSize(vec3 worldSize) {\\nreturn worldSize * cameraScale2D;\\n}\\nvec4 clipSpace(vec3 world) {\\nreturn ((projection * view) * vec4(cameraSpace(world.xzy), 1.0));\\n}\\nvec4 clipSpaceSize(vec3 worldSize) {\\nreturn ((projection * view) * vec4(cameraSpaceSize(worldSize.xzy), 0.0));\\n}\"","import { Control2D } from \"../../2d/view/control-2d\";\nimport { Layer2D } from \"../../2d/view/layer-2d\";\nimport { ShaderModule } from \"../../shaders\";\nimport { Layer } from \"../../surface/layer\";\nimport { ShaderInjectionTarget, UniformSize } from \"../../types\";\n\nconst doc = `\nThis is a special helper module used by\nthe system to map View2D content into\na 3D world space. The system utilizes\nthis module automatically for you when\nyou utilize createLayer2Din3D.\n`;\n\n/**\n * This module changes the projections for Layer2D style layers to map [x, y] -> [z, y]\n */\nShaderModule.register([\n  {\n    moduleId: \"world2DYZ\",\n    description: doc,\n    content: require(\"./shader-fragments/world-2d-yz-projection.vs\"),\n    compatibility: ShaderInjectionTarget.ALL,\n    uniforms: (layer: Layer<any, any>) => {\n      if (!(layer instanceof Layer2D)) {\n        console.warn(\n          \"A shader requesed the module world2DYZ; however, the layer the shader comes from is NOT a Layer2D which is\",\n          \"required for the module to work.\"\n        );\n        return [];\n      }\n\n      if (!layer.props.control2D) {\n        console.warn(\n          \"For a layer 2D to be compatible with a 3D View, the layer requires an additional prop of control2D\"\n        );\n        return [];\n      }\n\n      return [\n        // This injects the projection matrix from the view camera\n        {\n          name: \"projection\",\n          size: UniformSize.MATRIX4,\n          update: () => layer.view.props.camera.projection\n        },\n        // This injects the model view matrix from the view camera\n        {\n          name: \"view\",\n          size: UniformSize.MATRIX4,\n          update: () => layer.view.props.camera.view\n        },\n        // This injects a 2D camera's offset\n        {\n          name: \"cameraOffset\",\n          size: UniformSize.THREE,\n          update: () =>\n            layer.props.control2D instanceof Control2D\n              ? layer.props.control2D.offset\n              : [0, 0, 0]\n        },\n        // This injects the camera's current position\n        {\n          name: \"cameraPosition\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.position\n        },\n        // This injects the camera's current scale\n        {\n          name: \"cameraScale\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.scale\n        },\n        // This injects the camera's 2D current scale\n        {\n          name: \"cameraScale2D\",\n          size: UniformSize.THREE,\n          update: () =>\n            layer.props.control2D instanceof Control2D\n              ? layer.props.control2D.scale\n              : [1, 1, 1]\n        },\n        // This injects the camera's Euler rotation\n        {\n          name: \"cameraRotation\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.scale\n        },\n        // This injects the pixel width and height of the view\n        {\n          name: \"viewSize\",\n          size: UniformSize.TWO,\n          update: () => [\n            layer.view.viewBounds.width,\n            layer.view.viewBounds.height\n          ]\n        },\n        // This injects the current layer's pixel ratio so pixel ratio dependent items can react to it\n        // Things like gl_PointSize will need this metric if not working in clip space\n        {\n          name: \"pixelRatio\",\n          size: UniformSize.ONE,\n          update: () => [layer.view.pixelRatio]\n        }\n      ];\n    }\n  }\n]);\n","module.exports = \"vec3 cameraSpace(vec3 world) {\\nreturn (world + cameraOffset) * cameraScale2D;\\n}\\nvec3 cameraSpaceSize(vec3 worldSize) {\\nreturn worldSize * cameraScale2D;\\n}\\nvec4 clipSpace(vec3 world) {\\nreturn ((projection * view) * vec4(cameraSpace(world.zyx), 1.0));\\n}\\nvec4 clipSpaceSize(vec3 worldSize) {\\nreturn ((projection * view) * vec4(cameraSpaceSize(worldSize.zyx), 0.0));\\n}\"","export * from \"./view-3d\";\nexport * from \"./layer-2d-in-3d\";\nexport * from \"./projection-3d\";\nexport * from \"./view-3d\";\n","import { Control2D, Layer2D } from \"../../2d\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport { ILayerConstructable, ILayerProps } from \"../../surface/layer\";\nimport { IShaderInitialization, Omit } from \"../../types\";\nimport { createLayer } from \"../../util/create-layer\";\n\n/**\n * Specifies a 2D axis system within a 3D world.\n */\nexport enum Axis2D {\n  /** X-axis remains x-axis and y-axis remains y-axis */\n  XY,\n  /** X-axis remains x-axis and y-axis is now mapped to the z axis */\n  XZ,\n  /** X-axis is mapped to the z-axis and the y-axis remains y-axis */\n  YZ\n}\n\n/**\n * This method provides a means for a layer2d to be injected into a 3d world along a different axis system. This way\n * the 2d elements can render their positional information in the correct manner within the 3D world and remain\n * versatile enough to be used in many cases without having to render into a rendering context and then into the\n * 3D world.\n *\n * Mapped 2D layers will sometimes behave as expected and sometimes will not. For instance: rendering labels within\n * the 3D space will merely render their anchor position correctly within 3D but will not render the glyphs flat along\n * the axis. The glyphs will actually remain upright and rendered within the screen space.\n *\n * To render elements truly flat within the 3D world, use a render target first, then render the target within the 3D\n * world.\n */\nexport function createLayer2Din3D<T extends Instance, U extends ILayerProps<T>>(\n  axis2D: Axis2D,\n  classType: ILayerConstructable<T> & { defaultProps: U },\n  props: Omit<U, \"key\" | \"data\"> &\n    Partial<Pick<U, \"key\" | \"data\">> & { control2D: Control2D }\n) {\n  const doesInheritLayer2D =\n    classType === Layer2D || classType.prototype instanceof Layer2D;\n\n  if (!doesInheritLayer2D) {\n    console.warn(\n      \"A Layer type was specified for createLayer2din3D that is NOT a Layer2D type, which is invalid.\",\n      \"The layer will be used without being modified.\"\n    );\n    return createLayer(classType, props);\n  }\n\n  let newModule: string;\n\n  switch (axis2D) {\n    case Axis2D.XY:\n      newModule = \"world2DXY\";\n      break;\n    case Axis2D.XZ:\n      newModule = \"world2DXZ\";\n      break;\n    case Axis2D.YZ:\n      newModule = \"world2DYZ\";\n      break;\n\n    default:\n      return createLayer(classType, props);\n  }\n\n  const modifiedProps = Object.assign({}, props, {\n    baseShaderModules: (\n      _shaderIO: IShaderInitialization<Instance>,\n      layerModules: { fs: string[]; vs: string[] }\n    ) => {\n      // We remove the world 2D module to replace it with our custom module that will handle the projections correctly.\n      let world2DIndex = layerModules.vs.indexOf(\"world2D\");\n\n      if (world2DIndex >= 0) {\n        layerModules.vs.splice(world2DIndex, 1, newModule);\n      }\n\n      world2DIndex = layerModules.fs.indexOf(\"world2D\");\n\n      if (world2DIndex >= 0) {\n        layerModules.fs.splice(world2DIndex, 1, newModule);\n      }\n\n      return layerModules;\n    }\n  });\n\n  return createLayer(classType, modifiedProps);\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport { identity4 } from \"../../math\";\nimport { ShaderModule } from \"../../shaders\";\nimport { ILayerProps, Layer } from \"../../surface\";\nimport { ShaderInjectionTarget, UniformSize } from \"../../types\";\nimport { createUniform } from \"../../util\";\nimport { ISceneGraphLayerProps, SceneGraphLayer } from \"./scene-graph-layer\";\n\nconst doc = `\nWhen working with SceneGraphLayers, the\nlayer can have a transform applied to\nthe layer. This makes that transform\navailable in the parentTransform\nconstant.\n\nmat4 parentTransform;\n`;\n\nShaderModule.register({\n  moduleId: \"parent-transform\",\n  description: doc,\n  compatibility: ShaderInjectionTarget.VERTEX,\n  content: \"\",\n  uniforms: layer => {\n    const moduleLayer:\n      | SceneGraphLayer<Instance, ISceneGraphLayerProps<Instance>>\n      | Layer<Instance, ILayerProps<Instance>> = layer;\n\n    if (!(moduleLayer instanceof SceneGraphLayer)) {\n      console.warn(\n        \"A shader requested the module parent-transform; however, the layer the\",\n        \"shader is generated from is NOT a SceneGraphLayer which is\",\n        \"required for the module to work.\"\n      );\n      return [];\n    }\n\n    const identity = identity4();\n\n    return [\n      createUniform({\n        name: \"parentTransform\",\n        size: UniformSize.MATRIX4,\n        update: () => moduleLayer.props.parent?.matrix || identity\n      })\n    ];\n  }\n});\n","import {\n  apply2,\n  apply3,\n  decomposeRotation,\n  identity2,\n  identity4,\n  length4Components,\n  Mat4x4,\n  multiply4x4,\n  oneQuat,\n  Quaternion,\n  rotation2x2,\n  SRT4x4_2D,\n  Vec2Compat,\n  Vec3\n} from \"../../math\";\nimport { UpdateProp } from \"../../types\";\nimport { Instance2D } from \"./instance-2d\";\nimport { resolveUpdate, scheduleUpdate } from \"./transform-base\";\nimport { TreeNode } from \"./tree-node\";\n\n/**\n * This is a transform node that specifically only operates on x y positions and\n * single value rotations. It still is compatible with the 3D node system but\n * significantly reduces operations when only 2D operations are needed.\n */\nexport class Transform2D extends TreeNode<Transform2D> {\n  /** Indicates this transform is queued for an update in the update loop */\n  private isQueuedForUpdate = false;\n  /**\n   * Helper flag indicating it is relevant to have the world orientation\n   * decomposed from the world transform.\n   */\n  private needsWorldOrientation = false;\n  /**\n   * When this is set, this means the world matrix has updated and has not been\n   * decomposed yet.\n   */\n  private needsWorldDecomposition: boolean = false;\n\n  /** This is a special instance listener for the transform */\n  private _instance: Instance2D | null = null;\n  set instance(val: Instance2D | null) {\n    if (this._instance !== val && this._instance) {\n      this._instance.transform.instance = null;\n      if (val) val.transform = this;\n    }\n\n    this._instance = val;\n  }\n\n  /**\n   * This is the inner matrix that represents the culmination of all the\n   * properties into a single transform matrix. It is invalid and will cause\n   * undefined behavior if the elements of this matrix are modified. You should\n   * use the provided methods of this Transform class to manipulate this matrix.\n   *\n   * This matrix is what is used to transform coordinates into world space, thus\n   * it is also the culmination of all the parent's to this particular\n   * transform.\n   */\n  get matrix(): Mat4x4 {\n    this.update();\n    return this._matrix.value;\n  }\n  /**\n   * This is the culminated matrix for world space which includes this\n   * Transform's changes plus it's parent's changes.\n   */\n  private _matrix: UpdateProp<Mat4x4> = { value: identity4() };\n  /**\n   * This is the local matrix which represents the transform this Transform\n   * performs which does NOT include the parent transforms to this transform.\n   */\n  private _localMatrix: UpdateProp<Mat4x4> = { value: this._matrix.value };\n\n  /**\n   * Translation of this transform in world space.\n   */\n  get position() {\n    this.needsWorldOrientation = true;\n    this.update();\n    return this._position.value;\n  }\n  set position(val: Vec3) {\n    if (!this.parent) {\n      this.localPosition = val;\n    } else {\n      console.warn(\n        \"NOT IMPLEMENTED: Setting world position is not supported yet. Use localPosition for now.\"\n      );\n    }\n  }\n  /**\n   * The position on the x y axis\n   */\n  get localPosition() {\n    return this._localPosition.value;\n  }\n  set localPosition(val: Vec2Compat) {\n    this._localPosition.value[0] = val[0];\n    this._localPosition.value[1] = val[1];\n    this._localPosition.didUpdate = true;\n    this.invalidate();\n  }\n  private _position: UpdateProp<Vec3> = { value: [0, 0, 0] };\n  private _localPosition: UpdateProp<Vec2Compat> = {\n    value: this._position.value\n  };\n\n  /**\n   * Orientation of this transform in world space. When no parent is present\n   * rotation === localRotation.\n   */\n  get rotation() {\n    this.needsWorldOrientation = true;\n    this.update();\n    return this._rotation.value;\n  }\n  set rotation(_val: Quaternion) {\n    console.warn(\n      \"NOT IMPLEMENTED: Setting world rotation for a 2D transform is not supported yet.\"\n    );\n  }\n  /**\n   * Orientation of this transform without it's parent's orientation. When no\n   * parent is present rotation === localRotation.\n   */\n  get localRotation() {\n    return this._localRotation.value;\n  }\n  set localRotation(val: number) {\n    this._localRotation.value = val;\n    this._localRotation.didUpdate = true;\n    this.invalidate();\n  }\n  private _rotation: UpdateProp<Quaternion> = { value: oneQuat() };\n  private _localRotation: UpdateProp<number> = {\n    value: 0\n  };\n  private localRotationMatrix = identity2();\n\n  /**\n   * The scale of the Transform in world space. When there is no parent,\n   * localScale === scale.\n   */\n  get scale() {\n    this.needsWorldOrientation = true;\n    this.update();\n    return this._scale.value;\n  }\n  set scale(val: Vec3) {\n    if (!this.parent) {\n      this.localScale = val;\n    } else {\n      console.warn(\n        \"NOT IMPLEMENTED: Setting world scale is not supported yet. Use localScale for now.\"\n      );\n    }\n  }\n  /**\n   * The scale this Transform applies ignoring the parent Transform. When there\n   * is no parent, localScale === scale.\n   */\n  get localScale() {\n    return this._localScale.value;\n  }\n  set localScale(val: Vec2Compat) {\n    apply2(this._localScale.value, val[0], val[1]);\n    this._localScale.didUpdate = true;\n    this.invalidate();\n  }\n  private _scale: UpdateProp<Vec3> = { value: [1, 1, 1] };\n  private _localScale: UpdateProp<Vec2Compat> = { value: this._scale.value };\n\n  /**\n   * This method contains the math involved in decomposing our world SRT matrix\n   * so we can view the Transform's orientation relative to world space.\n   */\n  private decomposeWorldMatrix() {\n    // If no triggers occurred, we need to not decompose\n    if (\n      !this.parent ||\n      !this.needsWorldDecomposition ||\n      !this.needsWorldOrientation\n    ) {\n      return;\n    }\n\n    // Indicate the decomposition has been updated for the current world matrix\n    this.needsWorldDecomposition = false;\n    const m = this._matrix.value;\n    const translation = this._position.value;\n    const scale = this._scale.value;\n\n    // Translation is stored in the last row\n    this._position.didUpdate =\n      translation[0] !== m[12] ||\n      translation[1] !== m[13] ||\n      translation[2] !== m[14];\n    if (this._position.didUpdate) {\n      apply3(translation, m[12], m[13], m[14]);\n    }\n\n    // Scale is the magnitude of each row vector\n    const sx = length4Components(m[0], m[1], m[2], m[3]);\n    const sy = length4Components(m[4], m[5], m[6], m[7]);\n    const sz = length4Components(m[8], m[9], m[10], m[11]);\n    this._scale.didUpdate =\n      scale[0] !== sx || scale[1] !== sy || scale[2] !== sz;\n    apply3(scale, sx, sy, sz);\n    this._scale.didUpdate = true;\n\n    // Use the calculated scale to make a pure rotation matrix from which we can\n    // derive a Quaternion for the world orientation.\n    // prettier-ignore\n    const [a, b, c, d] = this._rotation.value;\n    decomposeRotation(this._matrix.value, sx, sy, sz, this._rotation.value);\n    const r = this._rotation.value;\n    this._rotation.didUpdate =\n      r[0] !== a || r[1] !== b || r[2] !== c || r[3] !== d;\n  }\n\n  /**\n   * Ensures this transform WILL receive an update if it fits requirements for\n   * potentially missing an update that may be needed by passive elements.\n   */\n  queueForUpdate() {\n    // If the invalidation did happen, then we check our monitored instance to\n    // see if it's actively waiting on any of the transform's properties. If it\n    // is, then the invalidation should also immediately trigger an update and\n    // trigger the resource updates for the instance.\n    if (!this.isQueuedForUpdate && this._instance && this._instance.active) {\n      this.isQueuedForUpdate = true;\n      scheduleUpdate(this);\n    }\n  }\n\n  /**\n   * If needed, this updates the matrix for this transform. This is called\n   * automatically when the matrix is retrieved.\n   *\n   * The unsafe flag causes this node to update without ensuring it's parents\n   * are out of date. Recommended to not use this flag ever. The system handles\n   * all of that for you.\n   */\n  update(unsafe?: boolean) {\n    let updateWorldMatrix = false;\n\n    // If this is queued for an update, we can remove it now as it's definitely\n    // up to date at this point.\n    if (this.isQueuedForUpdate) {\n      resolveUpdate(this);\n      this.isQueuedForUpdate = false;\n    }\n\n    // If this node directly needs an update we should update our local matrix\n    if (this.needsUpdate) {\n      const R = this.localRotationMatrix;\n\n      if (this._localRotation.didUpdate) {\n        rotation2x2(this._localRotation.value, R);\n      }\n\n      // Concat the SRT transform in this order Scale -> Rotation -> Translation\n      // We utilize our existing matrix to reduce redundant allocations of\n      // matrix information.\n      SRT4x4_2D(\n        this._localScale.value,\n        R,\n        this._localPosition.value,\n        this._localMatrix.value\n      );\n      this._localMatrix.didUpdate = true;\n      // Since we updated the local matrix, let's make sure the world matrix\n      // gets updated as well\n      updateWorldMatrix = true;\n    }\n\n    // If our parent has this node flagged for update, then this means our world\n    // matrix is no longer valid.\n    if (this.parent) {\n      // If the parent node specifically needs an update, then we need to\n      // process the updates of all the nodes bubling up the tree\n      if (this.parent.needsUpdate) {\n        // Flagging this as a child being out of date could mean several nodes\n        // up the chain are out of date as well. So we shall update those nodes\n        // starting at the top most out of date node, and work our way down\n        if (!unsafe) {\n          this.processParentUpdates(transform => {\n            transform.update(true);\n          });\n        }\n\n        updateWorldMatrix = true;\n      }\n\n      // If the parent doesn't need updating, but we still have a child\n      // unresolved flag set, then we still need the world matrix for this node\n      // updated.\n      else if (this.parent.childUpdate.has(this)) {\n        updateWorldMatrix = true;\n      }\n\n      // If something changed that required the world matrix to be recalculated,\n      // then let's update it.\n      if (updateWorldMatrix) {\n        // Apply the world change\n        multiply4x4(\n          this.parent._matrix.value,\n          this._localMatrix.value,\n          this._matrix.value\n        );\n        this._matrix.didUpdate = true;\n        this.needsWorldDecomposition = true;\n      }\n    }\n\n    // Make sure our world orientations are up to date if we updated our world\n    // matrix.\n    this.decomposeWorldMatrix();\n\n    // Perform all of the triggers needed to update the instance to the latest\n    if (this._instance && this._instance.active) {\n      if (this._localRotation.didUpdate) {\n        (this._instance as any)._localRotation = this._localRotation.value;\n      }\n\n      if (this._localPosition.didUpdate) {\n        (this._instance as any)._localPosition = this._localPosition.value;\n      }\n\n      if (this._localScale.didUpdate) {\n        (this._instance as any)._localScale = this._localScale.value;\n      }\n\n      // If we don't have a parent, then the local and the world positioning is\n      // merged and thus the world needs to be updated based on the local\n      if (!this.parent) {\n        if (this._localRotation.didUpdate) {\n          (this._instance as any)._rotation = this._localRotation.value;\n        }\n\n        if (this._localPosition.didUpdate) {\n          (this._instance as any)._position = this._localPosition.value;\n        }\n\n        if (this._localScale.didUpdate) {\n          (this._instance as any)._scale = this._localScale.value;\n        }\n      } else {\n        if (this._rotation.didUpdate) {\n          (this._instance as any)._rotation = this._rotation.value;\n        }\n\n        if (this._scale.didUpdate) {\n          (this._instance as any)._scale = this._scale.value;\n        }\n\n        if (this._position.didUpdate) {\n          (this._instance as any)._position = this._position.value;\n        }\n      }\n\n      // Trigger updates for the instance\n      if (this._matrix.didUpdate || this._localMatrix.didUpdate) {\n        this._instance.transform = this;\n      }\n    }\n\n    this._localScale.didUpdate = false;\n    this._localRotation.didUpdate = false;\n    this._localPosition.didUpdate = false;\n    this._rotation.didUpdate = false;\n    this._scale.didUpdate = false;\n    this._position.didUpdate = false;\n    this._matrix.didUpdate = false;\n    this._localMatrix.didUpdate = false;\n\n    this.resolve();\n  }\n}\n","export * from \"./cube\";\n","export * from \"./cube-layer\";\nexport * from \"./cube-instance\";\n","import { GLSettings } from \"../../../gl\";\nimport { InstanceProvider } from \"../../../instance-provider\";\nimport { Vec2, Vec3 } from \"../../../math/vector\";\nimport { ILayerProps, Layer } from \"../../../surface/layer\";\nimport {\n  FragmentOutputType,\n  InstanceAttributeSize,\n  IShaderInitialization,\n  VertexAttributeSize\n} from \"../../../types\";\nimport { CommonMaterialOptions, createAttribute } from \"../../../util\";\nimport { IdentityTransform } from \"../../scene-graph\";\nimport { CubeInstance } from \"./cube-instance\";\n\nexport interface ICubeLayerProps<TInstance extends CubeInstance>\n  extends ILayerProps<TInstance> {}\n\n/**\n * Layer for rendering simple cube primitives\n */\nexport class CubeLayer<\n  TInstance extends CubeInstance,\n  TProps extends ICubeLayerProps<TInstance>\n> extends Layer<TInstance, TProps> {\n  static defaultProps: ICubeLayerProps<CubeInstance> = {\n    data: new InstanceProvider<CubeInstance>(),\n    key: \"\",\n    materialOptions: CommonMaterialOptions.transparentShapeBlending\n  };\n\n  initShader(): IShaderInitialization<TInstance> | null {\n    const FRT: Vec3 = [1, 1, 1];\n    const BRT: Vec3 = [1, 1, -1];\n    const BRB: Vec3 = [1, -1, -1];\n    const FRB: Vec3 = [1, -1, 1];\n\n    const FLT: Vec3 = [-1, 1, 1];\n    const BLT: Vec3 = [-1, 1, -1];\n    const BLB: Vec3 = [-1, -1, -1];\n    const FLB: Vec3 = [-1, -1, 1];\n\n    const positions: Vec3[] = [\n      // right\n      FRT,\n      BRT,\n      BRB,\n      FRT,\n      BRB,\n      FRB,\n      // front\n      FLT,\n      FRT,\n      FRB,\n      FLT,\n      FRB,\n      FLB,\n      // left\n      FLT,\n      BLB,\n      BLT,\n      FLT,\n      FLB,\n      BLB,\n      // back\n      BLT,\n      BRB,\n      BRT,\n      BLT,\n      BLB,\n      BRB,\n      // up\n      FLT,\n      BRT,\n      FRT,\n      FLT,\n      BLT,\n      BRT,\n      // down\n      FLB,\n      FRB,\n      BRB,\n      FLB,\n      BRB,\n      BLB\n    ];\n\n    const right: Vec3 = [1, 0, 0];\n    const forward: Vec3 = [0, 0, 1];\n    const left: Vec3 = [-1, 0, 0];\n    const backward: Vec3 = [0, 0, -1];\n    const up: Vec3 = [0, 1, 0];\n    const down: Vec3 = [0, -1, 0];\n\n    const normals = [\n      right,\n      right,\n      right,\n      right,\n      right,\n      right,\n      forward,\n      forward,\n      forward,\n      forward,\n      forward,\n      forward,\n      left,\n      left,\n      left,\n      left,\n      left,\n      left,\n      backward,\n      backward,\n      backward,\n      backward,\n      backward,\n      backward,\n      up,\n      up,\n      up,\n      up,\n      up,\n      up,\n      down,\n      down,\n      down,\n      down,\n      down,\n      down\n    ];\n\n    const tex: Vec2[] = [\n      [0, 0],\n      [1, 0],\n      [1, 1],\n      [0, 0],\n      [1, 1],\n      [0, 1],\n\n      [0, 0],\n      [1, 0],\n      [1, 1],\n      [0, 0],\n      [1, 1],\n      [0, 1],\n\n      [0, 0],\n      [1, 1],\n      [1, 0],\n      [0, 0],\n      [0, 1],\n      [1, 1],\n\n      [0, 0],\n      [1, 1],\n      [1, 0],\n      [0, 0],\n      [0, 1],\n      [1, 1],\n\n      [0, 0],\n      [1, 1],\n      [1, 0],\n      [0, 0],\n      [0, 1],\n      [1, 1],\n\n      [0, 0],\n      [1, 0],\n      [1, 1],\n      [0, 0],\n      [1, 1],\n      [0, 1]\n    ];\n\n    return {\n      drawMode: GLSettings.Model.DrawMode.TRIANGLES,\n      fs: [\n        {\n          outputType: FragmentOutputType.COLOR,\n          source: require(\"./cube-layer.fs\")\n        }\n      ],\n      instanceAttributes: [\n        createAttribute({\n          name: \"transform\",\n          size: InstanceAttributeSize.MAT4X4,\n          update: o => (o.transform || IdentityTransform).matrix\n        }),\n        createAttribute({\n          name: \"size\",\n          size: InstanceAttributeSize.THREE,\n          update: o => o.size\n        })\n      ],\n      uniforms: [],\n      vertexAttributes: [\n        {\n          name: \"position\",\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => positions[vertex]\n        },\n        {\n          name: \"normal\",\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => normals[vertex]\n        },\n        {\n          name: \"texCoord\",\n          size: VertexAttributeSize.TWO,\n          update: (vertex: number) => tex[vertex]\n        }\n      ],\n      vertexCount: 36,\n      vs: require(\"./cube-layer.vs\")\n    };\n  }\n\n  getMaterialOptions() {\n    return Object.assign({}, CommonMaterialOptions.transparentShapeBlending, {\n      cullSide: GLSettings.Material.CullSide.CCW\n    });\n  }\n}\n","module.exports = \"varying vec2 _texCoord;\\nvoid main() {\\ngl_FragColor = mix(\\nvec4(1.0, 0.0, 0.0, 1.0),\\nvec4(0.0, 0.0, 0.0, 1.0),\\nfloat(_texCoord.x <= 0.01 || _texCoord.x > 0.99 || _texCoord.y < 0.01 || _texCoord.y > 0.99)\\n);\\n}\"","module.exports = \"${import: projection}\\nvarying vec2 _texCoord;\\nvoid main() {\\nvec4 pos = vec4(position * size, 1.0);\\nvec4 world = transform * pos;\\n_texCoord = texCoord;\\ngl_Position = clipSpace(world.xyz);\\n}\"","import { observable } from \"../../../instance-provider\";\nimport { Color, Size } from \"../../../types\";\nimport { IInstance3DOptions, Instance3D } from \"../../scene-graph/instance-3d\";\n\n/** Customizes a new Cube instance */\nexport interface ICubeOptions extends IInstance3DOptions {\n  /** Sets the dimensions of the cube */\n  size?: Size;\n  /** Sets the color of the cube */\n  color?: Color;\n}\n\n/**\n * Represents a cube model within 3D space.\n */\nexport class CubeInstance extends Instance3D {\n  /** Dimensions of the cube */\n  @observable size: Size = [1, 1, 1];\n  /** Color of the cube */\n  @observable color: Color = [1, 1, 1, 1];\n\n  constructor(options: ICubeOptions) {\n    super(options);\n    this.size = options.size || this.size;\n    this.color = options.color || this.color;\n  }\n}\n","export * from \"./basic-surface\";\n","import { isString } from \"util\";\nimport { EventManager } from \"../event-management/event-manager\";\nimport { Instance, InstanceProvider } from \"../instance-provider\";\nimport { Bounds } from \"../math/primitives/bounds\";\nimport { BaseResourceOptions } from \"../resources\";\nimport {\n  ISceneOptions,\n  ISurfaceOptions,\n  IViewProps,\n  LayerInitializer,\n  Surface,\n  View,\n  ViewInitializer\n} from \"../surface\";\nimport { IPipeline, Lookup, Omit, Size, SurfaceErrorType } from \"../types\";\nimport { onAnimationLoop, PromiseResolver, stopAnimationLoop } from \"../util\";\nimport { Camera } from \"../util/camera\";\nimport { waitForValidDimensions } from \"../util/wait-for-valid-dimensions\";\n\n/**\n * This gets all of the values of a Lookup\n */\nfunction lookupValues<T>(check: Function, lookup: Lookup<T> | T[]): T[] {\n  const out: T[] = [];\n  const toProcess = Object.values(lookup);\n\n  for (let index = 0; index < toProcess.length; ++index) {\n    const next = toProcess[index];\n\n    if (next instanceof check) {\n      out.push(next as T);\n    } else {\n      toProcess.push(...Object.values(next));\n    }\n  }\n\n  return out;\n}\n\n/**\n * This gets all of the values of a Lookup\n */\nfunction mapLookupValues<T, U>(\n  label: string,\n  check: (value: T | Lookup<T>) => boolean,\n  lookup: Lookup<T>,\n  callback: (key: string, value: T) => U\n): U[] {\n  const added = new Set();\n  const out: U[] = [];\n  const toProcess = Object.keys(lookup).map<[string, T | Lookup<T>]>(key => [\n    key,\n    (lookup as any)[key]\n  ]);\n\n  for (let index = 0; index < toProcess.length; ++index) {\n    const next = toProcess[index];\n\n    if (check(next[1])) {\n      out.push(callback(next[0], next[1] as T));\n    } else {\n      let error = false;\n      const nextChunk: [string, T | Lookup<T>][] = [];\n\n      Object.keys(next[1]).forEach(key => {\n        const value = (next[1] as any)[key];\n\n        if (!added.has(value)) {\n          nextChunk.push([`${next[0]}.${key}`, value]);\n          added.add(value);\n        } else {\n          error = true;\n          console.warn(\"Invalid lookup for BasicSurface detected:\", label);\n        }\n      });\n\n      // Inject the next chunk of items at the place of the current process item\n      // So we retain the tree order that items appear in\n      if (nextChunk.length > 0) {\n        toProcess.splice(index + 1, 0, ...nextChunk);\n      }\n\n      if (error) break;\n    }\n  }\n\n  return out;\n}\n\n/** Non-keyed View options with ordering property to specify rendering order */\nexport type BasicSurfaceView<TViewProps extends IViewProps> = Omit<\n  ViewInitializer<TViewProps>,\n  \"key\"\n> &\n  Partial<Pick<IViewProps, \"key\">>;\n/** Non-keyed layer initializer with ordering property to specify rendering order */\nexport type BasicSurfaceLayer = Omit<LayerInitializer, \"key\"> &\n  Partial<Pick<IViewProps, \"key\">>;\n\n/**\n * Defines a scene that elements are injected to. Each scene can be viewed with multiple views\n * and have several layers of injection into it.\n *\n * These are scene options without elements needing to specify keys. Instead, the keys will be\n * generated via Lookup definition keys.\n */\nexport type BasicSurfaceSceneOptions = Omit<\n  ISceneOptions,\n  \"key\" | \"views\" | \"layers\"\n> & {\n  /** Layers to inject elements into the scene */\n  layers: Lookup<BasicSurfaceLayer> | BasicSurfaceLayer[];\n  /** Views for rendering a perspective of the scene to a surface */\n  views: Lookup<BasicSurfaceView<IViewProps>> | BasicSurfaceView<IViewProps>[];\n};\n\nexport type BasicSurfaceResourceOptions = Omit<BaseResourceOptions, \"key\"> & {\n  key?: string;\n};\n\nexport interface IBasicSurfacePipeline {\n  /** Easy define the scenes to be used for the render pipeline */\n  scenes: Lookup<BasicSurfaceSceneOptions>;\n}\n\n/**\n * Customization for the basic surface\n */\nexport interface IBasicSurfaceOptions<\n  TProviders extends Lookup<InstanceProvider<Instance>>,\n  TCameras extends Lookup<Camera>,\n  TEvents extends Lookup<EventManager> | EventManager[],\n  TResources extends Lookup<\n    BaseResourceOptions | Record<number, BaseResourceOptions>\n  >,\n  TScenes extends Lookup<BasicSurfaceSceneOptions> | BasicSurfaceSceneOptions[]\n> {\n  /** The container this surface will fill with a canvas to render within */\n  container: HTMLElement;\n  /**\n   * A lookup of all cameras the surface will utilize. They are injected with identifiers to make it easy to\n   * reference them later. It's highly recommended to use an enum to identify the camera.\n   */\n  cameras: TCameras;\n  /**\n   * Tell the surface to absorb wheel events to prevent the wheel from scolling the page.\n   * This defaults to true as it's more common to need wheel controls than not. Explicitly set to false to disable.\n   */\n  handlesWheelEvents?: boolean;\n  /**\n   * A list of providers you will utilize within your application. They are injected with identifiers to make it easy to\n   * reference them later. It's highly recommended to use an enum to identify the provider.\n   *\n   * NOTE: This is optional as it is usually VERY handy to have strong typed providers\n   */\n  providers: TProviders;\n  /** Options used to specify settings for the surface itself and how it will be composited in the DOM */\n  rendererOptions?: ISurfaceOptions[\"rendererOptions\"];\n  /** The resources to be used for the pipeline */\n  resources?: TResources;\n\n  // CALLBACKS\n\n  /**\n   * All of the event managers used to control the surface. They are injected with identifiers to make it easy to\n   * reference them later. It's highly recommended to use an enum to identify the event manager.\n   */\n  eventManagers(cameras: TCameras): TEvents;\n  /** A callback that provides the pipeline to use in the surface */\n  scenes(\n    resources: TResources,\n    providers: TProviders,\n    cameras: TCameras,\n    managers: TEvents\n  ): TScenes;\n  /** This will be called if no webgl context is detected */\n  onNoWebGL?(): void;\n}\n\n/**\n * Helper method to make surface configuration be easier to read and aid in\n * better code hinting.\n */\nexport function createScene(options: BasicSurfaceSceneOptions) {\n  return options;\n}\n\n/**\n * This is a surface that has some concepts already set up within it, such as monitoring\n * resizing, waiting for a valid size to be present, a render loop tied into requestAnimationFrame.\n * Nothing here is difficult to set up in your own custom Surface implementation, this may provide\n * enough basics to quickly get started or be enough for most small projects.\n *\n * This auto generates a canvas object that tracks the size of the provided container HTMLElement. Essentially\n * this surface attempts to fill in the provided container.\n */\nexport class BasicSurface<\n  TProviders extends Lookup<InstanceProvider<Instance>>,\n  TCameras extends Lookup<Camera>,\n  TEvents extends Lookup<EventManager> | EventManager[],\n  TResources extends Lookup<\n    BaseResourceOptions | Record<number, BaseResourceOptions>\n  >,\n  TScenes extends Lookup<BasicSurfaceSceneOptions> | BasicSurfaceSceneOptions[]\n> {\n  /** The context generated by this surface to render into. */\n  private context: HTMLCanvasElement;\n  /** This is the last known time this surface executed it's draw loop */\n  private currentTime: number = 0;\n  /** This is the identifier of the requestAnimationFrame, used for canceling */\n  private drawRequestId: Promise<number>;\n  /** The target canvas to render on */\n  private options: IBasicSurfaceOptions<\n    TProviders,\n    TCameras,\n    TEvents,\n    TResources,\n    TScenes\n  >;\n  /** This is the timer id for resize events. This is used to debounce resize events */\n  private resizeTimer: number = 0;\n  /** Tracks the last visibility state the browser is in */\n  private visibility: VisibilityState = \"visible\";\n  /** This is the context  */\n  private waitForSize = waitForValidDimensions();\n\n  /** The cameras specified for this surface */\n  cameras: TCameras;\n  /** The surface we are implementing */\n  base?: Surface;\n  /** The event managers specified for this surface */\n  eventManagers: TEvents;\n  /** The providers specified for this surface */\n  providers: TProviders;\n  /** The scenes specified for this surface */\n  scenes: TScenes;\n  /** A promise to await for the surface to be ready for rendering */\n  ready: Promise<\n    BasicSurface<TProviders, TCameras, TEvents, TResources, TScenes>\n  >;\n  /** The resources specified for the surface pipeline */\n  resources: TResources;\n\n  constructor(\n    options: IBasicSurfaceOptions<\n      TProviders,\n      TCameras,\n      TEvents,\n      TResources,\n      TScenes\n    >\n  ) {\n    this.rebuild(options);\n  }\n\n  /**\n   * Generates the proper context for our surface to work with.\n   */\n  private createContext() {\n    // If our context is not defined, then one must be made\n    if (!this.context) {\n      this.context = document.createElement(\"canvas\");\n      this.context.title = \"\";\n      this.context.width =\n        (this.options.container.offsetWidth || 0) * window.devicePixelRatio;\n      this.context.height =\n        (this.options.container.offsetHeight || 0) * window.devicePixelRatio;\n      this.context.style.width = `${this.options.container.offsetWidth || 0}px`;\n      this.context.style.height = `${this.options.container.offsetHeight ||\n        0}px`;\n      this.options.container.appendChild(this.context);\n    }\n  }\n\n  /**\n   * Frees all GPU memory and resources used by this Surface.\n   */\n  destroy = () => {\n    if (this.base) {\n      this.base.destroy();\n      delete this.base;\n    }\n\n    if (this.context) {\n      this.context.remove();\n      delete this.context;\n    }\n\n    stopAnimationLoop(this.drawRequestId);\n    window.removeEventListener(\"resize\", this.handleResize);\n  };\n\n  /**\n   * The draw loop of the surface\n   */\n  private draw = async (time: number) => {\n    if (!this.base) return;\n    this.currentTime = time;\n    this.base.draw(time);\n  };\n\n  /**\n   * This is a handler that responds to varying resize events\n   */\n  private handleResize = () => {\n    clearTimeout(this.resizeTimer);\n    if (!this.base) return;\n\n    this.resizeTimer = window.setTimeout(() => {\n      this.fitContainer();\n    }, 100);\n  };\n\n  /**\n   * This is a handler that responds to the browser window losing visibility\n   */\n  private handleVisibility = () => {\n    if (document.visibilityState === \"visible\") {\n      if (this.visibility !== document.visibilityState) {\n        this.base?.redraw();\n      }\n    }\n\n    this.visibility = document.visibilityState;\n  };\n\n  /**\n   * Initializes all elements for the surface\n   */\n  async init() {\n    // If the base is established, then this is initialized\n    if (this.base) return;\n    // We wait for the DOM container to establish a size we can work with\n    const valid = await this.waitForSize(this.options.container);\n    // If the waiting process returns false it means we canceled the operation from overlapping calls into init()\n    if (!valid) return;\n    // Make the canvas context we wish to render into\n    this.createContext();\n\n    // In our initial calls to the surface we can have numerous errors emitted. Some errors are valid feedback into\n    // the state of the client's browser. Some errors are system failures that should be handled gracefully and logged\n    // appropriately for debugging.\n    try {\n      // Establish the providers this surface will track\n      this.providers = this.options.providers;\n      // Establish the cameras desired to be used in the surface\n      this.cameras = this.options.cameras;\n      // Establish the resources desired to be used in the surface\n      this.resources = this.options.resources || ({} as TResources);\n      // Establish the event managers to be used in the surface\n      this.eventManagers = this.options.eventManagers(this.cameras);\n\n      // Create the surface to work with\n      this.base = await new Surface({\n        context: this.context,\n        handlesWheelEvents:\n          this.options.handlesWheelEvents !== undefined\n            ? this.options.handlesWheelEvents\n            : true,\n        pixelRatio: window.devicePixelRatio,\n        eventManagers: lookupValues<EventManager>(\n          EventManager,\n          this.eventManagers\n        ),\n        rendererOptions: Object.assign(\n          {\n            alpha: true,\n            antialias: false\n          },\n          this.options.rendererOptions\n        )\n      }).ready;\n\n      // Make sure the context fits the container\n      this.fitContainer(true);\n      // Use the established cameras and managers to establish the initial pipeline for the surface\n      // await this.updatePipeline();\n      // Begin the draw loop\n      this.drawRequestId = onAnimationLoop(this.draw);\n      // Use the established cameras and managers to establish the initial pipeline for the surface\n      await this.updatePipeline();\n      // Establish event listeners\n      window.addEventListener(\"resize\", this.handleResize);\n      document.addEventListener(\"visibilitychange\", this.handleVisibility);\n    } catch (err) {\n      // We catch any initialization errors from the surface\n      if (err.error === SurfaceErrorType.NO_WEBGL_CONTEXT) {\n        if (this.options.onNoWebGL) this.options.onNoWebGL();\n      } else {\n        console.error(\"The Basic Surface could not be initialized\");\n        console.error(err.stack || err.message);\n      }\n    }\n  }\n\n  /**\n   * Tells the surface to resize to the container if it's not fitted currently.\n   */\n  fitContainer(preventRedraw?: boolean) {\n    if (this.base) {\n      this.context.remove();\n\n      this.base.resize(\n        this.options.container.offsetWidth || 0,\n        this.options.container.offsetHeight || 0\n      );\n\n      this.options.container.appendChild(this.context);\n      if (!preventRedraw) this.base.draw(this.currentTime);\n    }\n  }\n\n  /**\n   * Retrieves the projection methods for a given view. If the projections do not exist, this returns null.\n   */\n  getViewProjections(viewId: string) {\n    if (!this.base) return null;\n    return this.base.getProjections(viewId);\n  }\n\n  /**\n   * Retrieves the size of the view as it appears on the screen if the ID exists in the current pipeline.\n   * If it does not exist yet, this will return [0, 0]\n   */\n  getViewScreenSize(\n    viewId: string | ((scenes: TScenes) => ViewInitializer<any>)\n  ): Size {\n    if (!this.base) return [0, 0];\n    let bounds;\n\n    if (isString(viewId)) {\n      bounds = this.base.getViewSize(viewId);\n      if (!bounds) return [0, 0];\n    } else {\n      bounds = this.base.getViewSize(viewId(this.scenes).init[1].key);\n      if (!bounds) return [0, 0];\n    }\n\n    return [bounds.width, bounds.height];\n  }\n\n  /**\n   * Retrieves the bounds of the view as it appears on the screen (relative to the canvas).\n   * If it does not exist yet, this will return a dimensionless Bounds object.\n   */\n  getViewScreenBounds(viewId: string): Bounds<View<IViewProps>> {\n    if (!this.base) return new Bounds({ x: 0, y: 0, width: 0, height: 0 });\n    const bounds = this.base.getViewWorldBounds(viewId);\n    if (!bounds) return new Bounds({ x: 0, y: 0, width: 0, height: 0 });\n\n    return bounds;\n  }\n\n  /**\n   * Gets the bounds of the view within world space.\n   * If it does not exist yet, this will return a dimensionless Bounds object.\n   */\n  getViewWorldBounds(viewId: string): Bounds<View<IViewProps>> {\n    if (!this.base) return new Bounds({ x: 0, y: 0, width: 0, height: 0 });\n    const bounds = this.base.getViewWorldBounds(viewId);\n    if (!bounds) return new Bounds({ x: 0, y: 0, width: 0, height: 0 });\n\n    return bounds;\n  }\n\n  /**\n   * Redeclare the pipeline\n   */\n  async pipeline(\n    callback: IBasicSurfaceOptions<\n      TProviders,\n      TCameras,\n      TEvents,\n      TResources,\n      TScenes\n    >[\"scenes\"]\n  ) {\n    this.options.scenes = callback;\n    if (!this.base) return;\n    await this.updatePipeline();\n  }\n\n  /**\n   * Destroys all current existing GPU resources and reconstructs them anew.\n   *\n   * NOTE: options parameter f\n   */\n  async rebuild(): Promise<void>;\n  async rebuild(clearProviders?: boolean): Promise<void>;\n  async rebuild(\n    options?: IBasicSurfaceOptions<\n      TProviders,\n      TCameras,\n      TEvents,\n      TResources,\n      TScenes\n    >\n  ): Promise<void>;\n  async rebuild(\n    param?:\n      | IBasicSurfaceOptions<TProviders, TCameras, TEvents, TResources, TScenes>\n      | boolean\n  ) {\n    let options;\n\n    // See if the rebuild wanted to clear the providers or not.\n    if (typeof param === \"boolean\") {\n      if (param && this.providers) {\n        const providers = lookupValues<InstanceProvider<Instance>>(\n          InstanceProvider,\n          this.providers\n        );\n\n        for (let i = 0, iMax = providers.length; i < iMax; ++i) {\n          const provider = providers[i];\n          provider.clear();\n        }\n      }\n    }\n\n    // Otherwise, the parameter is options injected for the surface initial build\n    else {\n      options = param;\n    }\n\n    if (this.options && options) {\n      console.warn(\n        \"Ignoring options provided to rebuild method. The constructor is the only way to apply an options configuration object\"\n      );\n    }\n\n    // Destroy any existing base\n    if (this.base) {\n      this.base.destroy();\n    }\n\n    if (this.context) {\n      this.context.remove();\n      delete this.context;\n    }\n\n    // Only if the options have not been established will this work\n    if (!this.options && options) this.options = options;\n    // Make a resolver to handle making a promise and a way to resolve it easily\n    const resolver = new PromiseResolver<\n      BasicSurface<TProviders, TCameras, TEvents, TResources, TScenes>\n    >();\n    // Set our ready marker so contructors of the surface have an easy async pattern\n    this.ready = resolver.promise;\n    // Initialize this surface\n    await this.init();\n    // Resolve anything awaiting the ready marker for the basic surface. This is\n    // primarily for the contructor to have an easy async pattern.\n    resolver.resolve(this);\n  }\n\n  /**\n   * Point to a new container to fill.\n   */\n  setContainer(container: HTMLElement) {\n    this.options.container = container;\n    container.appendChild(this.context);\n    this.fitContainer();\n  }\n\n  /**\n   * Calls the pipeline callback to retrieve an updated pipeline for the surface\n   */\n  async updatePipeline() {\n    if (!this.base) return;\n\n    // NOTE: This chunk establishes the potentially undeclared keys of the\n    //       resource declaration objects. Thus it needs to execute before\n    //       blocks that require the key to be established.\n    //\n    // Take the resource lookup and flatten it's values to a list. Each value\n    // will be given a key based on whether the value expressed an explicit key\n    // or will be a key made from the properties leading up to the value in the\n    // lookup.\n    const resources =\n      mapLookupValues(\n        \"resources\",\n        (val: any) => val && val.type !== undefined,\n        this.resources || [],\n        (key: string, val: BaseResourceOptions) => {\n          const resource: BaseResourceOptions = {\n            ...val,\n            key: val.key || key\n          };\n\n          val.key = resource.key;\n          return resource;\n        }\n      ) || [];\n\n    // We must convert all look ups of scenes and layers etc into a list of\n    // items that contain keys\n    const pipelineWithLookups = this.options.scenes(\n      this.resources || ({} as TResources),\n      this.providers,\n      this.cameras,\n      this.eventManagers\n    );\n\n    // Make our configuration available\n    this.scenes = pipelineWithLookups;\n\n    const scenes = mapLookupValues(\n      \"scenes\",\n      (val: any) => val && val.views !== undefined && val.layers !== undefined,\n      pipelineWithLookups,\n      (sceneKey: string, val: BasicSurfaceSceneOptions) => {\n        const views = mapLookupValues(\n          \"views\",\n          (val: any) => val && val.init !== undefined && val.init.length === 2,\n          val.views,\n          (key: string, val: BasicSurfaceView<IViewProps>) => {\n            const view: ViewInitializer<IViewProps> = {\n              ...val,\n              key: `${sceneKey}.${val.key || key}`\n            };\n\n            // Make the props it's own object so we don't mutate the originating object when we apply the\n            // calculated key\n            view.init[1] = {\n              ...view.init[1],\n              key: view.key\n            };\n\n            return view;\n          }\n        );\n\n        const layers = mapLookupValues(\n          \"layers\",\n          (val: any) => val && val.init !== undefined,\n          val.layers,\n          (key: string, val: BasicSurfaceLayer) => {\n            const layer: LayerInitializer = {\n              init: val.init,\n              key: val.key || key\n            };\n\n            val.init[1].key = layer.key;\n            return layer;\n          }\n        );\n\n        const scene: ISceneOptions = {\n          key: sceneKey,\n          order: val.order,\n          views,\n          layers\n        };\n\n        if (val.order === undefined) {\n          delete scene.order;\n        }\n\n        return scene;\n      }\n    );\n\n    const pipeline: IPipeline = {\n      resources,\n      scenes\n    };\n\n    return await this.base.pipeline(pipeline);\n  }\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","export * from \"./log-changes-layer\";\n","import { Instance, InstanceProvider } from \"../instance-provider\";\nimport {\n  ILayerConstructable,\n  ILayerProps,\n  Layer,\n  LayerInitializer,\n  LayerScene,\n  Surface\n} from \"../surface\";\nimport { Omit } from \"../types\";\nimport { createLayer } from \"../util/create-layer\";\n\n/**\n * Options for generating a Logging layer\n */\ninterface ILogChangesLayerProps<T extends Instance>\n  extends Omit<ILayerProps<T>, \"key\"> {\n  /** Gets the key for the layer. */\n  key: string;\n  /** Provides a header to the log output to make the logs easier to understand */\n  messageHeader?(): string;\n  /** This is the wrapped layer initializer */\n  wrap?: LayerInitializer;\n}\n\n/**\n * This is a layer intended to help debug changes streaming through instances. This layer wraps\n * another layer and analyzes the changes passed to the child layer without editing the layer in any\n * way.\n */\nclass LogChangesLayer<\n  T extends Instance,\n  U extends ILogChangesLayerProps<T>\n> extends Layer<T, U> {\n  /** Default props for the Layer */\n  static defaultProps: ILogChangesLayerProps<any> = {\n    data: new InstanceProvider(),\n    key: \"default\",\n    messageHeader: () => \"\",\n    wrap: createLayer(Layer, {\n      data: new InstanceProvider(),\n      scene: \"default\"\n    })\n  };\n\n  constructor(surface: Surface, scene: LayerScene, props: U) {\n    super(surface, scene, props);\n\n    console.warn(\n      \"Please ensure all debugLayer calls are removed for production:\",\n      props.key\n    );\n  }\n\n  /**\n   * Hand the wrapped layer as a child layer to this layer\n   */\n  childLayers(): LayerInitializer[] {\n    if (!this.props.wrap) return [];\n    this.props.wrap.init[1].key = `debug-wrapper.${this.props.key}`;\n    return [this.props.wrap];\n  }\n\n  /**\n   * Our draw loop. We use this to hijack the changes flowing to our wrapped layer so we can output\n   * significant information about the changes.\n   */\n  draw() {\n    if (!this.props.wrap) return;\n    const changes = this.resolveChanges(true);\n    if (changes.length === 0) return;\n    const { messageHeader = () => \"\" } = this.props;\n\n    console.warn(`${messageHeader()}\\n`, {\n      totalChanges: changes.length,\n      changes\n    });\n  }\n\n  /**\n   * Log the shader information of the layer\n   */\n  initShader() {\n    if (!this.props.wrap) return null;\n\n    const layer = new this.props.wrap.init[0](\n      this.surface,\n      this.scene,\n      this.props.wrap.init[1]\n    );\n    const toProcess = layer.childLayers();\n    const childLayers: { [key: string]: {} } = {};\n\n    while (toProcess.length > 0) {\n      const child = toProcess.pop();\n      if (!child) continue;\n      const childLayer = new child.init[0](\n        this.surface,\n        this.scene,\n        child.init[1]\n      );\n\n      childLayers[childLayer.id] = {\n        shaderIO: childLayer.initShader()\n      };\n\n      childLayer.childLayers().forEach(l => toProcess.push(l));\n    }\n\n    console.warn(`Shader IO: ${this.id}\\n`, {\n      shaderIO: layer.initShader(),\n      childLayers\n    });\n\n    return null;\n  }\n}\n\n/**\n * Can use this instead of createLayer to view changes streaming through a layer.\n */\nexport function debugLayer<T extends Instance, U extends ILayerProps<T>>(\n  layerClass: ILayerConstructable<T> & { defaultProps: U },\n  props: Omit<U, \"key\" | \"data\"> & Partial<Pick<U, \"key\" | \"data\">>\n): LayerInitializer {\n  const initializer: LayerInitializer = createLayer(LogChangesLayer, {\n    messageHeader: () => `CHANGES FOR: ${initializer.init[1].key}`,\n    wrap: createLayer(layerClass, props),\n    data: props.data\n  });\n\n  return initializer;\n}\n","export * from \"./post-process\";\nexport * from \"./view/projection-screen\";\nexport * from \"./view/view-screen\";\nexport * from \"./base-effects\";\nexport * from \"./commands\";\n","import { GLSettings } from \"../../gl\";\nimport { Texture } from \"../../gl/texture\";\nimport {\n  Instance,\n  InstanceProvider,\n  observable\n} from \"../../instance-provider\";\nimport { Vec2 } from \"../../math/vector\";\nimport { IRenderTextureResource } from \"../../resources\";\nimport {\n  IRenderTextureResourceRequest,\n  textureRequest\n} from \"../../resources/texture/render-texture-resource-request\";\nimport { ILayerProps, Layer } from \"../../surface\";\nimport {\n  Color,\n  InstanceAttributeSize,\n  IShaderInitialization,\n  IUniform,\n  ShaderInjectionTarget,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../types\";\nimport { CommonMaterialOptions, isDefined } from \"../../util\";\nimport { flatten2D } from \"../../util/array\";\n\nclass PostProcessInstance extends Instance {\n  @observable tint: Color = [1, 1, 1, 1];\n  request: IRenderTextureResourceRequest;\n}\n\nexport interface IPostProcessLayer extends ILayerProps<PostProcessInstance> {\n  /** List of resource names and their respective keys to apply  */\n  buffers: Record<string, IRenderTextureResource | undefined>;\n  /**\n   * This is the fragment shader that will handle the operation to perform\n   * computations against all of the input shaders.\n   */\n  fs: string;\n  /**\n   * Additional uniforms to inject into the program.\n   */\n  uniforms?: IUniform[];\n}\n\n/**\n * Use an empty texture as a shim for failed resource manager texture fetch.\n */\nconst emptyTexture = new Texture({\n  data: {\n    width: 2,\n    height: 2,\n    buffer: new Uint8Array(16)\n  }\n});\n\n/**\n * This layer takes in several resources and sets up an appropriate geometry and\n * shader IO to allow for an aggregation shader to be specified.\n */\nexport class PostProcessLayer extends Layer<\n  PostProcessInstance,\n  IPostProcessLayer\n> {\n  static defaultProps: IPostProcessLayer = {\n    key: \"\",\n    data: new InstanceProvider<PostProcessInstance>([\n      new PostProcessInstance({})\n    ]),\n    buffers: {},\n    fs: \"void main() { gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\"\n  };\n\n  initShader(): IShaderInitialization<PostProcessInstance> {\n    const { buffers, fs } = this.props;\n    const dummyInstance = new PostProcessInstance({});\n\n    const vertexToNormal: Vec2[] = [\n      [-1, -1],\n      [1, -1],\n      [-1, 1],\n      [1, 1]\n    ];\n\n    const texCoord: Vec2[] = vertexToNormal.map(v => [\n      v[0] === 1 ? 1 : 0,\n      v[1] === 1 ? 1 : 0\n    ]);\n\n    /**\n     * Map all of the buffers to sampler uniforms with the specified keys as the\n     * uniform names.\n     */\n    const resourceUniforms: IUniform[] = flatten2D<IUniform>(\n      Object.keys(buffers)\n        .map(uniformName => {\n          const buffer = buffers[uniformName];\n          if (!buffer) return void 0;\n          const resourceKey = buffer.key;\n\n          const request = textureRequest({\n            key: resourceKey\n          });\n\n          return [\n            {\n              name: uniformName,\n              shaderInjection: ShaderInjectionTarget.FRAGMENT,\n              size: UniformSize.TEXTURE,\n              update: () => {\n                this.resource.request(this, dummyInstance, request);\n                return request.texture || emptyTexture;\n              }\n            },\n            {\n              name: `${uniformName}_size`,\n              shaderInjection: ShaderInjectionTarget.FRAGMENT,\n              size: UniformSize.TWO,\n              update: () => {\n                this.resource.request(this, dummyInstance, request);\n                const data = (request.texture || emptyTexture).data;\n                return [data?.width || 1, data?.height || 1];\n              }\n            }\n          ];\n        })\n        .filter(isDefined)\n    );\n\n    return {\n      drawMode: GLSettings.Model.DrawMode.TRIANGLE_STRIP,\n      instanceAttributes: [\n        {\n          name: \"tint\",\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.tint\n        }\n      ],\n      uniforms: resourceUniforms.concat(this.props.uniforms || []),\n      vertexAttributes: [\n        {\n          name: \"vertex\",\n          size: VertexAttributeSize.TWO,\n          update: (vertex: number) => vertexToNormal[vertex]\n        },\n        {\n          name: \"tex\",\n          size: VertexAttributeSize.TWO,\n          update: (vertex: number) => texCoord[vertex]\n        }\n      ],\n      vertexCount: 4,\n      vs: require(\"./post-process-layer.vs\"),\n      fs\n    };\n  }\n\n  getMaterialOptions() {\n    return CommonMaterialOptions.transparentImageBlending;\n  }\n}\n","/**\n * This file will contain convenience operations for manipulating arrays of any sort.\n * These methods are tested to be the fastest (currently known) version to accomplish\n * a goal.\n */\n\n/**\n * This method flattens a 2D depth of data.\n */\nexport function flatten2D<T>(array: T[][]) {\n  const c = [];\n\n  for (let i = 0, end = array.length; i < end; ++i) {\n    const temp = array[i];\n\n    for (let k = 0, endk = temp.length; k < endk; ++k) {\n      c.push(temp[k]);\n    }\n  }\n\n  return c;\n}\n","module.exports = \"varying vec2 texCoord;\\nvoid main() {\\ngl_Position = vec4(vertex, 0.0, 1.0);\\ntexCoord = tex;\\n}\"","import { Bounds } from \"../../math/primitives/bounds\";\nimport { add3 } from \"../../math/vector\";\nimport { IViewProps, View } from \"../../surface\";\nimport { LayerScene } from \"../../surface/layer-scene\";\nimport { Camera, CameraProjectionType } from \"../../util/camera\";\nimport { ProjectionScreen } from \"./projection-screen\";\n\n/**\n * Defines the input metrics of a view for a scene.\n */\nexport interface IViewScreenProps extends IViewProps {}\n\n/**s\n * Type guard to ensure the camera type is orthographic\n */\nfunction isOrthographic(val: Camera): val is Camera {\n  return val.projectionType === CameraProjectionType.ORTHOGRAPHIC;\n}\n\n/**\n * A View renders a perspective of a scene to a given surface or surfaces.\n */\nexport class ViewScreen<TViewProps extends IViewScreenProps> extends View<\n  TViewProps\n> {\n  static defaultProps: IViewScreenProps = {\n    key: \"\",\n    camera: Camera.makeOrthographic(),\n    viewport: {\n      left: 0,\n      right: 0,\n      bottom: 0,\n      top: 0\n    }\n  };\n\n  /** These are the projection methods specific to rendering with this 2D system. */\n  projection: ProjectionScreen = new ProjectionScreen();\n\n  constructor(scene: LayerScene, options: TViewProps) {\n    super(scene, options);\n  }\n\n  /**\n   * This operation makes sure we have the view camera adjusted to the new viewport's needs.\n   * For default behavior this ensures that the coordinate system has no distortion or perspective, orthographic,\n   * top left as 0,0 with +y axis pointing down.\n   */\n  fitViewtoViewport(\n    _surfaceDimensions: Bounds<never>,\n    viewBounds: Bounds<View<IViewProps>>\n  ) {\n    if (isOrthographic(this.props.camera)) {\n      const width = viewBounds.width;\n      const height = viewBounds.height;\n\n      const viewport = {\n        bottom: -height / 2,\n        far: 10000000,\n        left: -width / 2,\n        near: -100,\n        right: width / 2,\n        top: height / 2\n      };\n\n      const scaleX = 1 / this.pixelRatio;\n      const scaleY = 1 / this.pixelRatio;\n      const camera = this.props.camera;\n\n      camera.projectionOptions = Object.assign(\n        camera.projectionOptions,\n        viewport\n      );\n      camera.position = [\n        viewBounds.width / (2.0 * this.pixelRatio),\n        viewBounds.height / (2.0 * this.pixelRatio),\n        camera.position[2]\n      ];\n      camera.scale = [scaleX, -scaleY, 1.0];\n      // Always face the -z direction\n      camera.lookAt(add3(camera.position, [0, 0, -1]), [0, 1, 0]);\n      camera.update();\n\n      this.projection.viewBounds = viewBounds;\n      viewBounds.d = this;\n      this.projection.screenBounds = new Bounds<View<TViewProps>>({\n        height: this.viewBounds.height / this.pixelRatio,\n        width: this.viewBounds.width / this.pixelRatio,\n        x: this.viewBounds.x / this.pixelRatio,\n        y: this.viewBounds.y / this.pixelRatio\n      });\n      this.screenBounds.d = this;\n    } else if (!isOrthographic(this.props.camera)) {\n      console.warn(\"ViewScreen does not support non-orthographic cameras.\");\n    }\n  }\n\n  willUpdateProps(_newProps: IViewScreenProps) {\n    // NOOP\n  }\n}\n","export * from \"./gauss-horizontal-blur/gauss-horizontal-blur\";\nexport * from \"./gauss-vertical-blur/gauss-vertical-blur\";\nexport * from \"./box-sample/box-sample\";\nexport * from \"./bloom/bloom\";\nexport * from \"./draw/draw\";\n\nimport { bloom } from \"./bloom/bloom\";\nimport { boxSample } from \"./box-sample/box-sample\";\nimport { draw } from \"./draw/draw\";\nimport { gaussHorizontalBlur } from \"./gauss-horizontal-blur/gauss-horizontal-blur\";\nimport { gaussVerticalBlur } from \"./gauss-vertical-blur/gauss-vertical-blur\";\n\nexport const PostEffect = {\n  bloom,\n  boxSample,\n  draw,\n  gaussHorizontalBlur,\n  gaussVerticalBlur\n};\n","module.exports = \"${import: camera}\\nvarying vec2 texCoord;\\nvoid main() {\\nfloat dtx = 1.0 / viewSize.x;\\nvec3 result = texture2D(color, texCoord).rgb * weight[0];\\nfloat index = 1.0;\\nvec2 delta = vec2(0.0, 0.0);\\nfor(int i = 1; i < weight_length; ++i, index += 1.0) {\\ndelta.x = dtx * index;\\nresult += texture2D(color, texCoord + delta).rgb * weight[i];\\nresult += texture2D(color, texCoord - delta).rgb * weight[i];\\n}\\ngl_FragColor = vec4(result, 1.0);\\n}\"","module.exports = \"${import: camera}\\nvarying vec2 texCoord;\\nvoid main() {\\nfloat dty = 1.0 / viewSize.x;\\nvec3 result = texture2D(color, texCoord).rgb * weight[0];\\nfloat index = 1.0;\\nvec2 delta = vec2(0.0, 0.0);\\nfor(int i = 1; i < weight_length; ++i, index += 1.0) {\\ndelta.y = dty * index;\\nresult += texture2D(color, texCoord + delta).rgb * weight[i];\\nresult += texture2D(color, texCoord - delta).rgb * weight[i];\\n}\\ngl_FragColor = vec4(result, 1.0);\\n}\"","module.exports = \"${import: camera}\\nvarying vec2 texCoord;\\nvoid main() {\\nvec2 texelSize = 1.0 / viewSize;\\nvec4 o = texelSize.xyxy * vec2(-delta, delta).xxyy;\\nvec4 s =\\ntexture2D(color, texCoord + o.xy) + texture2D(color, texCoord + o.zy) +\\ntexture2D(color, texCoord + o.xw) + texture2D(color, texCoord + o.zw);\\ngl_FragColor = s * 0.25;\\n}\"","module.exports = \"varying vec2 texCoord;\\nvoid main() {\\nvec3 result = texture2D(color, texCoord).rgb;\\nresult += texture2D(glow, texCoord).rgb * 1.3;\\ngl_FragColor = vec4(result, 1.0);\\n}\"","import { Camera2D, View2D } from \"../2d\";\nimport { CommandCallback, CommandLayer, createView } from \"../surface\";\nimport { createLayer } from \"../util/create-layer\";\n\n/**\n * This sets up essentially a callback within the pipeline that lets you execute\n * arbitrary commands such as GL or built in Surface commands or simply run a\n * script in mid render pipeline.\n *\n * This is very open ended on what it is intended to do. You can really hose\n * performance if you use this without understanding how rendering pipelines\n * work or by not following documentation correctly.\n */\nexport function commands(commands: CommandCallback) {\n  return {\n    views: {\n      screen: createView(View2D, {\n        camera: new Camera2D(),\n        viewport: { left: 0, top: 0, width: 1, height: 1 }\n      })\n    },\n    layers: {\n      screen: createLayer(CommandLayer, {\n        commands\n      })\n    }\n  };\n}\n"],"sourceRoot":""}