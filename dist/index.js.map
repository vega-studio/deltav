{"version":3,"sources":["webpack://network-bubble-chart/webpack/universalModuleDefinition","webpack://network-bubble-chart/webpack/bootstrap","webpack://network-bubble-chart/./src/voidgl/types.ts","webpack://network-bubble-chart/external \"three\"","webpack://network-bubble-chart/./src/voidgl/util/index.ts","webpack://network-bubble-chart/./src/voidgl/instance-provider/index.ts","webpack://network-bubble-chart/./src/voidgl/primitives/bounds.ts","webpack://network-bubble-chart/./src/voidgl/surface/buffer-management/buffer-manager-base.ts","webpack://network-bubble-chart/./src/voidgl/instance-provider/instance.ts","webpack://network-bubble-chart/./src/voidgl/surface/layer.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/types.ts","webpack://network-bubble-chart/./src/voidgl/surface/layer-processing/layer-buffer-type.ts","webpack://network-bubble-chart/./src/voidgl/shaders/processing/index.ts","webpack://network-bubble-chart/./src/voidgl/primitives/index.ts","webpack://network-bubble-chart/./node_modules/debug/src/browser.js","webpack://network-bubble-chart/./src/voidgl/util/vector.ts","webpack://network-bubble-chart/./src/voidgl/surface/layer-processing/generate-layer-model.ts","webpack://network-bubble-chart/./src/voidgl/surface/texture/index.ts","webpack://network-bubble-chart/./src/voidgl/util/identify-by-key.ts","webpack://network-bubble-chart/./src/voidgl/util/shader-templating.ts","webpack://network-bubble-chart/./src/voidgl/util/uid.ts","webpack://network-bubble-chart/./src/voidgl/instance-provider/observable.ts","webpack://network-bubble-chart/./src/voidgl/surface/view.ts","webpack://network-bubble-chart/./src/voidgl/surface/scene.ts","webpack://network-bubble-chart/./src/voidgl/surface/texture/label-atlas-resource.ts","webpack://network-bubble-chart/./src/voidgl/surface/texture/base-atlas-resource.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/edges/types.ts","webpack://network-bubble-chart/./src/voidgl/surface/buffer-management/uniform-buffering/uniform-diff-processor.ts","webpack://network-bubble-chart/./src/voidgl/surface/buffer-management/instance-attribute-buffering/instance-attribute-diff-processor.ts","webpack://network-bubble-chart/./src/voidgl/util/webgl-stat.ts","webpack://network-bubble-chart/./src/voidgl/util/view-camera.ts","webpack://network-bubble-chart/./src/voidgl/shaders/template-vars.ts","webpack://network-bubble-chart/./src/voidgl/util/chart-camera.ts","webpack://network-bubble-chart/./src/voidgl/surface/event-manager.ts","webpack://network-bubble-chart/./src/voidgl/surface/mouse-event-manager.ts","webpack://network-bubble-chart/./src/voidgl/surface/layer-processing/generate-layer-material.ts","webpack://network-bubble-chart/./src/voidgl/surface/layer-processing/generate-layer-geometry.ts","webpack://network-bubble-chart/./src/voidgl/surface/layer-processing/generate-default-scene.ts","webpack://network-bubble-chart/./src/voidgl/shaders/processing/shader-module-unit.ts","webpack://network-bubble-chart/./src/voidgl/shaders/processing/shader-module.ts","webpack://network-bubble-chart/./src/voidgl/surface/layer-processing/inject-shader-io.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/labels/index.ts","webpack://network-bubble-chart/./src/voidgl/surface/texture/label-rasterizer.ts","webpack://network-bubble-chart/./src/voidgl/surface/texture/image-atlas-resource.ts","webpack://network-bubble-chart/./src/voidgl/surface/texture/color-rasterizer.ts","webpack://network-bubble-chart/./src/voidgl/surface/texture/color-atlas-resource.ts","webpack://network-bubble-chart/./src/voidgl/surface/texture/sub-texture.ts","webpack://network-bubble-chart/./src/voidgl/surface/texture/atlas.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/images/index.ts","webpack://network-bubble-chart/./src/voidgl/util/data-bounds.ts","webpack://network-bubble-chart/./src/voidgl/primitives/absolute-position.ts","webpack://network-bubble-chart/./src/voidgl/surface/buffer-management/base-diff-processor.ts","webpack://network-bubble-chart/./src/voidgl/shaders/processing/uniform-processing.ts","webpack://network-bubble-chart/./src/voidgl/util/emit-once.ts","webpack://network-bubble-chart/./src/voidgl/shaders/processing/formatting.ts","webpack://network-bubble-chart/./src/voidgl/util/mouse.ts","webpack://network-bubble-chart/./src/voidgl/shaders/util/extend-shader.ts","webpack://network-bubble-chart/./src/voidgl/util/auto-easing-method.ts","webpack://network-bubble-chart/./src/voidgl/util/common-options.ts","webpack://network-bubble-chart/./src/voidgl/util/easing-props.ts","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/shader-fragments/no-op.fs","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/shader-fragments/no-op.vs","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/util-modules.ts","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/shader-fragments/no-picking.fs","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/shader-fragments/no-picking.vs","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/shader-fragments/picking.fs","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/shader-fragments/picking.vs","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/picking.ts","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/shader-fragments/fsin.vs","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/shader-fragments/fcos.vs","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/shader-fragments/circular-arc.vs","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/shader-fragments/bezier2.vs","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/shader-fragments/bezier1.vs","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/shader-fragments/constants/to-radians.vs","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/shader-fragments/constants/to-degrees.vs","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/shader-fragments/constants/pi2.vs","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/shader-fragments/constants/pi.vs","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/shader-fragments/constants/pi_4.vs","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/shader-fragments/constants/pi_2.vs","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/math-modules.ts","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/instancing.ts","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/frame-metrics.ts","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/shader-fragments/projection.vs","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/camera-metrics.ts","webpack://network-bubble-chart/./src/voidgl/shaders/base-modules/index.ts","webpack://network-bubble-chart/./src/voidgl/shaders/index.ts","webpack://network-bubble-chart/./src/voidgl/surface/texture/atlas-resource-manager.ts","webpack://network-bubble-chart/./src/voidgl/util/quad-tree.ts","webpack://network-bubble-chart/./src/voidgl/surface/event-managers/layer-mouse-events.ts","webpack://network-bubble-chart/./src/voidgl/util/color-picking-analysis.ts","webpack://network-bubble-chart/./src/voidgl/shaders/processing/metrics-processing.ts","webpack://network-bubble-chart/./src/voidgl/shaders/processing/easing-processing.ts","webpack://network-bubble-chart/./src/voidgl/shaders/fragments/active-attribute-handler.vs","webpack://network-bubble-chart/./src/voidgl/shaders/processing/attribute-processing.ts","webpack://network-bubble-chart/./src/voidgl/surface/layer-processing/pack-attributes.ts","webpack://network-bubble-chart/./src/voidgl/surface/layer-processing/expand-easing-attributes.ts","webpack://network-bubble-chart/./src/voidgl/surface/layer-processing/expand-atlas-attributes.ts","webpack://network-bubble-chart/./src/voidgl/shaders/processing/shader-processor.ts","webpack://network-bubble-chart/./src/voidgl/surface/layer-surface.ts","webpack://network-bubble-chart/./src/voidgl/surface/index.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/rings/ring-layer.vs","webpack://network-bubble-chart/./src/voidgl/base-layers/rings/ring-layer.fs","webpack://network-bubble-chart/./src/voidgl/base-layers/rings/ring-layer.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/rings/ring-instance.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/rings/index.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/rectangle/rectangle-instance.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/rectangle/rectangle-layer.vs","webpack://network-bubble-chart/./src/voidgl/base-layers/rectangle/rectangle-layer.fs","webpack://network-bubble-chart/./src/voidgl/base-layers/rectangle/rectangle-layer.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/rectangle/index.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/labels/label-instance.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/labels/label-layer.vs","webpack://network-bubble-chart/./src/voidgl/base-layers/labels/label-layer.fs","webpack://network-bubble-chart/./src/voidgl/base-layers/labels/label-layer.ts","webpack://network-bubble-chart/./src/voidgl/surface/texture/image-rasterizer.ts","webpack://network-bubble-chart/./src/voidgl/surface/texture/atlas-manager.ts","webpack://network-bubble-chart/./src/voidgl/surface/texture/pack-node.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/images/image-instance.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/images/image-layer.vs","webpack://network-bubble-chart/./src/voidgl/base-layers/images/image-layer.fs","webpack://network-bubble-chart/./src/voidgl/base-layers/images/image-layer.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/edges/edge-instance.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/edges/shader/edge-layer.fs","webpack://network-bubble-chart/./src/voidgl/base-layers/edges/shader/edge-layer-screen-curve.vs","webpack://network-bubble-chart/./src/voidgl/base-layers/edges/shader/edge-layer.vs","webpack://network-bubble-chart/./src/voidgl/base-layers/edges/shader/edge-layer-bezier2.vs","webpack://network-bubble-chart/./src/voidgl/base-layers/edges/shader/edge-layer-bezier.vs","webpack://network-bubble-chart/./src/voidgl/base-layers/edges/shader/edge-layer-line.vs","webpack://network-bubble-chart/./src/voidgl/base-layers/edges/edge-picking.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/edges/edge-layer.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/edges/index.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/circles/circle-instance.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/circles/circle-layer.vs","webpack://network-bubble-chart/./src/voidgl/base-layers/circles/circle-layer.fs","webpack://network-bubble-chart/./src/voidgl/primitives/point.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/circles/circle-layer.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/circles/index.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/arcs/arc-instance.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/arcs/arc-layer.fs","webpack://network-bubble-chart/./src/voidgl/base-layers/arcs/arc-layer-screen-space.vs","webpack://network-bubble-chart/./src/voidgl/base-layers/arcs/arc-layer.vs","webpack://network-bubble-chart/./src/voidgl/surface/layer-interaction-handler.ts","webpack://network-bubble-chart/./src/voidgl/surface/buffer-management/uniform-buffering/uniform-quad-diff-processor.ts","webpack://network-bubble-chart/./src/voidgl/surface/buffer-management/uniform-buffering/uniform-color-diff-processor.ts","webpack://network-bubble-chart/./src/voidgl/surface/buffer-management/instance-attribute-buffering/instance-attribute-quad-diff-processor.ts","webpack://network-bubble-chart/./src/voidgl/surface/buffer-management/instance-attribute-buffering/instance-attribute-color-diff-processor.ts","webpack://network-bubble-chart/./src/voidgl/surface/buffer-management/uniform-buffering/uniform-buffer-manager.ts","webpack://network-bubble-chart/./src/voidgl/surface/buffer-management/instance-attribute-packed-buffering/instance-attribute-packing-buffer-manager.ts","webpack://network-bubble-chart/./src/voidgl/surface/buffer-management/instance-attribute-buffering/instance-attribute-buffer-manager.ts","webpack://network-bubble-chart/./src/voidgl/surface/buffer-management/instance-diff-manager.ts","webpack://network-bubble-chart/./src/voidgl/instance-provider/instance-provider.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/arcs/arc-layer.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/arcs/index.ts","webpack://network-bubble-chart/./src/voidgl/base-layers/index.ts","webpack://network-bubble-chart/./src/voidgl/util/tracked-quad-tree.ts","webpack://network-bubble-chart/./src/voidgl/util/reference-camera.ts","webpack://network-bubble-chart/./node_modules/ms/index.js","webpack://network-bubble-chart/./node_modules/debug/src/debug.js","webpack://network-bubble-chart/./node_modules/process/browser.js","webpack://network-bubble-chart/external \"bowser\"","webpack://network-bubble-chart/./src/voidgl/util/extend-shader-io.ts","webpack://network-bubble-chart/./src/voidgl/util/animation-helper.ts","webpack://network-bubble-chart/./src/voidgl/base-event-managers/basic-camera-controller.ts","webpack://network-bubble-chart/./src/voidgl/base-event-managers/index.ts","webpack://network-bubble-chart/./src/voidgl/index.ts","webpack://network-bubble-chart/./src/index.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__1__","__WEBPACK_EXTERNAL_MODULE__157__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","InstanceAttributeSize","InstanceBlockIndex","instanceAttributeSizeFloatCount","_a","ONE","TWO","THREE","FOUR","ATLAS","UniformSize","VertexAttributeSize","ShaderInjectionTarget","PickType","InstanceDiffType","__export","Bounds","options","this","x","y","width","height","left","top","bottom","right","emptyBounds","containsPoint","point","encapsulate","item","Math","abs","fits","bounds","hitBounds","isInside","toString","isBufferLocation","val","buffer","isBufferLocationGroup","propertyToBufferLocation","BufferManagerBase","layer","scene","easing_props_1","observable_1","instanceUID","Instance","changes","_easing","Map","observableStorage","_uid","newUID","_id","id","active","_this","_observer","oldObserver","clear","remove","clearEasing","easingId","getEasing","attributeName","easing","EasingProps","resourceTrigger","console","warn","__decorate","observable","Three","types_1","util_1","identify_by_key_1","instance_diff_manager_1","layer_interaction_handler_1","Layer","_super","props","depth","instanceById","instanceVertexCount","needsViewDrawn","animationEndTime","assign","defaultProps","picking","NONE","ALL","pickingMethods","getInstancePickingMethods","currentPickMode","hitTest","quadTree","TrackedQuadTree","boundsAccessor","type","SINGLE","uidToInstance","__extends","_bufferManager","_bufferType","baseShaderModules","shaderIO","additionalImportsVS","additionalImportsFS","push","instanceAttributes","find","check","Boolean","fs","vs","destroy","bufferManager","removeLayer","removeFromScene","didUpdateProps","draw","change","instance","bufferLocations","changeList","data","length","diffManager","processing","processor","incomingChangeList","end","getBufferLocations","values","commit","resolve","updateUniforms","Error","getModelType","drawMode","TrianglesDrawMode","modelType","Mesh","getMaterialOptions","initShader","uniforms","vertexAttributes","vertexCount","makeInstanceAttribute","block","blockIndex","size","update","atlas","makeUniform","shaderInjection","qualifier","setBufferManager","InstanceDiffManager","makeProcessor","interactions","LayerInteractionHandler","setBufferType","undefined","shouldDrawView","oldProps","newProps","key","uniform","materialUniforms","forEach","materialUniform","willUpdateInstances","_changes","willUpdateProps","_newProps","didUpdate","IdentifyByKey","AnchorType","ScaleType","LayerBufferType","webgl_stat_1","instance_attribute_buffer_manager_1","instance_attribute_packing_buffer_manager_1","uniform_buffer_manager_1","debug","getLayerBufferType","_gl","UNIFORM","attributesUsed","bufferType","WebGLStat","HARDWARE_INSTANCING","attribute","ceil","MAX_VERTEX_ATTRIBUTES","max","INSTANCE_ATTRIBUTE_PACKING","INSTANCE_ATTRIBUTE","makeLayerBufferManager","gl","InstanceAttributeBufferManager","InstanceAttributePackingBufferManager","UniformBufferManager","process","load","storage","e","env","DEBUG","log","Function","apply","arguments","formatArgs","args","useColors","namespace","humanize","diff","color","splice","index","lastC","replace","match","save","namespaces","removeItem","navigator","userAgent","toLowerCase","document","documentElement","style","WebkitAppearance","firebug","exception","table","parseInt","RegExp","$1","chrome","local","localStorage","localstorage","colors","formatters","j","v","JSON","stringify","err","message","enable","sqrt","min","add1","copy1","vec","divide1","inverse1","scale1","scale","subtract1","max1","min1","multiply1","dot1","linear1","start","t","length1","add2","copy2","divide2","inverse2","max2","min2","scale2","subtract2","multiply2","dot2","linear2","length2","add3","copy3","divide3","inverse3","scale3","subtract3","multiply3","linear3","length3","dot3","max3","min3","add4","copy4","divide4","inverse4","scale4","subtract4","multiply4","dot4","linear4","length4","max4","min4","isVec1","Array","isArray","isVec2","isVec3","isVec4","vec1","out","_i","slice","iMax","next","vec2","vec3","vec4","vec1Methods","add","copy","divide","dot","inverse","linear","multiply","subtract","vec2Methods","vec3Methods","vec4Methods","VecMath","generateLayerModel","geometry","material","modelInfo","model","isMesh","TriangleStripDrawMode","shaderTemplate","templateOptions","shader","required","onError","onToken","matched","noValueProvided","notFound","shaderOptions","shaderResults","_x","set","keys","option","results","resolvedShaderOptions","shaderProvidedOptions","unresolvedProvidedOptions","unresolvedShaderOptions","msg","error","UID","uid","CUID","colorUID","uid_1","ObservableMonitoring","setObservableMonitor","enabled","gatherIds","observableIds","getObservableMonitorIds","observableNamesToUID","target","propertyUID","newVal","observer","instanceUpdated","absolute_position_1","bounds_1","view_camera_1","isOrthographic","ClearFlags","View","pixelRatio","devicePixelRatio","needsDraw","screenToPixelSpace","pixelSpaceToScreen","screenToView","viewBounds","viewToScreen","screenToWorld","view","world","camera","offset","viewCamera","ViewCameraType","CUSTOM","worldToScreen","screen","viewToWorld","worldToView","fitViewtoViewport","surfaceDimensions","CONTROLLED","baseCamera","getAbsolutePositionBounds","viewport","far","near","position","z","updateMatrix","updateMatrixWorld","updateProjectionMatrix","screenBounds","DEFAULT_VIEW_ID","sortByDepth","a","b","Scene","container","pickingContainer","layers","sortIsDirty","viewById","frustumCulled","autoUpdate","addLayer","addView","indexOf","sortLayers","sort","DEFAULT_SCENE_ID","LabelAtlasResource","label","BaseAtlasResource","sampleScale","EdgeScaleType","EdgeType","EdgeBroadphase","base_diff_processor_1","buffer_manager_base_1","VECTOR_ACCESSORS","EMPTY","UniformDiffProcessor","addInstance","manager","_propIds","uniformCluster","changeInstance","updateInstance","removeInstance","uniformRangeStart","range","instanceData","instanceUniform","k","endk","resource","setTargetAtlas","activeAttribute","BaseDiffProcessor","DiffMode","InstanceAttributeDiffProcessor","diffMode","PARTIAL","bufferAttributeUpdateRange","bufferAttributeWillUpdate","updateInstancePartial","newBufferLocations","propIds","location","updateValue","updateRange","childLocations","attributeChangeUID","propertyToLocation","getUpdateAllPropertyIdList","packUID","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","getActiveAttributePropertyId","updateInstanceFull","updates","bufferAttribute","needsUpdate","count","getInstanceCount","FULL","getProgramInfo","program","result","attributeCount","attributes","uniformCount","activeUniforms","getProgramParameter","ACTIVE_UNIFORMS","activeAttributes","ACTIVE_ATTRIBUTES","enums","35664","35665","35666","35667","35668","35669","35670","35671","35672","35673","35674","35675","35676","35678","35680","5120","5121","5122","5123","5124","5125","5126","blocks","getActiveUniform","typeName","getActiveAttrib","MAX_VERTEX_UNIFORMS","MAX_FRAGMENT_UNIFORMS","WEBGL_SUPPORTED","MAX_TEXTURE_SIZE","HARDWARE_INSTANCING_ANGLE","canvas","createElement","WebGLRenderingContext","getContext","getAContext","getParameter","MAX_VERTEX_UNIFORM_VECTORS","MAX_FRAGMENT_UNIFORM_VECTORS","MAX_VERTEX_ATTRIBS","getExtension","initStats","ViewCamera","templateVars","easingMethod","extend","extendHeader","T","chartCameraUID","applyArray","source","concat","ChartCamera","_offset","_scale","_needsViewDrawn","setId","setOffset","setScale","EventManager","getProjection","viewId","mouseManager","getView","getViewScreenBounds","setMouseManager","mouse_1","quad_tree_1","isDefined","MouseEventManager","views","controllers","handlesWheelEvents","eventCleanup","_waitingForRender","getViewsUnderMouse","mouse","hitViews","query","resize","context","setViews","setControllers","addContextListeners","QuadTree","addAll","map","filter","startView","element","startPosition","wheelHandler","event","eventElementPosition","interaction","makeInteraction","wheel","makeWheel","controller","handleWheel","stopPropagation","preventDefault","onwheel","addEventListener","onmouseleave","waitingForRender","handleMouseOut","onmousemove","handleMouseMove","onmousedown","downViews","canClick","clickStartTime","Date","now","currentPosition","handleMouseDown","button","delta","drag","makeDrag","handleDrag","onmouseup","_event","onmouseover","handleMouseOver","handleMouseUp","handleClick","experiemental","onselectstart","addTouchContextListeners","ontouchstart","ontouchend","ontouchmove","ontouchcancel","previous","current","viewsUnderMouse","normalizeWheel","experimental","onmousewheel","removeEventListener","UNIFORM_SIZE_TO_MATERIAL_TYPE","MATRIX3","MATRIX4","DEFAULT_UNIFORM_VALUE","_b","toMaterialUniform","generateLayerMaterial","layerUniforms","instancingUniforms","materialParams","vertexShader","fragmentShader","generatedUniform","RawShaderMaterial","layer_buffer_type_1","isNumberCluster","generateLayerGeometry","maxInstancesPerBuffer","vertexBuffers","attribute_1","Float32Array","formatError","endj","instanceSize","endk_1","copyWithin","instancingBuffer","instanceStartIndex","BufferGeometry","attribute_3","materialAttribute","BufferAttribute","addAttribute","chart_camera_1","scene_1","view_1","generateDefaultScene","aspectRatio","viewSize","defaultCamera","OrthographicCamera","defaultChartCamera","defaultViewport","defaultView","defaultScene","LOCKED_MODULE_UNIT_MESSAGE","ShaderModuleUnit","_dependents","_content","_isLocked","_moduleId","_compatibility","isLocked","applyAnalyzedContent","content","dependents","lock","shader_module_unit_1","debugModuleVS","debugModuleFS","isUnitCompatible","unit","compatibility","ShaderModule","register","out_1","output","isFSCompatible","FRAGMENT","isVSCompatible","VERTEX","isFinal","analyzeDependents","errors","dependentSet","Set","templateResults","token","trimmedToken","trim","afterToken","substr","moduleContentFound_1","moduleIds","split","pop","mod","has","additionalModules","shaderModuleUnits","included","debugTarget","modifedShader","imports_1","tempShaderModuleUnit","reverse","join","queueIndex","unshift","circularPath","shift","checkCircularDependency","includedModuleContent","moduleContent","expand_atlas_attributes_1","expand_easing_attributes_1","pack_attributes_1","testStartVector","testEndVector","isInstanceAttribute","attr","isVertexAttribute","isUniform","toVertexAttributeInternal","toUniformInternal","sortNeedsUpdateFirstToTop","compareVec","round","injectShaderIO","importResults","moduleInstanceAttributes","moduleUniforms","moduleVertexAttributes","uniformNames","instanceAttributeNames","vertexAttributeNames","gatherIOFromShaderModules","testStart","testEnd","validationRules","validation","test","cpu","ignoreEndValueCheck","ignoreOverTimeCheck","validateInstanceAttributes","generateEasingAttributes","addedUniforms","generateAtlasResourceUniforms","addedInstanceAttributes","allUniforms","allInstanceAttributes","packAttributes","floor","LabelRasterizer","awaitContext","Promise","setTimeout","sent","calculateLabelSize","calculateTexture","calculateTrucatedText","sampleScaling","drawLabel","truncatedText","measureContents","minX","minY","maxX","maxY","rasterization","texture","createCroppedCanvas","maxWidth","text","firstTest","cursor","safety","nextCursor","cropped","imageSmoothingEnabled","drawImage","fontSize","getLabelRasterizationFontSize","fillStyle","font","makeCSSFont","measureText","fillText","potentialCanvas","fontWeight","fontFamily","imageData","getImageData","render","renderSync","ImageAtlasResource","image","ColorRasterizer","limit","makeCSS","g","opacity","fillRect","ColorAtlasResource","SubTexture","atlasReferenceID","atlasTexture","atlasTL","atlasTR","atlasBL","atlasBR","widthOnAtlas","heightOnAtlas","isValid","pixelWidth","pixelHeight","pack_node_1","sub_texture_1","AtlasSize","Atlas","validResources","textureSettings","packing","PackNode","updateTexture","invalidateResource","zero","setManager","registerResource","removeResource","delete","redoneCanvas","dispose","Texture","generateMipmaps","premultiplyAlpha","_isValid","DataBounds","data_bounds_1","ref","scaleRatio","parse","num","parseFloat","isNaN","reference","top_1","sizeToType","1","2","3","4","9","16","99","UniformProcessing","metricsProcessor","generateUniformAttributePacking","uniformPackingBufferName","totalInstanceUniformBlocks","fill","Vector4","injectionType","injection","toEmit","emitOnce","callback","emit","clearTimeout","flushEmitOnce","getAttributeShaderName","browser","vector_1","IE_ADJUSTMENT","OLD_IE_ADJUSTMENT","MAX_FIREFOX_WHEELDELTA","lowPassY","LOW_PASS_U0","LOW_PASS_U1","LOW_PASS_U2","LOW_PASS_U3","firefox","deltaX","deltaY","sign","msie","version","wheelDeltaX","wheelDeltaY","wheelDelta","detail","msedge","relative","mouseX","mouseY","eventX","eventY","nativeEvent","pageX","pageY","clientX","clientY","scrollLeft","scrollTop","body","offsetParent","offsetLeft","offsetTop","shader_templating_1","template_vars_1","extendShader","baseVS","baseFS","extendedVS","extendedFS","header","AutoEasingLoopStyle","pow","sin","PI","GPU_PI","clamp","minVal","maxVal","easeOutElasticGPU","easeBackInGPU","continuousSinusoidalGPU","AutoEasingMethod","gpu","duration","method","delay","loop","methodName","immediate","_start","_t","easeInQuad","time","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeOutElastic","easeBackIn","easeBackOut","t1","easeBackInOut","a1","t2","continuousSinusoidal","CONTINUOUS","direction","amplitude","CommonMaterialOptions","transparentShape","premultipliedAlpha","transparent","transparentImage","blending","CustomBlending","blendSrc","OneFactor","isManualStart","isTimeSet","setAutomatic","setStart","setTiming","_layer","processing_1","constants","allConstants","methods","surface","frameMetrics","currentTime","projectionMatrix","elements","matrix","label_atlas_resource_1","toInstanceIOValue","AtlasResourceManager","targetAtlas","requestQueue","requestLookup","atlasManager","dequeueRequests","didDequeue","resources","requests","this_1","updateAtlas","atlasRequests_1","request","requestAnimationFrame","from","entries","getAtlasTexture","atlasRequests","existingRequests","filterQuery","queryValues","filtered","obj","Quadrants","mid","TL","Node","TR","BL","BR","children","nodes","child","doAdd","cover","childrenProps","MAX_VALUE","allChildren","gatherChildren","area","list","visit","queryBounds","queryPoint","cb","finished","LayerMouseEvents","isOver","sceneViews","getSceneViewsUnderMouse","sceneViewByViewId","sceneView","viewItem","getMouseByViewId","viewMouseByViewId","handleInteraction","handleMouseClick","_drag","handleMouseDrag","sceneViews_1","handleSceneView","_e","_flag","updateColorPickRange","allSceneViews","currentSceneViews","analyzeColorPickingRendering","pickingData","allColors","colorData","dataHeight","dataWidth","nearestColor","uniqueColors","pixelIndex","distance","row","dx","dy","testDistance","MetricsProcessing","calculateUniformBlockUseage","instanceMaxBlock","blocksPerInstance","maxUniforms","maxUniformsForInstancing","EasingProcessing","methodSizes","sizeType","auto_easing_method_1","formatting_1","VECTOR_COMPONENTS","orderByPriority","makeVectorSwizzle","AttributeProcessing","uniformProcessor","declarations","processDeclarations","destructuring","processDestructuring","processVertexAttributes","processInstanceAttributeBufferStrategy","processInstanceAttributePackingBufferStrategy","orderedAttributes","processDestructuringInstanceAttribute","processDestructuringInstanceAttributePacking","processDestructuringUniformBuffer","processAutoEasingTiming","processDestructureBlocks","startTime","REPEAT","REFLECT","timePassed","pingPong","maxBlock","Block","available","setAttribute","ensureSizes","newBlock","BLANK_EASING_PROPS","isEasingAttribute","usedInstanceAttributes","easingAttributes","instanceAttributes_1","easingIds","providedUID","name_1","easingUID","attributeDataShare","attributeDelay","attributeDuration","easingValues","timeValue","childAttributes","startAttr","parentAttribute","_o","startTimeAttr","durationAttr","easingAttributes_1","emptyTexture","atlasInstanceAttributes","requestedAtlasInjections","isAtlasAttribute","injections","flatten","instanceAttribute","inject_shader_io_1","attribute_processing_1","easing_processing_1","metrics_processing_1","shader_module_1","uniform_processing_1","ShaderProcessor","easingProcessing","metricsProcessing","uniformProcessing","attributeProcessing","shadersWithImports","processImports","attributeDeclarations","vertexUniformDeclarations","fragmentUniformDeclarations","easingMethodDeclarations","fullShaderVS","fullShaderFS","processedShaderVS","stack","shaders","baseModules","moduleUnit","three_1","images_1","labels_1","shader_processor_1","color_picking_analysis_1","layer_mouse_events_1","generate_default_scene_1","generate_layer_geometry_1","generate_layer_material_1","generate_layer_model_1","mouse_event_manager_1","texture_1","atlas_resource_manager_1","DEFAULT_BACKGROUND_COLOR","Color","isCanvas","createLayer","layerClass","LayerSurface","AtlasManager","currentViewport","currentFrame","previousTime","isBufferingAtlas","scenes","willDisposeLayer","viewDrawDependencies","loadReady","loadReadyResolve","layerId","initLayer","frameIncrement","onViewReady","validLayers","erroredLayers","pickingPassByView","pickingPass","overlapViews","passed","initializer","resourceManager","renderer","pickingRenderer","LabelInstance","ImageInstance","drawSceneView","updateColorPick","flags","clearFlags","COLOR","DEPTH","pickingTarget","Uint8Array","pickWidth","readRenderTargetPixels","pickHeight","colorPicking","didBuffer","resolveContext","rendererSize","getSize","getPixelRatio","background","setScissorTest","setScissor","clearColor","setSize","setRenderTarget","STENCIL","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","setViewport","gatherViewDrawDependencies","endi","sourceView","targetView","getViewSize","getViewWorldBounds","topLeft","bottomRight","init","setContext","initGL","initMouseManager","initResources","WebGLRenderer","alpha","antialias","preserveDrawingBuffer","autoClear","setRendererSize","setPixelRatio","setClearColor","sceneViewDepth","SCISSOR_TEST","sceneOptions","newScene","defaultSceneElement","viewOptions","newView","addLayerToScene","shaderMetrics","printShader","eventManagers","atlasResources","createAtlas","layerInitializers","existingLayer","sync","fitContainer","_pixelRatio","parentElement","className","containerBox","getBoundingClientRect","box","isWebGLContext","canvasContext","isString","getElementById","WebGLRenderTarget","magFilter","LinearFilter","minFilter","stencilBuffer","instance_provider_1","primitives_1","layer_1","RingLayer","ring","radius","center","scaleFactor","animations","animate","animateColor","animateCenter","animateRadius","vertexToNormal","0","5","vertexToSide","attributeNames","thickness","_","vertex","InstanceProvider","instance_1","RingInstance","anchorCalculator","TopLeft","anchor","_rectangle","padding","TopMiddle","rectangle","TopRight","MiddleLeft","Middle","MiddleRight","BottomLeft","BottomMiddle","BottomRight","Custom","RectangleInstance","maxScale","scaling","BOUND_MAX","_anchor","setAnchor","newAnchor","types_2","RectangleLayer","anchorEffect","projection","minScale","ALWAYS","NEVER","screenPoint","_u","rasterizationLookUp","_label","_cssFont","_fontFamily","_fontSize","_fontStyle","_fontWeight","_maxWidth","_text","_width","_height","_isDestroyed","fontStyle","cssFontLookup","rasterizations","references","_rasterization","LabelLayer","animateLocation","animateSize","ImageRasterizer","calculateImageSize","_sampleScale","atlas_1","color_atlas_resource_1","color_rasterizer_1","image_atlas_resource_1","label_rasterizer_1","ZERO_IMAGE","allAtlas","destroyAtlas","atlasName","setDefaultImage","loadImage","loadedImage","isValidImage","rect","dimensions","first","second","insertedNode","insert","nodeImage","ux","nodeDimensions","uy","uw","uh","onePixelX","atlasDimensions","imageSrc","subTexture","image_1","onload","onerror","path","toDataURL","Image","src","resources_1","isLeaf","child0","child1","hasChild","newNode","fitFlag","imgWidth","imgHeight","dWidth","dHeight","removed","_image","tint","_sourceWidth","_sourceHeight","_element","_path","aspect","common_options_1","ImageLayer","animateTint","EdgeInstance","colorStart","colorEnd","control","widthStart","widthEnd","setEdgeWidth","setColor","interpolation","LINE","p1","p2","_c1","_c2","BEZIER","c1","BEZIER2","c2","TEST_RESOLUTION","edgePicking","broadphase","minPickDistance","scaleType","interpolate","edge","edgeWidthStart","edgeWidthEnd","PASS_X","PASS_Y","SCREEN_CURVE","closestIndex","closestDistance","secondClosestIndex","secondClosestDistance","control1","control2","startPoint","endPoint","linePoint","lineWidth","startSegment","endSegment","vector","lineDirection","lineNormal","distanceTo","_view","edge_picking_1","pickVS","screenVS","edgeFS","EdgeLayer","_c","_d","_f","animateEnd","animateStart","animateColorStart","animateColorEnd","animateControl","MAX_SEGMENTS","vertexInterpolation","_uniform","CircleInstance","squareDistance","Point","total","getClosest","testPoint","points","closestPoint","getClosestIndex","amount","normalize","magnitude","getDistance","squared","getMidpoint","make","CircleLayer","circle","circleScreenCenter","mouseScreen","fadeOutOversized","ArcInstance","angle","isMouseOver","isMouseDown","getColorPickInstance","isColorProcessor","_mouse","onMouseDown","hitTest_1","query_1","world_1","querySpace","instances","bind","instanceForColor","onMouseOut","hitTest_2","query_2","world_2","onMouseUp","hitTest_3","query_3","world_3","onMouseOver","onMouseMove","hitTest_4","query_4","info","world_4","notOverInstances","isCurrentlyOver_1","noLongerOver","onMouseClick","hitTest_5","query_5","world_5","UniformQuadDiffProcessor","quadPicking","UniformColorDiffProcessor","InstanceAttributeQuadDiffProcessor","locations","InstanceAttributeColorDiffProcessor","buffers","availableClusters","instanceToCluster","clusterToBuffer","makeNewBuffer","cluster","maxUniformBlock","uniformBlocksPerInstance","pickModel","setScene","newGeometry","drawRange","newMaterial","clone","newModel","activeInstances","clusters","firstInstance","lastInstance","uniformIndex","uniformName","fakeAttribute","InstancedBufferAttribute","instanceIndex","emit_once_1","allBufferLocations","availableLocations","currentInstancedCount","instanceToBufferLocation","growthCount","maxInstancedCount","blockSubAttributesLookup","attributeToPropertyIds","updateAllPropertyIdList","activePropertyId","doAddWithRegistration","propertyIdsForAttribute","makeUpdateAllPropertyIdList","locationInfo","resizeBuffer","gatherLocationsIntoGroups","newLocations","growth","ids","attributeToNewBufferLocations","InstancedBufferGeometry","previousInstanceAmount","blockAttributes","array","newAttribute","setDynamic","blockSubAttributes","blockSize","kMax","subAttribute","allLocations","internalAttribute","startAttributeIndex","attributeSize","jMax","newLocation","blockSizes","blockAttributeUID","totalNewInstances","attributesBufferLocations","bufferLocationsForAttribute","childBufferLocations","group","bufferLocation","childAttribute","bufferLocationsForChildAttribute","childBufferLocation","_g","instance_attribute_color_diff_processor_1","instance_attribute_diff_processor_1","instance_attribute_quad_diff_processor_1","uniform_color_diff_processor_1","uniform_diff_processor_1","uniform_quad_diff_processor_1","cleanObservation","instanceChanges","allowChanges","disposer","observableDisposer","INSERT","CHANGE","REMOVE","emptyPropertyChanges","ArcScaleType","ArcLayer","animateAngle","animateThickness","side","DoubleSide","getBounds","childToNode","childToBounds","nullBounded","fromSplit","doRemove","found","node","ReferenceCamera","offsetFilter","scaleFilter","base","_val","h","plural","ms","str","String","exec","long","fmtLong","fmtShort","createDebug","prevTime","self","curr","prev","coerce","format","formatter","hash","charCodeAt","selectColor","disable","names","skips","len","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","currentQueue","queue","draining","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","noop","nextTick","title","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","extend_shader_1","extendShaderInitialization","extendedShaders","isNumber","AnimationHelper","groupAnimation","groupCount","baseDelay","delayGap","modifyInstances","startFrameTime","gap","CameraBoundsAnchor","event_manager_1","BasicCameraController","isPanning","panFilter","_allViews","startViews","onRangeChanged","_camera","_targetView","startViewDidStart","applyBounds","applyScaleBounds","boundsHorizontalOffset","boundsVerticalOffset","scaleMin","scaleMax","setBounds","ignoreCoverViews","wheelShouldScroll","anchoredByBoundsHorizontal","TOP_LEFT","MIDDLE_LEFT","BOTTOM_LEFT","worldBounds","screenPadding","TOP_MIDDLE","MIDDLE","BOTTOM_MIDDLE","TOP_RIGHT","MIDDLE_RIGHT","BOTTOM_RIGHT","anchoredByBoundsVertical","worldTLinScreenSpace","worldBRinScreenSpace","canStart","findCoveredStartView","under","coveredStartView","getTargetView","_button","doPan","pan","wheelMetrics","currentZoomX","currentZoomY","deltaScale","beforeZoom","afterZoom","deltaZoom","getRange","setRange","newWorld","deltaPan"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"three\"), require(\"bowser\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"three\", \"bowser\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"network-bubble-chart\"] = factory(require(\"three\"), require(\"bowser\"));\n\telse\n\t\troot[\"network-bubble-chart\"] = factory(root[\"three\"], root[\"bowser\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__1__, __WEBPACK_EXTERNAL_MODULE__157__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 163);\n","import * as Three from \"three\";\nimport { Instance } from \"./instance-provider/instance\";\nimport { Bounds } from \"./primitives/bounds\";\nimport { ChartCamera, Vec, Vec2 } from \"./util\";\nimport { IAutoEasingMethod } from \"./util/auto-easing-method\";\nimport { IVisitFunction, TrackedQuadTree } from \"./util/tracked-quad-tree\";\n\nexport type Diff<T extends string, U extends string> = ({ [P in T]: P } &\n  { [P in U]: never } & { [x: string]: never })[T];\nexport type Omit<TType, TKeys> = Pick<TType, Exclude<keyof TType, TKeys>>;\nexport type ShaderIOValue =\n  | [number]\n  | [number, number]\n  | [number, number, number]\n  | [number, number, number, number]\n  | Three.Vector4[]\n  | Float32Array;\nexport type InstanceIOValue =\n  | [number]\n  | [number, number]\n  | [number, number, number]\n  | [number, number, number, number];\nexport type UniformIOValue =\n  | number\n  | InstanceIOValue\n  | Float32Array\n  | Three.Texture;\n\nexport enum InstanceBlockIndex {\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4\n}\n\nexport enum InstanceAttributeSize {\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4,\n  /** Special case for making instance attributes that can target Atlas resources */\n  ATLAS = 99\n}\n\nexport const instanceAttributeSizeFloatCount: { [key: number]: number } = {\n  [InstanceAttributeSize.ONE]: 1,\n  [InstanceAttributeSize.TWO]: 2,\n  [InstanceAttributeSize.THREE]: 3,\n  [InstanceAttributeSize.FOUR]: 4,\n  [InstanceAttributeSize.ATLAS]: 4\n};\n\nexport enum UniformSize {\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4,\n  MATRIX3 = 9,\n  MATRIX4 = 16,\n  ATLAS = 99\n}\n\nexport enum VertexAttributeSize {\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4\n}\n\n/**\n * This represents a color in the VoidGL system. Ranges are [0 - 1, 0 - 1, 0 - 1, 0 - 1]\n */\nexport type Color = [number, number, number, number];\n\n/**\n * Represents something with a unique id\n */\nexport interface Identifiable {\n  /** A unique identifier */\n  id: string;\n}\n\n/**\n * Information provided in mouse events interacting with instances and\n * layers.\n */\nexport interface IPickInfo<T extends Instance> {\n  /** If a mouse button is involved in the pick, this will be populated */\n  button?: number;\n  /** This is the parent layer id of the instances interacted with */\n  layer: string;\n  /** This is the list of instances that were detected in the interaction */\n  instances: T[];\n  /** If picking is set to ALL then this will be provided which can be used to make additional spatial queries */\n  querySpace?(bounds: Bounds | Vec2, visit?: IVisitFunction<T>): T[];\n  /** This is the screen coordinates of the mouse point that interacted with the instances */\n  screen: [number, number];\n  /** This is the world coordinates of the mouse point that interacted with the instances */\n  world: [number, number];\n  /** Projection methods to easily go between coordinate spaces */\n  projection: IProjection;\n}\n\nexport interface IVertexAttribute {\n  /**\n   * When initWithBuffer and customFill are not specified, this is was the system will initially\n   * load each vertex attribute with.\n   */\n  defaults?: number[];\n  /**\n   * When this is specified it will initialize the model's attribute with the data in this buffer.\n   */\n  initWithBuffer?: Float32Array;\n  /**\n   * When generating this attribute in the shader this will be the prefix to the attribute:\n   * For instance, if you specify 'highp' as the modifier, then the attribute that appears\n   * in the shader will be:\n   * attribute highp vec3 position;\n   */\n  qualifier?: string;\n  /**\n   * This is the name the attribute will be for the model.\n   */\n  name: string;\n  /**\n   * This is the number of floats the attribute will consume. For now, we only allow for up\n   * to four floats per attribute.\n   */\n  size: VertexAttributeSize;\n  /**\n   * This lets you populate the buffer with an automatically called method. This will fire when\n   * necessary updates are detected or on initialization.\n   */\n  update(vertex: number): ShaderIOValue;\n}\n\nexport interface IVertexAttributeInternal extends IVertexAttribute {\n  /** This is the actual attribute generated internally for the ThreeJS interfacing */\n  materialAttribute: Three.BufferAttribute | null;\n}\n\nexport interface IInstanceAttribute<T extends Instance> {\n  /**\n   * If this is specified, this attribute becomes a size of 4 and will have a block index of\n   * 0. This makes this attribute and layer become compatible with reading atlas resources.\n   * The value provided for this property should be the name of the atlas that is created.\n   */\n  atlas?: {\n    /** Specify which generated atlas to target for the resource */\n    key: string;\n    /** Specify the name that will be injected that will be the sampler2D in the shader */\n    name: string;\n    /**\n     * This specifies which of the shaders the sampler2D will be injected into.\n     * Defaults to the Fragment shader only.\n     */\n    shaderInjection?: ShaderInjectionTarget;\n  };\n  /**\n   * This is a block index helping describe the instancing process. It can be any number as\n   * the system will sort and organize them for you. This only helps the system detect when\n   * you cram too much info into a single block. The tighter you pack your blocks the better\n   * your program will perform.\n   *\n   * Note: It's best to leave this blank as the system now packs your attributes for you and\n   * will determine this number for you.\n   */\n  block?: number;\n  /**\n   * This is the index within the block this attribute will be available.\n   */\n  blockIndex?: InstanceBlockIndex;\n  /**\n   * If the settings on this attrubute spawns additional attributes, those attributes shall\n   * be populated here. Otherwise this remains undefined.\n   */\n  childAttributes?: IInstanceAttribute<T>[];\n  /**\n   * When this is set, the system will automatically inject necessary Shader IO to facilitate\n   * performing the easing on the GPU, which saves enormous amounts of CPU processing time\n   * trying to calcuate animations and tweens for properties.\n   *\n   * NOTE: Setting this increases the amount of data per instance by: size * 2 + ;\n   * as it injects in a start value, start time, and duration\n   */\n  easing?: IAutoEasingMethod<Vec>;\n  /**\n   * This is the name that will be available in your shader for use. This will only be\n   * available after the ${attributes} declaration.\n   */\n  name: string;\n  /**\n   * If this attribute is created automatically by the system based on the settings of another\n   * attribute, that parent attribute will be set here. Otherwise this remains undefined.\n   */\n  parentAttribute?: IInstanceAttribute<T>;\n  /**\n   * When generating this attribute in the shader this will be the prefix to the attribute:\n   * For instance, if you specify 'highp' as the modifier, then the attribute that appears\n   * in the shader will be:\n   * attribute highp vec3 position;\n   */\n  qualifier?: string;\n  /**\n   * This is how many floats the instance attribute takes up. Due to how instancing is\n   * implemented, we can only take up to 4 floats per variable right now.\n   */\n  size?: InstanceAttributeSize;\n  /**\n   * This is the accessor that executes when the instance needs updating. Simply return the\n   * value that should be populated for this attribute.\n   */\n  update(instance: T): InstanceIOValue;\n}\n\n/**\n * Internal Instance Attributes are ones that actually map to an attribute in the shader and use\n * hardware instancing.\n */\nexport interface IInstanceAttributeInternal<T extends Instance>\n  extends IInstanceAttribute<T> {\n  /** We will keep an internal uid for the  */\n  uid: number;\n  /**\n   * Sometimes an attribute is actually a sub attribute to another attribute, such as in the cases of\n   * attribute packing (in uniforms or in attribute packing). This UID indicates the parental attribute\n   * UID. This parent identifier may be an actual InstanceAttribute or not. It could just indicate this\n   * attribute is packed into SOMETHING.\n   */\n  packUID?: number;\n  /** This is the actual attribute mapped to a buffer */\n  bufferAttribute: Three.InstancedBufferAttribute;\n}\n\n/**\n * This is an attribute where the atlas is definitely declared.\n */\nexport interface IAtlasInstanceAttribute<T extends Instance>\n  extends IInstanceAttribute<T> {\n  /**\n   * If this is specified, this attribute becomes a size of 4 and will have a block index of\n   * 0. This makes this attribute and layer become compatible with reading atlas resources.\n   * The value provided for this property should be the name of the atlas that is created.\n   */\n  atlas: {\n    /** Specify which generated atlas to target for the resource */\n    key: string;\n    /** Specify the name that will be injected that will be the sampler2D in the shader */\n    name: string;\n    /**\n     * This specifies which of the shaders the sampler2D will be injected into.\n     * Defaults to the Fragment shader only.\n     */\n    shaderInjection?: ShaderInjectionTarget;\n  };\n}\n\n/**\n * This is an attribute that is simply a value\n */\nexport interface IEasingInstanceAttribute<T extends Instance>\n  extends IInstanceAttribute<T> {\n  /**\n   * This MUST be defined to be an Easing attribute\n   */\n  easing: IAutoEasingMethod<Vec> & { uid?: number };\n  /**\n   * Easing attributes requires size to be present\n   */\n  size: InstanceAttributeSize;\n}\n\n/**\n * This is an attribute that is simply a value\n */\nexport interface IValueInstanceAttribute<T extends Instance>\n  extends IInstanceAttribute<T> {\n  /**\n   * If this is specified, this attribute becomes a size of 4 and will have a block index of\n   * 0. This makes this attribute and layer become compatible with reading atlas resources.\n   * The value provided for this property should be the name of the atlas that is created.\n   */\n  atlas: undefined;\n}\n\n/** These are flags for indicating which shaders receive certain injection elements */\nexport enum ShaderInjectionTarget {\n  /** ONLY the vertex shader will receive the injection */\n  VERTEX = 1,\n  /** ONLY the fragment shader will receive the injection */\n  FRAGMENT = 2,\n  /** Both the fragment and vertex shader will receive the injection */\n  ALL = 3\n}\n\nexport interface IUniform {\n  /**\n   * This lets you specify which of the shaders will receive this uniform as available.\n   * This defaults to only injecting into the vertex shader.\n   */\n  shaderInjection?: ShaderInjectionTarget;\n  /** Name of the uniform as will be available in the shaders */\n  name: string;\n  /** How many floats the uniform shall encompass */\n  size: UniformSize;\n  /**\n   * When generating this uniform in the shader this will be the prefix to the uniform:\n   * For instance, if you specify 'highp' as the modifier, then the uniform that appears\n   * in the shader will be:\n   * uniform highp vec3 position;\n   */\n  qualifier?: string;\n  /**\n   * This is the accessor that executes every frame before this layer is drawn. It gives\n   * opportunity to update the uniform's value before every draw.\n   */\n  update(uniform: IUniform): UniformIOValue;\n}\n\nexport interface IUniformInternal extends IUniform {\n  /**\n   * All layers will have many many ShaderMaterials generated per each instance buffer as a single buffer\n   * can only render so many instances. This tracks across all generated ShaderMaterials for each buffer\n   * the material uniforms that need to be updated as a Uniform for a layer is dictated as uniform across\n   * all instances.\n   */\n  materialUniforms: Three.IUniform[];\n}\n\n/**\n * This is the structure of a uniform generated for the sake of instancing\n */\nexport interface IInstancingUniform {\n  name: string;\n  type: \"f\" | \"v2\" | \"v3\" | \"v4\" | \"4fv\" | \"bvec4\";\n  value: ShaderIOValue;\n}\n\n/**\n * Represents a complete shader object set.\n */\nexport interface IShaders {\n  fs: string;\n  vs: string;\n}\n\n/**\n * Represents an element that has a full list of projection methods\n */\nexport interface IProjection {\n  /** This is the chart camera utilized in the projection of elements */\n  camera: ChartCamera;\n  /** Converts from the pixel density layer to the screen space */\n  pixelSpaceToScreen(point: Vec2, out?: Vec2): Vec2;\n  /** Converts from the screen coordinates to the pixel density layer */\n  screenToPixelSpace(point: Vec2, out?: Vec2): Vec2;\n  /** Converts from screen space to the view's relative coordinates */\n  screenToView(point: Vec2, out?: Vec2): Vec2;\n  /** Converts from screen space to the world space of a scene */\n  screenToWorld(point: Vec2, out?: Vec2): Vec2;\n  /** Converts from a view's space to the screen */\n  viewToScreen(point: Vec2, out?: Vec2): Vec2;\n  /** Converts from a views space to the world coordinates */\n  viewToWorld(point: Vec2, out?: Vec2): Vec2;\n  /** Converts from world coordinate space of a scene to the screen */\n  worldToScreen(point: Vec2, out?: Vec2): Vec2;\n  /** Converts from world coordinate space of a scene to the view's space */\n  worldToView(point: Vec2, out?: Vec2): Vec2;\n}\n\nexport type IMaterialOptions = Partial<\n  Omit<\n    Omit<Omit<Three.ShaderMaterialParameters, \"uniforms\">, \"vertexShader\">,\n    \"fragmentShader\"\n  >\n>;\n\n/** This is the method signature for determining whether or not a point hits an instance */\nexport type InstanceHitTest<T> = (o: T, p: Vec2, v: IProjection) => boolean;\n\n/**\n * This is the type of picking assigned to a layer. Each mode has performance and functionality\n * tradeoffs.\n */\nexport enum PickType {\n  /** Disable any picking methodology */\n  NONE,\n  /** Pick all instances found underneath the mouse. The Layer must explicitly support this feature. */\n  ALL,\n  /**\n   * NOTE: NOT IMPLEMENTED YET\n   *\n   * Uses highly efficient color rendering method to detect an instance on a pixel by pixel check. Since it is\n   * based on rendering, it will only select the 'visually' top most rendered instance. This means instances can be occluded\n   * by other instances is an instance renders behind another.\n   *\n   * This is vastly more efficient and accurate than ALL. This also will be more readily supported than ALL.\n   */\n  SINGLE\n}\n\n/**\n * This represents the settings and objects used to facilitate picking in a layer.\n */\nexport interface IPickingMetrics {\n  /** This is the current pick mode that is active during the draw pass of the layer */\n  currentPickMode: PickType;\n  /** This is the picking style to be used */\n  type: PickType;\n}\n\n/**\n * This is the picking settings and objects to facilitate PickType.ALL so we can get\n * all instances underneath the mouse.\n */\nexport interface IQuadTreePickingMetrics<T extends Instance>\n  extends IPickingMetrics {\n  /** This handles the ALL type only */\n  type: PickType.ALL;\n  /** This stores all of our instances in a quad tree to spatially track our instances */\n  quadTree: TrackedQuadTree<T>;\n  /** This is the method for performing a hit test with the provided instance */\n  hitTest: InstanceHitTest<T>;\n}\n\n/**\n * This is the picking settings and objects to facilitate PickType.SINGLE so we can get\n * a single instance underneath the mouse.\n */\nexport interface ISinglePickingMetrics<T extends Instance>\n  extends IPickingMetrics {\n  /** Set the enum for the type */\n  type: PickType.SINGLE;\n  /**\n   * This is a lookup of the instance by it's UID which is all that is needed to decode a color to an instance\n   * The color UINT8 components composited into a single UINT32 IS the UID of the instance\n   */\n  uidToInstance: Map<number, T>;\n}\n\n/**\n * This is the picking settings and objects to facilitate PickType.NONE where no information\n * is retrieved for mouse interactions.\n */\nexport interface INonePickingMetrics extends IPickingMetrics {\n  // Single Picking does not require any special helper information\n  type: PickType.NONE;\n}\n\nexport interface IColorPickingData {\n  /** The mouse target position where the data is rendered */\n  mouse: Vec2;\n  /** The color data loaded for last picking rendering */\n  colorData: Uint8Array;\n  /** The height of the data array */\n  dataHeight: number;\n  /** The width of the data array */\n  dataWidth: number;\n  /** The nearest found color */\n  nearestColor: number;\n  /** All colors in the data */\n  allColors: number[];\n}\n\n/**\n * Diff types that an instance can go through. Used to help the system consume the diff\n * and apply it to the GL framework.\n */\nexport enum InstanceDiffType {\n  CHANGE = 0,\n  INSERT = 1,\n  REMOVE = 2\n}\n\n/**\n * This is the metrics associated with a frame. Mostly dealing with timing values.\n */\nexport type FrameMetrics = {\n  /** The frame number rendered. Increases by 1 every surface draw */\n  currentFrame: number;\n  /** The start time of the current frame */\n  currentTime: number;\n  /** The start time of the previous frame */\n  previousTime: number;\n};\n\n/**\n * This represents controls that can be utilized when adjustig easing\n */\nexport interface IEasingControl {\n  /** A value in ms that expresses how long the system should wait before beginning the animation */\n  readonly delay?: number;\n  /** Indicates how long the easing should take to complete in ms */\n  readonly duration: number;\n  /** The end value the easing should approach */\n  readonly end: Vec;\n  /** The starting value of the easing object */\n  readonly start: Vec;\n  /** The start time in ms the easing object utilizes */\n  readonly startTime: number;\n\n  /**\n   * If you manually set values for the easing properties, then you use this to return\n   * the easing object back to an automated state which is where the start value is\n   * the calculated current position of the output and the delay and duration is determined\n   * by the easing set to the layer's IAutomatedEasingMethod value set to the layer.\n   */\n  setAutomatic(): void;\n\n  /**\n   * This controls the start value of the easing. This should be used to force a starting\n   * value of the animation.\n   *\n   * Use setAutomatic() to return to default easing behavior.\n   */\n  setStart(start?: Vec): void;\n\n  /**\n   * This controls of the timing of the easing equation. This should be used to adjust\n   * when a value is to be adjusted\n   *\n   * Use setAutomatic() to return to default easing behavior.\n   */\n  setTiming(delay?: number, duration?: number): void;\n}\n\n/**\n * This is the minimum properties required to make all easing functions operate.\n */\nexport interface IEasingProps {\n  /** A value in ms that expresses how long the system should wait before beginning the animation */\n  delay?: number;\n  /** Indicates how long the easing should take to complete in ms */\n  duration: number;\n  /** The end value the easing should approach */\n  end: Vec;\n  /** A flag indicating if the easing start value is manually set, thus prioritizing the values already set in this object */\n  isManualStart?: boolean;\n  /** A flag indicating if the easing timing is manually set, thus prioritizing the values already set in this object */\n  isTimeSet?: boolean;\n  /** The starting value of the easing object */\n  start: Vec;\n  /** The start time in ms the easing object utilizes */\n  startTime: number;\n}\n\n/**\n * This is the Shader IO information a layer will provide.\n */\nexport interface IShaderInputs<T extends Instance> {\n  /** These are very frequently changing attributes and are uniform across all vertices in the model */\n  instanceAttributes?: (IInstanceAttribute<T> | null)[];\n  /** These are attributes that should be static on a vertex. These are considered unique per vertex. */\n  vertexAttributes?: (IVertexAttribute | null)[];\n  /** Specify how many vertices there are per instance */\n  vertexCount: number;\n  /** These are uniforms in the shader. These are uniform across all vertices and all instances for this layer. */\n  uniforms?: (IUniform | null)[];\n}\n\n/**\n * This is the initialization of the shader.\n */\nexport type IShaderInitialization<T extends Instance> = IShaderInputs<T> &\n  IShaders;\n\nexport interface IShaderExtension {\n  header?: string;\n  body?: string;\n}\n\nexport type IShaderIOExtension<T extends Instance> = Partial<\n  IShaderInputs<T>\n> & {\n  vs?: IShaderExtension;\n  fs?: IShaderExtension;\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","export * from \"../instance-provider/instance\";\nexport * from \"./common-options\";\nexport * from \"./animation-helper\";\nexport * from \"./auto-easing-method\";\nexport * from \"./chart-camera\";\nexport * from \"./extend-shader-io\";\nexport * from \"./mouse\";\nexport * from \"./reference-camera\";\nexport * from \"./shader-templating\";\nexport * from \"./tracked-quad-tree\";\nexport * from \"./uid\";\nexport * from \"./vector\";\nexport * from \"./view-camera\";\nexport * from \"./webgl-stat\";\n","export * from \"./observable\";\nexport * from \"./instance-provider\";\nexport * from \"./instance\";\n","import { Vec2 } from \"../util\";\n\nexport interface IBoundsOptions {\n  /** Top left x position */\n  x?: number;\n  /** Top left y position */\n  y?: number;\n  /** Width covered */\n  width?: number;\n  /** height covered */\n  height?: number;\n\n  /** Specify the left */\n  left?: number;\n  /** Specify the right */\n  right?: number;\n  /** Specify the top */\n  top?: number;\n  /** Specify the bottom */\n  bottom?: number;\n}\n\n/**\n * Class to manage the x, y, width, and height of an object\n *\n * @template T This specifies the data type associated with this shape and is accessible\n *             via the property 'd'\n */\nexport class Bounds {\n  x: number = 0;\n  y: number = 0;\n  width: number = 0;\n  height: number = 0;\n\n  get area() {\n    return this.width * this.height;\n  }\n\n  get bottom() {\n    return this.y + this.height;\n  }\n\n  get left() {\n    return this.x;\n  }\n\n  get mid(): Vec2 {\n    return [this.x + this.width / 2.0, this.y + this.height / 2.0];\n  }\n\n  get right() {\n    return this.x + this.width;\n  }\n\n  get top() {\n    return this.y;\n  }\n\n  static emptyBounds() {\n    return new Bounds({\n      height: 0,\n      width: 0,\n      x: 0,\n      y: 0\n    });\n  }\n\n  /**\n   * Create a new instance\n   *\n   * @param left  The left side (x coordinate) of the instance\n   * @param right The right side of the instance\n   * @param top The top (y coordinate) of the instance\n   * @param bottom The bottom of the instance\n   */\n  constructor(options: IBoundsOptions) {\n    this.x = options.x || options.left || 0;\n    this.y = options.y || options.top || 0;\n    this.height = options.height || (options.bottom || 0) - this.y || 0;\n    this.width = options.width || (options.right || 0) - this.x || 0;\n  }\n\n  /**\n   * Checks to see if a point is within this bounds object.\n   *\n   * @param point\n   */\n  containsPoint(point: Vec2) {\n    return !(\n      point[0] < this.x ||\n      point[1] < this.y ||\n      point[0] > this.right ||\n      point[1] > this.bottom\n    );\n  }\n\n  /**\n   * Grows this bounds object to cover the space of the provided bounds object\n   *\n   * @param item\n   */\n  encapsulate(item: Bounds | Vec2) {\n    if (item instanceof Bounds) {\n      if (item.x < this.x) {\n        this.width += Math.abs(item.x - this.x);\n        this.x = item.x;\n      }\n\n      if (item.y < this.y) {\n        this.height += Math.abs(item.y - this.y);\n        this.y = item.y;\n      }\n\n      if (this.right < item.right) {\n        this.width += item.right - this.right;\n      }\n\n      if (this.bottom < item.bottom) {\n        this.height += item.bottom - this.bottom;\n      }\n\n      return true;\n    } else {\n      if (item[0] < this.x) {\n        this.width += this.x - item[0];\n        this.x = item[0];\n      }\n\n      if (item[0] > this.right) {\n        this.width += item[0] - this.x;\n      }\n\n      if (item[1] < this.y) {\n        this.height += this.y - item[1];\n        this.y = item[1];\n      }\n\n      if (item[1] > this.bottom) {\n        this.height += item[1] - this.y;\n      }\n\n      return true;\n    }\n  }\n\n  /**\n   * Checks to see if the provided bounds object could fit within the dimensions of this bounds object\n   * This ignores position and just checks width and height.\n   *\n   * @param bounds\n   *\n   * @return {number} 0 if it doesn't fit. 1 if it fits perfectly. 2 if it just fits.\n   */\n  fits(bounds: Bounds): 0 | 1 | 2 {\n    // If the same, the bounds fits exactly into this bounds\n    if (this.width === bounds.width && this.height === bounds.height) {\n      return 1;\n    }\n\n    // The bounds can fit within this, then it just fits\n    if (this.width >= bounds.width && this.height >= bounds.height) {\n      return 2;\n    }\n\n    // Otherwise, the bounds does not fit within this bounds\n    return 0;\n  }\n\n  /**\n   * Checks if a bounds object intersects another bounds object.\n   *\n   * @param bounds\n   */\n  hitBounds(bounds: Bounds) {\n    return !(\n      this.right < bounds.x ||\n      this.x > bounds.right ||\n      this.bottom < bounds.y ||\n      this.y > bounds.height\n    );\n  }\n\n  /**\n   * Sees if the provided bounds is completely within this bounds object. Unlike fits() this takes\n   * position into account.\n   *\n   * @param bounds\n   */\n  isInside(bounds: Bounds): boolean {\n    return (\n      this.x >= bounds.x &&\n      this.right <= bounds.right &&\n      this.y >= bounds.y &&\n      this.bottom <= bounds.bottom\n    );\n  }\n\n  /**\n   * Top left position of the bounds\n   */\n  get location(): Vec2 {\n    return [this.x, this.y];\n  }\n\n  /**\n   * Easy readout of this Bounds object.\n   */\n  toString() {\n    return `{x: ${this.x} y:${this.y} w:${this.width} h:${this.height}}`;\n  }\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport { IInstanceAttributeInternal } from \"../../types\";\nimport { Vec2 } from \"../../util\";\nimport { Layer } from \"../layer\";\nimport { Scene } from \"../scene\";\n\nexport function isBufferLocation(val: any): val is IBufferLocation {\n  return val && val.buffer && val.buffer.value;\n}\n\nexport function isBufferLocationGroup(\n  val: any\n): val is IBufferLocationGroup<IBufferLocation> {\n  return val && val.propertyToBufferLocation;\n}\n\n/**\n * This defines a base information object that explains where in a buffer a value\n * is represented.\n */\nexport interface IBufferLocation {\n  /** This is the parent attribute of this location */\n  attribute: IInstanceAttributeInternal<Instance>;\n  /** For some buffer strategies, there is a concept of block that is used to tightly pack attributes together. */\n  block?: number;\n  /**\n   * This is the generic buffer object interface for accessing the actual buffer.\n   */\n  buffer: {\n    value: Float32Array | Uint8Array;\n  };\n  /**\n   * If the attribute has child attributes (attributes auto generated as a consequence of the attributes settings)\n   * then the children's buffer locations can be found here.\n   */\n  childLocations?: IBufferLocation[];\n  /**\n   * This is the instance index indicative of the instance positioning within the buffer.\n   * Keep in mind: This does NOT correlate to a lookup for an Instance object but rather for\n   * the instancing concept designed for GL Buffers.\n   */\n  instanceIndex: number;\n  /**\n   * This is the range within the buffer values should be injected for this location.\n   */\n  range: Vec2;\n}\n\n/**\n * Each instance that comes in can be associated with a group of buffer locations. A buffer location for each\n * instance attribute used in updates. So a grouping is several buffer locations that are keyed by\n * the instance's property's UIDs.\n */\nexport interface IBufferLocationGroup<T extends IBufferLocation> {\n  /** This is the instance index WITHIN THE BUFFERS. This does NOT have relevance to Instance type objects */\n  instanceIndex: number;\n  /** This is a map of property UIDs to an associated buffer location */\n  propertyToBufferLocation: { [key: number]: T };\n}\n\n/**\n * Layers manage instances and those instances require a form of binding to their associated buffers.\n * The buffers have to be intelligently created and managed in this tieing to maximize performance.\n * One can not have a buffer for every instance in most cases, so the buffer manager has to get instances\n * to cooperate sharing a buffer in whatever strategy possible that best suits the hardware and it's limitations.\n *\n * This provides a uniform interface between instances and their corresponding buffer.\n */\nexport abstract class BufferManagerBase<\n  T extends Instance,\n  U extends IBufferLocation\n> {\n  /** The layer this manager glues Instances to Buffers */\n  layer: Layer<T, any>;\n  /** The scene the layer is injecting elements into */\n  scene: Scene;\n\n  /**\n   * Base constructor. A manager always needs to be associated with it's layer and it's scene.\n   */\n  constructor(layer: Layer<T, any>, scene: Scene) {\n    this.layer = layer;\n    this.scene = scene;\n  }\n\n  /**\n   * Destroy all elements that consume GPU resources or consumes otherwise unreleaseable resources.\n   */\n  abstract destroy(): void;\n\n  /**\n   * This adds an instance to the manager and thus ties the instance to an IBuffer location\n   */\n  add: (instance: T) => U | IBufferLocationGroup<U> | undefined;\n\n  /**\n   * Retrieves the buffer locations for the instance provided\n   */\n  abstract getBufferLocations(\n    instance: T\n  ): U | IBufferLocationGroup<U> | undefined;\n\n  /**\n   * This retrieves the property ID for the active attribute. This is necessary to prevent\n   * the need for lookups to find the active attribute.\n   */\n  abstract getActiveAttributePropertyId(): number;\n\n  /**\n   * This returns how many instances this buffer manager has grown to accommodate.\n   */\n  abstract getInstanceCount(): number;\n\n  /**\n   * This should provide a minimum property id list that represents a set of properties that if triggered\n   * for update, would cause all of the attributes to be updated for the layer.\n   */\n  abstract getUpdateAllPropertyIdList(): number[];\n\n  /**\n   * Disassociates an instance with it's buffer location and makes the instance\n   * in the buffer no longer drawable.\n   */\n  remove: (instance: T) => T;\n\n  /**\n   * Removes the manager from the scene it applied itself to.\n   */\n  abstract removeFromScene(): void;\n}\n","import { Identifiable, IEasingControl, IEasingProps } from \"../types\";\nimport { EasingProps } from \"../util/easing-props\";\nimport { InstanceProvider } from \"./instance-provider\";\nimport { observable } from \"./observable\";\n\nlet instanceUID = 0;\n\nexport interface IInstanceOptions {\n  /** The instance can be declared with an initial active state */\n  active?: boolean;\n  /** An instance must be declared with an identifier */\n  id?: string;\n}\n\nexport class Instance implements Identifiable {\n  static get newUID() {\n    return (instanceUID = ++instanceUID % 0xffffff);\n  }\n\n  /** This indicates when the instance is active / rendering */\n  @observable active: boolean;\n  /** The property changes on the instance */\n  changes: { [key: number]: number } = {};\n  /** Stores property identification numbers */\n  property: { [key: string]: number } = {};\n  /**\n   * This is a lookup that provides a means to retrieve the id of an easing type currently available to the instance.\n   * This is populated when the instance becomes a part of a layer with easing attributes.\n   *\n   * This property is to NOT be mutated except by the system.\n   */\n  easingId: { [key: string]: number } | undefined;\n  /** This is an internal easing object to track properties for automated easing */\n  private _easing = new Map<number, IEasingProps>();\n  /** Internal, non-changeable id */\n  private _id: string;\n  /** This is the observer of the Instance's observable properties */\n  private _observer: InstanceProvider<this> | null;\n  /** This is where observables store their data for the instance */\n  observableStorage: any[] = [];\n  /** A numerical look up for the instance. Numerical identifiers run faster than objects or strings */\n  @observable private _uid = Instance.newUID;\n\n  /**\n   * Retrieves a method for disposing the link between observables and observer.\n   */\n  get observableDisposer(): () => void {\n    return () => delete this._observer;\n  }\n\n  /**\n   * Retrieves the observer of the observables.\n   */\n  get observer(): InstanceProvider<this> | null {\n    return this._observer || null;\n  }\n\n  /**\n   * Applies an observer for changes to the observables.\n   */\n  set observer(val: InstanceProvider<this> | null) {\n    // If an observer already is present, we should inform it, that it is being removed\n    // in favor of a new observer\n    const oldObserver = this._observer;\n\n    // If we're switching observers, then we have to dump out assumptions made within other observers\n    if (oldObserver && oldObserver !== val) {\n      this._easing.clear();\n      oldObserver.remove(this);\n    }\n\n    // Apply the new observer as the current observer\n    this._observer = val;\n  }\n\n  /**\n   * This clears any lingering easing information that may have been registered with the instance.\n   */\n  clearEasing() {\n    this._easing.clear();\n    delete this.easingId;\n  }\n\n  /**\n   * Retrieves easing properties for the observables that are associated with easing.\n   */\n  get easing() {\n    return this._easing;\n  }\n\n  /**\n   * This attempts to get the easing object for this instance for a given attribute that it MIGHT be associated with.\n   *\n   * When an instance is added to a layer and the layer has attributes with easing applied to them, the instance gains easing values\n   * for the attributes in the layer with applied easing.\n   *\n   * You can access the easing values by requesting the attribute's \"name\" property value using this method.\n   *\n   * There is NO WAY TO GUARANTEE this value is set or available, so this method WILL return undefined if you did\n   * not use the correct name, or no such value exists, or the layer decided to not make the attribute animateable.\n   *\n   * Thus ALWAYS check the returned value to ensure it is defined before attempting to use it's results.\n   *\n   * PERFORMANCE: You can probably get much better performance NOT using this to manipulate the easing object directly.\n   * The system is designed to automatically animate an item from it's current rendered location to the next location\n   * seamlessly thus accounting for most situations. This method is provided to commit much more complex start, duration,\n   * and delay animations within a given frame to prevent the need for complicated setTimeout patterns.\n   *\n   * This CAN be faster than the default behavior if it avoids causing complicated easing computations to determine where\n   * the rendering should be at the moment (complicated cpu methods within the IAutoEasingMethod used).\n   */\n  getEasing(attributeName: string): IEasingControl | undefined {\n    if (this.easingId) {\n      const easingId = this.easingId[attributeName];\n\n      if (easingId) {\n        const easing = this._easing.get(easingId);\n\n        if (easing instanceof EasingProps) {\n          return easing;\n        }\n      }\n    }\n\n    return;\n  }\n\n  /**\n   * Get the applied id of this instance\n   */\n  get id() {\n    return this._id;\n  }\n\n  /**\n   * Get the auto generated ID of this instance\n   */\n  get uid() {\n    return this._uid;\n  }\n\n  /**\n   * This method is utilized internally to indicate when requested resources are ready.\n   * If you have a property that will be requesting a resource, you should implement this method\n   * to cause a trigger for the property to activate such that the property will update it's buffer.\n   */\n  resourceTrigger() {\n    // No default behavior, subclasses must override and provide behavior.\n    console.warn(\n      \"resourceTrigger called on an instance that did not override resourceTrigger. resourceTrigger MUST be overridden for instances\",\n      \"that utilize a resource. The observable that is tied to committing the resource should be 'triggered' in this method.\"\n    );\n  }\n\n  constructor(options: IInstanceOptions) {\n    this._id = options.id || \"\";\n    this.active = options.active || this.active;\n  }\n}\n","import * as Three from \"three\";\nimport { Instance } from \"../instance-provider/instance\";\nimport { InstanceDiff } from \"../instance-provider/instance-provider\";\nimport {\n  IInstanceAttribute,\n  IMaterialOptions,\n  INonePickingMetrics,\n  InstanceAttributeSize,\n  InstanceBlockIndex,\n  InstanceDiffType,\n  InstanceHitTest,\n  InstanceIOValue,\n  IPickInfo,\n  IQuadTreePickingMetrics,\n  IShaderInitialization,\n  ISinglePickingMetrics,\n  IUniform,\n  IUniformInternal,\n  IVertexAttributeInternal,\n  PickType,\n  ShaderInjectionTarget,\n  UniformIOValue,\n  UniformSize\n} from \"../types\";\nimport { BoundsAccessor, TrackedQuadTree } from \"../util\";\nimport { IdentifyByKey, IdentifyByKeyOptions } from \"../util/identify-by-key\";\nimport {\n  BufferManagerBase,\n  IBufferLocation\n} from \"./buffer-management/buffer-manager-base\";\nimport { InstanceDiffManager } from \"./buffer-management/instance-diff-manager\";\nimport { LayerInteractionHandler } from \"./layer-interaction-handler\";\nimport { LayerBufferType } from \"./layer-processing/layer-buffer-type\";\nimport { LayerInitializer, LayerSurface } from \"./layer-surface\";\nimport { AtlasResourceManager } from \"./texture/atlas-resource-manager\";\nimport { View } from \"./view\";\n\nexport interface IModelType {\n  /** This is the draw type of the model to be used */\n  drawMode?: Three.TrianglesDrawModes;\n  /** This is the THREE JS model type */\n  modelType: IModelConstructable;\n}\n\n/**\n * Bare minimum required features a provider must provide to be the data for the layer.\n */\nexport interface IInstanceProvider<T extends Instance> {\n  /**\n   * This indicates the context this provider was handled within. Currently, only one context is allowed per provider,\n   * so we use this to detect when multiple contexts have attempted use of this provider.\n   */\n  resolveContext: string;\n\n  /** A list of changes to instances */\n  changeList: InstanceDiff<T>[];\n  /** Resolves the changes as consumed */\n  resolve(context: string): void;\n  /** Forces the provider to make a change list that ensures all elements are added */\n  sync(): void;\n}\n\n/**\n * Constructor options when generating a layer.\n */\nexport interface ILayerProps<T extends Instance> extends IdentifyByKeyOptions {\n  /** This is the data provider where the instancing data is injected and modified. */\n  data: IInstanceProvider<T>;\n  /**\n   * This sets how instances can be picked via the mouse. This activates the mouse events for the layer IFF\n   * the value is not NONE.\n   */\n  picking?: PickType;\n  /**\n   * Used for debugging. Logs the generated shader for the layer in the console.\n   */\n  printShader?: boolean;\n  /**\n   * This identifies the scene we want the layer to be a part of.\n   * Layer's with the same identifiers will render their buffers in the same scene.\n   * This only applies to the layer when the layer is initialized in a layer surface. You shouldn't\n   * be swapping layers from scene to scene.\n   *\n   * The scene identifier must be an identifier used when constructing the layer surface that this layer\n   * is added to.\n   */\n  scene: string;\n\n  // ---- EVENTS ----\n  /** Executes when the mouse is down on instances and a picking type is set */\n  onMouseDown?(info: IPickInfo<T>): void;\n  /** Executes when the mouse moves on instances and a picking type is set */\n  onMouseMove?(info: IPickInfo<T>): void;\n  /** Executes when the mouse no longer over instances and a picking type is set */\n  onMouseOut?(info: IPickInfo<T>): void;\n  /** Executes when the mouse is newly over instances and a picking type is set */\n  onMouseOver?(info: IPickInfo<T>): void;\n  /** Executes when the mouse button is release when over instances and a picking type is set */\n  onMouseUp?(info: IPickInfo<T>): void;\n  /** Executes when the mouse click gesture is executed over instances and a picking type is set */\n  onMouseClick?(info: IPickInfo<T>): void;\n}\n\nexport interface IModelConstructable {\n  new (\n    geometry?: Three.Geometry | Three.BufferGeometry,\n    material?: Three.Material | Three.Material[]\n  ): any;\n}\n\nexport interface IPickingMethods<T extends Instance> {\n  /** This provides a way to calculate bounds of an Instance */\n  boundsAccessor: BoundsAccessor<T>;\n  /** This is the way the system tests hitting an intsance */\n  hitTest: InstanceHitTest<T>;\n}\n\n/**\n * A base class for generating drawable content\n */\nexport class Layer<\n  T extends Instance,\n  U extends ILayerProps<T>\n> extends IdentifyByKey {\n  /** This MUST be implemented by sublayers in order for proper code hinting to happen */\n  static defaultProps: any = {};\n\n  /** This is the attribute that specifies the _active flag for an instance */\n  activeAttribute: IInstanceAttribute<T>;\n  /** This matches an instance to the list of Three uniforms that the instance is responsible for updating */\n  private _bufferManager: BufferManagerBase<T, IBufferLocation>;\n  /** Buffer manager is read only. Must use setBufferManager */\n  get bufferManager() {\n    return this._bufferManager;\n  }\n  /** This is the determined buffering strategy of the layer */\n  private _bufferType: LayerBufferType;\n  /** Buffer type is private and should not be directly modified */\n  get bufferType() {\n    return this._bufferType;\n  }\n  /** This determines the drawing order of the layer within it's scene */\n  depth: number = 0;\n  /** This contains the methods and controls for handling diffs for the layer */\n  diffManager: InstanceDiffManager<T>;\n  /**\n   * This gets populated when there are attributes that have easing applied to them. This\n   * subsequently gets applied to instances when they get added to the layer.\n   */\n  easingId: { [key: string]: number };\n  /** This is the threejs geometry filled with the vertex information */\n  geometry: Three.BufferGeometry;\n  /** This is the initializer used when making this layer. */\n  initializer: LayerInitializer;\n  /** This is all of the instance attributes generated for the layer */\n  instanceAttributes: IInstanceAttribute<T>[];\n  /** A lookup fo an instance by it's ID */\n  instanceById = new Map<string, T>();\n  /** Provides the number of vertices a single instance spans */\n  instanceVertexCount: number = 0;\n  /** This is the handler that manages interactions for the layer */\n  interactions: LayerInteractionHandler<T, U>;\n  /** The official shader material generated for the layer */\n  material: Three.RawShaderMaterial;\n  /** INTERNAL: For the given shader IO provided this is how many instances can be present per buffer. */\n  maxInstancesPerBuffer: number;\n  /** This is the mesh for the Threejs setup */\n  model: Three.Object3D;\n  /** This is all of the picking metrics kept for handling picking scenarios */\n  picking:\n    | IQuadTreePickingMetrics<T>\n    | ISinglePickingMetrics<T>\n    | INonePickingMetrics;\n  /** Properties handed to the Layer during a LayerSurface render */\n  props: U;\n  /** This is the system provided resource manager that lets a layer request Atlas resources */\n  resource: AtlasResourceManager;\n  /** This is the surface this layer is generated under */\n  surface: LayerSurface;\n  /** This is all of the uniforms generated for the layer */\n  uniforms: IUniformInternal[];\n  /** This is all of the vertex attributes generated for the layer */\n  vertexAttributes: IVertexAttributeInternal[];\n  /** This is the view the layer is applied to. The system sets this, modifying will only cause sorrow. */\n  view: View;\n  /** This indicates whether this layer needs to draw */\n  needsViewDrawn: boolean = false;\n  /** End time of animation */\n  animationEndTime: number = 0;\n\n  constructor(props: ILayerProps<T>) {\n    // We do not establish bounds in the layer. The surface manager will take care of that for us\n    // After associating the layer with the view it is a part of.\n    super(props);\n    // Keep our props within the layer\n    this.props = Object.assign({}, Layer.defaultProps || {}, props as U);\n    // Set up the pick type for the layer\n    const { picking = PickType.NONE } = this.props;\n\n    // If ALL is specified we set up QUAD tree picking for our instances\n    if (picking === PickType.ALL) {\n      const pickingMethods = this.getInstancePickingMethods();\n\n      this.picking = {\n        currentPickMode: PickType.NONE,\n        hitTest: pickingMethods.hitTest,\n        quadTree: new TrackedQuadTree<T>(\n          0,\n          1,\n          0,\n          1,\n          pickingMethods.boundsAccessor\n        ),\n        type: PickType.ALL\n      };\n    } else if (picking === PickType.SINGLE) {\n      this.picking = {\n        currentPickMode: PickType.NONE,\n        type: PickType.SINGLE,\n        uidToInstance: new Map<number, T>()\n      };\n    } else {\n      this.picking = {\n        currentPickMode: PickType.NONE,\n        type: PickType.NONE\n      };\n    }\n  }\n\n  /**\n   * This establishes basic modules required by the layer for the shaders. At it's core functionality, it will\n   * support the basic properties a layer has to provide, such as Picking modes\n   */\n  baseShaderModules(\n    shaderIO: IShaderInitialization<T>\n  ): { fs: string[]; vs: string[] } {\n    const additionalImportsVS = [];\n    const additionalImportsFS = [];\n\n    // All layers need the basic instancing functionality\n    additionalImportsVS.push(\"instancing\");\n\n    // See if the layer needs picking modules\n    if (this.picking.type === PickType.SINGLE) {\n      additionalImportsVS.push(\"picking\");\n      additionalImportsFS.push(\"picking\");\n    } else {\n      additionalImportsVS.push(\"no-picking\");\n      additionalImportsFS.push(\"no-picking\");\n    }\n\n    // See if there are any attributes that have  auto easing involved\n    const easing = (shaderIO.instanceAttributes || []).find(check =>\n      Boolean(check && check.easing)\n    );\n\n    // If easing is involved then we need to make sure that frame metrics are imported for our animations\n    if (easing) {\n      additionalImportsVS.push(\"frame\");\n    }\n\n    return {\n      fs: additionalImportsFS,\n      vs: additionalImportsVS\n    };\n  }\n\n  /**\n   * Invalidate and free all resources assocated with this layer.\n   */\n  destroy() {\n    if (this.bufferManager) {\n      if (this.bufferManager.scene) this.bufferManager.scene.removeLayer(this);\n      this.bufferManager.removeFromScene();\n      this.bufferManager.destroy();\n    }\n  }\n\n  didUpdateProps() {\n    /** LIFECYCLE */\n  }\n\n  /**\n   * This is where global uniforms should update their values. Executes every frame.\n   */\n  draw() {\n    // Consume the diffs for the instances to update each element\n    const changeList = this.props.data.changeList;\n    // Set needsViewDrawn to be true if there is any change\n    if (changeList.length > 0) this.needsViewDrawn = true;\n    // Make some holder variables to prevent declaration within the loop\n    let change, instance, bufferLocations;\n    // Fast ref to the processor and manager\n    const diffManager = this.diffManager;\n    const processing = diffManager.processing;\n    const processor = diffManager.processor;\n\n    // Forewarn the processor how many instances are flagged for a change.\n    processor.incomingChangeList(changeList);\n\n    for (let i = 0, end = changeList.length; i < end; ++i) {\n      change = changeList[i];\n      instance = change[0];\n      bufferLocations = this.bufferManager.getBufferLocations(instance);\n      // The diff type is change[1] which we use to find the diff processing method to use\n      processing[change[1]](\n        processor,\n        instance,\n        Object.values(change[2]),\n        bufferLocations\n      );\n      // Clear the changes for the instance\n      instance.changes = {};\n    }\n\n    // Tell the diff processor that it has completed it's task set\n    processor.commit();\n    // Flag the changes as resolved\n    this.props.data.resolve(this.id);\n    // Trigger uniform updates\n    this.updateUniforms();\n  }\n\n  /**\n   * This method is for layers to implement to specify how the bounds for an instance are retrieved or\n   * calculated and how the Instance interacts with a point. This is REQUIRED to support PickType.ALL on the layer.\n   */\n  getInstancePickingMethods(): IPickingMethods<T> {\n    throw new Error(\n      \"When picking is set to PickType.ALL, the layer MUST have this method implemented; otherwise, the layer is incompatible with this picking mode.\"\n    );\n  }\n\n  /**\n   * The type of Three model as well as the preferred draw mode associated with it.\n   */\n  getModelType(): IModelType {\n    return {\n      drawMode: Three.TrianglesDrawMode,\n      modelType: Three.Mesh\n    };\n  }\n\n  /**\n   * The options for a three material without uniforms.\n   */\n  getMaterialOptions(): IMaterialOptions {\n    return {};\n  }\n\n  /**\n   * This sets up all of the data bindings that will transport data from the CPU\n   * to the Shader on the GPU.\n   *\n   * Instance Attributes: These are very frequently changing attributes\n   * Vertex Attributes: These are attributes that should be static on a vertex. Conisder it very costly to update.\n   *                    The only time making these modifieable is in the event of GL_POINTS.\n   * Uniforms: These set up the uniforms for the layer, thus having all normal implications of a uniform. Global\n   *           across the fragment and vertex shaders and can be modified with little consequence.\n   */\n  initShader(): IShaderInitialization<T> {\n    return {\n      fs: \"${import: no-op}\",\n      instanceAttributes: [],\n      uniforms: [],\n      vertexAttributes: [],\n      vertexCount: 0,\n      vs: \"${import: no-op}\"\n    };\n  }\n\n  /**\n   * Helper method for making an instance attribute. Depending on set up, this makes creating elements\n   * have better documentation when typing out the elements.\n   */\n  makeInstanceAttribute(\n    block: number,\n    blockIndex: InstanceBlockIndex,\n    name: string,\n    size: InstanceAttributeSize,\n    update: (o: T) => InstanceIOValue,\n    atlas?: {\n      key: string;\n      name: string;\n      shaderInjection?: ShaderInjectionTarget;\n    }\n  ): IInstanceAttribute<T> {\n    return {\n      atlas,\n      block,\n      blockIndex,\n      name,\n      size,\n      update\n    };\n  }\n\n  /**\n   * Helper method for making a uniform type. Depending on set up, this makes creating elements\n   * have better documentation when typing out the elements.\n   */\n  makeUniform(\n    name: string,\n    size: UniformSize,\n    update: (o: IUniform) => UniformIOValue,\n    shaderInjection?: ShaderInjectionTarget,\n    qualifier?: string\n  ): IUniform {\n    return {\n      name,\n      qualifier,\n      shaderInjection,\n      size,\n      update\n    };\n  }\n\n  /**\n   * Applies a buffer manager to the layer which handles instance changes and applies those changes\n   * to an appropriate buffer at the appropriate location.\n   */\n  setBufferManager(bufferManager: BufferManagerBase<T, IBufferLocation>) {\n    if (!this._bufferManager) {\n      this._bufferManager = bufferManager;\n      this.diffManager = new InstanceDiffManager<T>(this, bufferManager);\n      this.diffManager.makeProcessor();\n      this.interactions = new LayerInteractionHandler(this);\n    } else {\n      console.warn(\n        \"You can not change a layer's buffer strategy once it has been instantiated.\"\n      );\n    }\n  }\n\n  /**\n   * Only allows the buffer type to be set once\n   */\n  setBufferType(val: LayerBufferType) {\n    if (this._bufferType === undefined) {\n      this._bufferType = val;\n    } else {\n      console.warn(\n        \"You can not change a layers buffer strategy once it has been instantiated.\"\n      );\n    }\n  }\n\n  /**\n   * This method returns a flag indicating whether or not the layer should trigger it's view to redraw.\n   * By default, a redraw is triggered (this returns true) when a shallow comparison of the current props\n   * and the incoming props are different.\n   * This method can be overridden to place custom logic at this point to indicate when redraws should happen.\n   *\n   * NOTE: This should be considered for redraw logic centered around changes in the layer itself.\n   * There ARE additional triggers in the system that causes redraws. This method just aids in ensuring\n   * necessary redraws take place for layer level logic and props.\n   */\n  shouldDrawView(oldProps: U, newProps: U) {\n    for (const key in newProps) {\n      if (newProps[key] !== oldProps[key]) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * This triggers the layer to update the material uniforms that have been created for the layer.\n   * This is primarily used internally.\n   */\n  updateUniforms() {\n    let uniform: IUniformInternal;\n    let value: UniformIOValue;\n\n    // Loop through the uniforms that are across all instances\n    for (let i = 0, end = this.uniforms.length; i < end; ++i) {\n      uniform = this.uniforms[i];\n      value = uniform.update(uniform);\n      uniform.materialUniforms.forEach(\n        materialUniform => (materialUniform.value = value)\n      );\n    }\n  }\n\n  willUpdateInstances(_changes: [T, InstanceDiffType]) {\n    // HOOK: Simple hook so a class can review all of it's changed instances before\n    //       Getting applied to the Shader IO\n  }\n\n  willUpdateProps(_newProps: ILayerProps<T>) {\n    /** LIFECYCLE */\n  }\n\n  didUpdate() {\n    this.props.data.resolve(this.id);\n  }\n}\n","export enum AnchorType {\n  BottomLeft,\n  BottomMiddle,\n  BottomRight,\n  Custom,\n  Middle,\n  MiddleLeft,\n  MiddleRight,\n  TopLeft,\n  TopMiddle,\n  TopRight\n}\n\nexport type Anchor = {\n  /** When the anchor gets calculated on the image, this allows the anchor to go beyond the borders of the image by this amount */\n  padding: number;\n  /** This is the location of the anchor. If a custom anchor is specified, then the x and y are not automatically populated */\n  type: AnchorType;\n  /** This is populated with the anchor's location relative to the image's surface */\n  x?: number;\n  /** This is populated with the anchor's location relative to the image's surface */\n  y?: number;\n};\n\nexport enum ScaleType {\n  /** The size of the image will be tied to world space */\n  ALWAYS = 1,\n  /** The image will scale to it's font size then stop growing */\n  BOUND_MAX = 2,\n  /** The image will alwyas retain it's font size on screen */\n  NEVER = 3\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport {\n  IInstanceAttribute,\n  instanceAttributeSizeFloatCount,\n  IVertexAttribute\n} from \"../../types\";\nimport { WebGLStat } from \"../../util/webgl-stat\";\nimport { InstanceAttributeBufferManager } from \"../buffer-management/instance-attribute-buffering/instance-attribute-buffer-manager\";\nimport { InstanceAttributePackingBufferManager } from \"../buffer-management/instance-attribute-packed-buffering/instance-attribute-packing-buffer-manager\";\nimport { UniformBufferManager } from \"../buffer-management/uniform-buffering/uniform-buffer-manager\";\nimport { Layer } from \"../layer\";\nimport { Scene } from \"../scene\";\n\nconst debug = require(\"debug\")(\"performance\");\n\nexport enum LayerBufferType {\n  // This is a compatibility mode for instance attributes. This is used when:\n  // 1. It would perform better\n  // 2. When instance attributes are not available for the gl context (ANGLE draw instanced arrays)\n  // 3. When the instance attributes + vertex attributes exceeds the max Vertex Attributes for the hardware and Attribute\n  //    packing still can not fit all of the attributes for the item.\n  UNIFORM,\n  // This is a fast and zippy buffering strategy used when the hardware supports it for a provided layer!\n  INSTANCE_ATTRIBUTE,\n  // This is a slight degradation from the normal INSTANCE_ATTRIBUTE buffering strategy. If provided attributes do\n  // not fit the limited amount of vertex attributes supported by the hardware, then we have one last strategy\n  // to utilize the highly optimized hardware instancing, which is to cram multiple attributes within single\n  // attribute blocks. An attribute block is considered to be 4 32 bit floats. These packed attributes will then\n  // get dereferenced in the shader.\n  INSTANCE_ATTRIBUTE_PACKING\n}\n\n/**\n * This analyzes a layer and determines if it should use a compatibility instancing mode or use hardware\n * instancing.\n */\nexport function getLayerBufferType<T extends Instance>(\n  _gl: WebGLRenderingContext,\n  layer: Layer<T, any>,\n  vertexAttributes: IVertexAttribute[],\n  instanceAttributes: IInstanceAttribute<T>[]\n) {\n  let type = LayerBufferType.UNIFORM;\n  let attributesUsed = 0;\n\n  // The layer only gets it's buffer type calculated once\n  if (layer.bufferType !== undefined) {\n    return layer.bufferType;\n  }\n\n  // Uncomment this to force the uniform buffer strategy\n  // layer.setBufferType(LayerBufferType.UNIFORM);\n  // return LayerBufferType.UNIFORM;\n\n  if (WebGLStat.HARDWARE_INSTANCING) {\n    for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n      const attribute = vertexAttributes[i];\n      attributesUsed += Math.ceil(attribute.size / 4);\n    }\n\n    for (let i = 0, end = instanceAttributes.length; i < end; ++i) {\n      const attribute = instanceAttributes[i];\n      attributesUsed += Math.ceil(\n        instanceAttributeSizeFloatCount[attribute.size || 1] / 4\n      );\n    }\n\n    // Too many attempted single attributes. We will next attempt to see if we can pack the vertex\n    // attributes down into blocks.\n    if (attributesUsed > WebGLStat.MAX_VERTEX_ATTRIBUTES) {\n      attributesUsed = 0;\n\n      for (let i = 0, end = instanceAttributes.length; i < end; ++i) {\n        const attribute = instanceAttributes[i];\n        attributesUsed = Math.max(attributesUsed, attribute.block || 0);\n      }\n\n      for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n        const attribute = vertexAttributes[i];\n        attributesUsed += Math.ceil(attribute.size / 4);\n      }\n\n      // If we can fit now, then we are good to go with using attribute packing\n      if (attributesUsed < WebGLStat.MAX_VERTEX_ATTRIBUTES) {\n        type = LayerBufferType.INSTANCE_ATTRIBUTE_PACKING;\n\n        debug(\n          `Performance Issue (Moderate):\n          Layer %o is utilizing too many vertex attributes and is now using vertex packing.\n          Max Vertex units %o\n          Used Vertex units %o\n          Instance Attributes %o\n          Vertex Attributes %o`,\n          layer.id,\n          WebGLStat.MAX_VERTEX_ATTRIBUTES,\n          attributesUsed,\n          instanceAttributes,\n          vertexAttributes\n        );\n      }\n    } else {\n      // If we make it here, we are good to go using hardware instancing! Hooray performance!\n      type = LayerBufferType.INSTANCE_ATTRIBUTE;\n    }\n  }\n\n  // No other faster mode supported: use uniform instancing\n  if (type === LayerBufferType.UNIFORM) {\n    debug(\n      `Performance Issue (High):\n      Layer %o is utilizing too many vertex attributes and is now using a uniform buffer.\n      Max Vertex units %o\n      Used Vertex units %o\n      Instance Attributes %o\n      Vertex Attributes %o`,\n      layer.id,\n      WebGLStat.MAX_VERTEX_ATTRIBUTES,\n      attributesUsed,\n      instanceAttributes,\n      vertexAttributes\n    );\n    type = LayerBufferType.UNIFORM;\n  }\n\n  // Apply the type to the layer\n  layer.setBufferType(type);\n\n  return type;\n}\n\n/**\n * Builds the proper buffer manager for the provided layer\n */\nexport function makeLayerBufferManager<T extends Instance>(\n  gl: WebGLRenderingContext,\n  layer: Layer<T, any>,\n  scene: Scene\n) {\n  // Esnure the buffering type has been calculated for the layer\n  const type = getLayerBufferType(\n    gl,\n    layer,\n    layer.vertexAttributes,\n    layer.instanceAttributes\n  );\n\n  switch (type) {\n    // This is the Instance Attribute buffering strategy, which means the system\n    case LayerBufferType.INSTANCE_ATTRIBUTE: {\n      layer.setBufferManager(new InstanceAttributeBufferManager(layer, scene));\n      break;\n    }\n\n    // This is the Instance Attribute buffering strategy, which means the system\n    case LayerBufferType.INSTANCE_ATTRIBUTE_PACKING: {\n      layer.setBufferManager(\n        new InstanceAttributePackingBufferManager(layer, scene)\n      );\n      break;\n    }\n\n    // Anything not utiliziing a specialized buffering strategy will use the uniform compatibility mode\n    default: {\n      layer.setBufferManager(new UniformBufferManager(layer, scene));\n      break;\n    }\n  }\n}\n","export * from \"./shader-module\";\nexport * from \"./shader-module-unit\";\n","export * from \"./absolute-position\";\nexport * from \"./bounds\";\nexport * from \"./box\";\nexport * from \"./image\";\nexport * from \"./label\";\nexport * from \"./point\";\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","const { sqrt, max, min } = Math;\n\n/** Explicit Vec1 */\nexport interface IVec1 extends Array<number> {\n  0: number;\n  length: 1;\n}\n\n/** Explicit Vec2 */\nexport interface IVec2 extends Array<number> {\n  0: number;\n  1: number;\n  length: 2;\n}\n\n/** Explicit Vec3 */\nexport interface IVec3 extends Array<number> {\n  0: number;\n  1: number;\n  2: number;\n  length: 3;\n}\n\n/** Explicit Vec4 */\nexport interface IVec4 extends Array<number> {\n  0: number;\n  1: number;\n  2: number;\n  3: number;\n  length: 4;\n}\n\n/** Vector of 1 components */\nexport type Vec1 = [number];\n/** Vector of 2 components */\nexport type Vec2 = [number, number];\n/** Vector of 3 components */\nexport type Vec3 = [number, number, number];\n/** Vector of 4 components */\nexport type Vec4 = [number, number, number, number];\n\n/** Compatible types with Vec1 for operations (just not iterating) */\nexport type Vec1Compat = Vec1 | Vec2 | Vec3 | Vec4;\n/** Compatible types with Vec2 for operations (just not iterating) */\nexport type Vec2Compat = Vec2 | Vec3 | Vec4;\n/** Compatible types with Vec3 for operations (just not iterating) */\nexport type Vec3Compat = Vec3 | Vec4;\n/** Compatible types with Vec4 for operations (just not iterating) */\nexport type Vec4Compat = Vec4;\n\n/** This type defines any possible explicit vector */\nexport type IVec = IVec1 | IVec2 | IVec3 | IVec4;\n/** This type defines any possible vector */\nexport type Vec = Vec1 | Vec2 | Vec3 | Vec4;\n\n// Type guards for Vecs\n\nexport function isVec1(val: any): val is Vec1 {\n  return val && Array.isArray(val) && val.length === 1;\n}\n\nexport function isVec2(val: any): val is Vec2 {\n  return val && Array.isArray(val) && val.length === 2;\n}\n\nexport function isVec3(val: any): val is Vec3 {\n  return val && Array.isArray(val) && val.length === 3;\n}\n\nexport function isVec4(val: any): val is Vec4 {\n  return val && Array.isArray(val) && val.length === 4;\n}\n\n// Vec1 methods\n\nexport function add1(left: Vec1Compat, right: Vec1Compat): Vec1 {\n  return [left[0] + right[0]];\n}\n\nexport function copy1(vec: Vec1Compat): Vec1 {\n  return [vec[0]];\n}\n\nexport function divide1(top: Vec1Compat, bottom: Vec1Compat): Vec1 {\n  return [top[0] / bottom[0]];\n}\n\nexport function inverse1(vec: Vec1Compat): Vec1 {\n  return [1 / vec[0]];\n}\n\nexport function scale1(vec: Vec1Compat, scale: number): Vec1 {\n  return [vec[0] * scale];\n}\n\nexport function subtract1(left: Vec1Compat, right: Vec1Compat): Vec1 {\n  return [left[0] - right[0]];\n}\n\nexport function max1(left: Vec1Compat, right: Vec1Compat): Vec1 {\n  return [max(left[0], right[0])];\n}\n\nexport function min1(left: Vec1Compat, right: Vec1Compat): Vec1 {\n  return [min(left[0], right[0])];\n}\n\nexport function multiply1(left: Vec1Compat, right: Vec1Compat): Vec1 {\n  return [left[0] * right[0]];\n}\n\nexport function dot1(left: Vec1Compat, right: Vec1Compat): number {\n  return left[0] * right[0];\n}\n\nexport function linear1(start: Vec1Compat, end: Vec1Compat, t: number): Vec1 {\n  return scale1(add1(subtract1(end, start), start), t);\n}\n\nexport function length1(start: Vec1Compat): number {\n  return sqrt(dot1(start, start));\n}\n\nexport function vec1(\n  values: number[] | number,\n  ...args: (number | number[])[]\n): Vec1 {\n  let out: number[];\n  args = args || [];\n\n  if (Array.isArray(values)) {\n    out = values.slice(0, 1) as Vec1;\n  } else {\n    out = [values];\n  }\n\n  if (out.length < 1) {\n    for (let i = 0, iMax = args.length; i < iMax && out.length < 1; ++i) {\n      const next = args[i];\n      if (Array.isArray(next)) {\n        out.push(...next.slice(0, 1 - out.length));\n      } else {\n        out.push(next);\n      }\n    }\n  }\n\n  while (out.length < 1) out.push(0);\n\n  return out as Vec1;\n}\n\n// Vec2 methods\n\nexport function add2(left: Vec2Compat, right: Vec2Compat): Vec2 {\n  return [left[0] + right[0], left[1] + right[1]];\n}\n\nexport function copy2(vec: Vec2Compat): Vec2 {\n  return [vec[0], vec[1]];\n}\n\nexport function divide2(top: Vec2Compat, bottom: Vec2Compat): Vec2 {\n  return [top[0] / bottom[0], top[1] / bottom[1]];\n}\n\nexport function inverse2(vec: Vec2Compat): Vec2 {\n  return [1 / vec[0], 1 / vec[1]];\n}\n\nexport function max2(left: Vec2Compat, right: Vec2Compat): Vec2 {\n  return [max(left[0], right[0]), max(left[1], right[1])];\n}\n\nexport function min2(left: Vec2Compat, right: Vec2Compat): Vec2 {\n  return [min(left[0], right[0]), min(left[1], right[1])];\n}\n\nexport function scale2(left: Vec2Compat, scale: number): Vec2 {\n  return [left[0] * scale, left[1] * scale];\n}\n\nexport function subtract2(left: Vec2Compat, right: Vec2Compat): Vec2 {\n  return [left[0] - right[0], left[1] - right[1]];\n}\n\nexport function multiply2(left: Vec2Compat, right: Vec2Compat): Vec2 {\n  return [left[0] * right[0], left[1] * right[1]];\n}\n\nexport function dot2(left: Vec2Compat, right: Vec2Compat): number {\n  return left[0] * right[0] + left[1] * right[1];\n}\n\nexport function linear2(start: Vec2Compat, end: Vec2Compat, t: number): Vec2 {\n  return scale2(add2(subtract2(end, start), start), t);\n}\n\nexport function length2(start: Vec2Compat): number {\n  return sqrt(dot2(start, start));\n}\n\nexport function vec2(\n  values: number[] | number,\n  ...args: (number | number[])[]\n): Vec2 {\n  let out: number[];\n  args = args || [];\n\n  if (Array.isArray(values)) {\n    out = values.slice(0, 2) as Vec2;\n  } else {\n    out = [values];\n  }\n\n  if (out.length < 2) {\n    for (let i = 0, iMax = args.length; i < iMax && out.length < 2; ++i) {\n      const next = args[i];\n      if (Array.isArray(next)) {\n        out.push(...next.slice(0, 2 - out.length));\n      } else {\n        out.push(next);\n      }\n    }\n  }\n\n  while (out.length < 2) out.push(0);\n\n  return out as Vec2;\n}\n\n// Vec3 methods\n\nexport function add3(left: Vec3Compat, right: Vec3Compat): Vec3 {\n  return [left[0] + right[0], left[1] + right[1], left[2] + right[2]];\n}\n\nexport function copy3(vec: Vec3Compat): Vec3 {\n  return [vec[0], vec[1], vec[2]];\n}\n\nexport function divide3(top: Vec3Compat, bottom: Vec3Compat): Vec3 {\n  return [top[0] / bottom[0], top[1] / bottom[1], top[2] / bottom[2]];\n}\n\nexport function inverse3(vec: Vec3Compat): Vec3 {\n  return [1 / vec[0], 1 / vec[1], 1 / vec[2]];\n}\n\nexport function scale3(left: Vec3Compat, scale: number): Vec3 {\n  return [left[0] * scale, left[1] * scale, left[2] * scale];\n}\n\nexport function subtract3(left: Vec3Compat, right: Vec3Compat): Vec3 {\n  return [left[0] - right[0], left[1] - right[1], left[2] - right[2]];\n}\n\nexport function multiply3(left: Vec3Compat, right: Vec3Compat): Vec3 {\n  return [left[0] * right[0], left[1] * right[1], left[2] * right[2]];\n}\n\nexport function linear3(start: Vec3Compat, end: Vec3Compat, t: number): Vec3 {\n  return scale3(add3(subtract3(end, start), start), t);\n}\n\nexport function length3(start: Vec3Compat): number {\n  return sqrt(dot3(start, start));\n}\n\nexport function max3(left: Vec3Compat, right: Vec3Compat): Vec3 {\n  return [\n    max(left[0], right[0]),\n    max(left[1], right[1]),\n    max(left[2], right[2])\n  ];\n}\n\nexport function min3(left: Vec3Compat, right: Vec3Compat): Vec3 {\n  return [\n    min(left[0], right[0]),\n    min(left[1], right[1]),\n    min(left[2], right[2])\n  ];\n}\n\nexport function dot3(left: Vec3Compat, right: Vec3Compat): number {\n  return left[0] * right[0] + left[1] * right[1] + left[2] * right[2];\n}\n\nexport function vec3(\n  values: number[] | number,\n  ...args: (number | number[])[]\n): Vec3 {\n  let out: number[];\n  args = args || [];\n\n  if (Array.isArray(values)) {\n    out = values.slice(0, 3) as Vec3;\n  } else {\n    out = [values];\n  }\n\n  if (out.length < 3) {\n    for (let i = 0, iMax = args.length; i < iMax && out.length < 3; ++i) {\n      const next = args[i];\n      if (Array.isArray(next)) {\n        out.push(...next.slice(0, 3 - out.length));\n      } else {\n        out.push(next);\n      }\n    }\n  }\n\n  while (out.length < 3) out.push(0);\n\n  return out as Vec3;\n}\n\n// Vec4 methods\n\nexport function add4(left: Vec4, right: Vec4): Vec4 {\n  return [\n    left[0] + right[0],\n    left[1] + right[1],\n    left[2] + right[2],\n    left[3] + right[3]\n  ];\n}\n\nexport function copy4(vec: Vec4): Vec4 {\n  return [vec[0], vec[1], vec[2], vec[3]];\n}\n\nexport function divide4(top: Vec4Compat, bottom: Vec4Compat): Vec4 {\n  return [\n    top[0] / bottom[0],\n    top[1] / bottom[1],\n    top[2] / bottom[2],\n    top[3] / bottom[3]\n  ];\n}\n\nexport function inverse4(vec: Vec4): Vec4 {\n  return [1 / vec[0], 1 / vec[1], 1 / vec[2], 1 / vec[3]];\n}\n\nexport function scale4(left: Vec4, scale: number): Vec4 {\n  return [left[0] * scale, left[1] * scale, left[2] * scale, left[3] * scale];\n}\n\nexport function subtract4(left: Vec4, right: Vec4): Vec4 {\n  return [\n    left[0] - right[0],\n    left[1] - right[1],\n    left[2] - right[2],\n    left[3] - right[3]\n  ];\n}\n\nexport function multiply4(left: Vec4, right: Vec4): Vec4 {\n  return [\n    left[0] * right[0],\n    left[1] * right[1],\n    left[2] * right[2],\n    left[3] * right[3]\n  ];\n}\n\nexport function dot4(left: Vec4, right: Vec4): number {\n  return (\n    left[0] * right[0] +\n    left[1] * right[1] +\n    left[2] * right[2] +\n    left[3] * right[3]\n  );\n}\n\nexport function linear4(start: Vec4, end: Vec4, t: number): Vec4 {\n  return scale4(add4(subtract4(end, start), start), t);\n}\n\nexport function length4(start: Vec4): number {\n  return sqrt(dot4(start, start));\n}\n\nexport function max4(left: Vec4Compat, right: Vec4Compat): Vec4 {\n  return [\n    max(left[0], right[0]),\n    max(left[1], right[1]),\n    max(left[2], right[2]),\n    max(left[3], right[3])\n  ];\n}\n\nexport function min4(left: Vec4Compat, right: Vec4Compat): Vec4 {\n  return [\n    min(left[0], right[0]),\n    min(left[1], right[1]),\n    min(left[2], right[2]),\n    min(left[3], right[3])\n  ];\n}\n\nexport function vec4(\n  values: number[] | number,\n  ...args: (number | number[])[]\n): Vec4 {\n  let out: number[];\n  args = args || [];\n\n  if (Array.isArray(values)) {\n    out = values.slice(0, 4) as Vec4;\n  } else {\n    out = [values];\n  }\n\n  if (out.length < 4) {\n    for (let i = 0, iMax = args.length; i < iMax && out.length < 4; ++i) {\n      const next = args[i];\n      if (Array.isArray(next)) {\n        out.push(...next.slice(0, 4 - out.length));\n      } else {\n        out.push(next);\n      }\n    }\n  }\n\n  while (out.length < 4) out.push(0);\n\n  return out as Vec4;\n}\n\n// Vec method aggregations\n\nexport type VecMethods<T extends Vec> = {\n  add(left: T, right: T): T;\n  copy(vec: T): T;\n  divide(top: T, bottom: T): T;\n  dot(left: T, right: T): number;\n  inverse(vec: T): T;\n  length(vec: T): number;\n  linear(start: T, end: T, t: number): T;\n  max(left: T, right: T): T;\n  min(left: T, right: T): T;\n  multiply(left: T, right: T): T;\n  scale(vec: T, scale: number): T;\n  subtract(left: T, right: T): T;\n};\n\nexport const vec1Methods: VecMethods<Vec1> = {\n  add: add1,\n  copy: copy1,\n  divide: divide1,\n  dot: dot1,\n  inverse: inverse1,\n  length: length1,\n  linear: linear1,\n  max: max1,\n  min: min1,\n  multiply: multiply1,\n  scale: scale1,\n  subtract: subtract1\n};\n\nexport const vec2Methods: VecMethods<Vec2> = {\n  add: add2,\n  copy: copy2,\n  divide: divide2,\n  dot: dot2,\n  inverse: inverse2,\n  length: length2,\n  linear: linear2,\n  max: max2,\n  min: min2,\n  multiply: multiply2,\n  scale: scale2,\n  subtract: subtract2\n};\n\nexport const vec3Methods: VecMethods<Vec3> = {\n  add: add3,\n  copy: copy3,\n  divide: divide3,\n  dot: dot3,\n  inverse: inverse3,\n  length: length3,\n  linear: linear3,\n  max: max3,\n  min: min3,\n  multiply: multiply3,\n  scale: scale3,\n  subtract: subtract3\n};\n\nexport const vec4Methods: VecMethods<Vec4> = {\n  add: add4,\n  copy: copy4,\n  divide: divide4,\n  dot: dot4,\n  inverse: inverse4,\n  length: length4,\n  linear: linear4,\n  max: max4,\n  min: min4,\n  multiply: multiply4,\n  scale: scale4,\n  subtract: subtract4\n};\n\nexport function VecMath<T extends IVec>(vec: T): VecMethods<T> {\n  let methods: VecMethods<T>;\n\n  if (vec.length === 1) {\n    methods = vec1Methods as VecMethods<T>;\n    return methods;\n  } else if (vec.length === 2) {\n    methods = vec2Methods as VecMethods<T>;\n    return methods;\n  } else if (vec.length === 3) {\n    methods = vec3Methods as VecMethods<T>;\n    return methods;\n  }\n\n  methods = vec4Methods as VecMethods<T>;\n\n  return methods;\n}\n","import * as Three from \"three\";\nimport { IModelConstructable, Layer } from \"../layer\";\n\nfunction isMesh(val: any): val is Three.Mesh {\n  return Boolean(val.isMesh);\n}\n\nexport function generateLayerModel(\n  layer: Layer<any, any>,\n  geometry: Three.BufferGeometry,\n  material: Three.ShaderMaterial\n): IModelConstructable & Three.Object3D {\n  const modelInfo = layer.getModelType();\n  const model = new modelInfo.modelType(geometry, material);\n\n  if (isMesh(model)) {\n    model.drawMode =\n      modelInfo.drawMode === undefined\n        ? Three.TriangleStripDrawMode\n        : modelInfo.drawMode;\n  }\n\n  return model;\n}\n","export * from \"./atlas\";\nexport * from \"./atlas-manager\";\nexport * from \"./color-atlas-resource\";\nexport * from \"./color-rasterizer\";\nexport * from \"./image-atlas-resource\";\nexport * from \"./image-rasterizer\";\nexport * from \"./label-atlas-resource\";\nexport * from \"./label-rasterizer\";\n","export interface IdentifyByKeyOptions {\n  /** The identifier of the object */\n  key: string;\n}\n\n/**\n * This is an object that specifically is generated with a 'key' option that can never\n * be modified on the object and is identified henceforth with the key applied as the\n * 'id' of the object.\n */\nexport class IdentifyByKey {\n  /** Internal key held by the object */\n  private key: string;\n\n  /** READONLY id of the object. */\n  get id() {\n    return this.key;\n  }\n\n  constructor(options: IdentifyByKeyOptions) {\n    this.key = options.key;\n  }\n}\n","export interface IShaderTemplateResults {\n  /** This is the resulting shader string generated from the templating */\n  shader: string;\n  /** This is the template options provided by the shader. {option: num occurrences} */\n  shaderProvidedOptions: Map<string, number>;\n  /**\n   * This is the template options provided by the shader that were not resolved by the options parameter\n   * {option: num occurrences}\n   */\n  unresolvedShaderOptions: Map<string, number>;\n  /** This is the options provided to the template that did not get resolved by the shader {option: 1} */\n  unresolvedProvidedOptions: Map<string, number>;\n  /** This is the list of options that DID get resolved by the options provided {option: num occurrences} */\n  resolvedShaderOptions: Map<string, number>;\n}\n\nexport interface IShaderTemplateRequirements {\n  /** A string identifier to make it easier to identify which shader template failed requirements */\n  name: string;\n  /** The options that must be present within both provided options AND within the template */\n  values: string[];\n}\n\nexport interface IShaderTemplateOptions {\n  /** Callback for 'required' errors being emitted */\n  onError?(msg: string): void;\n  /** Callback that allows overrides for token replacement. Provides the token found and the suggested replacement for it */\n  onToken?(token: string, replace: string): string;\n  /** This is a key value pair the template uses to match tokens found to replacement values */\n  options: { [key: string]: string };\n  /** This is used to indicate which tokens are required both within the shader AND within the 'options' */\n  required?: IShaderTemplateRequirements;\n  /** THis is the shader written with templating information */\n  shader: string;\n}\n\n/**\n * This is a method that aids in making shaders a bit more dynamic with simple string replacement based on tokens written\n * into the shader. Tokens in the shader will appear as ${token} and will either be ignored by this method and thus removed\n * or will be replaced with a provided value.\n *\n * This method will give feedback on the replacements taking place and simplify the process of detecting errors within the process.\n */\nexport function shaderTemplate(\n  templateOptions: IShaderTemplateOptions\n): IShaderTemplateResults {\n  const { shader, options, required, onError, onToken } = templateOptions;\n  const matched = new Map<string, number>();\n  const noValueProvided = new Map<string, number>();\n  const notFound = new Map<string, number>();\n  const shaderOptions = new Map<string, number>();\n\n  const shaderResults = shader.replace(\n    /\\$\\{([^\\}]*)\\}/g,\n    (_x: string, match: string) => {\n      let replace = \"\";\n      shaderOptions.set(match, (shaderOptions.get(match) || 0) + 1);\n\n      if (match in options) {\n        matched.set(match, (matched.get(match) || 0) + 1);\n        replace = options[match];\n      } else {\n        noValueProvided.set(match, (noValueProvided.get(match) || 0) + 1);\n      }\n\n      if (onToken) {\n        replace = onToken(match, replace);\n      }\n\n      return replace;\n    }\n  );\n\n  Object.keys(options).forEach(option => {\n    if (!matched.get(option)) {\n      notFound.set(option, (notFound.get(option) || 0) + 1);\n    }\n  });\n\n  // Provide metrics\n  const results = {\n    resolvedShaderOptions: matched,\n    shader: shaderResults,\n    shaderProvidedOptions: shaderOptions,\n    unresolvedProvidedOptions: notFound,\n    unresolvedShaderOptions: noValueProvided\n  };\n\n  if (required) {\n    // This will ensure that BOTH the parameter input AND the shader provided the required options.\n    required.values.forEach(require => {\n      if (results.unresolvedProvidedOptions.get(require)) {\n        const msg = `${\n          required.name\n        }: Could not resolve all the required inputs. Input: ${require}`;\n        if (onError) onError(msg);\n        else console.error(msg);\n      } else if (results.unresolvedShaderOptions.get(require)) {\n        const msg = `${\n          required.name\n        }: A required option was not provided in the options parameter. Option: ${require}`;\n        if (onError) onError(msg);\n        else console.error(msg);\n      } else if (!results.resolvedShaderOptions.get(require)) {\n        const msg = `${\n          required.name\n        }: A required option was not provided in the options parameter. Option: ${require}`;\n        if (onError) onError(msg);\n        else console.error(msg);\n      }\n    });\n  }\n\n  return results;\n}\n","/** Important to start UIDs at 1 so that falsey evaluations do not pass when examining UIDs */\nlet UID = 1;\n\n/**\n * Provides a 64 bit UID.\n *\n * Note: all uids generated with uid() are unique amongst uid() calls and NOT unique amongst\n * other types of uid calls.\n */\nexport function uid() {\n  return ++UID;\n}\n\nlet CUID = 0;\n\n/**\n * Provides a 24 bit UID (keeps the UID within non-alpha color ranges)\n *\n * Note: all uids generated with colorUID() are unique amongst colorUID() calls and NOT unique amongst\n * other types of uid calls.\n */\nexport function colorUID() {\n  return ++CUID % 0xffffff;\n}\n","import { uid } from \"../util/uid\";\nimport { Instance } from \"./instance\";\n\nexport class ObservableMonitoring {\n  static gatherIds: boolean = false;\n  static observableIds: number[] = [];\n  static observableNamesToUID = new Map<string, number>();\n\n  /**\n   * This activates all observables to gather their UIDs when they are retrieved via their getter.\n   * All of the ID's gathered can be accessed via getObservableMonitorIds. It is REQUIRED that this\n   * is disabled again to prevent a MASSIVE memory leak.\n   */\n  static setObservableMonitor(enabled: boolean) {\n    ObservableMonitoring.gatherIds = enabled;\n    ObservableMonitoring.observableIds = [];\n  }\n\n  /**\n   * This retrieves the observables montiored IDs that were gathered when setObservableMonitor was\n   * enabled.\n   */\n  static getObservableMonitorIds(clear?: boolean) {\n    const values = ObservableMonitoring.observableIds.slice(0);\n    if (clear) ObservableMonitoring.observableIds = [];\n\n    return values;\n  }\n}\n\n/**\n * This is a custom decorator intended for single properties on Instances only! It will\n * facilitate automatic updates and stream the updates through an InstanceProvider to properly\n * update the Instances values in the appropriate and corresponding buffers that will get committed\n * to the GPU.\n */\nexport function observable<T extends Instance>(target: T, key: string) {\n  // Here we store the name of the observable to a UID. This mapping allows us to have a UID\n  // per NAME of an observable. A UID for a name can produce MUCH faster lookups than the name itself.\n  // Matching against the name allows us to have instances with their own property sets but have matching\n  // name mappings to improve compatibility of Instances with varying Layers.\n  let propertyUID: number =\n    ObservableMonitoring.observableNamesToUID.get(key) || 0;\n\n  if (!propertyUID) {\n    propertyUID = uid();\n    ObservableMonitoring.observableNamesToUID.set(key, propertyUID);\n  }\n\n  /**\n   * New property getter to get the property's alternative storage since we overrode\n   * the initial storage with a custom getter and setter.\n   */\n  function getter(this: T) {\n    if (ObservableMonitoring.gatherIds) {\n      ObservableMonitoring.observableIds.push(propertyUID);\n    }\n    return this.observableStorage[propertyUID];\n  }\n\n  /**\n   * New property setter to replace the property marked as observable. This allows\n   * us to broadcast a change to our current observer.\n   */\n  function setter(this: T, newVal: any) {\n    // Update the privatized value\n    this.observableStorage[propertyUID] = newVal;\n    // Broadcast change\n    this.changes[propertyUID] = propertyUID;\n    this.observer && this.observer.instanceUpdated(this);\n  }\n\n  /**\n   * Make sure the desired property is declared on the class with our custom getter and\n   * setter.\n   */\n  Object.defineProperty(target, key, {\n    configurable: true,\n    enumerable: true,\n    get: getter,\n    set: setter\n  });\n}\n","import * as Three from \"three\";\nimport {\n  AbsolutePosition,\n  getAbsolutePositionBounds\n} from \"../primitives/absolute-position\";\nimport { Bounds } from \"../primitives/bounds\";\nimport { Color } from \"../types\";\nimport { Vec2 } from \"../util\";\nimport { ChartCamera } from \"../util/chart-camera\";\nimport { DataBounds } from \"../util/data-bounds\";\nimport { IdentifyByKey, IdentifyByKeyOptions } from \"../util/identify-by-key\";\nimport { ViewCamera, ViewCameraType } from \"../util/view-camera\";\n\nexport enum ClearFlags {\n  COLOR = 0b0001,\n  DEPTH = 0b0010,\n  STENCIL = 0b0100\n}\n\n/**\n * Defines the input metrics of a view for a scene.\n */\nexport interface IViewOptions extends IdentifyByKeyOptions {\n  /**\n   * The background color that gets cleared out for this view. Performance is\n   * better if this is left clear. Probably better to draw a colored quad instead.\n   * This is just convenient.\n   */\n  background?: Color;\n  /**\n   * This is the spatial charting camera that is concerned with offsets and scales.\n   * It is often easier to work with camera positioning and settings rather than working\n   * with the complex and nuanced viewCamera which works with special transformation matrices\n   * to express orientation.\n   *\n   * If not provided, then this camera will use a default ChartCamera for this camera slot. This\n   * will also cause a normal camera handler to be utilized.\n   */\n  camera?: ChartCamera;\n  /**\n   * This sets what buffers get cleared by webgl before the view is drawn in it's space.\n   */\n  clearFlags?: ClearFlags[];\n  /**\n   * If this is provided, the layer can be rendered with a traditional camera that utilizes\n   * matrix transforms to provide orientation/projection for the view.\n   *\n   * If this is NOT provided, the camera will be a special orthographic camera for 2d spaces\n   * with a y-axis of +y points down with (0, 0) at the top left of the viewport.\n   */\n  viewCamera?: ViewCamera;\n  /**\n   * This specifies the bounds on the canvas this camera will render to. This let's you render\n   * say a little square in the bottom right showing a minimap.\n   *\n   * If this is not specified, the entire canvas will be the viewport.\n   */\n  viewport: AbsolutePosition;\n}\n\nfunction isOrthographic(val: Three.Camera): val is Three.OrthographicCamera {\n  return \"left\" in val;\n}\n\n/**\n * This defines a view of a scene\n */\nexport class View extends IdentifyByKey {\n  static DEFAULT_VIEW_ID = \"__default__\";\n\n  /** If present, is the cleared color before this view renders */\n  background: Color;\n  /** Camera that defines the individual components of each axis with simpler concepts */\n  camera: ChartCamera;\n  /** These are the clear flags set for this view */\n  clearFlags: ClearFlags[];\n  /**\n   * This is the depth of the view. The higher the depth represents which layer is on top.\n   * Zero always represents the default view.\n   */\n  depth: number = 0;\n  /** This is set to ensure the projections that happen properly translates the pixel ratio to normal Web coordinates */\n  pixelRatio: number = window.devicePixelRatio;\n  /** This is the rendering bounds within screen space */\n  screenBounds: Bounds;\n  /** Camera that defines the view projection matrix */\n  viewCamera: ViewCamera;\n  /** The size positioning of the view */\n  viewport: AbsolutePosition;\n  /** The bounds of the render space on the canvas this view will render on */\n  viewBounds: DataBounds<View>;\n  /** This is the flag to see if a view needs draw */\n  needsDraw: boolean = false;\n  /** End time of animation */\n  animationEndTime: number = 0;\n\n  constructor(options: IViewOptions) {\n    super(options);\n    Object.assign(this, options);\n  }\n\n  screenToPixelSpace(point: Vec2, out?: Vec2) {\n    const p = out || [0, 0];\n\n    p[0] = point[0] * this.pixelRatio;\n    p[1] = point[1] * this.pixelRatio;\n\n    return p;\n  }\n\n  pixelSpaceToScreen(point: Vec2, out?: Vec2) {\n    const p = out || [0, 0];\n\n    p[0] = point[0] / this.pixelRatio;\n    p[1] = point[1] / this.pixelRatio;\n\n    return p;\n  }\n\n  screenToView(point: Vec2, out?: Vec2) {\n    const p = this.screenToPixelSpace(point, out);\n\n    p[0] = p[0] - this.viewBounds.x;\n    p[1] = p[1] - this.viewBounds.y;\n\n    return p;\n  }\n\n  viewToScreen(point: Vec2, out?: Vec2) {\n    const p: Vec2 = [0, 0];\n\n    p[0] = point[0] + this.viewBounds.x;\n    p[1] = point[1] + this.viewBounds.y;\n\n    return this.pixelSpaceToScreen(p, out);\n  }\n\n  screenToWorld(point: Vec2, out?: Vec2) {\n    const view = this.pixelSpaceToScreen(this.screenToView(point));\n\n    const world = out || [0, 0];\n    world[0] =\n      (view[0] - this.camera.offset[0] * this.camera.scale[0]) /\n      this.camera.scale[0];\n    world[1] =\n      (view[1] - this.camera.offset[1] * this.camera.scale[1]) /\n      this.camera.scale[1];\n\n    // If this is a custom camera, we must actually project our world point to the screen\n    if (this.viewCamera.type === ViewCameraType.CUSTOM) {\n      console.warn(\"Custom View Camera projections not supported yet\");\n    }\n\n    return world;\n  }\n\n  worldToScreen(point: Vec2, out?: Vec2) {\n    const screen: Vec2 = [0, 0];\n\n    // Calculate from the camera to view space\n    screen[0] =\n      (point[0] * this.camera.scale[0] +\n        this.camera.offset[0] * this.camera.scale[0]) *\n      this.pixelRatio;\n    screen[1] =\n      (point[1] * this.camera.scale[1] +\n        this.camera.offset[1] * this.camera.scale[1]) *\n      this.pixelRatio;\n\n    // If this is a custom camera, we must actually project our world point to the screen\n    if (this.viewCamera.type === ViewCameraType.CUSTOM) {\n      console.warn(\"Custom View Camera projections not supported yet\");\n    }\n\n    // Convert from view to screen space\n    return this.viewToScreen(screen, out);\n  }\n\n  viewToWorld(point: Vec2, out?: Vec2) {\n    const world = out || [0, 0];\n\n    const screen = this.pixelSpaceToScreen(point);\n    world[0] =\n      (screen[0] - this.camera.offset[0] * this.camera.scale[0]) /\n      this.camera.scale[0];\n    world[1] =\n      (screen[1] - this.camera.offset[1] * this.camera.scale[1]) /\n      this.camera.scale[1];\n\n    // If this is a custom camera, we must actually project our world point to the screen\n    if (this.viewCamera.type === ViewCameraType.CUSTOM) {\n      console.warn(\"Custom View Camera projections not supported yet\");\n    }\n\n    return world;\n  }\n\n  worldToView(point: Vec2, out?: Vec2) {\n    const screen = out || [0, 0];\n\n    // Calculate from the camera to view space\n    screen[0] =\n      point[0] * this.camera.scale[0] +\n      this.camera.offset[0] * this.camera.scale[0];\n    screen[1] =\n      point[1] * this.camera.scale[1] +\n      this.camera.offset[1] * this.camera.scale[1];\n\n    // If this is a custom camera, we must actually project our world point to the screen\n    if (this.viewCamera.type === ViewCameraType.CUSTOM) {\n      console.warn(\"Custom View Camera projections not supported yet\");\n    }\n\n    return screen;\n  }\n\n  /**\n   * This operation makes sure we have the view camera adjusted to the new viewport's needs.\n   * For default behavior this ensures that the coordinate system has no distortion, orthographic,\n   * top left as 0,0 with +y axis pointing down.\n   */\n  fitViewtoViewport(surfaceDimensions: Bounds) {\n    if (\n      this.viewCamera.type === ViewCameraType.CONTROLLED &&\n      isOrthographic(this.viewCamera.baseCamera)\n    ) {\n      const viewBounds = getAbsolutePositionBounds<View>(\n        this.viewport,\n        surfaceDimensions,\n        this.pixelRatio\n      );\n\n      const width = viewBounds.width;\n      const height = viewBounds.height;\n\n      const viewport = {\n        bottom: -height / 2,\n        far: 10000000,\n        left: -width / 2,\n        near: -100,\n        right: width / 2,\n        top: height / 2\n      };\n\n      const scaleX = 1;\n      const scaleY = 1;\n      const camera = this.viewCamera.baseCamera;\n\n      Object.assign(camera, viewport);\n      camera.position.set(\n        -viewBounds.width / 2.0 * scaleX,\n        viewBounds.height / 2.0 * scaleY,\n        camera.position.z\n      );\n      camera.scale.set(scaleX, -scaleY, 1.0);\n      camera.updateMatrix();\n      camera.updateMatrixWorld(true);\n      camera.updateProjectionMatrix();\n\n      this.viewBounds = viewBounds;\n      this.viewBounds.data = this;\n      this.screenBounds = new Bounds({\n        height: this.viewBounds.height / this.pixelRatio,\n        width: this.viewBounds.width / this.pixelRatio,\n        x: this.viewBounds.x / this.pixelRatio,\n        y: this.viewBounds.y / this.pixelRatio\n      });\n    } else if (!isOrthographic(this.viewCamera.baseCamera)) {\n      console.warn(\n        \"Fit to viewport does not support non-orthographic cameras as a default behavior.\"\n      );\n    }\n  }\n}\n","import * as Three from \"three\";\nimport { Instance } from \"../instance-provider/instance\";\nimport { ILayerProps, Layer } from \"../surface/layer\";\nimport { IdentifyByKey, IdentifyByKeyOptions } from \"../util/identify-by-key\";\nimport { IViewOptions, View } from \"./view\";\n\n/**\n * Defines the input for an available scene layers can add themselves to. Each scene can be rendered with multiple\n * views.\n */\nexport interface ISceneOptions extends IdentifyByKeyOptions {\n  /**\n   * This indicates all of the views this scene can be rendered with. For instance: You have a\n   * world scene and you want to render it stereoscopically for VR. Then you can specify two\n   * views with two viewports to render the scene on both halves of the canvas.\n   *\n   * Or perhaps you want an aerial shot as a minimap in the bottom right corner while the rest\n   * of the canvas renders a first person view, then you would make two views for that as well.\n   */\n  views: IViewOptions[];\n}\n\nfunction sortByDepth(a: Layer<any, any>, b: Layer<any, any>) {\n  return a.depth - b.depth;\n}\n\n/**\n * This defines a scene to which layers are added to. It also tracks the views that this scene\n * is rendered with.\n */\nexport class Scene extends IdentifyByKey {\n  static DEFAULT_SCENE_ID = \"__default__\";\n\n  /** This is the three scene which actually sets up the rendering objects */\n  container: Three.Scene | undefined = new Three.Scene();\n  // TODO: This 'could' be smarter when Three is gone. The pipeline could IMMEDIATELY render\n  /** We make a picking container specifically for the cases where objects must be rendered for picking */\n  pickingContainer: Three.Scene = new Three.Scene();\n  /** This is all of the layers tracked to the scene */\n  layers: Layer<any, any>[] = [];\n  /** This indicates the sort is dirty for a set of layers */\n  sortIsDirty = false;\n  /** This is the view */\n  viewById = new Map<string, View>();\n\n  constructor(options: ISceneOptions) {\n    super(options);\n\n    if (this.container) {\n      this.container.frustumCulled = false;\n      this.container.autoUpdate = false;\n    }\n  }\n\n  /**\n   * Adds a layer to the scene with the current view setting the layer contains.\n   * The layer can not jump between views or scenes. You must destroy and reconstruct\n   * the layer.\n   */\n  addLayer<T extends Instance, U extends ILayerProps<T>>(layer: Layer<T, U>) {\n    // Add the layer to the list of layers under the view\n    this.layers.push(layer);\n    this.sortIsDirty = true;\n  }\n\n  /**\n   * This adds a view to this scene to be used by the scene\n   */\n  addView(view: View) {\n    this.viewById.set(view.id, view);\n  }\n\n  /**\n   * Release any resources this may be hanging onto\n   */\n  destroy() {\n    delete this.container;\n  }\n\n  /**\n   * Removes a layer from the scene. No resort is needed as remove operations\n   * do not adjust the sorting order.\n   */\n  removeLayer(layer: Layer<any, any>) {\n    if (this.layers) {\n      const index = this.layers.indexOf(layer);\n\n      if (index >= 0) {\n        this.layers.splice(index, 1);\n        return;\n      }\n    }\n\n    console.warn(\n      \"Could not remove a layer from the scene as the layer was not a part of the scene to start. Scene:\",\n      this.id,\n      \"Layer:\",\n      layer.id\n    );\n  }\n\n  sortLayers() {\n    if (this.sortIsDirty) {\n      this.layers.sort(sortByDepth);\n    }\n  }\n}\n","import { Label } from \"../../primitives/label\";\nimport { BaseAtlasResource } from \"./base-atlas-resource\";\n\nexport class LabelAtlasResource extends BaseAtlasResource {\n  /** This is the label to be loaded into the atlas */\n  label: Label;\n  /** If the label renders */\n  truncatedText: string;\n\n  constructor(label: Label) {\n    super();\n    this.label = label;\n  }\n}\n","import { SubTexture } from \"./sub-texture\";\n\nexport class BaseAtlasResource {\n  /** The rasterization metrics of the label */\n  rasterization: {\n    /**\n     * WARNING: This will ONLY SOMETIMES be populated. The system can choose\n     * when to consume this as it chooses as it can be a major memory eater if\n     * permanently left in place. DO NOT RELY on this being available.\n     */\n    canvas?: HTMLCanvasElement;\n    image?: HTMLImageElement;\n    /** The rasterization dimensions as it is rendered to texture space on an atlas */\n    texture: {\n      height: number;\n      width: number;\n    };\n    /** The rasterization dimensions as it would be rendered in world space */\n    world: {\n      height: number;\n      width: number;\n    };\n  };\n  /**\n   * This sets the ratserization to be a larger value on the texture than is rendered within\n   * the world space. This allows for techniques to be applied in the shaders to incorporate super sampling\n   * or other processes which require higher levels of resolution.\n   *\n   * The default is 1 for a 1 to 1 sample scaling to world space rendering\n   */\n  sampleScale: number = 1;\n  /** Once loaded into the texture, this will be populated */\n  texture: SubTexture;\n}\n","export enum EdgeScaleType {\n  /** All dimensions are within world space */\n  NONE,\n  /**\n   * The control points are a delta from the end points within screen space, and the line thickness is within\n   * screen space as well all measured in pixels. The scaleFactor scales both thickness and control delta values.\n   * The endpoints remain in world space\n   */\n  SCREEN_CURVE\n}\n\nexport enum EdgeType {\n  /** Makes a straight edge with no curve */\n  LINE,\n  /** Makes a single control point Bezier curve */\n  BEZIER,\n  /** Makes a two control point bezier curve */\n  BEZIER2\n}\n\n/**\n * This is the broadphase control for edges to help handle quad tree adjustments for picking. If the edge scale type\n * is NONE, you don't need to utilize this. If you use screen space and have camera distortions along an axis, this\n * can help greatly.\n */\nexport enum EdgeBroadphase {\n  /** Use this if the broad phase detection should use both width and height of the edge's bounds */\n  ALL,\n  /** Use this to ensure a test against the edge is performed if the mouse aligns with it on the x-axis */\n  PASS_Y,\n  /** Use this to ensure a test against the edge is performed if the mouse aligns with it on the y axis */\n  PASS_X\n}\n","import * as Three from \"three\";\nimport { Instance, InstanceDiff } from \"../../../instance-provider\";\nimport { BaseDiffProcessor } from \"../base-diff-processor\";\nimport { isBufferLocation } from \"../buffer-manager-base\";\nimport { IInstanceDiffManagerTarget } from \"../instance-diff-manager\";\nimport { IUniformBufferLocation } from \"./uniform-buffer-manager\";\n\n// This is a mapping of the vector properties as they relate to an array order\nconst VECTOR_ACCESSORS: (keyof Three.Vector4)[] = [\"x\", \"y\", \"z\", \"w\"];\nconst EMPTY: number[] = [];\n\n/**\n * Manages diffs for layers that are utilizing the base uniform instancing buffer strategy.\n */\nexport class UniformDiffProcessor<T extends Instance> extends BaseDiffProcessor<\n  T\n> {\n  /**\n   * This processes add operations from changes in the instancing data\n   */\n  addInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster?: IUniformBufferLocation\n  ) {\n    // If the uniform cluster already exists, then we swap over to a change update\n    if (uniformCluster) {\n      manager.changeInstance(manager, instance, EMPTY, uniformCluster);\n    } else {\n      // Otherwise, we DO need to perform an add and we link a Uniform cluster to our instance\n      const uniforms = manager.layer.bufferManager.add(instance);\n\n      if (isBufferLocation(uniforms)) {\n        instance.active = true;\n        instance.easingId = manager.layer.easingId;\n        manager.updateInstance(manager.layer, instance, uniforms);\n      }\n    }\n  }\n\n  /**\n   * This processes change operations from changes in the instancing data\n   */\n  changeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster?: IUniformBufferLocation\n  ) {\n    // If there is an existing uniform cluster for this instance, then we can update the uniforms\n    if (uniformCluster) {\n      manager.updateInstance(manager.layer, instance, uniformCluster);\n    } else {\n      // If we don't have existing uniforms, then we must remove the instance\n      manager.addInstance(manager, instance, EMPTY, uniformCluster);\n    }\n  }\n\n  /**\n   * This processes remove operations from changes in the instancing data\n   */\n  removeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster?: IUniformBufferLocation\n  ) {\n    if (uniformCluster) {\n      // We deactivate the instance so it does not render anymore\n      instance.active = false;\n      // Remove the easing information the instance gained from being apart of the layer\n      instance.clearEasing();\n      // We do one last update on the instance to update to it's deactivated state\n      manager.updateInstance(manager.layer, instance, uniformCluster);\n      // Unlink the instance from the uniform cluster\n      manager.layer.bufferManager.remove(instance);\n    }\n  }\n\n  /**\n   * This performs the actual updating of buffers the instance needs to update\n   */\n  updateInstance(\n    layer: IInstanceDiffManagerTarget<T>,\n    instance: T,\n    uniformCluster: IUniformBufferLocation\n  ) {\n    if (instance.active) {\n      const uniforms = uniformCluster.buffer;\n      const uniformRangeStart = uniformCluster.range[0];\n      const instanceData: Three.Vector4[] = uniforms.value;\n      let instanceUniform, value, block, start;\n      let k, endk;\n\n      // Loop through the instance attributes and update the uniform cluster with the valaues\n      // Calculated for the instance\n      for (let i = 0, end = layer.instanceAttributes.length; i < end; ++i) {\n        instanceUniform = layer.instanceAttributes[i];\n        value = instanceUniform.update(instance);\n        block = instanceData[uniformRangeStart + (instanceUniform.block || 0)];\n        instanceUniform.atlas &&\n          layer.resource.setTargetAtlas(instanceUniform.atlas.key);\n        start = instanceUniform.blockIndex;\n\n        if (start === undefined) {\n          continue;\n        }\n\n        // Hyper optimized vector filling routine. It uses properties that are globally scoped\n        // To greatly reduce overhead\n        for (k = start, endk = value.length + start; k < endk; ++k) {\n          block[VECTOR_ACCESSORS[k]] = value[k - start];\n        }\n      }\n\n      uniforms.value = instanceData;\n    } else {\n      const uniforms: Three.IUniform = uniformCluster.buffer;\n      const uniformRangeStart = uniformCluster.range[0];\n      const instanceData: Three.Vector4[] = uniforms.value;\n      let instanceUniform, value, block, start;\n\n      // Only update the _active attribute to ensure it is false. When it is false, there is no\n      // Point to updating any other uniform\n      instanceUniform = layer.activeAttribute;\n      value = instanceUniform.update(instance);\n      block = instanceData[uniformRangeStart + (instanceUniform.block || 0)];\n      instanceUniform.atlas &&\n        layer.resource.setTargetAtlas(instanceUniform.atlas.key);\n      start = instanceUniform.blockIndex;\n\n      if (start !== undefined) {\n        // Hyper optimized vector filling routine. It uses properties that are globally scoped\n        // To greatly reduce overhead\n        for (let k = start, endk = value.length + start; k < endk; ++k) {\n          block[VECTOR_ACCESSORS[k]] = value[k - start];\n        }\n      }\n\n      uniforms.value = instanceData;\n    }\n  }\n\n  /**\n   * Right now there is no operations for committing for the uniform manager.\n   */\n  commit() {\n    /** no-op */\n  }\n\n  /**\n   * There are no optimizations available for this processor yet.\n   */\n  incomingChangeList(_changes: InstanceDiff<T>[]) {\n    /** no-op */\n  }\n}\n","import { Instance } from \"../../../instance-provider/instance\";\nimport { InstanceDiff } from \"../../../instance-provider/instance-provider\";\nimport { IInstanceAttributeInternal } from \"../../../types\";\nimport { Vec } from \"../../../util\";\nimport { BaseDiffProcessor } from \"../base-diff-processor\";\nimport {\n  IBufferLocation,\n  IBufferLocationGroup,\n  isBufferLocationGroup\n} from \"../buffer-manager-base\";\nimport { IInstanceDiffManagerTarget } from \"../instance-diff-manager\";\nimport { IInstanceAttributeBufferLocationGroup } from \"./instance-attribute-buffer-manager\";\n\nconst EMPTY: number[] = [];\nconst { min, max } = Math;\n\nenum DiffMode {\n  /** This mode will analyze incoming buffer location changes and only update the range of changed buffer */\n  PARTIAL,\n  /** This mode will not spend time figuring out what has changed for a buffer, rather the whole buffer will get an update */\n  FULL\n}\n\n/**\n * Manages diffs for layers that are utilizing the base uniform instancing buffer strategy.\n */\nexport class InstanceAttributeDiffProcessor<\n  T extends Instance\n> extends BaseDiffProcessor<T> {\n  /** This is the processor's current diff mode for consuming instance updates. */\n  private diffMode: DiffMode = DiffMode.PARTIAL;\n\n  /** This tracks a buffer attribute's uid to the range of data that it should update */\n  bufferAttributeUpdateRange: {\n    [key: number]: [IInstanceAttributeInternal<T>, number, number];\n  } = {};\n\n  /** This tracks a buffer attribute's uid that will perform a complete update */\n  bufferAttributeWillUpdate: {\n    [key: number]: IInstanceAttributeInternal<T>;\n  } = {};\n\n  /**\n   * The instance updating is a property instead of a method as we will want to be able to gear shift it for varying levels\n   * of adjustments.\n   */\n  updateInstance: (\n    layer: IInstanceDiffManagerTarget<T>,\n    instance: T,\n    propIds: number[],\n    bufferLocations: IBufferLocationGroup<IBufferLocation>\n  ) => void = this.updateInstancePartial;\n\n  /**\n   * This processes add operations from changes in the instancing data\n   */\n  addInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    bufferLocations?: IInstanceAttributeBufferLocationGroup\n  ) {\n    // If the uniform cluster already exists, then we swap over to a change update\n    if (bufferLocations) {\n      manager.changeInstance(manager, instance, EMPTY, bufferLocations);\n    } else {\n      // Otherwise, we DO need to perform an add and we link a Uniform cluster to our instance\n      const newBufferLocations = manager.layer.bufferManager.add(instance);\n\n      if (isBufferLocationGroup(newBufferLocations)) {\n        instance.active = true;\n        instance.easingId = manager.layer.easingId;\n\n        manager.updateInstance(\n          manager.layer,\n          instance,\n          EMPTY,\n          newBufferLocations\n        );\n      }\n    }\n  }\n\n  /**\n   * This processes change operations from changes in the instancing data\n   */\n  changeInstance(\n    manager: this,\n    instance: T,\n    propIds: number[],\n    bufferLocations?: IInstanceAttributeBufferLocationGroup\n  ) {\n    // If there is an existing uniform cluster for this instance, then we can update the bufferLocations\n    if (bufferLocations) {\n      manager.updateInstance(manager.layer, instance, propIds, bufferLocations);\n    } else {\n      // If we don't have existing bufferLocations, then we must add the instance\n      manager.addInstance(manager, instance, EMPTY, bufferLocations);\n    }\n  }\n\n  /**\n   * This processes remove operations from changes in the instancing data\n   */\n  removeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    bufferLocations?: IInstanceAttributeBufferLocationGroup\n  ) {\n    if (bufferLocations) {\n      // We deactivate the instance so it does not render anymore\n      instance.active = false;\n      // Remove the easing information the instance gained from being apart of the layer\n      instance.clearEasing();\n      // We do one last update on the instance to update to it's deactivated state\n      manager.updateInstance(manager.layer, instance, EMPTY, bufferLocations);\n      // Unlink the instance from the uniform cluster\n      manager.layer.bufferManager.remove(instance);\n    }\n  }\n\n  /**\n   * This performs the actual updating of buffers the instance needs to update\n   */\n  updateInstancePartial(\n    layer: IInstanceDiffManagerTarget<T>,\n    instance: T,\n    propIds: number[],\n    bufferLocations: IBufferLocationGroup<IBufferLocation>\n  ) {\n    const propertyToLocation = bufferLocations.propertyToBufferLocation;\n    const bufferAttributeUpdateRange = this.bufferAttributeUpdateRange;\n    let location: IBufferLocation;\n    let updateValue: Vec;\n    let updateRange;\n    let childLocations: IBufferLocation[];\n    let attribute: IInstanceAttributeInternal<T>;\n    let attributeChangeUID;\n\n    if (instance.active) {\n      // If no prop ids provided, then we perform a complete instance property update\n      if (propIds.length === 0) {\n        propIds = this.bufferManager.getUpdateAllPropertyIdList();\n      }\n\n      for (let i = 0, end = propIds.length; i < end; ++i) {\n        // First update for the instance attribute itself\n        location = propertyToLocation[propIds[i]];\n        attribute = location.attribute;\n        attributeChangeUID = attribute.packUID || attribute.uid;\n        attribute.atlas && layer.resource.setTargetAtlas(attribute.atlas.key);\n        updateValue = attribute.update(instance);\n        location.buffer.value.set(updateValue, location.range[0]);\n        updateRange = bufferAttributeUpdateRange[attributeChangeUID] || [\n          null,\n          Number.MAX_SAFE_INTEGER,\n          Number.MIN_SAFE_INTEGER\n        ];\n        updateRange[0] = attribute;\n        updateRange[1] = min(location.range[0], updateRange[1]);\n        updateRange[2] = max(location.range[1], updateRange[2]);\n        bufferAttributeUpdateRange[attributeChangeUID] = updateRange;\n\n        // Now update any child attributes that would need updating based on the parent attribute changing\n        if (location.childLocations) {\n          childLocations = location.childLocations;\n\n          for (let k = 0, endk = childLocations.length; k < endk; ++k) {\n            location = childLocations[k];\n            attributeChangeUID =\n              location.attribute.packUID || location.attribute.uid;\n            updateValue = location.attribute.update(instance);\n            location.buffer.value.set(updateValue, location.range[0]);\n            updateRange = bufferAttributeUpdateRange[attributeChangeUID] || [\n              null,\n              Number.MAX_SAFE_INTEGER,\n              Number.MIN_SAFE_INTEGER\n            ];\n            updateRange[0] = location.attribute;\n            updateRange[1] = min(location.range[0], updateRange[1]);\n            updateRange[2] = max(location.range[1], updateRange[2]);\n            bufferAttributeUpdateRange[attributeChangeUID] = updateRange;\n          }\n        }\n      }\n    } else {\n      // When the instance is inactive all we update is the active attribute to false\n      location =\n        propertyToLocation[this.bufferManager.getActiveAttributePropertyId()];\n      attribute = location.attribute;\n      attributeChangeUID = attribute.packUID || attribute.uid;\n      updateValue = attribute.update(instance);\n      location.buffer.value.set(updateValue, location.range[0]);\n      updateRange = bufferAttributeUpdateRange[attributeChangeUID] || [\n        null,\n        Number.MAX_SAFE_INTEGER,\n        Number.MIN_SAFE_INTEGER\n      ];\n      updateRange[0] = attribute;\n      updateRange[1] = min(location.range[0], updateRange[1]);\n      updateRange[2] = max(location.range[1], updateRange[2]);\n      bufferAttributeUpdateRange[attributeChangeUID] = updateRange;\n    }\n  }\n\n  /**\n   * This performs an update on the buffers with the intent the entire buffer is going to update\n   * rather than a chunk of it.\n   */\n  updateInstanceFull(\n    layer: IInstanceDiffManagerTarget<T>,\n    instance: T,\n    propIds: number[],\n    bufferLocations: IBufferLocationGroup<IBufferLocation>\n  ) {\n    const propertyToLocation = bufferLocations.propertyToBufferLocation;\n    const bufferAttributeWillUpdate = this.bufferAttributeWillUpdate;\n    let location: IBufferLocation;\n    let updateValue: Vec;\n    let childLocations: IBufferLocation[];\n    let attribute: IInstanceAttributeInternal<T>;\n\n    if (instance.active) {\n      // If no prop ids provided, then we perform a complete instance property update\n      if (propIds.length === 0) {\n        propIds = this.bufferManager.getUpdateAllPropertyIdList();\n      }\n\n      for (let i = 0, end = propIds.length; i < end; ++i) {\n        // First update for the instance attribute itself\n        location = propertyToLocation[propIds[i]];\n        attribute = location.attribute;\n        attribute.atlas && layer.resource.setTargetAtlas(attribute.atlas.key);\n        updateValue = attribute.update(instance);\n        location.buffer.value.set(updateValue, location.range[0]);\n        bufferAttributeWillUpdate[\n          attribute.packUID || attribute.uid\n        ] = attribute;\n\n        // Now update any child attributes that would need updating based on the parent attribute changing\n        if (location.childLocations) {\n          childLocations = location.childLocations;\n\n          for (let k = 0, endk = childLocations.length; k < endk; ++k) {\n            location = childLocations[k];\n            attribute = location.attribute;\n            updateValue = attribute.update(instance);\n            location.buffer.value.set(updateValue, location.range[0]);\n            bufferAttributeWillUpdate[\n              attribute.packUID || attribute.uid\n            ] = attribute;\n          }\n        }\n      }\n    } else {\n      // When the instance is inactive all we update is the active attribute to false\n      location =\n        propertyToLocation[this.bufferManager.getActiveAttributePropertyId()];\n      attribute = location.attribute;\n      attribute.atlas && layer.resource.setTargetAtlas(attribute.atlas.key);\n      updateValue = attribute.update(instance);\n      location.buffer.value.set(updateValue, location.range[0]);\n      bufferAttributeWillUpdate[attribute.packUID || attribute.uid] = attribute;\n    }\n  }\n\n  /**\n   * Finalize all of the buffer changes and apply the correct update ranges\n   */\n  commit() {\n    // If we're in a partial mode: just update the portion of the buffer that needs updating.\n    if (this.diffMode === DiffMode.PARTIAL) {\n      // We now grab all of the attributes and set their update ranges\n      const updates = Object.values(this.bufferAttributeUpdateRange);\n\n      for (let i = 0, end = updates.length; i < end; ++i) {\n        const update = updates[i];\n        const attribute = update[0].bufferAttribute;\n        attribute.needsUpdate = true;\n        attribute.updateRange = {\n          count: update[2] - update[1],\n          offset: update[1]\n        };\n      }\n    } else {\n      // Otherwise just update the full buffer\n      // We now grab all of the attributes and set their update ranges\n      const updates = Object.values(this.bufferAttributeWillUpdate);\n\n      for (let i = 0, end = updates.length; i < end; ++i) {\n        const attribute = updates[i].bufferAttribute;\n        attribute.needsUpdate = true;\n        attribute.updateRange = {\n          count: -1,\n          offset: 0\n        };\n      }\n    }\n\n    // Clear the attribute update metrics\n    this.bufferAttributeUpdateRange = {};\n  }\n\n  /**\n   * This will optimize the update method used. If there are enough instances being updated, we will\n   * cause the entire attribute buffer to update. If there are not enough, then we will update with\n   * additional steps to only update the chunks of the buffer that are affected by the changelist.\n   */\n  incomingChangeList(changes: InstanceDiff<T>[]) {\n    if (changes.length === 0) {\n      this.diffMode = DiffMode.PARTIAL;\n    } else if (changes.length > this.bufferManager.getInstanceCount() * 0.7) {\n      this.diffMode = DiffMode.FULL;\n    } else {\n      this.diffMode = DiffMode.PARTIAL;\n    }\n\n    if (this.diffMode === DiffMode.PARTIAL) {\n      this.updateInstance = this.updateInstancePartial;\n    } else {\n      this.updateInstance = this.updateInstanceFull;\n    }\n  }\n}\n","export function getProgramInfo(gl: WebGLRenderingContext, program: any) {\n  const result = {\n      attributeCount: 0,\n      attributes: new Array(),\n      uniformCount: 0,\n      uniforms: new Array()\n    },\n    activeUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS),\n    activeAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\n  // Taken from the WebGl spec:\n  // Http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14\n  const enums: { [key: number]: string } = {\n    0x8b50: \"FLOAT_VEC2\",\n    0x8b51: \"FLOAT_VEC3\",\n    0x8b52: \"FLOAT_VEC4\",\n    0x8b53: \"INT_VEC2\",\n    0x8b54: \"INT_VEC3\",\n    0x8b55: \"INT_VEC4\",\n    0x8b56: \"BOOL\",\n    0x8b57: \"BOOL_VEC2\",\n    0x8b58: \"BOOL_VEC3\",\n    0x8b59: \"BOOL_VEC4\",\n    0x8b5a: \"FLOAT_MAT2\",\n    0x8b5b: \"FLOAT_MAT3\",\n    0x8b5c: \"FLOAT_MAT4\",\n    0x8b5e: \"SAMPLER_2D\",\n    0x8b60: \"SAMPLER_CUBE\",\n    0x1400: \"BYTE\",\n    0x1401: \"UNSIGNED_BYTE\",\n    0x1402: \"SHORT\",\n    0x1403: \"UNSIGNED_SHORT\",\n    0x1404: \"INT\",\n    0x1405: \"UNSIGNED_INT\",\n    0x1406: \"FLOAT\"\n  };\n\n  const blocks: { [key: number]: number } = {\n    0x8b50: 1,\n    0x8b51: 1,\n    0x8b52: 1,\n    0x8b53: 1,\n    0x8b54: 1,\n    0x8b55: 1,\n    0x8b56: 1,\n    0x8b57: 1,\n    0x8b58: 1,\n    0x8b59: 1,\n    0x8b5a: 1,\n    0x8b5b: 3,\n    0x8b5c: 4,\n    0x8b5e: 1,\n    0x8b60: 1,\n    0x1400: 1,\n    0x1401: 1,\n    0x1402: 1,\n    0x1403: 1,\n    0x1404: 1,\n    0x1405: 1,\n    0x1406: 1\n  };\n\n  // Loop through active uniforms\n  for (let i = 0; i < activeUniforms; ++i) {\n    const uniform: any = gl.getActiveUniform(program, i);\n    uniform.typeName = enums[uniform.type];\n    result.uniforms.push(uniform);\n    result.uniformCount += uniform.size;\n    uniform.size = uniform.size * blocks[uniform.type];\n  }\n\n  // Loop through active attributes\n  for (let i = 0; i < activeAttributes; i++) {\n    const attribute: any = gl.getActiveAttrib(program, i);\n    attribute.typeName = enums[attribute.type];\n    result.attributes.push(attribute);\n    result.attributeCount += attribute.size;\n  }\n\n  return result;\n}\n\nexport class WebGLStat {\n  static MAX_VERTEX_UNIFORMS = 0;\n  static MAX_FRAGMENT_UNIFORMS = 0;\n  static MAX_VERTEX_ATTRIBUTES = 0;\n  static WEBGL_SUPPORTED: boolean = false;\n  static MAX_TEXTURE_SIZE = 0;\n  static HARDWARE_INSTANCING = false;\n  static HARDWARE_INSTANCING_ANGLE = false;\n}\n\nfunction initStats() {\n  // Let's perform some immediate operations to do some gl querying for useful information\n  function getAContext() {\n    try {\n      const canvas = document.createElement(\"canvas\");\n      return (\n        (window as any).WebGLRenderingContext &&\n        (canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\"))\n      );\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Attempt to retrieve a context for webgl\n  const gl = getAContext();\n\n  // If the context exists, then we know gl is supported and we can fill in some metrics\n  if (gl) {\n    WebGLStat.WEBGL_SUPPORTED = true;\n    WebGLStat.MAX_VERTEX_UNIFORMS = gl.getParameter(\n      gl.MAX_VERTEX_UNIFORM_VECTORS\n    );\n    WebGLStat.MAX_FRAGMENT_UNIFORMS = gl.getParameter(\n      gl.MAX_FRAGMENT_UNIFORM_VECTORS\n    );\n    WebGLStat.MAX_VERTEX_ATTRIBUTES = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n    WebGLStat.MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    WebGLStat.HARDWARE_INSTANCING_ANGLE = Boolean(\n      gl.getExtension(\"ANGLE_instanced_arrays\")\n    );\n    WebGLStat.HARDWARE_INSTANCING = WebGLStat.HARDWARE_INSTANCING_ANGLE;\n  }\n}\n\ninitStats();\n","import * as Three from \"three\";\n\nexport enum ViewCameraType {\n  /**\n   * Indicates a camera that is forced by the system to follow:\n   * - Match width and height of the view port\n   * - +y axis points downward\n   * - gl origin is at the top left of the screen\n   */\n  CONTROLLED,\n  /**\n   * This allows a custom view camera to be applied to the scene.\n   */\n  CUSTOM\n}\n\n/**\n * This is a camera that controls the view projection matrix. This is a much more\n * complicated way to handle views that is better suited for handling 3D applications\n * and is very overkill for most 2D charting systems. If you are working purely with\n * 2D components, it's recommended to leave this as a CONTROLLED camera and utilize\n * the ChartCamera for most of your needs.\n */\nexport class ViewCamera {\n  type: ViewCameraType = ViewCameraType.CONTROLLED;\n  baseCamera: Three.Camera;\n}\n","export const templateVars = {\n  attributes: \"attributes\",\n  easingMethod: \"easingMethod\",\n  extend: \"extend\",\n  extendHeader: \"extendHeader\",\n  T: \"T\"\n};\n","import { Vec3 } from \"./vector\";\n\nlet chartCameraUID = 0;\n\nexport interface IChartCameraOptions {\n  /** The world space offset of elements in the chart */\n  offset?: [number] | [number, number] | Vec3;\n  /** The world space scaling present in the chart */\n  scale?: [number] | [number, number] | Vec3;\n}\n\n/**\n * Quick method for applying a source array to a target array. This\n * ensures the arrays both are valid and applies the values without just making\n * a copy of the source.\n */\nfunction applyArray(target?: number[], source?: number[]) {\n  target && source && target.splice(0, source.length, ...source);\n}\n\nexport class ChartCamera {\n  /** Internally set id */\n  private _id: number = chartCameraUID++;\n  /** Represents how much an element should be offset in world space */\n  private _offset: Vec3 = [0, 0, 0];\n  /** Represents how scaled each axis should be in world space */\n  private _scale: Vec3 = [1, 1, 1];\n  /** This indicates whether the view where the camera is in needs drawn */\n  private _needsViewDrawn: boolean = true;\n\n  constructor(options?: IChartCameraOptions) {\n    if (options) {\n      applyArray(this.offset, options.offset);\n      applyArray(this.scale, options.scale);\n    }\n  }\n\n  /** Keep id as readonly */\n  get id() {\n    return this._id;\n  }\n\n  setId(id: number) {\n    this._id = id;\n    this._needsViewDrawn = true;\n  }\n\n  get offset() {\n    return this._offset;\n  }\n\n  /**\n   * Sets the location of the camera by adjusting the offsets to match.\n   */\n  setOffset(offset: Vec3) {\n    this._offset = offset.slice(0) as Vec3;\n    this._needsViewDrawn = true;\n  }\n\n  get scale() {\n    return this._scale;\n  }\n\n  setScale(scale: Vec3) {\n    this._scale = scale;\n    this._needsViewDrawn = true;\n  }\n\n  get needsViewDrawn() {\n    return this._needsViewDrawn;\n  }\n\n  resolve() {\n    this._needsViewDrawn = false;\n  }\n\n  update() {\n    this._needsViewDrawn = true;\n  }\n}\n","import { Bounds } from \"../primitives\";\nimport { IProjection } from \"../types\";\nimport {\n  IDragMetrics,\n  IMouseInteraction,\n  IWheelMetrics,\n  MouseEventManager\n} from \"./mouse-event-manager\";\nimport { View } from \"./view\";\n\n/**\n * Classes can extend this and override the methods to respond to events.\n */\nexport abstract class EventManager {\n  private mouseManager: MouseEventManager;\n\n  abstract handleMouseDown(e: IMouseInteraction, button: number): void;\n  abstract handleMouseUp(e: IMouseInteraction, button: number): void;\n  abstract handleMouseOver(e: IMouseInteraction): void;\n  abstract handleMouseOut(e: IMouseInteraction): void;\n  abstract handleMouseMove(e: IMouseInteraction): void;\n  abstract handleClick(e: IMouseInteraction, button: number): void;\n  abstract handleDrag(e: IMouseInteraction, drag: IDragMetrics): void;\n  abstract handleWheel(e: IMouseInteraction, wheel: IWheelMetrics): void;\n\n  /**\n   * This retrieves the projections for the view specified by the provided viewId.\n   */\n  getProjection(viewId: string): IProjection | null {\n    return this.mouseManager.getView(viewId);\n  }\n\n  /**\n   * This retrieves the actual view for the view specified by the provided viewId.\n   */\n  getView(viewId: string): View | null {\n    return (this.mouseManager && this.mouseManager.getView(viewId)) || null;\n  }\n\n  /**\n   * This retrieves the screen bounds for the view specified by the provided viewId.\n   */\n  getViewScreenBounds(viewId: string): Bounds | null {\n    const view = this.mouseManager.getView(viewId);\n\n    if (view) {\n      return view.screenBounds;\n    }\n\n    return null;\n  }\n\n  /**\n   * This is used internally which provides the parent MouseEventManager via the param mouseManager for this\n   * EventManager.\n   */\n  setMouseManager(mouseManager: MouseEventManager) {\n    this.mouseManager = mouseManager;\n  }\n}\n","import { subtract2, Vec2 } from \"../util\";\nimport { DataBounds } from \"../util/data-bounds\";\nimport { eventElementPosition, normalizeWheel } from \"../util/mouse\";\nimport { QuadTree } from \"../util/quad-tree\";\nimport { EventManager } from \"./event-manager\";\nimport { Scene } from \"./scene\";\nimport { View } from \"./view\";\n\n// If a mouse up after a mouse down happens before this many milliseconds, a click gesture will happen\nconst VALID_CLICK_DELAY = 1e3;\n\n/**\n * Theorectically we can have a view be applied to multiple scenes. So to properly qualify a view\n * it must be paired with the scene it is rendering for.\n */\nexport type SceneView = {\n  /** This specifies the order the view is rendered in so we can pick the top most item when needed */\n  depth: number;\n  /** This is the scene the view is rendering for */\n  scene: Scene;\n  /** This is the view itself that our mouse will interact with */\n  view: View;\n  /** Gets the bounds of this view for this particular scene */\n  bounds?: DataBounds<SceneView>;\n};\n\n/**\n * This represents an interaction with the Layer Surface. It provides mouse metrics with how the mouse\n * interacts with the views below it.\n */\nexport interface IMouseInteraction {\n  /** When present indicates any relevant button codes used during a click event */\n  button?: number;\n  /** Metrics of the interaction in screen space */\n  screen: {\n    mouse: Vec2;\n  };\n  /** The View the mouse was 'down' on */\n  start?: {\n    mouse: Vec2;\n    view: View;\n  };\n  /** The View Immediately underneath the mouse */\n  target: {\n    mouse: Vec2;\n    view: View;\n  };\n  /** This is populated with ALL of the views underneath the mouse */\n  viewsUnderMouse: {\n    /** The mouse's location in the views coordinate space */\n    mouse: Vec2;\n    /** The view that is interacted with */\n    view: View;\n  }[];\n}\n\nexport interface IDragMetrics {\n  /** Drag metrics in screen space */\n  screen: {\n    /** The start position of the drag where the mouse down first occurred */\n    start: Vec2;\n    /** The previous position of the mouse last frame */\n    previous: Vec2;\n    /** The current position the mouse is located for this frame */\n    current: Vec2;\n    /** The change in position from last frame to this frame */\n    delta: Vec2;\n  };\n}\n\nexport interface IWheelMetrics {\n  wheel: [number, number];\n}\n\n/**\n * This is metrics measured between two touches\n */\nexport interface ITouchRelation {\n  /** The direction to the other touch */\n  direction: Vec2;\n  /** The current distance to the other touch */\n  distance: number;\n  /** The id of the other touch */\n  id: number;\n}\n\n/**\n * This is the information of a touch for a given frame.\n */\nexport interface ITouchFrame {\n  /** This is the location or delta location of the touch for this frame */\n  location: Vec2;\n  /** This is the direction from the start touch frame */\n  direction: Vec2;\n  /** This is the metrics or delta metrics of the touch relative to the other touches for the frame */\n  relations: Map<number, ITouchRelation>;\n}\n\nexport interface ITouchMetrics {\n  /** The starting metrics of the touch */\n  start: ITouchFrame;\n  /** The delta changes from previous event to the current event */\n  delta: ITouchFrame;\n  /** The current metrics of the touch event */\n  current: ITouchFrame;\n}\n\nfunction sortByDepth(a: DataBounds<SceneView>, b: DataBounds<SceneView>) {\n  return b.data.depth - a.data.depth;\n}\n\nfunction isDefined<T>(val: T | null | undefined): val is T {\n  return Boolean(val);\n}\n\n/**\n * This manages mouse events on the provided canvas and provides some higher level\n * interactions with the surface.\n */\nexport class MouseEventManager {\n  /** This is the canvas context we are rendering to */\n  context: HTMLCanvasElement;\n  /** This is list of Event Managers that receive the events and gestures which perform the nexessary actions */\n  controllers: EventManager[];\n  /** This is the quad tree for finding intersections with the mouse */\n  quadTree: QuadTree<DataBounds<SceneView>>;\n  /** This is the current list of views being managed */\n  views: SceneView[];\n\n  eventCleanup: [string, EventListenerOrEventListenerObject][] = [];\n\n  /**\n   * This flag is set when the system is waiting to render the elements to establish bounds.\n   * No Mouse interations will happen while this is set to true.\n   */\n  private _waitingForRender: boolean = true;\n\n  get waitingForRender() {\n    return this._waitingForRender;\n  }\n\n  set waitingForRender(val: boolean) {\n    this._waitingForRender = val;\n\n    // When we're no longer waiting for render to occur we update all of our views in the quad tree\n    if (!val) {\n      this.quadTree = new QuadTree(0, 0, 0, 0);\n      this.quadTree.addAll(this.views.map(v => v.bounds).filter(isDefined));\n    }\n  }\n\n  constructor(\n    canvas: HTMLCanvasElement,\n    views: SceneView[],\n    controllers: EventManager[],\n    handlesWheelEvents?: boolean\n  ) {\n    this.context = canvas;\n    this.setViews(views);\n    this.setControllers(controllers);\n    this.addContextListeners(handlesWheelEvents);\n  }\n\n  /**\n   * This sets up the DOM events to listen to the events that are broadcasted by the canvas.\n   * These events are set up in such a way as to continue some events when the user\n   * drags the mouse off of the browser or off the canvas without releasing.\n   */\n  addContextListeners(handlesWheelEvents?: boolean) {\n    const element = this.context;\n    let startView: SceneView | undefined;\n    let startPosition: Vec2 = [0, 0];\n\n    if (handlesWheelEvents) {\n      const wheelHandler = (event: MouseWheelEvent) => {\n        const mouse = eventElementPosition(event, element);\n        const interaction = this.makeInteraction(\n          mouse,\n          startPosition,\n          startView\n        );\n        const wheel = this.makeWheel(event);\n\n        this.controllers.forEach(controller => {\n          controller.handleWheel(interaction, wheel);\n        });\n\n        event.stopPropagation();\n        event.preventDefault();\n      };\n\n      if (\"onwheel\" in element) {\n        element.onwheel = wheelHandler;\n      }\n\n      if (\"addEventListener\" in element) {\n        element.addEventListener(\"DOMMouseScroll\", wheelHandler);\n        this.eventCleanup.push([\"DOMMouseScroll\", wheelHandler]);\n      }\n    }\n\n    element.onmouseleave = event => {\n      // No interactions while waiting for the render to update\n      if (this.waitingForRender) return;\n\n      const mouse = eventElementPosition(event, element);\n      const interaction = this.makeInteraction(mouse, startPosition, startView);\n\n      this.controllers.forEach(controller => {\n        controller.handleMouseOut(interaction);\n      });\n    };\n\n    element.onmousemove = event => {\n      // No interactions while waiting for the render to update\n      if (this.waitingForRender) return;\n\n      const mouse = eventElementPosition(event, element);\n      const interaction = this.makeInteraction(mouse, startPosition, startView);\n\n      this.controllers.forEach(controller => {\n        controller.handleMouseMove(interaction);\n      });\n    };\n\n    element.onmousedown = (event: MouseEvent) => {\n      // No interactions while waiting for the render to update\n      if (this.waitingForRender) return;\n\n      startPosition = eventElementPosition(event, element);\n      const downViews = this.getViewsUnderMouse(startPosition);\n      // While this is true, when mouse up happens, the click gesture will execute\n      let canClick = true;\n      const clickStartTime = Date.now();\n\n      // If no views under this view, then we just quick exit with no interactions\n      if (downViews.length <= 0) {\n        return;\n      }\n\n      startView = downViews[0].data;\n      if (!startView) return;\n\n      const interaction = this.makeInteraction(\n        startPosition,\n        startPosition,\n        startView\n      );\n      let currentPosition = startPosition;\n\n      this.controllers.forEach(controller => {\n        controller.handleMouseDown(interaction, event.button);\n      });\n\n      event.stopPropagation();\n\n      document.onmousemove = (event: MouseEvent) => {\n        const mouse = eventElementPosition(event, element);\n        const interaction = this.makeInteraction(\n          mouse,\n          startPosition,\n          startView\n        );\n        const delta: Vec2 = subtract2(mouse, currentPosition);\n\n        const drag = this.makeDrag(\n          mouse,\n          startPosition || { x: 0, y: 0 },\n          currentPosition,\n          delta\n        );\n        currentPosition = mouse;\n\n        this.controllers.forEach(controller => {\n          controller.handleDrag(interaction, drag);\n        });\n\n        // If we move after a mouse down, it's no longer a click\n        canClick = false;\n      };\n\n      document.onmouseup = (_event: MouseEvent) => {\n        document.onmousemove = null;\n        document.onmouseup = null;\n        document.onmouseover = null;\n      };\n\n      document.onmouseover = (event: MouseEvent) => {\n        const mouse = eventElementPosition(event, element);\n        const interaction = this.makeInteraction(\n          mouse,\n          startPosition,\n          startView\n        );\n\n        this.controllers.forEach(controller => {\n          controller.handleMouseOver(interaction);\n        });\n\n        event.stopPropagation();\n      };\n\n      element.onmouseup = (event: MouseEvent) => {\n        const mouse = eventElementPosition(event, element);\n        const interaction = this.makeInteraction(\n          mouse,\n          startPosition,\n          startView\n        );\n\n        this.controllers.forEach(controller => {\n          controller.handleMouseUp(interaction, event.button);\n        });\n\n        // If we release the mouse before the valid click delay\n        if (canClick && Date.now() - clickStartTime < VALID_CLICK_DELAY) {\n          this.controllers.forEach(controller => {\n            controller.handleClick(interaction, event.button);\n          });\n        }\n      };\n\n      // Text will not be selected when it is being dragged\n      const experiemental = element as any;\n      if (experiemental.onselectstart !== undefined) {\n        experiemental.onselectstart = function() {\n          return false;\n        };\n      } else {\n        element.addEventListener(\"selectstart\", function() {\n          event.preventDefault();\n        });\n      }\n    };\n\n    // Enable touch support\n    this.addTouchContextListeners();\n  }\n\n  addTouchContextListeners() {\n    const element = this.context;\n\n    element.ontouchstart = _event => {\n      // TODO: This is the start work for the touch events. And this retains sentimental value.\n      // For (let i = 0, end = event.changedTouches.length; i < end; ++i) {\n      // TODO\n      // Const touch = event.changedTouches.item(i);\n      // CurrentTouches.set(touch.identifier, to);\n      // }\n    };\n\n    element.ontouchend = _event => {\n      // TODO\n    };\n\n    element.ontouchmove = _event => {\n      // TODO\n    };\n\n    element.ontouchcancel = _event => {\n      // TODO\n    };\n  }\n\n  /**\n   * Retrieves the view for the provided id\n   */\n  getView(viewId: string): View | null {\n    for (const view of this.views) {\n      if (view.view.id === viewId) {\n        return view.view;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Retrieves the views underneath the mouse with the top most view as\n   * the first view in the list.\n   */\n  getViewsUnderMouse = (mouse: Vec2) => {\n    // Find the views the mouse has interacted with\n    const hitViews = this.quadTree.query(mouse);\n    // Sort them by depth\n    hitViews.sort(sortByDepth);\n\n    return hitViews;\n  };\n\n  /**\n   * This generates the metrics for a drag gesture.\n   */\n  makeDrag(\n    mouse: Vec2,\n    start: Vec2,\n    previous: Vec2,\n    delta: Vec2\n  ): IDragMetrics {\n    return {\n      screen: {\n        current: mouse,\n        delta,\n        previous,\n        start\n      }\n    };\n  }\n\n  /**\n   * This makes the metrics for interactions with the views.\n   */\n  makeInteraction(\n    mouse: Vec2,\n    start?: Vec2,\n    startView?: SceneView\n  ): IMouseInteraction {\n    // Find the views the mouse has interacted with\n    const hitViews = this.getViewsUnderMouse(mouse);\n\n    return {\n      screen: {\n        mouse\n      },\n      start: start &&\n        startView && {\n          mouse: startView.view.screenToView(mouse),\n          view: startView.view\n        },\n      target: {\n        mouse: hitViews[0] && hitViews[0].data.view.screenToView(mouse),\n        view: hitViews[0] && hitViews[0].data.view\n      },\n      viewsUnderMouse: hitViews.map(v => ({\n        mouse: v.data.view.screenToView(mouse),\n        view: v.data.view\n      }))\n    };\n  }\n\n  makeWheel(event: MouseWheelEvent): IWheelMetrics {\n    const wheel = normalizeWheel(event);\n\n    return {\n      wheel\n    };\n  }\n\n  /**\n   * When the renderer is resized, we must reform our quad tree\n   */\n  resize = () => {\n    this._waitingForRender = true;\n  };\n\n  /**\n   * Sets the controllers to receive events from this manager.\n   */\n  setControllers(controllers: EventManager[]) {\n    this.controllers = controllers;\n\n    for (const controller of this.controllers) {\n      controller.setMouseManager(this);\n    }\n  }\n\n  /**\n   * Sets the views that gets queried for interactions.\n   */\n  setViews(views: SceneView[]) {\n    this.views = views;\n  }\n\n  destroy() {\n    delete this.quadTree;\n    this.context.onmousedown = null;\n    this.context.onmousemove = null;\n    this.context.onmouseleave = null;\n\n    const experimental = this.context as any;\n\n    if (experimental.onmousewheel) {\n      experimental.onmousewheel = null;\n    }\n\n    this.eventCleanup.forEach(event => {\n      this.context.removeEventListener(event[0], event[1]);\n    });\n  }\n}\n","import * as Three from \"three\";\nimport { IInstancingUniform, IUniform, UniformSize } from \"../../types\";\nimport { Instance } from \"../../util\";\nimport { ILayerProps, Layer } from \"../layer\";\n\nconst UNIFORM_SIZE_TO_MATERIAL_TYPE: { [key: number]: string } = {\n  [UniformSize.ONE]: \"f\",\n  [UniformSize.TWO]: \"v2\",\n  [UniformSize.THREE]: \"v3\",\n  [UniformSize.FOUR]: \"v4\",\n  [UniformSize.MATRIX3]: \"Matrix3fv\",\n  [UniformSize.MATRIX4]: \"Matrix4fv\"\n};\n\nconst DEFAULT_UNIFORM_VALUE: { [key: number]: number[] } = {\n  [UniformSize.ONE]: [0],\n  [UniformSize.TWO]: [0, 0],\n  [UniformSize.THREE]: [0, 0, 0],\n  [UniformSize.FOUR]: [0, 0, 0, 0],\n  [UniformSize.MATRIX3]: [0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [UniformSize.MATRIX4]: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n};\n\nfunction toMaterialUniform(uniform: IUniform) {\n  return {\n    type: UNIFORM_SIZE_TO_MATERIAL_TYPE[uniform.size],\n    value: DEFAULT_UNIFORM_VALUE[uniform.size]\n  };\n}\n\nexport function generateLayerMaterial<\n  T extends Instance,\n  U extends ILayerProps<T>\n>(\n  layer: Layer<T, U>,\n  vs: string,\n  fs: string,\n  layerUniforms: IUniform[],\n  instancingUniforms: IInstancingUniform[]\n): Three.RawShaderMaterial {\n  // We now need to establish the material for the layer\n  const materialParams: Three.ShaderMaterialParameters = layer.getMaterialOptions();\n  materialParams.vertexShader = vs;\n  materialParams.fragmentShader = fs;\n\n  // We must convert all of the uniforms to actual Three material initialization uniforms\n  materialParams.uniforms = {};\n\n  // Convert our non-instancing uniforms to our material uniforms\n  for (let i = 0, end = layerUniforms.length; i < end; ++i) {\n    const uniform = layerUniforms[i];\n    const materialUniform = toMaterialUniform(uniform);\n    materialParams.uniforms[uniform.name] = materialUniform;\n  }\n\n  // Add in the generated instancing uniforms\n  for (let i = 0, end = instancingUniforms.length; i < end; ++i) {\n    const generatedUniform = instancingUniforms[i];\n    materialParams.uniforms[generatedUniform.name] = {\n      type: generatedUniform.type,\n      value: generatedUniform.value\n    };\n  }\n\n  return new Three.RawShaderMaterial(materialParams);\n}\n","import * as Three from \"three\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport {\n  IVertexAttribute,\n  IVertexAttributeInternal,\n  ShaderIOValue\n} from \"../../types\";\nimport { Layer } from \"../layer\";\nimport { LayerBufferType } from \"./layer-buffer-type\";\n\nfunction isNumberCluster(\n  val: ShaderIOValue\n): val is\n  | [number]\n  | [number, number]\n  | [number, number, number]\n  | [number, number, number, number] {\n  return !Array.isArray(val[0]);\n}\n\nexport function generateLayerGeometry<T extends Instance>(\n  layer: Layer<T, any>,\n  maxInstancesPerBuffer: number,\n  vertexAttributes: IVertexAttributeInternal[],\n  vertexCount: number\n): Three.BufferGeometry {\n  // Make the new buffers to be updated\n  const vertexBuffers = [];\n\n  // Certain buffer strategies only need one instance buffered in\n  if (\n    layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE ||\n    layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE_PACKING\n  ) {\n    maxInstancesPerBuffer = 1;\n  }\n\n  for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n    const attribute = vertexAttributes[i];\n    vertexBuffers.push(\n      new Float32Array(attribute.size * vertexCount * maxInstancesPerBuffer)\n    );\n  }\n\n  // Let's now fill in the baseline geometry with the instances we will be generating\n  // First we ask the layer for a single instance's buffer setup\n  const endk = vertexAttributes.length;\n  let buffer: Float32Array;\n  let attribute: IVertexAttribute;\n  let value: ShaderIOValue;\n  let formatError: boolean = false;\n\n  for (let i = 0, end = vertexCount; i < end; ++i) {\n    for (let k = 0; k < endk; ++k) {\n      attribute = vertexAttributes[k];\n      buffer = vertexBuffers[k];\n      value = attribute.update(i);\n\n      if (isNumberCluster(value)) {\n        for (\n          let j = i * attribute.size, endj = j + attribute.size, index = 0;\n          j < endj;\n          ++j, ++index\n        ) {\n          buffer[j] = value[index];\n        }\n      } else {\n        formatError = true;\n      }\n    }\n  }\n\n  if (formatError) {\n    console.warn(\n      \"A vertex buffer updating method should not use arrays of arrays of numbers.\"\n    );\n  }\n\n  // After getting the geometry for a single instance, we can now copy paste\n  // For subsequent instances using very fast FLoat32 methods\n  // NOTE: This is ONLY for certain buffering strategies. This is essentially a noop when the\n  // maxInstances is set to one.\n  for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n    const attribute = vertexAttributes[i];\n    const instanceSize = attribute.size * vertexCount;\n\n    // Copy the first buffer set into the rest of the buffer\n    for (let k = 1, endk = maxInstancesPerBuffer; k < endk; ++k) {\n      vertexBuffers[i].copyWithin(instanceSize * k, 0, instanceSize);\n    }\n  }\n\n  // Lastly, we make the instance attribute reflect correctly so each instance\n  // Can have varied information. This is only appropriate for the uniform buffer strategy\n  if (layer.bufferType === LayerBufferType.UNIFORM) {\n    const instancingBuffer = vertexBuffers[0];\n\n    for (let i = 0, end = maxInstancesPerBuffer; i < end; ++i) {\n      const instanceStartIndex = i * vertexCount;\n\n      for (let k = 0; k < vertexCount; ++k) {\n        instancingBuffer[k + instanceStartIndex] = i;\n      }\n    }\n  }\n\n  // Now we can generate the attributes and apply them to a geometry object\n  const geometry = new Three.BufferGeometry();\n\n  for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n    const attribute = vertexAttributes[i];\n    const materialAttribute = new Three.BufferAttribute(\n      vertexBuffers[i],\n      attribute.size\n    );\n    attribute.materialAttribute = materialAttribute;\n    geometry.addAttribute(attribute.name, materialAttribute);\n  }\n\n  return geometry;\n}\n","import * as Three from \"three\";\nimport { AbsolutePosition } from \"../../primitives/absolute-position\";\nimport { ChartCamera } from \"../../util/chart-camera\";\nimport { ViewCamera } from \"../../util/view-camera\";\nimport { Scene } from \"../scene\";\nimport { View } from \"../view\";\n\nexport interface IDefaultSceneElements {\n  /** Default chartting camera */\n  camera: ChartCamera;\n  /** Default scene for elements to be added into */\n  scene: Scene;\n  /** Default view scenes are rendered with when no other views are specified by the layer or the surface */\n  view: View;\n  /**\n   * The default view projection. Defaults to being an orthographic rendering with the origin at the\n   * top left of the canvas and the y-axis as +y going downward.\n   */\n  viewCamera: ViewCamera;\n  /** The default viewport that encompasses the entire canvas */\n  viewport: AbsolutePosition;\n}\n\n/**\n * This generates all of the cameras/views/scenes necessary for default viewing of elements.\n *\n * These defaults are required to ensure the following:\n *\n * - Orthographic view\n * - top left corner of the canvas is 0,0\n * - y axis is +y downward\n * - entire canvas is the viewport.\n */\nexport function generateDefaultScene(\n  context: WebGLRenderingContext\n): IDefaultSceneElements {\n  // Generate a default view camera that is\n  // - Orthographic\n  // - (0, 0) is the top left of the canvas\n  // - the y axis is +y going downward\n  const height = context.canvas.height;\n  const width = context.canvas.width;\n  const aspectRatio = width / height;\n\n  const viewport = {\n    aspectRatio: aspectRatio,\n    bottom: -height / 2,\n    far: 10000000,\n    left: -width / 2,\n    near: -100,\n    right: width / 2,\n    top: height / 2,\n    viewSize: height\n  };\n\n  const defaultCamera: ViewCamera = new ViewCamera();\n  defaultCamera.baseCamera = new Three.OrthographicCamera(\n    viewport.left,\n    viewport.right,\n    viewport.top,\n    viewport.bottom,\n    viewport.near,\n    viewport.far\n  );\n\n  defaultCamera.baseCamera.scale.set(1.0, -1.0, 1.0);\n  defaultCamera.baseCamera.position.set(0.0, 0.0, -300.0);\n  defaultCamera.baseCamera.updateMatrixWorld(true);\n  defaultCamera.baseCamera.updateMatrix();\n\n  if (defaultCamera.baseCamera instanceof Three.OrthographicCamera) {\n    defaultCamera.baseCamera.updateProjectionMatrix();\n  }\n\n  // Generate a charting camera with all scales set to 1 and no offsets in any direction\n  const defaultChartCamera: ChartCamera = new ChartCamera();\n\n  // This is a viewport that covers the entire context\n  const defaultViewport = {\n    bottom: 0,\n    left: 0,\n    right: 0,\n    top: 0\n  };\n\n  // Make a view using our defaults\n  const defaultView = new View({\n    camera: defaultChartCamera,\n    key: View.DEFAULT_VIEW_ID,\n    viewCamera: defaultCamera,\n    viewport: defaultViewport\n  });\n\n  // Make a scene with our defaults\n  const defaultScene = new Scene({\n    key: Scene.DEFAULT_SCENE_ID,\n    views: []\n  });\n\n  // Make sure the default view is a part of the default scene\n  defaultScene.addView(defaultView);\n\n  return {\n    camera: defaultChartCamera,\n    scene: defaultScene,\n    view: defaultView,\n    viewCamera: defaultCamera,\n    viewport: defaultViewport\n  };\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport { ILayerProps, Layer } from \"../../surface/layer\";\nimport {\n  IInstanceAttribute,\n  IUniform,\n  IVertexAttribute,\n  Omit,\n  ShaderInjectionTarget\n} from \"../../types\";\n\n/** This is the message used when a module unit is attempted to be modified after it has been locked down */\nconst LOCKED_MODULE_UNIT_MESSAGE =\n  \"Once a ShaderModuleUnit has been registered, you CAN NOT modify it! Module ID:\";\n\n/** Options for the constructor for a new ShaderModuleUnit */\nexport type ShaderModuleUnitOptions = Omit<Partial<ShaderModuleUnit>, \"lock\">;\n\n/**\n * This is a module unit that can be registered as a ShaderModule which the system will use to resolve\n * imports within a shader.\n */\nexport class ShaderModuleUnit {\n  private _isLocked: boolean;\n  private _content: string;\n  private _compatibility: ShaderInjectionTarget;\n  private _moduleId: string;\n  private _dependents: string[] | null = null;\n\n  /**\n   * This is the content that replaces shader imports\n   */\n  get content(): string {\n    return this._content;\n  }\n  set content(val: string) {\n    if (this._isLocked) {\n      console.warn(LOCKED_MODULE_UNIT_MESSAGE, this._moduleId);\n      return;\n    }\n\n    this._content = val;\n  }\n\n  /**\n   * This defines which shader type the content is compatible with. You can only have one content assigned\n   * per each ShaderInjectionTarget type. Thus you can have a module such as 'picking' with two unique implementations\n   * one for Fragment and one for Vertex shaders. Or you can assign it to both.\n   */\n  get compatibility(): ShaderInjectionTarget {\n    return this._compatibility;\n  }\n  set compatibility(val: ShaderInjectionTarget) {\n    if (this._isLocked) {\n      console.warn(LOCKED_MODULE_UNIT_MESSAGE, this._moduleId);\n      return;\n    }\n\n    this._compatibility = val;\n  }\n\n  /**\n   * This is the list of module id dependents this unit will need. We store\n   * this here so the module can be analyzed once. Import statements will be stripped and the sub module contents will\n   * be added to the top of the contents of the shader. This only stores ids, as the ids will still need to be analyzed\n   * so duplication can be prevented.\n   */\n  get dependents(): string[] | null {\n    return this._dependents;\n  }\n  set dependents(val: string[] | null) {\n    // If this has been locked AND the dependents have been established then dependents can not be\n    // adjusted.\n    if (this._isLocked && this._dependents !== null) {\n      console.warn(LOCKED_MODULE_UNIT_MESSAGE, this._moduleId);\n      return;\n    }\n\n    this._dependents = val;\n  }\n\n  /**\n   * Method for the unit to provide instance attributes for the module\n   */\n  instanceAttributes?<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>\n  ): IInstanceAttribute<T>[];\n\n  /**\n   * Indicates this unit cannot be modified anymore.\n   */\n  isLocked() {\n    return this._isLocked;\n  }\n\n  /**\n   * Allows a module to prevent overrides by another module using the same moduleId.\n   * Attempted overrides will throw warnings.\n   */\n  isFinal?: boolean;\n  /** This is the string ID a shader must use to include the provided content. */\n  get moduleId(): string {\n    return this._moduleId;\n  }\n  set moduleId(val: string) {\n    if (this._isLocked) {\n      console.warn(LOCKED_MODULE_UNIT_MESSAGE, this._moduleId);\n      return;\n    }\n\n    this._moduleId = val;\n  }\n\n  /**\n   * Method so the unit can provide uniforms for the module.\n   */\n  uniforms?<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>\n  ): IUniform[];\n\n  /**\n   * Method so the unit can provide vertex attributes for the module.\n   */\n  vertexAttributes?<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>\n  ): IVertexAttribute[];\n\n  /**\n   * Default ctor for creating a new Shader Module Unit to be registered with the system.\n   */\n  constructor(options: ShaderModuleUnitOptions) {\n    Object.assign(this, options);\n  }\n\n  /**\n   * Applies the content after it's been processed for import statements. You can not set the content this way\n   * again after processing has happened.\n   */\n  applyAnalyzedContent(content: string) {\n    if (this._isLocked && this.dependents !== null) {\n      console.warn(LOCKED_MODULE_UNIT_MESSAGE, this._moduleId);\n      return;\n    }\n\n    this._content = content;\n  }\n\n  /**\n   * Makes this unit unable to be modified in anyway\n   */\n  lock() {\n    this._isLocked = true;\n  }\n}\n","import { ShaderInjectionTarget } from \"../../types\";\nimport { shaderTemplate } from \"../../util\";\nimport {\n  ShaderModuleUnit,\n  ShaderModuleUnitOptions\n} from \"./shader-module-unit\";\n\nconst debug = require(\"debug\")(\"performance\");\nconst debugModuleVS = require(\"debug\")(\"shader-module-vs\");\nconst debugModuleFS = require(\"debug\")(\"shader-module-fs\");\n\n/**\n * This is the results expected from a compile() operation from the ShaderModule.\n */\nexport interface IShaderCompileResults {\n  /** Error messages generated from analyzing the shaders */\n  errors: string[];\n  /** The generated shader from analyzing the module */\n  shader: string | null;\n  /** The shader module units discovered during the processing of the module */\n  shaderModuleUnits: Set<ShaderModuleUnit>;\n}\n\n/**\n * The partial token that must be matched to indicate an import statement.\n * (Must be the first non-whitespace word found in the token)\n */\nconst IMPORT_TOKEN = \"import\";\n/**\n * This is a delimiter between the import token and the identifying import id value\n * provided. This must be the next non-whitespace character found after the import token.\n *\n * We allow whitespace between the token and it's delimiter to allow for style preference\n *\n * import: id\n * import:id\n * import : id\n *\n * etc.\n */\nconst IMPORT_DELIMITER = \":\";\n\n/**\n * Tests to see if a ShaderModuleUnit is compatible with a provided Shader Target\n */\nfunction isUnitCompatible(\n  unit: ShaderModuleUnit,\n  target: ShaderInjectionTarget\n) {\n  return (\n    Boolean(unit) &&\n    (unit.compatibility === target ||\n      unit.compatibility === ShaderInjectionTarget.ALL)\n  );\n}\n\n/**\n * This file defines modules for shaders. Shader modules are global to the window context.\n */\nexport class ShaderModule {\n  /** These are all of the currently registered modules for the Shader Modules */\n  static modules = new Map<\n    string,\n    { fs?: ShaderModuleUnit; vs?: ShaderModuleUnit }\n  >();\n\n  /**\n   * This registers a new ShaderModuleUnit. It makes the module available by it's importId within shaders\n   * using this framework.\n   *\n   * If the module is registered with no returned output, the registration was a success. Any returned output\n   * indicates issues encountered while registering the module.\n   */\n  static register(\n    unit: ShaderModuleUnit | ShaderModuleUnitOptions | ShaderModuleUnitOptions[]\n  ): string | null {\n    // If the input is just Shader Module Unit options injected, then we simply handle wrapping\n    // the options into a ShaderModuleUnit and do a registration.\n    if (!(unit instanceof ShaderModuleUnit)) {\n      if (Array.isArray(unit)) {\n        let out = \"\";\n\n        unit.forEach(options => {\n          const output = ShaderModule.register(options);\n          if (output) out += `${output}\\n`;\n        });\n\n        // If there was no output at any time, let's be sure to return a simple null\n        if (!out) {\n          return null;\n        }\n\n        return out;\n      }\n\n      return ShaderModule.register(new ShaderModuleUnit(unit));\n    }\n\n    let current = ShaderModule.modules.get(unit.moduleId);\n\n    if (!current) {\n      current = {};\n      ShaderModule.modules.set(unit.moduleId, current);\n    }\n\n    const fs = current.fs;\n    const vs = current.vs;\n    const isFSCompatible = isUnitCompatible(\n      unit,\n      ShaderInjectionTarget.FRAGMENT\n    );\n    const isVSCompatible = isUnitCompatible(unit, ShaderInjectionTarget.VERTEX);\n\n    if (fs && isFSCompatible) {\n      if (fs.isFinal) {\n        return `Module ID: ${\n          unit.moduleId\n        } Can not override the module's existing Fragment registration as the exisitng module is marked as final`;\n      }\n\n      debug(\n        \"A Shader Module Unit has overridden an existing module for the Fragment Shader Module ID: %o\",\n        unit.moduleId\n      );\n    }\n\n    if (vs && isVSCompatible) {\n      if (vs.isFinal) {\n        return `Module ID: ${\n          unit.moduleId\n        } Can not override the module's existing Vertex registration as the exisitng module is marked as final`;\n      }\n\n      debug(\n        \"A Shader Module Unit has overridden an existing module for the Vertex Shader Module ID: %o\",\n        unit.moduleId\n      );\n    }\n\n    // Register the module as it passed all scrutiny by this point\n    if (isFSCompatible) {\n      current.fs = unit;\n    }\n\n    if (isVSCompatible) {\n      current.vs = unit;\n    }\n\n    // Lock the unit down indicating it can no longer be modified ever again.\n    unit.lock();\n\n    return null;\n  }\n\n  /**\n   * This gathers all of the dependents for the module as ids. This also causes the contents of the module to\n   * be stripped of it's import statements.\n   */\n  static analyzeDependents(unit: ShaderModuleUnit) {\n    // If the dependents are already established for this unit and it can not be modified further,\n    // then we do not bother to analyze the dependents again.\n    if (unit.dependents && unit.isLocked) {\n      return [];\n    }\n\n    // Gathers error messages found while processing the module\n    const errors: string[] = [];\n    // Stores the dependents in the order they are found in the module\n    const dependents: string[] = [];\n    // Stores all of the unique dependents found for this module\n    const dependentSet = new Set<string>();\n    // Get then compatibility target of the module unit so we can properly see what modules are available\n    // to the unit and what is not.\n    const target = unit.compatibility;\n    // This is the identifier of the module requesting it's dependents\n    const id = unit.moduleId;\n\n    // Here we process the module contents and look for additional import statements.\n    const templateResults = shaderTemplate({\n      // We do not want any direct replacement options, we will handle token analyzing\n      // via our onToken callback so we can find our special \"import:\" case\n      options: {},\n      // Provide the shader to our template processor\n      shader: unit.content,\n\n      // We do not want to remove any template macros that do not deal with extension\n      onToken: token => {\n        const trimmedToken = token.trim();\n\n        // See if the token is the first thing to appear\n        if (trimmedToken.indexOf(IMPORT_TOKEN) === 0) {\n          // Analyze the remainder of the token to find the necessary colon to be the NEXT\n          // Non-whitespace character\n          const afterToken = trimmedToken.substr(IMPORT_TOKEN.length).trim();\n\n          // Make sure the character IS a colon\n          if (afterToken[0] === IMPORT_DELIMITER) {\n            // Indicates if content was properly found for the requested ID\n            let moduleContentFound = false;\n            // At this point, ANYTHING after the colon is the module id being requested (with white space trimmed)\n            // We allow comma delimited module ids to be specified\n            const moduleIds = afterToken\n              .substr(IMPORT_DELIMITER.length)\n              .trim()\n              .split(\",\");\n\n            // Wealso  allow trailing comma\n            if (moduleIds[moduleIds.length - 1].trim().length === 0) {\n              moduleIds.pop();\n            }\n\n            // Loop through all discovered module ids after the import statement\n            moduleIds.forEach(moduleId => {\n              // Make sure whitespace is cleared\n              moduleId = moduleId.trim();\n              // Get the requested module\n              const mod = ShaderModule.modules.get(moduleId);\n\n              // If we found the module, great! We can store the identifier as a module associated with this shader\n              // string thus reducing processing time needed for next processing.\n              if (mod) {\n                if (\n                  target === ShaderInjectionTarget.FRAGMENT ||\n                  target === ShaderInjectionTarget.ALL\n                ) {\n                  if (mod.fs) {\n                    moduleContentFound = true;\n\n                    if (!dependentSet.has(moduleId)) {\n                      dependents.push(moduleId);\n                    }\n                  } else {\n                    errors.push(\n                      `Could not find requested target fragment module for Module ID: ${moduleId} requested by module: ${id}`\n                    );\n                  }\n                }\n\n                if (\n                  target === ShaderInjectionTarget.VERTEX ||\n                  target === ShaderInjectionTarget.ALL\n                ) {\n                  if (mod.vs) {\n                    moduleContentFound = true;\n\n                    if (!dependentSet.has(moduleId)) {\n                      dependents.push(moduleId);\n                    }\n                  } else {\n                    errors.push(\n                      `Could not find requested target vertex module for Module ID: ${moduleId} requested by module: ${id}`\n                    );\n                  }\n                }\n\n                if (!mod.vs && !mod.fs) {\n                  errors.push(\n                    \"Could not find a vertex or fragment shader within exisitng module\"\n                  );\n                }\n\n                if (!moduleContentFound) {\n                  errors.push(\n                    `Error Processing module Module ID: ${moduleId} requested by module: ${id}`\n                  );\n                }\n              } else {\n                errors.push(\n                  `Could not find requested module: ${moduleId} requested by module: ${id}`\n                );\n              }\n            });\n\n            // Clear the import token from the body of the shader\n            return \"\";\n          }\n        }\n\n        // Leave any token not processed alone\n        return `$\\{${token}}`;\n      }\n    });\n\n    // Update the content to be stripped of it's import statements\n    unit.applyAnalyzedContent(templateResults.shader);\n    // Update the dependents to include the modules found that this module requested\n    unit.dependents = dependents;\n\n    return errors;\n  }\n\n  /**\n   * This examines a shader string and replaces all import statements with any existing registered modules.\n   * This will also output any issues such as requested modules that don't exist and detect circular dependencies\n   * and such ilk.\n   *\n   * @param shader The content of the shader to analyze for import statements\n   * @param target The shader target type to consider\n   * @param additionalModules Additional modules to include in the shader regardless if the shader requested it or not\n   */\n  static process(\n    id: string,\n    shader: string,\n    target: ShaderInjectionTarget,\n    additionalModules?: string[]\n  ): IShaderCompileResults {\n    // The discovered shader module units during processing\n    const shaderModuleUnits = new Set<ShaderModuleUnit>();\n    // This stores the module id's that have already been included in the shader\n    const included = new Set<string>();\n    // This stores the import stack that is currently being processed\n    const processing: (string | null)[] = [];\n    // This is all of the processed errors discovered while resolving imports\n    const errors: string[] = [];\n    // Pick a debugging target based on shader target\n    const debugTarget =\n      target === ShaderInjectionTarget.VERTEX ? debugModuleVS : debugModuleFS;\n    debugTarget(\"Processing Shader for id %o:\", id);\n\n    // Internal checking method of the state of the process to find circular dependencies\n    function checkCircularDependency(unit: ShaderModuleUnit) {\n      // Get the id of the module being processed for quick reference\n      const id = unit.moduleId;\n      // Debugging for the import id's found along with the current stack\n      debugTarget(\n        \"%o: %o\",\n        id,\n        processing\n          .slice(0)\n          .reverse()\n          .join(\" -> \")\n      );\n\n      // First look to see if the identifier is already in the processing queue. If it is, we\n      // have a heinous circular dependency.\n      const queueIndex = processing.indexOf(id);\n      // Queue up this id as being processed\n      processing.unshift(id);\n\n      // See if the circular dependency is found.\n      if (queueIndex > -1) {\n        // Since we have a queue of our processing path, we can show the circular dependency path\n        const circularPath = processing.slice(0, queueIndex + 2).reverse();\n        // Spew the blood\n        errors.push(\n          `A Shader has detected a Circular dependency in import requests: ${circularPath.join(\n            \" -> \"\n          )}`\n        );\n        // Remove the id from the queue\n        processing.shift();\n\n        // Return a null flag indicating the process failed.\n        return false;\n      }\n\n      return true;\n    }\n\n    // We place this method as an internal recursive strategy to solving this issue due to the complexities of\n    // the problem at hand. We have shaders that have tokens analyzed that MUST be immediately resolved\n    // to a correct value. Thus we can not use a process queue to remove the need for the recursion. Also, as\n    // this is a static method, this provides some needed properties within the context of the function that we\n    // do not want exposed at all, which is impossible to hide within a static context (private static is not supported).\n    function process(unit: ShaderModuleUnit): string | null {\n      // This is the id of the module unit  currently being processed\n      const id = unit.moduleId;\n\n      // Do the circular dependency check for the module\n      if (!checkCircularDependency(unit)) {\n        return null;\n      }\n\n      // At this point we need to determine if the id has already been included in the module imports\n      // Each import should only be included once so we prevent duplicate items from showing up\n      if (id && included.has(id)) {\n        // Remove the id from the queue\n        processing.shift();\n\n        // Return empty, but not errored\n        return \"\";\n      }\n\n      // This will store all of the module content that should be injected as the header\n      let includedModuleContent = \"\";\n      // Make sure the dependents for the module are properly analyzed\n      const dependentsErrors = ShaderModule.analyzeDependents(unit);\n      // Add in any errors discovered during module analysis\n      dependentsErrors.forEach(error => errors.push(error));\n      // Get the dependents for the module for processing\n      const dependents = unit.dependents;\n\n      if (dependents && dependents.length > 0) {\n        for (let i = 0, iMax = dependents.length; i < iMax; ++i) {\n          // The dependent is the id of the module id dependency\n          const moduleId = dependents[i];\n          // Get the requested module\n          const mod = ShaderModule.modules.get(moduleId);\n\n          // If we found the module, great! We can see if the found module has a compatible target for this module.\n          if (mod) {\n            let moduleContent;\n\n            if (\n              target === ShaderInjectionTarget.FRAGMENT ||\n              target === ShaderInjectionTarget.ALL\n            ) {\n              if (mod.fs) {\n                shaderModuleUnits.add(mod.fs);\n                moduleContent = process(mod.fs);\n              } else {\n                errors.push(\n                  `Could not find requested target fragment module for Module ID: ${moduleId} requested by module: ${id}`\n                );\n              }\n            }\n\n            if (\n              target === ShaderInjectionTarget.VERTEX ||\n              target === ShaderInjectionTarget.ALL\n            ) {\n              if (mod.vs) {\n                shaderModuleUnits.add(mod.vs);\n                moduleContent = process(mod.vs);\n              } else {\n                errors.push(\n                  `Could not find requested target vertex module for Module ID: ${moduleId} requested by module: ${id}`\n                );\n              }\n            }\n\n            if (!mod.vs && !mod.fs) {\n              errors.push(\n                \"Could not find a vertex or fragment shader within exisitng module\"\n              );\n            }\n\n            if (moduleContent === null) {\n              errors.push(\n                `Error Processing module Module ID: ${moduleId} requested by module: ${id}`\n              );\n            }\n\n            // Include the discovered content in the module content output\n            includedModuleContent += moduleContent || \"\";\n          } else {\n            errors.push(\n              `Could not find requested module: ${moduleId} requested by module: ${id}`\n            );\n          }\n        }\n      }\n\n      // Remove the id being processed currently\n      processing.shift();\n      // Add the id to the list of items that have been included\n      included.add(id || \"\");\n\n      // Place the included module content at the top of the shader and return this module with it's necessary\n      // inclusions\n      return `${includedModuleContent.trim()}\\n\\n${unit.content.trim()}`;\n    }\n\n    // We throw in the additional imports  at the top of the shader being analyzed\n    let modifedShader = shader;\n\n    if (additionalModules) {\n      let imports = \"\";\n\n      additionalModules.forEach(\n        moduleId => (imports += `$\\{import: ${moduleId}}\\n`)\n      );\n\n      modifedShader = imports + shader;\n    }\n\n    // Make our shader a temp module unit to make it compatible with the rest of the shader module processing\n    const tempShaderModuleUnit = new ShaderModuleUnit({\n      content: modifedShader,\n      compatibility: target,\n      moduleId: `Layer \"${id}\" ${\n        target === ShaderInjectionTarget.ALL\n          ? \"fs vs\"\n          : target === ShaderInjectionTarget.VERTEX\n            ? \"vs\"\n            : \"fs\"\n      }`\n    });\n\n    // Generate the results needed\n    const results = {\n      errors,\n      shader: process(tempShaderModuleUnit),\n      shaderModuleUnits\n    };\n\n    return results;\n  }\n}\n","/**\n * This file is dedicted to the all important step of processing desired inputs from the layer\n * and coming up with automated generated uniforms and attributes that the shader's will need\n * in order to operate with the conveniences the library offers. This includes things such as\n * injecting camera projection uniforms, resource uniforms, animation adjustments etc etc.\n */\nimport { Instance } from \"../../instance-provider/instance\";\nimport { ProcessShaderImportResults } from \"../../shaders/processing/shader-processor\";\nimport {\n  IInstanceAttribute,\n  InstanceAttributeSize,\n  IShaderInitialization,\n  IUniform,\n  IUniformInternal,\n  IVertexAttribute,\n  IVertexAttributeInternal\n} from \"../../types\";\nimport { Vec } from \"../../util\";\nimport { ILayerProps, Layer } from \"../layer\";\nimport { generateAtlasResourceUniforms } from \"./expand-atlas-attributes\";\nimport { generateEasingAttributes } from \"./expand-easing-attributes\";\nimport { getLayerBufferType } from \"./layer-buffer-type\";\nimport { packAttributes } from \"./pack-attributes\";\n\n/**\n * This is a lookup for a test vector for the provided size\n */\nconst testStartVector: { [key: number]: Vec } = {\n  [InstanceAttributeSize.ONE]: [1],\n  [InstanceAttributeSize.TWO]: [1, 2],\n  [InstanceAttributeSize.THREE]: [1, 2, 3],\n  [InstanceAttributeSize.FOUR]: [1, 2, 3, 4]\n};\n\n/**\n * This is a lookup for a test vector for the provided size\n */\nconst testEndVector: { [key: number]: Vec } = {\n  [InstanceAttributeSize.ONE]: [4],\n  [InstanceAttributeSize.TWO]: [4, 3],\n  [InstanceAttributeSize.THREE]: [4, 3, 2],\n  [InstanceAttributeSize.FOUR]: [4, 3, 2, 1]\n};\n\nfunction isInstanceAttribute<T extends Instance>(\n  attr: any\n): attr is IInstanceAttribute<T> {\n  return Boolean(attr);\n}\n\nfunction isVertexAttribute(attr: any): attr is IVertexAttribute {\n  return Boolean(attr);\n}\n\nfunction isUniform(attr: any): attr is IUniform {\n  return Boolean(attr);\n}\n\nfunction toVertexAttributeInternal(\n  attribute: IVertexAttribute\n): IVertexAttributeInternal {\n  return Object.assign({}, attribute, { materialAttribute: null });\n}\n\nfunction toUniformInternal(uniform: IUniform): IUniformInternal {\n  return Object.assign({}, uniform, { materialUniforms: [] });\n}\n\n/**\n * This sorts the attributes such that the attributes that MUST be updated first are put to the top.\n * This is necessary for complex attributes like atlas and easing attributes who have other attributes\n * that have dependent behaviors based on their source attribute.\n */\nfunction sortNeedsUpdateFirstToTop<T extends Instance>(\n  a: IInstanceAttribute<T>,\n  b: IInstanceAttribute<T>\n) {\n  if (a.atlas && !b.atlas) return -1;\n  if (a.easing && !b.easing) return -1;\n  return 1;\n}\n\nfunction compareVec(a: Vec, b: Vec) {\n  if (a.length !== b.length) return false;\n\n  for (let i = 0, end = a.length; i < end; ++i) {\n    if (Math.round(a[i] * 100) / 100 !== Math.round(b[i] * 100) / 100) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction validateInstanceAttributes<T extends Instance>(\n  layer: Layer<T, any>,\n  instanceAttributes: IInstanceAttribute<T>[],\n  vertexAttributes: IVertexAttribute[]\n) {\n  instanceAttributes.forEach(attribute => {\n    if (attribute.name === undefined) {\n      console.warn(\n        \"All instance attributes MUST have a name on Layer:\",\n        layer.id\n      );\n    }\n\n    if (\n      instanceAttributes.find(\n        attr => attr !== attribute && attr.name === attribute.name\n      )\n    ) {\n      console.warn(\n        \"An instance attribute can not have the same name used more than once:\",\n        attribute.name\n      );\n    }\n\n    if (vertexAttributes.find(attr => attr.name === attribute.name)) {\n      console.warn(\n        \"An instance attribute and a vertex attribute in a layer can not share the same name:\",\n        attribute.name\n      );\n    }\n\n    if (attribute.easing && attribute.atlas) {\n      console.warn(\n        \"An instance attribute can not have both easing and atlas properties. Undefined behavior will occur.\"\n      );\n      console.warn(attribute);\n    }\n\n    if (!attribute.atlas) {\n      if (attribute.size === undefined) {\n        console.warn(\"An instance attribute requires the size to be defined.\");\n        console.warn(attribute);\n      }\n    }\n\n    if (attribute.easing) {\n      if (attribute.size !== undefined) {\n        const testStart = testStartVector[attribute.size];\n        const testEnd = testEndVector[attribute.size];\n        const validationRules = attribute.easing.validation || {};\n\n        let test = attribute.easing.cpu(testStart, testEnd, 0);\n        if (!compareVec(test, testStart)) {\n          console.warn(\n            \"Auto Easing Validation Failed: using a time of 0 does not produce the start value\"\n          );\n          console.warn(\"Start:\", testStart, \"End:\", testEnd, \"Result:\", test);\n          console.warn(attribute);\n        }\n\n        test = attribute.easing.cpu(testStart, testEnd, 1);\n        if (\n          !validationRules.ignoreEndValueCheck &&\n          !compareVec(test, testEnd)\n        ) {\n          console.warn(\n            \"Auto Easing Validation Failed: using a time of 1 does not produce the end value\"\n          );\n          console.warn(\"Start:\", testStart, \"End:\", testEnd, \"Result:\", test);\n          console.warn(attribute);\n        }\n\n        test = attribute.easing.cpu(testStart, testEnd, -1);\n        if (!compareVec(test, testStart)) {\n          console.warn(\n            \"Auto Easing Validation Failed: using a time of -1 does not produce the start value\"\n          );\n          console.warn(\"Start:\", testStart, \"End:\", testEnd, \"Result:\", test);\n          console.warn(attribute);\n        }\n\n        test = attribute.easing.cpu(testStart, testEnd, 2);\n        if (\n          !validationRules.ignoreOverTimeCheck &&\n          !compareVec(test, testEnd)\n        ) {\n          console.warn(\n            \"Auto Easing Validation Failed: using a time of 2 does not produce the end value\"\n          );\n          console.warn(\"Start:\", testStart, \"End:\", testEnd, \"Result:\", test);\n          console.warn(attribute);\n        }\n      } else {\n        console.warn(\n          \"An Instance Attribute with easing MUST have a size declared\"\n        );\n      }\n    }\n  });\n}\n\n/**\n * This processes the results of shaders importing modules by gathering the attributes\n * and uniforms that arose from\n */\nfunction gatherIOFromShaderModules<\n  T extends Instance,\n  U extends ILayerProps<T>\n>(\n  layer: Layer<T, U>,\n  shaderIO: IShaderInitialization<T>,\n  importResults: ProcessShaderImportResults\n) {\n  if (!importResults) return;\n\n  // Get the existing items from the IO\n  let moduleInstanceAttributes = shaderIO.instanceAttributes || [];\n  let moduleUniforms = shaderIO.uniforms || [];\n  let moduleVertexAttributes = shaderIO.vertexAttributes || [];\n\n  // Add in the module requested items\n  importResults.shaderModuleUnits.forEach(unit => {\n    if (unit.instanceAttributes) {\n      moduleInstanceAttributes = moduleInstanceAttributes.concat(\n        unit.instanceAttributes(layer)\n      );\n    }\n\n    if (unit.uniforms) {\n      moduleUniforms = moduleUniforms.concat(unit.uniforms(layer));\n    }\n\n    if (unit.vertexAttributes) {\n      moduleVertexAttributes = moduleVertexAttributes.concat(\n        unit.vertexAttributes(layer)\n      );\n    }\n  });\n\n  // Dedup any element by name and show warnings when any item is overridden\n  const uniformNames = new Set<string>();\n  const instanceAttributeNames = new Set<string>();\n  const vertexAttributeNames = new Set<string>();\n\n  moduleUniforms.filter(uniform => {\n    if (uniform) {\n      if (uniformNames.has(uniform.name)) {\n        console.warn(\n          \"Included shader modules has introduced duplicate uniform names:\",\n          uniform.name,\n          \"One will be overridden thus causing a potential crash of the shader.\"\n        );\n        return false;\n      }\n\n      uniformNames.add(uniform.name);\n\n      return true;\n    }\n\n    return false;\n  });\n\n  moduleInstanceAttributes.filter(attribute => {\n    if (attribute) {\n      if (instanceAttributeNames.has(attribute.name)) {\n        console.warn(\n          \"Included shader modules has introduced duplicate Instance Attribute names:\",\n          attribute.name,\n          \"One will be overridden thus causing a potential crash of the shader.\"\n        );\n        return false;\n      }\n\n      instanceAttributeNames.add(attribute.name);\n\n      return true;\n    }\n\n    return false;\n  });\n\n  moduleVertexAttributes.filter(attribute => {\n    if (attribute) {\n      if (vertexAttributeNames.has(attribute.name)) {\n        console.warn(\n          \"Included shader modules has introduced duplicate Vertex Attribute names:\",\n          attribute.name,\n          \"One will be overridden thus causing a potential crash of the shader.\"\n        );\n        return false;\n      }\n\n      vertexAttributeNames.add(attribute.name);\n\n      return true;\n    }\n\n    return false;\n  });\n\n  // Apply any changes to the IO object\n  shaderIO.instanceAttributes = moduleInstanceAttributes;\n  shaderIO.uniforms = moduleUniforms;\n  shaderIO.vertexAttributes = moduleVertexAttributes;\n}\n\n/**\n * This is the primary method that analyzes all shader IO and determines which elements needs to be automatically injected\n * into the shader.\n */\nexport function injectShaderIO<T extends Instance, U extends ILayerProps<T>>(\n  gl: WebGLRenderingContext,\n  layer: Layer<T, U>,\n  shaderIO: IShaderInitialization<T>,\n  importResults: ProcessShaderImportResults\n) {\n  // After processing imports, we can now include any uniforms, or attributes the shader modules requested to be included in the\n  // layer so that the modules can operate properly. This mostly includes items such as times, projection matrices etc\n  // that the system should be providing rather than the layer\n  gatherIOFromShaderModules(layer, shaderIO, importResults);\n\n  // All of the instance attributes with nulls filtered out\n  const instanceAttributes = (shaderIO.instanceAttributes || []).filter(\n    isInstanceAttribute\n  );\n  // All of the vertex attributes with nulls filtered out\n  const vertexAttributes = (shaderIO.vertexAttributes || []).filter(\n    isVertexAttribute\n  );\n  // All of the uniforms with nulls filtered out\n  const uniforms = (shaderIO.uniforms || []).filter(isUniform);\n  // Do a validation pass of the attributes injected so we can provide feedback as to why things behave odd\n  validateInstanceAttributes(layer, instanceAttributes, vertexAttributes);\n  // Generates all of the attributes needed to make attributes automagically be eased when changed\n  generateEasingAttributes(layer, instanceAttributes);\n  // Get the uniforms needed to facilitate atlas resource requests if any exists\n  const addedUniforms: IUniform[] = uniforms.concat(\n    generateAtlasResourceUniforms(layer, instanceAttributes)\n  );\n  // Create the base instance attributes that must be present\n  const addedInstanceAttributes = instanceAttributes.slice(0);\n  // Convert our uniforms to the internal structure they need to be\n  const allUniforms = addedUniforms.map(toUniformInternal);\n\n  const allInstanceAttributes = addedInstanceAttributes.sort(\n    sortNeedsUpdateFirstToTop\n  );\n\n  // Let's pack in our attributes automagically so we can determine block and block indices.\n  packAttributes(allInstanceAttributes);\n  // Before we make the vertex attributes, we must determine the buffering strategy our layer will utilize\n  getLayerBufferType(gl, layer, vertexAttributes, allInstanceAttributes);\n\n  // Create the base vertex attributes that must be present\n  const addedVertexAttributes: IVertexAttribute[] = [];\n\n  // Aggregate all of the injected shaderIO with the layer's shaderIO\n  const allVertexAttributes: IVertexAttributeInternal[] = addedVertexAttributes\n    .concat(vertexAttributes || [])\n    .map(toVertexAttributeInternal);\n\n  return {\n    instanceAttributes: allInstanceAttributes,\n    uniforms: allUniforms,\n    vertexAttributes: allVertexAttributes\n  };\n}\n","export * from \"./label-layer\";\nexport * from \"./label-instance\";\n","import { Label } from \"../../primitives/label\";\nimport { LabelAtlasResource } from \"./label-atlas-resource\";\n\nlet canvas: CanvasRenderingContext2D;\nconst MAX_FONT_SIZE = 50;\nconst { floor, max, min } = Math;\n\nexport interface ILabelRasterizedMetrics {\n  canvas: HTMLCanvasElement;\n  height: number;\n  width: number;\n}\n\nexport class LabelRasterizer {\n  /**\n   * This loops until our canvas context is available\n   */\n  static async awaitContext() {\n    // Iterate till the browser provides a valid canvas to render elements into\n    while (!canvas) {\n      this.getContext();\n      await new Promise(resolve => setTimeout(resolve, 10));\n    }\n  }\n\n  /**\n   * This renders our label to a sizeable canvas where we loop over the pixel data to determine\n   * the bounds of the label.\n   *\n   * @param {boolean} calculateWorld This is used within the method. It switches from calculating\n   *                                 the size to be rendered to the texture to the size the label\n   *                                 should be within world space.\n   * @param {number} sampleScale     INTERNAL: Do not use this parameter manually.\n   */\n  static calculateLabelSize(\n    resource: LabelAtlasResource,\n    sampleScale?: number,\n    calculateTexture?: boolean\n  ) {\n    // If a max width is specified, then we must render and determine the potentially truncated text of the\n    // Label. We can do a binary search for the correct truncated label size.\n    if (calculateTexture) {\n      this.calculateTrucatedText(resource);\n    }\n\n    /** Get the label properties for rasterizing */\n    const label = resource.label;\n    // Get the scaling of the sample base\n    const sampleScaling = sampleScale || resource.sampleScale || 1.0;\n    // Draw our label to a canvas\n    this.drawLabel(label, resource.truncatedText, canvas, sampleScaling);\n    // Measure the contents of the canvas\n    const { minX, minY, maxX, maxY } = this.measureContents(canvas);\n\n    // Make sure the rasterization object is initialized\n    resource.rasterization = resource.rasterization || {\n      texture: { height: 0, width: 0 },\n      world: { height: 0, width: 0 }\n    };\n\n    // When a forced sampling is present, it calculates that as the world space\n    if (!calculateTexture) {\n      // Update the calculated texture size.\n      resource.rasterization.world = {\n        height: maxY - minY,\n        width: maxX - minX\n      };\n    } else {\n      // Otherwise we first calculate the texture rasterization for the label\n      // Update the calculated texture size.\n      resource.rasterization.texture = {\n        height: maxY - minY,\n        width: maxX - minX\n      };\n\n      resource.rasterization.canvas = this.createCroppedCanvas(\n        resource,\n        minY,\n        minX\n      );\n      this.calculateLabelSize(resource, 1.0, false);\n    }\n  }\n\n  /**\n   * This determines what the truncated text of the label will be. If there is no truncation\n   * then the truncated text === the label's text\n   */\n  static calculateTrucatedText(resource: LabelAtlasResource) {\n    const label = resource.label;\n    const maxWidth = label.maxWidth;\n\n    // If the label has no max width, then there will be no truncation\n    if (!maxWidth) {\n      resource.truncatedText = label.text;\n      return;\n    }\n\n    // We now do an initial rendering of the label as it will appear in world space\n    this.drawLabel(label, label.text, canvas, 1);\n    // We measure the contents of the rendered item to see if it violates the maxWidth\n    const firstTest = this.measureContents(canvas);\n\n    // If we're within spec, we do not need to truncate\n    if (firstTest.maxX - firstTest.minX <= maxWidth) {\n      resource.truncatedText = label.text;\n      return;\n    }\n\n    // At this point we need to binary search through chopping off letters to find a string\n    // That will fit within max width\n    const text = label.text;\n    let left = 0;\n    let right = text.length;\n    let cursor = floor((right - left) / 2.0);\n    let safety = 0;\n    const safetyMax = 50;\n\n    // Loop to perform the binary search\n    while (right > left && cursor !== 0 && safety++ < safetyMax) {\n      // Draw and measure\n      this.drawLabel(label, `${text.substr(0, cursor)}...`, canvas, 1);\n      const { minX, maxX } = this.measureContents(canvas);\n\n      // If we pass then we move left to cursor to make the test string longer\n      if (maxX - minX <= maxWidth) {\n        left = cursor;\n      } else {\n        // If we fail, we move right to cursor to make the test string shorter\n        right = cursor;\n      }\n\n      // Get our next cursor position\n      const nextCursor = floor((right - left) / 2.0) + left;\n\n      // If the next cursor is the same as cursor, then we're done searching\n      if (nextCursor === cursor) {\n        break;\n      }\n\n      // Move our cursor\n      cursor = nextCursor;\n    }\n\n    // If cursor is zero, nothing passed and our truncation is just ellipses\n    if (cursor === 0) {\n      resource.truncatedText = \"...\";\n    } else {\n      // Otherwise we get the string that passes and use that as our truncated text\n      resource.truncatedText = `${text.substr(0, cursor)}...`;\n    }\n  }\n\n  /**\n   * This generates a canvas that has the cropped version of the label where the label\n   * fits neatly in the canvas object.\n   */\n  static createCroppedCanvas(\n    resource: LabelAtlasResource,\n    top: number,\n    left: number\n  ) {\n    const cropped = document.createElement(\"canvas\");\n    const context = cropped.getContext(\"2d\");\n\n    if (context) {\n      const texture = resource.rasterization.texture;\n      cropped.width = texture.width;\n      cropped.height = texture.height;\n      context.imageSmoothingEnabled = false;\n\n      // Draw just the region the label appears into the canvas\n      context.drawImage(\n        canvas.canvas,\n        left,\n        top,\n        texture.width,\n        texture.height,\n        0,\n        0,\n        texture.width,\n        texture.height\n      );\n    } else {\n      console.warn(\n        \"Could not create a canvas 2d context to generate a label's cropped image.\"\n      );\n    }\n\n    return cropped;\n  }\n\n  /**\n   * This actually renders a string to a canvas context using a label's settings\n   */\n  static drawLabel(\n    label: Label,\n    text: string,\n    canvas: CanvasRenderingContext2D,\n    sampleScaling: number\n  ) {\n    // Get the font size we will rasterize with\n    const fontSize = this.getLabelRasterizationFontSize(label, sampleScaling);\n    // Set the color of the label to white so we know what color to look for\n    canvas.fillStyle = \"white\";\n    // Set the font to the canvas\n    canvas.font = this.makeCSSFont(label, sampleScaling);\n    // We will use the canvas measuring tool to give us a baseline for how wide\n    // The label will be. We add the font size to the width for the padding needed to ensure\n    // The entirety of the text is placed on the canvas.\n    canvas.canvas.width = canvas.measureText(label.text).width + fontSize;\n    // Make our test area the font size with one extra level of the font size\n    // For padding.\n    canvas.canvas.height = fontSize * 2.0;\n    // After adjusting the canvas dimensions we must re-set the font metrics\n    // Set the color of the label to white so we know what color to look for\n    canvas.fillStyle = \"white\";\n    // Set the font to the canvas\n    canvas.font = this.makeCSSFont(label, sampleScaling);\n    // Render the text into our canvas for calculating\n    canvas.fillText(text, fontSize / 2.0, fontSize / 4.0 + fontSize);\n  }\n\n  /**\n   * Attempts to populate the 'canvas' context for rendering labels offscreen.\n   */\n  static getContext() {\n    if (!canvas) {\n      const potentialCanvas = document.createElement(\"canvas\").getContext(\"2d\");\n\n      if (potentialCanvas) {\n        canvas = potentialCanvas;\n      }\n\n      return potentialCanvas;\n    }\n\n    return canvas;\n  }\n\n  /**\n   * This retrieves the font size that will be used when rasterizing the label. This takes into\n   * account whether the label is requesting super sampling be present for the rendering.\n   */\n  static getLabelRasterizationFontSize(label: Label, sampleScale: number) {\n    return label.fontSize * sampleScale;\n  }\n\n  /**\n   * Generates the CSS font string based on the label's values\n   */\n  static makeCSSFont(label: Label, sampleScale: number) {\n    return `${label.fontWeight} ${this.getLabelRasterizationFontSize(\n      label,\n      sampleScale\n    )}px ${label.fontFamily}`;\n  }\n\n  /**\n   * This measures the contents of what is inside the canvas assumming the rendered values are only white\n   */\n  static measureContents(canvas: CanvasRenderingContext2D) {\n    const { width, height } = canvas.canvas;\n    const imageData = canvas.getImageData(0, 0, width, height).data;\n    let r;\n\n    let minY = Number.MAX_SAFE_INTEGER;\n    let minX = Number.MAX_SAFE_INTEGER;\n    let maxX = Number.MIN_SAFE_INTEGER;\n    let maxY = Number.MIN_SAFE_INTEGER;\n\n    for (let i = 0; i < width; ++i) {\n      for (let k = 0; k < height; ++k) {\n        const redIndex = k * (width * 4) + i * 4;\n        r = imageData[redIndex];\n\n        if (r > 0.0) {\n          minY = min(minY, k);\n          minX = min(minX, i);\n          maxX = max(maxX, i);\n          maxY = max(maxY, k);\n        }\n      }\n    }\n\n    // The identified pixel needs to be encased and not a direct target\n    minY -= 1;\n    maxY += 2;\n    maxX += 2;\n    minX -= 1;\n\n    minY = max(minY, 0);\n    minX = max(minX, 0);\n\n    return { minX, minY, maxX, maxY };\n  }\n\n  /**\n   * Performs the rendering of the label\n   */\n  static async render(\n    resource: LabelAtlasResource\n  ): Promise<LabelAtlasResource> {\n    // Make sure our canvas object is ready for rendering\n    await this.awaitContext();\n\n    // Validate the label's input\n    if (resource.label.fontSize > MAX_FONT_SIZE) {\n      console.warn(\"Labels only support font sizes up to 50\");\n      return resource;\n    }\n\n    // Calculate all of the label metrics and generate a canvas on the label that can\n    // Be rendered to the canvas.\n    this.calculateLabelSize(resource, resource.sampleScale, true);\n\n    return resource;\n  }\n\n  /**\n   * Performs the rendering of the label\n   */\n  static renderSync(resource: LabelAtlasResource): LabelAtlasResource {\n    // Ensure our offscreen canvas is prepped\n    this.getContext();\n\n    if (!canvas) {\n      console.warn(\n        \"Can not render a label synchronously without the canvas context being ready.\"\n      );\n      return resource;\n    }\n\n    // Validate the label's input\n    if (resource.label.fontSize > MAX_FONT_SIZE) {\n      console.warn(\"Labels only support font sizes up to 50\");\n      return resource;\n    }\n\n    // Calculate all of the label metrics and generate a canvas on the label that can\n    // Be rendered to the canvas.\n    this.calculateLabelSize(resource, resource.sampleScale, true);\n\n    return resource;\n  }\n}\n","import { Image } from \"../../primitives/image\";\nimport { BaseAtlasResource } from \"./base-atlas-resource\";\n\nexport class ImageAtlasResource extends BaseAtlasResource {\n  /** This is the image to be loaded into the atlas */\n  image: Image;\n\n  constructor(image: Image) {\n    super();\n    this.image = image;\n  }\n}\n","import { Color } from \"../../primitives/color\";\nimport { ColorAtlasResource } from \"./color-atlas-resource\";\n\n// When ratserized to the image, this determines the size of the square rendered to the atlas.\nconst COLOR_RASTERIZATION_SIZE = 2;\n\n/**\n * Static class for rasterizing a color to a canvas object\n */\nexport class ColorRasterizer {\n  /**\n   * This loops until our canvas context is available\n   */\n  static async awaitContext(canvas: HTMLCanvasElement) {\n    // Iterate till the browser provides a valid canvas to render elements into\n    for (\n      let c = canvas.getContext(\"2d\"), limit = 0;\n      !Boolean(c) && limit < 100;\n      c = canvas.getContext(\"2d\"), ++limit\n    ) {\n      await new Promise(resolve => setTimeout(resolve, 10));\n    }\n  }\n\n  /**\n   * Generates the CSS string version of the color\n   */\n  static makeCSS(color: Color) {\n    return `rgba(${Math.floor(color.r * 256)}, ${Math.floor(\n      color.g * 256\n    )}, ${Math.floor(color.b * 256)}, ${color.opacity})`;\n  }\n\n  static async render(resource: ColorAtlasResource) {\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext(\"2d\");\n\n    await this.awaitContext(canvas);\n\n    if (context) {\n      canvas.width = COLOR_RASTERIZATION_SIZE;\n      canvas.height = COLOR_RASTERIZATION_SIZE;\n      context.imageSmoothingEnabled = false;\n      context.fillStyle = this.makeCSS(resource.color);\n\n      // Draw the color to the fill space\n      context.fillRect(\n        0,\n        0,\n        COLOR_RASTERIZATION_SIZE,\n        COLOR_RASTERIZATION_SIZE\n      );\n      // Update the resource with the rasterization\n      resource.rasterization.canvas = canvas;\n    } else {\n      console.warn(\n        \"Could not create a canvas 2d context to generate a color for rasterization.\"\n      );\n    }\n\n    return resource;\n  }\n}\n","import { Color } from \"../../primitives/color\";\nimport { BaseAtlasResource } from \"./base-atlas-resource\";\n\nexport class ColorAtlasResource extends BaseAtlasResource {\n  /** This is the color to be loaded into the atlas */\n  color: Color;\n\n  constructor(color: Color) {\n    super();\n    this.color = color;\n  }\n}\n","import * as Three from \"three\";\nimport { Vec2 } from \"../../util/vector\";\n\n/**\n * Defines a texture that is located on an atlas\n */\nexport class SubTexture {\n  /** Stores the aspect ratio of the image for quick reference */\n  aspectRatio: number = 1.0;\n  /** The id of the atlas this texture is located on */\n  atlasReferenceID: string = \"\";\n  /** This is the actual texture of the atlas this resource is located on */\n  atlasTexture: Three.Texture | null = null;\n  /** This is the top left UV coordinate of the sub texture on the atlas */\n  atlasTL: Vec2 = [0, 0];\n  /** This is the top right UV coordinate of the sub texture on the atlas */\n  atlasTR: Vec2 = [0, 0];\n  /** This is the bottom left UV coordinate of the sub texture on the atlas */\n  atlasBL: Vec2 = [0, 0];\n  /** This is the bottom right UV coordinate of the sub texture on the atlas */\n  atlasBR: Vec2 = [0, 0];\n  /** This is the normalized width of the sub texture on the atlas */\n  widthOnAtlas: number = 0;\n  /** This is the normalized height of the sub texture on the atlas */\n  heightOnAtlas: number = 0;\n  /** This flag is set to false when the underlying texture is no longer valid */\n  isValid: boolean = false;\n  /** Width in pixels of the image on the atlas */\n  pixelWidth: number = 0;\n  /** Height in pixels of the image on the atlas */\n  pixelHeight: number = 0;\n}\n","import * as Three from \"three\";\nimport {\n  IdentifyByKey,\n  IdentifyByKeyOptions\n} from \"../../util/identify-by-key\";\nimport { Vec2 } from \"../../util/vector\";\nimport { AtlasManager, AtlasResource } from \"./atlas-manager\";\nimport { PackNode } from \"./pack-node\";\nimport { SubTexture } from \"./sub-texture\";\n\n/**\n * These are valid atlas sizes available. We force a power of 2 to be utilized.\n * We do not allow crazy large sizes as browsers have very real caps on resources.\n * This helps implementations be a little smarter about what they are using. Future\n * versions may increase this number as GPUs improve and standards allow greater\n * flexibility.\n */\nexport enum AtlasSize {\n  _2 = 0x01 << 1,\n  _4 = 0x01 << 2,\n  _8 = 0x01 << 3,\n  _16 = 0x01 << 4,\n  _32 = 0x01 << 5,\n  _64 = 0x01 << 6,\n  _128 = 0x01 << 7,\n  _256 = 0x01 << 8,\n  _512 = 0x01 << 9,\n  _1024 = 0x01 << 10,\n  _2048 = 0x01 << 11,\n  _4096 = 0x01 << 12\n}\n\nexport interface IAtlasOptions extends IdentifyByKeyOptions {\n  /** This is the height of the texture */\n  height: AtlasSize;\n  /** This is the width of the atlas */\n  width: AtlasSize;\n  /**\n   * This applies any desired settings to the Threejs texture as desired.\n   * Some noteable defaults this system sets:\n   *  - generateMipMaps is false and\n   *  - premultiply alpha is true.\n   */\n  textureSettings?: Partial<Three.Texture>;\n}\n\n/**\n * This represents a single Texture on the gpu that is composed of several smaller textures\n * as a 'look up'.\n */\nexport class Atlas extends IdentifyByKey {\n  /** Stores the size of the atlas texture */\n  height: AtlasSize;\n  /** This is the parent manager of the atlas */\n  manager: AtlasManager;\n  /** This is the packing of the  */\n  packing: PackNode;\n  /** This is the actual texture object that represents the atlas on the GPU */\n  texture: Three.Texture;\n  /** These are the applied settings to our texture */\n  textureSettings?: Partial<Three.Texture>;\n  /**\n   * This is all of the resources associated with this atlas. The boolean flag indicates if the resource\n   * is flagged for removal. When set to false, the resource is no longer valid and can be removed from\n   * the atlas at any given moment.\n   */\n  validResources = new Set<AtlasResource>();\n  /** Stores the size of the atlas texture */\n  width: AtlasSize;\n\n  constructor(options: IAtlasOptions) {\n    super(options);\n    const canvas = document.createElement(\"canvas\");\n    this.width = canvas.width = options.width;\n    this.height = canvas.height = options.height;\n    this.textureSettings = options.textureSettings;\n\n    // Set up the packing for this atlas\n    this.packing = new PackNode(0, 0, options.width, options.height);\n    // Make sure the texture is started and updated\n    this.updateTexture(canvas);\n  }\n\n  /**\n   * This invalidates the SubTexture of an atlas resource.\n   */\n  private invalidateResource(resource: AtlasResource) {\n    const zero: Vec2 = [0, 0];\n    resource.texture.aspectRatio = 1;\n    resource.texture.atlasBL = zero;\n    resource.texture.atlasBR = zero;\n    resource.texture.atlasTL = zero;\n    resource.texture.atlasTR = zero;\n    resource.texture.atlasReferenceID = \"\";\n    resource.texture.pixelWidth = 0;\n    resource.texture.pixelHeight = 0;\n    resource.texture.isValid = false;\n    resource.texture.atlasTexture = null;\n  }\n\n  /**\n   * Sets the parent manager of this atlas\n   */\n  setManager(manager: AtlasManager) {\n    this.manager = manager;\n  }\n\n  /**\n   * Adds a resource to this atlas AND ensures the resource is flagged valid for use.\n   *\n   * @return {boolean} True if the resource successfully registered\n   */\n  registerResource(resource: AtlasResource) {\n    if (!this.validResources.has(resource)) {\n      if (!resource.texture || !resource.texture.isValid) {\n        if (!resource.texture) {\n          resource.texture = new SubTexture();\n        }\n\n        resource.texture.isValid = true;\n        resource.texture.atlasTexture = this.texture;\n        this.validResources.add(resource);\n\n        return true;\n      } else {\n        console.warn(\n          \"Atlas Error:\",\n          this.id,\n          \"Attempted to add a resource to an Atlas that is already a valid resource on another atlas.\",\n          \"Consider Creating a new resource to be loaded into this particular atlas.\",\n          \"Resource:\",\n          resource\n        );\n      }\n    } else {\n      console.warn(\n        \"Atlas Error:\",\n        this.id,\n        \"A resource was trying to be added to the atlas that has already been added before.\",\n        \"Consider creating a new resource to indicate what you want loaded to the atlas\",\n        \"Resource:\",\n        resource\n      );\n    }\n\n    return false;\n  }\n\n  /**\n   * This flags a resource from removal from an atlas.\n   *\n   * NOTE: This does not immediately clear the resource fromt he atlas, nor does it even guarantee\n   * the resource will be cleared from the atlas for a while. It merely suggests the resource be removed\n   * and makes the SubTexture invalid. It could be a long while before the atlas gets regnerated and repacked\n   * to actually reflect the resource not existing on the atlas.\n   */\n  removeResource(resource: AtlasResource) {\n    if (this.validResources.has(resource)) {\n      this.validResources.delete(resource);\n      this.invalidateResource(resource);\n    } else {\n      console.warn(\n        \"Atlas Error:\",\n        this.id,\n        \"Attempted to remove a resource that does not exist on this atlas.\",\n        \"or the resource was already considered invalidated on this atlas.\",\n        \"Resource:\",\n        resource\n      );\n    }\n  }\n\n  /**\n   * TODO:\n   * This performs the currently best known way to update a texture.\n   *\n   * This is the current best attempt at updating the atlas which is junk as it destroys the old texture\n   * And makes a new one. We REALLY should be just subTexture2D updating the texture, but Three makes that really\n   * Difficult\n   */\n  updateTexture(canvas?: HTMLCanvasElement) {\n    if (this.texture) {\n      const redoneCanvas: HTMLCanvasElement = this.texture.image;\n      this.texture.dispose();\n      this.texture = new Three.Texture(redoneCanvas);\n    } else {\n      this.texture = new Three.Texture(canvas);\n    }\n\n    this.validResources.forEach(resource => {\n      if (resource.texture) {\n        resource.texture.atlasTexture = this.texture;\n      }\n    });\n\n    // Apply any relevant options to the texture desired to be set\n    this.texture.generateMipmaps = true;\n    this.texture.premultiplyAlpha = true;\n    this.textureSettings && Object.assign(this.texture, this.textureSettings);\n    this.texture.needsUpdate = true;\n  }\n\n  /**\n   * This frees up all the resources down to the GPU related to this atlas. It also\n   * loops through every resource and invalidates the texturing information within\n   * them so subsequent accidental renders will appear as a single color rather than\n   * an artifacted element.\n   */\n  destroy() {\n    this.texture.dispose();\n    this.validResources.forEach((_isValid, resource) => {\n      this.invalidateResource(resource);\n    });\n  }\n}\n","export * from \"./image-layer\";\nexport * from \"./image-instance\";\n","import { Bounds } from \"../primitives/bounds\";\n\nexport class DataBounds<T> extends Bounds {\n  data: T;\n\n  static emptyBounds<T>() {\n    return new DataBounds<T>({\n      height: 0,\n      width: 0,\n      x: 0,\n      y: 0\n    });\n  }\n}\n","import { DataBounds } from \"../util/data-bounds\";\nimport { Bounds } from \"./bounds\";\n\n/**\n * Anytime this is used to express bounds of an object, it is expected\n * to behave like CSS styling with absolute positioning.\n *\n * Setting a left and a right will auto calculate width (setting width takes precedence)\n *\n * You can set numbers to a %. If no % is present all other characters will be ignored\n * (px, em, and other dimensions will not be supported...just px by default unless %)\n */\nexport type AbsolutePosition = {\n  bottom?: number | string;\n  height?: number | string;\n  left?: number | string;\n  right?: number | string;\n  top?: number | string;\n  width?: number | string;\n};\n\nfunction value(val: number | string, ref: number, scaleRatio: number) {\n  const parse = `${val}`;\n  const num = parseFloat(parse);\n\n  if (isNaN(num)) {\n    return 0;\n  }\n\n  // If this is a percentage use the reference as the num to multiply against\n  if (parse.indexOf(\"%\") > -1) {\n    return num / 100.0 * ref;\n  }\n\n  return num * scaleRatio;\n}\n\n/**\n * This evaluates an absolute position with a reference to produce meaningful bounds.\n *\n * The scaleRatio provided should be available in or for percents to have the same weighting\n * as whole number values.\n */\nexport function getAbsolutePositionBounds<T>(\n  item: AbsolutePosition,\n  reference: Bounds,\n  scaleRatio: number\n): DataBounds<T> {\n  if (reference.width === 0 || reference.height === 0) {\n    console.warn(\n      \"An AbsolutePosition evaluated to invalid dimensions.\",\n      \"Please ensure that the object provided and the reference has valid dimensions\",\n      \"to produce dimensions with width and height that are non-zero.\",\n      \"item:\",\n      item,\n      \"reference:\",\n      reference.toString()\n    );\n  }\n\n  const bounds = DataBounds.emptyBounds<T>();\n  let width;\n  let height;\n\n  // Calculate the horizontal values\n  if (item.width) {\n    bounds.width = value(item.width, reference.width, scaleRatio);\n\n    if (item.left !== undefined) {\n      bounds.x = value(item.left, reference.width, scaleRatio);\n    } else if (item.right !== undefined) {\n      bounds.x =\n        reference.width -\n        value(item.right, reference.width, scaleRatio) -\n        bounds.width;\n    }\n  } else {\n    const left = value(item.left || 0, reference.width, scaleRatio);\n    const right =\n      reference.width - value(item.right || 0, reference.width, scaleRatio);\n    width = right - left;\n\n    if (width < 0) {\n      console.warn(\n        \"An AbsolutePosition evaluated to invalid dimensions.\",\n        \"Please ensure that the object provided and the reference has valid dimensions\",\n        \"to produce dimensions with width and height that are greater than zero.\",\n        \"item:\",\n        item,\n        \"reference:\",\n        reference.toString()\n      );\n    }\n\n    bounds.x = left;\n    bounds.width = width;\n  }\n\n  // Calculate the vertical values\n  if (item.height) {\n    bounds.height = value(item.height, reference.height, scaleRatio);\n\n    if (item.top !== undefined) {\n      bounds.y = value(item.top, reference.height, scaleRatio);\n    } else if (item.bottom !== undefined) {\n      bounds.y =\n        reference.height -\n        value(item.bottom, reference.height, scaleRatio) -\n        bounds.height;\n    }\n  } else {\n    const top = value(item.top || 0, reference.height, scaleRatio);\n    const bottom =\n      reference.height - value(item.bottom || 0, reference.height, scaleRatio);\n    height = bottom - top;\n\n    if (height === undefined || height < 0) {\n      console.warn(\n        \"An AbsolutePosition evaluated to invalid dimensions.\",\n        \"Please ensure that the object provided and the reference has valid dimensions\",\n        \"to produce dimensions with width and height that are greater than zero.\",\n        \"item:\",\n        item,\n        \"reference:\",\n        reference.toString()\n      );\n    }\n\n    bounds.y = top;\n    bounds.height = height;\n  }\n\n  if (\n    bounds.width === 0 ||\n    bounds.height === 0 ||\n    isNaN(bounds.x + bounds.y + bounds.width + bounds.height)\n  ) {\n    bounds.x = 0;\n    bounds.y = 0;\n    bounds.width = reference.width;\n    bounds.height = reference.height;\n  }\n\n  return bounds;\n}\n","import { Instance, InstanceDiff } from \"../../instance-provider\";\nimport {\n  BufferManagerBase,\n  IBufferLocation,\n  IBufferLocationGroup\n} from \"./buffer-manager-base\";\nimport { IInstanceDiffManagerTarget } from \"./instance-diff-manager\";\n\n/**\n * Base requirements for handling diffs from a layer.\n */\nexport abstract class BaseDiffProcessor<T extends Instance> {\n  layer: IInstanceDiffManagerTarget<T>;\n  bufferManager: BufferManagerBase<T, IBufferLocation>;\n\n  constructor(\n    layer: IInstanceDiffManagerTarget<T>,\n    bufferManager: BufferManagerBase<T, IBufferLocation>\n  ) {\n    this.layer = layer;\n    this.bufferManager = bufferManager;\n  }\n\n  /** Perform an 'add' operation for the instance's buffer */\n  abstract addInstance(\n    manager: this,\n    instance: T,\n    propIds: number[],\n    bufferLocation?: IBufferLocation | IBufferLocationGroup<IBufferLocation>\n  ): void;\n  /** Perform a 'change' operation for the instance's buffer */\n  abstract changeInstance(\n    manager: this,\n    instance: T,\n    propIds: number[],\n    bufferLocation?: IBufferLocation | IBufferLocationGroup<IBufferLocation>\n  ): void;\n  /** Perform a 'remove' operation for the instance's buffer */\n  abstract removeInstance(\n    manager: this,\n    instance: T,\n    propIds: number[],\n    bufferLocation?: IBufferLocation | IBufferLocationGroup<IBufferLocation>\n  ): void;\n\n  /**\n   * This indicates all changes have been applied, this allows the processor to finalize buffer updates\n   */\n  abstract commit(): void;\n  /**\n   * This will be called with the changes that WILL be processed. This allows this processor to make extra judgement calls on\n   * how it will process the changes and let's it optimize itself before changes are actually processed. An example optimization:\n   *\n   * Buffers have an update range we can adjust so only a piece of the buffer is updated. However, calculating that range causes\n   * overhead to calculate the affected range. So, if we have mass changes happening for major sections of the buffer (number of\n   * changes approaches some large percentage of the instances supported by the buffer), then it would be more efficient just to\n   * update the entire buffer rather than discover the portion needing updating.\n   */\n  abstract incomingChangeList(changes: InstanceDiff<T>[]): void;\n}\n","import * as Three from \"three\";\nimport {\n  IInstancingUniform,\n  IUniform,\n  ShaderInjectionTarget\n} from \"../../types\";\nimport { MetricsProcessing } from \"./metrics-processing\";\n\n/** Converts a size to a shader type */\nconst sizeToType: { [key: number]: string } = {\n  1: \"float\",\n  2: \"vec2\",\n  3: \"vec3\",\n  4: \"vec4\",\n  9: \"mat3\",\n  16: \"mat4\",\n  99: \"sampler2D\"\n};\n\n/**\n * This contains methods centered around processing uniforms and generating the uniform declarations\n * needed to make a shader compatible with a layer.\n */\nexport class UniformProcessing {\n  /** Tracks all of the generated uniforms the system created in order to aid in compatibility */\n  materialUniforms: IInstancingUniform[] = [];\n  /** Provides needed metrics for processing uniform generation */\n  private metricsProcessor: MetricsProcessing;\n\n  constructor(metricsProcessor: MetricsProcessing) {\n    this.metricsProcessor = metricsProcessor;\n  }\n\n  /**\n   * This is the special case where attributes are packed into a uniform buffer instead of into\n   * attributes. This is to maximize compatibility with hard and maximize flexibility in creative approaches\n   * to utilizing shaders that need a lot of input.\n   */\n  generateUniformAttributePacking() {\n    let out = \"\\n// Instance Attributes as a packed Uniform Buffer\";\n\n    // Add the uniform buffer to the shader\n    out += `uniform vec4 ${UniformProcessing.uniformPackingBufferName()}[${\n      this.metricsProcessor.totalInstanceUniformBlocks\n    }];\\n`;\n    // Add the number of blocks an instance utilizes\n    out += `int instanceSize = ${\n      this.metricsProcessor.totalInstanceUniformBlocks\n    };`;\n    // Add the block retrieval method to aid in the Destructuring process\n    out += `vec4 getBlock(int index, int instanceIndex) { return ${UniformProcessing.uniformPackingBufferName()}[(instanceSize * instanceIndex) + index]; }`;\n\n    // Add our extra uniform to the material uniform output so the system can utilize it as needed.\n    this.materialUniforms.push({\n      name: UniformProcessing.uniformPackingBufferName(),\n      type: \"4fv\",\n      value: new Array(this.metricsProcessor.totalInstanceUniformBlocks)\n        .fill(0)\n        .map(() => new Three.Vector4(0, 0, 0, 0))\n    });\n\n    return out;\n  }\n\n  /**\n   * Processes a layer and it's requested uniforms and generates the injections needed to declare the\n   * uniforms.\n   */\n  process(uniforms: IUniform[], injectionType: ShaderInjectionTarget) {\n    let out = \"\";\n    const injection = injectionType || ShaderInjectionTarget.VERTEX;\n\n    uniforms.forEach(uniform => {\n      uniform.shaderInjection =\n        uniform.shaderInjection || ShaderInjectionTarget.VERTEX;\n\n      if (\n        uniform.shaderInjection === injection ||\n        uniform.shaderInjection === ShaderInjectionTarget.ALL\n      ) {\n        out += `uniform ${uniform.qualifier || \"\"}${\n          uniform.qualifier ? \" \" : \"\"\n        }${sizeToType[uniform.size]} ${uniform.name};\\n`;\n      }\n    });\n\n    return out;\n  }\n\n  /**\n   * This is the name of the Uniform Buffer packing strategies name for the Uniform buffer that\n   * all of our attributes get packed into.\n   */\n  static uniformPackingBufferName() {\n    return `instanceData`;\n  }\n}\n","let toEmit: { [key: string]: [Function, number, number] } = {};\n\nexport function emitOnce(\n  id: string,\n  callback: (calledCountBeforeEmit: number, id: string) => void\n) {\n  const emit = toEmit[id] || [callback, -1, 0];\n  toEmit[id] = emit;\n  emit[2]++;\n\n  clearTimeout(emit[1]);\n  emit[1] = window.setTimeout(() => {\n    callback(emit[2], id);\n    delete toEmit[id];\n  }, 1);\n}\n\nexport function flushEmitOnce() {\n  for (const id in toEmit) {\n    const emit = toEmit[id];\n    clearTimeout(emit[1]);\n    emit[0](emit[2], id);\n  }\n\n  toEmit = {};\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport { IInstanceAttribute } from \"../../types\";\n\nexport function getAttributeShaderName<T extends Instance>(\n  attribute: IInstanceAttribute<T>\n) {\n  if (attribute.easing) {\n    return `_${attribute.name}_end`;\n  } else {\n    return attribute.name;\n  }\n}\n","import * as browser from \"bowser\";\nimport { scale2, Vec2 } from \"./vector\";\nconst debug = require(\"debug\")(\"CommunicationsView:Mouse\");\n\n/** Used to adjust the base whee delta for IE browsers */\nconst IE_ADJUSTMENT = 1 / 30;\n/** Used to adjust the rates for IE 11 */\nconst OLD_IE_ADJUSTMENT = -0.25;\n// This determines how large the delta can grow to in firefox\nconst MAX_FIREFOX_WHEELDELTA = 100;\n/**\n * Create a low pass filter memory bank so we can slow down rapid accelerations and let normal slower accelerations pass\n * Common use case for this is the discrepancy in firefox from mousewheels to trackpad scroll speeds\n */\nconst lowPassY: number[] = [0, 0, 0, 0];\n// These coefficients represent the coefficients of a FIR filter.\n// This FIR filter uses the lowPassY as the memory for the filter and is created for\n// The reasons specified for the lowPassY memory. To edit the coefficients, you simply\n// Ensure the coefficients added together === 1.0. If they do not, you may get an unstable\n// Result that goes to infinity rather quickly. Changing the distribution of these coefficients\n// Alters the rate at which the delta can approach MAX_FIREFOX_WHEELDELTA. Explaining exactly\n// How it affects the rate requires an understanding of FIR filters, so unless this is already\n// Known knowledge, it would be faster to just tweak the coefficients until a desired effect is\n// Attained.\nconst LOW_PASS_U0 = 0.02;\nconst LOW_PASS_U1 = 0.1;\nconst LOW_PASS_U2 = 0.18;\nconst LOW_PASS_U3 = 0.7;\n\nfunction normalizeFirefoxWheel(e: MouseWheelEvent): Vec2 {\n  const wheel: WheelEvent = e;\n  let deltaX = 0;\n  let deltaY = 0;\n\n  // Reset the filter if the direction changes to prevent lag in directional change\n  if (Math.sign(lowPassY[0]) !== Math.sign(deltaY)) {\n    lowPassY.splice(0, lowPassY.length, 0, 0, 0, 0);\n  }\n\n  deltaX = wheel.deltaX * MAX_FIREFOX_WHEELDELTA;\n\n  // Calculate the next value output from the FIR filter\n  deltaY =\n    wheel.deltaY * MAX_FIREFOX_WHEELDELTA * LOW_PASS_U0 +\n    lowPassY[0] * LOW_PASS_U1 +\n    lowPassY[1] * LOW_PASS_U2 +\n    lowPassY[2] * LOW_PASS_U3;\n  // Store the value of the filter in the FIR memory bank\n  lowPassY.unshift(deltaY);\n  // Keep our FIR memory clean and only the size of the number of coefficients\n  lowPassY.pop();\n\n  return [-deltaX, -deltaY];\n}\n\nfunction normalizeChromeWheel(e: MouseWheelEvent): Vec2 {\n  const wheel: WheelEvent = e;\n\n  return [wheel.deltaX, -wheel.deltaY];\n}\n\nfunction normalizeIE11Wheel(e: MouseWheelEvent): Vec2 {\n  const wheel: WheelEvent = e;\n  let deltaX = wheel.deltaX;\n\n  if (deltaX === undefined) {\n    deltaX =\n      wheel.wheelDeltaX !== undefined ? wheel.wheelDeltaX * IE_ADJUSTMENT : 0;\n  }\n\n  let deltaY = wheel.deltaY;\n\n  if (deltaY === undefined) {\n    if (wheel.wheelDeltaY !== undefined) {\n      deltaY = wheel.wheelDeltaY * IE_ADJUSTMENT;\n    } else {\n      deltaY = (wheel.wheelDelta || -wheel.detail) * OLD_IE_ADJUSTMENT;\n    }\n  }\n\n  return [-deltaX, -deltaY];\n}\n\nfunction normalizeIE12Wheel(e: MouseWheelEvent): Vec2 {\n  const wheel: WheelEvent = e;\n  let { deltaX, deltaY } = wheel;\n\n  if (deltaX === undefined) {\n    deltaX =\n      wheel.wheelDeltaX !== undefined ? wheel.wheelDeltaX * IE_ADJUSTMENT : 0;\n  }\n\n  if (deltaY === undefined) {\n    if (wheel.wheelDeltaY !== undefined) {\n      deltaY = wheel.wheelDeltaY * IE_ADJUSTMENT;\n    } else {\n      deltaY = wheel.wheelDelta || -wheel.detail;\n    }\n  }\n\n  const v: Vec2 = [deltaX, -deltaY];\n  scale2(v, 0.25);\n\n  return v;\n}\n\n// Determine this browsers version of wheel normalization and apply it\nlet normalizeWheel: (e: MouseWheelEvent) => Vec2;\n\nif (browser.firefox) {\n  debug(\"Using mouse wheel for firefox\");\n  normalizeWheel = normalizeFirefoxWheel;\n} else if (browser.msie && +browser.version >= 11) {\n  debug(\"Using mouse wheel for IE 11\");\n  normalizeWheel = normalizeIE11Wheel;\n} else if (browser.msedge) {\n  debug(\"Using mouse wheel for MS EDGE\");\n  normalizeWheel = normalizeIE12Wheel;\n} else {\n  debug(\"Using mouse wheel for Chrome\");\n  normalizeWheel = normalizeChromeWheel;\n}\n\n/**\n * Analyzes a MouseEvent and calculates the mouse coordinates (relative to the element).\n */\nfunction eventElementPosition(e: any, relative?: HTMLElement): Vec2 {\n  let mouseX: number = 0,\n    mouseY: number = 0,\n    eventX: number = 0,\n    eventY: number = 0,\n    object: any =\n      relative || (e.nativeEvent && e.nativeEvent.target) || e.target;\n\n  // Get mouse position on document crossbrowser\n  if (!e) {\n    e = window.event;\n  }\n\n  if (e.pageX || e.pageY) {\n    mouseX = e.pageX;\n    mouseY = e.pageY;\n  } else if (e.clientX || e.clientY) {\n    let scrollLeft = 0;\n    let scrollTop = 0;\n\n    if (document.documentElement) {\n      scrollLeft = document.documentElement.scrollLeft;\n      scrollTop = document.documentElement.scrollTop;\n    }\n\n    mouseX = e.clientX + document.body.scrollLeft + scrollLeft;\n    mouseY = e.clientY + document.body.scrollTop + scrollTop;\n  }\n\n  // Get parent element position in document\n  if (object.offsetParent) {\n    do {\n      eventX += object.offsetLeft;\n      eventY += object.offsetTop;\n      object = object.offsetParent;\n    } while (object);\n  }\n\n  // Mouse position minus elm position is mouseposition relative to element:\n  return [mouseX - eventX, mouseY - eventY];\n}\n\nexport { eventElementPosition, normalizeWheel };\n","import { Instance } from \"../../instance-provider/instance\";\nimport { IShaderExtension, IShaderInitialization } from \"../../types\";\nimport {\n  IShaderTemplateRequirements,\n  shaderTemplate\n} from \"../../util/shader-templating\";\nimport { templateVars } from \"../template-vars\";\n\nexport function extendShader<T extends Instance>(\n  shaderIO: IShaderInitialization<T>,\n  vs?: IShaderExtension,\n  fs?: IShaderExtension\n) {\n  const baseVS = shaderIO.vs;\n  const baseFS = shaderIO.fs;\n\n  let extendedVS = { shader: baseVS };\n  let extendedFS = { shader: baseFS };\n\n  // Set the replacements for the extension locations, but also retain the extension modifier to allow for\n  // Further extensions if desired.\n  if (vs) {\n    const options: { [key: string]: string } = {};\n\n    options[templateVars.extendHeader] = vs.header\n      ? `${vs.header}\\n$\\{${templateVars.extendHeader}}`\n      : \"\";\n    options[templateVars.extend] = vs.body\n      ? `${vs.body}\\n$\\{${templateVars.extend}}`\n      : \"\";\n\n    // It is REQUIRED to have both header and body extensions to be a valid extendible shader\n    const required: IShaderTemplateRequirements = {\n      name: \"Extend VS Shader\",\n      values: [templateVars.extendHeader, templateVars.extend]\n    };\n\n    // Generated the extended shader\n    extendedVS = shaderTemplate({\n      options,\n      required,\n      shader: baseVS,\n\n      // We do not want to remove any template macros that do not deal with extension\n      onToken: (token, replace) => {\n        if (\n          token === templateVars.extendHeader ||\n          token === templateVars.extend\n        ) {\n          return replace;\n        }\n\n        return `$\\{${token}}`;\n      }\n    });\n  }\n\n  // Next, extend the fragment shader\n\n  // Set the replacements for the extension locations, but also retain the extension modifier to allow for\n  // Further extensions if desired.\n  if (fs) {\n    const options: { [key: string]: string } = {};\n\n    options[templateVars.extendHeader] = fs.header\n      ? `${fs.header}\\n$\\{${templateVars.extendHeader}}`\n      : \"\";\n    options[templateVars.extend] = fs.body\n      ? `${fs.body}\\n$\\{${templateVars.extend}}`\n      : \"\";\n\n    // It is REQUIRED to have both header and body extensions to be a valid extendible shader\n    const required = {\n      name: \"Extend FS Shader\",\n      values: [templateVars.extendHeader, templateVars.extend]\n    };\n\n    // Generate the extended shader\n    extendedFS = shaderTemplate({\n      options,\n      required,\n      shader: baseFS,\n\n      // We do not want to remove any template macros that do not deal with extension\n      onToken: (token, replace) => {\n        if (\n          token === templateVars.extendHeader ||\n          token === templateVars.extend\n        ) {\n          return replace;\n        }\n\n        return `$\\{${token}}`;\n      }\n    });\n  }\n\n  // Apply the extension to the shader io program\n  return {\n    fs: extendedFS.shader,\n    vs: extendedVS.shader\n  };\n}\n","import { InstanceIOValue } from \"../types\";\nimport { uid } from \"../util/uid\";\nimport { Vec, VecMath } from \"./vector\";\n\nconst { min, max, pow, round, sin, PI } = Math;\nconst GPU_PI = round(PI * 1000) / 1000;\n\nfunction clamp(x: number, minVal: number, maxVal: number) {\n  return min(max(x, minVal), maxVal);\n}\n\nexport enum AutoEasingLoopStyle {\n  /** Time will go from 0 -> 1 then stop at 1 */\n  NONE = 1,\n  /** Time will go from 0 -> infinity */\n  CONTINUOUS = 4,\n  /** Time will continuously go 0 -> 1 then 0 -> 1 then 0 -> 1 etc etc */\n  REPEAT = 2,\n  /** Time will continously go 0 -> 1 then 1 -> 0 then 0 -> 1 then 1 -> 0 etc etc */\n  REFLECT = 3\n}\n\n/**\n * This defines a GPU enabled easing method that will be executed on the GPU to maneuver\n *\n */\nexport interface IAutoEasingMethod<T extends InstanceIOValue> {\n  /** An easing method that should produce IDENTICAL values to the values of the gpu easing method using the exact same parameters */\n  cpu(start: T, end: T, t: number): T;\n  /** This adds a delay to the starting time of an easing change */\n  delay: number;\n  /** This is how long the easing method should last */\n  duration: number;\n  /**\n   * An easing method written in shader language that should produce IDENTICAL\n   * values to the values of the cpu easing method using the exact same parameters.\n   */\n  gpu: string;\n  /**\n   * This defines the looping style of the easing.\n   */\n  loop: AutoEasingLoopStyle;\n  /**\n   * This shall be the name of the easing method as it appears in the spu shader.\n   * BE WARNED: This name is used to dedup the methods created on the shader. So,\n   * if you use the same name as another ease method used on a single layer, you run\n   * the risk of one overriding the other with an undefined chance of who wins.\n   */\n  methodName: string;\n  /**\n   * A unique identifier for the auto easing method.\n   */\n  uid: number;\n\n  /**\n   * This lets you modify some auto easing validation rules.\n   */\n  validation?: {\n    ignoreEndValueCheck?: boolean;\n    ignoreOverTimeCheck?: boolean;\n  };\n}\n\n// GPU easing methods! Written here because it's cleaner to write `` style strings\n// Against the left side of the editor\n\nconst immediateGPU = `\n$\\{easingMethod} {\n  return end;\n}\n`;\n\nconst linearGPU = `\n$\\{easingMethod} {\n  return (end - start) * t + start;\n}\n`;\n\nconst easeInQuadGPU = `\n$\\{easingMethod} {\n  float time = t * t;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeOutQuadGPU = `\n$\\{easingMethod} {\n  float time = t * (2.0 - t);\n  return (end - start) * time + start;\n}\n`;\nconst easeInOutQuadGPU = `\n$\\{easingMethod} {\n  float time = t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;\n  return (end - start) * time + start;\n}\n`;\nconst easeInCubicGPU = `\n$\\{easingMethod} {\n  float time = t * t * t;\n  return (end - start) * time + start;\n}\n`;\nconst easeOutCubicGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = t1 * t1 * t1 + 1.0;\n  return (end - start) * time + start;\n}\n`;\nconst easeInOutCubicGPU = `\n$\\{easingMethod} {\n  float time = t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0;\n  return (end - start) * time + start;\n}\n`;\nconst easeInQuartGPU = `\n$\\{easingMethod} {\n  float time = t * t * t * t;\n  return (end - start) * time + start;\n}\n`;\nconst easeOutQuartGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = 1.0 - t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n`;\nconst easeInOutQuartGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = t < 0.5 ? 8.0 * t * t * t * t : 1.0 - 8.0 * t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n`;\nconst easeInQuintGPU = `\n$\\{easingMethod} {\n  float time = t * t * t * t * t;\n  return (end - start) * time + start;\n}\n`;\nconst easeOutQuintGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = 1.0 + t1 * t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n`;\nconst easeInOutQuintGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = t < 0.5 ? 16.0 * t * t * t * t * t : 1.0 + 16.0 * t1 * t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeOutElasticGPU = `\n$\\{easingMethod} {\n  float p = 0.3;\n  float time = pow(2.0, -10.0 * t) * sin((t - p / 4.0) * (2.0 * ${GPU_PI}) / p) + 1.0;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeBackInGPU = `\n$\\{easingMethod} {\n  float time = t * t * t - t * 1.05 * sin(t * ${GPU_PI});\n  return (end - start) * time + start;\n}\n`;\n\nconst easeBackOutGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float a = 1.7;\n  float time = (t1 * t1 * ((a + 1.0) * t1 + a) + 1.0);\n  return (end - start) * time + start;\n}\n`;\n\nconst easeBackInOutGPU = `\n$\\{easingMethod} {\n  float a = 1.4;\n  float a1 = a * 1.525;\n  float t1 = t / 0.5;\n  float t2 = t1 - 2.0;\n  float time =\n    (t1 < 1.0) ? 0.5 * (t1 * t1 * (a1 + 1.0) * t1 - a1) :\n    0.5 * (t2 * t2 * ((a1 + 1.0) * t2 + a1) + 2.0)\n  ;\n\n  return (end - start) * time + start;\n}\n`;\n\nconst continuousSinusoidalGPU = `\n$\\{easingMethod} {\n  $\\{T} direction = end - start;\n  float amplitude = length(direction) * 2.0;\n  return start + direction * sin(t * ${GPU_PI} * 2.0) * amplitude;\n}\n`;\n\n/**\n * Class of base AutoEasingMethods as well as helper constructs for making the methods.\n */\nexport class AutoEasingMethod<T extends InstanceIOValue>\n  implements IAutoEasingMethod<T> {\n  /**\n   * Autoeasing methods for linear easing\n   */\n  static immediate<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (_start: T, end: T, _t: number) => end,\n      delay,\n      duration,\n      gpu: immediateGPU,\n      loop,\n      methodName: \"immediate\"\n    };\n  }\n\n  /**\n   * Autoeasing methods for linear easing\n   */\n  static linear<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number) => {\n        const { add, scale, subtract } = VecMath(start);\n        t = clamp(t, 0, 1);\n        return add(scale(subtract(end, start), t), start);\n      },\n      delay,\n      duration,\n      gpu: linearGPU,\n      loop,\n      methodName: \"linear\"\n    };\n  }\n\n  /**\n   * Auto easing for Accelerating to end\n   */\n  static easeInQuad<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeInQuadGPU,\n      loop,\n      methodName: \"easeInQuad\"\n    };\n  }\n\n  /**\n   * Auto easing for decelerating to end\n   */\n  static easeOutQuad<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = t * (2 - t);\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeOutQuadGPU,\n      loop,\n      methodName: \"easeOutQuad\"\n    };\n  }\n\n  /**\n   * Auto easing for Accelerate to mid, then decelerate to end\n   */\n  static easeInOutQuad<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeInOutQuadGPU,\n      loop,\n      methodName: \"easeInOutQuad\"\n    };\n  }\n\n  /**\n   * Auto easing for Slower acceleration\n   */\n  static easeInCubic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeInCubicGPU,\n      loop,\n      methodName: \"easeInCubic\"\n    };\n  }\n\n  /**\n   * Auto easing for Slower deceleration\n   */\n  static easeOutCubic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = --t * t * t + 1;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeOutCubicGPU,\n      loop,\n      methodName: \"easeOutCubic\"\n    };\n  }\n\n  /**\n   * Auto easing for Slower acceleration to mid, and slower deceleration to end\n   */\n  static easeInOutCubic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time =\n          t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeInOutCubicGPU,\n      loop,\n      methodName: \"easeInOutCubic\"\n    };\n  }\n\n  /**\n   * Auto easing for even Slower acceleration to end\n   */\n  static easeInQuart<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeInQuartGPU,\n      loop,\n      methodName: \"easeInQuart\"\n    };\n  }\n\n  /**\n   * Auto easing for even Slower deceleration to end\n   */\n  static easeOutQuart<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = 1 - --t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeOutQuartGPU,\n      loop,\n      methodName: \"easeOutQuart\"\n    };\n  }\n\n  /**\n   * Auto easing for even Slower acceleration to mid, and even slower deceleration to end\n   */\n  static easeInOutQuart<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeInOutQuartGPU,\n      loop,\n      methodName: \"easeInOutQuart\"\n    };\n  }\n\n  /**\n   * Auto easing for super slow accelerating to the end\n   */\n  static easeInQuint<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = t * t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeInQuintGPU,\n      loop,\n      methodName: \"easeInQuint\"\n    };\n  }\n\n  /**\n   * Auto easing for super slow decelerating to the end\n   */\n  static easeOutQuint<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time = 1 + --t * t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeOutQuintGPU,\n      loop,\n      methodName: \"easeOutQuint\"\n    };\n  }\n\n  /**\n   * Auto easing for super slow accelerating to mid and super slow decelerating to the end\n   */\n  static easeInOutQuint<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const time =\n          t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeInOutQuintGPU,\n      loop,\n      methodName: \"easeInOutQuint\"\n    };\n  }\n\n  /**\n   * Auto easing for elastic effect\n   */\n  static easeOutElastic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const p = 0.3;\n        const time = pow(2, -10 * t) * sin((t - p / 4) * (2 * PI) / p) + 1;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeOutElasticGPU,\n      loop,\n      methodName: \"easeOutElastic\"\n    };\n  }\n\n  /**\n   * Auto easing for retracting first then shooting to the end\n   */\n  static easeBackIn<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const a = 1.05;\n        const time = t * t * t - t * a * sin(t * PI);\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeBackInGPU,\n      loop,\n      methodName: \"easeBackIn\"\n    };\n  }\n\n  /**\n   * Auto easing for overshooting at the end\n   */\n  static easeBackOut<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const a = 1.7;\n        const t1 = t - 1;\n        const time = t1 * t1 * ((a + 1) * t1 + a) + 1;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeBackOutGPU,\n      loop,\n      methodName: \"easeBackOut\"\n    };\n  }\n\n  /**\n   * Auto easing for overshooting at the end\n   */\n  static easeBackInOut<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number) => {\n        t = clamp(t, 0, 1);\n        const a = 1.7;\n        const a1 = a * 1.525;\n        const t1 = t / 0.5;\n        const t2 = t1 - 2;\n        const time =\n          t1 < 1\n            ? 0.5 * (t1 * t1 * (a1 + 1) * t1 - a1)\n            : 0.5 * (t2 * t2 * ((a1 + 1) * t2 + a1) + 2);\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start);\n      },\n      delay,\n      duration,\n      gpu: easeBackInOutGPU,\n      loop,\n      methodName: \"easeBackInOut\"\n    };\n  }\n\n  /**\n   * This is an easing method that performs a sinusoidal wave where the amplitude is\n   * (start - end) * 2 and the wave starts at the start value.\n   *\n   * This is intended to work best with the CONTINUOUS loop style.\n   */\n  static continuousSinusoidal<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.CONTINUOUS\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number) => {\n        const { add, length, scale, subtract } = VecMath(start);\n        t = clamp(t, 0, 1);\n        const direction = subtract(end, start);\n        const amplitude = length(direction) * 2.0;\n        return add(start, scale(direction, sin(t * PI * 2) * amplitude));\n      },\n      delay,\n      duration,\n      gpu: continuousSinusoidalGPU,\n      loop,\n      methodName: \"repeatingSinusoidal\",\n\n      // Since this is sinusoidial and operates off of a continuous time structure\n      validation: {\n        // When time = 1 our value will = start and NOT end\n        ignoreEndValueCheck: true,\n        // When the time is > 1 our value will not clamp to the value at 1.\n        ignoreOverTimeCheck: true\n      }\n    };\n  }\n\n  /** A uid for the easing method */\n  uid = uid();\n  /** The easing method for the cpu */\n  cpu: IAutoEasingMethod<T>[\"cpu\"];\n  /** Time before a delay  */\n  delay: number = 0;\n  /** The time in ms is takes to complete the animation */\n  duration: number = 500;\n  /** The easing method on the GPU */\n  gpu: IAutoEasingMethod<T>[\"gpu\"];\n  /** The looping style of the animation */\n  loop = AutoEasingLoopStyle.NONE;\n  /** Method name of the ease function on the gpu */\n  methodName: string;\n\n  constructor(\n    cpu: IAutoEasingMethod<T>[\"cpu\"],\n    gpu: IAutoEasingMethod<T>[\"gpu\"],\n    duration?: number,\n    method?: string\n  ) {\n    this.cpu = cpu;\n    this.gpu = gpu;\n    this.duration = duration || 500;\n    this.methodName = method || \"easingMethod\";\n  }\n}\n","import * as Three from \"three\";\nimport { IMaterialOptions } from \"../types\";\n\nexport class CommonMaterialOptions {\n  static transparentShape: IMaterialOptions = {\n    premultipliedAlpha: false,\n    transparent: true\n  };\n\n  static transparentImage: IMaterialOptions = {\n    blending: Three.CustomBlending,\n    blendSrc: Three.OneFactor,\n    premultipliedAlpha: true,\n    transparent: true\n  };\n}\n","import { IEasingProps } from \"../types\";\nimport { Vec } from \"./vector\";\n\n/**\n * This object represents the data associated with easing. It provides the\n * information needed to make an easing equation execute to completion. It also\n * contains a few methods to aid in properly adjusting the easing values.\n */\nexport class EasingProps implements IEasingProps {\n  delay: number = 0;\n  duration: number;\n  end: Vec;\n  isManualStart = false;\n  isTimeSet = false;\n  start: Vec;\n  startTime: number;\n\n  constructor(options: IEasingProps) {\n    Object.assign(this, options);\n  }\n\n  /**\n   * If you manually set values for the easing properties, then you use this to return\n   * the easing object back to an automated state which is where the start value is\n   * the calculated current position of the output and the delay and duration is determined\n   * by the easing set to the layer's IAutomatedEasingMethod value set to the layer.\n   */\n  setAutomatic() {\n    this.isManualStart = false;\n    this.isTimeSet = false;\n  }\n\n  /**\n   * This controls the start value of the easing. This should be used to force a starting\n   * value of the animation.\n   *\n   * Use setAutomatic() to return to default easing behavior.\n   */\n  setStart(start?: Vec) {\n    if (start) {\n      if (this.start.length !== start.length) {\n        console.warn(\n          \"A manual easing adjustment provided an incompatible value for the easing type.\"\n        );\n      } else {\n        this.start = start;\n        this.isManualStart = true;\n      }\n    }\n  }\n\n  /**\n   * This controls of the timing of the easing equation. This should be used to adjust\n   * when a value is to be adjusted\n   *\n   * Use setAutomatic() to return to default easing behavior.\n   */\n  setTiming(delay?: number, duration?: number) {\n    this.delay = delay === undefined ? this.delay : delay;\n    this.duration = duration === undefined ? this.duration : duration;\n    this.isTimeSet = true;\n  }\n}\n","module.exports = \"void main() {\\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n\"","module.exports = \"void main() {\\n  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n}\\n\"","import { ShaderInjectionTarget } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\nShaderModule.register([\n  {\n    moduleId: \"no-op\",\n    content: require(\"./shader-fragments/no-op.vs\"),\n    compatibility: ShaderInjectionTarget.VERTEX\n  },\n  {\n    moduleId: \"no-op\",\n    content: require(\"./shader-fragments/no-op.fs\"),\n    compatibility: ShaderInjectionTarget.FRAGMENT\n  }\n]);\n","module.exports = \"lowp vec4 setColor(vec4 color) {\\n  gl_FragColor = color;\\n  return gl_FragColor;\\n}\\n\"","module.exports = \"\\n\"","module.exports = \"// This contains the method required to be used on a fragment shader when a layer desires to use\\n// PickType.SINGLE (color picking).\\nvarying vec4 _picking_color_pass_;\\n\\nlowp vec4 setColor(vec4 color) {\\n  gl_FragColor = mix(color, _picking_color_pass_, pickingActive);\\n\\n  if (color.a == 0.0) {\\n    discard;\\n  }\\n\\n  return gl_FragColor;\\n}\\n\"","module.exports = \"// This is the varying auto generated for the fragment shader that is needed in the vertex shader to pass the\\n// color for the instance through to the fragment shader\\nvarying vec4 _picking_color_pass_;\\n\"","import { Layer } from \"../../surface/layer\";\nimport {\n  InstanceAttributeSize,\n  PickType,\n  ShaderInjectionTarget,\n  UniformSize\n} from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\nShaderModule.register([\n  {\n    moduleId: \"picking\",\n    content: require(\"./shader-fragments/picking.vs\"),\n    compatibility: ShaderInjectionTarget.VERTEX,\n\n    instanceAttributes: (_layer: Layer<any, any>) => [\n      {\n        name: \"_pickingColor\",\n        size: InstanceAttributeSize.FOUR,\n        update: o => {\n          // We start from white and move down so the colors are more visible\n          // For debugging\n          const color = 0xffffff - o.uid;\n\n          // Do bit maths do get float components out of the int color\n          return [\n            (color >> 16) / 255.0,\n            ((color & 0x00ff00) >> 8) / 255.0,\n            (color & 0x0000ff) / 255.0,\n            1\n          ];\n        }\n      }\n    ],\n\n    uniforms: layer => [\n      {\n        name: \"pickingActive\",\n        shaderInjection: ShaderInjectionTarget.ALL,\n        size: UniformSize.ONE,\n        update: () => [\n          layer.picking.currentPickMode === PickType.SINGLE ? 1.0 : 0.0\n        ]\n      }\n    ]\n  },\n  {\n    moduleId: \"picking\",\n    content: require(\"./shader-fragments/picking.fs\"),\n    compatibility: ShaderInjectionTarget.FRAGMENT\n  },\n  {\n    moduleId: \"no-picking\",\n    content: require(\"./shader-fragments/no-picking.vs\"),\n    compatibility: ShaderInjectionTarget.VERTEX\n  },\n  {\n    moduleId: \"no-picking\",\n    content: require(\"./shader-fragments/no-picking.fs\"),\n    compatibility: ShaderInjectionTarget.FRAGMENT\n  }\n]);\n","module.exports = \"${import: PI, PI2}\\n\\n/**\\n * This is an approximation of sin that allows us to bypass hardware precision\\n * limitations for sin.\\n *\\n * http://lab.polygonal.de/2007/07/18/fast-and-accurate-sinecosine-approximation/\\n * This is a GPU adaptation of this method to provide optimal GPU performance for the operation\\n */\\nfloat fsin(float x) {\\n  float sine;\\n\\n  // Always wrap input angle to -PI..PI\\n  x += mix(\\n    mix(\\n      0.0,\\n      -PI2, float(x > PI)\\n    ),\\n    PI2, float(x < -PI)\\n  );\\n\\n  // Compute sine\\n  sine = 1.27323954 * x;\\n  sine += mix(-1.0, 1.0, float(x < 0.0)) * 0.405284735 * x * x;\\n  sine = 0.225 * (sine * (mix(1.0, -1.0, float(sine < 0.0)) * sine) - sine) + sine;\\n\\n  return sine;\\n}\\n\"","module.exports = \"${import: PI, PI2, PI_2}\\n\\n/**\\n * This is an approximation of cos that allows us to bypass hardware precision\\n * limitations for cos.\\n *\\n * http://lab.polygonal.de/2007/07/18/fast-and-accurate-sinecosine-approximation/\\n * This is a GPU adaptation of this method to provide optimal GPU performance for the operation\\n */\\nfloat fcos(float x) {\\n  float sine;\\n  // Cos is the same as sine but\\n  x += PI_2;\\n\\n  // Always wrap input angle to -PI..PI\\n  x += mix(\\n    mix(\\n      0.0,\\n      -PI2, float(x > PI)\\n    ),\\n    PI2, float(x < -PI)\\n  );\\n\\n  // Compute sine\\n  sine = 1.27323954 * x;\\n  sine += mix(-1.0, 1.0, float(x < 0.0)) * 0.405284735 * x * x;\\n  sine = 0.225 * (sine * (mix(1.0, -1.0, float(sine < 0.0)) * sine) - sine) + sine;\\n\\n  return sine;\\n}\\n\"","module.exports = \"${import: fsin, fcos}\\n\\n/**\\n * A circular arc interpolator\\n */\\nvec2 circularArc(float t, vec2 center, float radius, float start, float end) {\\n  float angle = (end - start) * t + start;\\n  return center + vec2(fcos(angle) * radius, fsin(angle) * radius);\\n}\\n\"","module.exports = \"/**\\n * Two control point bezier curve\\n */\\nvec2 bezier2(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {\\n  float t1 = 1.0 - t;\\n  return pow(t1, 3.0) * p1 + 3.0 * t * pow(t1, 2.0) * c1 + 3.0 * pow(t, 2.0) * t1 * c2 + pow(t, 3.0) * p2;\\n}\"","module.exports = \"/**\\n * Single control point bezier curve\\n */\\nvec2 bezier1(float t, vec2 p1, vec2 p2, vec2 c1) {\\n  return (1.0 - t) * (1.0 - t) * p1 + 2.0 * t * (1.0 - t) * c1 + t * t * p2;\\n}\\n\"","module.exports = \"float toRadians = 0.01745329252;\\n\"","module.exports = \"float toDegrees = 57.2957795131;\\n\"","module.exports = \"float PI2 = 6.2831853;\\n\"","module.exports = \"float PI = 3.14159265;\\n\"","module.exports = \"float PI_4 = 0.7853981634;\\n\"","module.exports = \"float PI_2 = 1.5707963268;\\n\"","import { ShaderInjectionTarget } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\n// All of the constants fragments\nconst constants = [\n  {\n    moduleId: \"PI_2\",\n    content: require(\"./shader-fragments/constants/pi_2.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"PI_4\",\n    content: require(\"./shader-fragments/constants/pi_4.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"PI\",\n    content: require(\"./shader-fragments/constants/pi.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"PI2\",\n    content: require(\"./shader-fragments/constants/pi2.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"toDegrees\",\n    content: require(\"./shader-fragments/constants/to-degrees.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"toRadians\",\n    content: require(\"./shader-fragments/constants/to-radians.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  }\n];\n\n// A bin import that let's you add all common constants to your shader\nconst allConstants = {\n  moduleId: \"constants\",\n  content: `$\\{import: ${constants.map(c => c.moduleId).join(\", \")}}`,\n  compatibility: ShaderInjectionTarget.ALL\n};\n\n// All of the mathematical methods\nconst methods = [\n  {\n    moduleId: \"bezier1\",\n    content: require(\"./shader-fragments/bezier1.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"bezier2\",\n    content: require(\"./shader-fragments/bezier2.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"circularArc\",\n    content: require(\"./shader-fragments/circular-arc.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"fcos\",\n    content: require(\"./shader-fragments/fcos.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"fsin\",\n    content: require(\"./shader-fragments/fsin.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  }\n];\n\n// Register all modules\nShaderModule.register([...methods, ...constants, allConstants]);\n","import { LayerBufferType } from \"../../surface/layer-processing/layer-buffer-type\";\nimport {\n  IInstanceAttribute,\n  InstanceAttributeSize,\n  ShaderInjectionTarget,\n  VertexAttributeSize\n} from \"../../types\";\nimport { Instance } from \"../../util\";\nimport { ShaderModule } from \"../processing\";\n\n/**\n * This module contains the basic needs required to facilitate instancing for our shaders\n */\nShaderModule.register({\n  moduleId: \"instancing\",\n  content: \"\",\n  compatibility: ShaderInjectionTarget.ALL,\n\n  instanceAttributes: layer => {\n    // This is injected so the system can control when an instance should not be rendered.\n    // This allows for holes to be in the buffer without having to correct them immediately\n    const activeAttribute: IInstanceAttribute<Instance> = {\n      name: \"_active\",\n      size: InstanceAttributeSize.ONE,\n      update: o => [o.active ? 1 : 0]\n    };\n\n    // Set the active attribute to the layer for quick reference\n    layer.activeAttribute = activeAttribute;\n\n    return [activeAttribute];\n  },\n\n  vertexAttributes: layer => {\n    // Only the uniform buffering strategy requires instance information in it's vertex attributes\n    if (layer.bufferType === LayerBufferType.UNIFORM) {\n      return [\n        // We add an inherent instance attribute to our vertices so they can determine the instancing\n        // Data to retrieve.\n        {\n          name: \"instance\",\n          size: VertexAttributeSize.ONE,\n          // We no op this as our geometry generating routine will establish the values needed here\n          update: () => [0]\n        }\n      ];\n    }\n\n    return [];\n  }\n});\n","import { Layer } from \"../../surface/layer\";\nimport { ShaderInjectionTarget, UniformSize } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\n/**\n * This module provides uniforms for retrieving camera propeerties within the shader.\n */\nShaderModule.register({\n  moduleId: \"frame\",\n  content: \"\",\n  compatibility: ShaderInjectionTarget.ALL,\n  uniforms: (layer: Layer<any, any>) => [\n    // This will be the current frame's current time which is updated in the layer's surface draw call\n    {\n      name: \"currentTime\",\n      size: UniformSize.ONE,\n      update: () => [layer.surface.frameMetrics.currentTime]\n    }\n  ]\n});\n","module.exports = \"// These are projection methods utilizing the simpler camera breakdown approach\\n${import: camera}\\n\\nvec3 cameraSpace(vec3 world) {\\n  return (world + cameraOffset) * cameraScale;\\n}\\n\\nvec3 cameraSpaceSize(vec3 worldSize) {\\n  return worldSize * cameraScale;\\n}\\n\\nvec4 clipSpace(vec3 world) {\\n  return vec4(((projection * modelView) * vec4(cameraSpace(world), 1.0)).xyz, 1.0);\\n}\\n\\nvec4 clipSpaceSize(vec3 worldSize) {\\n  return vec4(((projection * modelView) * vec4(cameraSpaceSize(worldSize), 0.0)).xyz, 1.0);\\n}\\n\"","import { Layer } from \"../../surface/layer\";\nimport { ShaderInjectionTarget, UniformSize } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\n/**\n * This module provides uniforms for retrieving camera propeerties within the shader.\n */\nShaderModule.register([\n  {\n    moduleId: \"camera\",\n    content: \"\",\n    compatibility: ShaderInjectionTarget.ALL,\n    uniforms: (layer: Layer<any, any>) => [\n      // This injects the projection matrix from the view camera\n      {\n        name: \"projection\",\n        size: UniformSize.MATRIX4,\n        update: () => layer.view.viewCamera.baseCamera.projectionMatrix.elements\n      },\n      // This injects the model view matrix from the view camera\n      {\n        name: \"modelView\",\n        size: UniformSize.MATRIX4,\n        update: () => layer.view.viewCamera.baseCamera.matrix.elements\n      },\n      // This injects the camera offset uniforms that need to be present for projecting in a more\n      // Chart centric style\n      {\n        name: \"cameraOffset\",\n        size: UniformSize.THREE,\n        update: () => layer.view.camera.offset\n      },\n      // This injects the camera scaling uniforms that need to be present for projecting in a more\n      // Chart centric style\n      {\n        name: \"cameraScale\",\n        size: UniformSize.THREE,\n        update: () => layer.view.camera.scale\n      },\n      // This injects the camera scaling uniforms that need to be present for projecting in a more\n      // Chart centric style\n      {\n        name: \"viewSize\",\n        size: UniformSize.TWO,\n        update: () => [\n          layer.view.viewBounds.width,\n          layer.view.viewBounds.height\n        ]\n      },\n      // This injects the current layer's pixel ratio so pixel ratio dependent items can react to it\n      // Things like gl_PointSize will need this metric if not working in clip space\n      {\n        name: \"pixelRatio\",\n        size: UniformSize.ONE,\n        update: () => [layer.view.pixelRatio]\n      }\n    ]\n  },\n  {\n    moduleId: \"projection\",\n    content: require(\"./shader-fragments/projection.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  }\n]);\n","import \"./camera-metrics\";\nimport \"./frame-metrics\";\nimport \"./instancing\";\nimport \"./math-modules\";\nimport \"./picking\";\nimport \"./util-modules\";\n","import \"./base-modules\";\nexport * from \"./util/extend-shader\";\n","import * as Three from \"three\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport { InstanceIOValue } from \"../../types\";\nimport { ILayerProps, Layer } from \"../layer\";\nimport { AtlasManager, AtlasResource } from \"./atlas-manager\";\nimport { LabelAtlasResource } from \"./label-atlas-resource\";\nimport { SubTexture } from \"./sub-texture\";\n\nexport interface IAtlasResourceManagerOptions {\n  /** This is the atlas manager that handles operations with our atlas' */\n  atlasManager: AtlasManager;\n}\n\nfunction toInstanceIOValue(texture?: SubTexture): InstanceIOValue {\n  // If the texture is not defined we just output an empty reference\n  if (!texture) {\n    return [0, 0, 0, 0];\n  }\n\n  // Otherwise, we return the atlas information of the texture\n  return [\n    texture.atlasTL[0],\n    texture.atlasTL[1],\n    texture.atlasBR[0],\n    texture.atlasBR[1]\n  ];\n}\n\n/**\n * This class is responsible for tracking resources requested to be placed on an Atlas.\n * This makes sure the resource is uploaded and then properly cached so similar requests\n * return already existing resources. This also manages instances waiting for the resource\n * to be made available.\n */\nexport class AtlasResourceManager {\n  /** This is the atlas manager that handles operations with our atlas' */\n  atlasManager: AtlasManager;\n  /** This is the atlas currently targetted by requests */\n  targetAtlas: string = \"\";\n  /** This stores all of the requests awaiting dequeueing */\n  private requestQueue = new Map<string, AtlasResource[]>();\n  /**\n   * This tracks if a resource is already in the request queue. This also stores ALL instances awaiting the resource.\n   */\n  private requestLookup = new Map<\n    string,\n    Map<AtlasResource, [Layer<any, any>, Instance][]>\n  >();\n\n  constructor(options: IAtlasResourceManagerOptions) {\n    this.atlasManager = options.atlasManager;\n  }\n\n  /**\n   * This dequeues all instance requests for a resource and processes the request which will\n   * inevitably make the instance active\n   */\n  async dequeueRequests() {\n    // This flag will be modified to reflect if a dequeue operation has occurred\n    let didDequeue = false;\n\n    for (const [targetAtlas, resources] of Array.from(\n      this.requestQueue.entries()\n    )) {\n      if (resources.length > 0) {\n        // We did dequeue\n        didDequeue = true;\n        // Pull out all of the requests into a new array and empty the existing queue to allow the queue to register\n        // New requests while this dequeue is being processed\n        const requests = resources.slice(0);\n        // Empty the queue to begin taking in new requests as needed\n        resources.length = 0;\n\n        // Tell the atlas manager to update with all of the requested resources\n        await this.atlasManager.updateAtlas(targetAtlas, requests);\n        // Get the requests for the given atlas\n        const atlasRequests = this.requestLookup.get(targetAtlas);\n\n        if (atlasRequests) {\n          // Once the manager has been updated, we can now flag all of the instances waiting for the resources\n          // As active, which should thus trigger an update to the layers to perform a diff for each instance\n          requests.forEach(resource => {\n            const request = atlasRequests.get(resource);\n            atlasRequests.delete(resource);\n\n            if (request) {\n              for (let i = 0, iMax = request.length; i < iMax; ++i) {\n                const [layer, instance] = request[i];\n                // If the instance is still associated with buffer locations, then the instance can be activated. Having\n                // A buffer location is indicative the instance has not been deleted.\n                if (layer.bufferManager.getBufferLocations(instance)) {\n                  // Make sure the instance is active\n                  instance.active = true;\n                }\n              }\n\n              // Do a delay to next frame before we do our resource trigger so we can see any lingering updates get\n              // applied to the instance's rendering\n              requestAnimationFrame(() => {\n                for (let i = 0, iMax = request.length; i < iMax; ++i) {\n                  const instance = request[i][1];\n                  instance.resourceTrigger();\n                }\n              });\n            }\n          });\n        }\n      }\n    }\n\n    return didDequeue;\n  }\n\n  /**\n   * Free ALL resources managed under this resource manager\n   */\n  destroy() {\n    this.atlasManager.destroy();\n  }\n\n  /**\n   * This retrieves the actual atlas texture that should be applied to a uniform's\n   * value.\n   */\n  getAtlasTexture(key: string): Three.Texture | null {\n    const atlas = this.atlasManager.getAtlasTexture(key);\n\n    if (atlas) {\n      return atlas.texture;\n    }\n\n    return null;\n  }\n\n  /**\n   * This is a request for atlas texture resources. It will produce either the coordinates needed to\n   * make valid texture lookups, or it will trigger a loading of resources to an atlas and cause an\n   * automated deactivation and reactivation of the instance.\n   */\n  request<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>,\n    instance: Instance,\n    resource: AtlasResource\n  ): InstanceIOValue {\n    const texture: SubTexture = resource.texture;\n\n    // If the texture is ready and available, then we simply return the IO values\n    if (texture) {\n      return toInstanceIOValue(texture);\n    }\n\n    if (resource instanceof LabelAtlasResource) {\n      if (!resource.label.text) {\n        return toInstanceIOValue(texture);\n      }\n    }\n\n    // If a request is already made, then we must save the instance making the request for deactivation and\n    // Reactivation but without any additional atlas loading\n    let atlasRequests = this.requestLookup.get(this.targetAtlas);\n\n    if (atlasRequests) {\n      const existingRequests = atlasRequests.get(resource);\n\n      if (existingRequests) {\n        existingRequests.push([layer, instance]);\n        instance.active = false;\n\n        return toInstanceIOValue(texture);\n      }\n    } else {\n      atlasRequests = new Map();\n      this.requestLookup.set(this.targetAtlas, atlasRequests);\n    }\n\n    // If the texture is not available, then we must load the resource, deactivate the instance\n    // And wait for the resource to become available. Once the resource is available, the system\n    // Must activate the instance to render the resource.\n    instance.active = false;\n    let requests = this.requestQueue.get(this.targetAtlas);\n\n    if (!requests) {\n      requests = [];\n      this.requestQueue.set(this.targetAtlas, requests);\n    }\n\n    requests.push(resource);\n    atlasRequests.set(resource, [[layer, instance]]);\n\n    // This returns essentially returns blank values for the resource lookup\n    return toInstanceIOValue(texture);\n  }\n\n  /**\n   * This is used by the system to target the correct atlas for subsequent requests to a resource.\n   */\n  setTargetAtlas(target: string) {\n    this.targetAtlas = target;\n  }\n}\n","import { Bounds } from \"../primitives/bounds\";\nimport { isVec2, Vec2 } from \"./vector\";\n\n// A configuration that controls how readily a quadtree will split to another level\n// Adjusting this number can improve or degrade your performance significantly and\n// Must be tested for specific use cases\nconst maxPopulation: number = 5;\nconst maxDepth: number = 10;\n\nexport interface IQuadItem {\n  area: number;\n  bottom: number;\n  height: number;\n  left: number;\n  location: Vec2;\n  mid: Vec2;\n  right: number;\n  top: number;\n  width: number;\n  x: number;\n  y: number;\n\n  containsPoint(point: Vec2): boolean;\n  encapsulate(item: IQuadItem): boolean;\n  fits(item: IQuadItem): 0 | 1 | 2;\n  hitBounds(item: IQuadItem): boolean;\n  isInside(item: IQuadItem): boolean;\n}\n\n/**\n * This filters a quad tree query by type\n *\n * @export\n * @template T\n */\nexport function filterQuery<T extends IQuadItem>(\n  type: Function[],\n  queryValues: IQuadItem[]\n): T[] {\n  const filtered: T[] = [];\n\n  queryValues.forEach((obj: IQuadItem) => {\n    if (type.find(t => obj instanceof t)) {\n      filtered.push(obj as T);\n    }\n  });\n\n  return filtered;\n}\n\n/**\n * Allows typing of a callback argument\n */\nexport interface IVisitFunction<T extends IQuadItem> {\n  /**\n   * A callback to use during add or query\n   *\n   * Called do provide aggregation or filtering like Array.reduce or\n   * Array.filter, but in a QuadTree instead.\n   *\n   * @param node  The node to effect the function upon\n   * @param child The child to add to the node\n   */\n  (node: Node<T>, child?: IQuadItem): void;\n}\n\n/**\n * This is a class used specifically by the quad tree nodes to indicate split space\n * within the quad tree.\n *\n * @class Quadrants\n */\nexport class Quadrants<T extends IQuadItem> {\n  TL: Node<T>;\n  TR: Node<T>;\n  BL: Node<T>;\n  BR: Node<T>;\n\n  /**\n   * Ensures all memory is released for all nodes and all references are removed\n   * to potentially high memory consumption items\n   *\n   * @memberOf Quadrants\n   */\n  destroy() {\n    this.TL.destroy();\n    this.TR.destroy();\n    this.BL.destroy();\n    this.BR.destroy();\n    delete this.TL;\n    delete this.TR;\n    delete this.BL;\n    delete this.BR;\n  }\n\n  /**\n   * Creates an instance of Quadrants.\n   *\n   * @param bounds The bounds this will create quandrants for\n   * @param depth  The child depth of this element\n   *\n   * @memberOf Quadrants\n   */\n  constructor(bounds: IQuadItem, depth: number) {\n    const mid = bounds.mid;\n    this.TL = new Node<T>(bounds.x, mid[0], bounds.y, mid[1], depth);\n    this.TR = new Node<T>(mid[0], bounds.right, bounds.y, mid[1], depth);\n    this.BL = new Node<T>(bounds.x, mid[0], mid[1], bounds.bottom, depth);\n    this.BR = new Node<T>(mid[0], bounds.right, mid[1], bounds.bottom, depth);\n  }\n}\n\n/**\n * The quad tree node. This Node will take in a certain population before dividing itself into\n * 4 quadrants which it will attempt to inject it's population into. If a member of the population\n * does not completely get injected into one of the quadrants it remains as a member of this node.\n *\n * @export\n * @class Node\n */\nexport class Node<T extends IQuadItem> {\n  bounds: Bounds;\n  children: T[] = [];\n  depth: number = 0;\n  nodes: Quadrants<T>;\n\n  /**\n   * Destroys this node and ensures all child nodes are destroyed as well.\n   *\n   * @memberOf Node\n   */\n  destroy() {\n    delete this.children;\n    delete this.bounds;\n\n    if (this.nodes) {\n      this.nodes.destroy();\n      delete this.nodes;\n    }\n  }\n\n  /**\n   * Creates an instance of Node.\n   *\n   * @param l     The bounding left wall of the space this node covers\n   * @param r     The bounding right wall of the space this node covers\n   * @param t     The bounding top wall of the space this node covers\n   * @param b     The bounding bottom wall of the space this node covers\n   * @param depth The depth within the quad tree this node resides\n   *\n   * @memberOf Node\n   */\n  constructor(\n    left: number,\n    right: number,\n    top: number,\n    bottom: number,\n    depth?: number\n  ) {\n    // If params insertted\n    if (arguments.length >= 4) {\n      this.bounds = new Bounds({\n        height: top - bottom,\n        width: right - left,\n        x: left,\n        y: top\n      });\n    } else {\n      // Otherwise, make tiny start area\n      this.bounds = new Bounds({\n        height: 1,\n        width: 1,\n        x: 0,\n        y: 0\n      });\n    }\n\n    // Ensure the depth is set\n    this.depth = depth || 0;\n  }\n\n  /**\n   * Adds an object that extends Bounds (or is Bounds) and properly injects it into this node\n   * or into a sub quadrant if this node is split already. If the child is outside the boundaries\n   * this quad tree spans (and this is the root node), the quad tree will expand to include\n   * the new child.\n   *\n   * @param child The Bounds type object to inject\n   * @param props Properties that can be retrieved with the child object if applicable\n   *\n   * @returns True if the insertion was successful\n   *\n   * @memberOf Node\n   */\n  add(child: T, props: any): boolean {\n    // This is the entry function for adding children, so we must first expand our top node\n    // To cover the area that the child is located.\n    // If we're in bounds, then let's just add the child\n    if (child.isInside(this.bounds)) {\n      return this.doAdd(child);\n    } else {\n      // Otherwise, we need to expand first\n      this.cover(child);\n      return this.add(child, props);\n    }\n  }\n\n  /**\n   * Adds a list of new children to this quad tree. It performs the same operations as\n   * addChild for each child in the list, however, it more efficiently recalculates the\n   * bounds necessary to cover the area the children cover.\n   *\n   * @param children      List of Bounds objects to inject\n   * @param childrenProps List of props to associate with each element\n   *\n   * @memberOf Node\n   */\n  addAll(children: T[], childrenProps?: any[]) {\n    // Ensure the properties are at least defined\n    childrenProps = childrenProps || [];\n\n    // Make sure we cover the entire area of all the children.\n    // We can speed this up a lot if we first calculate the total bounds the new children covers\n    let minX = Number.MAX_VALUE;\n    let minY = Number.MAX_VALUE;\n    let maxX = -Number.MAX_VALUE;\n    let maxY = -Number.MAX_VALUE;\n\n    // Get the dimensions of the new bounds\n    children.forEach(child => {\n      if (child.x < minX) {\n        minX = child.x;\n      }\n      if (child.right > maxX) {\n        maxX = child.right;\n      }\n      if (child.bottom > maxY) {\n        maxY = child.bottom;\n      }\n      if (child.y < minY) {\n        minY = child.y;\n      }\n    });\n\n    // Make sure our bounds includes the specified bounds\n    this.cover(\n      new Bounds({\n        height: maxY - minY,\n        width: maxX - minX,\n        x: minX,\n        y: minY\n      })\n    );\n\n    // Add all of the children into the tree\n    children.forEach(child => this.doAdd(child));\n  }\n\n  /**\n   * Ensures this quad tree includes the bounds specified in it's spatial coverage.\n   * This will cause all children to be re-injected into the tree.\n   *\n   * @param bounds The bounds to include in the tree's coverage\n   *\n   * @memberOf Node\n   */\n  cover(bounds: IQuadItem) {\n    // If we are already covering the area: abort\n    if (bounds.isInside(this.bounds)) {\n      return;\n    }\n\n    // Make our bounds cover the new area\n    this.bounds.encapsulate(bounds);\n    this.bounds.x -= 1;\n    this.bounds.y -= 1;\n    this.bounds.width += 2;\n    this.bounds.height += 4;\n    // Get all of the children underneath this node\n    const allChildren = this.gatherChildren([]);\n\n    // Destroy the split nodes\n    if (this.nodes) {\n      // Completely...destroy...\n      this.nodes.destroy();\n      delete this.nodes;\n    }\n\n    // Reinsert all children with the new dimensions in place\n    allChildren.forEach(child => this.doAdd(child));\n  }\n\n  /**\n   * When adding children, this performs the actual action of injecting the child into the tree\n   * without the process of seeing if the tree needs a spatial adjustment to account for the child.\n   *\n   * @param child The Bounds item to inject into the tree\n   * @param props The props to remain associated with the child\n   *\n   * @returns True if the injection was successful\n   *\n   * @memberOf Node\n   */\n  doAdd(child: T): boolean {\n    // If nodes are present, then we have already exceeded the population of this node\n    if (this.nodes) {\n      if (child.isInside(this.nodes.TL.bounds)) {\n        return this.nodes.TL.doAdd(child);\n      }\n\n      if (child.isInside(this.nodes.TR.bounds)) {\n        return this.nodes.TR.doAdd(child);\n      }\n\n      if (child.isInside(this.nodes.BL.bounds)) {\n        return this.nodes.BL.doAdd(child);\n      }\n\n      if (child.isInside(this.nodes.BR.bounds)) {\n        return this.nodes.BR.doAdd(child);\n      }\n\n      // Otherwise, this is a child overlapping this border\n      this.children.push(child);\n\n      return true;\n    } else if (child.isInside(this.bounds)) {\n      // Otherwise, we have not had a split due to population limits being exceeded\n      this.children.push(child);\n\n      // If we exceeded our population for this quadrant, it is time to split up\n      if (this.children.length > maxPopulation && this.depth < maxDepth) {\n        this.split();\n      }\n\n      return true;\n    }\n\n    // This is when there is something wrong with the insertted child. The bounds\n    // For the quad should have grown without issue, but in this case the bounds\n    // Could not grow to accomodate the child.\n    if (isNaN(child.width + child.height + child.x + child.y)) {\n      console.error(\n        \"Child did not fit into bounds because a dimension is NaN\",\n        child\n      );\n    } else if (child.area === 0) {\n      console.error(\n        \"Child did not fit into bounds because the area is zero\",\n        child\n      );\n    }\n\n    // Don't insert the child and continue\n    return true;\n  }\n\n  /**\n   * Collects all children of all the current and sub nodes into a single list.\n   *\n   * @param list The list we must aggregate children into\n   *\n   * @return The list specified as the list parameter\n   */\n  gatherChildren(list: T[]): T[] {\n    list = list.concat(this.children);\n\n    if (this.nodes) {\n      this.nodes.TL.gatherChildren(list);\n      this.nodes.TR.gatherChildren(list);\n      this.nodes.BL.gatherChildren(list);\n      this.nodes.BR.gatherChildren(list);\n    }\n\n    return list;\n  }\n\n  /**\n   * Entry query for determining query type based on input object\n   *\n   * @param bounds Can be a Bounds or a Point object\n   * @param visit  A callback function that will receive the Node as it is analyzed. This gives\n   *               information on a spatial scale, how a query reaches it's target intersections.\n   *\n   * @return An array of children that intersects with the query\n   */\n  query(bounds: IQuadItem | Vec2, visit?: IVisitFunction<T>): T[] {\n    // Query a rectangle\n    if (bounds instanceof Bounds) {\n      if (bounds.hitBounds(this.bounds)) {\n        return this.queryBounds(bounds, [], visit);\n      }\n\n      // Return an empty array when nothing is collided with\n      return [];\n    } else if (isVec2(bounds)) {\n      // Query a point\n      if (this.bounds.containsPoint(bounds)) {\n        return this.queryPoint(bounds, [], visit);\n      }\n    }\n\n    // Return an empty array when nothing is collided with\n    return [];\n  }\n\n  /**\n   * Queries children for intersection with a bounds object\n   *\n   * @param b     The Bounds to test children against\n   * @param list  The list of children to aggregate into the query\n   * @param visit A callback function that will receive the Node as it is analyzed. This gives\n   *              information on a spatial scale, how a query reaches it's target intersections.\n   *\n   * @return     Returns the exact same list that was input as the list param\n   */\n  queryBounds(b: IQuadItem, list: T[], visit?: IVisitFunction<T>): T[] {\n    this.children.forEach(c => {\n      if (c.hitBounds(b)) {\n        list.push(c);\n      }\n    });\n\n    if (visit) {\n      visit(this);\n    }\n\n    if (this.nodes) {\n      if (b.hitBounds(this.nodes.TL.bounds)) {\n        this.nodes.TL.queryBounds(b, list, visit);\n      }\n\n      if (b.hitBounds(this.nodes.TR.bounds)) {\n        this.nodes.TR.queryBounds(b, list, visit);\n      }\n\n      if (b.hitBounds(this.nodes.BL.bounds)) {\n        this.nodes.BL.queryBounds(b, list, visit);\n      }\n\n      if (b.hitBounds(this.nodes.BR.bounds)) {\n        this.nodes.BR.queryBounds(b, list, visit);\n      }\n    }\n\n    return list;\n  }\n\n  /**\n   * Queries children for intersection with a point\n   *\n   * @param p     The Point to test children against\n   * @param list  The list of children to aggregate into the query\n   * @param visit A callback function that will receive the Node as it is analyzed. This gives\n   *              information on a spatial scale, how a query reaches it's target intersections.\n   *\n   * @return      Returns the exact same list that was input as the list param\n   */\n  queryPoint(p: any, list: T[], visit?: IVisitFunction<T>): T[] {\n    this.children.forEach(c => {\n      if (c.containsPoint(p)) {\n        list.push(c);\n      }\n    });\n\n    if (visit) {\n      visit(this);\n    }\n\n    if (this.nodes) {\n      if (this.nodes.TL.bounds.containsPoint(p)) {\n        this.nodes.TL.queryPoint(p, list, visit);\n      }\n\n      if (this.nodes.TR.bounds.containsPoint(p)) {\n        this.nodes.TR.queryPoint(p, list, visit);\n      }\n\n      if (this.nodes.BL.bounds.containsPoint(p)) {\n        this.nodes.BL.queryPoint(p, list, visit);\n      }\n\n      if (this.nodes.BR.bounds.containsPoint(p)) {\n        this.nodes.BR.queryPoint(p, list, visit);\n      }\n    }\n\n    return list;\n  }\n\n  /**\n   * Creates four sub quadrants for this node.\n   */\n  split() {\n    // Gather all items to be handed down\n    const allChildren = this.gatherChildren([]);\n    // Gather all props for the children to be handed down as well\n    this.nodes = new Quadrants<T>(this.bounds, this.depth + 1);\n\n    this.children = [];\n\n    while (allChildren.length > 0) {\n      const child = allChildren.pop();\n      if (child) this.doAdd(child);\n    }\n  }\n\n  /**\n   * Traverses the quad tree returning every quadrant encountered\n   *\n   * @param cb A callback that has the parameter (node) which is a quadrant in the tree\n   */\n  visit(cb: IVisitFunction<T>): void {\n    const finished = Boolean(cb(this));\n\n    if (this.nodes && !finished) {\n      this.nodes.TL.visit(cb);\n      this.nodes.TR.visit(cb);\n      this.nodes.BL.visit(cb);\n      this.nodes.BR.visit(cb);\n    }\n  }\n}\n\nexport class QuadTree<T extends IQuadItem> extends Node<T> {}\n","import { IProjection, PickType } from \"../../types\";\nimport { Vec2 } from \"../../util\";\nimport { EventManager } from \"../event-manager\";\nimport { Layer } from \"../layer\";\nimport { LayerSurface } from \"../layer-surface\";\nimport {\n  IDragMetrics,\n  IMouseInteraction,\n  SceneView\n} from \"../mouse-event-manager\";\n\nfunction isDefined<T>(val: T | null | undefined): val is T {\n  return Boolean(val);\n}\n\n/**\n * This class is an injected event manager for the surface, it specifically handles taking in mouse events intended for view interactions\n * and broadcasts them to the layers that have picking enabled, thus allowing the layers to respond to\n * mouse view locations and broadcast Instance interactions based on the interaction with the View the layer is a part of\n *\n * In Summary: This is an adapter that takes in interactions to the views and injects those events into the layers associated with\n * the views so that the layers can translate the events to gestures.\n */\nexport class LayerMouseEvents extends EventManager {\n  /** This tracks which views have the mouse over them so we can properly broadcast view is out events */\n  isOver = new Map<SceneView, boolean>();\n  /** This is the surface this manager is aiding with broadcasting events to layers */\n  sceneViews: SceneView[];\n  /**\n   * This is the surface this LayerMouseEvent Controller is operating on behalf of. We use this to trigger,\n   * pre-layer processing items, such as color pick narrowing prior to the Layers receiving the event.\n   */\n  surface: LayerSurface;\n\n  constructor(surface: LayerSurface) {\n    super();\n    this.surface = surface;\n    this.sceneViews = surface.sceneViews;\n  }\n\n  getSceneViewsUnderMouse(e: IMouseInteraction) {\n    const sceneViewByViewId = new Map<string, SceneView>();\n\n    // Map the scene views by the view's identifiers\n    for (const sceneView of this.sceneViews) {\n      sceneViewByViewId.set(sceneView.view.id, sceneView);\n    }\n\n    // Now retrieve and convert each view under the mouse to the scene view it coincides with\n    return e.viewsUnderMouse\n      .map(viewItem => sceneViewByViewId.get(viewItem.view.id))\n      .filter(isDefined);\n  }\n\n  getMouseByViewId(e: IMouseInteraction) {\n    // This is the mouse position for the provided view in view space\n    const viewMouseByViewId = new Map<string, Vec2>();\n\n    for (const viewItem of e.viewsUnderMouse) {\n      viewMouseByViewId.set(viewItem.view.id, viewItem.mouse);\n    }\n\n    return viewMouseByViewId;\n  }\n\n  handleClick(e: IMouseInteraction, button: number) {\n    this.handleInteraction(e, (layer, view, mouse) =>\n      layer.interactions.handleMouseClick(view, mouse, button)\n    );\n  }\n\n  handleDrag(e: IMouseInteraction, _drag: IDragMetrics) {\n    this.handleInteraction(e, (layer, view, mouse) =>\n      layer.interactions.handleMouseDrag(view, mouse)\n    );\n  }\n\n  handleInteraction(\n    e: IMouseInteraction,\n    callback: (layer: Layer<any, any>, view: IProjection, mouse: Vec2) => void\n  ) {\n    // Get all of the scenes under the mouse\n    const sceneViews = this.getSceneViewsUnderMouse(e);\n    // Get a lookup of a view id to the mouse position in the view\n    const viewMouseByViewId = this.getMouseByViewId(e);\n\n    // For every view of every scene, we must tell it's layers it's world space is receiving mouse interactions\n    for (const sceneView of sceneViews) {\n      this.handleSceneView(sceneView, viewMouseByViewId, callback);\n    }\n\n    return sceneViews;\n  }\n\n  handleMouseDown(e: IMouseInteraction, button: number) {\n    this.handleInteraction(e, (layer, view, mouse) =>\n      layer.interactions.handleMouseDown(view, mouse, button)\n    );\n  }\n\n  handleMouseUp(e: IMouseInteraction, button: number) {\n    this.handleInteraction(e, (layer, view, mouse) =>\n      layer.interactions.handleMouseUp(view, mouse, button)\n    );\n  }\n\n  handleMouseOver(_e: IMouseInteraction) {\n    // We let the mouse move event handle the registration of moused over views\n  }\n\n  handleMouseOut(e: IMouseInteraction) {\n    // Get a lookup of a view id to the mouse position in the view\n    const viewMouseByViewId = this.getMouseByViewId(e);\n    const screen = e.screen.mouse;\n\n    // All views that are moused over should no longer be considered over and broadcast a mouse out\n    this.isOver.forEach((_flag, sceneView) => {\n      // Since we are leaving the view we must make the view relative cooridinates fromt he screen space coords\n      viewMouseByViewId.set(\n        sceneView.view.id,\n        sceneView.view.screenToView(screen)\n      );\n\n      this.handleSceneView(sceneView, viewMouseByViewId, (layer, view, mouse) =>\n        layer.interactions.handleMouseOut(view, mouse)\n      );\n    });\n\n    // Nothing is over anymore\n    this.isOver.clear();\n  }\n\n  handleMouseMove(e: IMouseInteraction) {\n    if (this.surface) {\n      this.surface.updateColorPickRange(\n        e.screen.mouse,\n        e.viewsUnderMouse.map(v => v.view)\n      );\n    }\n\n    // Get all of the scenes we have interacted with, and broadcast a move event for each\n    const allSceneViews = this.handleInteraction(e, (layer, view, mouse) =>\n      layer.interactions.handleMouseMove(view, mouse)\n    );\n    // Get a lookup of a view id to the mouse position in the view\n    const viewMouseByViewId = this.getMouseByViewId(e);\n    // Get the position of the mouse on the screen\n    const screen = e.screen.mouse;\n\n    // For quick lookups map all of the current SceneViews that are over\n    const currentSceneViews = new Map<SceneView, boolean>();\n    allSceneViews.forEach(v => currentSceneViews.set(v, true));\n\n    // Detect which of the views are newly over\n    currentSceneViews.forEach((_flag, sceneView) => {\n      if (!this.isOver.get(sceneView)) {\n        this.handleSceneView(\n          sceneView,\n          viewMouseByViewId,\n          (layer, view, mouse) =>\n            layer.interactions.handleMouseOver(view, mouse)\n        );\n      }\n    });\n\n    // Detect which of the views are no longer over\n    this.isOver.forEach((_flag, sceneView) => {\n      if (!currentSceneViews.get(sceneView)) {\n        // Since these views were not interacted with, we must create the mouse interaction position\n        viewMouseByViewId.set(\n          sceneView.view.id,\n          sceneView.view.screenToView(screen)\n        );\n\n        this.handleSceneView(\n          sceneView,\n          viewMouseByViewId,\n          (layer, view, mouse) => layer.interactions.handleMouseOut(view, mouse)\n        );\n      }\n    });\n\n    // Update the current views that are over to the currently over views for next event\n    this.isOver = currentSceneViews;\n  }\n\n  handleSceneView(\n    sceneView: SceneView,\n    viewMouseByViewId: Map<string, Vec2>,\n    callback: (layer: Layer<any, any>, view: IProjection, mouse: Vec2) => void\n  ) {\n    const view = sceneView.view;\n    const mouse = viewMouseByViewId.get(view.id);\n\n    if (mouse) {\n      for (const layer of sceneView.scene.layers) {\n        if (layer.picking && layer.picking.type !== PickType.NONE) {\n          callback(layer, view, mouse);\n        }\n      }\n    }\n  }\n\n  handleWheel(_e: IMouseInteraction) {\n    // TODO: This may need to be implemented. As of right now, there is no particular benefit\n  }\n}\n","import { IColorPickingData } from \"../types\";\nimport { Vec2 } from \"./vector\";\n\n/**\n * This analyzes the rendered data for color picking and outputs the metrics and data needed\n * for the operation.\n */\nexport function analyzeColorPickingRendering(\n  mouse: Vec2,\n  data: Uint8Array,\n  width: number,\n  height: number\n) {\n  const pickingData: IColorPickingData = {\n    allColors: [],\n    colorData: data,\n    dataHeight: height,\n    dataWidth: width,\n    mouse,\n    nearestColor: 0\n  };\n\n  const uniqueColors = new Map<number, boolean>();\n  let pixelIndex = 0;\n  const colors: number[][] = [];\n  const mouseX: number = width / 2;\n  const mouseY: number = height / 2;\n\n  let nearestColor = 0x000000;\n  let distance = Number.MAX_SAFE_INTEGER;\n\n  for (let i = 0; i < height; ++i) {\n    const row: number[] = [];\n    colors.push(row);\n\n    for (let k = 0; k < width; ++k) {\n      const r = data[pixelIndex];\n      const g = data[pixelIndex + 1];\n      const b = data[pixelIndex + 2];\n      pixelIndex += 4;\n\n      const color = (r << 16) | (g << 8) | b;\n      uniqueColors.set(color, true);\n      row.push(color);\n\n      // If the color is not black, let's test the distance against currnet nearest color\n      if (color !== 0x000000) {\n        const dx = k - mouseX;\n        const dy = i - mouseY;\n        const testDistance = dx * dx + dy * dy;\n\n        if (testDistance < distance) {\n          distance = testDistance;\n          nearestColor = color;\n        }\n      }\n    }\n  }\n\n  // Apply all o fthe unique colors that were discovered within the rendering\n  pickingData.allColors = Array.from(uniqueColors.keys());\n  // The nearest color will be the element in the middle of the array of colors\n  pickingData.nearestColor = nearestColor;\n\n  return pickingData;\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport { IInstanceAttribute, IUniform } from \"../../types\";\nimport { WebGLStat } from \"../../util/webgl-stat\";\n\n/**\n * This handles processing some metrics that are commonly needed by other processors.\n */\nexport class MetricsProcessing {\n  /** This is an instance's max listed block */\n  instanceMaxBlock: number;\n  /** This is the number of blocks each instance will use */\n  blocksPerInstance: number;\n  /** This is how many uniform blocks the current device can utilize in a shader */\n  maxUniforms: number;\n  /** This reflects how many uniform blocks are available for instancing */\n  maxUniformsForInstancing: number;\n  /** Get the number of instances the client's system supports */\n  maxInstancesPerBuffer: number;\n  /** This is the total blocks to be used in our uniform buffer for handling instances */\n  totalInstanceUniformBlocks: number;\n\n  /**\n   * This calculates how many uniform blocks are utilized based on the input uniforms\n   */\n  static calculateUniformBlockUseage(uniforms: IUniform[]) {\n    let count = 0;\n\n    for (let i = 0, end = uniforms.length; i < end; ++i) {\n      count += Math.ceil(uniforms[i].size / 4);\n    }\n\n    return count;\n  }\n\n  /**\n   * Calculates all of the metrics that will be needed in this processor.\n   */\n  process<T extends Instance>(\n    instanceAttributes: IInstanceAttribute<T>[],\n    uniforms: IUniform[]\n  ) {\n    this.instanceMaxBlock = 0;\n\n    // First find the max block to be utilized\n    instanceAttributes.forEach(attribute => {\n      this.instanceMaxBlock = Math.max(\n        this.instanceMaxBlock,\n        attribute.block || 0\n      );\n    });\n\n    this.blocksPerInstance = this.instanceMaxBlock + 1;\n    this.maxUniforms = WebGLStat.MAX_VERTEX_UNIFORMS;\n    this.maxUniformsForInstancing =\n      this.maxUniforms -\n      MetricsProcessing.calculateUniformBlockUseage(uniforms);\n    this.maxInstancesPerBuffer = Math.floor(\n      this.maxUniformsForInstancing / this.blocksPerInstance\n    );\n    this.totalInstanceUniformBlocks =\n      this.maxInstancesPerBuffer * this.blocksPerInstance;\n  }\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport { IInstanceAttribute, InstanceAttributeSize } from \"../../types\";\nimport {\n  IShaderTemplateRequirements,\n  shaderTemplate\n} from \"../../util/shader-templating\";\nimport { templateVars } from \"../template-vars\";\n\n/** Converts a size to a shader type */\nconst sizeToType: { [key: number]: string } = {\n  1: \"float\",\n  2: \"vec2\",\n  3: \"vec3\",\n  4: \"vec4\",\n  9: \"mat3\",\n  16: \"mat4\",\n  99: \"sampler2D\"\n};\n\n/**\n * This processor deals with how easing and AutoEasingMethods work with the shaders.\n */\nexport class EasingProcessing {\n  /**\n   * This generates the methods needed from all of the auto easing methods and makes them\n   * injectable into our shader.\n   */\n  process<T extends Instance>(instanceAttributes: IInstanceAttribute<T>[]) {\n    const methods = new Map<string, Map<InstanceAttributeSize, string>>();\n    let out = \"// Auto Easing Methods specified by the layer\\n\";\n\n    // First dedupe the methods needed by their method name\n    instanceAttributes.forEach(attribute => {\n      if (attribute.easing && attribute.size) {\n        let methodSizes = methods.get(attribute.easing.methodName);\n\n        if (!methodSizes) {\n          methodSizes = new Map<InstanceAttributeSize, string>();\n          methods.set(attribute.easing.methodName, methodSizes);\n        }\n\n        methodSizes.set(attribute.size, attribute.easing.gpu);\n      }\n    });\n\n    if (methods.size === 0) {\n      return \"\";\n    }\n\n    const required: IShaderTemplateRequirements = {\n      name: \"Easing Method Generation\",\n      values: [templateVars.easingMethod]\n    };\n\n    // Now generate the full blown method for each element. We create overloaded methods for\n    // Each method name for each vector size required\n    methods.forEach(\n      (methodSizes: Map<InstanceAttributeSize, string>, methodName: string) => {\n        methodSizes.forEach((method, size) => {\n          const sizeType = sizeToType[size];\n\n          const templateOptions: { [key: string]: string } = {\n            [templateVars.easingMethod]: `${sizeType} ${methodName}(${sizeType} start, ${sizeType} end, float t)`,\n            [templateVars.T]: `${sizeType}`\n          };\n\n          const results = shaderTemplate({\n            options: templateOptions,\n            required,\n            shader: method\n          });\n\n          out += `${results.shader}\\n`;\n        });\n      }\n    );\n\n    return out;\n  }\n}\n","module.exports = \"\\n  // This is a special injected instance attribute. It lets the system\\n  // control specific instances ability to draw, which allows the backend\\n  // system greater control on how it optimizes draw calls and it's buffers.\\n  if (_active == 0.0) {\\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n\\n    // Quick exit to prevent any geometry from arising from the instance\\n    return;\\n  }\\n\"","import { Instance } from \"../../instance-provider/instance\";\nimport { ILayerProps, Layer } from \"../../surface/layer\";\nimport { LayerBufferType } from \"../../surface/layer-processing/layer-buffer-type\";\nimport {\n  IInstanceAttribute,\n  InstanceAttributeSize,\n  IVertexAttribute,\n  PickType\n} from \"../../types\";\nimport { AutoEasingLoopStyle } from \"../../util/auto-easing-method\";\nimport { getAttributeShaderName } from \"./formatting\";\nimport { MetricsProcessing } from \"./metrics-processing\";\nimport { UniformProcessing } from \"./uniform-processing\";\n\n/** Defines the elements for destructuring out of a vector */\nconst VECTOR_COMPONENTS = [\"x\", \"y\", \"z\", \"w\"];\n\n/** Converts a size to a shader type */\nconst sizeToType: { [key: number]: string } = {\n  1: \"float\",\n  2: \"vec2\",\n  3: \"vec3\",\n  4: \"vec4\",\n  9: \"mat3\",\n  16: \"mat4\",\n  /** This is the special case for instance attributes that want an atlas resource */\n  99: \"vec4\"\n};\n\n/**\n * This sorts attributes specific to how they need to be destructured. For example:\n * easing attributes MUST appear AFTER all of the specially integrated attributes that were generated\n * such as start times and durations.\n */\nfunction orderByPriority(\n  a: IInstanceAttribute<any>,\n  b: IInstanceAttribute<any>\n) {\n  if (a.easing && !b.easing) return 1;\n  return -1;\n}\n\n/**\n * This method properly provides a vector's chunk of data based on a swizzle. So a size of 2\n * provides vector.xy and a size of 4 provides vector.xyzw.\n */\nfunction makeVectorSwizzle(start: number, size: number) {\n  return VECTOR_COMPONENTS.slice(start, start + size).join(\"\");\n}\n\n/**\n * This object is responsible for generating how attributes are declared as input to the shader.\n */\nexport class AttributeProcessing {\n  private uniformProcessor: UniformProcessing;\n  private metricsProcessor: MetricsProcessing;\n\n  constructor(\n    uniformProcessor: UniformProcessing,\n    metricsProcessor: MetricsProcessing\n  ) {\n    this.metricsProcessor = metricsProcessor;\n    this.uniformProcessor = uniformProcessor;\n  }\n\n  /**\n   * Produces the chunk of code that establishes how a layer injects information into the shader.\n   */\n  process<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>,\n    vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<T>[]\n  ) {\n    return {\n      declarations: this.processDeclarations(\n        layer,\n        vertexAttributes,\n        instanceAttributes\n      ),\n      destructuring: this.processDestructuring(layer, instanceAttributes)\n    };\n  }\n\n  /**\n   * This processes the declarations needed to set up the Input for the shader from the layer.\n   */\n  private processDeclarations<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>,\n    vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<T>[]\n  ) {\n    let out = \"// Shader input\\n\";\n\n    // If we are in a uniform buffer type strategy. Then we generate a uniform buffer that will contain\n    // our instance attribute information along with some extras to help dereference from the buffer.\n    if (\n      layer.bufferType === LayerBufferType.UNIFORM &&\n      instanceAttributes.length > 0\n    ) {\n      out += this.uniformProcessor.generateUniformAttributePacking();\n    }\n\n    // Add in the vertex attributes input\n    out += this.processVertexAttributes(vertexAttributes);\n\n    // If we are in an instance attribute Buffer Type strategy, then we simply list out\n    // the attributes listed in our instance attributes as attributes.\n    if (\n      layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE &&\n      instanceAttributes.length > 0\n    ) {\n      out += this.processInstanceAttributeBufferStrategy(instanceAttributes);\n    }\n\n    // If we are in an instance attribute \"packing\" buffer type strategy, then the layer\n    // is expecting to have attributes that are \"blocks\" instead of explicitally named\n    // attributes. The layer will be utilizing the blocks to efficiently pack in our instance information\n    if (\n      layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE_PACKING &&\n      instanceAttributes.length > 0\n    ) {\n      out += this.processInstanceAttributePackingBufferStrategy(\n        this.metricsProcessor.instanceMaxBlock\n      );\n    }\n\n    return out;\n  }\n\n  /**\n   * This processes the layer and it's attributes to generate a Destructuring chunk that guarantees the attributes\n   * and special properties with the attributes are available based on the instance attributes names provided\n   * by the layer.\n   *\n   * IE- this guarantees an attribute with auto easing linear to be available by name AND it's value will be properly\n   * populated with a linearly eased value based on the system time.\n   */\n  private processDestructuring<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>,\n    instanceAttributes: IInstanceAttribute<T>[]\n  ) {\n    let out = \"\";\n\n    // Order the attributes such that the easing attributes come last so the needed\n    // info for the easing attribute can be in place\n    const orderedAttributes = instanceAttributes.slice(0).sort(orderByPriority);\n\n    // See which buffer strategy our layer is using and produce a destructuring strategy that suits it\n    switch (layer.bufferType) {\n      case LayerBufferType.INSTANCE_ATTRIBUTE:\n        out = this.processDestructuringInstanceAttribute(orderedAttributes);\n        break;\n\n      case LayerBufferType.INSTANCE_ATTRIBUTE_PACKING:\n        out = this.processDestructuringInstanceAttributePacking(\n          orderedAttributes\n        );\n        break;\n\n      case LayerBufferType.UNIFORM:\n        out = this.processDestructuringUniformBuffer(\n          orderedAttributes,\n          this.metricsProcessor.blocksPerInstance\n        );\n        break;\n    }\n\n    // For now we add in our picking varying assignment should it be needed\n    if (layer.picking.type === PickType.SINGLE) {\n      out +=\n        \"\\n// This portion is where the shader assigns the picking color that gets passed to the fragment shader\\n_picking_color_pass_ = _pickingColor;\\n\";\n    }\n\n    // The final item in the destructuring will always be the active attribute handler to ensure elements\n    // honor the active control\n    out += require(\"../fragments/active-attribute-handler.vs\");\n\n    return out;\n  }\n\n  /**\n   * This generates all Destructuring needs for the Instance Attribute strategy. For this scenario\n   * we only need to dereference AutoEasingMethods so that they will follow the easing values based on the\n   * injected timings by the system.\n   */\n  private processDestructuringInstanceAttribute<T extends Instance>(\n    orderedAttributes: IInstanceAttribute<T>[]\n  ) {\n    let out = \"\";\n\n    orderedAttributes.forEach(attribute => {\n      // If this is the source easing attribute, we must add it in as an eased method along with a calculation for the\n      // Easing interpolation time value based on the current time and the injected start time of the change.\n      if (attribute.easing && attribute.size) {\n        // Make the time calculation for the easing equation\n        out += this.processAutoEasingTiming(attribute);\n\n        out += `  ${sizeToType[attribute.size]} ${attribute.name} = ${\n          attribute.easing.methodName\n        }(_${attribute.name}_start, _${attribute.name}_end, _${\n          attribute.name\n        }_time);\\n`;\n      }\n    });\n\n    return out;\n  }\n\n  /**\n   * This generates all Destructuring needs for the Instance Attribute Packing strategy. For this scenario\n   * attributes are tighly packed into attribute blocks rather than explicitly named attributes, thus the blocks\n   * must be destructured into the proper names of the attributes.\n   *\n   * This will, as well, destructure the auto easing methods.\n   */\n  private processDestructuringInstanceAttributePacking<T extends Instance>(\n    orderedAttributes: IInstanceAttribute<T>[]\n  ) {\n    let out = \"\";\n\n    // The attributes are generated in blocks already. Thus all that need be done for this scenario\n    // is merely perform block destructuring\n    out += this.processDestructureBlocks(orderedAttributes);\n\n    return out;\n  }\n\n  /**\n   * This generates all Destructuring needs for the Uniform Packing strategy. For this scenario\n   * attributes are tighly packed into uniform blocks rather than attributes, thus the blocks\n   * must be destructured into the proper names of the attributes.\n   *\n   * This will, as well, destructure the auto easing methods.\n   */\n  private processDestructuringUniformBuffer<T extends Instance>(\n    orderedAttributes: IInstanceAttribute<T>[],\n    blocksPerInstance: number\n  ) {\n    let out = \"int instanceIndex = int(instance);\";\n\n    // Generate the blocks\n    for (let i = 0; i < blocksPerInstance; ++i) {\n      out += `  vec4 block${i} = getBlock(${i}, instanceIndex);\\n`;\n    }\n\n    // Destructure the blocks\n    out += this.processDestructureBlocks(orderedAttributes);\n\n    return out;\n  }\n\n  /**\n   * This produces the destructuring elements needed to utilize the attribute data stored in blocks with names\n   * like:\n   *\n   * vec4 block0;\n   * vec4 block1;\n   *\n   * etc\n   */\n  private processDestructureBlocks<T extends Instance>(\n    orderedAttributes: IInstanceAttribute<T>[]\n  ) {\n    let out = \"\";\n\n    orderedAttributes.forEach(attribute => {\n      const block = attribute.block;\n\n      // If this is the source easing attribute, we must add it in as an eased method along with a calculation for the\n      // Easing interpolation time value based on the current time and the injected start time of the change.\n      if (attribute.easing && attribute.size) {\n        if (attribute.size === InstanceAttributeSize.FOUR) {\n          out += `  ${sizeToType[attribute.size]} _${\n            attribute.name\n          }_end = block${block};\\n`;\n        } else {\n          out += `  ${sizeToType[attribute.size || 1]} _${\n            attribute.name\n          }_end = block${block}.${makeVectorSwizzle(\n            attribute.blockIndex || 0,\n            attribute.size || 1\n          )};\\n`;\n        }\n\n        // Generate the proper timing calculation for the easing involved\n        out += this.processAutoEasingTiming(attribute);\n\n        out += `  ${sizeToType[attribute.size]} ${attribute.name} = ${\n          attribute.easing.methodName\n        }(_${attribute.name}_start, _${attribute.name}_end, _${\n          attribute.name\n        }_time);\\n`;\n      } else if (attribute.size === InstanceAttributeSize.FOUR) {\n        // If we have a size the size of a block, then don't swizzle the vector\n        out += `  ${sizeToType[attribute.size]} ${\n          attribute.name\n        } = block${block};\\n`;\n      } else if (attribute.atlas) {\n        // If the attribute is an atlas, then we use the special ATLAS size and don't swizzle the vector\n        out += `  ${sizeToType[InstanceAttributeSize.ATLAS]} ${\n          attribute.name\n        } = block${block};\\n`;\n      } else {\n        // Do normal destructuring with any other size and type\n        out += `  ${sizeToType[attribute.size || 1]} ${\n          attribute.name\n        } = block${block}.${makeVectorSwizzle(\n          attribute.blockIndex || 0,\n          attribute.size || 1\n        )};\\n`;\n      }\n    });\n\n    return out;\n  }\n\n  /**\n   * This processes the attribute to generate a timing variable used in the Destructuring of auto easing methods.\n   */\n  private processAutoEasingTiming<T extends Instance>(\n    attribute: IInstanceAttribute<T>\n  ) {\n    if (!attribute.easing) {\n      return;\n    }\n\n    let out = \"\";\n\n    // These are common values across all easing loop styles\n    const time = `_${attribute.name}_time`;\n    const duration = `_${attribute.name}_duration`;\n    const startTime = `_${attribute.name}_start_time`;\n\n    switch (attribute.easing.loop) {\n      // Continuous means letting the time go from 0 to infinity\n      case AutoEasingLoopStyle.CONTINUOUS: {\n        out += `  float ${time} = (currentTime - ${startTime}) / ${duration};\\n`;\n        break;\n      }\n\n      // Repeat means going from 0 to 1 then 0 to 1 etc etc\n      case AutoEasingLoopStyle.REPEAT: {\n        out += `  float ${time} = clamp(fract((currentTime - ${startTime}) / ${duration}), 0.0, 1.0);\\n`;\n        break;\n      }\n\n      // Reflect means going from 0 to 1 then 1 to 0 then 0 to 1 etc etc\n      case AutoEasingLoopStyle.REFLECT: {\n        const timePassed = `_${attribute.name}_timePassed`;\n        const pingPong = `_${attribute.name}_pingPong`;\n\n        // Get the time passed in a linear fashion\n        out += `  float ${timePassed} = (currentTime - ${startTime}) / ${duration};\\n`;\n        // Make a triangle wave from the time passed to ping pong the value\n        out += `  float ${pingPong} = abs((fract(${timePassed} / 2.0)) - 0.5) * 2.0;\\n`;\n        // Ensure we're clamped to the right values\n        out += `  float ${time} = clamp(${pingPong}, 0.0, 1.0);\\n`;\n        break;\n      }\n\n      // No loop means just linear time\n      case AutoEasingLoopStyle.NONE:\n      default: {\n        out += `  float ${time} = clamp((currentTime - ${startTime}) / ${duration}, 0.0, 1.0);\\n`;\n        break;\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Produces attributes that are explicitally named and set by the attribute itself.\n   */\n  private processInstanceAttributeBufferStrategy<T extends Instance>(\n    instanceAttributes: IInstanceAttribute<T>[]\n  ) {\n    let out = \"\\n// Instance Attributes\\n\";\n\n    instanceAttributes.forEach(attribute => {\n      out += `attribute ${\n        sizeToType[attribute.size || 1]\n      } ${attribute.qualifier || \"\"}${(attribute.qualifier && \" \") ||\n        \"\"} ${getAttributeShaderName(attribute)};\\n`;\n    });\n\n    return out;\n  }\n\n  /**\n   * Produces attributes that are blocks instead of individual attributes. The system uses these\n   * blocks to pack attributes tightly together to maximize capabilities.\n   */\n  private processInstanceAttributePackingBufferStrategy(maxBlock: number) {\n    let out = \"\\n// Instance Attributes\\n\";\n\n    // Now print out blocks up to that block\n    for (let i = 0, iMax = maxBlock + 1; i < iMax; ++i) {\n      out += `attribute ${sizeToType[InstanceAttributeSize.FOUR]} block${i};\\n`;\n    }\n\n    return out;\n  }\n\n  /**\n   * Produces the vertex attributes without any bias or modification.\n   */\n  private processVertexAttributes(vertexAttributes: IVertexAttribute[]) {\n    // No matter what, vertex attributes listed are strictly vertex attributes\n    let out = \"// Vertex Attributes\\n\";\n\n    vertexAttributes.forEach(attribute => {\n      out += `attribute ${sizeToType[attribute.size]} ${attribute.qualifier ||\n        \"\"}${(attribute.qualifier && \" \") || \"\"}${attribute.name};\\n`;\n    });\n\n    return out;\n  }\n}\n","/**\n * The purpose of this file and processes is to take a layers attributes and\n * instance attributes and optimally pack them into blocks. As it should be known\n * an attribute and a uniform is limited by the hardware in 'blocks'. Each block\n * for webgl 1.0 is 4 floats. If you use a single float and not the rest, you have\n * used an entire block.\n *\n * Thus, we pack down the attributes into appropriate block indices and slots.\n */\n\nimport { IInstanceAttribute, InstanceAttributeSize } from \"../../types\";\nimport { Instance } from \"../../util\";\n\n/**\n * A quick representation of an available block with a convenience method to easily apply\n * metrics to an attribute if it fits.\n */\nclass Block<T extends Instance> {\n  index: number = 0;\n  available: number = 4;\n\n  constructor(blockIndex: number) {\n    this.index = blockIndex;\n  }\n\n  setAttribute(attr: IInstanceAttribute<T>) {\n    if ((attr.size || 0) <= this.available) {\n      attr.block = this.index;\n      attr.blockIndex = 4 - this.available;\n      this.available -= attr.size || 0;\n\n      return true;\n    }\n\n    return false;\n  }\n}\n\n/**\n * This loops through all attributes and ensures each attribute is applied\n */\nfunction ensureSizes<T extends Instance>(attributes: IInstanceAttribute<T>[]) {\n  attributes.forEach(attr => {\n    if (attr.atlas) {\n      attr.size = InstanceAttributeSize.FOUR;\n    }\n\n    // If the size of the attribute is not determiend at this point, we do our best\n    // to find it by whatever means possible\n    if (!attr.size) {\n      try {\n        // We inject a very phoney instance, we don't need accurate data, we will be happy if we get\n        // an array of undefineds which should be in line with the size of the attribute.\n        const check = attr.update(new Instance({}) as T);\n\n        // We see if the output is sane\n        if (check.length > 0 && check.length <= InstanceAttributeSize.FOUR) {\n          attr.size = check.length;\n        }\n      } catch (err) {\n        console.warn(\n          \"The system could not determine the size of the provided attribute. Please provide the size of the attribute:\",\n          attr\n        );\n      }\n    }\n  });\n}\n\n/**\n * This is the packing method that calculates the block and block index best suited for an attribute\n * so a layer developer does not have to worry about it.\n */\nexport function packAttributes<T extends Instance>(\n  attributes: IInstanceAttribute<T>[]\n) {\n  // First make sure each attribute has a size\n  ensureSizes(attributes);\n  // Keep a list of the blocks we have decided needs to be in use\n  const blocks = [new Block(0)];\n\n  // Loop through all attributes and pack em' in\n  attributes.forEach(attr => {\n    // Look for a block that can fit our attribute\n    const block = blocks.find(block => {\n      if (block.setAttribute(attr)) {\n        return Boolean(block);\n      }\n\n      return false;\n    });\n\n    // If our attribute did not fit into any of the existing blocks, then we must create a new block\n    // to stuff our attribute into.\n    if (!block) {\n      const newBlock = new Block(blocks.length);\n      blocks.push(newBlock);\n\n      if (!newBlock.setAttribute(attr)) {\n        console.warn(\n          \"There was a problem packing an attribute into a block. No block would accommodate it:\",\n          attr\n        );\n      }\n    }\n  });\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport {\n  IEasingInstanceAttribute,\n  IEasingProps,\n  IInstanceAttribute,\n  InstanceAttributeSize\n} from \"../../types\";\nimport { AutoEasingLoopStyle } from \"../../util\";\nimport { EasingProps } from \"../../util/easing-props\";\nimport { ILayerProps, Layer } from \"../layer\";\n\nconst { abs } = Math;\n\nconst BLANK_EASING_PROPS: IEasingProps = {\n  duration: 0,\n  start: [0],\n  end: [0],\n  startTime: 0\n};\n\n/**\n * Tests an attribute to see if it is an easing attribute\n */\nfunction isEasingAttribute<T extends Instance>(\n  attr: any\n): attr is IEasingInstanceAttribute<T> {\n  return Boolean(attr) && attr.easing && attr.size !== undefined;\n}\n\n/**\n * This modifies the instance attributes in a way that produces enough attributes to handle the easing equations\n * being performed on the gpu.\n */\nexport function generateEasingAttributes<\n  T extends Instance,\n  U extends ILayerProps<T>\n>(layer: Layer<T, U>, instanceAttributes: IInstanceAttribute<T>[]) {\n  const usedInstanceAttributes = new Set<number>();\n  const easingAttributes: IEasingInstanceAttribute<T>[] = [];\n\n  // We gather all of the easing attributes first so we can modify the attribute array\n  // On next pass\n  for (const attribute of instanceAttributes) {\n    if (isEasingAttribute(attribute)) {\n      easingAttributes.push(attribute);\n    }\n  }\n\n  const easingIds: { [key: string]: number } = {};\n  layer.easingId = easingIds;\n\n  // Now loop through each easing attribute and generate attributes needed for the easing method\n  for (const attribute of easingAttributes) {\n    const { cpu: easing, loop, uid: providedUID } = attribute.easing;\n    const { name, size, update } = attribute;\n    const easingUID = providedUID;\n\n    // Make our easing ID lookup so instances can access their easing information for higher level\n    // animation control.\n    easingIds[attribute.name] = easingUID;\n\n    // Ensure the AutoEasing method is unique\n    if (usedInstanceAttributes.has(easingUID)) {\n      console.error(\n        \"Undefined behavior occurs if you reuse an IAutoEasingMethod. Please ensure you are using uid() from the util to give the IAutoEasingMethod its uid, or just use the default provided methods\"\n      );\n    }\n\n    // Flag the uid of the easing method as used\n    usedInstanceAttributes.add(easingUID);\n    // We keep this in a scope above the update as we utilize the fact that the attributes will update\n    // In the order they are declared for a single instance. The attributes will all share this information.\n    const attributeDataShare: { values: IEasingProps } = {\n      values: BLANK_EASING_PROPS\n    };\n\n    // Hijack the update from the attribute to a new update method which will\n    // Be able to interact with the values for the easing methodology\n    attribute.update = instance => {\n      // We retrieve properties that we want to be dynamic from the easing equation\n      const {\n        delay: attributeDelay,\n        duration: attributeDuration\n      } = attribute.easing;\n\n      // First get the value that is to be our new destination\n      const end = update(instance);\n      const currentTime = layer.surface.frameMetrics.currentTime;\n\n      // Get the easing values specific to an instance.\n      let values = instance.easing.get(easingUID);\n\n      // If the easing values do not exist yet, make them now\n      if (!values) {\n        values = new EasingProps({\n          duration: attributeDuration,\n          end,\n          start: end,\n          startTime: currentTime\n        });\n\n        // Make sure the instance contains the current easing values\n        instance.easing.set(easingUID, values);\n      }\n\n      // Assign the established values\n      const easingValues = values;\n      let duration = attributeDuration;\n      let delay = attributeDelay;\n\n      if (easingValues.isTimeSet) {\n        duration = easingValues.duration || attributeDuration;\n        delay = easingValues.delay || 0;\n      }\n\n      if (!easingValues.isManualStart) {\n        // Previous position time value\n        let timeValue = 1;\n\n        switch (loop) {\n          // Continuous means we start at 0 and let the time go to infinity\n          case AutoEasingLoopStyle.CONTINUOUS:\n            timeValue = (currentTime - easingValues.startTime) / duration;\n            break;\n\n          // Repeat means going from 0 to 1 then 0 to 1 etc etc\n          case AutoEasingLoopStyle.REPEAT:\n            timeValue = ((currentTime - easingValues.startTime) / duration) % 1;\n            break;\n\n          // Reflect means going from 0 to 1 then 1 to 0 then 0 to 1 etc etc\n          case AutoEasingLoopStyle.REFLECT:\n            const timePassed =\n              (currentTime - easingValues.startTime) / duration;\n            // This is a triangle wave for an input\n            timeValue = abs((timePassed / 2.0) % 1 - 0.5) * 2.0;\n            break;\n\n          // No loop means just linear time\n          case AutoEasingLoopStyle.NONE:\n          default:\n            timeValue = (currentTime - easingValues.startTime) / duration;\n            break;\n        }\n\n        // Now get the value of where our instance currently is located this frame\n        easingValues.start = easing(\n          easingValues.start,\n          easingValues.end,\n          timeValue\n        );\n      }\n\n      // Set the current time as the start time of our animation\n      easingValues.startTime = currentTime + delay;\n      // Set the provided value as our destination\n      easingValues.end = end;\n      // Update the information shared between this attribute and it's children\n      attributeDataShare.values = easingValues;\n\n      /** Set layer's animation end time */\n      layer.animationEndTime = Math.max(\n        layer.animationEndTime,\n        easingValues.startTime + duration\n      );\n\n      return end;\n    };\n\n    // The attribute is going to generate some child attributes\n    attribute.childAttributes = [];\n\n    // Find a slot available for our new start value\n    const startAttr: IInstanceAttribute<T> = {\n      name: `_${name}_start`,\n      parentAttribute: attribute,\n      size,\n      update: _o => attributeDataShare.values.start\n    };\n\n    attribute.childAttributes.push(startAttr);\n    instanceAttributes.push(startAttr);\n\n    // Find a slot available for our new start time\n    const startTimeAttr: IInstanceAttribute<T> = {\n      name: `_${name}_start_time`,\n      parentAttribute: attribute,\n      size: InstanceAttributeSize.ONE,\n      update: _o => [attributeDataShare.values.startTime]\n    };\n\n    attribute.childAttributes.push(startTimeAttr);\n    instanceAttributes.push(startTimeAttr);\n\n    // Find a slot available for our duration\n    const durationAttr: IInstanceAttribute<T> = {\n      name: `_${name}_duration`,\n      parentAttribute: attribute,\n      size: InstanceAttributeSize.ONE,\n      update: _o => [attributeDataShare.values.duration]\n    };\n\n    attribute.childAttributes.push(durationAttr);\n    instanceAttributes.push(durationAttr);\n  }\n}\n","import * as Three from \"three\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport {\n  IAtlasInstanceAttribute,\n  IInstanceAttribute,\n  InstanceAttributeSize,\n  InstanceBlockIndex,\n  IUniform,\n  IValueInstanceAttribute,\n  ShaderInjectionTarget,\n  UniformSize\n} from \"../../types\";\nimport { ILayerProps, Layer } from \"../layer\";\n\nconst emptyTexture = new Three.Texture();\n\nfunction isAtlasAttribute<T extends Instance>(\n  attr: any\n): attr is IAtlasInstanceAttribute<T> {\n  return Boolean(attr) && attr.atlas;\n}\n\n/**\n * This generates any uniforms needed for when a layer is requesting\n */\nexport function generateAtlasResourceUniforms<\n  T extends Instance,\n  U extends ILayerProps<T>\n>(layer: Layer<T, U>, instanceAttributes: IInstanceAttribute<T>[]) {\n  // Retrieve all of the instance attributes that are atlas references\n  const atlasInstanceAttributes: IAtlasInstanceAttribute<T>[] = [];\n  // Key: The atlas uniform name requested\n  const requestedAtlasInjections = new Map<string, [boolean, boolean]>();\n\n  // Get the atlas requests that have unique names. We only need one uniform\n  // For a single unique provided name. We also must merge the requests for\n  // Vertex and fragment injections\n  instanceAttributes.forEach(\n    (attribute: IValueInstanceAttribute<T> | IAtlasInstanceAttribute<T>) => {\n      if (isAtlasAttribute(attribute)) {\n        // Auto set the size of the attribute. Attribute's that are a resource automatically\n        // Consume a size of four\n        attribute.size = InstanceAttributeSize.FOUR;\n        attribute.blockIndex = InstanceBlockIndex.ONE;\n        // Get the atlas resource uniform (sampler2D) injection targets. We default to only the\n        // Fragment shader as it's the most commonly used location for sampler2Ds\n        const injection: number =\n          attribute.atlas.shaderInjection || ShaderInjectionTarget.FRAGMENT;\n        // See if we already have an injection for the given injected uniform name for an atlas resource.\n        const injections = requestedAtlasInjections.get(attribute.atlas.name);\n\n        if (injections) {\n          requestedAtlasInjections.set(attribute.atlas.name, [\n            injections[0] ||\n              injection === ShaderInjectionTarget.VERTEX ||\n              injection === ShaderInjectionTarget.ALL,\n            injections[1] ||\n              injection === ShaderInjectionTarget.FRAGMENT ||\n              injection === ShaderInjectionTarget.ALL\n          ]);\n        } else {\n          atlasInstanceAttributes.push(attribute);\n          requestedAtlasInjections.set(attribute.atlas.name, [\n            injection === ShaderInjectionTarget.VERTEX ||\n              injection === ShaderInjectionTarget.ALL,\n            injection === ShaderInjectionTarget.FRAGMENT ||\n              injection === ShaderInjectionTarget.ALL\n          ]);\n        }\n      }\n    }\n  );\n\n  // Make uniforms for all of the unique atlas requests.\n  const uniforms = atlasInstanceAttributes.map(\n    (instanceAttribute): IUniform[] => {\n      let injection: ShaderInjectionTarget = ShaderInjectionTarget.FRAGMENT;\n\n      if (instanceAttribute.atlas) {\n        const injections = requestedAtlasInjections.get(\n          instanceAttribute.atlas.name\n        );\n\n        if (injections) {\n          injection =\n            (injections[0] && injections[1] && ShaderInjectionTarget.ALL) ||\n            (injections[0] && !injections[1] && ShaderInjectionTarget.VERTEX) ||\n            (!injections[0] &&\n              injections[1] &&\n              ShaderInjectionTarget.FRAGMENT) ||\n            injection;\n        }\n      }\n\n      return [\n        {\n          name: instanceAttribute.atlas.name,\n          shaderInjection: injection,\n          size: UniformSize.ATLAS,\n          update: () =>\n            layer.resource.getAtlasTexture(instanceAttribute.atlas.key) ||\n            emptyTexture\n        },\n        {\n          name: `${instanceAttribute.atlas.name}_size`,\n          shaderInjection: injection,\n          size: UniformSize.TWO,\n          update: () => {\n            const atlas = layer.resource.getAtlasTexture(\n              instanceAttribute.atlas.key\n            );\n\n            if (atlas && atlas.image) {\n              const { width, height } = atlas.image;\n              return [width || 1, height || 1];\n            }\n\n            return [1, 1];\n          }\n        }\n      ];\n    }\n  );\n\n  const flatten: IUniform[] = [];\n  uniforms.forEach(list => list.forEach(uniform => flatten.push(uniform)));\n\n  return flatten;\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport { ILayerProps, Layer } from \"../../surface/layer\";\nimport { injectShaderIO } from \"../../surface/layer-processing/inject-shader-io\";\nimport { getLayerBufferType } from \"../../surface/layer-processing/layer-buffer-type\";\nimport {\n  IInstanceAttribute,\n  IInstancingUniform,\n  IShaderInitialization,\n  IShaders,\n  IUniformInternal,\n  IVertexAttributeInternal,\n  ShaderInjectionTarget\n} from \"../../types\";\nimport { shaderTemplate } from \"../../util/shader-templating\";\nimport { templateVars } from \"../template-vars\";\nimport { AttributeProcessing } from \"./attribute-processing\";\nimport { EasingProcessing } from \"./easing-processing\";\nimport { MetricsProcessing } from \"./metrics-processing\";\nimport { ShaderModule } from \"./shader-module\";\nimport { ShaderModuleUnit } from \"./shader-module-unit\";\nimport { UniformProcessing } from \"./uniform-processing\";\n\n/**\n * This is the expected results from processing the shader and it's layer's attributes.\n */\nexport interface IShaderProcessingResults<T extends Instance> {\n  /** The resulting fragment shader from processing the module */\n  fs: string;\n  /** Any additional system uniforms that arose from the processing */\n  materialUniforms: IInstancingUniform[];\n  /** Calculated max instances per buffer (mostly for uniform packing procedures) */\n  maxInstancesPerBuffer: number;\n  /** The modules that were included within the module processing */\n  modules: ShaderModuleUnit[];\n  /** The resulting vertex shader from processing the module */\n  vs: string;\n  /** All instance attributes that arise from module processing */\n  instanceAttributes: IInstanceAttribute<T>[];\n  /** All vertex attributes that arise from module processing */\n  vertexAttributes: IVertexAttributeInternal[];\n  /** All uniform attributes that arise from module processing */\n  uniforms: IUniformInternal[];\n}\n\n/** Expected results from processing shader imports */\nexport type ProcessShaderImportResults =\n  | (IShaders & { shaderModuleUnits: Set<ShaderModuleUnit> })\n  | null;\n\n/**\n * The intent of this processor is to analyze a layer's Shader IO elements and produce a functional\n * shader from those elements. This includes supporting a layer's capabilties with the client systems\n * capabilities and matching compatibilities.\n *\n * This inlcudes:\n *\n * Injecting needed module imports based on the layers specifications\n * Resolving Module imports and handling errors\n * Utilizing layer information to create attributes and uniforms based on attribute packing strategies\n * Destructuring attributes based on easing requirements or if attributes were packed\n * Swapping out miscellaneous template variables\n */\nexport class ShaderProcessor {\n  /** The processor that defines easing methods that are to be injected into the shaders */\n  easingProcessing: EasingProcessing = new EasingProcessing();\n  /** Processor that calculates shared metrics across all processors */\n  metricsProcessing: MetricsProcessing = new MetricsProcessing();\n  /** The processor that defines how uniforms are written into the shader */\n  uniformProcessing: UniformProcessing = new UniformProcessing(\n    this.metricsProcessing\n  );\n  /** The processor that defines how attributes are packed into the shader */\n  attributeProcessing: AttributeProcessing = new AttributeProcessing(\n    this.uniformProcessing,\n    this.metricsProcessing\n  );\n\n  /**\n   * This processes a layer, it's Shader IO requirements, and it's shaders to produce a fully functional\n   * shader that is compatible with the client's system.\n   */\n  process<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>,\n    shaderIO: IShaderInitialization<T>\n  ): IShaderProcessingResults<T> | null {\n    try {\n      // Reset anything state that needs revertting\n      this.uniformProcessing.materialUniforms = [];\n\n      // First process imports to create a shader complete with the necessary\n      const shadersWithImports = this.processImports(layer, shaderIO);\n      if (!shadersWithImports) return null;\n\n      // After processing our imports, we can now fully aggregate the needed shader IO to make our layer\n      // operate properly\n      // Get the injected shader IO attributes and uniforms\n      const { vertexAttributes, instanceAttributes, uniforms } = injectShaderIO(\n        layer.surface.gl,\n        layer,\n        shaderIO,\n        shadersWithImports\n      );\n      // After all of the shader IO is established, let's calculate the appropriate buffering strategy\n      // For the layer.\n      getLayerBufferType(\n        layer.surface.gl,\n        layer,\n        vertexAttributes,\n        instanceAttributes\n      );\n\n      // Calculate needed metrics that may be used by any of the processors\n      this.metricsProcessing.process(instanceAttributes, uniforms);\n\n      // Next generate the attribute packing strategy for the layer. The layer will define how it expects\n      // attributes (instance and vertex) to be handled. This will be written as the input to the shader at\n      // the top of the vertex shader file.\n      const attributeDeclarations = this.attributeProcessing.process(\n        layer,\n        vertexAttributes,\n        instanceAttributes\n      );\n      if (attributeDeclarations === null) return null;\n\n      // Next generate any uniform declarations necessary for the vertex shader\n      const vertexUniformDeclarations = this.uniformProcessing.process(\n        uniforms,\n        ShaderInjectionTarget.VERTEX\n      );\n      if (vertexUniformDeclarations === null) return null;\n\n      // Generate uniform declarations for the fragment shader\n      const fragmentUniformDeclarations = this.uniformProcessing.process(\n        uniforms,\n        ShaderInjectionTarget.FRAGMENT\n      );\n      if (fragmentUniformDeclarations === null) return null;\n\n      // Generate the easing methods the layer specified\n      const easingMethodDeclarations = this.easingProcessing.process(\n        instanceAttributes\n      );\n      if (easingMethodDeclarations === null) return null;\n\n      // Create a default precision modifier for now\n      const precision = \"precision highp float;\\n\\n\";\n\n      // Now we concatenate the shader pieces into one glorious shader of compatibility and happiness\n      const fullShaderVS =\n        precision +\n        attributeDeclarations.declarations +\n        vertexUniformDeclarations +\n        easingMethodDeclarations +\n        shadersWithImports.vs;\n\n      const fullShaderFS =\n        precision + fragmentUniformDeclarations + shadersWithImports.fs;\n\n      // Last we replace any templating variables with their relevant values\n      let templateOptions: { [key: string]: string } = {\n        [templateVars.attributes]: attributeDeclarations.destructuring\n      };\n\n      const processedShaderVS = shaderTemplate({\n        options: templateOptions,\n        required: undefined,\n        shader: fullShaderVS\n      });\n\n      // We process the Fragment shader as well, currently with nothing to replace\n      // aside from removing any superfluous template requests\n      templateOptions = {};\n\n      const processShaderFS = shaderTemplate({\n        options: templateOptions,\n        required: undefined,\n        shader: fullShaderFS\n      });\n\n      const results = {\n        fs: processShaderFS.shader.trim(),\n        materialUniforms: this.uniformProcessing.materialUniforms,\n        maxInstancesPerBuffer: this.metricsProcessing.maxInstancesPerBuffer,\n        modules: Array.from(shadersWithImports.shaderModuleUnits),\n        vs: processedShaderVS.shader.trim(),\n        vertexAttributes,\n        instanceAttributes,\n        uniforms\n      };\n\n      return results;\n    } catch (err) {\n      console.warn(\n        \"An unknown error occurred while processing the shaders for layer:\",\n        layer.id\n      );\n      console.warn(\"Error:\");\n      console.warn(err && (err.stack || err.message));\n      return null;\n    }\n  }\n\n  /**\n   * This applies the imports for the specified layer and generates the appropriate shaders from the output.\n   * Upon failure, this will just return null.\n   *\n   * This also does some additional work to add in some modules based on the layer's preferences\n   */\n  private processImports<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>,\n    shaders: IShaderInitialization<T>\n  ): ProcessShaderImportResults {\n    const shaderModuleUnits = new Set<ShaderModuleUnit>();\n    const baseModules = layer.baseShaderModules(shaders);\n\n    // Process imports for the vertex shader\n    const vs = ShaderModule.process(\n      layer.id,\n      shaders.vs,\n      ShaderInjectionTarget.VERTEX,\n      baseModules.vs\n    );\n\n    if (vs.errors.length > 0) {\n      console.warn(\n        \"Error processing imports for the vertex shader of layer:\",\n        layer.id,\n        \"Errors\",\n        ...vs.errors.reverse()\n      );\n\n      return null;\n    }\n\n    // Process imports for the fragment shader\n    const fs = ShaderModule.process(\n      layer.id,\n      shaders.fs,\n      ShaderInjectionTarget.FRAGMENT,\n      baseModules.fs\n    );\n\n    if (fs.errors.length > 0) {\n      console.warn(\n        \"Error processing imports for the fragment shader of layer:\",\n        layer.id,\n        \"Errors\",\n        ...fs.errors.reverse()\n      );\n\n      return null;\n    }\n\n    // Gather all discovered Shader Module Units\n    vs.shaderModuleUnits.forEach(moduleUnit =>\n      shaderModuleUnits.add(moduleUnit)\n    );\n    fs.shaderModuleUnits.forEach(moduleUnit =>\n      shaderModuleUnits.add(moduleUnit)\n    );\n\n    return {\n      fs: fs.shader || \"\",\n      vs: vs.shader || \"\",\n      shaderModuleUnits\n    };\n  }\n}\n","import * as Three from \"three\";\nimport { WebGLRenderTarget } from \"three\";\nimport { ImageInstance } from \"../base-layers/images\";\nimport { LabelInstance } from \"../base-layers/labels\";\nimport { Instance } from \"../instance-provider/instance\";\nimport { Bounds } from \"../primitives/bounds\";\nimport { Box } from \"../primitives/box\";\nimport { ShaderProcessor } from \"../shaders/processing/shader-processor\";\nimport { FrameMetrics } from \"../types\";\nimport { PickType } from \"../types\";\nimport { analyzeColorPickingRendering } from \"../util/color-picking-analysis\";\nimport { DataBounds } from \"../util/data-bounds\";\nimport { Vec2 } from \"../util/vector\";\nimport { EventManager } from \"./event-manager\";\nimport { LayerMouseEvents } from \"./event-managers/layer-mouse-events\";\nimport { ILayerProps, Layer } from \"./layer\";\nimport { generateDefaultScene } from \"./layer-processing/generate-default-scene\";\nimport { generateLayerGeometry } from \"./layer-processing/generate-layer-geometry\";\nimport { generateLayerMaterial } from \"./layer-processing/generate-layer-material\";\nimport { generateLayerModel } from \"./layer-processing/generate-layer-model\";\nimport { makeLayerBufferManager } from \"./layer-processing/layer-buffer-type\";\nimport { MouseEventManager, SceneView } from \"./mouse-event-manager\";\nimport { ISceneOptions, Scene } from \"./scene\";\nimport { AtlasManager } from \"./texture\";\nimport { IAtlasOptions } from \"./texture/atlas\";\nimport { AtlasResourceManager } from \"./texture/atlas-resource-manager\";\nimport { ClearFlags, View } from \"./view\";\n\nexport interface ILayerSurfaceOptions {\n  /**\n   * These are the atlas resources we want available that our layers can be provided to utilize\n   * for their internal processes.\n   */\n  atlasResources?: IAtlasOptions[];\n  /**\n   * This is the color the canvas will be set to.\n   */\n  background: [number, number, number, number];\n  /**\n   * If this is provided, it will use this context for rendering. If a string is provided\n   * it will search for the canvas context by id.\n   */\n  context?: WebGLRenderingContext | HTMLCanvasElement | string;\n  /**\n   * This is the event managers to respond to the mouse events.\n   */\n  eventManagers?: EventManager[];\n  /**\n   * Set to true to allow this surface to absorb and handle wheel events from the mouse.\n   */\n  handlesWheelEvents?: boolean;\n  /**\n   * This specifies the density of rendering in the surface. The default value is window.devicePixelRatio to match the\n   * monitor for optimal clarity. Using a value of 1 will be acceptable, will not get high density renders, but will\n   * have better performance if needed.\n   */\n  pixelRatio?: number;\n  /**\n   * This sets up the available scenes the surface will have to work with. Layers then can\n   * reference the scene by it's scene property. The order of the scenes here is the drawing\n   * order of the scenes.\n   */\n  scenes: ISceneOptions[];\n}\n\nconst DEFAULT_BACKGROUND_COLOR = new Three.Color(1.0, 1.0, 1.0);\n\nfunction isCanvas(val: any): val is HTMLCanvasElement {\n  return Boolean(val.getContext);\n}\n\nfunction isString(val: any): val is string {\n  return Boolean(val.substr);\n}\n\nfunction isWebGLContext(val: any): val is WebGLRenderingContext {\n  return Boolean(val.canvas);\n}\n\nexport interface ILayerConstructable<T extends Instance> {\n  new (props: ILayerProps<T>): Layer<any, any>;\n}\n\n/**\n * This is a pair of a Class Type and the props to be applied to that class type.\n */\nexport type LayerInitializer = [\n  ILayerConstructable<Instance> & { defaultProps: ILayerProps<Instance> },\n  ILayerProps<Instance>\n];\n\n/**\n * Used for reactive layer generation and updates.\n */\nexport function createLayer<T extends Instance, U extends ILayerProps<T>>(\n  layerClass: ILayerConstructable<T> & { defaultProps: U },\n  props: U\n): LayerInitializer {\n  return [layerClass, props];\n}\n\n/**\n * This is a manager for layers. It will use voidgl layers to intelligently render resources\n * as efficiently as possible. Layers will be rendered in the order they are provided and this\n * surface will provide some basic camera controls by default.\n */\nexport class LayerSurface {\n  /** This is the atlas manager that will help with modifying and tracking atlas' generated for the layers */\n  private atlasManager: AtlasManager = new AtlasManager();\n  /** This is the gl context this surface is rendering to */\n  private context: WebGLRenderingContext;\n  /** This is the current viewport the renderer state is in */\n  currentViewport = new Map<Three.WebGLRenderer, Box>();\n  /**\n   * This is the metrics of the current running frame\n   */\n  frameMetrics: FrameMetrics = {\n    currentFrame: 0,\n    currentTime: Date.now() | 0,\n    previousTime: Date.now() | 0\n  };\n  /**\n   * This is used to help resolve concurrent draws. There are some very async operations that should\n   * not overlap in draw calls.\n   */\n  private isBufferingAtlas = false;\n  /** This is all of the layers in this manager by their id */\n  layers = new Map<string, Layer<Instance, ILayerProps<Instance>>>();\n  /** This manages the mouse events for the current canvas context */\n  private mouseManager: MouseEventManager;\n  /**\n   * This is the renderer that is meant for rendering the picking pass. We have a separate renderer so we can disable\n   * over complicated features like antialiasing which would ruin the picking pass.\n   */\n  pickingRenderer: Three.WebGLRenderer;\n  /** This is a target used to perform rendering our picking pass */\n  pickingTarget: Three.WebGLRenderTarget;\n  /** This is the density the rendering renders for the surface */\n  pixelRatio: number = window.devicePixelRatio;\n  /** This is the THREE render system we use to render scenes with views */\n  renderer: Three.WebGLRenderer;\n  /** This is the resource manager that handles resource requests for instances */\n  resourceManager: AtlasResourceManager;\n  /**\n   * This is all of the available scenes and their views for this surface. Layers reference the IDs\n   * of the scenes and the views to be a part of their rendering state.\n   */\n  scenes = new Map<string, Scene>();\n  /**\n   * This is all of the views currently generated for this surface paired with the scene they render.\n   */\n  sceneViews: SceneView[] = [];\n  /** When set to true, the next render will make sure color picking is updated for layer interactions */\n  updateColorPick?: {\n    mouse: Vec2;\n    views: View[];\n  };\n  /**\n   * This flags all layers by id for disposal at the end of every render. A Layer must be recreated\n   * after each render in order to clear it's disposal flag. This is the trick to making this a\n   * reactive system.\n   */\n  willDisposeLayer = new Map<string, boolean>();\n  /**\n   * This map is a quick look up for a view to determine other views that\n   * would need to be redrawn as a consequence of the source view needing a redraw\n   */\n  private viewDrawDependencies = new Map<View, View[]>();\n  /** This is used to indicate whether the loading is completed */\n  private loadReadyResolve: () => void;\n  loadReady: Promise<void> = new Promise(\n    resolve => (this.loadReadyResolve = resolve)\n  );\n\n  /** Read only getter for the gl context */\n  get gl() {\n    return this.context;\n  }\n\n  /**\n   * This adds a layer to the manager which will manage all of the resource lifecycles of the layer\n   * as well as additional helper injections to aid in instancing and shader i/o.\n   */\n  private addLayer<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>\n  ): Layer<T, U> | null {\n    if (!layer.id) {\n      console.warn(\"All layers must have an id\");\n      return layer;\n    }\n\n    if (this.layers.get(layer.id)) {\n      console.warn(\"All layer's ids must be unique per layer manager\");\n      return layer;\n    }\n\n    // We add the layer to our management\n    this.layers.set(layer.id, layer);\n\n    // Now we initialize the layer's gl components\n    const layerId = layer.id;\n\n    // Init the layer and see if the initialization is successful\n    if (!this.initLayer(layer)) {\n      this.layers.delete(layerId);\n      return null;\n    }\n\n    return layer;\n  }\n\n  /**\n   * The performs all of the needed updates that layers need to commit to the scene and buffers\n   * to be ready for a draw pass. This is callable outside of the draw loop to allow for specialized\n   * procedures or optimizations to take place, where incremental updates to the buffers would make\n   * the most sense.\n   *\n   * @param time The start time of the given frame\n   * @param frameIncrement When true, the frame count for the frame metrics will increment\n   * @param onViewReady Callback for when all of the layers of a scene view have been committed\n   *                    and are thus potentially ready to be rendered.\n   */\n  async commit(\n    time?: number,\n    frameIncrement?: boolean,\n    onViewReady?: (\n      needsDraw: boolean,\n      scene: Scene,\n      view: View,\n      pickingPass: Layer<any, any>[]\n    ) => void\n  ) {\n    if (!this.gl) return;\n\n    // For now, while certain mysteries remain, we will track only if any view needs to be redrawn.\n    // Any view that needs to be redrawn will trigger a redraw of the entire surface for now until\n    // we can optimize down to only drawing a single view without erasing views that were not redrawn.\n    let needsDraw = false;\n\n    // We are rendering a new frame so increment our frame count\n    if (frameIncrement) this.frameMetrics.currentFrame++;\n    this.frameMetrics.previousTime = this.frameMetrics.currentTime;\n\n    // If no manual time was provided, we shall use Date.now in 32 bit format\n    if (time === undefined) {\n      this.frameMetrics.currentTime = Date.now() | 0;\n    } else {\n      // If this is our first frame and we have a manual time entry, then we first need to sync up\n      // The manual time as our previous timing.\n      if (this.frameMetrics.previousTime === this.frameMetrics.currentTime) {\n        this.frameMetrics.previousTime = time;\n      }\n\n      this.frameMetrics.currentTime = time;\n    }\n\n    // Get the scenes in their added order\n    const scenes = Array.from(this.scenes.values());\n    const validLayers: { [key: string]: Layer<any, any> } = {};\n    const erroredLayers: { [key: string]: [Layer<any, any>, Error] } = {};\n    const pickingPassByView = new Map<View, Layer<any, any>[]>();\n\n    // Loop through scenes\n    for (let i = 0, end = scenes.length; i < end; ++i) {\n      const scene = scenes[i];\n      const views = Array.from(scene.viewById.values());\n      const layers = scene.layers;\n\n      // Make sure the layers are depth sorted\n      scene.sortLayers();\n\n      // Loop through the views\n      for (let k = 0, endk = views.length; k < endk; ++k) {\n        const view = views[k];\n        // When this flags true, a picking pass will be rendered for the provided scene / view\n        const pickingPass: Layer<any, any>[] = [];\n\n        // We must perform any operations necessary to make the view camera fit the viewport\n        // Correctly\n        view.fitViewtoViewport(\n          new Bounds({\n            height: this.context.canvas.height,\n            width: this.context.canvas.width,\n            x: 0,\n            y: 0\n          })\n        );\n\n        // Let the layers update their uniforms before the draw\n        for (let j = 0, endj = layers.length; j < endj; ++j) {\n          // Get the layer to be rendered in the scene\n          const layer = layers[j];\n          // Update the layer with the view it is about to be rendered with\n          layer.view = view;\n\n          // Make sure the layer is given the opportunity to update all of it's uniforms\n          // To match the view state and update any unresolved diffs internally\n          try {\n            // Update uniforms, resolve diff changes\n            layer.draw();\n            // If any of the layers under the view need a redraw\n            // Then the view needs a redraw\n            if (layer.needsViewDrawn) view.needsDraw = true;\n            // Flag the layer as valid\n            validLayers[layer.id] = layer;\n            // The view's animationEndTime is the largest end time found on one of the view's child layers.\n            view.animationEndTime = Math.max(\n              view.animationEndTime,\n              layer.animationEndTime\n            );\n          } catch (err) {\n            if (!erroredLayers[layer.id]) {\n              erroredLayers[layer.id] = [layer, err];\n            }\n          }\n\n          // If this layer specifies a picking draw pass, then we shall store it in the current draw order\n          // For that next step\n          if (layer.picking.type === PickType.SINGLE) {\n            pickingPass.push(layer);\n          }\n        }\n\n        // Analyze the view's animation end timings and the camera to see if there are view changes\n        // that will trigger a redraw outside of our layer changes\n        if (\n          view.needsDraw ||\n          (time && time < view.animationEndTime) ||\n          view.camera.needsViewDrawn\n        ) {\n          view.needsDraw = true;\n          needsDraw = true;\n\n          // Get all of the dependent views for that view\n          const overlapViews = this.viewDrawDependencies.get(view);\n\n          // And make all of them need a redraw.\n          if (overlapViews) {\n            overlapViews.forEach(view => {\n              view.needsDraw = true;\n            });\n          }\n        }\n\n        // Store the picking pass for the view to use when the view is ready to draw\n        pickingPassByView.set(view, pickingPass);\n      }\n    }\n\n    // If any draw need was detected, redraw the surface\n    for (let i = 0, end = scenes.length; i < end; ++i) {\n      const scene = scenes[i];\n      // Our scene must have a valid container to operate\n      if (!scene.container) continue;\n      const views = Array.from(scene.viewById.values());\n\n      for (let k = 0, endk = views.length; k < endk; ++k) {\n        const view = views[k];\n\n        // Now perform the rendering\n        if (onViewReady) {\n          onViewReady(\n            needsDraw,\n            scene,\n            view,\n            pickingPassByView.get(view) || []\n          );\n        }\n      }\n    }\n\n    // get the layers with errors flagged for them\n    const errors = Object.values(erroredLayers);\n\n    if (errors.length > 0) {\n      const passed = Object.values(validLayers);\n\n      console.warn(\n        \"Some layers errored during their draw update. These layers will be removed. They can be re-added if render() is called again:\",\n        errors.map(err => err[0].id)\n      );\n\n      // Output each layer and why it errored\n      errors.forEach(err => {\n        console.warn(`Layer ${err[0].id} removed for the following error:`);\n        if (err[1]) console.error(err[1].stack || err[1].message);\n      });\n\n      // Re-render but only include non-errored layers\n      this.render(passed.map(layer => layer.initializer));\n    }\n  }\n\n  /**\n   * Free all resources consumed by this surface that gets applied to the GPU.\n   */\n  destroy() {\n    this.layers.forEach(layer => layer.destroy());\n    this.resourceManager.destroy();\n    this.mouseManager.destroy();\n    this.sceneViews.forEach(sceneView => sceneView.scene.destroy());\n    this.renderer.dispose();\n    this.pickingRenderer.dispose();\n    this.currentViewport.clear();\n\n    // TODO: Instances should be implementing destroy for these clean ups.\n    LabelInstance.destroy();\n    ImageInstance.destroy();\n  }\n  /**\n   * This is the draw loop that must be called per frame for updates to take effect and display.\n   *\n   * @param time This is an optional time flag so one can manually control the time flag for the frame.\n   *             This will affect animations and other automated gpu processes.\n   */\n  async draw(time?: number) {\n    if (!this.gl) return;\n\n    // Make the layers commit their changes to the buffers then draw each scene view on\n    // Completion.\n    await this.commit(time, true, (needsDraw, scene, view, pickingPass) => {\n      // Our scene must have a valid container to operate\n      if (!scene.container) return;\n\n      if (needsDraw) {\n        // Now perform the rendering\n        this.drawSceneView(scene.container, view);\n      }\n\n      // If a layer needs a picking pass, then perform a picking draw pass only\n      // if a request for the color pick has been made, then we query the pixels rendered to our picking target\n      if (pickingPass.length > 0 && this.updateColorPick) {\n        // Get the requested metrics\n        const mouse = this.updateColorPick.mouse;\n        const views = this.updateColorPick.views;\n\n        // Only if the view is interacted with should we both with rendering\n        if (views.indexOf(view) > -1) {\n          // Picking uses a pixel ratio of 1\n          view.pixelRatio = 1.0;\n          // Get the current flags for the view\n          const flags = view.clearFlags.slice(0);\n          // Set color rendering flasg\n          view.clearFlags = [ClearFlags.COLOR, ClearFlags.DEPTH];\n\n          // We must perform any operations necessary to make the view camera fit the viewport\n          // Correctly with the possibly adjusted pixel ratio\n          view.fitViewtoViewport(\n            new Bounds({\n              height: this.context.canvas.height / this.pixelRatio,\n              width: this.context.canvas.width / this.pixelRatio,\n              x: 0,\n              y: 0\n            })\n          );\n\n          // We must redraw the layers so they will update their uniforms to adapt to a picking pass\n          for (let j = 0, endj = pickingPass.length; j < endj; ++j) {\n            const layer = pickingPass[j];\n            // Adjust the layer to utilize the proper pick mode, thus causing the layer to properly\n            // Set it's uniforms into a pick mode.\n            layer.picking.currentPickMode = PickType.SINGLE;\n\n            // Update the layer's material uniforms and avoid causing the changelist to attempt updates again\n            try {\n              layer.updateUniforms();\n            } catch (err) {\n              /** No-op, the first draw should have output an error for bad draw calls */\n              console.warn(err);\n            }\n\n            layer.picking.currentPickMode = PickType.NONE;\n          }\n\n          // Draw the picking container for the scene with our view long with our specialized picking renderer\n          // NOTE: Neat trick, just remove 'this.pickingTarget' from the argument and add\n          // canvas.parentNode.appendChild(this.pickingRenderer.getContext().canvas);\n          // below where the picking Target is created and you will see what is being rendered to the color picking buffer\n          this.drawSceneView(\n            scene.pickingContainer,\n            view,\n            this.pickingRenderer,\n            this.pickingTarget\n          );\n\n          // Make our metrics for how much of the image we wish to analyze\n          const pickWidth = 5;\n          const pickHeight = 5;\n          const numBytesPerColor = 4;\n          const out = new Uint8Array(pickWidth * pickHeight * numBytesPerColor);\n\n          // Read the pixels out\n          // TODO: We need to defer this reading to next frame as the rendering MUST be completed before a readPixels\n          // operation can complete. Thus in complex rendering situations that pushes the GPU, this could be a MAJOR bottleneck.\n          this.pickingRenderer.readRenderTargetPixels(\n            this.pickingTarget,\n            mouse[0] - view.screenBounds.x - pickWidth / 2,\n            view.screenBounds.height -\n              (mouse[1] - view.screenBounds.y) -\n              pickHeight / 2,\n            pickWidth,\n            pickHeight,\n            out\n          );\n\n          // Analyze the rendered color data for the picking routine\n          const pickingData = analyzeColorPickingRendering(\n            [mouse[0] - view.screenBounds.x, mouse[1] - view.screenBounds.y],\n            out,\n            pickWidth,\n            pickHeight\n          );\n\n          // We must redraw the layers so they will update their uniforms to adapt to a picking pass\n          for (let j = 0, endj = pickingPass.length; j < endj; ++j) {\n            const layer = pickingPass[j];\n\n            if (layer.picking.type === PickType.SINGLE) {\n              layer.interactions.colorPicking = pickingData;\n            }\n          }\n\n          // Return the pixel ratio back to the rendered ratio\n          view.pixelRatio = this.pixelRatio;\n          // Return the view's clear flags\n          view.clearFlags = flags;\n\n          // After reverting the pixel ratio, we must return to the state we came from so that mouse interactions\n          // will work properly\n          view.fitViewtoViewport(\n            new Bounds({\n              height: this.context.canvas.height,\n              width: this.context.canvas.width,\n              x: 0,\n              y: 0\n            })\n          );\n        }\n      }\n    });\n\n    // After we have drawn our views of our scenes, we can now ensure all of the bounds\n    // Are updated in the interactions and flag our interactions ready for mouse input\n    if (this.mouseManager.waitingForRender) {\n      this.sceneViews.forEach(sceneView => {\n        sceneView.bounds = new DataBounds(sceneView.view.screenBounds);\n        sceneView.bounds.data = sceneView;\n      });\n\n      this.mouseManager.waitingForRender = false;\n    }\n\n    // Now that all of our layers have performed updates to everything, we can now dequeue\n    // All resource requests\n    // We create this gate in case multiple draw calls flow through before a buffer opertion is completed\n    if (!this.isBufferingAtlas) {\n      this.isBufferingAtlas = true;\n      const didBuffer = await this.resourceManager.dequeueRequests();\n      this.isBufferingAtlas = false;\n\n      // If buffering did occur and completed, then we should be performing a draw to ensure all of the\n      // Changes are committed and pushed out.\n      if (didBuffer) {\n        this.loadReadyResolve();\n        this.loadReady = new Promise(\n          resolve => (this.loadReadyResolve = resolve)\n        );\n        this.draw();\n      }\n    }\n\n    // Clear out the flag requesting a pick pass so we don't perform a pick render pass unless we have\n    // another requested from mouse interactions\n    delete this.updateColorPick;\n\n    // Each frame needs to analyze if draws are needed or not. Thus we reset all draw needs so they will\n    // be considered resolved for the current set of changes.\n    // Set draw needs of cameras and views back to false\n    this.sceneViews.forEach(sceneView => {\n      sceneView.view.needsDraw = false;\n      sceneView.view.camera.resolve();\n    });\n\n    // Set all layers draw needs back to false, also, resolve all of the data providers\n    // so their changelists are considered consumed.\n    this.layers.forEach(layer => {\n      layer.needsViewDrawn = false;\n      layer.props.data.resolveContext = \"\";\n    });\n  }\n\n  /**\n   * This finalizes everything and sets up viewports and clears colors and performs the actual render step\n   */\n  private drawSceneView(\n    scene: Three.Scene,\n    view: View,\n    renderer?: Three.WebGLRenderer,\n    target?: Three.WebGLRenderTarget\n  ) {\n    renderer = renderer || this.renderer;\n    const offset = { x: view.viewBounds.left, y: view.viewBounds.top };\n    const size = view.viewBounds;\n    const rendererSize = renderer.getSize();\n    const pixelRatio = renderer.getPixelRatio();\n    rendererSize.width *= pixelRatio;\n    rendererSize.height *= pixelRatio;\n    const background = view.background;\n    const context = renderer.getContext();\n\n    // Something is up with threejs that does not allow us to set viewport x and y values. So for targets\n    // We simply size the target to the view size and render. Thus scissoring is not required\n    if (!target) {\n      // Set the scissor rectangle.\n      renderer.setScissorTest(true);\n      renderer.setScissor(\n        offset.x / pixelRatio,\n        offset.y / pixelRatio,\n        size.width / pixelRatio,\n        size.height / pixelRatio\n      );\n\n      // If a background is established, we should clear the background color\n      // Specified for this context\n      if (view.background) {\n        // Clear the rect of color and depth so the region is totally it's own\n        context.clearColor(\n          background[0],\n          background[1],\n          background[2],\n          background[3]\n        );\n      }\n    }\n\n    // Get the view's clearing preferences\n    if (view.clearFlags) {\n      // For targets, we must also perform clear operations\n      if (target) {\n        // TODO: This is frustrating. Right now we can't specify and set the viewport for a render target\n        // Possibly with Threejs going away we can actually be more explcit for the render area to a render target\n        // and not cause this overhead of resizing the render target for every picking pass\n        target.setSize(size.width, size.height);\n        renderer.setRenderTarget(target);\n        renderer.clear(\n          view.clearFlags.indexOf(ClearFlags.COLOR) > -1,\n          view.clearFlags.indexOf(ClearFlags.DEPTH) > -1,\n          view.clearFlags.indexOf(ClearFlags.STENCIL) > -1\n        );\n      } else {\n        renderer\n          .getContext()\n          .clear(\n            (view.clearFlags.indexOf(ClearFlags.COLOR) > -1\n              ? context.COLOR_BUFFER_BIT\n              : 0x0) |\n              (view.clearFlags.indexOf(ClearFlags.DEPTH) > -1\n                ? context.DEPTH_BUFFER_BIT\n                : 0x0) |\n              (view.clearFlags.indexOf(ClearFlags.STENCIL) > -1\n                ? context.STENCIL_BUFFER_BIT\n                : 0x0)\n          );\n      }\n    } else {\n      // Default clearing is depth and color\n      // For targets, we must also perform clear operations\n      if (target) {\n        // TODO: This is frustrating. Right now we can't specify and set the viewport for a render target\n        // Possibly with Threejs going away we can actually be more explcit for the render area to a render target\n        // and not cause this overhead of resizing the render target for every picking pass\n        target.setSize(size.width, size.height);\n        renderer.setRenderTarget(target);\n        renderer.clear(true, true);\n      } else {\n        context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);\n      }\n    }\n\n    // Make sure the viewport is set properly for the next render\n    renderer.setViewport(\n      offset.x / pixelRatio,\n      offset.y / pixelRatio,\n      size.width,\n      size.height\n    );\n\n    // Render the scene with the provided view metrics\n    renderer.render(scene, view.viewCamera.baseCamera, target);\n  }\n\n  /**\n   * This gathers all the overlap views of every view\n   */\n  private gatherViewDrawDependencies() {\n    this.viewDrawDependencies.clear();\n\n    // Fit all views to viewport\n    for (let i = 0, endi = this.sceneViews.length; i < endi; i++) {\n      this.sceneViews[i].view.fitViewtoViewport(\n        new Bounds({\n          height: this.context.canvas.height,\n          width: this.context.canvas.width,\n          x: 0,\n          y: 0\n        })\n      );\n    }\n\n    // Set viewDrawDependencies\n    for (let i = 0, endi = this.sceneViews.length; i < endi; i++) {\n      const sourceView = this.sceneViews[i].view;\n      const overlapViews: View[] = [];\n\n      for (let j = 0, endj = this.sceneViews.length; j < endj; j++) {\n        if (j !== i) {\n          const targetView = this.sceneViews[j].view;\n\n          if (sourceView.viewBounds.hitBounds(targetView.viewBounds)) {\n            overlapViews.push(targetView);\n          }\n        }\n      }\n\n      this.viewDrawDependencies.set(sourceView, overlapViews);\n    }\n  }\n\n  /**\n   * This allows for querying a view's screen bounds. Null is returned if the view id\n   * specified does not exist.\n   */\n  getViewSize(viewId: string): Bounds | null {\n    for (const sceneView of this.sceneViews) {\n      if (sceneView.view.id === viewId) {\n        return sceneView.view.screenBounds;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * This queries a view's window into a world's space.\n   */\n  getViewWorldBounds(viewId: string): Bounds | null {\n    for (const sceneView of this.sceneViews) {\n      if (sceneView.view.id === viewId) {\n        const view = sceneView.view;\n\n        if (view.screenBounds) {\n          const topLeft = view.viewToWorld([0, 0]);\n          const bottomRight = view.screenToWorld([\n            view.screenBounds.right,\n            view.screenBounds.bottom\n          ]);\n\n          return new Bounds({\n            bottom: bottomRight[1],\n            left: topLeft[0],\n            right: bottomRight[0],\n            top: topLeft[1]\n          });\n        } else {\n          return null;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * This is the beginning of the system. This should be called immediately after the surface is constructed.\n   * We make this mandatory outside of the constructor so we can make it follow an async pattern.\n   */\n  async init(options: ILayerSurfaceOptions) {\n    // Make sure our desired pixel ratio is set up\n    this.pixelRatio = options.pixelRatio || this.pixelRatio;\n\n    if (this.pixelRatio < 1.0) {\n      this.pixelRatio = 1.0;\n    }\n\n    // Make sure we have a gl context to work with\n    this.setContext(options.context);\n\n    if (this.gl) {\n      // Initialize our GL needs that set the basis for rendering\n      this.initGL(options);\n      // Initialize our event manager that handles mouse interactions/gestures with the canvas\n      this.initMouseManager(options);\n      // Initialize any resources requested or needed, such as textures or rendering surfaces\n      await this.initResources(options);\n    } else {\n      console.warn(\n        \"Could not establish a GL context. Layer Surface will be unable to render\"\n      );\n    }\n\n    return this;\n  }\n\n  /**\n   * This initializes the Canvas GL contexts needed for rendering.\n   */\n  private initGL(options: ILayerSurfaceOptions) {\n    if (!this.context) {\n      console.error(\n        \"Can not initialize Layer Surface as a valid GL context was not established.\"\n      );\n      return;\n    }\n\n    // Get the canvas of our context to set up our Three settings\n    const canvas = this.context.canvas;\n    // Get the starting width and height so adjustments don't affect it\n    const width = canvas.width;\n    const height = canvas.height;\n\n    // Generate the renderer along with it's properties\n    this.renderer = new Three.WebGLRenderer({\n      // Context supports rendering to an alpha canvas only if the background color has a transparent\n      // Alpha value.\n      alpha: options.background && options.background[3] < 1.0,\n      // Yes to antialias! Make it preeeeetty!\n      antialias: true,\n      // Make three use an existing canvas rather than generate another\n      canvas,\n      // TODO: This should be toggleable. If it's true it allows us to snapshot the rendering in the canvas\n      //       But we dont' always want it as it makes performance drop a bit.\n      preserveDrawingBuffer: true\n    });\n\n    // Generate a renderer for the picking pass\n    this.pickingRenderer = new Three.WebGLRenderer({\n      // Context supports rendering to an alpha canvas only if the background color has a transparent\n      // Alpha value.\n      alpha: false,\n      // Picking shall not\n      antialias: false,\n      // Do not need this for picking\n      preserveDrawingBuffer: true\n    });\n\n    // NOTE: Uncomment this plus remove this.pickingTarget from the drawSceneView of the color picking pass\n    // to view the colors rendered to the color picking buffer. This disables the interactions but helps\n    // debug what's going on with shaders etc\n    // canvas.parentNode.appendChild(this.pickingRenderer.getContext().canvas);\n\n    // We want clearing to be controlled via the layer\n    this.renderer.autoClear = false;\n\n    // This sets the pixel ratio to handle differing pixel densities in screens\n    this.setRendererSize(width, height);\n    // Set the pixel ratio to match the pixel density of the monitor in use\n    this.renderer.setPixelRatio(this.pixelRatio);\n\n    // Applies the background color and establishes whether or not the context supports\n    // Alpha or not\n    if (options.background) {\n      this.renderer.setClearColor(\n        new Three.Color(\n          options.background[0],\n          options.background[1],\n          options.background[2]\n        ),\n        options.background[3]\n      );\n    } else {\n      // If a background color was not established, then we set a default background color\n      this.renderer.setClearColor(DEFAULT_BACKGROUND_COLOR);\n    }\n\n    // We want clearing to be controlled via the layer\n    this.pickingRenderer.autoClear = false;\n    // Picking does not need retina style precision\n    this.pickingRenderer.setPixelRatio(1.0);\n    // Applies the background color and establishes whether or not the context supports\n    // Alpha or not\n    this.pickingRenderer.setClearColor(new Three.Color(0, 0, 0), 1);\n\n    // Make a scene view depth tracker so we can track the order each scene view combo is drawn\n    let sceneViewDepth = 0;\n\n    // Turn on the scissor test to keep the rendering clipped within the\n    // Render region of the context\n    this.context.enable(this.context.SCISSOR_TEST);\n\n    // Add the requested scenes to the surface and apply the necessary defaults\n    if (options.scenes) {\n      options.scenes.forEach(sceneOptions => {\n        // Make us a new scene based on the requested options\n        const newScene = new Scene(sceneOptions);\n        // Use defaultSceneElement to set cameras\n        const defaultSceneElement = generateDefaultScene(this.context);\n        // Generate the views requested for the scene\n        sceneOptions.views.forEach(viewOptions => {\n          const newView = new View(viewOptions);\n          newView.camera = newView.camera || defaultSceneElement.camera;\n          newView.viewCamera =\n            newView.viewCamera || defaultSceneElement.viewCamera;\n          newView.pixelRatio = this.pixelRatio;\n          newScene.addView(newView);\n\n          for (const sceneView of this.sceneViews) {\n            if (sceneView.view.id === newView.id) {\n              console.warn(\n                \"You can NOT have two views with the same id. Please use unique identifiers for every view generated.\"\n              );\n            }\n          }\n\n          this.sceneViews.push({\n            depth: ++sceneViewDepth,\n            scene: newScene,\n            view: newView\n          });\n        });\n\n        this.scenes.set(sceneOptions.key, newScene);\n      });\n\n      this.gatherViewDrawDependencies();\n    }\n  }\n\n  /**\n   * This does special initialization by gathering the layers shader IO, generates a material\n   * and injects special automated uniforms and attributes to make instancing work for the\n   * shader.\n   */\n  private initLayer<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>\n  ): Layer<T, U> | null {\n    // Set the layer's parent surface here\n    layer.surface = this;\n    // Set the resource manager this surface utilizes to the layer\n    layer.resource = this.resourceManager;\n    // For the sake of initializing uniforms to the correct values, we must first add the layer to it's appropriate\n    // Scene so that the necessary values will be in place for the sahder IO\n    const scene = this.addLayerToScene(layer);\n    if (!scene) return null;\n    // Get the shader metrics the layer desires\n    const shaderIO = layer.initShader();\n    // Clean out nulls provided as a convenience to the layer\n    shaderIO.instanceAttributes = (shaderIO.instanceAttributes || []).filter(\n      Boolean\n    );\n    shaderIO.vertexAttributes = (shaderIO.vertexAttributes || []).filter(\n      Boolean\n    );\n    shaderIO.uniforms = (shaderIO.uniforms || []).filter(Boolean);\n\n    // Generate the actual shaders to be used by injecting all of the necessary fragments and injecting\n    // Instancing fragments\n    const shaderMetrics = new ShaderProcessor().process(layer, shaderIO);\n    // Check to see if the Shader Processing failed. If so return null as a failure flag.\n    if (!shaderMetrics) return null;\n\n    // Retrieve all of the attributes created as a result of layer input and module processing.\n    const { vertexAttributes, instanceAttributes, uniforms } = shaderMetrics;\n\n    // Generate the geometry this layer will be utilizing\n    const geometry = generateLayerGeometry(\n      layer,\n      shaderMetrics.maxInstancesPerBuffer,\n      vertexAttributes,\n      shaderIO.vertexCount\n    );\n    // This is the material that is generated for the layer that utilizes all of the generated and\n    // Injected shader IO and shader fragments\n    const material = generateLayerMaterial(\n      layer,\n      shaderMetrics.vs,\n      shaderMetrics.fs,\n      uniforms,\n      shaderMetrics.materialUniforms\n    );\n    // And now we can now generate the mesh that will be added to the scene\n    const model = generateLayerModel(layer, geometry, material);\n\n    // Now that all of the elements of the layer are complete, let us apply them to the layer\n    layer.geometry = geometry;\n    layer.instanceAttributes = instanceAttributes;\n    layer.instanceVertexCount = shaderIO.vertexCount;\n    layer.material = material;\n    layer.maxInstancesPerBuffer = shaderMetrics.maxInstancesPerBuffer;\n    layer.model = model;\n    layer.uniforms = uniforms;\n    layer.vertexAttributes = vertexAttributes;\n\n    // Generate the correct buffering strategy for the layer\n    makeLayerBufferManager(this.gl, layer, scene);\n\n    if (layer.props.printShader) {\n      console.warn(\n        \"A Layer requested its shader be debugged. Do not leave this active for production:\",\n        \"Layer:\",\n        layer.props.key,\n        \"Shader Metrics\",\n        shaderMetrics\n      );\n      console.warn(\"\\n\\nVERTEX SHADER\\n--------------\\n\\n\", shaderMetrics.vs);\n      console.warn(\"\\n\\nFRAGMENT SHADER\\n--------------\\n\\n\", shaderMetrics.fs);\n    }\n\n    return layer;\n  }\n\n  /**\n   * Initializes elements for handling mouse interactions with the canvas.\n   */\n  private initMouseManager(options: ILayerSurfaceOptions) {\n    // We must inject an event manager to broadcast events through the layers themselves\n    const eventManagers: EventManager[] = ([\n      new LayerMouseEvents(this)\n    ] as EventManager[]).concat(options.eventManagers || []);\n\n    // Generate the mouse manager for the layer\n    this.mouseManager = new MouseEventManager(\n      this.context.canvas,\n      this.sceneViews,\n      eventManagers,\n      options.handlesWheelEvents\n    );\n  }\n\n  /**\n   * This initializes resources needed or requested such as textures or render surfaces.\n   */\n  private async initResources(options: ILayerSurfaceOptions) {\n    // Tell our manager to generate all of the atlas' requested for surface\n    if (options.atlasResources) {\n      for (const resource of options.atlasResources) {\n        await this.atlasManager.createAtlas(resource);\n      }\n    }\n\n    // Initialize our resource manager with the atlas manager\n    this.resourceManager = new AtlasResourceManager({\n      atlasManager: this.atlasManager\n    });\n  }\n\n  /**\n   * This finds the scene and view the layer belongs to based on the layer's props. For invalid or not provided\n   * props, the layer gets added to default scenes and views.\n   */\n  private addLayerToScene<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>\n  ): Scene | undefined {\n    // Get the scene the layer will add itself to\n    const scene = this.scenes.get(layer.props.scene || \"\");\n\n    if (!scene) {\n      console.warn(\n        \"No scene is specified by the layer, or the scene identifier is invalid\"\n      );\n    } else {\n      // Add the layer to the scene for rendering\n      scene.addLayer(layer);\n    }\n\n    return scene;\n  }\n\n  /**\n   * Discontinues a layer's management by this surface. This will invalidate any resources\n   * the layer was using in association with the context. If the layer is re-insertted, it will\n   * be revaluated as though it were a new layer.\n   */\n  private removeLayer<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U> | null\n  ): Layer<T, U> | null {\n    // Make sure we are removing a layer that exists in the system\n    if (!layer) {\n      return null;\n    }\n    if (!this.layers.get(layer && layer.id)) {\n      console.warn(\n        \"Tried to remove a layer that is not in the manager.\",\n        layer\n      );\n      return layer;\n    }\n\n    layer.destroy();\n    this.layers.delete(layer.id);\n\n    return layer;\n  }\n\n  /**\n   * Used for reactive rendering and diffs out the layers for changed layers.\n   */\n  render(layerInitializers: LayerInitializer[]) {\n    if (!this.gl) return;\n\n    // Loop through all of the initializers and properly add and remove layers as needed\n    if (layerInitializers && layerInitializers.length > 0) {\n      layerInitializers.forEach(init => {\n        const layerClass = init[0];\n        const props = init[1];\n        const existingLayer = this.layers.get(props.key);\n\n        if (existingLayer) {\n          existingLayer.willUpdateProps(props);\n\n          // If we have a provider that is about to be newly set to the layer, then the provider\n          // needs to do a full sync in order to have existing\n          if (props.data !== existingLayer.props.data) {\n            props.data.sync();\n          }\n\n          // Check to see if the layer is going to require it's view to be redrawn based on the props for the Layer changing,\n          // or by custom logic of the layer.\n          if (existingLayer.shouldDrawView(existingLayer.props, props)) {\n            existingLayer.needsViewDrawn = true;\n          }\n\n          Object.assign(existingLayer.props, props);\n          existingLayer.initializer[1] = existingLayer.props;\n          existingLayer.didUpdateProps();\n        } else {\n          // Generate the new layer and provide it it's initial props\n          const layer = new layerClass(\n            Object.assign({}, layerClass.defaultProps, props)\n          );\n          // Keep the initializer object that generated the layer for reference and debugging\n          layer.initializer = init;\n          // Sync the data provider applied to the layer in case the provider has existing data\n          // before being applied tot he layer\n          layer.props.data.sync();\n\n          // Add the layer to this surface\n          if (!this.addLayer(layer)) {\n            console.warn(\n              \"Error initializing layer:\",\n              props.key,\n              \"A layer was unable to be added to the surface. See previous warnings (if any) to determine why they could not be instantiated\"\n            );\n\n            return;\n          }\n        }\n\n        this.willDisposeLayer.set(props.key, false);\n      });\n    }\n\n    // Take any layer that retained it's disposal flag and trash it\n    this.willDisposeLayer.forEach((dispose, layerId) => {\n      if (dispose) {\n        const layer = this.layers.get(layerId);\n        if (layer) {\n          this.removeLayer(layer);\n        } else {\n          console.warn(\n            \"this.willDisposeLayer applied to a layer that does not exist in the existing layer check.\"\n          );\n        }\n      }\n    });\n\n    // Resolve that all disposals occurred\n    this.willDisposeLayer.clear();\n\n    // Reflag every layer for removal again so creation of layers will determine\n    // Which layers remain for a reactive pattern\n    this.layers.forEach((_layer, id) => {\n      this.willDisposeLayer.set(id, true);\n    });\n  }\n\n  /**\n   * This must be executed when the canvas changes size so that we can re-calculate the scenes and views\n   * dimensions for handling all of our rendered elements.\n   */\n  fitContainer(_pixelRatio?: number) {\n    const container = this.context.canvas.parentElement;\n\n    if (container) {\n      const canvas = this.context.canvas;\n      canvas.className = \"\";\n      canvas.setAttribute(\"style\", \"\");\n      container.style.position = \"relative\";\n      canvas.style.position = \"absolute\";\n      canvas.style.left = \"0xp\";\n      canvas.style.top = \"0xp\";\n      canvas.style.width = \"100%\";\n      canvas.style.height = \"100%\";\n      canvas.setAttribute(\"width\", \"\");\n      canvas.setAttribute(\"height\", \"\");\n      const containerBox = container.getBoundingClientRect();\n      const box = canvas.getBoundingClientRect();\n\n      this.resize(box.width || 100, containerBox.height || 100);\n    }\n  }\n\n  /**\n   * This resizes the canvas and retains pixel ratios amongst all of the resources involved.\n   */\n  resize(width: number, height: number, pixelRatio?: number) {\n    this.pixelRatio = pixelRatio || this.pixelRatio;\n\n    if (this.pixelRatio < 1.0) {\n      this.pixelRatio = 1.0;\n    }\n\n    this.sceneViews.forEach(\n      sceneView => (sceneView.view.pixelRatio = this.pixelRatio)\n    );\n    this.setRendererSize(width, height);\n    this.renderer.setPixelRatio(this.pixelRatio);\n    this.pickingRenderer.setPixelRatio(1.0);\n    this.mouseManager.resize();\n    this.gatherViewDrawDependencies();\n  }\n\n  /**\n   * This establishes the rendering canvas context for the surface.\n   */\n  private setContext(\n    context?: WebGLRenderingContext | HTMLCanvasElement | string\n  ) {\n    if (!context) {\n      return;\n    }\n\n    if (isWebGLContext(context)) {\n      this.context = context;\n    } else if (isCanvas(context)) {\n      const canvasContext =\n        context.getContext(\"webgl\") || context.getContext(\"experimental-webgl\");\n\n      if (!canvasContext) {\n        console.warn(\n          \"A valid GL context was not found for the context provided to the surface. This surface will not be able to operate.\"\n        );\n      } else {\n        this.context = canvasContext;\n      }\n    } else if (isString(context)) {\n      const element = document.getElementById(context);\n\n      if (isCanvas(element)) {\n        this.setContext(element);\n      }\n    }\n  }\n\n  /**\n   * This applies a new size to the renderer and resizes any additional resources that requires being\n   * sized along with the renderer.\n   */\n  private setRendererSize(width: number, height: number) {\n    width = width || 100;\n    height = height || 100;\n\n    this.renderer.setSize(width, height);\n    this.pickingRenderer.setSize(width, height);\n\n    if (!this.pickingTarget) {\n      this.pickingTarget = new WebGLRenderTarget(width, height, {\n        magFilter: Three.LinearFilter,\n        minFilter: Three.LinearFilter,\n        stencilBuffer: false\n      });\n    }\n\n    this.pickingTarget.setSize(width, height);\n  }\n\n  /**\n   * This triggers an update to all of the layers that perform picking, the pixel data\n   * within the specified mouse range.\n   */\n  updateColorPickRange(mouse: Vec2, views: View[]) {\n    // We will flag the color range as needing an update\n    this.updateColorPick = {\n      mouse,\n      views\n    };\n  }\n}\n","export * from \"./layer-surface\";\nexport * from \"./event-manager\";\nexport * from \"./layer-processing/generate-default-scene\";\nexport * from \"./layer-processing/generate-layer-geometry\";\nexport * from \"./layer-processing/generate-layer-material\";\nexport * from \"./layer-processing/generate-layer-model\";\nexport * from \"./layer-processing/inject-shader-io\";\nexport * from \"./layer\";\nexport * from \"./mouse-event-manager\";\nexport * from \"./scene\";\nexport * from \"./texture\";\nexport * from \"./view\";\n","module.exports = \"precision highp float;\\n\\n${import: projection}\\n\\nvarying vec4 vertexColor;\\nvarying float edgeSharpness;\\nvarying float borderSize;\\nvarying vec2 pointCoord;\\n${extendHeader}\\n\\nvarying float scale;\\n\\nvoid main() {\\n  ${attributes}\\n\\n  scale = scaleFactor;\\n\\n  vertexColor = color;\\n  float size = radius * scaleFactor;\\n\\n  float ringWidth = mix(2.0 , thickness, float(thickness > 2.0));\\n\\n  borderSize = mix(\\n    (ringWidth) / size,\\n    ((ringWidth * pixelRatio) / size),\\n    float(pixelRatio > 1.0)\\n  );\\n\\n  edgeSharpness = min(0.2 / (ringWidth * scale),  0.1);\\n\\n  pointCoord = (position.xy + vec2(1.0, 1.0)) / 2.0;\\n\\n  // Center within clip space\\n  vec4 clipCenter = clipSpace(vec3(center, depth));\\n  // Center in screen space\\n  vec2 screenCenter = (clipCenter.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\n  // Position in screen space\\n  vec2 vertex = (position.xy * size) + screenCenter;\\n  // Position back to clip space\\n  gl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), clipCenter.zw);\\n  ${extend}\\n}\\n\"","module.exports = \"precision highp float;\\n\\n/** This is the color of the ring */\\nvarying vec4 vertexColor;\\n/**\\n * This is how sharp the ring renders. For tiny rings, it's best to have\\n * less sharpness to better convey the shape of a circle. A good starter setting:\\n * edgeSharpness = mix(0.8, 0.01, min(gl_PointSize / 45.0, 1.0));\\n */\\nvarying float edgeSharpness;\\n/**\\n * This should be a value that sets the thickness of the ring in normal space\\n * relative to the PointSize\\n */\\nvarying float borderSize;\\n/**\\n * Since this is now a quad instead of a point sprite, this provides what gl_PointCoord\\n * used to provide.\\n */\\nvarying vec2 pointCoord;\\n\\nvarying float scale;\\n\\nfloat circle(vec2 coord, float radius){\\n  vec2 dist = coord - vec2(0.5);\\n\\n  return 1.0 - smoothstep(\\n    radius - (radius * edgeSharpness),\\n    radius,\\n    dot(dist, dist) * 4.0\\n  );\\n\\n}\\n\\n${extendHeader}\\n\\nvoid main() {\\n  float outer_step_factor = circle(pointCoord, 1.0);\\n  float inner_step_factor = circle(pointCoord, 1.0 - borderSize * scale);\\n\\n  setColor(mix(\\n    mix(                        // Select the outer color outside of the inner radius\\n      vec4(0.0, 0.0, 0.0, 0.0),    // Select invisible outside of inner and outer radius\\n      vertexColor,                  // Select outer color outside of inner, but inside outer\\n      outer_step_factor\\n    ),\\n    vec4(0.0, 0.0, 0.0, 0.0),                 // Select inner color inside inner\\n    inner_step_factor\\n  ));\\n\\n  ${extend}\\n}\\n\"","import * as Three from \"three\";\nimport { InstanceProvider } from \"../../instance-provider\";\nimport { Bounds } from \"../../primitives\";\nimport { ILayerProps, IModelType, Layer } from \"../../surface/layer\";\nimport {\n  IMaterialOptions,\n  InstanceAttributeSize,\n  IProjection,\n  IShaderInitialization,\n  IUniform,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../types\";\nimport {\n  CommonMaterialOptions,\n  dot2,\n  IAutoEasingMethod,\n  subtract2,\n  Vec,\n  Vec2\n} from \"../../util\";\nimport { RingInstance } from \"./ring-instance\";\nconst { max } = Math;\n\nexport interface IRingLayerProps<T extends RingInstance>\n  extends ILayerProps<T> {\n  /** This sets a scaling factor for the circle's radius */\n  scaleFactor?(): number;\n  animate?: {\n    color?: IAutoEasingMethod<Vec>;\n    center?: IAutoEasingMethod<Vec>;\n    radius?: IAutoEasingMethod<Vec>;\n  };\n}\n\n/**\n * This layer displays circles and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class RingLayer<\n  T extends RingInstance,\n  U extends IRingLayerProps<T>\n> extends Layer<T, U> {\n  static defaultProps: IRingLayerProps<RingInstance> = {\n    key: \"\",\n    data: new InstanceProvider<RingInstance>(),\n    scene: \"default\"\n  };\n\n  static attributeNames = {\n    center: \"center\",\n    radius: \"radius\",\n    depth: \"depth\",\n    color: \"color\",\n    thickness: \"thickness\"\n  };\n\n  /**\n   * We provide bounds and hit test information for the instances for this layer to allow for mouse picking\n   * of elements\n   */\n  getInstancePickingMethods() {\n    return {\n      // Provide the calculated AABB world bounds for a given circle\n      boundsAccessor: (ring: RingInstance) =>\n        new Bounds({\n          height: ring.radius * 2,\n          width: ring.radius * 2,\n          x: ring.center[0] - ring.radius,\n          y: ring.center[1] - ring.radius\n        }),\n\n      // Provide a precise hit test for the ring\n      hitTest: (ring: RingInstance, point: Vec2, view: IProjection) => {\n        const r = ring.radius / max(...view.camera.scale);\n        const delta = subtract2(point, ring.center);\n\n        return dot2(delta, delta) < r * r;\n      }\n    };\n  }\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<RingInstance> {\n    const scaleFactor = this.props.scaleFactor || (() => 1);\n    const animations = this.props.animate || {};\n    const {\n      color: animateColor,\n      center: animateCenter,\n      radius: animateRadius\n    } = animations;\n\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: -1,\n      1: -1,\n      2: -1,\n      3: 1,\n      4: 1,\n      5: 1\n    };\n\n    return {\n      fs: require(\"./ring-layer.fs\"),\n      instanceAttributes: [\n        {\n          easing: animateCenter,\n          name: RingLayer.attributeNames.center,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.center\n        },\n        {\n          easing: animateRadius,\n          name: RingLayer.attributeNames.radius,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.radius]\n        },\n        {\n          name: RingLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        {\n          easing: animateColor,\n          name: RingLayer.attributeNames.color,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.color\n        },\n        {\n          name: RingLayer.attributeNames.thickness,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.thickness]\n        }\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: (_: IUniform) => [scaleFactor()]\n        }\n      ],\n      vertexAttributes: [\n        // TODO: This is from the heinous evils of THREEJS and their inability to fix a bug within our lifetimes.\n        // Right now position is REQUIRED in order for rendering to occur, otherwise the draw range gets updated to\n        // Zero against your wishes.\n        {\n          name: \"position\",\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexToSide[vertex],\n            0\n          ]\n        }\n      ],\n      vertexCount: 6,\n      vs: require(\"./ring-layer.vs\")\n    };\n  }\n\n  getModelType(): IModelType {\n    return {\n      drawMode: Three.TriangleStripDrawMode,\n      modelType: Three.Mesh\n    };\n  }\n\n  getMaterialOptions(): IMaterialOptions {\n    return CommonMaterialOptions.transparentShape;\n  }\n}\n","import { IInstanceOptions, Instance } from \"../../instance-provider/instance\";\nimport { observable } from \"../../instance-provider/observable\";\nimport { Vec2 } from \"../../util\";\n\nexport interface IRingInstanceOptions extends IInstanceOptions {\n  /** The center of the ring */\n  center?: Vec2;\n  /** The color of this ring */\n  color?: [number, number, number, number];\n  /** The z depth of the ring (for draw ordering) */\n  depth?: number;\n  /** The outer radius of the ring */\n  radius?: number;\n  /** The thickness of the ring */\n  thickness?: number;\n}\n\nexport class RingInstance extends Instance {\n  @observable color: [number, number, number, number] = [1.0, 1.0, 1.0, 1.0];\n  @observable depth: number = 0;\n  @observable radius: number = 0;\n  @observable thickness: number = 1;\n  @observable center: Vec2 = [0, 0];\n\n  constructor(options: IRingInstanceOptions) {\n    super(options);\n\n    this.color = options.color || this.color;\n    this.depth = options.depth || this.depth;\n    this.radius = options.radius || this.radius;\n    this.thickness = options.thickness || this.thickness;\n    this.center = options.center || this.center;\n  }\n\n  get width() {\n    return this.radius * 2;\n  }\n\n  get height() {\n    return this.radius * 2;\n  }\n\n  get innerRadius() {\n    return this.radius - this.thickness;\n  }\n}\n","export * from \"./ring-instance\";\nexport * from \"./ring-layer\";\n","import { observable } from \"../../instance-provider\";\nimport { IInstanceOptions, Instance } from \"../../instance-provider/instance\";\nimport { Anchor, AnchorType, ScaleType } from \"../types\";\n\nexport interface IRectangleInstanceOptions extends IInstanceOptions {\n  /**\n   * The point on the rectangle which will be placed in world space via the x, y coords. This is also the point\n   * which the rectangle will be scaled around.\n   */\n  anchor?: Anchor;\n  /** Depth sorting of the rectangle (or the z value of the lable) */\n  depth?: number;\n  /** The height of the rectangle as it is to be rendered in world space */\n  height?: number;\n  /** Sets the way the rectangle scales with the world */\n  scaling?: ScaleType;\n  /** The color the rectangle should render as */\n  color: [number, number, number, number];\n  /** The width of the rectangle as it is to be rendered in world space */\n  width?: number;\n  /** The x coordinate where the rectangle will be anchored to in world space */\n  x?: number;\n  /** The y coordinate where the rectangle will be anchored to in world space */\n  y?: number;\n}\n\n/**\n * This is a lookup to quickly find the proper calculation for setting the correct anchor\n * position based on the anchor type.\n */\nconst anchorCalculator: {\n  [key: number]: (anchor: Anchor, rectangle: RectangleInstance) => void;\n} = {\n  [AnchorType.TopLeft]: (anchor: Anchor, _rectangle: RectangleInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopMiddle]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.width / 2.0;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopRight]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.width + anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.MiddleLeft]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = rectangle.height / 2;\n  },\n  [AnchorType.Middle]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.width / 2.0;\n    anchor.y = rectangle.height / 2.0;\n  },\n  [AnchorType.MiddleRight]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.width + anchor.padding;\n    anchor.y = rectangle.height / 2.0;\n  },\n  [AnchorType.BottomLeft]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = rectangle.height + anchor.padding;\n  },\n  [AnchorType.BottomMiddle]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.width / 2.0;\n    anchor.y = rectangle.height + anchor.padding;\n  },\n  [AnchorType.BottomRight]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.width + anchor.padding;\n    anchor.y = rectangle.height + anchor.padding;\n  },\n  [AnchorType.Custom]: (anchor: Anchor, _rectangle: RectangleInstance) => {\n    anchor.x = anchor.x || 0;\n    anchor.y = anchor.y || 0;\n  }\n};\n\n/**\n * This generates a new rectangle instance which will render a single line of text for a given layer.\n * There are restrictions surrounding rectangles due to texture sizes and rendering limitations.\n *\n * Currently, we only support rendering a rectangle via canvas, then rendering it to an Atlas texture\n * which is used to render to cards in the world for rendering. This is highly performant, but means:\n *\n * - Rectangles should only be so long.\n * - Multiline is not supported inherently\n * - Once a rectangle is constructed, only SOME properties can be altered thereafter\n *\n * A rectangle that is constructed can only have some properties set upon creating the rectangle and are locked\n * thereafter. The only way to modify them would be to destroy the rectangle, then construct a new rectangle\n * with the modifications. This has to deal with performance regarding rasterizing the rectangle\n */\nexport class RectangleInstance extends Instance {\n  /** This is the rendered color of the rectangle */\n  @observable color: [number, number, number, number] = [0, 0, 0, 1];\n  /** Depth sorting of the rectangle (or the z value of the lable) */\n  @observable depth: number = 0;\n  /** The height of the rectangle as it is to be rendered in world space */\n  @observable height: number = 1;\n  /** When in BOUND_MAX mode, this allows the rectangle to scale up beyond it's max size */\n  @observable maxScale: number = 1;\n  /** Scales the rectangle uniformly */\n  @observable scale: number = 1;\n  /** Sets the way the rectangle scales with the world */\n  @observable scaling: ScaleType = ScaleType.BOUND_MAX;\n  /** The width of the rectangle as it is to be rendered in world space */\n  @observable width: number = 1;\n  /** The x coordinate where the rectangle will be anchored to in world space */\n  @observable x: number = 0;\n  /** The y coordinate where the rectangle will be anchored to in world space */\n  @observable y: number = 0;\n\n  // These are properties that can be altered, but have side effects from being changed\n\n  /** This is the anchor location on the  */\n  @observable\n  private _anchor: Anchor = {\n    padding: 0,\n    type: AnchorType.TopLeft,\n    x: 0,\n    y: 0\n  };\n\n  constructor(options: IRectangleInstanceOptions) {\n    super(options);\n\n    this.depth = options.depth || this.depth;\n    this.color = options.color || this.color;\n    this.scaling = options.scaling || this.scaling;\n    this.x = options.x || this.x;\n    this.y = options.y || this.y;\n    this.width = options.width || 1;\n    this.height = options.height || 1;\n\n    // Make sure the anchor is set to the appropriate location\n    options.anchor && this.setAnchor(options.anchor);\n  }\n\n  get anchor() {\n    return this._anchor;\n  }\n\n  /**\n   * This applies a new anchor to this rectangle and properly determines it's anchor position on the rectangle\n   */\n  setAnchor(anchor: Anchor) {\n    const newAnchor = {\n      padding: anchor.padding || 0,\n      type: anchor.type,\n      x: anchor.x || 0,\n      y: anchor.y || 0\n    };\n\n    // Calculate the new anchors position values\n    anchorCalculator[newAnchor.type](newAnchor, this);\n    // Apply the anchor\n    this._anchor = newAnchor;\n  }\n}\n","module.exports = \"${import: projection}\\n\\nprecision highp float;\\n\\nvarying vec4 vertexColor;\\n${extendHeader}\\n\\nvoid main() {\\n  ${attributes}\\n\\n  // Determine final screen size of label\\n  vec3 screenSize = cameraSpaceSize(vec3(size * scale / maxScale, 1.0));\\n\\n  // Test whether the label is larger on the screen than the font size\\n  bool largerOnScreen = screenSize.y > size.y || screenSize.x > size.x;\\n\\n  // Determines if a scale mode should be used or not for the vertex\\n  float useScaleMode = float(\\n    (\\n      scaling == 3.0 ||                  // NEVER mode - keep the image the same size always\\n      (largerOnScreen && scaling == 2.0) // BOUND_MAX mode - only if we're larger than the font size do we scale down\\n    ) &&\\n    scaling != 1.0                       // ALWAYS mode - the image stays completely in world space allowing it to scale freely\\n  );\\n\\n  // Correct aspect ratio. Sufficient fix for most applications.\\n  // Will need another solution in the case of:\\n  // (cameraScale y != cameraScale.x) && (cameraScale.x != 1 && cameraScale.y != 1)\\n\\n  // If zooms are unequal, assume one is filtered to be 1.0\\n  float unequalZooms = float(cameraScale.x != cameraScale.y);\\n\\n  vec2 adjustedSize = mix(\\n    size,\\n    (size * cameraScale.yx),\\n    unequalZooms\\n  );\\n\\n  // Destructure threejs's bug with the position requirement\\n  float normal = position.x;\\n  float side = position.y;\\n\\n  vec2 scaledAnchor = anchor * scale;\\n\\n  // Get the location of the anchor in world space\\n  vec2 worldAnchor = location + scaledAnchor;\\n\\n  vec2 adjustedAnchor = mix(\\n    scaledAnchor,\\n    (scaledAnchor * cameraScale.yx),\\n    unequalZooms\\n  );\\n\\n  // Get the position of the current vertex\\n  vec2 vertex = vec2(side, float(normal == 1.0)) * scale * adjustedSize + location - adjustedAnchor;\\n\\n  // See how scaled the size on screen will be from the actual height of the label\\n  float labelScreenScale = mix(\\n    screenSize.y / adjustedSize.y,\\n    screenSize.x / adjustedSize.x,\\n    float((cameraScale.x != 1.0))\\n  );\\n\\n  float currentScale = labelScreenScale * scale;\\n\\n  // If our screen rendering is larger than the size the label is supposed to be, then we automagically\\n  // scale down our label to stay the correct size, centered on the anchor point\\n  vec2 anchorToVertex = vertex - location;\\n\\n  // We now choose between keeping the same image size or keeping it in world space\\n  vertex = mix(\\n    // This option keeps the image size in world space\\n    vertex,\\n    // This option counters the scaling of the image on the screen keeping it a static size\\n    (anchorToVertex / labelScreenScale) + location,\\n    // This is the flag determining if a scale mode should be applied to the vertex\\n    useScaleMode\\n  );\\n\\n  // --Texture and Color\\n  // Apply the label's color as a tint to the label (all labels are rendered white to the base texture)\\n  vertexColor = color;\\n\\n  gl_Position = clipSpace(vec3(vertex, depth));\\n  ${extend}\\n}\\n\"","module.exports = \"precision highp float;\\n\\nvarying vec4 vertexColor;\\n${extendHeader}\\n\\nvoid main() {\\n  setColor(vertexColor);\\n  ${extend}\\n}\\n\"","import * as Three from \"three\";\nimport { InstanceProvider } from \"../../instance-provider\";\nimport { Bounds } from \"../../primitives\";\nimport { ILayerProps, IModelType, Layer } from \"../../surface/layer\";\nimport {\n  IMaterialOptions,\n  InstanceAttributeSize,\n  IProjection,\n  IShaderInitialization,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../types\";\nimport { CommonMaterialOptions, divide2, subtract2, Vec2 } from \"../../util\";\nimport { ScaleType } from \"../types\";\nimport { RectangleInstance } from \"./rectangle-instance\";\n\nconst { min, max } = Math;\n\nexport interface IRectangleLayerProps<T extends RectangleInstance>\n  extends ILayerProps<T> {\n  atlas?: string;\n}\n\n/**\n * This layer displays Rectangles and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class RectangleLayer<\n  T extends RectangleInstance,\n  U extends IRectangleLayerProps<T>\n> extends Layer<T, U> {\n  static defaultProps: IRectangleLayerProps<RectangleInstance> = {\n    key: \"\",\n    data: new InstanceProvider<RectangleInstance>(),\n    scene: \"default\"\n  };\n\n  static attributeNames = {\n    anchor: \"anchor\",\n    color: \"color\",\n    depth: \"depth\",\n    location: \"location\",\n    maxScale: \"maxScale\",\n    scale: \"scale\",\n    scaling: \"scaling\",\n    size: \"size\"\n  };\n\n  /**\n   * We provide bounds and hit test information for the instances for this layer to allow for mouse picking\n   * of elements\n   */\n  getInstancePickingMethods() {\n    return {\n      // Provide the calculated AABB world bounds for a given rectangle\n      boundsAccessor: (rectangle: RectangleInstance) => {\n        const anchorEffect = [0, 0];\n\n        if (rectangle.anchor) {\n          anchorEffect[0] = rectangle.anchor.x || 0;\n          anchorEffect[1] = rectangle.anchor.y || 0;\n        }\n        const topLeft = [\n          rectangle.x - anchorEffect[0],\n          rectangle.y - anchorEffect[1]\n        ];\n\n        return new Bounds({\n          height: rectangle.height,\n          width: rectangle.width,\n          x: topLeft[0],\n          y: topLeft[1]\n        });\n      },\n\n      // Provide a precise hit test for the circle\n      hitTest: (\n        rectangle: RectangleInstance,\n        point: Vec2,\n        projection: IProjection\n      ) => {\n        // The bounds of the rectangle is in world space, but it does not account for the scale mode of the rectangle.\n        // Here, we will apply the scale mode testing to the rectangle\n        const maxScale = max(...projection.camera.scale);\n        const minScale = min(...projection.camera.scale);\n\n        // If we scale always then the rectangle stays within it's initial world bounds at all times\n        if (rectangle.scaling === ScaleType.ALWAYS) {\n          return true;\n        } else if (rectangle.scaling === ScaleType.BOUND_MAX) {\n          // If we scale with bound max, then when the camera zooms in, the bounds will shrink to keep the\n          // Rectangle the same size. If the camera zooms out then the bounds === the world bounds.\n          // We are zooming out. the bounds will stay within the world bounds\n          if (minScale <= 1 && maxScale <= 1) {\n            return true;\n          } else {\n            // We are zooming in. The bounds will shrink to keep the rectangle at max font size\n            // The location is within the world, but we reverse project the anchor spread\n            const anchorEffect = [0, 0];\n\n            if (rectangle.anchor) {\n              anchorEffect[0] = rectangle.anchor.x || 0;\n              anchorEffect[1] = rectangle.anchor.y || 0;\n            }\n\n            const topLeft = [\n              rectangle.x - anchorEffect[0] / maxScale,\n              rectangle.y - anchorEffect[1] / maxScale\n            ];\n\n            // Reverse project the size and we should be within the distorted world coordinates\n            return new Bounds({\n              height: rectangle.height / maxScale,\n              width: rectangle.width / maxScale,\n              x: topLeft[0],\n              y: topLeft[1]\n            }).containsPoint(point);\n          }\n        } else if (rectangle.scaling === ScaleType.NEVER) {\n          // If we never allow the rectangle to scale, then the bounds will grow and shrink to counter the effects\n          // Of the camera zoom\n          // The location is within the world, but we reverse project the anchor spread\n          const anchorEffect: Vec2 = [0, 0];\n\n          if (rectangle.anchor) {\n            anchorEffect[0] = rectangle.anchor.x || 0;\n            anchorEffect[1] = rectangle.anchor.y || 0;\n          }\n\n          const topLeft = subtract2(\n            [rectangle.x, rectangle.y],\n            divide2(anchorEffect, projection.camera.scale)\n          );\n\n          const screenPoint = projection.worldToScreen(point);\n\n          // Reverse project the size and we should be within the distorted world coordinates\n          return new Bounds({\n            height: rectangle.height,\n            width: rectangle.width,\n            x: topLeft[0],\n            y: topLeft[1]\n          }).containsPoint(screenPoint);\n        }\n\n        return true;\n      }\n    };\n  }\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<RectangleInstance> {\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: 0,\n      1: 0,\n      2: 0,\n      3: 1,\n      4: 1,\n      5: 1\n    };\n\n    return {\n      fs: require(\"./rectangle-layer.fs\"),\n      instanceAttributes: [\n        {\n          name: RectangleLayer.attributeNames.location,\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.x, o.y]\n        },\n        {\n          name: RectangleLayer.attributeNames.anchor,\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.anchor.x || 0, o.anchor.y || 0]\n        },\n        {\n          name: RectangleLayer.attributeNames.size,\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.width, o.height]\n        },\n        {\n          name: RectangleLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        {\n          name: RectangleLayer.attributeNames.scaling,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scaling]\n        },\n        {\n          name: RectangleLayer.attributeNames.color,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.color\n        },\n        {\n          name: RectangleLayer.attributeNames.scale,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scale]\n        },\n        {\n          name: RectangleLayer.attributeNames.maxScale,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.maxScale]\n        }\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: _u => [1]\n        }\n      ],\n      vertexAttributes: [\n        // TODO: This is from the heinous evils of THREEJS and their inability to fix a bug within our lifetimes.\n        // Right now position is REQUIRED in order for rendering to occur, otherwise the draw range gets updated to\n        // Zero against your wishes.\n        {\n          name: \"position\",\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexToSide[vertex],\n            0\n          ]\n        }\n      ],\n      vertexCount: 6,\n      vs: require(\"./rectangle-layer.vs\")\n    };\n  }\n\n  getModelType(): IModelType {\n    return {\n      drawMode: Three.TriangleStripDrawMode,\n      modelType: Three.Mesh\n    };\n  }\n\n  getMaterialOptions(): IMaterialOptions {\n    return CommonMaterialOptions.transparentShape;\n  }\n}\n","export * from \"./rectangle-layer\";\nexport * from \"./rectangle-instance\";\n","import { observable } from \"../../instance-provider\";\nimport { IInstanceOptions, Instance } from \"../../instance-provider/instance\";\nimport { Label } from \"../../primitives/label\";\nimport { LabelAtlasResource, LabelRasterizer } from \"../../surface/texture\";\nimport { Vec2 } from \"../../util\";\nimport { Anchor, AnchorType, ScaleType } from \"../types\";\n\nexport interface ILabelInstanceOptions\n  extends IInstanceOptions,\n    Partial<Label> {\n  /**\n   * The point on the label which will be placed in world space via the x, y coords. This is also the point\n   * which the label will be scaled around.\n   */\n  anchor?: Anchor;\n  /** The color the label should render as */\n  color: [number, number, number, number];\n  /** Depth sorting of the label (or the z value of the label) */\n  depth?: number;\n  /** The font of the label */\n  fontFamily?: string;\n  /** The font size of the label in px */\n  fontSize?: number;\n  /** Stylization of the font */\n  fontStyle?: Label[\"fontStyle\"];\n  /** The weight of the font */\n  fontWeight?: Label[\"fontWeight\"];\n  /** When this is set labels will only draw the label up to this size. If below, the label will automatically truncate with ellipses */\n  maxWidth?: number;\n  /** When in BOUND_MAX mode, this allows the label to scale up beyond it's max size */\n  maxScale?: number;\n  /** This allows for control over rasterization to the atlas */\n  rasterization?: {\n    /**\n     * This is the scale of the rasterization on the atlas. Higher numbers increase atlas usage, but can provide\n     * higher quality render outputs to the surface.\n     */\n    scale: number;\n  };\n  /** Sets the way the label scales with the world */\n  scaling?: ScaleType;\n  /** Scales the label uniformly */\n  scale?: number;\n  /** This will be the text that should render with  */\n  text: string;\n  /** The x coordinate where the label will be anchored to in world space */\n  position: Vec2;\n}\n\n/** This is to make a clear type that references label text values */\ntype TextValue = string;\n/** This is to make a clear type that references label css font values */\ntype CSSFont = string;\n/**\n * This is a reference for a rasterization that has reference counting. When the references go to zero,\n * the rasterization should be invalidated and resources freed for the rasterization.\n */\ntype RasterizationReference = {\n  resource: LabelAtlasResource;\n  references: number;\n};\n\n/**\n * This is a lookup to find existing rasterizations for a particularly created label so that every\n * new label does not have to go through the rasterization process.\n */\nconst rasterizationLookUp = new Map<\n  TextValue,\n  Map<CSSFont, RasterizationReference>\n>();\n\n/**\n * This is a lookup to quickly find the proper calculation for setting the correct anchor\n * position based on the anchor type.\n */\nconst anchorCalculator: {\n  [key: number]: (anchor: Anchor, label: LabelInstance) => void;\n} = {\n  [AnchorType.TopLeft]: (anchor: Anchor, _label: LabelInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopMiddle]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.width / 2.0;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopRight]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.width + anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.MiddleLeft]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = label.height / 2;\n  },\n  [AnchorType.Middle]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.width / 2.0;\n    anchor.y = label.height / 2.0;\n  },\n  [AnchorType.MiddleRight]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.width + anchor.padding;\n    anchor.y = label.height / 2.0;\n  },\n  [AnchorType.BottomLeft]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = label.height + anchor.padding;\n  },\n  [AnchorType.BottomMiddle]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.width / 2.0;\n    anchor.y = label.height + anchor.padding;\n  },\n  [AnchorType.BottomRight]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.width + anchor.padding;\n    anchor.y = label.height + anchor.padding;\n  },\n  [AnchorType.Custom]: (anchor: Anchor, _label: LabelInstance) => {\n    anchor.x = anchor.x || 0;\n    anchor.y = anchor.y || 0;\n  }\n};\n\n/**\n * This generates a new label instance which will render a single line of text for a given layer.\n * There are restrictions surrounding labels due to texture sizes and rendering limitations.\n *\n * Currently, we only support rendering a label via canvas, then rendering it to an Atlas texture\n * which is used to render to cards in the world for rendering. This is highly performant, but means:\n *\n * - Labels should only be so long.\n * - Multiline is not supported inherently\n * - Once a label is constructed, only SOME properties can be altered thereafter\n *\n * A label that is constructed can only have some properties set upon creating the label and are locked\n * thereafter. The only way to modify them would be to destroy the label, then construct a new label\n * with the modifications. This has to deal with performance regarding rasterizing the label\n */\nexport class LabelInstance extends Instance implements Label {\n  /**\n   * TODO: We should be implementing the destroy on LabelInstances to clean this up\n   * Frees up module scoped data.\n   */\n  static destroy() {\n    rasterizationLookUp.clear();\n  }\n\n  /** This is the rendered color of the label */\n  @observable color: [number, number, number, number] = [0, 0, 0, 1];\n  /** Depth sorting of the label (or the z value of the label) */\n  @observable depth: number = 0;\n  /** When in BOUND_MAX mode, this allows the label to scale up beyond it's max size */\n  @observable maxScale: number = 1;\n  /** Sets the way the label scales with the world */\n  @observable scaling: ScaleType = ScaleType.BOUND_MAX;\n  /** Scales the label uniformly */\n  @observable scale: number = 1.0;\n  /** The x coordinate where the label will be anchored to in world space */\n  @observable position: Vec2 = [0, 0];\n\n  // The following properties are properties that are locked in after creating this label\n  // As the properties are completely locked into how the label was rasterized and can not\n  // Nor should not be easily adjusted for performance concerns\n\n  private _cssFont: string = \"\";\n  private _fontFamily: string = \"Arial\";\n  private _fontSize: number = 12;\n  private _fontStyle: Label[\"fontStyle\"] = \"normal\";\n  private _fontWeight: Label[\"fontWeight\"] = 400;\n  private _maxWidth: number = 0;\n  private _text: string = \"\";\n\n  @observable private _width: number = 0;\n\n  @observable private _height: number = 0;\n\n  private _isDestroyed: boolean = false;\n\n  @observable private _rasterization: RasterizationReference;\n\n  // The following are the getters for the locked in parameters of the label so we can read\n  // The properties but not set any of them.\n\n  /**\n   * This is the full css string that represents this label. This + the text of the label is essentially\n   * a unique identifier for the rendering of the label and is used to key the rasterization of the label\n   * so that label rasterization can be shared for similar labels.\n   */\n  get cssFont() {\n    return this._cssFont;\n  }\n  /** This flag indicates if this label is valid anymore */\n  get isDestroyed() {\n    return this._isDestroyed;\n  }\n  /** This is the font family of the label */\n  get fontFamily() {\n    return this._fontFamily;\n  }\n  /**\n   * This is the size of the label in pixels. For Labels, this correlates to the rendering font size.\n   * The true pixel height of the label is calculated and placed into the height property for the label.\n   */\n  get fontSize() {\n    return this._fontSize;\n  }\n  /** This is the style of the font (italic, oblique, etc) */\n  get fontStyle() {\n    return this._fontStyle;\n  }\n  /** This is the font weight specified for the label (bold, normal, etc). */\n  get fontWeight() {\n    return this._fontWeight;\n  }\n  /** This is the max width in pixels this label can fill */\n  get maxWidth() {\n    return this._maxWidth;\n  }\n  /** This gets the atlas resource that is uniquely identified for this label */\n  get resource() {\n    return this._rasterization.resource;\n  }\n  /** This is the label's text. */\n  get text() {\n    return this._text;\n  }\n  /**\n   * If a maxWidth is specified, there is a chance the text will be truncated.\n   * This provides the calculated truncated text.\n   */\n  get truncatedText() {\n    return this._rasterization.resource.truncatedText || this.text;\n  }\n\n  /**\n   * This is the width in world space of the label. If there is no camera distortion,\n   * this would be the width of the label in pixels on the screen.\n   */\n  get width() {\n    return this._width;\n  }\n\n  /**\n   * This is the height in world space of the label. If there is no camera distortion,\n   * this would be the height of the label in pixels on the screen.\n   */\n  get height() {\n    return this._height;\n  }\n\n  // These are properties that can be altered, but have side effects from being changed\n\n  /** This is the anchor location on the  */\n  @observable\n  private _anchor: Anchor = {\n    padding: 0,\n    type: AnchorType.TopLeft,\n    x: 0,\n    y: 0\n  };\n\n  constructor(options: ILabelInstanceOptions) {\n    super(options);\n\n    this.depth = options.depth || this.depth;\n    this.color = options.color || this.color;\n    this.maxScale = options.maxScale || this.maxScale;\n    this.scaling = options.scaling || this.scaling;\n    this.scale = options.scale || this.scale;\n\n    this.position = options.position;\n\n    this._fontFamily = options.fontFamily || this._fontFamily;\n    this._fontSize = options.fontSize || this._fontSize;\n    this._fontStyle = options.fontStyle || this._fontStyle;\n    this._fontWeight = options.fontWeight || this._fontWeight;\n    this._maxWidth = options.maxWidth || 0;\n    this._text = options.text || this._text;\n\n    // We get the CSS font string for this label so we can uniquely identify the rasterization\n    // Easily.\n    this._cssFont = LabelRasterizer.makeCSSFont(this, 1);\n    // This is css font used to look up rasterizations. This lookup includes the max width of the label\n    // Which the css font does not account for\n    const cssFontLookup = `${this._cssFont}_${this._maxWidth}`;\n    // Look for other same texts that have been rasterized\n    let rasterizations = rasterizationLookUp.get(this._text);\n    let rasterization: RasterizationReference | null | undefined;\n\n    if (rasterizations) {\n      // Look for those texts that have been rasterized in the same fashion that this label is requesting\n      rasterization = rasterizations.get(cssFontLookup);\n\n      // If a rasterization exists, we must increment the use reference\n      if (rasterization) {\n        rasterization.references++;\n      }\n    } else {\n      rasterizations = new Map<CSSFont, RasterizationReference>();\n    }\n\n    // If we have not found an existing rasterization\n    if (!rasterization) {\n      rasterization = {\n        references: 1,\n        resource: new LabelAtlasResource(this)\n      };\n\n      // Look to see if any rasterization options were specified\n      if (options.rasterization) {\n        rasterization.resource.sampleScale = options.rasterization.scale || 1.0;\n      }\n\n      // Ensure the sample scale is set. Defaults to 1.0\n      rasterization.resource.sampleScale =\n        rasterization.resource.sampleScale || 1.0;\n      // Rasterize the resource generated for this label. We need it immediately rasterized so\n      // That we can utilize the dimensions for calculations.\n      LabelRasterizer.renderSync(rasterization.resource);\n      // Now that we have an official rasterization for this text / label combo, we shall store it\n      // For others to look up\n      rasterizationLookUp.set(this._text, rasterizations);\n      rasterizations.set(cssFontLookup, rasterization);\n    }\n\n    this._rasterization = rasterization;\n    this._width = rasterization.resource.rasterization.world.width;\n    this._height = rasterization.resource.rasterization.world.height;\n\n    // Make sure the anchor is set to the appropriate location\n    options.anchor && this.setAnchor(options.anchor);\n  }\n\n  get anchor() {\n    return this._anchor;\n  }\n\n  /**\n   * Labels are a sort of unique case where the use of a label should be destroyed as rasterization\n   * resources are in a way kept alive through reference counting.\n   */\n  destroy() {\n    if (!this._isDestroyed) {\n      this._isDestroyed = true;\n      this._rasterization.references--;\n\n      // If all references are cleared, then the rasterization needs to be eradicated\n      if (this._rasterization.references === 0) {\n        this._rasterization.resource;\n      }\n    }\n  }\n\n  /**\n   * Triggers any attributes waiting on resources\n   */\n  resourceTrigger() {\n    // Trigger the accessed element that the layer utilizes for resource fetching.\n    this._rasterization = this._rasterization;\n    this._width = this._width;\n    // Make sure all public properties that could have changed during the load are triggered\n    // so they properly have updated all of their elements.\n    this.position = this.position;\n    this.color = this.color;\n    this.depth = this.depth;\n    this.maxScale = this.maxScale;\n    this.scaling = this.scaling;\n    this.scale = this.scale;\n  }\n\n  /**\n   * This applies a new anchor to this label and properly determines it's anchor position on the label\n   */\n  setAnchor(anchor: Anchor) {\n    const newAnchor = {\n      padding: anchor.padding || 0,\n      type: anchor.type,\n      x: anchor.x || 0,\n      y: anchor.y || 0\n    };\n\n    // Calculate the new anchors position values\n    anchorCalculator[newAnchor.type](newAnchor, this);\n    // Apply the anchor\n    this._anchor = newAnchor;\n  }\n}\n","module.exports = \"precision highp float;\\n\\n${import: projection}\\n\\nvarying vec4 vertexColor;\\nvarying vec2 texCoord;\\n${extendHeader}\\n\\nvoid main() {\\n  ${attributes}\\n\\n  // Determine final screen size of label\\n  vec3 screenSize = cameraSpaceSize(vec3(size * scale / maxScale, 1.0));\\n\\n  // Test whether the label is larger on the screen than the font size\\n  bool largerOnScreen = screenSize.y > size.y || screenSize.x > size.x;\\n\\n  // Determines if a scale mode should be used or not for the vertex\\n  float useScaleMode = float(\\n    (\\n      scaling == 3.0 ||                  // NEVER mode - keep the image the same size always\\n      (largerOnScreen && scaling == 2.0) // BOUND_MAX mode - only if we're larger than the font size do we scale down\\n    ) &&\\n    scaling != 1.0                       // ALWAYS mode - the image stays completely in world space allowing it to scale freely\\n  );\\n\\n  // Correct aspect ratio.  Sufficient fix for most applications.\\n  // Will need another solution in the case of:\\n  //  (cameraScale y != cameraScale.x) && (cameraScale.x != 1 && cameraScale.y != 1)\\n\\n  // If zooms are unequal, assume one is filtered to be 1.0\\n  float unequalZooms = float(cameraScale.x != cameraScale.y);\\n\\n  vec2 adjustedSize = mix(\\n    size,\\n    (size * cameraScale.yx),\\n    unequalZooms\\n  );\\n\\n  // Destructure threejs's bug with the position requirement\\n  float normal = position.x;\\n  float side = position.y;\\n\\n  vec2 scaledAnchor = anchor * scale;\\n\\n  // Get the location of the anchor in world space\\n  vec2 worldAnchor = location + scaledAnchor;\\n\\n  vec2 adjustedAnchor = mix(\\n    scaledAnchor,\\n    (scaledAnchor * cameraScale.yx),\\n    unequalZooms\\n  );\\n\\n  // Get the position of the current vertex\\n  vec2 vertex = vec2(side, float(normal == 1.0)) * scale * adjustedSize + location - adjustedAnchor;\\n\\n  // See how scaled the size on screen will be from the actual height of the label\\n  float labelScreenScale = mix(\\n    screenSize.y / adjustedSize.y,\\n    screenSize.x / adjustedSize.x,\\n    float((cameraScale.x != 1.0))\\n  );\\n\\n  float currentScale = labelScreenScale * scale;\\n\\n  // If our screen rendering is larger than the size the label is supposed to be, then we automagically\\n  // scale down our label to stay the correct size, centered on the anchor point\\n  vec2 anchorToVertex = vertex - location;\\n\\n  // We now choose between keeping the same image size or keeping it in world space\\n  vertex = mix(\\n    // This option keeps the image size in world space\\n    vertex,\\n    // This option counters the scaling of the image on the screen keeping it a static size\\n    (anchorToVertex / labelScreenScale) + location,\\n    // This is the flag determining if a scale mode should be applied to the vertex\\n    useScaleMode\\n  );\\n\\n  // --Texture and Color\\n  // Get the tex coord from our inject texture info\\n  texCoord = texture.xy + ((texture.zw - texture.xy) * vec2(side, float(normal == -1.0)));\\n  // Apply the label's color as a tint to the label (all labels are rendered white to the base texture)\\n  vertexColor = color * color.a;\\n\\n  gl_Position = clipSpace(vec3(vertex, depth));\\n  ${extend}\\n}\\n\"","module.exports = \"precision highp float;\\n\\nvarying vec4 vertexColor;\\nvarying vec2 texCoord;\\n${extendHeader}\\n\\nvoid main() {\\n  gl_FragColor = texture2D(labelAtlas, texCoord) * vertexColor;\\n  setColor(gl_FragColor);\\n  ${extend}\\n}\\n\"","import * as Three from \"three\";\nimport { InstanceProvider } from \"../../instance-provider\";\nimport { Bounds } from \"../../primitives\";\nimport { ILayerProps, IModelType, Layer } from \"../../surface/layer\";\nimport {\n  IMaterialOptions,\n  InstanceAttributeSize,\n  IProjection,\n  IShaderInitialization,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../types\";\nimport {\n  CommonMaterialOptions,\n  divide2,\n  IAutoEasingMethod,\n  subtract2,\n  Vec,\n  Vec2\n} from \"../../util\";\nimport { ScaleType } from \"../types\";\nimport { LabelInstance } from \"./label-instance\";\n\nexport interface ILabelLayerProps<T extends LabelInstance>\n  extends ILayerProps<T> {\n  atlas?: string;\n  animate?: {\n    color?: IAutoEasingMethod<Vec>;\n    location?: IAutoEasingMethod<Vec>;\n    size?: IAutoEasingMethod<Vec>;\n  };\n}\n\nconst { max, min } = Math;\n\n/**\n * This layer displays Labels and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class LabelLayer<\n  T extends LabelInstance,\n  U extends ILabelLayerProps<T>\n> extends Layer<T, U> {\n  static defaultProps: ILabelLayerProps<LabelInstance> = {\n    key: \"\",\n    data: new InstanceProvider<LabelInstance>(),\n    scene: \"default\"\n  };\n\n  static attributeNames = {\n    location: \"location\",\n    anchor: \"anchor\",\n    size: \"size\",\n    depth: \"depth\",\n    scaling: \"scaling\",\n    texture: \"texture\",\n    color: \"color\",\n    scale: \"scale\",\n    maxScale: \"maxScale\"\n  };\n\n  /**\n   * We provide bounds and hit test information for the instances for this layer to allow for mouse picking\n   * of elements\n   */\n  getInstancePickingMethods() {\n    return {\n      // Provide the calculated AABB world bounds for a given label\n      boundsAccessor: (label: LabelInstance) => {\n        const anchor: Vec2 = [label.anchor.x || 0, label.anchor.y || 0];\n\n        const topLeft = subtract2(label.position, anchor);\n\n        return new Bounds({\n          height: label.height,\n          width: label.width,\n          x: topLeft[0],\n          y: topLeft[1]\n        });\n      },\n\n      // Provide a precise hit test for the circle\n      hitTest: (label: LabelInstance, point: Vec2, view: IProjection) => {\n        // The bounds of the label is in world space, but it does not account for the scale mode of the label.\n        // Here, we will apply the scale mode testing to the label\n        const maxScale = max(...view.camera.scale);\n        const minScale = min(...view.camera.scale);\n\n        // If we scale always then the label stays within it's initial world bounds at all times\n        if (label.scaling === ScaleType.ALWAYS) {\n          return true;\n        } else if (label.scaling === ScaleType.BOUND_MAX) {\n          // If we scale with bound max, then when the camera zooms in, the bounds will shrink to keep the\n          // Label the same size. If the camera zooms out then the bounds === the world bounds.\n          // We are zooming out. the bounds will stay within the world bounds\n          if (minScale <= 1 && maxScale <= 1) {\n            return true;\n          } else {\n            // We are zooming in. The bounds will shrink to keep the label at max font size\n            const anchor: Vec2 = [label.anchor.x || 0, label.anchor.y || 0];\n\n            // The location is within the world, but we reverse project the anchor spread\n            const topLeft = subtract2(\n              label.position,\n              divide2(anchor, view.camera.scale)\n            );\n\n            const screenPoint = view.worldToScreen(point);\n\n            // Reverse project the size and we should be within the distorted world coordinates\n            return new Bounds({\n              height: label.height,\n              width: label.width,\n              x: topLeft[0],\n              y: topLeft[1]\n            }).containsPoint(screenPoint);\n          }\n        } else if (label.scaling === ScaleType.NEVER) {\n          // If we never allow the label to scale, then the bounds will grow and shrink to counter the effects\n          // Of the camera zoom\n          const anchor: Vec2 = [label.anchor.x || 0, label.anchor.y || 0];\n          const topLeft = subtract2(\n            label.position,\n            divide2(anchor, view.camera.scale)\n          );\n          const screenPoint = view.worldToScreen(point);\n\n          // Reverse project the size and we should be within the distorted world coordinates\n          return new Bounds({\n            height: label.height,\n            width: label.width,\n            x: topLeft[0],\n            y: topLeft[1]\n          }).containsPoint(screenPoint);\n        }\n\n        return true;\n      }\n    };\n  }\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<LabelInstance> {\n    const animations = this.props.animate || {};\n    const {\n      color: animateColor,\n      location: animateLocation,\n      size: animateSize\n    } = animations;\n\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: 0,\n      1: 0,\n      2: 0,\n      3: 1,\n      4: 1,\n      5: 1\n    };\n\n    return {\n      fs: require(\"./label-layer.fs\"),\n      instanceAttributes: [\n        {\n          easing: animateLocation,\n          name: LabelLayer.attributeNames.location,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.position\n        },\n        {\n          name: LabelLayer.attributeNames.anchor,\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.anchor.x || 0, o.anchor.y || 0]\n        },\n        {\n          easing: animateSize,\n          name: LabelLayer.attributeNames.size,\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.width, o.height]\n        },\n        {\n          name: LabelLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        {\n          name: LabelLayer.attributeNames.scaling,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scaling]\n        },\n        {\n          atlas: {\n            key: this.props.atlas || \"\",\n            name: \"labelAtlas\"\n          },\n          name: LabelLayer.attributeNames.texture,\n          update: o => this.resource.request(this, o, o.resource)\n        },\n        {\n          easing: animateColor,\n          name: LabelLayer.attributeNames.color,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.color\n        },\n        {\n          name: LabelLayer.attributeNames.scale,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scale]\n        },\n        {\n          name: LabelLayer.attributeNames.maxScale,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.maxScale]\n        }\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: _u => [1]\n        }\n      ],\n      vertexAttributes: [\n        // TODO: This is from the heinous evils of THREEJS and their inability to fix a bug within our lifetimes.\n        // Right now position is REQUIRED in order for rendering to occur, otherwise the draw range gets updated to\n        // Zero against your wishes.\n        {\n          name: \"position\",\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexToSide[vertex],\n            0\n          ]\n        }\n      ],\n      vertexCount: 6,\n      vs: require(\"./label-layer.vs\")\n    };\n  }\n\n  getModelType(): IModelType {\n    return {\n      drawMode: Three.TriangleStripDrawMode,\n      modelType: Three.Mesh\n    };\n  }\n\n  getMaterialOptions(): IMaterialOptions {\n    return CommonMaterialOptions.transparentImage;\n  }\n}\n","import { ImageAtlasResource } from \"./image-atlas-resource\";\n\nlet canvas: CanvasRenderingContext2D | null;\n\nexport interface IImageRasterizedMetrics {\n  canvas: HTMLCanvasElement;\n  height: number;\n  width: number;\n}\n\nexport class ImageRasterizer {\n  /**\n   * This loops until our canvas context is available\n   */\n  static async awaitContext() {\n    // Iterate till the browser provides a valid canvas to render elements into\n    while (!canvas) {\n      this.getContext();\n      await new Promise(resolve => setTimeout(resolve, 10));\n    }\n  }\n\n  /**\n   * Attempts to populate the 'canvas' context for rendering images offscreen.\n   */\n  static getContext() {\n    if (!canvas) {\n      canvas = document.createElement(\"canvas\").getContext(\"2d\");\n    }\n\n    return canvas;\n  }\n\n  /**\n   * This renders our image to a sizeable canvas where we loop over the pixel data to determine\n   * the bounds of the image.\n   *\n   * @param {boolean} calculateWorld This is used within the method. It switches from calculating\n   *                                 the size to be rendered to the texture to the size the image\n   *                                 should be within world space.\n   * @param {number} sampleScale     INTERNAL: Do not use this parameter manually.\n   */\n  static calculateImageSize(\n    resource: ImageAtlasResource,\n    _sampleScale?: number\n  ) {\n    /** Get the image properties for rasterizing */\n    const image = resource.image.element;\n\n    if (!image) {\n      console.warn(\n        \"Image does not exist! Please ensure the resource contains a valid image.\"\n      );\n      return;\n    }\n\n    if (!canvas) {\n      console.warn(\n        \"The Image rasterizer was unable to establish a valid canvas context. Please ensure the system supports contexts and ensure the document is ready first.\"\n      );\n      return;\n    }\n\n    if (image.width === 0 || image.height === 0) {\n      console.warn(\n        \"Images provided shoud have valid dimensions! Please ensure the image is loaded first.\"\n      );\n      return;\n    }\n\n    // Just make sure th canvas is available\n    canvas.canvas.width = 100;\n    canvas.canvas.height = 100;\n    // Render the image into our canvas merely to ensure the image can be rendered\n    // This action often 'warms up' images such as images that have a data URL instead of a path\n    canvas.drawImage(image, 0, 0);\n\n    // Make sure the rasterization object is initialized\n    resource.rasterization = resource.rasterization || {\n      texture: { height: 0, width: 0 },\n      world: { height: 0, width: 0 }\n    };\n\n    // Update the calculated texture size.\n    resource.rasterization.texture = {\n      height: image.height * resource.sampleScale,\n      width: image.width * resource.sampleScale\n    };\n\n    resource.rasterization.world = {\n      height: image.height,\n      width: image.width\n    };\n\n    resource.rasterization.image = image;\n  }\n\n  /**\n   * Performs the rendering of the image\n   */\n  static async render(\n    resource: ImageAtlasResource\n  ): Promise<ImageAtlasResource> {\n    // Make sure our canvas object is ready for rendering\n    await this.awaitContext();\n\n    // Calculate all of the image metrics and ensure the image can be drawn\n    this.calculateImageSize(resource, resource.sampleScale);\n\n    return resource;\n  }\n\n  /**\n   * Performs the rendering of the image\n   */\n  static renderSync(resource: ImageAtlasResource): ImageAtlasResource {\n    // Ensure our offscreen canvas is prepped\n    this.getContext();\n\n    if (!canvas) {\n      console.warn(\n        \"Can not render a image synchronously without the canvas context being ready.\"\n      );\n      return resource;\n    }\n\n    // Calculate all of the image metrics and generate a canvas on the image that can\n    // Be rendered to the canvas.\n    this.calculateImageSize(resource, resource.sampleScale);\n\n    return resource;\n  }\n}\n","import { Bounds } from \"../../primitives/bounds\";\nimport { Atlas, IAtlasOptions } from \"./atlas\";\nimport { ColorAtlasResource } from \"./color-atlas-resource\";\nimport { ColorRasterizer } from \"./color-rasterizer\";\nimport { ImageAtlasResource } from \"./image-atlas-resource\";\nimport { LabelAtlasResource } from \"./label-atlas-resource\";\nimport { LabelRasterizer } from \"./label-rasterizer\";\nimport { ImageDimensions, PackNode } from \"./pack-node\";\nimport { SubTexture } from \"./sub-texture\";\n\nconst debug = require(\"debug\")(\"webgl-surface:Atlas\");\n\nconst ZERO_IMAGE: SubTexture = {\n  aspectRatio: 0,\n  atlasBL: [0, 0],\n  atlasBR: [0, 0],\n  atlasReferenceID: \"\",\n  atlasTexture: null,\n  atlasTL: [0, 0],\n  atlasTR: [0, 0],\n  heightOnAtlas: 0,\n  isValid: false,\n  pixelHeight: 0,\n  pixelWidth: 0,\n  widthOnAtlas: 0\n};\n\nexport type AtlasResource =\n  | ColorAtlasResource\n  | LabelAtlasResource\n  | ImageAtlasResource;\n\n/**\n * Determines if a SubTexture is a valid SubTexture for rendering\n */\nfunction isValidImage(image: SubTexture) {\n  let isValid = false;\n\n  if (image && image.isValid) {\n    if (image.pixelWidth && image.pixelHeight) {\n      isValid = true;\n    }\n  }\n\n  return isValid;\n}\n\n/**\n * Defines a manager of atlas', which includes generating the atlas and producing\n * textures defining those pieces of atlas.\n */\nexport class AtlasManager {\n  /** Stores all of the generated atlas' in a lookup by name */\n  allAtlas = new Map<string, Atlas>();\n\n  /**\n   * Atlas' must be created from scratch to update them. In order to properly\n   * update an existing one, you must destroy it then recreate it again.\n   * This is from not knowing how to update a texture via three js.\n   *\n   * @param resources The images with their image path set to be loaded into the atlas.\n   *               Images that keep an atlas ID of null indicates the image did not load\n   *               correctly\n   *\n   * @return {Texture} The Threejs texture that is created as our atlas. The images injected\n   *                   into the texture will be populated with the atlas'\n   */\n  async createAtlas(options: IAtlasOptions, resources?: AtlasResource[]) {\n    // Create the new Atlas object that tracks all of our atlas' metrics\n    const atlas = new Atlas(options);\n    // Set the manager to the atlas\n    atlas.setManager(this);\n    // Make the atlas identifiable by it's name\n    this.allAtlas.set(atlas.id, atlas);\n\n    // Now we load, pack in, and draw each requested resource\n    if (resources) {\n      await this.updateAtlas(atlas.id, resources);\n    }\n\n    debug(\"Atlas Created-> %o\", atlas);\n\n    return atlas;\n  }\n\n  /**\n   * Free ALL resources under this manager\n   */\n  destroy() {\n    this.allAtlas.forEach(value => value.destroy());\n  }\n\n  /**\n   * Disposes of the resources the atlas held and makes the atlas invalid for use\n   *\n   * @param atlasName\n   */\n  destroyAtlas(atlasName: string) {\n    const atlas = this.allAtlas.get(atlasName);\n\n    if (atlas) {\n      atlas.destroy();\n    }\n  }\n\n  private setDefaultImage(image: SubTexture, atlasName: string) {\n    image = Object.assign(image, ZERO_IMAGE, { atlasReferenceID: atlasName });\n    return image;\n  }\n\n  /**\n   * This loads, packs, and draws the indicated image into the specified canvas\n   * using the metrics that exists for the specified atlas.\n   *\n   * @param resource The image who should have it's image path loaded\n   * @param atlasName The name of the atlas to make the packing work\n   * @param canvas The canvas we will be drawing into to generate the complete image\n   *\n   * @return {Promise<boolean>} Promise that resolves to if the image successfully was drawn or not\n   */\n  private async draw(atlas: Atlas, resource: AtlasResource): Promise<boolean> {\n    const canvas = atlas.texture.image;\n    const atlasName = atlas.id;\n\n    // Register the resource with the atlas\n    if (!atlas.registerResource(resource)) {\n      console.warn(\n        \"Could not draw resource to the atlas as the resource was not properly registered to the atlas first\",\n        atlas,\n        resource\n      );\n      return Promise.resolve(false);\n    }\n\n    // First we must load the image\n    // Make a buffer to hold our new image\n    // Load the image into memory, default to keeping the alpha channel\n    const loadedImage: HTMLImageElement | null = await this.loadImage(resource);\n\n    // Only a non-null image means the image loaded correctly\n    if (loadedImage && isValidImage(resource.texture)) {\n      // Get the sub texture that is going to be applied to the atlas\n      const rasterization = resource.rasterization;\n      const texture = resource.texture;\n      // Now we create a Rectangle to store the image dimensions\n      const rect: Bounds = new Bounds({\n        bottom: rasterization.texture.height,\n        left: 0,\n        right: rasterization.texture.width,\n        top: 0\n      });\n      // Create ImageDimension to insert into our atlas mapper\n      const dimensions: ImageDimensions = {\n        first: texture,\n        second: rect\n      };\n\n      // Auto add a buffer in\n      dimensions.second.width += 1;\n      dimensions.second.height += 1;\n      // Get the atlas map node\n      const packing: PackNode = atlas.packing;\n      // Store the node resulting from the insert operation\n      const insertedNode: PackNode | null = packing.insert(dimensions);\n\n      // If the result was NULL we did not successfully insert the image into any map\n      if (insertedNode) {\n        debug(\"Atlas location determined: %o\", insertedNode);\n\n        // Apply the image to the node\n        insertedNode.nodeImage = texture;\n\n        // Set our image's atlas properties\n        const ux = insertedNode.nodeDimensions.x / atlas.width;\n        const uy = insertedNode.nodeDimensions.y / atlas.height;\n        const uw = insertedNode.nodeDimensions.width / atlas.width;\n        const uh = insertedNode.nodeDimensions.height / atlas.height;\n        const onePixelX = 1 / atlas.width;\n\n        const atlasDimensions: Bounds = new Bounds({\n          bottom: 1.0 - uy,\n          left: ux,\n          right: ux + uw,\n          top: 1.0 - (uy + uh)\n        });\n\n        const bottom = atlasDimensions.bottom;\n        const top = atlasDimensions.y;\n        const left = atlasDimensions.x;\n        const right = atlasDimensions.x + atlasDimensions.width - onePixelX;\n\n        texture.atlasReferenceID = atlasName;\n        texture.atlasTL = [left, top];\n        texture.atlasBR = [right, bottom];\n        texture.atlasBL = [left, bottom];\n        texture.atlasTR = [right, top];\n        texture.widthOnAtlas = Math.abs(\n          texture.atlasTR[0] - texture.atlasTL[0]\n        );\n        texture.heightOnAtlas = Math.abs(\n          texture.atlasTR[1] - texture.atlasBR[1]\n        );\n        texture.pixelWidth = rasterization.texture.width;\n        texture.pixelHeight = rasterization.texture.height;\n\n        // Now draw the image to the indicated canvas\n        canvas\n          .getContext(\"2d\")\n          .drawImage(\n            loadedImage,\n            insertedNode.nodeDimensions.x,\n            insertedNode.nodeDimensions.y\n          );\n\n        // We have finished inserting\n        return true;\n      } else {\n        // Log an error\n        console.error(`Could not fit resource into atlas`, resource);\n        resource.texture = this.setDefaultImage(resource.texture, atlasName);\n        return false;\n      }\n    } else {\n      if (!resource.texture.isValid) {\n        debug(\"Resource was invalidated during load:\", resource);\n      } else {\n        // Log an error and load a default sub texture\n        console.error(`Could not load resource:`, resource);\n      }\n\n      resource.texture = this.setDefaultImage(resource.texture, atlasName);\n      return false;\n    }\n  }\n\n  /**\n   * Retrieves the threejs texture for the atlas\n   *\n   * @param atlasName The identifier of the atlas\n   */\n  getAtlasTexture(atlasName: string): Atlas | undefined {\n    return this.allAtlas.get(atlasName);\n  }\n\n  /**\n   * This takes in any atlas resource and rasterizes it.\n   *\n   * @param {SubTexture} resource This is any atlas resource which will have it's image rasterized\n   *\n   * @return {Promise<HTMLImageElement>} A promise to resolve to the loaded image\n   *                                     or null if there was an error\n   */\n  private async loadImage(\n    resource: AtlasResource\n  ): Promise<HTMLImageElement | null> {\n    let imageSrc: string = \"\";\n\n    const subTexture = resource.texture || new SubTexture();\n    resource.texture = subTexture;\n\n    if (resource.texture.isValid === false) return null;\n\n    if (resource instanceof ImageAtlasResource) {\n      // If the texture was provided an image then we ensure the image is loaded\n      // Then hand it back\n      if (resource.image.element) {\n        if (\n          resource.image.element.width !== 0 &&\n          resource.image.element.height !== 0\n        ) {\n          const image = resource.image.element;\n          subTexture.pixelWidth = image.width;\n          subTexture.pixelHeight = image.height;\n          subTexture.aspectRatio = image.width / image.height;\n\n          return image;\n        }\n\n        const image = await new Promise<HTMLImageElement | null>(resolve => {\n          const image: HTMLImageElement | undefined = resource.image.element;\n\n          if (image) {\n            image.onload = function() {\n              subTexture.pixelWidth = image.width;\n              subTexture.pixelHeight = image.height;\n              subTexture.aspectRatio = image.width / image.height;\n              resolve(image);\n            };\n\n            image.onerror = function() {\n              resolve(null);\n            };\n          } else {\n            resolve(null);\n          }\n        });\n\n        return image;\n      } else if (resource.image.path) {\n        // If a string was returned, we must load the image then return the image\n        imageSrc = resource.image.path;\n      }\n    } else if (resource instanceof LabelAtlasResource) {\n      // Ensure the label has been rasterized to a canvas element\n      if (!resource.rasterization.canvas) {\n        await LabelRasterizer.render(resource);\n      }\n\n      // Make sure the rasterization properly executed\n      if (resource.rasterization.canvas) {\n        debug(\"Rasterized label %o\", resource.rasterization);\n        imageSrc = resource.rasterization.canvas.toDataURL(\"image/png\");\n      } else {\n        console.warn(\"The label was not able to be rasterized\");\n      }\n    } else if (resource instanceof ColorAtlasResource) {\n      // Ensure the color has been rasterized to a canvas element\n      if (!resource.rasterization.canvas) {\n        await ColorRasterizer.render(resource);\n      }\n\n      // Make sure the rasterization properly executed\n      if (resource.rasterization.canvas) {\n        debug(\"Rasterized color %o\", resource.rasterization);\n        imageSrc = resource.rasterization.canvas.toDataURL(\"image/png\");\n      } else {\n        console.warn(\"The color was not able to be rasterized\");\n      }\n    }\n\n    if (imageSrc) {\n      const image = await new Promise<HTMLImageElement | null>(resolve => {\n        const image: HTMLImageElement = new Image();\n\n        image.onload = function() {\n          subTexture.pixelWidth = image.width;\n          subTexture.pixelHeight = image.height;\n          subTexture.aspectRatio = image.width / image.height;\n          resolve(image);\n        };\n\n        image.onerror = function() {\n          resolve(null);\n        };\n\n        image.src = imageSrc;\n      });\n\n      return image;\n    }\n\n    return null;\n  }\n\n  /**\n   * This targets an existing atlas and attempts to update it with the provided atlas resources.\n   *\n   * @param atlasName\n   * @param resources\n   */\n  async updateAtlas(atlasName: string, resources: AtlasResource[]) {\n    const atlas = this.allAtlas.get(atlasName);\n\n    if (atlas) {\n      for (const resource of resources) {\n        await this.draw(atlas, resource);\n      }\n\n      // Perform the best method for updating the underlying texture of the atlas to the latest changes\n      atlas.updateTexture();\n    } else {\n      console.warn(\n        \"Can not update non-existing atlas:\",\n        atlasName,\n        \"These resources will not be loaded:\",\n        resources\n      );\n    }\n  }\n}\n","import { Bounds } from \"../../primitives/bounds\";\nimport { SubTexture } from \"./sub-texture\";\n\n/**\n * Helps us track the bounds of the image being loaded in tied in with the\n * texture it represents\n */\nexport interface ImageDimensions {\n  first: SubTexture;\n  second: Bounds;\n}\n\n/**\n * This is used specifically by the atlas manager to aid in packing\n * in textures within an area. This will guarantee boundaries of textures are\n * not violated and provide proper feedback for where to draw a given image\n */\nexport class PackNode {\n  child: [PackNode | null, PackNode | null] = [null, null];\n  isLeaf: boolean = true;\n  nodeDimensions: Bounds;\n  nodeImage: SubTexture | null = null;\n\n  constructor(x: number, y: number, width: number, height: number) {\n    this.nodeDimensions = new Bounds({\n      height,\n      width,\n      x,\n      y\n    });\n  }\n\n  /**\n   * Deletes all of the sub nodes in this Mapping, thus clearing up memory usage\n   */\n  destroy() {\n    const child0 = this.child[0];\n    const child1 = this.child[1];\n    this.nodeImage = null;\n    if (child0) {\n      child0.destroy();\n    }\n    if (child1) {\n      child1.destroy();\n    }\n    this.child[0] = null;\n    this.child[1] = null;\n  }\n\n  /**\n   * Indicates if there is a child\n   */\n  hasChild(): boolean {\n    const child0 = this.child[0];\n    const child1 = this.child[1];\n    if (child0 && !child0.nodeImage) {\n      return !child0.isLeaf;\n    }\n    if (child1 && !child1.nodeImage) {\n      return !child1.isLeaf;\n    }\n    return false;\n  }\n\n  /**\n   * Inserts images into our mapping, fitting them appropriately\n   */\n  insert(image: ImageDimensions): PackNode | null {\n    let child0 = this.child[0];\n    let child1 = this.child[1];\n\n    if (!this.isLeaf && child0 && child1) {\n      // Try inserting into first child\n      const newNode: PackNode | null = child0.insert(image);\n      if (newNode !== null) {\n        return newNode;\n      }\n      // No room in first so insert into second\n      return child1.insert(image);\n    } else {\n      // If there's already an image here, return\n      if (this.nodeImage) {\n        return null;\n      }\n      // Check the fit status of the image in this nodes rectangle space\n      const fitFlag: number = this.nodeDimensions.fits(image.second);\n      // If we're too small, return null indicating can not fit\n      if (fitFlag === 0) {\n        return null;\n      }\n      // If we're just right, accept\n      if (fitFlag === 1) {\n        return this;\n      }\n\n      // Otherwise, gotta split this node and create some leaves\n      this.isLeaf = false;\n      // Get the image width\n      const imgWidth: number = image.second.width;\n      const imgHeight: number = image.second.height;\n      // Decide which way to split\n      const dWidth: number = this.nodeDimensions.width - imgWidth;\n      const dHeight: number = this.nodeDimensions.height - image.second.height;\n\n      if (dWidth > dHeight) {\n        child0 = this.child[0] = new PackNode(\n          this.nodeDimensions.x,\n          this.nodeDimensions.y,\n          imgWidth,\n          this.nodeDimensions.height\n        );\n        child1 = this.child[1] = new PackNode(\n          this.nodeDimensions.x + imgWidth,\n          this.nodeDimensions.y,\n          dWidth,\n          this.nodeDimensions.height\n        );\n      } else {\n        child0 = this.child[0] = new PackNode(\n          this.nodeDimensions.x,\n          this.nodeDimensions.y,\n          this.nodeDimensions.width,\n          imgHeight\n        );\n        child1 = this.child[1] = new PackNode(\n          this.nodeDimensions.x,\n          this.nodeDimensions.y + imgHeight,\n          this.nodeDimensions.width,\n          dHeight\n        );\n      }\n    }\n\n    // Insert into first child we created\n    return child0.insert(image);\n  }\n\n  /**\n   * Removes the image from the mapping and tries to open up as much space as possible.\n   *\n   * @param {AtlasTexture} image The image to insert into the\n   */\n  remove(image: SubTexture): boolean {\n    const child0 = this.child[0];\n    const child1 = this.child[1];\n\n    if (child1 && child0 && !this.isLeaf) {\n      // Try removing from first child\n      let removed: boolean = child0.remove(image);\n      if (removed) {\n        return true;\n      }\n      // Try remove from second\n      removed = child1.remove(image);\n\n      if (!child0.hasChild()) {\n        if (!child1.hasChild()) {\n          this.child[0] = null;\n          this.child[1] = null;\n        }\n      }\n\n      return removed;\n    } else {\n      if (this.nodeImage === image) {\n        this.nodeImage = null;\n        delete image.atlasReferenceID;\n        image.pixelWidth = 0;\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }\n}\n","import { observable } from \"../../instance-provider\";\nimport { IInstanceOptions, Instance } from \"../../instance-provider/instance\";\nimport { Image } from \"../../primitives/image\";\nimport { ImageAtlasResource, ImageRasterizer } from \"../../surface/texture\";\nimport { Vec2 } from \"../../util/vector\";\nimport { Anchor, AnchorType, ScaleType } from \"../types\";\n\nconst { max } = Math;\n\nexport interface IImageInstanceOptions extends IInstanceOptions {\n  /**\n   * The point on the image which will be placed in world space via the x, y coords. This is also the point\n   * which the image will be scaled around.\n   */\n  anchor?: Anchor;\n  /** Depth sorting of the image (or the z value of the lable) */\n  depth?: number;\n  /** This is the HTMLImageElement that the image is to render. This element MUST be loaded completely before this instance is created. */\n  element: HTMLImageElement;\n  /** The height of the image as it is to be rendered in world space */\n  height?: number;\n  /** The coordinate where the image will be anchored to in world space */\n  position?: Vec2;\n  /** Sets the way the image scales with the world */\n  scaling?: ScaleType;\n  /** The color the image should render as */\n  tint: [number, number, number, number];\n  /** The width of the image as it is to be rendered in world space */\n  width?: number;\n}\n\n/**\n * This is a reference for a rasterization that has reference counting. When the references go to zero,\n * the rasterization should be invalidated and resources freed for the rasterization.\n */\ntype RasterizationReference = {\n  resource: ImageAtlasResource;\n  references: number;\n};\n\n/**\n * This is a lookup to find existing rasterizations for a particularly created image so that every\n * new image does not have to go through the rasterization process.\n */\nconst rasterizationLookUp = new Map<\n  string | HTMLImageElement,\n  RasterizationReference\n>();\n\n/**\n * This is a lookup to quickly find the proper calculation for setting the correct anchor\n * position based on the anchor type.\n */\nconst anchorCalculator: {\n  [key: number]: (anchor: Anchor, image: ImageInstance) => void;\n} = {\n  [AnchorType.TopLeft]: (anchor: Anchor, _image: ImageInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopMiddle]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width / 2.0;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopRight]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width + anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.MiddleLeft]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = image.height / 2;\n  },\n  [AnchorType.Middle]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width / 2.0;\n    anchor.y = image.height / 2.0;\n  },\n  [AnchorType.MiddleRight]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width + anchor.padding;\n    anchor.y = image.height / 2.0;\n  },\n  [AnchorType.BottomLeft]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = image.height + anchor.padding;\n  },\n  [AnchorType.BottomMiddle]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width / 2.0;\n    anchor.y = image.height + anchor.padding;\n  },\n  [AnchorType.BottomRight]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width + anchor.padding;\n    anchor.y = image.height + anchor.padding;\n  },\n  [AnchorType.Custom]: (anchor: Anchor, _image: ImageInstance) => {\n    anchor.x = anchor.x || 0;\n    anchor.y = anchor.y || 0;\n  }\n};\n\n/**\n * This generates a new image instance.\n * There are restrictions surrounding images due to texture sizes and rendering limitations.\n *\n * Currently, we only support rendering a image via canvas, then rendering it to an Atlas texture\n * which is used to render to cards in the world for rendering. This is highly performant, but means:\n *\n * - Images should only be so large.\n * - Once a image is constructed, only SOME properties can be altered thereafter\n *\n * An image that is constructed can only have some properties set upon creating the image and are locked\n * thereafter. The only way to modify them would be to destroy the image, then construct a new image\n * with the modifications. This has to deal with performance regarding rasterizing the image.\n */\nexport class ImageInstance extends Instance implements Image {\n  /**\n   * TODO: We should be implementing the destroy on ImageInstances to clean this up\n   * Frees up module scoped data.\n   */\n  static destroy() {\n    rasterizationLookUp.clear();\n  }\n\n  /** This is the rendered color of the image */\n  @observable tint: [number, number, number, number] = [0, 0, 0, 1];\n  /** Depth sorting of the image (or the z value of the lable) */\n  @observable depth: number = 0;\n  /** The height of the image as it is to be rendered in world space */\n  @observable height: number = 1;\n  /** The coordinate where the image will be anchored to in world space */\n  @observable position: Vec2 = [0, 0];\n  /** Sets the way the image scales with the world */\n  @observable scaling: ScaleType = ScaleType.BOUND_MAX;\n  /** The width of the image as it is to be rendered in world space */\n  @observable width: number = 1;\n\n  get size() {\n    return max(this.width, this.height);\n  }\n  set size(value: number) {\n    const aspect = this.width / this.height;\n    this.width = value * aspect;\n    this.height = value;\n  }\n\n  // The following properties are properties that are locked in after creating this image\n  // As the properties are completely locked into how the image was rasterized and can not\n  // Nor should not be easily adjusted for performance concerns\n\n  private _sourceWidth: number = 0;\n  private _sourceHeight: number = 0;\n  private _isDestroyed: boolean = false;\n  @observable private _rasterization: RasterizationReference;\n  private _path: string;\n  private _element: HTMLImageElement;\n\n  // The following are the getters for the locked in parameters of the image so we can read\n  // The properties but not set any of them.\n\n  /** This is the provided element this image will be rendering */\n  get element() {\n    return this._element;\n  }\n  /** This flag indicates if this image is valid anymore */\n  get isDestroyed() {\n    return this._isDestroyed;\n  }\n  /** This is the path to the image's resource if it's available */\n  get path() {\n    return this._path;\n  }\n  /** This gets the atlas resource that is uniquely idenfied for this image */\n  get resource() {\n    return this._rasterization.resource;\n  }\n\n  /**\n   * This is the width in world space of the image. If there is no camera distortion,\n   * this would be the width of the image in pixels on the screen.\n   */\n  get sourceWidth() {\n    return this._sourceWidth;\n  }\n\n  /**\n   * This is the height in world space of the image. If there is no camera distortion,\n   * this would be the height of the image in pixels on the screen.\n   */\n  get sourceHeight() {\n    return this._sourceHeight;\n  }\n\n  // These are properties that can be altered, but have side effects from being changed\n\n  /** This is the anchor location on the  */\n  @observable\n  private _anchor: Anchor = {\n    padding: 0,\n    type: AnchorType.TopLeft,\n    x: 0,\n    y: 0\n  };\n\n  constructor(options: IImageInstanceOptions) {\n    super(options);\n\n    this.depth = options.depth || this.depth;\n    this.tint = options.tint || this.tint;\n    this.scaling = options.scaling || this.scaling;\n    this.position = options.position || this.position;\n\n    // This is the image that is to be rendered\n    this._element = options.element;\n    // Look for other same texts that have been rasterized\n    let rasterization = rasterizationLookUp.get(this._path || this._element);\n\n    // If a rasterization exists, we must increment the use reference\n    if (rasterization) {\n      rasterization.references++;\n    }\n\n    // If we have not found an existing rasterization\n    if (!rasterization) {\n      rasterization = {\n        references: 1,\n        resource: new ImageAtlasResource(this)\n      };\n\n      // Ensure the sample scale is set. Defaults to 1.0\n      rasterization.resource.sampleScale =\n        rasterization.resource.sampleScale || 1.0;\n      // Rasterize the resource generated for this image. We need it immediately rasterized so\n      // That we can utilize the dimensions for calculations.\n      ImageRasterizer.renderSync(rasterization.resource);\n      // Now that we have an official rasterization for this image, we shall store it\n      // For others to look up\n      rasterizationLookUp.set(this._path || this._element, rasterization);\n    }\n\n    this._rasterization = rasterization;\n    this._sourceWidth = rasterization.resource.rasterization.world.width;\n    this._sourceHeight = rasterization.resource.rasterization.world.height;\n\n    this.width = options.width || this._sourceWidth || 1;\n    this.height = options.height || this._sourceHeight || 1;\n\n    // Make sure the anchor is set to the appropriate location\n    options.anchor && this.setAnchor(options.anchor);\n  }\n\n  get anchor() {\n    return this._anchor;\n  }\n\n  /**\n   * Images are a sort of unique case where the use of a image should be destroyed as rasterization\n   * resources are in a way kept alive through reference counting.\n   */\n  destroy() {\n    if (!this._isDestroyed) {\n      this._isDestroyed = true;\n      this._rasterization.references--;\n\n      // If all references are cleared, then the rasterization needs to be eradicated\n      if (this._rasterization.references === 0) {\n        this._rasterization.resource;\n        console.warn(\"The destroy method still needs completion\");\n      }\n    }\n  }\n\n  resourceTrigger() {\n    // Trigger the accessed element that the layer utilizes for resource fetching.\n    this._rasterization = this._rasterization;\n\n    this.tint = this.tint;\n    this.depth = this.depth;\n    this.height = this.height;\n    this.scaling = this.scaling;\n    this.width = this.width;\n    this.position = this.position;\n  }\n\n  /**\n   * This applies a new anchor to this image and properly determines it's anchor position on the image\n   */\n  setAnchor(anchor: Anchor) {\n    const newAnchor = {\n      padding: anchor.padding || 0,\n      type: anchor.type,\n      x: anchor.x || 0,\n      y: anchor.y || 0\n    };\n\n    // Calculate the new anchors position values\n    anchorCalculator[newAnchor.type](newAnchor, this);\n    // Apply the anchor\n    this._anchor = newAnchor;\n  }\n}\n","module.exports = \"precision highp float;\\n\\n${import: projection}\\n\\nvarying vec4 vertexColor;\\nvarying vec2 texCoord;\\n\\n${extendHeader}\\n\\nvoid main() {\\n  ${attributes}\\n\\n  // Figure out the size of the image as it'd show on the screen\\n  vec3 screenSize = cameraSpaceSize(vec3(size, 1.0));\\n  // Do the test for when the image is larger on the screen than the font size\\n  bool largerOnScreen = screenSize.y > size.y;\\n\\n  // Determines if a scale mode should be used or not for the vertex\\n  float useScaleMode = float(\\n    (\\n      scaling == 3.0 ||                  // NEVER mode - keep the image the same size always\\n      (largerOnScreen && scaling == 2.0) // BOUND_MAX mode - only if we're larger than the font size do we scale down\\n    ) &&\\n    scaling != 1.0                       // ALWAYS mode - the image stays completely in world space allowing it to scale freely\\n  );\\n  // If zooms are unequal, assume one is filtered to be 1.0\\n  float unequalZooms = float(cameraScale.x != cameraScale.y);\\n\\n  // Destructure threejs's bug with the position requirement\\n  float normal = position.x;\\n  float side = position.y;\\n\\n  // Get the location of the anchor in world space\\n  vec2 worldAnchor = location + anchor;\\n\\n  // Get the tex coord from our inject texture info\\n  texCoord = texture.xy + ((texture.zw - texture.xy) * vec2(side, float(normal == -1.0)));\\n  // Apply the image's tint as a tint to the image\\n  vertexColor = tint;\\n\\n  // Correct aspect ratio.\\n  vec2 adjustedSize = mix(\\n    size,\\n    (size * cameraScale.yx),\\n    unequalZooms\\n  );\\n\\n  vec2 adjustedAnchor = mix(\\n    anchor,\\n    (anchor * cameraScale.yx),\\n    unequalZooms\\n  );\\n\\n  vec2 vertex = vec2(side, float(normal == 1.0)) * adjustedSize + location - adjustedAnchor;\\n\\n  // See how scaled the size on screen will be from the actual height of the image\\n  float imageScreenScale = mix(\\n    screenSize.y / adjustedSize.y,\\n    screenSize.x / adjustedSize.x,\\n    float((cameraScale.x < 1.0) || (cameraScale.x > 1.0))\\n  );\\n\\n  // If our screen rendering is larger than the size the image is supposed to be, then we automagically\\n  // scale down our image to stay the correct size, centered on the anchor point\\n  vec2 anchorToVertex = vertex - location;\\n\\n  // We now choose between keeping the same image size or keeping it in world space\\n  vertex = mix(\\n    // This option keeps the image size in world space\\n    vertex,\\n    // This option counters the scaling of the image on the screen keeping it a static size\\n    (anchorToVertex / imageScreenScale) + location,\\n    // This is the flag determining if a scale mode should be applied to the vertex\\n    useScaleMode\\n  );\\n\\n  gl_Position = clipSpace(vec3(vertex, depth));\\n\\n  ${extend}\\n}\\n\"","module.exports = \"precision highp float;\\n\\nvarying vec4 vertexColor;\\nvarying vec2 texCoord;\\n${extendHeader}\\n\\nvoid main() {\\n  gl_FragColor = texture2D(imageAtlas, texCoord) * vertexColor;\\n  setColor(gl_FragColor * gl_FragColor.a);\\n  ${extend}\\n}\\n\"","import * as Three from \"three\";\nimport { InstanceProvider } from \"../../instance-provider\";\nimport { Bounds } from \"../../primitives\";\nimport { ILayerProps, IModelType, Layer } from \"../../surface/layer\";\nimport {\n  IMaterialOptions,\n  InstanceAttributeSize,\n  IProjection,\n  IShaderInitialization,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../types\";\nimport { divide2, IAutoEasingMethod, subtract2, Vec, Vec2 } from \"../../util\";\nimport { CommonMaterialOptions } from \"../../util/common-options\";\nimport { ScaleType } from \"../types\";\nimport { ImageInstance } from \"./image-instance\";\n\nconst { min, max } = Math;\n\nexport interface IImageLayerProps<T extends ImageInstance>\n  extends ILayerProps<T> {\n  atlas?: string;\n  animate?: {\n    tint?: IAutoEasingMethod<Vec>;\n    location?: IAutoEasingMethod<Vec>;\n    size?: IAutoEasingMethod<Vec>;\n  };\n}\n\n/**\n * This layer displays Images and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class ImageLayer<\n  T extends ImageInstance,\n  U extends IImageLayerProps<T>\n> extends Layer<T, U> {\n  static defaultProps: IImageLayerProps<any> = {\n    key: \"\",\n    data: new InstanceProvider<ImageInstance>(),\n    scene: \"default\"\n  };\n\n  static attributeNames = {\n    location: \"location\",\n    anchor: \"anchor\",\n    size: \"size\",\n    depth: \"depth\",\n    scaling: \"scaling\",\n    texture: \"texture\",\n    tint: \"tint\"\n  };\n\n  /**\n   * We provide bounds and hit test information for the instances for this layer to allow for mouse picking\n   * of elements\n   */\n  getInstancePickingMethods() {\n    return {\n      // Provide the calculated AABB world bounds for a given image\n      boundsAccessor: (image: ImageInstance) => {\n        const anchorEffect: Vec2 = [0, 0];\n\n        if (image.anchor) {\n          anchorEffect[0] = image.anchor.x || 0;\n          anchorEffect[1] = image.anchor.y || 0;\n        }\n\n        const topLeft = subtract2(image.position, anchorEffect);\n\n        return new Bounds({\n          height: image.height,\n          width: image.width,\n          x: topLeft[0],\n          y: topLeft[1]\n        });\n      },\n\n      // Provide a precise hit test for the circle\n      hitTest: (image: ImageInstance, point: Vec2, view: IProjection) => {\n        // The bounds of the image is in world space, but it does not account for the scale mode of the image.\n        // Here, we will apply the scale mode testing to the image\n        const maxScale = max(...view.camera.scale);\n        const minScale = min(...view.camera.scale);\n\n        // If we scale always then the image stays within it's initial world bounds at all times\n        if (image.scaling === ScaleType.ALWAYS) {\n          return true;\n        } else if (image.scaling === ScaleType.BOUND_MAX) {\n          // If we scale with bound max, then when the camera zooms in, the bounds will shrink to keep the\n          // Image the same size. If the camera zooms out then the bounds === the world bounds.\n          // We are zooming out. the bounds will stay within the world bounds\n          if (minScale <= 1 && maxScale <= 1) {\n            return true;\n          } else {\n            // We are zooming in. The bounds will shrink to keep the image at max font size\n            // The location is within the world, but we reverse project the anchor spread\n            const anchorEffect: Vec2 = [0, 0];\n\n            if (image.anchor) {\n              anchorEffect[0] = image.anchor.x || 0;\n              anchorEffect[1] = image.anchor.y || 0;\n            }\n\n            const topLeft = subtract2(\n              image.position,\n              divide2(anchorEffect, view.camera.scale)\n            );\n\n            const screenPoint = view.worldToScreen(point);\n\n            // Reverse project the size and we should be within the distorted world coordinates\n            return new Bounds({\n              height: image.height,\n              width: image.width,\n              x: topLeft[0],\n              y: topLeft[1]\n            }).containsPoint(screenPoint);\n          }\n        } else if (image.scaling === ScaleType.NEVER) {\n          // If we never allow the image to scale, then the bounds will grow and shrink to counter the effects\n          // Of the camera zoom\n          // The location is within the world, but we reverse project the anchor spread\n          const anchorEffect: Vec2 = [0, 0];\n\n          if (image.anchor) {\n            anchorEffect[0] = image.anchor.x || 0;\n            anchorEffect[1] = image.anchor.y || 0;\n          }\n\n          const topLeft = view.worldToScreen(\n            subtract2(image.position, divide2(anchorEffect, view.camera.scale))\n          );\n\n          const screenPoint = view.worldToScreen(point);\n\n          // Reverse project the size and we should be within the distorted world coordinates\n          const bounds = new Bounds({\n            height: image.height,\n            width: image.width,\n            x: topLeft[0],\n            y: topLeft[1]\n          });\n\n          return bounds.containsPoint(screenPoint);\n        }\n\n        return true;\n      }\n    };\n  }\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<ImageInstance> {\n    const animations = this.props.animate || {};\n    const {\n      tint: animateTint,\n      location: animateLocation,\n      size: animateSize\n    } = animations;\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: 0,\n      1: 0,\n      2: 0,\n      3: 1,\n      4: 1,\n      5: 1\n    };\n\n    return {\n      fs: require(\"./image-layer.fs\"),\n      instanceAttributes: [\n        {\n          easing: animateLocation,\n          name: ImageLayer.attributeNames.location,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.position\n        },\n        {\n          name: ImageLayer.attributeNames.anchor,\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.anchor.x || 0, o.anchor.y || 0]\n        },\n        {\n          easing: animateSize,\n          name: ImageLayer.attributeNames.size,\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.width, o.height]\n        },\n        {\n          name: ImageLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        {\n          name: ImageLayer.attributeNames.scaling,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scaling]\n        },\n        {\n          atlas: {\n            key: this.props.atlas || \"\",\n            name: \"imageAtlas\"\n          },\n          name: ImageLayer.attributeNames.texture,\n          update: o => this.resource.request(this, o, o.resource)\n        },\n        {\n          easing: animateTint,\n          name: ImageLayer.attributeNames.tint,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.tint\n        }\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: _u => [1]\n        }\n      ],\n      vertexAttributes: [\n        // TODO: This is from the heinous evils of THREEJS and their inability to fix a bug within our lifetimes.\n        // Right now position is REQUIRED in order for rendering to occur, otherwise the draw range gets updated to\n        // Zero against your wishes.\n        {\n          name: \"position\",\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexToSide[vertex],\n            0\n          ]\n        }\n      ],\n      vertexCount: 6,\n      vs: require(\"./image-layer.vs\")\n    };\n  }\n\n  getModelType(): IModelType {\n    return {\n      drawMode: Three.TriangleStripDrawMode,\n      modelType: Three.Mesh\n    };\n  }\n\n  getMaterialOptions(): IMaterialOptions {\n    return CommonMaterialOptions.transparentImage;\n  }\n}\n","import { IInstanceOptions, Instance } from \"../../instance-provider/instance\";\nimport { observable } from \"../../instance-provider/observable\";\n\nexport interface IEdgeInstanceOptions extends IInstanceOptions {\n  /** The color of this edge at the start point. */\n  colorStart?: [number, number, number, number];\n  /** The color of this edge at the end point. */\n  colorEnd?: [number, number, number, number];\n  /** This is the list of control points  */\n  control?: [number, number][];\n  /** The z depth of the edge (for draw ordering) */\n  depth?: number;\n  /** End point of the edge. */\n  end: [number, number];\n  /** Beginning point of the edge. */\n  start: [number, number];\n  /** Start width of the edge. */\n  widthStart?: number;\n  /** End width of the edge */\n  widthEnd?: number;\n}\n\nexport type EdgeColor = [number, number, number, number];\n\nexport class EdgeInstance extends Instance {\n  @observable colorStart: EdgeColor = [1.0, 1.0, 1.0, 1.0];\n  @observable colorEnd: EdgeColor = [1.0, 1.0, 1.0, 1.0];\n  @observable control: [number, number][] = [[0, 0], [0, 0]];\n  @observable depth: number = 0;\n  @observable end: [number, number] = [0, 0];\n  @observable start: [number, number] = [0, 0];\n  @observable widthStart: number = 1.0;\n  @observable widthEnd: number = 1.0;\n\n  get length() {\n    const delta = [this.end[0] - this.start[0], this.end[1] - this.start[1]];\n\n    return Math.sqrt(delta[0] * delta[0] + delta[1] * delta[1]);\n  }\n\n  /**\n   * Calculates the midpoint of the edge\n   */\n  get midpoint() {\n    return 0;\n  }\n\n  /**\n   * Calculates a perpendicular direction vector to the edge\n   */\n  get perpendicular(): [number, number] {\n    const length = this.length;\n\n    return [\n      (this.end[1] - this.start[1]) / length,\n      -(this.end[0] - this.start[0]) / length\n    ];\n  }\n\n  /**\n   * Applies the edge width to the start and end\n   */\n  setEdgeWidth(width: number) {\n    if (width) {\n      this.widthEnd = width;\n      this.widthStart = width;\n    }\n  }\n\n  /**\n   * Applies the color to the start and end\n   */\n  setColor(color: EdgeColor) {\n    this.colorStart = color;\n    this.colorEnd = color;\n  }\n\n  constructor(options: IEdgeInstanceOptions) {\n    super(options);\n    this.colorStart = options.colorStart || this.colorStart;\n    this.colorEnd = options.colorEnd || this.colorEnd;\n    this.control = options.control || this.control;\n    this.depth = options.depth || this.depth;\n    this.end = options.end || this.end;\n    this.widthStart = options.widthStart || this.widthStart;\n    this.widthEnd = options.widthEnd || this.widthEnd;\n    this.start = options.start || this.start;\n  }\n}\n","module.exports = \"precision highp float;\\n\\nvarying vec4 vertexColor;\\n${extendHeader}\\n\\nvoid main() {\\n  setColor(vertexColor);\\n  ${extend}\\n}\\n\"","module.exports = \"/**\\n  This vertex shader calculates edges based in world space to make an edge based on\\n  bezier curves with 0, 1, and 2 control points.\\n**/\\nprecision highp float;\\n\\n${import: projection}\\n\\nvarying vec4 vertexColor;\\n\\n// Interpolation type injection\\n${interpolation}\\n\\n${extendHeader}\\n\\nvoid main() {\\n  ${attributes}\\n\\n  // Destructure threejs's bug with the position requirement\\n  float normal = position.x;\\n  float interpolationTime = position.y;\\n  float interpolationIncrement = 1.0 / position.z;\\n\\n  // Convert our world points to screen space\\n  vec4 startClip = clipSpace(vec3(start, depth));\\n  vec4 endClip = clipSpace(vec3(end, depth));\\n  vec2 startScreen = (startClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\n  vec2 endScreen = (endClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\n  // Controls for this mode are screen space deltas from the end points\\n  vec2 control1 = startScreen + vec2(control.x, -control.y) * scaleFactor;\\n  vec2 control2 = endScreen + vec2(control.z, -control.w) * scaleFactor;\\n\\n  // Get the position of the current vertex\\n  vec2 currentPosition = interpolation(interpolationTime, startScreen, endScreen, control1, control2);\\n  // Calculate the next and previous segment's location on the line\\n  vec2 prePosition = interpolation(interpolationTime - interpolationIncrement, startScreen, endScreen, control1, control2);\\n  vec2 nextPosition = interpolation(interpolationTime + interpolationIncrement, startScreen, endScreen, control1, control2);\\n\\n  vec2 preLine = prePosition - currentPosition;\\n  vec2 nextLine = nextPosition - currentPosition;\\n\\n  // Get a spliced nromal at the joining of two segments to make a crisper curve\\n  vec2 currentNormal = mix(\\n    // Pick this value if we're at the beginning of the line\\n    normalize(vec2(preLine.y, -preLine.x)),\\n    mix(\\n      // Pick this value when we're between the ends\\n      normalize(vec2(preLine.y, -preLine.x) + vec2(-nextLine.y, nextLine.x)),\\n      // Pick this value if we're at the end of the line\\n      normalize(vec2(-nextLine.y, nextLine.x)),\\n      float(position.x >= 1.0)\\n    ),\\n    float(position.x > 0.0)\\n  );\\n\\n  // Get the thickness based on the side we're on\\n  float lineThickness = mix(widthStart, widthEnd, interpolationTime) / 2.0;\\n  // Start on the calculated line and push out by the normal's value\\n  vec2 vertex = currentPosition + currentNormal * (-normal * lineThickness * scaleFactor);\\n  // Get the color based on where we are on the line\\n  vertexColor = mix(colorStart, colorEnd, interpolationTime);\\n  vertexColor.a *= vertexColor.a * layerOpacity;\\n\\n  gl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), startClip.zw);\\n  gl_PointSize = 5.0;\\n\\n  ${extend}\\n}\\n\"","module.exports = \"${import: projection}\\n\\nprecision highp float;\\n\\n/**\\n  This vertex shader calculates edges whose curve and width is in screen space where the curve is\\n  bezier curves with 0, 1, and 2 control points.\\n**/\\nvarying vec4 vertexColor;\\n\\n// Interpolation type injection\\n${interpolation}\\n\\n${extendHeader}\\n\\nvoid main() {\\n  ${attributes}\\n\\n  // Destructure threejs's bug with the position requirement\\n  float normal = position.x;\\n  float interpolationTime = position.y;\\n  float interpolationIncrement = 1.0 / position.z;\\n  // Get the position of the current vertex\\n  vec2 currentPosition = interpolation(interpolationTime, start, end, control.xy, control.zw);\\n  // Calculate the next and previous segment's location on the line\\n  vec2 prePosition = interpolation(interpolationTime - interpolationIncrement, start, end, control.xy, control.zw);\\n  vec2 nextPosition = interpolation(interpolationTime + interpolationIncrement, start, end, control.xy, control.zw);\\n\\n  vec2 preLine = prePosition - currentPosition;\\n  vec2 nextLine = nextPosition - currentPosition;\\n\\n  // Get a spliced nromal at the joining of two segments to make a crisper curve\\n  vec2 currentNormal = mix(\\n    // Pick this value if we're at the beginning of the line\\n    normalize(vec2(preLine.y, -preLine.x)),\\n    mix(\\n      // Pick this value when we're between the ends\\n      normalize(vec2(preLine.y, -preLine.x) + vec2(-nextLine.y, nextLine.x)),\\n      // Pick this value if we're at the end of the line\\n      normalize(vec2(-nextLine.y, nextLine.x)),\\n      float(position.x >= 1.0)\\n    ),\\n    float(position.x > 0.0)\\n  );\\n\\n  // Get the thickness based on the side we're on\\n  float lineThickness = mix(widthStart, widthEnd, interpolationTime) / 2.0;\\n  // Start on the calculated line and push out by the normal's value\\n  vec2 vertex = currentPosition + currentNormal * (normal * lineThickness);\\n  // Get the color based on where we are on the line\\n  vertexColor = mix(colorStart, colorEnd, interpolationTime);\\n  vertexColor.a *= layerOpacity;\\n\\n  gl_Position = clipSpace(vec3(vertex, depth));\\n  gl_PointSize = 5.0;\\n\\n  ${extend}\\n}\\n\"","module.exports = \"/**\\n * Makes a linear interpolation between two points\\n *\\n * @param {vec2} s The start point\\n * @param {vec2} e The end point\\n * @param {vec2} c The bezier control point\\n * @param {float} t The interpolation value [0, 1]\\n *\\n * @returns {vec2} A point interpolated between the two provided points\\n */\\nvec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {\\n  float t1 = 1.0 - t;\\n  return pow(t1, 3.0) * p1 + 3.0 * t * pow(t1, 2.0) * c1 + 3.0 * pow(t, 2.0) * t1 * c2 + pow(t, 3.0) * p2;\\n}\\n\"","module.exports = \"/**\\n * Makes a linear interpolation between two points\\n *\\n * @param {vec2} s The start point\\n * @param {vec2} e The end point\\n * @param {vec2} c The bezier control point\\n * @param {float} t The interpolation value [0, 1]\\n *\\n * @returns {vec2} A point interpolated between the two provided points\\n */\\nvec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {\\n  return (1.0 - t) * (1.0 - t) * p1 + 2.0 * t * (1.0 - t) * c1 + t * t * p2;\\n}\\n\"","module.exports = \"/**\\n * Makes a linear interpolation between two points\\n *\\n * @param {vec2} s The start point\\n * @param {vec2} e The end point\\n * @param {vec2} c The bezier control point\\n * @param {float} t The interpolation value [0, 1]\\n *\\n * @returns {vec2} A point interpolated between the two provided points\\n */\\nvec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {\\n  return p1 + (p2 - p1) * t;\\n}\\n\"","/**\n * This file contains the logic for handling edge picking via quad tree and hit tests.\n * The methods involved are fairly robust and would clutter the layer's code file.\n */\nimport { Bounds } from \"../../primitives/bounds\";\nimport { IPickingMethods } from \"../../surface/layer\";\nimport { IProjection } from \"../../types\";\nimport {\n  add2,\n  copy2,\n  dot2,\n  length2,\n  scale2,\n  subtract2,\n  Vec2\n} from \"../../util/vector\";\nimport { EdgeInstance } from \"./edge-instance\";\nimport { IEdgeLayerProps } from \"./edge-layer\";\nimport { EdgeBroadphase, EdgeScaleType, EdgeType } from \"./types\";\nconst { pow } = Math;\n\ntype InterpolationMethod = (\n  t: number,\n  p1: Vec2,\n  p2: Vec2,\n  c1: Vec2,\n  c2: Vec2\n) => Vec2;\n\n/** This is an interpolation across a line */\nfunction linear(t: number, p1: Vec2, p2: Vec2, _c1: Vec2, _c2: Vec2): Vec2 {\n  return add2(scale2(subtract2(p2, p1), t), p1);\n}\n\n/** This is an interpolation across a bezier curve, single control */\nfunction bezier(t: number, p1: Vec2, p2: Vec2, c1: Vec2, _c2: Vec2): Vec2 {\n  return [\n    (1.0 - t) * (1.0 - t) * p1[0] + 2.0 * t * (1.0 - t) * c1[0] + t * t * p2[0],\n    (1.0 - t) * (1.0 - t) * p1[1] + 2.0 * t * (1.0 - t) * c1[1] + t * t * p2[1]\n  ];\n}\n\n/** This is an interpolation across a bezier curve, double control */\nfunction bezier2(t: number, p1: Vec2, p2: Vec2, c1: Vec2, c2: Vec2): Vec2 {\n  const t1 = 1.0 - t;\n\n  return [\n    pow(t1, 3.0) * p1[0] +\n      3.0 * t * pow(t1, 2.0) * c1[0] +\n      3.0 * pow(t, 2.0) * t1 * c2[0] +\n      pow(t, 3.0) * p2[0],\n    pow(t1, 3.0) * p1[1] +\n      3.0 * t * pow(t1, 2.0) * c1[1] +\n      3.0 * pow(t, 2.0) * t1 * c2[1] +\n      pow(t, 3.0) * p2[1]\n  ];\n}\n\n/** A quick lookup for an interpolation method based on Edge Type */\nconst interpolation: { [key: number]: InterpolationMethod } = {\n  [EdgeType.LINE]: linear,\n  [EdgeType.BEZIER]: bezier,\n  [EdgeType.BEZIER2]: bezier2\n};\n\n/** Takes two points that forms a line then calculates the nearest distance from that line to the third point */\nfunction distanceTo(start: Vec2, end: Vec2, p: Vec2) {\n  // Make a vector from a line point to the indicated point\n  const vector: Vec2 = subtract2(start, p);\n  const lineDirection: Vec2 = subtract2(end, start);\n  const lineNormal: Vec2 = [lineDirection[1], -lineDirection[0]];\n  const distance: number =\n    Math.abs(dot2(vector, lineNormal)) / length2(lineDirection);\n\n  // The distance is d = |v . r| where v is a unit perpendicular vector to the Line\n  return distance;\n}\n\n// This sets the number of iterations along a curve we sample to test collisions with\nconst TEST_RESOLUTION = 50;\n\n/**\n * This generates the picking methods needed for managing PickType.ALL for the edge layer.\n */\nexport function edgePicking<T extends EdgeInstance>(\n  props: IEdgeLayerProps<T>\n): IPickingMethods<EdgeInstance> {\n  const { broadphase, minPickDistance = 0, scaleType, type } = props;\n  const interpolate = interpolation[props.type];\n\n  const boundsAccessor = (edge: EdgeInstance) => {\n    const edgeWidthStart = edge.widthStart / 2 + minPickDistance;\n    const edgeWidthEnd = edge.widthEnd / 2 + minPickDistance;\n    // Encapsulate the endpoints as they are guaranteed to be included in the shape\n    // Each endpoint will be a box that includes the endpoint thickness\n    const bounds = new Bounds({\n      height: edge.widthStart,\n      width: edge.widthStart,\n      x: edge.start[0] - edgeWidthStart,\n      y: edge.start[1] - edgeWidthStart\n    });\n\n    bounds.encapsulate(\n      new Bounds({\n        height: edge.widthEnd,\n        width: edge.widthEnd,\n        x: edge.end[0] - edgeWidthEnd,\n        y: edge.end[1] - edgeWidthEnd\n      })\n    );\n\n    // Encapsulating the bezier control points is enough of a broadphase for beziers\n    if (props.type === EdgeType.BEZIER) {\n      bounds.encapsulate(edge.control[0]);\n    } else if (props.type === EdgeType.BEZIER2) {\n      // Encapsulating the bezier control points is enough of a broadphase for beziers\n      bounds.encapsulate(edge.control[0]);\n      bounds.encapsulate(edge.control[1]);\n    }\n\n    if (broadphase === EdgeBroadphase.PASS_X) {\n      bounds.x = Number.MIN_SAFE_INTEGER / 2;\n      bounds.width = Number.MAX_SAFE_INTEGER;\n    }\n\n    if (broadphase === EdgeBroadphase.PASS_Y) {\n      bounds.y = Number.MIN_SAFE_INTEGER / 2;\n      bounds.height = Number.MAX_SAFE_INTEGER;\n    }\n\n    return bounds;\n  };\n\n  if (scaleType === EdgeScaleType.SCREEN_CURVE) {\n    return {\n      // Provide the calculated AABB world bounds for a given circle\n      boundsAccessor,\n\n      // Provide a precise hit test for the edge. This method performs all of the rendering\n      // And hit tests within screen space as opposed to world space.\n      hitTest: (edge: EdgeInstance, point: Vec2, view: IProjection) => {\n        point = view.worldToScreen(point);\n        const mouse: Vec2 = point;\n        let closestIndex = 0;\n        let closestDistance = Number.MAX_VALUE;\n        let secondClosestIndex = 0;\n        let secondClosestDistance = Number.MAX_VALUE;\n\n        const start = view.worldToScreen(edge.start);\n        const end = view.worldToScreen(edge.end);\n        let control1: Vec2 = [0, 0];\n        let control2: Vec2 = [0, 0];\n\n        if (type === EdgeType.BEZIER) {\n          control1 = add2(start, edge.control[0]);\n        } else if (type === EdgeType.BEZIER2) {\n          control1 = add2(start, edge.control[0]);\n          control2 = add2(end, edge.control[1]);\n        }\n\n        const startPoint = copy2(start);\n        const endPoint = copy2(end);\n\n        control1 = edge.control.length > 0 ? control1 : [0, 0];\n        control2 = edge.control.length > 1 ? control2 : [0, 0];\n\n        // Loop through sample points on the line and find one that is closest to the mouse point as possible\n        for (let i = 0; i < TEST_RESOLUTION; ++i) {\n          const linePoint = interpolate(\n            i / TEST_RESOLUTION,\n            startPoint,\n            endPoint,\n            control1,\n            control2\n          );\n          const distance = length2(subtract2(mouse, linePoint));\n\n          if (distance < closestDistance) {\n            secondClosestIndex = closestIndex;\n            secondClosestDistance = closestDistance;\n            closestIndex = i;\n            closestDistance = distance;\n          } else if (distance < secondClosestDistance) {\n            secondClosestIndex = i;\n            closestDistance = distance;\n          }\n        }\n\n        const t = closestIndex / TEST_RESOLUTION;\n        const lineWidth =\n          (edge.widthEnd - edge.widthStart) * t + edge.widthStart;\n\n        if (closestIndex === secondClosestIndex) {\n          return false;\n        }\n\n        const startSegment = interpolate(\n          closestIndex / TEST_RESOLUTION,\n          startPoint,\n          endPoint,\n          control1,\n          control2\n        );\n\n        const endSegment = interpolate(\n          secondClosestIndex / TEST_RESOLUTION,\n          startPoint,\n          endPoint,\n          control1,\n          control2\n        );\n\n        // See how close the mouse is to the line between the two closest points for a more accurate\n        // Test\n        closestDistance = distanceTo(startSegment, endSegment, mouse);\n\n        // This helps determine if the mouse is beyond the end point\n        if (\n          dot2(\n            subtract2(endSegment, startSegment),\n            subtract2(mouse, startSegment)\n          ) < 0\n        ) {\n          return false;\n        }\n\n        return closestDistance < lineWidth / 2.0 + minPickDistance;\n      }\n    };\n  }\n\n  return {\n    // Provide the calculated AABB world bounds for a given circle\n    boundsAccessor,\n\n    // Provide a precise hit test for the edge\n    hitTest: (edge: EdgeInstance, point: Vec2, _view: IProjection) => {\n      const mouse: Vec2 = point;\n      let closestIndex = 0;\n      let closestDistance = Number.MAX_VALUE;\n\n      // Loop through sample points on the line and find one that is closest to the mouse point as possible\n      for (let i = 0; i < TEST_RESOLUTION; ++i) {\n        const linePoint = interpolate(\n          i / TEST_RESOLUTION,\n          edge.start,\n          edge.end,\n          edge.control.length > 0 ? edge.control[0] : [0, 0],\n          edge.control.length > 1 ? edge.control[1] : [0, 0]\n        );\n        const distance = length2(subtract2(mouse, linePoint));\n\n        if (distance < closestDistance) {\n          closestIndex = i;\n          closestDistance = distance;\n        }\n      }\n\n      const t = closestIndex / TEST_RESOLUTION;\n      const lineWidth = (edge.widthEnd - edge.widthStart) * t + edge.widthStart;\n\n      return closestDistance < lineWidth / 2.0;\n    }\n  };\n}\n","import * as Three from \"three\";\nimport { InstanceProvider } from \"../../instance-provider\";\nimport {\n  ILayerProps,\n  IModelType,\n  IPickingMethods,\n  Layer\n} from \"../../surface/layer\";\nimport {\n  IMaterialOptions,\n  InstanceAttributeSize,\n  InstanceIOValue,\n  IShaderInitialization,\n  IUniform,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../types\";\nimport {\n  CommonMaterialOptions,\n  IAutoEasingMethod,\n  shaderTemplate,\n  Vec\n} from \"../../util\";\nimport { EdgeInstance } from \"./edge-instance\";\nimport { edgePicking } from \"./edge-picking\";\nimport { EdgeBroadphase, EdgeScaleType, EdgeType } from \"./types\";\n\nexport interface IEdgeLayerProps<T extends EdgeInstance>\n  extends ILayerProps<T> {\n  /** Properties for animating attributes */\n  animate?: {\n    end?: IAutoEasingMethod<Vec>;\n    start?: IAutoEasingMethod<Vec>;\n    colorStart?: IAutoEasingMethod<Vec>;\n    colorEnd?: IAutoEasingMethod<Vec>;\n    control?: IAutoEasingMethod<Vec>;\n  };\n  /** Allows adjustments for broadphase interactions for an edge */\n  broadphase?: EdgeBroadphase;\n  /** Any distance to the mouse from an edge that is less than this distance will be picked */\n  minPickDistance?: number;\n  /** The transparency of the layer as a whole. (Makes for very efficient fading of all elements) */\n  opacity?: number;\n  /** This sets a scaling factor for the edge's line width and curve  */\n  scaleFactor?(): number;\n  /**\n   * If this is set, then the thickness of the line and the curvature of the line exists in screen space\n   * rather than world space.\n   */\n  scaleType?: EdgeScaleType;\n  /** Specifies how the edge is formed */\n  type: EdgeType;\n}\n\nexport interface IEdgeLayerState {}\n\n/** Converts a control list to an IO value */\nfunction toInstanceIOValue(value: [number, number][]): InstanceIOValue {\n  return [value[0][0], value[0][1], value[1][0], value[1][1]];\n}\n\n/** This picks the appropriate shader for the edge type desired */\nconst pickVS = {\n  [EdgeType.LINE]: require(\"./shader/edge-layer-line.vs\"),\n  [EdgeType.BEZIER]: require(\"./shader/edge-layer-bezier.vs\"),\n  [EdgeType.BEZIER2]: require(\"./shader/edge-layer-bezier2.vs\")\n};\n\n/** This is the base edge layer which is a template that can be filled with the needed specifics for a given line type */\nconst baseVS = require(\"./shader/edge-layer.vs\");\nconst screenVS = require(\"./shader/edge-layer-screen-curve.vs\");\nconst edgeFS = require(\"./shader/edge-layer.fs\");\n\n/**\n * This layer displays edges and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class EdgeLayer<\n  T extends EdgeInstance,\n  U extends IEdgeLayerProps<T>\n> extends Layer<T, U> {\n  // Set default props for the layer\n  static defaultProps: IEdgeLayerProps<EdgeInstance> = {\n    broadphase: EdgeBroadphase.ALL,\n    data: new InstanceProvider<EdgeInstance>(),\n    key: \"none\",\n    scaleType: EdgeScaleType.NONE,\n    scene: \"default\",\n    type: EdgeType.LINE\n  };\n\n  static attributeNames = {\n    start: \"start\",\n    end: \"end\",\n    widthStart: \"widthStart\",\n    widthEnd: \"widthEnd\",\n    depth: \"depth\",\n    colorStart: \"colorStart\",\n    colorEnd: \"colorEnd\",\n    control: \"control\"\n  };\n\n  /**\n   * We provide bounds and hit test information for the instances for this layer to allow for mouse picking\n   * of elements\n   */\n  getInstancePickingMethods(): IPickingMethods<EdgeInstance> {\n    return edgePicking(this.props);\n  }\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<EdgeInstance> {\n    const {\n      animate = {},\n      scaleFactor = () => 1,\n      type,\n      scaleType = EdgeScaleType.NONE\n    } = this.props;\n\n    const {\n      end: animateEnd,\n      start: animateStart,\n      colorStart: animateColorStart,\n      colorEnd: animateColorEnd,\n      control: animateControl\n    } = animate;\n\n    const MAX_SEGMENTS = type === EdgeType.LINE ? 2 : 50;\n\n    // Calculate the normals and interpolations for our vertices\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      [MAX_SEGMENTS * 2 + 2]: -1\n    };\n\n    const vertexInterpolation: { [key: number]: number } = {\n      0: 0,\n      [MAX_SEGMENTS * 2 + 2]: 1\n    };\n\n    let sign = 1;\n    for (let i = 0; i < MAX_SEGMENTS * 2; ++i) {\n      vertexToNormal[i + 1] = sign;\n      vertexInterpolation[i + 1] = Math.floor(i / 2) / (MAX_SEGMENTS - 1);\n      sign *= -1;\n    }\n\n    const templateOptions = {\n      interpolation: pickVS[type]\n    };\n\n    const vs = shaderTemplate({\n      options: templateOptions,\n      required: {\n        name: \"Edge Layer\",\n        values: [\"interpolation\"]\n      },\n      shader: scaleType === EdgeScaleType.NONE ? baseVS : screenVS,\n\n      // We do not want to remove any other templating options present\n      onToken: (token, replace) => {\n        if (!(token in templateOptions)) {\n          return `$\\{${token}}`;\n        }\n\n        return replace;\n      }\n    });\n\n    return {\n      fs: edgeFS,\n      instanceAttributes: [\n        {\n          easing: animateStart,\n          name: EdgeLayer.attributeNames.start,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.start\n        },\n        {\n          easing: animateEnd,\n          name: EdgeLayer.attributeNames.end,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.end\n        },\n        {\n          name: EdgeLayer.attributeNames.widthStart,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.widthStart]\n        },\n        {\n          name: EdgeLayer.attributeNames.widthEnd,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.widthEnd]\n        },\n        {\n          name: EdgeLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        {\n          easing: animateColorStart,\n          name: EdgeLayer.attributeNames.colorStart,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.colorStart\n        },\n        {\n          easing: animateColorEnd,\n          name: EdgeLayer.attributeNames.colorEnd,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.colorEnd\n        },\n        type === EdgeType.LINE\n          ? {\n              easing: animateControl,\n              name: EdgeLayer.attributeNames.control,\n              size: InstanceAttributeSize.FOUR,\n              update: _o => [0, 0, 0, 0]\n            }\n          : null,\n        type === EdgeType.BEZIER\n          ? {\n              easing: animateControl,\n              name: EdgeLayer.attributeNames.control,\n              size: InstanceAttributeSize.FOUR,\n              update: o => [o.control[0][0], o.control[0][1], 0, 0]\n            }\n          : null,\n        type === EdgeType.BEZIER2\n          ? {\n              easing: animateControl,\n              name: EdgeLayer.attributeNames.control,\n              size: InstanceAttributeSize.FOUR,\n              update: o => toInstanceIOValue(o.control)\n            }\n          : null\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: (_uniform: IUniform) => [scaleFactor()]\n        },\n        {\n          name: \"layerOpacity\",\n          size: UniformSize.ONE,\n          update: (_uniform: IUniform) => [\n            this.props.opacity === undefined ? 1.0 : this.props.opacity\n          ]\n        }\n      ],\n      vertexAttributes: [\n        // TODO: This is from the heinous evils of THREEJS and their inability to fix a bug within our lifetimes.\n        // Right now position is REQUIRED in order for rendering to occur, otherwise the draw range gets updated to\n        // Zero against your wishes.\n        {\n          name: \"position\",\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexInterpolation[vertex],\n            // The number of vertices\n            MAX_SEGMENTS * 2\n          ]\n        }\n      ],\n      vertexCount: MAX_SEGMENTS * 2 + 2,\n      vs: vs.shader\n    };\n  }\n\n  getModelType(): IModelType {\n    return {\n      drawMode: Three.TriangleStripDrawMode,\n      modelType: Three.Mesh\n    };\n  }\n\n  getMaterialOptions(): IMaterialOptions {\n    return CommonMaterialOptions.transparentShape;\n  }\n}\n","export * from \"./edge-layer\";\nexport * from \"./edge-instance\";\nexport * from \"./types\";\n","import { observable } from \"../../instance-provider\";\nimport { IInstanceOptions, Instance } from \"../../instance-provider/instance\";\nimport { Vec2 } from \"../../util\";\n\nexport interface ICircleInstanceOptions extends IInstanceOptions {\n  /** Center x position of the circle */\n  center: Vec2;\n  /** The radius of the circle */\n  radius: number;\n  /** The color of this circle */\n  color?: [number, number, number, number];\n  /** The z depth of the circle (for draw ordering) */\n  depth?: number;\n}\n\nexport class CircleInstance extends Instance {\n  @observable color: [number, number, number, number] = [1.0, 1.0, 1.0, 1.0];\n  @observable depth: number = 0;\n  @observable radius: number = 0;\n  @observable center: Vec2 = [0, 0];\n\n  constructor(options: ICircleInstanceOptions) {\n    super(options);\n\n    this.color = options.color || this.color;\n    this.radius = options.radius || this.radius;\n    this.center = options.center || this.center;\n    this.depth = options.depth || this.depth;\n  }\n\n  get width() {\n    return this.radius * 2;\n  }\n\n  get height() {\n    return this.radius * 2;\n  }\n}\n","module.exports = \"precision highp float;\\n\\n${import: projection}\\n\\nvarying vec4 vertexColor;\\nvarying float edgeSharpness;\\nvarying float edgeSharpnessBase;\\nvarying vec2 pointCoord;\\n\\n${extendHeader}\\n\\nvoid main() {\\n  ${attributes}\\n\\n  vertexColor = color;\\n  vertexColor.a *= layerOpacity;\\n  float size = radius * scaleFactor;\\n  edgeSharpness = mix(0.8, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));\\n  edgeSharpnessBase = mix(0.1, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));\\n  pointCoord = (position.xy + vec2(1.0, 1.0)) / 2.0;\\n\\n  // Center within clip space\\n  vec4 clipCenter = clipSpace(vec3(center, depth));\\n  // Center in screen space\\n  vec2 screenCenter = (clipCenter.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\n  // Position in screen space\\n  vec2 vertex = (position.xy * size) + screenCenter;\\n  // Position back to clip space\\n  gl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), clipCenter.zw);\\n\\n  ${extend}\\n}\\n\"","module.exports = \"precision highp float;\\n\\nvarying vec4 vertexColor;\\nvarying float edgeSharpness;\\nvarying float edgeSharpnessBase;\\nvarying vec2 pointCoord;\\n\\nfloat circle(vec2 coord, float radius){\\n  vec2 dist = coord - vec2(0.5);\\n\\n  return 1.0 - smoothstep(\\n    radius - (radius * edgeSharpness),\\n    radius + (radius * edgeSharpnessBase),\\n    dot(dist, dist) * 4.0\\n  );\\n}\\n\\n${extendHeader}\\n\\nvoid main() {\\n  float step_factor = circle(pointCoord.xy, 1.0);\\n\\n  setColor(mix(\\n    vec4(0.0, 0.0, 0.0, 0.0),\\n    vertexColor,\\n    step_factor\\n  ));\\n\\n  ${extend}\\n}\\n\"","import { add2, scale2, subtract2, Vec2 } from \"../util\";\n\n/**\n * Calculates the distance between two points, but keeps the distance in dquared form\n * thus performing Math.sqrt() on the output of this distance would provide the true\n * distance between the points.\n *\n * It is often faster and all that is needed to compare squared distances vs real distances\n * thus eliminating multiple Math.sqrt operations\n *\n * NOTE: For vectors this is the same as (pseudo code):\n * let vector3 = vector2.subtract(vector1)\n * return vector3.dot(vector3)\n *\n * @param p1 The point to find the distance from the second point\n * @param p2 The point to find the distance from the first point\n *\n * @return {number} The distance * distance between the two points\n */\nfunction squareDistance(p1: Vec2, p2: Vec2): number {\n  const delta = subtract2(p1, p2);\n  const dx = delta[0];\n  const dy = delta[1];\n\n  return dx * dx + dy * dy;\n}\n\n/**\n * Contains methods for managing or manipulating points\n *\n * @export\n * @class Point\n */\nexport class Point {\n  /**\n   * Adds two points together\n   *\n   * @static\n   * @param p1\n   * @param p2\n   * @param out If this is specified, the results will be placed into this rather than allocate a new object\n   *\n   * @return The two points added together\n   */\n  static add(p1: Vec2, p2: Vec2, out?: Vec2): Vec2 {\n    const total = add2(p1, p2);\n\n    if (out) {\n      out[0] = total[0];\n      out[1] = total[1];\n      return out;\n    }\n\n    return total;\n  }\n\n  /**\n   * @static\n   * This analyzes a test point against a list of points and determines which of the points is\n   * the closest to the test point. If there are equi-distant points in the list, this will return\n   * the first found in the list.\n   *\n   * @param testPoint The point to compare against other points\n   * @param points The list of points to be compared against\n   *\n   * @return The closest point to the test point\n   */\n  static getClosest(testPoint: Vec2, points: Vec2[]): Vec2 {\n    let closestDistance = Number.MAX_VALUE;\n    let closestPoint: Vec2 = testPoint;\n    let distance: number;\n\n    const findClosest = function(point: Vec2) {\n      distance = squareDistance(point, testPoint);\n\n      if (distance < closestDistance) {\n        closestDistance = distance;\n        closestPoint = point;\n      }\n    };\n\n    points.forEach(findClosest);\n\n    return closestPoint;\n  }\n\n  /**\n   * @static\n   * This analyzes a test point against a list of points and determines which of the points is\n   * the closest to the test point. If there are equi-distant points in the list, this will return\n   * the first found in the list.\n   *\n   * This just returns the index of the found point and not the point itself\n   *\n   * @param testPoint The point to compare against other points\n   * @param points The list of points to be compared against\n   *\n   * @return The index of the closest point to the test point\n   */\n  static getClosestIndex(testPoint: Vec2, points: Vec2[]): number {\n    let closestDistance = Number.MAX_VALUE;\n    let closestPoint: number = 0;\n    let distance: number;\n\n    const findClosest = function(point: Vec2, i: number) {\n      distance = squareDistance(point, testPoint);\n\n      if (distance < closestDistance) {\n        closestDistance = distance;\n        closestPoint = i;\n      }\n    };\n\n    points.forEach(findClosest);\n\n    return closestPoint;\n  }\n\n  /**\n   * @static\n   * This will calculate a direction vector between two points that points toward p2\n   *\n   * @param amount The start of the direction\n   * @param from The direction to point the vector towards\n   * @param normalize If true, this will make the vector have a magnitude of 1\n   */\n  static subtract(amount: Vec2, from: Vec2, normalize: boolean = false): Vec2 {\n    const delta = subtract2(from, amount);\n    let dx = delta[0];\n    let dy = delta[1];\n\n    if (normalize) {\n      const magnitude = Math.sqrt(dx * dx + dy * dy);\n      dx /= magnitude;\n      dy /= magnitude;\n    }\n\n    return [dx, dy];\n  }\n\n  /**\n   * @static\n   * Gets the distance between two points\n   *\n   * @param p1\n   * @param p2\n   * @param squared If set to true, returns the distance * distance (performs faster)\n   */\n  static getDistance(p1: Vec2, p2: Vec2, squared: boolean = false): number {\n    if (squared) {\n      return squareDistance(p1, p2);\n    }\n\n    return Math.sqrt(squareDistance(p1, p2));\n  }\n\n  /**\n   * @static\n   * Gets a point perfectly between two points\n   *\n   * @param p1\n   * @param p2\n   *\n   * @returns The point between the two provided points\n   */\n  static getMidpoint(p1: Vec2, p2: Vec2) {\n    const mid = scale2(subtract2(p2, p1), 0.5);\n\n    return add2(mid, p1);\n  }\n\n  static make(x: number, y: number) {\n    return { x, y };\n  }\n\n  /**\n   * Scales a point by a given amount\n   *\n   * @static\n   * @param p1\n   * @param s The amount to scale the point by\n   * @param out If this is specified, the results will be placed into this rather than allocate a new object\n   */\n  static scale(p1: Vec2, s: number, out?: Vec2): Vec2 {\n    if (out) {\n      out[0] = p1[0] * s;\n      out[1] = p1[1] * s;\n      return out;\n    }\n\n    return [p1[0] * s, p1[1] * s];\n  }\n\n  /**\n   * Makes a new point initialized to {0,0}\n   *\n   * @static\n   * @returns A new point object at {0,0}\n   */\n  static zero(): Vec2 {\n    return [0, 0];\n  }\n}\n","import * as Three from \"three\";\nimport { InstanceProvider } from \"../../instance-provider\";\nimport { Bounds } from \"../../primitives\";\nimport { ILayerProps, IModelType, Layer } from \"../../surface/layer\";\nimport {\n  IMaterialOptions,\n  InstanceAttributeSize,\n  IProjection,\n  IShaderInitialization,\n  IUniform,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../types\";\nimport { CommonMaterialOptions, subtract2, Vec, Vec2 } from \"../../util\";\nimport { IAutoEasingMethod } from \"../../util/auto-easing-method\";\nimport { CircleInstance } from \"./circle-instance\";\n\nexport interface ICircleLayerProps<T extends CircleInstance>\n  extends ILayerProps<T> {\n  /** This sets the  */\n  fadeOutOversized?: number;\n  /** This sets a scaling factor for the circle's radius */\n  scaleFactor?(): number;\n  /** Flags this layer to draw  */\n  disableDepthTest?: boolean;\n  /** Opacity of the layer as a whole */\n  opacity?: number;\n  /**\n   * This is the properties that can toggle on animations.\n   *\n   * NOTE: The more properties declared as animated will reduce the performance of the layer.\n   * if animated properties are created, it can be beneficial to have other layers with no\n   * animations be available for the Instances to 'rest' in when not moving.\n   */\n  animate?: {\n    center?: IAutoEasingMethod<Vec>;\n    radius?: IAutoEasingMethod<Vec>;\n    color?: IAutoEasingMethod<Vec>;\n  };\n}\n\n/**\n * This layer displays circles and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class CircleLayer<\n  T extends CircleInstance,\n  U extends ICircleLayerProps<T>\n> extends Layer<T, U> {\n  static defaultProps: ICircleLayerProps<CircleInstance> = {\n    data: new InstanceProvider<CircleInstance>(),\n    fadeOutOversized: -1,\n    key: \"\",\n    scaleFactor: () => 1,\n    scene: \"default\"\n  };\n\n  static attributeNames = {\n    center: \"center\",\n    radius: \"radius\",\n    depth: \"depth\",\n    color: \"color\"\n  };\n\n  /**\n   * We provide bounds and hit test information for the instances for this layer to allow for mouse picking\n   * of elements\n   */\n  getInstancePickingMethods() {\n    const noScaleFactor = () => 1;\n\n    return {\n      // Provide the calculated AABB world bounds for a given circle\n      boundsAccessor: (circle: CircleInstance) =>\n        new Bounds({\n          height: circle.radius * 2,\n          width: circle.radius * 2,\n          x: circle.center[0] - circle.radius,\n          y: circle.center[1] - circle.radius\n        }),\n\n      // Provide a precise hit test for the circle\n      hitTest: (circle: CircleInstance, point: Vec2, view: IProjection) => {\n        const circleScreenCenter = view.worldToScreen(circle.center);\n        const mouseScreen = view.worldToScreen(point);\n        const r = circle.radius * (this.props.scaleFactor || noScaleFactor)();\n        const delta = subtract2(mouseScreen, circleScreenCenter);\n\n        return delta[0] * delta[0] + delta[1] * delta[1] < r * r;\n      }\n    };\n  }\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<CircleInstance> {\n    const scaleFactor = this.props.scaleFactor || (() => 1);\n    const animations = this.props.animate || {};\n    const {\n      center: animateCenter,\n      radius: animateRadius,\n      color: animateColor\n    } = animations;\n\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: -1,\n      1: -1,\n      2: -1,\n      3: 1,\n      4: 1,\n      5: 1\n    };\n\n    return {\n      fs: require(\"./circle-layer.fs\"),\n      instanceAttributes: [\n        {\n          easing: animateCenter,\n          name: CircleLayer.attributeNames.center,\n          size: InstanceAttributeSize.TWO,\n          update: circle => circle.center\n        },\n        {\n          easing: animateRadius,\n          name: CircleLayer.attributeNames.radius,\n          size: InstanceAttributeSize.ONE,\n          update: circle => [circle.radius]\n        },\n        {\n          name: CircleLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: circle => [circle.depth]\n        },\n        {\n          easing: animateColor,\n          name: CircleLayer.attributeNames.color,\n          size: InstanceAttributeSize.FOUR,\n          update: circle => circle.color\n        }\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: (_uniform: IUniform) => [scaleFactor()]\n        },\n        {\n          name: \"layerOpacity\",\n          size: UniformSize.ONE,\n          update: (_uniform: IUniform) => [\n            this.props.opacity === undefined ? 1.0 : this.props.opacity\n          ]\n        }\n      ],\n      vertexAttributes: [\n        // TODO: This is from the heinous evils of THREEJS and their inability to fix a bug within our lifetimes.\n        // Right now position is REQUIRED in order for rendering to occur, otherwise the draw range gets updated to\n        // Zero against your wishes.\n        {\n          name: \"position\",\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexToSide[vertex],\n            0\n          ]\n        }\n      ],\n      vertexCount: 6,\n      vs: require(\"./circle-layer.vs\")\n    };\n  }\n\n  getModelType(): IModelType {\n    return {\n      drawMode: Three.TriangleStripDrawMode,\n      modelType: Three.Mesh\n    };\n  }\n\n  getMaterialOptions(): IMaterialOptions {\n    return CommonMaterialOptions.transparentShape;\n  }\n}\n","export * from \"./circle-layer\";\nexport * from \"./circle-instance\";\n","import { observable } from \"../../instance-provider\";\nimport { IInstanceOptions, Instance } from \"../../instance-provider/instance\";\nimport { Vec2, Vec4 } from \"../../util\";\n\nexport interface IArcInstanceOptions extends IInstanceOptions {\n  /** The start and end angle of the arc */\n  angle: Vec2;\n  /** The center point where the arc wraps around */\n  center: Vec2;\n  /** This is the end color of the arc */\n  colorEnd: Vec4;\n  /** This is the start color of the arc */\n  colorStart: Vec4;\n  /** Depth sorting of the arc (or the z value of the lable) */\n  depth: number;\n  /** The radius of how far the middle of the arc is from the center point */\n  radius: number;\n  /** The start to end thickness of the arc */\n  thickness: Vec2;\n}\n\n/**\n * This generates a new arc instance. An arc is a shape with a center and an angle that\n * is spans. This effectively can be used for a 'pie slice' or just the edge line on the pie\n * slice.\n */\nexport class ArcInstance extends Instance {\n  /** The start and end angle of the arc */\n  @observable angle: Vec2 = [0, Math.PI];\n  /** This is the end color of the arc */\n  @observable colorEnd: Vec4 = [0, 0, 0, 1];\n  /** This is the start color of the arc */\n  @observable colorStart: Vec4 = [0, 0, 0, 1];\n  /** The center point where the arc wraps around */\n  @observable center: Vec2 = [0, 0];\n  /** Depth sorting of the arc (or the z value of the lable) */\n  @observable depth: number = 0;\n  /** The radius of how far the middle of the arc is from the center point */\n  @observable radius: number = 1;\n  /** The start to end thickness of the arc */\n  @observable thickness: Vec2 = [1, 1];\n\n  constructor(options: IArcInstanceOptions) {\n    super(options);\n\n    this.angle = options.angle || this.angle;\n    this.colorEnd = options.colorEnd || this.colorEnd;\n    this.colorStart = options.colorStart || this.colorStart;\n    this.center = options.center || this.center;\n    this.depth = options.depth || this.depth;\n    this.radius = options.radius || this.radius;\n    this.thickness = options.thickness || this.thickness;\n  }\n}\n","module.exports = \"precision highp float;\\n\\nvarying vec4 vertexColor;\\n${extendHeader}\\n\\nvoid main() {\\n  setColor(vertexColor);\\n  gl_FragColor = vertexColor;\\n  ${extend}\\n}\\n\"","module.exports = \"precision highp float;\\n\\n/**\\n  This vertex shader calculates edges whose curve and width is in screen space where the curve is\\n  bezier curves with 0, 1, and 2 control points.\\n**/\\nvarying vec4 vertexColor;\\n\\nvec2 interpolation(float t, vec2 center, float radius, float start, float end) {\\n  float angle = (end - start) * t + start;\\n  return center + vec2(cos(angle) * radius, sin(angle) * radius);\\n}\\n\\n${extendHeader}\\n\\nvoid main() {\\n  ${attributes}\\n\\n  // Destructure some of the vec injections\\n  float startAngle = angle.x;\\n  float endAngle = angle.y;\\n  float widthStart = thickness.x;\\n  float widthEnd = thickness.y;\\n\\n  // Convert world points to screen space\\n  vec4 centerClip = clipSpace(vec3(center, depth));\\n  vec2 centerScreen = (centerClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\n  // Destructure threejs's bug with the position requirement\\n  float normal = position.x;\\n  float interpolationTime = position.y;\\n  float interpolationIncrement = 1.0 / position.z;\\n  // Get the position of the current vertex\\n  vec2 currentPosition = interpolation(interpolationTime, centerScreen, radius, startAngle, endAngle);\\n  // Get normal with currentPosition and center\\n  vec2 currentNormal = normalize(currentPosition - centerScreen);\\n  // Get the thickness based on the side we're on\\n  float lineThickness = mix(widthStart, widthEnd, interpolationTime) / 2.0;\\n  // Start on the calculated line and push out by the normal's value\\n  vec2 vertex = currentPosition + currentNormal * (normal * lineThickness);\\n  // Get the color based on where we are on the line\\n  vertexColor = mix(colorStart, colorEnd, interpolationTime);\\n  vertexColor *= vertexColor.a;\\n\\n  gl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), centerClip.zw);\\n  gl_PointSize = 5.0;\\n\\n  ${extend}\\n}\\n\"","module.exports = \"${import: circularArc, projection}\\nprecision highp float;\\n\\n/**\\n  This vertex shader calculates edges whose curve and width is in screen space where the curve is\\n  bezier curves with 0, 1, and 2 control points.\\n**/\\nvarying vec4 vertexColor;\\n\\n${extendHeader}\\n\\nvoid main() {\\n  ${attributes}\\n\\n  // Destructure some of the vec injections\\n  float startAngle = angle.x;\\n  float endAngle = angle.y;\\n  float widthStart = thickness.x;\\n  float widthEnd = thickness.y;\\n  // Destructure threejs's bug with the position requirement\\n  float normal = position.x;\\n  float interpolationTime = position.y;\\n  float interpolationIncrement = 1.0 / position.z;\\n  // Get the position of the current vertex\\n  vec2 currentPosition = circularArc(interpolationTime, center, radius, startAngle, endAngle);\\n  // Get normal with currentPosition and center\\n  vec2 currentNormal = normalize(currentPosition - center);\\n  // Get the thickness based on the side we're on\\n  float lineThickness = mix(widthStart, widthEnd, interpolationTime) / 2.0;\\n  // Start on the calculated line and push out by the normal's value\\n  vec2 vertex = currentPosition + currentNormal * (normal * lineThickness);\\n  // Get the color based on where we are on the line\\n  vertexColor = mix(colorStart, colorEnd, interpolationTime);\\n\\n  gl_Position = clipSpace(vec3(vertex, depth));\\n\\n  ${extend}\\n}\\n\"","import { Bounds } from \"../primitives\";\nimport {\n  IColorPickingData,\n  InstanceHitTest,\n  IPickInfo,\n  IProjection,\n  PickType\n} from \"../types\";\nimport { Instance, TrackedQuadTree, Vec2 } from \"../util\";\nimport { UniformColorDiffProcessor } from \"./buffer-management/uniform-buffering/uniform-color-diff-processor\";\nimport { ILayerProps, Layer } from \"./layer\";\n\nfunction isColorProcessor<T extends Instance>(\n  val: any\n): val is UniformColorDiffProcessor<T> {\n  return val && val.colorPicking;\n}\n\n/**\n * This manages mouse gestures broadcast to the layer and handles appropriate actions such as determining\n * how to make the interaction translate to picking events for the layer's instances.\n *\n * This class, in summary, takes in the gestures to the view and converts them to gestures to the instances.\n */\nexport class LayerInteractionHandler<\n  T extends Instance,\n  U extends ILayerProps<T>\n> {\n  /** This is the color picking information most recently rendered */\n  colorPicking?: IColorPickingData;\n  /** This tracks the elements that have the mouse currently over them */\n  isMouseOver = new Map<T, boolean>();\n  /** This tracks the elements the mouse was down on */\n  isMouseDown = new Map<T, boolean>();\n  /** This is the layer the interaction handler manages events for */\n  layer: Layer<T, U>;\n\n  constructor(layer: Layer<T, U>) {\n    this.layer = layer;\n  }\n\n  /**\n   * Retrieves the color picking instance determined for the procedure.\n   */\n  getColorPickInstance() {\n    if (\n      this.colorPicking &&\n      isColorProcessor<T>(this.layer.diffManager.processor)\n    ) {\n      return this.layer.diffManager.processor.colorPicking.uidToInstance.get(\n        0xffffff - this.colorPicking.nearestColor\n      );\n    }\n\n    return null;\n  }\n\n  /**\n   * Handles mouse down gestures for a layer within a view\n   */\n  handleMouseOver(_view: IProjection, _mouse: Vec2) {\n    // This is the mouse over for the view itself. We should probably just let the mouse over events handle the interactions\n    // With the instances\n  }\n\n  /**\n   * Handles mouse down gestures for a layer within a view\n   */\n  handleMouseDown(view: IProjection, mouse: Vec2, button: number) {\n    // This handles interactions for PickType ALL layers\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      const { onMouseDown } = this.layer.props;\n\n      // If we have a listener for either event we should continue to process the event in more detail\n      if (onMouseDown) {\n        const world = view.viewToWorld(mouse);\n        let hitTest: InstanceHitTest<T>;\n        let query: TrackedQuadTree<T>[\"query\"];\n        let querySpace;\n        let instances: T[] = [];\n\n        if (this.layer.picking.type === PickType.ALL) {\n          hitTest = this.layer.picking.hitTest;\n          query = this.layer.picking.quadTree.query.bind(\n            this.layer.picking.quadTree\n          );\n          querySpace = (check: Bounds | Vec2) =>\n            query(check).filter(o => hitTest(o, world, view));\n          instances = query(world).filter(o => hitTest(o, world, view));\n        } else if (this.layer.picking.type === PickType.SINGLE) {\n          // Get the instance for the nearest color\n          const instanceForColor = this.getColorPickInstance();\n\n          if (instanceForColor) {\n            instances.push(instanceForColor);\n          }\n        }\n\n        const info: IPickInfo<T> = {\n          button,\n          instances,\n          layer: this.layer.id,\n          projection: view,\n          querySpace,\n          screen: mouse,\n          world\n        };\n\n        onMouseDown(info);\n\n        // We track all the elements the mouse is currently down on\n        this.isMouseDown.clear();\n        instances.forEach(o => this.isMouseDown.set(o, true));\n      }\n    }\n  }\n\n  /**\n   * Handles mouse out events for a layer within the view\n   */\n  handleMouseOut(view: IProjection, mouse: Vec2) {\n    // This will fire an instance mouse out for any over instances in the queue since we left the view\n    // Thus no instances shall be considered 'over'\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      const { onMouseOut } = this.layer.props;\n\n      if (onMouseOut) {\n        const world = view.viewToWorld(mouse);\n        let hitTest: InstanceHitTest<T>;\n        let query: TrackedQuadTree<T>[\"query\"];\n        let querySpace;\n\n        if (this.layer.picking.type === PickType.ALL) {\n          hitTest = this.layer.picking.hitTest;\n          query = this.layer.picking.quadTree.query.bind(\n            this.layer.picking.quadTree\n          );\n          querySpace = (check: Bounds | Vec2) =>\n            query(check).filter(o => hitTest(o, world, view));\n        }\n\n        const info: IPickInfo<T> = {\n          instances: Array.from(this.isMouseOver.keys()),\n          layer: this.layer.id,\n          projection: view,\n          querySpace,\n          screen: mouse,\n          world\n        };\n\n        onMouseOut(info);\n      }\n    }\n\n    // We clear as no instances are over anymore\n    this.isMouseOver.clear();\n    // We also clear all down elements as the mouse is no longer in proper context for the instances\n    // But since the mouse was never actually released, we do not fire an up\n    this.isMouseDown.clear();\n  }\n\n  /**\n   * Handles mouse up gestures for the layer within the provided view\n   */\n  handleMouseUp(view: IProjection, mouse: Vec2, button: number) {\n    // This handles interactions for PickType ALL layers\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      const { onMouseUp } = this.layer.props;\n\n      // If we have a listener for either event we should continue to process the event in more detail\n      if (onMouseUp) {\n        const world = view.viewToWorld(mouse);\n        let hitTest: InstanceHitTest<T>;\n        let query: TrackedQuadTree<T>[\"query\"];\n        let querySpace;\n        let instances: T[] = [];\n\n        if (this.layer.picking.type === PickType.ALL) {\n          hitTest = this.layer.picking.hitTest;\n          query = this.layer.picking.quadTree.query.bind(\n            this.layer.picking.quadTree\n          );\n          querySpace = (check: Bounds | Vec2) =>\n            query(check).filter(o => hitTest(o, world, view));\n          instances = query(world).filter(o => hitTest(o, world, view));\n        } else if (this.layer.picking.type === PickType.SINGLE) {\n          // Get the instance for the nearest color\n          const instanceForColor = this.getColorPickInstance();\n\n          if (instanceForColor) {\n            instances.push(instanceForColor);\n          }\n        }\n\n        const info: IPickInfo<T> = {\n          button,\n          instances,\n          layer: this.layer.id,\n          projection: view,\n          querySpace,\n          screen: mouse,\n          world\n        };\n\n        onMouseUp(info);\n      }\n    }\n  }\n\n  /**\n   * Mouse move events on the layer will detect when instances have their item newly over or just moved on\n   */\n  handleMouseMove(view: IProjection, mouse: Vec2) {\n    // This handles interactions for PickType ALL layers\n    const { onMouseOver, onMouseMove, onMouseOut } = this.layer.props;\n\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      // If we have a listener for either event we should continue to process the event in more detail\n      if (onMouseOver || onMouseMove || onMouseOut) {\n        let info: IPickInfo<T>;\n        const world = view.viewToWorld(mouse);\n        let hitTest: InstanceHitTest<T>;\n        let query: TrackedQuadTree<T>[\"query\"];\n        let querySpace;\n        let instances: T[] = [];\n\n        if (this.layer.picking.type === PickType.ALL) {\n          hitTest = this.layer.picking.hitTest;\n          query = this.layer.picking.quadTree.query.bind(\n            this.layer.picking.quadTree\n          );\n          querySpace = (check: Bounds | Vec2) =>\n            query(check).filter(o => hitTest(o, world, view));\n          instances = query(world).filter(o => hitTest(o, world, view));\n        } else if (this.layer.picking.type === PickType.SINGLE) {\n          // Get the instance for the nearest color\n          const instanceForColor = this.getColorPickInstance();\n\n          if (instanceForColor) {\n            instances.push(instanceForColor);\n          }\n        }\n\n        // Broadcast the picking info for newly over instances to any of the layers listeners if needed\n        if (onMouseOver) {\n          const notOverInstances = instances.filter(\n            o => !this.isMouseOver.get(o)\n          );\n          info = {\n            instances: notOverInstances,\n            layer: this.layer.id,\n            projection: view,\n            querySpace,\n            screen: mouse,\n            world\n          };\n\n          if (notOverInstances.length > 0) onMouseOver(info);\n        }\n\n        // Broadcast the the picking info for all instances that the mouse moved on\n        if (onMouseMove) {\n          // This is the pick info object we will broadcast from the layer\n          info = {\n            instances,\n            layer: this.layer.id,\n            projection: view,\n            querySpace,\n            screen: mouse,\n            world\n          };\n\n          onMouseMove(info);\n        }\n\n        // We take the hovered instances\n        const isCurrentlyOver = new Map<T, boolean>();\n        instances.forEach(o => isCurrentlyOver.set(o, true));\n\n        // Broadcast the the picking info for all instances that the mouse moved off of\n        if (onMouseOut) {\n          const noLongerOver = Array.from(this.isMouseOver.keys()).filter(\n            o => !isCurrentlyOver.get(o)\n          );\n\n          // This is the pick info object we will broadcast from the layer\n          info = {\n            instances: noLongerOver,\n            layer: this.layer.id,\n            projection: view,\n            querySpace,\n            screen: mouse,\n            world\n          };\n\n          if (noLongerOver.length > 0) onMouseOut(info);\n        }\n\n        // We store the current hovered over items as our over item list for next interaction\n        this.isMouseOver = isCurrentlyOver;\n      }\n    }\n  }\n\n  /**\n   * Handles click gestures on the layer within a view\n   */\n  handleMouseClick(view: IProjection, mouse: Vec2, button: number) {\n    // This handles interactions for PickType ALL layers\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      const { onMouseClick } = this.layer.props;\n\n      // If we have a listener for either event we should continue to process the event in more detail\n      if (onMouseClick) {\n        const world = view.viewToWorld(mouse);\n        let hitTest: InstanceHitTest<T>;\n        let query: TrackedQuadTree<T>[\"query\"];\n        let querySpace;\n        let instances: T[] = [];\n\n        if (this.layer.picking.type === PickType.ALL) {\n          hitTest = this.layer.picking.hitTest;\n          query = this.layer.picking.quadTree.query.bind(\n            this.layer.picking.quadTree\n          );\n          querySpace = (check: Bounds | Vec2) =>\n            query(check).filter(o => hitTest(o, world, view));\n          instances = query(world).filter(o => hitTest(o, world, view));\n        } else if (this.layer.picking.type === PickType.SINGLE) {\n          // Get the instance for the nearest color\n          const instanceForColor = this.getColorPickInstance();\n\n          if (instanceForColor) {\n            instances.push(instanceForColor);\n          }\n        }\n\n        const info: IPickInfo<T> = {\n          button,\n          instances,\n          layer: this.layer.id,\n          projection: view,\n          querySpace,\n          screen: mouse,\n          world\n        };\n\n        onMouseClick(info);\n      }\n    }\n  }\n\n  /**\n   * Handles drag gestures for the layer within the view\n   */\n  handleMouseDrag(_view: IProjection, _mouse: Vec2) {\n    // We probably should not broadcast drag events for the sake of instances. Instance dragging should be handled on\n    // An instance by instance basis rather than coming from the view's gestures\n  }\n}\n","import { Instance } from \"../../../instance-provider\";\nimport { IQuadTreePickingMetrics, PickType } from \"../../../types\";\nimport {\n  BufferManagerBase,\n  IBufferLocation,\n  isBufferLocation\n} from \"../buffer-manager-base\";\nimport { IInstanceDiffManagerTarget } from \"../instance-diff-manager\";\nimport { IUniformBufferLocation } from \"./uniform-buffer-manager\";\nimport { UniformDiffProcessor } from \"./uniform-diff-processor\";\n\nconst EMPTY: number[] = [];\n\n/**\n * Manages diffs for layers that are utilizing the base uniform instancing buffer strategy.\n */\nexport class UniformQuadDiffProcessor<\n  T extends Instance\n> extends UniformDiffProcessor<T> {\n  quadPicking: IQuadTreePickingMetrics<T>;\n\n  constructor(\n    layer: IInstanceDiffManagerTarget<T>,\n    bufferManager: BufferManagerBase<T, IBufferLocation>\n  ) {\n    super(layer, bufferManager);\n\n    if (layer.picking.type === PickType.ALL) {\n      this.quadPicking = layer.picking;\n    } else {\n      console.warn(\n        \"Diff Processing Error: A layer has a diff processor requesting Quad Processing but the picking type is not valid.\"\n      );\n    }\n  }\n\n  /**\n   * This processes add operations from changes in the instancing data and manages the layer's quad tree\n   * with the instance as well.\n   */\n  addInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster?: IUniformBufferLocation\n  ) {\n    // If the uniform cluster already exists, then we swap over to a change update\n    if (uniformCluster) {\n      manager.changeInstance(manager, instance, EMPTY, uniformCluster);\n    } else {\n      // Otherwise, we DO need to perform an add and we link a Uniform cluster to our instance\n      const uniforms = manager.layer.bufferManager.add(instance);\n\n      if (isBufferLocation(uniforms)) {\n        instance.active = true;\n        instance.easingId = manager.layer.easingId;\n        manager.updateInstance(manager.layer, instance, uniforms);\n\n        // Ensure the instance has an updated injection in the quad tree\n        manager.quadPicking.quadTree.remove(instance);\n        manager.quadPicking.quadTree.add(instance);\n      }\n    }\n  }\n\n  /**\n   * This processes change operations from changes in the instancing data\n   */\n  changeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster?: IUniformBufferLocation\n  ) {\n    // If there is an existing uniform cluster for this instance, then we can update the uniforms\n    if (uniformCluster) {\n      manager.updateInstance(manager.layer, instance, uniformCluster);\n\n      // Ensure the instance has an updated injection in the quad tree\n      manager.quadPicking.quadTree.remove(instance);\n      manager.quadPicking.quadTree.add(instance);\n    } else {\n      // If we don't have existing uniforms, then we must remove the instance\n      manager.addInstance(manager, instance, EMPTY, uniformCluster);\n    }\n  }\n\n  /**\n   * This processes remove operations from changes in the instancing data\n   */\n  removeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster?: IUniformBufferLocation\n  ) {\n    if (uniformCluster) {\n      // We deactivate the instance so it does not render anymore\n      instance.active = false;\n      // Remove the easing information the instance gained from being apart of the layer\n      instance.clearEasing();\n      // We do one last update on the instance to update to it's deactivated state\n      manager.updateInstance(manager.layer, instance, uniformCluster);\n      // Unlink the instance from the uniform cluster\n      manager.layer.bufferManager.remove(instance);\n      // Remove the instance from our quad tree\n      manager.quadPicking.quadTree.remove(instance);\n    }\n  }\n}\n","import { Instance } from \"../../../instance-provider\";\nimport { ISinglePickingMetrics, PickType } from \"../../../types\";\nimport {\n  BufferManagerBase,\n  IBufferLocation,\n  isBufferLocation\n} from \"../buffer-manager-base\";\nimport { IInstanceDiffManagerTarget } from \"../instance-diff-manager\";\nimport { IUniformBufferLocation } from \"./uniform-buffer-manager\";\nimport { UniformDiffProcessor } from \"./uniform-diff-processor\";\n\nconst EMPTY: number[] = [];\n\n/**\n * Manages diffs for layers that are utilizing the base uniform instancing buffer strategy.\n */\nexport class UniformColorDiffProcessor<\n  T extends Instance\n> extends UniformDiffProcessor<T> {\n  colorPicking: ISinglePickingMetrics<T>;\n\n  constructor(\n    layer: IInstanceDiffManagerTarget<T>,\n    bufferManager: BufferManagerBase<T, IBufferLocation>\n  ) {\n    super(layer, bufferManager);\n\n    if (layer.picking.type === PickType.SINGLE) {\n      this.colorPicking = layer.picking;\n      this.colorPicking.uidToInstance = new Map<number, T>();\n    } else {\n      console.warn(\n        \"Diff Processing Error: A layer has a diff processor requesting Color Processing but the picking type is not valid.\"\n      );\n    }\n  }\n\n  /**\n   * This processes add operations from changes in the instancing data and manages the layer's matching of\n   * color / UID to Instance\n   */\n  addInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster: IUniformBufferLocation\n  ) {\n    // If the uniform cluster already exists, then we swap over to a change update\n    if (uniformCluster) {\n      manager.changeInstance(manager, instance, EMPTY, uniformCluster);\n    } else {\n      // Otherwise, we DO need to perform an add and we link a Uniform cluster to our instance\n      const uniforms = manager.layer.bufferManager.add(instance);\n\n      if (isBufferLocation(uniforms)) {\n        instance.active = true;\n        instance.easingId = manager.layer.easingId;\n        manager.updateInstance(manager.layer, instance, uniforms);\n\n        // Make sure the instance is mapped to it's UID\n        manager.colorPicking.uidToInstance.set(instance.uid, instance);\n      } else {\n        console.warn(\n          \"A data cluster was not provided by the manager to associate an instance with.\"\n        );\n      }\n    }\n  }\n\n  /**\n   * This processes change operations from changes in the instancing data\n   */\n  changeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster: IUniformBufferLocation\n  ) {\n    // If there is an existing uniform cluster for this instance, then we can update the uniforms\n    if (uniformCluster) {\n      manager.updateInstance(manager.layer, instance, uniformCluster);\n    } else {\n      // If we don't have existing uniforms, then we must remove the instance\n      manager.addInstance(manager, instance, EMPTY, uniformCluster);\n    }\n  }\n\n  /**\n   * This processes remove operations from changes in the instancing data\n   */\n  removeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster: IUniformBufferLocation\n  ) {\n    if (uniformCluster) {\n      // We deactivate the instance so it does not render anymore\n      instance.active = false;\n      // Remove the easing information the instance gained from being apart of the layer\n      instance.clearEasing();\n      // We do one last update on the instance to update to it's deactivated state\n      manager.updateInstance(manager.layer, instance, uniformCluster);\n      // Unlink the instance from the uniform cluster\n      manager.layer.bufferManager.remove(instance);\n      // Remove the instance from our quad tree\n      manager.colorPicking.uidToInstance.delete(instance.uid);\n    }\n  }\n}\n","import { Instance } from \"../../../instance-provider\";\nimport { IQuadTreePickingMetrics, PickType } from \"../../../types\";\nimport {\n  BufferManagerBase,\n  IBufferLocation,\n  isBufferLocationGroup\n} from \"../buffer-manager-base\";\nimport { IInstanceDiffManagerTarget } from \"../instance-diff-manager\";\nimport { IInstanceAttributeBufferLocationGroup } from \"./instance-attribute-buffer-manager\";\nimport { InstanceAttributeDiffProcessor } from \"./instance-attribute-diff-processor\";\n\nconst EMPTY: number[] = [];\n\n/**\n * Manages diffs for layers that are utilizing the base uniform instancing buffer strategy.\n */\nexport class InstanceAttributeQuadDiffProcessor<\n  T extends Instance\n> extends InstanceAttributeDiffProcessor<T> {\n  quadPicking: IQuadTreePickingMetrics<T>;\n\n  constructor(\n    layer: IInstanceDiffManagerTarget<T>,\n    bufferManager: BufferManagerBase<T, IBufferLocation>\n  ) {\n    super(layer, bufferManager);\n\n    if (layer.picking.type === PickType.ALL) {\n      this.quadPicking = layer.picking;\n    } else {\n      console.warn(\n        \"Diff Processing Error: A layer has a diff processor requesting Quad Processing but the picking type is not valid.\"\n      );\n    }\n  }\n\n  /**\n   * This processes add operations from changes in the instancing data and manages the layer's quad tree\n   * with the instance as well.\n   */\n  addInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    bufferLocations?: IInstanceAttributeBufferLocationGroup\n  ) {\n    // If the uniform cluster already exists, then we swap over to a change update\n    if (bufferLocations) {\n      manager.changeInstance(manager, instance, EMPTY, bufferLocations);\n    } else {\n      // Otherwise, we DO need to perform an add and we link a Uniform cluster to our instance\n      const locations = manager.layer.bufferManager.add(instance);\n\n      if (isBufferLocationGroup(locations)) {\n        instance.active = true;\n        instance.easingId = manager.layer.easingId;\n        manager.updateInstance(manager.layer, instance, EMPTY, locations);\n\n        // Ensure the instance has an updated injection in the quad tree\n        manager.quadPicking.quadTree.remove(instance);\n        manager.quadPicking.quadTree.add(instance);\n      }\n    }\n  }\n\n  /**\n   * This processes change operations from changes in the instancing data\n   */\n  changeInstance(\n    manager: this,\n    instance: T,\n    propIds: number[],\n    bufferLocations?: IInstanceAttributeBufferLocationGroup\n  ) {\n    // If there is an existing uniform cluster for this instance, then we can update the uniforms\n    if (bufferLocations) {\n      manager.updateInstance(manager.layer, instance, propIds, bufferLocations);\n\n      // Ensure the instance has an updated injection in the quad tree\n      manager.quadPicking.quadTree.remove(instance);\n      manager.quadPicking.quadTree.add(instance);\n    } else {\n      // If we don't have existing uniforms, then we must remove the instance\n      manager.addInstance(manager, instance, EMPTY, bufferLocations);\n    }\n  }\n\n  /**\n   * This processes remove operations from changes in the instancing data\n   */\n  removeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    bufferLocations?: IInstanceAttributeBufferLocationGroup\n  ) {\n    if (bufferLocations) {\n      // We deactivate the instance so it does not render anymore\n      instance.active = false;\n      // Remove the easing information the instance gained from being apart of the layer\n      instance.clearEasing();\n      // We do one last update on the instance to update to it's deactivated state\n      manager.updateInstance(manager.layer, instance, EMPTY, bufferLocations);\n      // Unlink the instance from the uniform cluster\n      manager.layer.bufferManager.remove(instance);\n      // Remove the instance from our quad tree\n      manager.quadPicking.quadTree.remove(instance);\n    }\n  }\n}\n","import { Instance } from \"../../../instance-provider\";\nimport { ISinglePickingMetrics, PickType } from \"../../../types\";\nimport {\n  BufferManagerBase,\n  IBufferLocation,\n  isBufferLocationGroup\n} from \"../buffer-manager-base\";\nimport { IInstanceDiffManagerTarget } from \"../instance-diff-manager\";\nimport { IInstanceAttributeBufferLocationGroup } from \"./instance-attribute-buffer-manager\";\nimport { InstanceAttributeDiffProcessor } from \"./instance-attribute-diff-processor\";\n\nconst EMPTY: number[] = [];\n\n/**\n * Manages diffs for layers that are utilizing the base uniform instancing buffer strategy.\n */\nexport class InstanceAttributeColorDiffProcessor<\n  T extends Instance\n> extends InstanceAttributeDiffProcessor<T> {\n  colorPicking: ISinglePickingMetrics<T>;\n\n  constructor(\n    layer: IInstanceDiffManagerTarget<T>,\n    bufferManager: BufferManagerBase<T, IBufferLocation>\n  ) {\n    super(layer, bufferManager);\n\n    if (layer.picking.type === PickType.SINGLE) {\n      this.colorPicking = layer.picking;\n      this.colorPicking.uidToInstance = new Map<number, T>();\n    } else {\n      console.warn(\n        \"Diff Processing Error: A layer has a diff processor requesting Color Processing but the picking type is not valid.\"\n      );\n    }\n  }\n\n  /**\n   * This processes add operations from changes in the instancing data and manages the layer's matching of\n   * color / UID to Instance\n   */\n  addInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    bufferLocations?: IInstanceAttributeBufferLocationGroup\n  ) {\n    // If the uniform cluster already exists, then we swap over to a change update\n    if (bufferLocations) {\n      manager.changeInstance(manager, instance, EMPTY, bufferLocations);\n    } else {\n      // Otherwise, we DO need to perform an add and we link a Uniform cluster to our instance\n      const locations = manager.layer.bufferManager.add(instance);\n\n      if (isBufferLocationGroup(locations)) {\n        instance.active = true;\n        instance.easingId = manager.layer.easingId;\n        manager.updateInstance(manager.layer, instance, EMPTY, locations);\n\n        // Make sure the instance is mapped to it's UID\n        manager.colorPicking.uidToInstance.set(instance.uid, instance);\n      } else {\n        console.warn(\n          \"A data cluster was not provided by the manager to associate an instance with.\"\n        );\n      }\n    }\n  }\n\n  /**\n   * This processes change operations from changes in the instancing data\n   */\n  changeInstance(\n    manager: this,\n    instance: T,\n    propIds: number[],\n    bufferLocations?: IInstanceAttributeBufferLocationGroup\n  ) {\n    // If there is an existing uniform cluster for this instance, then we can update the uniforms\n    if (bufferLocations) {\n      manager.updateInstance(manager.layer, instance, propIds, bufferLocations);\n    } else {\n      // If we don't have existing uniforms, then we must remove the instance\n      manager.addInstance(manager, instance, EMPTY, bufferLocations);\n    }\n  }\n\n  /**\n   * This processes remove operations from changes in the instancing data\n   */\n  removeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    bufferLocations?: IInstanceAttributeBufferLocationGroup\n  ) {\n    if (bufferLocations) {\n      // We deactivate the instance so it does not render anymore\n      instance.active = false;\n      // Remove the easing information the instance gained from being apart of the layer\n      instance.clearEasing();\n      // We do one last update on the instance to update to it's deactivated state\n      manager.updateInstance(manager.layer, instance, EMPTY, bufferLocations);\n      // Unlink the instance from the uniform cluster\n      manager.layer.bufferManager.remove(instance);\n      // Remove the instance from our quad tree\n      manager.colorPicking.uidToInstance.delete(instance.uid);\n    }\n  }\n}\n","import * as Three from \"three\";\nimport { Instance } from \"../../../instance-provider\";\nimport { UniformProcessing } from \"../../../shaders/processing/uniform-processing\";\nimport { IInstanceAttribute, PickType } from \"../../../types\";\nimport { uid, Vec2 } from \"../../../util\";\nimport { Layer } from \"../../layer\";\nimport { generateLayerModel } from \"../../layer-processing/generate-layer-model\";\nimport { Scene } from \"../../scene\";\nimport { BufferManagerBase, IBufferLocation } from \"../buffer-manager-base\";\n\nexport interface IUniformBufferLocation extends IBufferLocation {\n  /** This is the index of the instance as it appears in the buffer */\n  instanceIndex: number;\n  /** This is the instance data uniform */\n  buffer: Three.IUniform;\n  /** This is the instance data range within the instanceData uniform */\n  range: Vec2;\n}\n\nexport interface InstanceUniformBuffer {\n  /** This tracks which instances are active. Helps optimize draw range */\n  activeInstances: boolean[];\n  /** This is all of the clusters within this buffer */\n  clusters: IUniformBufferLocation[];\n  /** The first instance in the draw range */\n  firstInstance: number;\n  /** The unique geometry object for the buffer: Used to set draw range */\n  geometry: Three.BufferGeometry;\n  /** The last instance in the draw range */\n  lastInstance: number;\n  /** The unique material for the buffer: Used to provide a new set of uniforms */\n  material: Three.ShaderMaterial;\n  /** The unique model generated for the buffer: Used to allow the buffer to be rendered by adding to a scene */\n  model: Three.Object3D;\n  /** Threejs can not have duplicate objects across Scenes */\n  pickModel?: Three.Object3D;\n}\n\n/**\n * This is a Buffer Management system that performs instancing via the uniforms available to the hardware.\n * This improves compatibility with instancing for systems DRAMATICALLY as ALL systems WILL support uniforms.\n * This will NOT perform the best against true hardware instancing support, but it will have edge cases where it\n * is needed.\n *\n * When a layer has too many instance + vertex attributes for the hardware, the system will defer to this buffer methodology.\n *\n * This class does a whoooooole lot of making the magical instancing optimization controls possible.\n *\n * Our instancing hackyness comes from the idea that uniforms are fast, and you don't have to commit\n * ALL of them when you touch just a little piece, and you don't have worry about drivers not supporting\n * partial vertex buffer updates.\n *\n * This also is WebGL 1.0 compatible without any extensions that are poorly implemented. And again: does\n * NOT require entire attribute buffer commits.\n *\n * Uniforms are limited for any given draw call. So we have to create multiple materials to support\n * chunks of the instances that need to be drawn. We then have to associate an instance with the set\n * of uniforms that is related to the instance and keep them paired together. If we have too many instances\n * we must generate more buffers to accomodate them.\n *\n * If we remove instances, we must free up the uniform set so that others can use the uniforms. While the uniforms\n * are not in use, the instance should not be rendering.\n */\nexport class UniformBufferManager<T extends Instance> extends BufferManagerBase<\n  T,\n  IUniformBufferLocation\n> {\n  /** The number of uniform blocks an instance requires */\n  private uniformBlocksPerInstance: number;\n  /** The generated buffers by this manager */\n  private buffers: InstanceUniformBuffer[] = [];\n  /** The uniform clusters that are free and can be used by an instance */\n  private availableClusters: IUniformBufferLocation[] = [];\n  /** A lookup of an instance to a cluster of uniforms associated with it */\n  private instanceToCluster: { [key: number]: IUniformBufferLocation } = {};\n  /** A map of a cluster of uniforms to the buffer it comes from */\n  private clusterToBuffer = new Map<\n    IUniformBufferLocation,\n    InstanceUniformBuffer\n  >();\n\n  constructor(layer: Layer<T, any>, scene: Scene) {\n    super(layer, scene);\n\n    let maxUniformBlock: number = 0;\n    layer.instanceAttributes.forEach((attributes: IInstanceAttribute<T>) => {\n      maxUniformBlock = Math.max(attributes.block || 0, maxUniformBlock);\n    });\n\n    this.uniformBlocksPerInstance = maxUniformBlock + 1;\n  }\n\n  /**\n   * This adds an instance to the manager and gives the instance an associative\n   * block of uniforms to work with.\n   */\n  add = function(instance: T) {\n    // If there are no available buffers, we must add a buffer\n    if (this.availableClusters.length <= 0) {\n      this.makeNewBuffer();\n    }\n\n    const cluster = this.availableClusters.pop();\n\n    if (cluster) {\n      this.instanceToCluster[instance.uid] = cluster;\n    } else {\n      console.warn(\n        \"No valid cluster available for instance added to uniform manager.\"\n      );\n    }\n\n    return cluster;\n  };\n\n  /**\n   * Free all resources this manager may be holding onto\n   */\n  destroy() {\n    this.buffers.forEach(buffer => {\n      buffer.geometry.dispose();\n      buffer.material.dispose();\n    });\n  }\n\n  /**\n   * This retireves the uniforms associated with an instance, or returns nothing\n   * if the instance has not been associated yet.\n   */\n  getBufferLocations(instance: T) {\n    return this.instanceToCluster[instance.uid];\n  }\n\n  /**\n   * TODO: The uniform buffer does not need to utilize this yet. it will be more necessary\n   * when this manager updates only changed properties.\n   */\n  getActiveAttributePropertyId() {\n    return -1;\n  }\n\n  /**\n   * TODO: This is irrelevant tot his manager for now.\n   * Number of instances this buffer manages.\n   */\n  getInstanceCount() {\n    return -1;\n  }\n\n  /**\n   * TODO: The uniform buffer updates ALL attributes every change for any property so far.\n   * This should be fixed for performance improvements on the compatibility mode.\n   */\n  getUpdateAllPropertyIdList() {\n    return [];\n  }\n\n  /**\n   * Disassociates an instance with it's group of uniforms and makes the instance\n   * in the buffer no longer drawable.\n   */\n  remove = function(instance: T) {\n    const cluster = this.instanceToCluster[instance.uid];\n\n    // If the instance is associated with a cluster, we can add the cluster back to being available\n    // For another instance.\n    if (cluster) {\n      delete this.instanceToCluster[instance.uid];\n      this.availableClusters.push(cluster);\n    }\n\n    return instance;\n  };\n\n  /**\n   * Clears all elements of this manager from the current scene it was in.\n   */\n  removeFromScene() {\n    const scene = this.scene;\n\n    if (scene.container) {\n      for (let i = 0, end = this.buffers.length; i < end; ++i) {\n        const buffer = this.buffers[i];\n        scene.container.remove(buffer.model);\n        buffer.pickModel &&\n          this.scene.pickingContainer.remove(buffer.pickModel);\n      }\n\n      delete this.scene;\n    }\n  }\n\n  /**\n   * Applies the buffers to the provided scene for rendering.\n   */\n  setScene(scene: Scene) {\n    if (scene.container) {\n      for (let i = 0, end = this.buffers.length; i < end; ++i) {\n        const buffer = this.buffers[i];\n        scene.container.add(buffer.model);\n        buffer.pickModel && scene.pickingContainer.add(buffer.pickModel);\n      }\n\n      this.scene = scene;\n    } else {\n      console.warn(\"Can not set a scene that has an undefined container.\");\n    }\n  }\n\n  /**\n   * This generates a new buffer of uniforms to associate instances with.\n   */\n  makeNewBuffer() {\n    // We generate a new geometry object for the buffer as the geometry\n    // Needs to have it's own unique draw range per buffer for optimal\n    // Performance\n    const newGeometry = new Three.BufferGeometry();\n    this.layer.vertexAttributes.forEach(attribute => {\n      if (attribute.materialAttribute) {\n        newGeometry.addAttribute(attribute.name, attribute.materialAttribute);\n      }\n    });\n\n    // Ensure the draw range covers every instance in the geometry.\n    newGeometry.drawRange.start = 0;\n    newGeometry.drawRange.count =\n      this.layer.maxInstancesPerBuffer * this.layer.instanceVertexCount;\n\n    // This is the material that is generated for the layer that utilizes all of the generated and\n    // Injected shader IO and shader fragments\n    const newMaterial = this.layer.material.clone();\n    // Now make a Model for the buffer so it can be rendered withn the scene\n    const newModel = generateLayerModel(this.layer, newGeometry, newMaterial);\n    // We render junkloads of instances in a buffer. Culling will have to happen\n    // On an instance level.\n    newModel.frustumCulled = false;\n\n    // Make our new buffer which will manage the geometry and everything necessary\n    const buffer: InstanceUniformBuffer = {\n      activeInstances: [],\n      clusters: [],\n      firstInstance: 0,\n      geometry: newGeometry,\n      lastInstance: 0,\n      material: newMaterial,\n      model: newModel,\n      pickModel:\n        this.layer.picking.type === PickType.SINGLE\n          ? newModel.clone()\n          : undefined\n    };\n\n    this.buffers.push(buffer);\n\n    // Now that we have created a new buffer, we have all of it's uniforms\n    // To use to render more instances. We must take the instancing uniforms\n    // And divvy them up into clusters for our available buffer.\n    let uniformIndex = 0;\n    const uniformName = UniformProcessing.uniformPackingBufferName();\n    const instanceData = newMaterial.uniforms[uniformName];\n\n    // We must ensure the vector objects are TOTALLY unique otherwise they'll get shared across buffers\n    instanceData.value = instanceData.value.map(\n      () => new Three.Vector4(0.0, 0.0, 0.0, 0.0)\n    );\n\n    // TODO: This will go away! To satisfy the changing buffer manager interfaces, we make a\n    // fake internal attribute for now\n    const fakeAttribute = Object.assign({}, this.layer.instanceAttributes[0], {\n      bufferAttribute: new Three.InstancedBufferAttribute(\n        new Float32Array(1),\n        1\n      ),\n      uid: uid()\n    });\n\n    for (let i = 0, end = this.layer.maxInstancesPerBuffer; i < end; ++i) {\n      const cluster: IUniformBufferLocation = {\n        attribute: fakeAttribute, // TODO: This is not needed for the uniform method yet. When we break down\n        // the uniform updates into attributes, this will be utilized.\n        buffer: instanceData,\n        instanceIndex: i,\n        range: [uniformIndex, 0]\n      };\n\n      uniformIndex += this.uniformBlocksPerInstance;\n      cluster.range[1] = uniformIndex;\n\n      buffer.clusters.push(cluster);\n      this.availableClusters.push(cluster);\n      this.clusterToBuffer.set(cluster, buffer);\n    }\n\n    // Grab the global uniforms from the material and add it to the uniform's materialUniform list so that\n    // We can keep uniforms consistent across all Instances\n    for (let i = 0, end = this.layer.uniforms.length; i < end; ++i) {\n      const uniform = this.layer.uniforms[i];\n      uniform.materialUniforms.push(newMaterial.uniforms[uniform.name]);\n    }\n\n    // Now that we are ready to utilize the buffer, let's add it to the scene so it may be rendered.\n    // Each new buffer equates to one draw call.\n    if (this.scene && this.scene.container) {\n      this.scene.container.add(buffer.model);\n      buffer.pickModel && this.scene.pickingContainer.add(buffer.pickModel);\n    }\n  }\n}\n","import * as Three from \"three\";\nimport { Instance, ObservableMonitoring } from \"../../../instance-provider\";\nimport {\n  IInstanceAttribute,\n  IInstanceAttributeInternal,\n  InstanceAttributeSize,\n  PickType\n} from \"../../../types\";\nimport { uid } from \"../../../util\";\nimport { emitOnce, flushEmitOnce } from \"../../../util/emit-once\";\nimport { IModelConstructable, Layer } from \"../../layer\";\nimport { generateLayerModel } from \"../../layer-processing/generate-layer-model\";\nimport { Scene } from \"../../scene\";\nimport {\n  BufferManagerBase,\n  IBufferLocation,\n  IBufferLocationGroup\n} from \"../buffer-manager-base\";\n\nconst { max } = Math;\n\n/**\n * This represents the location of data for an instance's property to the piece of attribute buffer\n * it will update when it changes.\n */\nexport interface IInstanceAttributePackingBufferLocation\n  extends IBufferLocation {}\n\n/** Represents the Location Groupings for Instance attribute Buffer locations */\nexport type IInstanceAttributePackingBufferLocationGroup = IBufferLocationGroup<\n  IInstanceAttributePackingBufferLocation\n>;\n\n/**\n * This manages instances in how they associate with buffer data for an instanced attribute strategy that is\n * packed tightly.\n */\nexport class InstanceAttributePackingBufferManager<\n  T extends Instance\n> extends BufferManagerBase<T, IInstanceAttributePackingBufferLocation> {\n  /** This stores an attribute's name to the buffer locations generated for it */\n  private allBufferLocations: { [key: string]: IBufferLocation[] } = {};\n  /** This contains the buffer locations the system will have available */\n  private availableLocations: IInstanceAttributePackingBufferLocationGroup[] = [];\n  /** This is the number of instances the buffer draws currently */\n  currentInstancedCount = 0;\n  /** This is the mapped buffer location to the provided Instance */\n  private instanceToBufferLocation: {\n    [key: number]: IInstanceAttributePackingBufferLocationGroup;\n  } = {};\n  /**\n   * This is the number of times the buffer has grown. This is used to determine how much the buffer will grow\n   * for next growth pass.\n   */\n  private growthCount: number = 0;\n  /** This is the number of instances the buffer currently supports */\n  private maxInstancedCount: number = 1000;\n\n  // These are the only Three objects that must be monitored for disposal\n  private geometry?: Three.InstancedBufferGeometry;\n  private material?: Three.ShaderMaterial;\n  private model?: IModelConstructable & Three.Object3D;\n  private pickModel?: IModelConstructable & Three.Object3D | undefined;\n  private attributes?: IInstanceAttributeInternal<T>[];\n  private blockAttributes?: IInstanceAttributeInternal<T>[];\n  private blockSubAttributesLookup = new Map<number, IInstanceAttribute<T>[]>();\n\n  /** This is a mapping of all attributes to their associated property ids that, when the property changes, the attribute will be updated */\n  private attributeToPropertyIds = new Map<IInstanceAttribute<T>, number[]>();\n  /**\n   * This is a trimmed listing of minimum property ids needed to trigger an update on all properties.\n   * This is used by the diffing process mostly to handle adding a new instance.\n   */\n  private updateAllPropertyIdList: number[] = [];\n  /**\n   * This is the discovered property id of the active attribute for the instance type this manager manages.\n   * This is used by the diffing process to target updates related to deactivating an instance.\n   */\n  private activePropertyId: number = -1;\n\n  constructor(layer: Layer<T, any>, scene: Scene) {\n    super(layer, scene);\n    // Start our add method as a registration step.\n    this.add = this.doAddWithRegistration;\n  }\n\n  /**\n   * First instance to be added to this manager will be heavily analyzed for used observables per attribute.\n   */\n  private doAddWithRegistration(instance: T) {\n    // We need to find out how an instance interacts with the attributes, so we will\n    // loop through the instances, call their updates and get feedback\n    this.layer.instanceAttributes.forEach(attribute => {\n      // We don't need to register child attributes as they get updated as a consequence to parent attributes\n      if (attribute.parentAttribute) return;\n      // Activate monitoring of ids, this also resets the monitor's list\n      ObservableMonitoring.setObservableMonitor(true);\n      // Access the update which accesses an instance's properties (usually)\n      attribute.update(instance);\n      // We now have all of the ids of the properties that were used in updating the attributes\n      const propertyIdsForAttribute = ObservableMonitoring.getObservableMonitorIds(\n        true\n      );\n      // Store the mapping of the property ids\n      this.attributeToPropertyIds.set(attribute, propertyIdsForAttribute);\n\n      // If this is the active attribute, then we track the property id that modifies it\n      // for handling internal instance management.\n      if (attribute === this.layer.activeAttribute) {\n        this.activePropertyId = propertyIdsForAttribute[0];\n      }\n    });\n\n    // SUPER IMPORTANT to deactivate this here. Leaving this turned on causes memory to be chewed up\n    // for every property getter.\n    ObservableMonitoring.setObservableMonitor(false);\n    // This analyzes the properties and how they affect the attributes. It determines the smallest\n    // list possible of property ids needed to trigger an update on all of the attributes.\n    this.makeUpdateAllPropertyIdList();\n    // Do the first resize which creates the buffer and makes all of the initial buffer locations\n    const locationInfo = this.resizeBuffer();\n    // After all of the property id to attribute associations are made, we must break down the buffers\n    // into locations and then group those locations which will become our instance to buffer location\n    // slots\n    this.gatherLocationsIntoGroups(\n      locationInfo.newLocations,\n      locationInfo.growth\n    );\n    // After the first registration add, we gear shift to a more efficient add method.\n    this.add = this.doAdd;\n\n    // Perform the add after all of the registration process is complete\n    return this.doAdd(instance);\n  }\n\n  /**\n   * After the registration add happens, we gear shift over to this add method which will only pair instances\n   * with their appropriate buffer location.\n   */\n  private doAdd(instance: T) {\n    // Ensure we have buffer locations available\n    if (this.availableLocations.length <= 0) {\n      // Resice the buffer to accommodate more instances\n      const locationInfo = this.resizeBuffer();\n      // Break down the newly generated buffers into property groupings for the instances\n      this.gatherLocationsIntoGroups(\n        locationInfo.newLocations,\n        locationInfo.growth\n      );\n    }\n\n    // Get the next available location\n    const bufferLocations = this.availableLocations.shift();\n\n    // Pair up the instance with it's buffer location\n    if (bufferLocations && this.geometry) {\n      this.instanceToBufferLocation[instance.uid] = bufferLocations;\n      this.currentInstancedCount = this.geometry.maxInstancedCount = max(\n        this.currentInstancedCount,\n        // Instance index + 1 because the indices are zero indexed and the maxInstancedCount is a count value\n        bufferLocations.instanceIndex + 1\n      );\n      this.geometry.drawRange = {\n        count: this.currentInstancedCount * this.layer.instanceVertexCount,\n        start: 0\n      };\n    } else {\n      console.error(\n        \"Add Error: Instance Attribute Buffer Manager failed to pair an instance with a buffer location\"\n      );\n    }\n\n    return bufferLocations;\n  }\n\n  /**\n   * Destroy this manager and clear out all elements utilized within the scene.\n   */\n  destroy() {\n    if (this.geometry) this.geometry.dispose();\n    if (this.material) this.material.dispose();\n\n    if (this.scene && this.scene.container && this.model) {\n      this.scene.container.remove(this.model);\n    }\n  }\n\n  /**\n   * This retireves the buffer locations associated with an instance, or returns nothing\n   * if the instance has not been associated yet.\n   */\n  getBufferLocations(instance: T) {\n    return this.instanceToBufferLocation[instance.uid];\n  }\n\n  /**\n   * This is the property id of the active attribute.\n   */\n  getActiveAttributePropertyId() {\n    return this.activePropertyId;\n  }\n\n  /**\n   * This is the bare minimum property ids that, when triggered for update, will update ALL of the attribute buffers\n   * for the managed layer.\n   */\n  getUpdateAllPropertyIdList() {\n    return this.updateAllPropertyIdList;\n  }\n\n  /**\n   * Analyzes the list of attributes to the property ids that affects them. This populates the list\n   * of minimal property ids needed to trigger updates on all of the attributes.\n   */\n  private makeUpdateAllPropertyIdList() {\n    // Make a deduping list of ids\n    const updateAllPropertyIdList: { [key: number]: number } = {};\n\n    // Get unique ids that will target all attributes\n    this.attributeToPropertyIds.forEach(ids => {\n      updateAllPropertyIdList[ids[0]] = ids[0];\n    });\n\n    // Store the list for the diffing process to utilize\n    this.updateAllPropertyIdList = Object.values(\n      updateAllPropertyIdList\n    ).filter(Boolean);\n  }\n\n  /**\n   * Disassociates an instance with a buffer\n   */\n  remove = (instance: T) => {\n    const location = this.instanceToBufferLocation[instance.uid];\n\n    if (location) {\n      delete this.instanceToBufferLocation[instance.uid];\n      this.availableLocations.push(location);\n    }\n\n    return instance;\n  };\n\n  /**\n   * Clears all elements of this manager from the current scene it was in.\n   */\n  removeFromScene() {\n    if (this.scene && this.scene.container && this.model) {\n      this.scene.container.remove(this.model);\n    }\n\n    this.pickModel && this.scene.pickingContainer.remove(this.pickModel);\n    delete this.scene;\n  }\n\n  /**\n   * This generates a new buffer of attributes to associate instances with.\n   *\n   * This method for the attribute packing strategy creates a vertex attribute for each block required.\n   * The individual properties are then packed into each of these blocks.\n   */\n  private resizeBuffer() {\n    let growth = 0;\n    // Each attribute will generate lists of new buffer locations after being created or expanded\n    const attributeToNewBufferLocations = new Map<\n      string,\n      IInstanceAttributePackingBufferLocation[]\n    >();\n\n    // If our geometry is not created yet, then it need be made\n    if (!this.geometry) {\n      // The buffer grows from 0 to our initial instance count\n      growth = this.maxInstancedCount;\n      // We generate a new geometry object for the buffer as the geometry\n      // Needs to have it's own unique draw range per buffer for optimal\n      // Performance.\n      this.geometry = new Three.InstancedBufferGeometry();\n\n      // The geometry needs the vertex information (which should be shared amongst all instances of the layer)\n      // These are static non-dynamic buffers for the instance.\n      for (const attribute of this.layer.vertexAttributes) {\n        if (attribute.materialAttribute) {\n          this.geometry.addAttribute(\n            attribute.name,\n            attribute.materialAttribute\n          );\n        }\n      }\n\n      this.attributes = [];\n      this.blockAttributes = [];\n\n      // We have to determine how many blocks will be used to cram all of our instance properties into.\n      // So we calculate how big each block will be. The number of sizes calculated will be how manyblocks\n      // need to be generated.\n      const blockSizes = new Map<number, number>();\n      const blockSubAttributesLookup = new Map<\n        number,\n        IInstanceAttribute<T>[]\n      >();\n      this.blockSubAttributesLookup = blockSubAttributesLookup;\n\n      for (\n        let i = 0, iMax = this.layer.instanceAttributes.length;\n        i < iMax;\n        ++i\n      ) {\n        const attribute = this.layer.instanceAttributes[i];\n        const block = attribute.block || 0;\n        let blockSize = blockSizes.get(block) || 0;\n        // Determine the bigger of the block sizes (incoming attribute or previously checked attribute)\n        blockSize = Math.max(\n          blockSize,\n          (attribute.blockIndex || 0) + (attribute.size || 0)\n        );\n        // Store the larger size for the block\n        blockSizes.set(block, blockSize);\n        // We need to store all of the attributes associated with a block\n        let blockAttributes = blockSubAttributesLookup.get(block);\n\n        if (!blockAttributes) {\n          blockAttributes = [];\n          blockSubAttributesLookup.set(block, blockAttributes);\n        }\n\n        blockAttributes.push(attribute);\n      }\n\n      // Let's sort all of the attributes associated with each block by their index in the block\n      // so from here on out we can assume they are in ascending order\n      blockSubAttributesLookup.forEach(attributes =>\n        attributes.sort((a, b) => (a.blockIndex || 0) - (b.blockIndex || 0))\n      );\n\n      // Now that we have the blocks that will be needed to accommodate the attributes, we will\n      // create these blocks as attributes attached to the geometry.\n      for (let block = 0, iMax = blockSizes.size; block < iMax; ++block) {\n        // Get the size each attribute will be for the block\n        const blockSize: number = blockSizes.get(block) || 0;\n        // This is an interesting case, the attributes that are generated are packed into other attributes\n        // for optimal use of the vertex attributes allotted for a systems resources.\n        const blockAttributeUID = uid();\n\n        if (!blockSize) {\n          console.warn(\n            \"Instance Attribute Packing Error: The system tried to build an attribute with a size of zero.\",\n            \"These are the attributes used:\",\n            this.layer.instanceAttributes,\n            \"These are the block sizes calculated\",\n            blockSizes,\n            \"This is the block to attribute lookup generated\",\n            blockSubAttributesLookup\n          );\n        }\n\n        // Make our attribute buffer to accommodate all of the instances to be rendered.\n        const buffer = new Float32Array(blockSize * this.maxInstancedCount);\n        // Make an instanced buffer to take advantage of hardware instancing\n        const bufferAttribute = new Three.InstancedBufferAttribute(\n          buffer,\n          blockSize\n        );\n        bufferAttribute.setDynamic(true);\n\n        // Add the attribute to our geometry labeled as a block like the uniform block packing strategy\n        this.geometry.addAttribute(`block${block}`, bufferAttribute);\n\n        // Get all of the attributes that will be applied to this block\n        const blockSubAttributes = blockSubAttributesLookup.get(block);\n\n        if (blockSubAttributes) {\n          for (let k = 0, kMax = blockSubAttributes.length; k < kMax; ++k) {\n            const attribute = blockSubAttributes[k];\n\n            let newBufferLocations = attributeToNewBufferLocations.get(\n              attribute.name\n            );\n\n            if (!newBufferLocations) {\n              newBufferLocations = [];\n              attributeToNewBufferLocations.set(\n                attribute.name,\n                newBufferLocations\n              );\n            }\n\n            const allLocations = this.allBufferLocations[attribute.name] || [];\n            this.allBufferLocations[attribute.name] = allLocations;\n\n            const internalAttribute: IInstanceAttributeInternal<\n              T\n            > = Object.assign({}, attribute, {\n              uid: block,\n              packUID: blockAttributeUID,\n              bufferAttribute,\n              size: blockSize\n            });\n\n            const startAttributeIndex = attribute.blockIndex || 0;\n            const attributeSize = attribute.size || 1;\n\n            for (let i = 0; i < this.maxInstancedCount; ++i) {\n              const newLocation: IBufferLocation = {\n                attribute: internalAttribute,\n                block,\n                buffer: {\n                  value: buffer\n                },\n                instanceIndex: i,\n                range: [\n                  i * blockSize + startAttributeIndex,\n                  i * blockSize + startAttributeIndex + attributeSize\n                ]\n              };\n\n              newBufferLocations.push(newLocation);\n              allLocations.push(newLocation);\n            }\n\n            this.attributes.push(internalAttribute);\n          }\n\n          // Make an internal instance attribute for tracking\n          this.blockAttributes.push({\n            uid: uid(),\n            packUID: blockAttributeUID,\n            bufferAttribute,\n            name: `block${block}`,\n            size: InstanceAttributeSize.FOUR,\n            update: () => [0]\n          });\n        } else {\n          console.warn(\n            \"Instance Attribute Packing Buffer Error: Somehow there are no attributes associated with a block.\",\n            \"These are the attributes used:\",\n            this.layer.instanceAttributes,\n            \"These are the block sizes calculated\",\n            blockSizes,\n            \"This is the block to attribute lookup generated\",\n            blockSubAttributesLookup\n          );\n        }\n      }\n\n      // Ensure the draw range covers every instance in the geometry.\n      this.geometry.maxInstancedCount = 0;\n      // This is the material that is generated for the layer that utilizes all of the generated and\n      // Injected shader IO and shader fragments\n      this.material = this.layer.material.clone();\n\n      // Grab the global uniforms from the material and add it to the uniform's materialUniform list so that\n      // We can keep uniforms consistent across all Instances\n      for (let i = 0, end = this.layer.uniforms.length; i < end; ++i) {\n        const uniform = this.layer.uniforms[i];\n        uniform.materialUniforms.push(this.material.uniforms[uniform.name]);\n      }\n    } else {\n      // If the geometry is already created, then we will expand each instanced attribute to the next growth\n      // level and generate the new buffer locations based on the expansion\n      // Since were are resizing the buffer, let's destroy the old buffer and make one anew\n      this.geometry.dispose();\n      this.geometry = new Three.InstancedBufferGeometry();\n      const previousInstanceAmount = this.maxInstancedCount;\n\n      // The geometry needs the vertex information (which should be shared amongst all instances of the layer)\n      for (const attribute of this.layer.vertexAttributes) {\n        if (attribute.materialAttribute) {\n          this.geometry.addAttribute(\n            attribute.name,\n            attribute.materialAttribute\n          );\n        }\n      }\n\n      // We grow our buffer by magnitudes of 10 * 1024\n      // First growth: 1000\n      // Next: 10000\n      // Next: 10000\n      // Next: 10000\n      // Next: 10000\n      // We cap at growth of 1 million to prevent a mass unused RAM void.\n      this.growthCount = Math.min(1, this.growthCount + 1);\n      growth = Math.pow(10, this.growthCount) * 1000;\n      this.maxInstancedCount += growth;\n\n      // Ensure attributes is still defined\n      this.attributes = this.attributes || [];\n      this.blockAttributes = this.blockAttributes || [];\n\n      for (\n        let block = 0, iMax = this.blockAttributes.length;\n        block < iMax;\n        ++block\n      ) {\n        const attribute = this.blockAttributes[block];\n        let bufferAttribute = attribute.bufferAttribute;\n        const size: number = attribute.size || 0;\n\n        if (bufferAttribute.array instanceof Float32Array) {\n          // Make a new buffer that is the proper size\n          const buffer: Float32Array = new Float32Array(\n            this.maxInstancedCount * size\n          );\n          // Retain all of the information in the previous buffer\n          buffer.set(bufferAttribute.array, 0);\n          // Make our new attribute based on the grown buffer\n          const newAttribute = new Three.InstancedBufferAttribute(buffer, size);\n          // Set the attribute to dynamic so we can update ranges within it\n          newAttribute.setDynamic(true);\n          // Make sure our attribute is updated with the newly made attribute\n          attribute.bufferAttribute = bufferAttribute = newAttribute;\n          // Add the new attribute to our new geometry object\n          this.geometry.addAttribute(attribute.name, newAttribute);\n\n          // Since we have a new buffer object we are working with, we must update all of the existing buffer\n          // locations to utilize this new buffer. The locations keep everything else the same, but the buffer\n          // object itself should be updated\n          // Get all of the attributes that will be applied to this block\n          const blockSubAttributes = this.blockSubAttributesLookup.get(block);\n          const blockSize = attribute.size || 0;\n\n          if (blockSubAttributes) {\n            for (let k = 0, kMax = blockSubAttributes.length; k < kMax; ++k) {\n              const subAttribute = blockSubAttributes[k];\n\n              let newBufferLocations = attributeToNewBufferLocations.get(\n                subAttribute.name\n              );\n\n              if (!newBufferLocations) {\n                newBufferLocations = [];\n                attributeToNewBufferLocations.set(\n                  subAttribute.name,\n                  newBufferLocations\n                );\n              }\n\n              const allLocations =\n                this.allBufferLocations[subAttribute.name] || [];\n              this.allBufferLocations[subAttribute.name] = allLocations;\n\n              const internalAttribute: IInstanceAttributeInternal<\n                T\n              > = Object.assign({}, subAttribute, {\n                uid: uid(),\n                packUID: attribute.packUID,\n                bufferAttribute\n              });\n\n              const startAttributeIndex = subAttribute.blockIndex || 0;\n              const attributeSize = subAttribute.size || 1;\n\n              // Update all existing attribute locations with the new internal attribute\n              for (let j = 0, jMax = allLocations.length; j < jMax; ++j) {\n                const location = allLocations[j];\n                location.attribute = internalAttribute;\n              }\n\n              // Create new locations for each new instance we will cover\n              for (\n                let i = previousInstanceAmount;\n                i < this.maxInstancedCount;\n                ++i\n              ) {\n                const newLocation: IBufferLocation = {\n                  attribute: internalAttribute,\n                  block,\n                  buffer: {\n                    value: buffer\n                  },\n                  instanceIndex: i,\n                  range: [\n                    i * blockSize + startAttributeIndex,\n                    i * blockSize + startAttributeIndex + attributeSize\n                  ]\n                };\n\n                newBufferLocations.push(newLocation);\n                allLocations.push(newLocation);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Remove any existing model\n    if (this.scene && this.model && this.scene.container) {\n      this.scene.container.remove(this.model);\n    }\n\n    // Make sure the picking element is removed as well\n    if (this.scene && this.scene.pickingContainer && this.pickModel) {\n      this.scene.pickingContainer.remove(this.pickModel);\n    }\n\n    // Ensure material is defined\n    this.material = this.material || this.layer.material.clone();\n    // Remake the model with the generated geometry\n    this.model = generateLayerModel(this.layer, this.geometry, this.material);\n    // We render junkloads of instances for a given buffer. Culling will have to happen\n    // On an instance level.\n    this.model.frustumCulled = false;\n    // Make a picking model if we need it so we can render the model with a different uniform set\n    // for the picking procedure.\n    this.pickModel =\n      this.layer.picking.type === PickType.SINGLE\n        ? this.model.clone()\n        : undefined;\n\n    // Now that we are ready to utilize the buffer, let's add it to the scene so it may be rendered.\n    // Each new buffer equates to one draw call.\n    if (this.scene && this.scene.container) {\n      this.scene.container.add(this.model);\n\n      if (this.pickModel) {\n        this.scene.pickingContainer.add(this.pickModel);\n      }\n    }\n\n    return {\n      growth,\n      newLocations: attributeToNewBufferLocations\n    };\n  }\n\n  /**\n   * This takes newly created buffer locations and groups them by the property ids identified by the\n   * registration phase.\n   */\n  private gatherLocationsIntoGroups(\n    attributeToNewBufferLocations: Map<\n      string,\n      IInstanceAttributePackingBufferLocation[]\n    >,\n    totalNewInstances: number\n  ) {\n    if (this.attributeToPropertyIds.size === 0) return;\n\n    // Optimize inner loops by pre-fetching lookups by names\n    const attributesBufferLocations: {\n      attribute: IInstanceAttribute<T>;\n      bufferLocationsForAttribute: IInstanceAttributePackingBufferLocation[];\n      childBufferLocations: IInstanceAttributePackingBufferLocation[][];\n      ids: number[];\n    }[] = [];\n\n    this.attributeToPropertyIds.forEach((ids, attribute) => {\n      attributesBufferLocations.push({\n        attribute,\n        bufferLocationsForAttribute:\n          attributeToNewBufferLocations.get(attribute.name) || [],\n        childBufferLocations: (attribute.childAttributes || []).map(\n          attr => attributeToNewBufferLocations.get(attr.name) || []\n        ),\n        ids\n      });\n    });\n\n    // Loop through all of the new instances available and gather all of the buffer locations\n    for (let i = 0; i < totalNewInstances; ++i) {\n      const group: IInstanceAttributePackingBufferLocationGroup = {\n        instanceIndex: -1,\n        propertyToBufferLocation: {}\n      };\n\n      // Loop through all of the property ids that affect specific attributes. Each of these ids\n      // needs an association with the buffer location they modify.\n      for (let j = 0, endj = attributesBufferLocations.length; j < endj; ++j) {\n        const allLocations = attributesBufferLocations[j];\n        const attribute = allLocations.attribute;\n        const ids = allLocations.ids;\n        const bufferLocationsForAttribute =\n          allLocations.bufferLocationsForAttribute;\n\n        if (!bufferLocationsForAttribute) {\n          emitOnce(\n            \"Instance Attribute Buffer Error\",\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: There is an error in forming buffer location groups in InstanceAttributePackingBufferManager. Error count: ${count}`\n              );\n            }\n          );\n          continue;\n        }\n\n        const bufferLocation = bufferLocationsForAttribute.shift();\n\n        if (!bufferLocation) {\n          emitOnce(\n            \"Instance Attribute Buffer Error\",\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: There is an error in forming buffer location groups in InstanceAttributePackingBufferManager. Error count: ${count}`\n              );\n            }\n          );\n          continue;\n        }\n\n        if (group.instanceIndex === -1) {\n          group.instanceIndex = bufferLocation.instanceIndex;\n        } else if (bufferLocation.instanceIndex !== group.instanceIndex) {\n          emitOnce(\n            \"Instance Attribute Parallelism Error\",\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: A buffer location does not have a matching instance index which means the buffer locations are not in parallel with each other somehow. Error count: ${count}`\n              );\n              console.warn(attribute.name, bufferLocation);\n            }\n          );\n          continue;\n        }\n\n        // If the attribute has children attributes. Then when the attribute is updated, the child attributes should\n        // be updated as well. Thus the buffer location needs the child attribute buffer locations.\n        if (attribute.childAttributes) {\n          const childLocations = [];\n\n          for (\n            let k = 0, endk = attribute.childAttributes.length;\n            k < endk;\n            ++k\n          ) {\n            const childAttribute = attribute.childAttributes[k];\n            const bufferLocationsForChildAttribute =\n              allLocations.childBufferLocations[k];\n\n            if (bufferLocationsForChildAttribute) {\n              const childBufferLocation = bufferLocationsForChildAttribute.shift();\n              if (childBufferLocation) {\n                childLocations.push(childBufferLocation);\n              } else {\n                emitOnce(\n                  \"Instance Attribute Child Attribute Error\",\n                  (count: number, id: string) => {\n                    console.warn(\n                      `${id}: A child attribute does not have a buffer location available. Error count: ${count}`\n                    );\n                    console.warn(\n                      `Parent Attribute: ${attribute.name} Child Attribute: ${\n                        childAttribute.name\n                      }`\n                    );\n                  }\n                );\n              }\n            }\n          }\n\n          bufferLocation.childLocations = childLocations;\n        }\n\n        // In the group, associate the property ids that affect a buffer location WITH the buffer location they affect\n        for (let k = 0, endk = ids.length; k < endk; ++k) {\n          const id = ids[k];\n          group.propertyToBufferLocation[id] = bufferLocation;\n        }\n      }\n\n      // Store this group as a group that is ready to be associated with an instance\n      this.availableLocations.push(group);\n    }\n\n    // This helps ensure errors get reported in a timely fashion in case this triggers some massive looping\n    flushEmitOnce();\n  }\n\n  /**\n   * Returns the total instances this buffer manages.\n   */\n  getInstanceCount() {\n    return this.maxInstancedCount;\n  }\n}\n","import * as Three from \"three\";\nimport { Instance, ObservableMonitoring } from \"../../../instance-provider\";\nimport { getAttributeShaderName } from \"../../../shaders/processing/formatting\";\nimport {\n  IInstanceAttribute,\n  IInstanceAttributeInternal,\n  PickType\n} from \"../../../types\";\nimport { emitOnce, flushEmitOnce } from \"../../../util/emit-once\";\nimport { uid } from \"../../../util/uid\";\nimport { IModelConstructable, Layer } from \"../../layer\";\nimport { generateLayerModel } from \"../../layer-processing/generate-layer-model\";\nimport { Scene } from \"../../scene\";\nimport {\n  BufferManagerBase,\n  IBufferLocation,\n  IBufferLocationGroup\n} from \"../buffer-manager-base\";\n\nconst { max } = Math;\n\n/**\n * This represents the location of data for an instance's property to the piece of attribute buffer\n * it will update when it changes.\n */\nexport interface IInstanceAttributeBufferLocation extends IBufferLocation {}\n\n/** Represents the Location Groupings for Instance attribute Buffer locations */\nexport type IInstanceAttributeBufferLocationGroup = IBufferLocationGroup<\n  IInstanceAttributeBufferLocation\n>;\n\n/**\n * This manages instances in how they associate with buffer data for an instanced attribute strategy.\n */\nexport class InstanceAttributeBufferManager<\n  T extends Instance\n> extends BufferManagerBase<T, IInstanceAttributeBufferLocation> {\n  /** This stores an attribute's name to the buffer locations generated for it */\n  private allBufferLocations: { [key: string]: IBufferLocation[] } = {};\n  /** This contains the buffer locations the system will have available */\n  private availableLocations: IInstanceAttributeBufferLocationGroup[] = [];\n  /** This is the number of instances the buffer draws currently */\n  currentInstancedCount = 0;\n  /** This is the mapped buffer location to the provided Instance */\n  private instanceToBufferLocation: {\n    [key: number]: IInstanceAttributeBufferLocationGroup;\n  } = {};\n  /**\n   * This is the number of times the buffer has grown. This is used to determine how much the buffer will grow\n   * for next growth pass.\n   */\n  private growthCount: number = 0;\n  /** This is the number of instances the buffer currently supports */\n  private maxInstancedCount: number = 1000;\n\n  // These are the only Three objects that must be monitored for disposal\n  private geometry?: Three.InstancedBufferGeometry;\n  private material?: Three.ShaderMaterial;\n  private model?: IModelConstructable & Three.Object3D;\n  private pickModel?: IModelConstructable & Three.Object3D | undefined;\n  private attributes?: IInstanceAttributeInternal<T>[];\n\n  /** This is a mapping of all attributes to their associated property ids that, when the property changes, the attribute will be updated */\n  private attributeToPropertyIds = new Map<IInstanceAttribute<T>, number[]>();\n  /**\n   * This is a trimmed listing of minimum property ids needed to trigger an update on all properties.\n   * This is used by the diffing process mostly to handle adding a new instance.\n   */\n  private updateAllPropertyIdList: number[] = [];\n  /**\n   * This is the discovered property id of the active attribute for the instance type this manager manages.\n   * This is used by the diffing process to target updates related to deactivating an instance.\n   */\n  private activePropertyId: number = -1;\n\n  constructor(layer: Layer<T, any>, scene: Scene) {\n    super(layer, scene);\n    // Start our add method as a registration step.\n    this.add = this.doAddWithRegistration;\n  }\n\n  /**\n   * First instance to be added to this manager will be heavily analyzed for used observables per attribute.\n   */\n  private doAddWithRegistration(instance: T) {\n    // We need to find out how an instance interacts with the attributes, so we will\n    // loop through the instances, call their updates and get feedback\n    this.layer.instanceAttributes.forEach(attribute => {\n      // We don't need to register child attributes as they get updated as a consequence to parent attributes\n      if (attribute.parentAttribute) return;\n      // Activate monitoring of ids, this also resets the monitor's list\n      ObservableMonitoring.setObservableMonitor(true);\n      // Access the update which accesses an instances properties (usually)\n      attribute.update(instance);\n      // We now have all of the ids of the properties that were used in updating the attributes\n      const propertyIdsForAttribute = ObservableMonitoring.getObservableMonitorIds(\n        true\n      );\n      // Store the mapping of the property ids\n      this.attributeToPropertyIds.set(attribute, propertyIdsForAttribute);\n\n      // If this is the active attribute, then we track the property id that modifies it\n      // for handling internal instance management.\n      if (attribute === this.layer.activeAttribute) {\n        this.activePropertyId = propertyIdsForAttribute[0];\n      }\n    });\n\n    // SUPER IMPORTANT to deactivate this here. Leaving this turned on causes memory to be chewed up\n    // for every property getter.\n    ObservableMonitoring.setObservableMonitor(false);\n    // This analyzes the properties and how they affect the attributes. It determines the smallest\n    // list possible of property ids needed to trigger an update on all of the attributes.\n    this.makeUpdateAllPropertyIdList();\n    // Do the first resize which creates the buffer and makes all of the initial buffer locations\n    const locationInfo = this.resizeBuffer();\n    // After all of the property id to attribute associations are made, we must break down the buffers\n    // into locations and then group those locations which will become our instance to buffer location\n    // slots\n    this.gatherLocationsIntoGroups(\n      locationInfo.newLocations,\n      locationInfo.growth\n    );\n    // After the first registration add, we gear shift to a more efficient add method.\n    this.add = this.doAdd;\n\n    // Perform the add after all of the registration process is complete\n    return this.doAdd(instance);\n  }\n\n  /**\n   * After the registration add happens, we gear shift over to this add method which will only pair instances\n   * with their appropriate buffer location.\n   */\n  private doAdd(instance: T) {\n    // Ensure we have buffer locations available\n    if (this.availableLocations.length <= 0) {\n      // Resice the buffer to accommodate more instances\n      const locationInfo = this.resizeBuffer();\n      // Break down the newly generated buffers into property groupings for the instances\n      this.gatherLocationsIntoGroups(\n        locationInfo.newLocations,\n        locationInfo.growth\n      );\n    }\n\n    // Get the next available location\n    const bufferLocations = this.availableLocations.shift();\n\n    // Pair up the instance with it's buffer location\n    if (bufferLocations && this.geometry) {\n      this.instanceToBufferLocation[instance.uid] = bufferLocations;\n      this.currentInstancedCount = this.geometry.maxInstancedCount = max(\n        this.currentInstancedCount,\n        // Instance index + 1 because the indices are zero indexed and the maxInstancedCount is a count value\n        bufferLocations.instanceIndex + 1\n      );\n      this.geometry.drawRange = {\n        count: this.currentInstancedCount * this.layer.instanceVertexCount,\n        start: 0\n      };\n    } else {\n      console.error(\n        \"Add Error: Instance Attribute Buffer Manager failed to pair an instance with a buffer location\"\n      );\n    }\n\n    return bufferLocations;\n  }\n\n  destroy() {\n    if (this.geometry) this.geometry.dispose();\n    if (this.material) this.material.dispose();\n\n    if (this.scene && this.scene.container && this.model) {\n      this.scene.container.remove(this.model);\n    }\n  }\n\n  /**\n   * This retireves the buffer locations associated with an instance, or returns nothing\n   * if the instance has not been associated yet.\n   */\n  getBufferLocations(instance: T) {\n    return this.instanceToBufferLocation[instance.uid];\n  }\n\n  /**\n   * This is the property id of the active attribute.\n   */\n  getActiveAttributePropertyId() {\n    return this.activePropertyId;\n  }\n\n  /**\n   * This is the bare minimum property ids that, when triggered for update, will update ALL of the attribute buffers\n   * for the managed layer.\n   */\n  getUpdateAllPropertyIdList() {\n    return this.updateAllPropertyIdList;\n  }\n\n  /**\n   * Analyzes the list of attributes to the property ids that affects them. This populates the list\n   * of minimal property ids needed to trigger updates on all of the attributes.\n   */\n  private makeUpdateAllPropertyIdList() {\n    // Make a deduping list of ids\n    const updateAllPropertyIdList: { [key: number]: number } = {};\n\n    // Get unique ids that will target all attributes\n    this.attributeToPropertyIds.forEach(ids => {\n      updateAllPropertyIdList[ids[0]] = ids[0];\n    });\n\n    // Store the list for the diffing process to utilize\n    this.updateAllPropertyIdList = Object.values(\n      updateAllPropertyIdList\n    ).filter(Boolean);\n  }\n\n  /**\n   * Disassociates an instance with a buffer\n   */\n  remove = (instance: T) => {\n    const location = this.instanceToBufferLocation[instance.uid];\n\n    if (location) {\n      delete this.instanceToBufferLocation[instance.uid];\n      this.availableLocations.push(location);\n    }\n\n    return instance;\n  };\n\n  /**\n   * Clears all elements of this manager from the current scene it was in.\n   */\n  removeFromScene() {\n    if (this.scene && this.scene.container && this.model) {\n      this.scene.container.remove(this.model);\n    }\n    this.pickModel && this.scene.pickingContainer.remove(this.pickModel);\n    delete this.scene;\n  }\n\n  /**\n   * This generates a new buffer of uniforms to associate instances with.\n   */\n  private resizeBuffer() {\n    let growth = 0;\n    // Each attribute will generate lists of new buffer locations after being created or expanded\n    const attributeToNewBufferLocations = new Map<\n      string,\n      IInstanceAttributeBufferLocation[]\n    >();\n\n    // If our geometry is not created yet, then it need be made\n    if (!this.geometry) {\n      // The buffer grows from 0 to our initial instance count\n      growth = this.maxInstancedCount;\n      // We generate a new geometry object for the buffer as the geometry\n      // Needs to have it's own unique draw range per buffer for optimal\n      // Performance.\n      this.geometry = new Three.InstancedBufferGeometry();\n\n      // The geometry needs the vertex information (which should be shared amongst all instances of the layer)\n      for (const attribute of this.layer.vertexAttributes) {\n        if (attribute.materialAttribute) {\n          this.geometry.addAttribute(\n            attribute.name,\n            attribute.materialAttribute\n          );\n        }\n      }\n\n      this.attributes = [];\n\n      // We now take the instance attributes and add them as Instanced Attributes to our geometry\n      for (const attribute of this.layer.instanceAttributes) {\n        // We start with enough data in the buffer to accommodate 1024 instances\n        const size: number = attribute.size || 0;\n        const buffer = new Float32Array(size * this.maxInstancedCount);\n        const bufferAttribute = new Three.InstancedBufferAttribute(\n          buffer,\n          size\n        );\n        bufferAttribute.setDynamic(true);\n        this.geometry.addAttribute(\n          getAttributeShaderName(attribute),\n          bufferAttribute\n        );\n        let newBufferLocations = attributeToNewBufferLocations.get(\n          attribute.name\n        );\n\n        if (!newBufferLocations) {\n          newBufferLocations = [];\n          attributeToNewBufferLocations.set(attribute.name, newBufferLocations);\n        }\n\n        const allLocations = this.allBufferLocations[attribute.name] || [];\n        this.allBufferLocations[attribute.name] = allLocations;\n\n        const internalAttribute: IInstanceAttributeInternal<T> = Object.assign(\n          {},\n          attribute,\n          { uid: uid(), bufferAttribute: bufferAttribute }\n        );\n\n        for (let i = 0; i < this.maxInstancedCount; ++i) {\n          const newLocation: IBufferLocation = {\n            attribute: internalAttribute,\n            buffer: {\n              value: buffer\n            },\n            instanceIndex: i,\n            range: [i * size, i * size + size]\n          };\n\n          newBufferLocations.push(newLocation);\n          allLocations.push(newLocation);\n        }\n\n        // Make an internal instance attribute for tracking\n        this.attributes.push(internalAttribute);\n      }\n\n      // Ensure the draw range covers every instance in the geometry.\n      this.geometry.maxInstancedCount = 0;\n      // This is the material that is generated for the layer that utilizes all of the generated and\n      // Injected shader IO and shader fragments\n      this.material = this.layer.material.clone();\n\n      // Grab the global uniforms from the material and add it to the uniform's materialUniform list so that\n      // We can keep uniforms consistent across all Instances\n      for (let i = 0, end = this.layer.uniforms.length; i < end; ++i) {\n        const uniform = this.layer.uniforms[i];\n        uniform.materialUniforms.push(this.material.uniforms[uniform.name]);\n      }\n    } else {\n      // If the geometry is already created, then we will expand each instanced attribute to the next growth\n      // level and generate the new buffer locations based on the expansion\n      // Since were are resizing the buffer, let's destroy the old buffer and make one anew\n      this.geometry.dispose();\n      this.geometry = new Three.InstancedBufferGeometry();\n      const previousInstanceAmount = this.maxInstancedCount;\n\n      // The geometry needs the vertex information (which should be shared amongst all instances of the layer)\n      for (const attribute of this.layer.vertexAttributes) {\n        if (attribute.materialAttribute) {\n          this.geometry.addAttribute(\n            attribute.name,\n            attribute.materialAttribute\n          );\n        }\n      }\n\n      // We grow our buffer by magnitudes of 10 * 1024\n      // First growth: 1000\n      // Next: 10000\n      // Next: 10000\n      // Next: 10000\n      // Next: 10000\n      // We cap at growth of 1 million to prevent a mass unused RAM void.\n      this.growthCount = Math.min(1, this.growthCount + 1);\n      growth = Math.pow(10, this.growthCount) * 1000;\n      this.maxInstancedCount += growth;\n\n      // Ensure attributes is still defined\n      this.attributes = this.attributes || [];\n\n      for (const attribute of this.attributes) {\n        const bufferAttribute = attribute.bufferAttribute;\n        const size: number = attribute.size || 0;\n\n        if (bufferAttribute.array instanceof Float32Array) {\n          // Make a new buffer that is the proper size\n          const buffer: Float32Array = new Float32Array(\n            this.maxInstancedCount * size\n          );\n          // Retain all of the information in the previous buffer\n          buffer.set(bufferAttribute.array, 0);\n          // Make our new attribute based on the grown buffer\n          const newAttribute = new Three.InstancedBufferAttribute(buffer, size);\n          // Set the attribute to dynamic so we can update ranges within it\n          newAttribute.setDynamic(true);\n          // Make sure our attribute is updated with the newly made attribute\n          attribute.bufferAttribute = newAttribute;\n          // Add the new attribute to our new geometry object\n          this.geometry.addAttribute(\n            getAttributeShaderName(attribute),\n            newAttribute\n          );\n          // Get the temp storage for new buffer locations\n          let newBufferLocations = attributeToNewBufferLocations.get(\n            attribute.name\n          );\n\n          // Since we have a new buffer object we are working with, we must update all of the existing buffer\n          // locations to utilize this new buffer. The locations keep everything else the same, but the buffer\n          // object itself should be updated\n          const allLocations = this.allBufferLocations[attribute.name] || [];\n          this.allBufferLocations[attribute.name] = allLocations;\n\n          for (let k = 0, endk = allLocations.length; k < endk; ++k) {\n            allLocations[k].buffer.value = buffer;\n          }\n\n          if (!newBufferLocations) {\n            newBufferLocations = [];\n            attributeToNewBufferLocations.set(\n              attribute.name,\n              newBufferLocations\n            );\n          }\n\n          for (\n            let i = previousInstanceAmount, end = this.maxInstancedCount;\n            i < end;\n            ++i\n          ) {\n            const newLocation: IBufferLocation = {\n              attribute,\n              buffer: {\n                value: buffer\n              },\n              instanceIndex: i,\n              range: [i * size, i * size + size]\n            };\n\n            newBufferLocations.push(newLocation);\n            allLocations.push(newLocation);\n          }\n        }\n      }\n\n      if (this.scene.container && this.model) {\n        this.scene.container.remove(this.model);\n      }\n    }\n\n    if (this.scene && this.model && this.scene.container) {\n      this.scene.container.remove(this.model);\n    }\n\n    if (this.scene && this.scene.pickingContainer && this.pickModel) {\n      this.scene.pickingContainer.remove(this.pickModel);\n    }\n\n    // Ensure material is defined\n    this.material = this.material || this.layer.material.clone();\n    // Remake the model with the generated geometry\n    this.model = generateLayerModel(this.layer, this.geometry, this.material);\n    // We render junkloads of instances for a given buffer. Culling will have to happen\n    // On an instance level.\n    this.model.frustumCulled = false;\n    // Make a picking model if we need it so we can render the model with a different uniform set\n    // for the picking procedure.\n    this.pickModel =\n      this.layer.picking.type === PickType.SINGLE\n        ? this.model.clone()\n        : undefined;\n\n    // Now that we are ready to utilize the buffer, let's add it to the scene so it may be rendered.\n    // Each new buffer equates to one draw call.\n    if (this.scene && this.scene.container) {\n      this.scene.container.add(this.model);\n\n      if (this.pickModel) {\n        this.scene.pickingContainer.add(this.pickModel);\n      }\n    }\n\n    return {\n      growth,\n      newLocations: attributeToNewBufferLocations\n    };\n  }\n\n  /**\n   * This takes newly created buffer locations and groups them by the property ids identified by the\n   * registration phase.\n   */\n  private gatherLocationsIntoGroups(\n    attributeToNewBufferLocations: Map<\n      string,\n      IInstanceAttributeBufferLocation[]\n    >,\n    totalNewInstances: number\n  ) {\n    if (this.attributeToPropertyIds.size === 0) return;\n\n    // Optimize inner loops by pre-fetching lookups by names\n    const attributesBufferLocations: {\n      attribute: IInstanceAttribute<T>;\n      bufferLocationsForAttribute: IInstanceAttributeBufferLocation[];\n      childBufferLocations: IInstanceAttributeBufferLocation[][];\n      ids: number[];\n    }[] = [];\n\n    this.attributeToPropertyIds.forEach((ids, attribute) => {\n      attributesBufferLocations.push({\n        attribute,\n        bufferLocationsForAttribute:\n          attributeToNewBufferLocations.get(attribute.name) || [],\n        childBufferLocations: (attribute.childAttributes || []).map(\n          attr => attributeToNewBufferLocations.get(attr.name) || []\n        ),\n        ids\n      });\n    });\n\n    // Loop through all of the new instances available and gather all of the buffer locations\n    for (let i = 0; i < totalNewInstances; ++i) {\n      const group: IInstanceAttributeBufferLocationGroup = {\n        instanceIndex: -1,\n        propertyToBufferLocation: {}\n      };\n\n      // Loop through all of the property ids that affect specific attributes. Each of these ids\n      // needs an association with the buffer location they modify.\n      for (let j = 0, endj = attributesBufferLocations.length; j < endj; ++j) {\n        const allLocations = attributesBufferLocations[j];\n        const attribute = allLocations.attribute;\n        const ids = allLocations.ids;\n        const bufferLocationsForAttribute =\n          allLocations.bufferLocationsForAttribute;\n\n        if (!bufferLocationsForAttribute) {\n          emitOnce(\n            \"Instance Attribute Buffer Error\",\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: There is an error in forming buffer location groups in InstanceAttributeBufferManager. Error count: ${count}`\n              );\n            }\n          );\n          continue;\n        }\n\n        const bufferLocation = bufferLocationsForAttribute.shift();\n\n        if (!bufferLocation) {\n          emitOnce(\n            \"Instance Attribute Buffer Error\",\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: There is an error in forming buffer location groups in InstanceAttributeBufferManager. Error count: ${count}`\n              );\n            }\n          );\n          continue;\n        }\n\n        if (group.instanceIndex === -1) {\n          group.instanceIndex = bufferLocation.instanceIndex;\n        } else if (bufferLocation.instanceIndex !== group.instanceIndex) {\n          emitOnce(\n            \"Instance Attribute Parallelism Error\",\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: A buffer location does not have a matching instance index which means the buffer locations are not in parallel with each other somehow. Error count: ${count}`\n              );\n              console.warn(attribute.name, bufferLocation);\n            }\n          );\n          continue;\n        }\n\n        // If the attribute has children attributes. Then when the attribute is updated, the child attributes should\n        // be updated as well. Thus the buffer location needs the child attribute buffer locations.\n        if (attribute.childAttributes) {\n          const childLocations = [];\n\n          for (\n            let k = 0, endk = attribute.childAttributes.length;\n            k < endk;\n            ++k\n          ) {\n            const childAttribute = attribute.childAttributes[k];\n            const bufferLocationsForChildAttribute =\n              allLocations.childBufferLocations[k];\n\n            if (bufferLocationsForChildAttribute) {\n              const childBufferLocation = bufferLocationsForChildAttribute.shift();\n              if (childBufferLocation) {\n                childLocations.push(childBufferLocation);\n              } else {\n                emitOnce(\n                  \"Instance Attribute Child Attribute Error\",\n                  (count: number, id: string) => {\n                    console.warn(\n                      `${id}: A child attribute does not have a buffer location available. Error count: ${count}`\n                    );\n                    console.warn(\n                      `Parent Attribute: ${attribute.name} Child Attribute: ${\n                        childAttribute.name\n                      }`\n                    );\n                  }\n                );\n              }\n            }\n          }\n\n          bufferLocation.childLocations = childLocations;\n        }\n\n        // In the group, associate the property ids that affect a buffer location WITH the buffer location they affect\n        for (let k = 0, endk = ids.length; k < endk; ++k) {\n          const id = ids[k];\n          group.propertyToBufferLocation[id] = bufferLocation;\n        }\n      }\n\n      // Store this group as a group that is ready to be associated with an instance\n      this.availableLocations.push(group);\n    }\n\n    // This helps ensure errors get reported in a timely fashion in case this triggers some massive looping\n    flushEmitOnce();\n  }\n\n  /**\n   * Returns the total instances this buffer manages.\n   */\n  getInstanceCount() {\n    return this.maxInstancedCount;\n  }\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport {\n  IInstanceAttribute,\n  INonePickingMetrics,\n  IQuadTreePickingMetrics,\n  ISinglePickingMetrics,\n  PickType\n} from \"../../types\";\nimport { LayerBufferType } from \"../layer-processing/layer-buffer-type\";\nimport { AtlasResourceManager } from \"../texture/atlas-resource-manager\";\nimport { BaseDiffProcessor } from \"./base-diff-processor\";\nimport { IBufferLocationGroup } from \"./buffer-manager-base\";\nimport { BufferManagerBase, IBufferLocation } from \"./buffer-manager-base\";\nimport { InstanceAttributeColorDiffProcessor } from \"./instance-attribute-buffering/instance-attribute-color-diff-processor\";\nimport { InstanceAttributeDiffProcessor } from \"./instance-attribute-buffering/instance-attribute-diff-processor\";\nimport { InstanceAttributeQuadDiffProcessor } from \"./instance-attribute-buffering/instance-attribute-quad-diff-processor\";\nimport { UniformColorDiffProcessor } from \"./uniform-buffering/uniform-color-diff-processor\";\nimport { UniformDiffProcessor } from \"./uniform-buffering/uniform-diff-processor\";\nimport { UniformQuadDiffProcessor } from \"./uniform-buffering/uniform-quad-diff-processor\";\n\n/** Signature of a method that handles a diff */\nexport type DiffHandler<T extends Instance> = (\n  manager: BaseDiffProcessor<T>,\n  instance: T,\n  propIds: number[],\n  bufferLocations?: IBufferLocation | IBufferLocationGroup<IBufferLocation>\n) => void;\n/** A set of diff handling methods in this order [change, add, remove] */\nexport type DiffLookup<T extends Instance> = DiffHandler<T>[];\n\n/**\n * This interface is the bare minimum properties needed for this diff manager to map instance updates to\n * uniform changes. We don't use a Layer as a target explicitly to avoid circular/hard dependencies\n */\nexport interface IInstanceDiffManagerTarget<T extends Instance> {\n  /** This is the attribute for the target that represents the _active injected value */\n  activeAttribute: IInstanceAttribute<T>;\n  /** This is used by the automated easing system and is the easing Ids used by the layer for given attributes */\n  easingId: { [key: string]: number };\n  /** This is all of the instance attributes applied to the target */\n  instanceAttributes: IInstanceAttribute<T>[];\n  /** This is the picking metrics for how Instances are picked with the mouse */\n  picking:\n    | IQuadTreePickingMetrics<T>\n    | ISinglePickingMetrics<T>\n    | INonePickingMetrics;\n  /** This is the resource manager for the target which let's us fetch information from an atlas for an instance */\n  resource: AtlasResourceManager;\n  /** This is the manager that links an instance to it's uniform cluster for populating the uniform buffer */\n  bufferManager: BufferManagerBase<T, IBufferLocation>;\n  /** This is the buffering strategy being used */\n  bufferType: LayerBufferType;\n}\n\n/**\n * This class manages the process of taking the diffs of a layer and executing methods on those diffs to perform\n * updates to the uniforms that control those instances.\n */\nexport class InstanceDiffManager<T extends Instance> {\n  bufferManager: BufferManagerBase<T, IBufferLocation>;\n  processor: BaseDiffProcessor<T>;\n  processing: DiffLookup<T>;\n  layer: IInstanceDiffManagerTarget<T>;\n\n  constructor(\n    layer: IInstanceDiffManagerTarget<T>,\n    bufferManager: BufferManagerBase<T, IBufferLocation>\n  ) {\n    this.layer = layer;\n    this.bufferManager = bufferManager;\n  }\n\n  /**\n   * This returns the proper diff processor for handling diffs\n   */\n  makeProcessor(): DiffLookup<T> {\n    // If this manager has already figured out which processor to use. Just return that processor.\n    if (this.processing) return this.processing;\n\n    if (\n      this.layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE ||\n      this.layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE_PACKING\n    ) {\n      // Now we look at the state of the layer to determine the best diff processor strategy\n      if (this.layer.picking) {\n        if (this.layer.picking.type === PickType.SINGLE) {\n          this.processor = new InstanceAttributeColorDiffProcessor(\n            this.layer,\n            this.bufferManager\n          );\n        } else if (this.layer.picking.type === PickType.ALL) {\n          this.processor = new InstanceAttributeQuadDiffProcessor(\n            this.layer,\n            this.bufferManager\n          );\n        }\n      }\n\n      if (!this.processor) {\n        this.processor = new InstanceAttributeDiffProcessor(\n          this.layer,\n          this.bufferManager\n        );\n      }\n    } else {\n      // Now we look at the state of the layer to determine the best diff processor strategy\n      if (this.layer.picking) {\n        if (this.layer.picking.type === PickType.ALL) {\n          this.processor = new UniformQuadDiffProcessor(\n            this.layer,\n            this.bufferManager\n          );\n        } else if (this.layer.picking.type === PickType.SINGLE) {\n          this.processor = new UniformColorDiffProcessor(\n            this.layer,\n            this.bufferManager\n          );\n        }\n      }\n\n      if (!this.processor) {\n        this.processor = new UniformDiffProcessor(\n          this.layer,\n          this.bufferManager\n        );\n      }\n    }\n\n    this.processing = [\n      this.processor.changeInstance,\n      this.processor.addInstance,\n      this.processor.removeInstance\n    ];\n\n    return this.processing;\n  }\n}\n","import { IInstanceProvider } from \"../surface/layer\";\nimport { InstanceDiffType } from \"../types\";\nimport { Instance } from \"./instance\";\n\n/**\n * This is an entry within the change list of the provider. It represents the type of change\n * and stores the property id's of the properties on the instance that have changed.\n */\nexport type InstanceDiff<T extends Instance> = [\n  T,\n  InstanceDiffType,\n  { [key: number]: number }\n];\n\ntype InstanceDisposer<T extends Instance> = [T, Function];\n\n/**\n * This is an optimized provider, that can provide instances that use the internal observable system\n * to deliver updates to the framework.\n */\nexport class InstanceProvider<T extends Instance>\n  implements IInstanceProvider<T> {\n  /** Stores the disposers that are called when the instance is no longer listened to */\n  private cleanObservation = new Map<number, InstanceDisposer<T>>();\n  /** This stores the changes to the instances themselves */\n  private instanceChanges = new Map<number, InstanceDiff<T>>();\n  /** This flag is true when resolving changes when the change list is retrieved. it blocks changes until the current list is resolved */\n  private allowChanges = true;\n  /**\n   * This indicates the context this provider was handled within. Currently, only one context is allowed per provider,\n   * so we use this to detect when multiple contexts have attempted use of this provider.\n   */\n  resolveContext: string = \"\";\n\n  /**\n   * Retrieve all of the changes applied to instances\n   */\n  get changeList(): InstanceDiff<T>[] {\n    this.allowChanges = false;\n    const changes = Array.from(this.instanceChanges.values());\n\n    return changes;\n  }\n\n  /**\n   * Adds an instance to the provider which will stream observable changes of the instance to\n   * the framework.\n   */\n  add(instance: T) {\n    // No need to duplicate the addition\n    if (this.cleanObservation.get(instance.uid)) {\n      return instance;\n    }\n\n    if (this.allowChanges) {\n      instance.observer = this;\n      const disposer: Function = instance.observableDisposer;\n      // Store the disposers so we can clean up the observable properties\n      this.cleanObservation.set(instance.uid, [instance, disposer]);\n      // Indicate we have a new instance\n      this.instanceChanges.set(instance.uid, [\n        instance,\n        InstanceDiffType.INSERT,\n        instance.changes\n      ]);\n    }\n\n    return instance;\n  }\n\n  /**\n   * Removes all instances from this provider\n   */\n  clear() {\n    this.cleanObservation.forEach(values => {\n      this.remove(values[0]);\n    });\n  }\n\n  /**\n   * Clear all resources held by this provider. It IS valid to lose reference to all instances\n   * and to this object, which would effectively cause this object to get GC'ed. But if you\n   * desire to hang onto the instance objects, then this should be called.\n   */\n  destroy() {\n    this.cleanObservation.forEach(values => {\n      values[1]();\n    });\n\n    this.cleanObservation.clear();\n    this.instanceChanges.clear();\n  }\n\n  /**\n   * This is called from observables to indicate it's parent has been updated\n   */\n  instanceUpdated(instance: T) {\n    if (this.allowChanges) {\n      // Flag the instance as having a property changed\n      this.instanceChanges.set(instance.uid, [\n        instance,\n        InstanceDiffType.CHANGE,\n        instance.changes\n      ]);\n    }\n  }\n\n  /**\n   * Removes the instance from being advertised changes and from providing the changes\n   * for the instance.\n   */\n  remove(instance: T) {\n    if (this.allowChanges) {\n      const disposer = this.cleanObservation.get(instance.uid);\n\n      if (disposer) {\n        disposer[1]();\n        this.cleanObservation.delete(instance.uid);\n        this.instanceChanges.set(instance.uid, [\n          instance,\n          InstanceDiffType.REMOVE,\n          {}\n        ]);\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Flagged all changes as dealt with\n   */\n  resolve(context: string) {\n    this.allowChanges = true;\n    this.instanceChanges.clear();\n\n    if (this.resolveContext && this.resolveContext !== context) {\n      throw new Error(\n        \"An instance provider has been issued to two layers. This is not a suppported feature yet and will cause issues.\"\n      );\n    }\n\n    this.resolveContext = context;\n  }\n\n  /**\n   * This performs an operation that forces all of the instances to be flagged as an\n   * 'add' change. This allows a layer listening to this provider to ensure it has added\n   * all currently existing instances monitored by the provider.\n   *\n   * NOTE: This is a VERY poor performing method and should probably be used by the framework\n   * and not manually.\n   */\n  sync() {\n    const emptyPropertyChanges: number[] = [];\n\n    // Loop through all registered instances (which is only stored in the disposer list kept by this provider)\n    this.cleanObservation.forEach(disposer => {\n      const [instance] = disposer;\n      // Flag the instance as having a property changed\n      this.instanceChanges.set(instance.uid, [\n        instance,\n        InstanceDiffType.INSERT,\n        emptyPropertyChanges\n      ]);\n    });\n  }\n}\n","import * as Three from \"three\";\nimport { InstanceProvider } from \"../../instance-provider\";\nimport { ILayerProps, IModelType, Layer } from \"../../surface/layer\";\nimport {\n  IMaterialOptions,\n  InstanceAttributeSize,\n  IShaderInitialization,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../types\";\nimport { CommonMaterialOptions, IAutoEasingMethod, Vec } from \"../../util\";\nimport { ArcInstance } from \"./arc-instance\";\n\nexport enum ArcScaleType {\n  /** All dimensions are within world space */\n  NONE,\n  /**\n   * The thickness of the arc is in screen space. Thus, camera zoom changes will not affect it and\n   * must be controlled by scaleFactor alone.\n   */\n  SCREEN_CURVE\n}\n\nexport interface IArcLayerProps<T extends ArcInstance> extends ILayerProps<T> {\n  scaleType?: ArcScaleType;\n  animate?: {\n    angle?: IAutoEasingMethod<Vec>;\n    center?: IAutoEasingMethod<Vec>;\n    colorEnd?: IAutoEasingMethod<Vec>;\n    colorStart?: IAutoEasingMethod<Vec>;\n    radius?: IAutoEasingMethod<Vec>;\n    thickness?: IAutoEasingMethod<Vec>;\n  };\n}\n\n/**\n * This layer displays Arcs and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class ArcLayer<\n  T extends ArcInstance,\n  U extends IArcLayerProps<T>\n> extends Layer<T, U> {\n  static defaultProps: IArcLayerProps<ArcInstance> = {\n    data: new InstanceProvider<ArcInstance>(),\n    key: \"\",\n    scaleType: ArcScaleType.NONE,\n    scene: \"default\"\n  };\n\n  /** Easy lookup of all attribute names for the layer */\n  static attributeNames = {\n    angle: \"angle\",\n    center: \"center\",\n    colorEnd: \"colorEnd\",\n    colorStart: \"colorStart\",\n    depth: \"depth\",\n    radius: \"radius\",\n    thickness: \"thickness\"\n  };\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<ArcInstance> {\n    const { scaleType } = this.props;\n    const animations = this.props.animate || {};\n    const {\n      angle: animateAngle,\n      center: animateCenter,\n      radius: animateRadius,\n      thickness: animateThickness,\n      colorStart: animateColorStart,\n      colorEnd: animateColorEnd\n    } = animations;\n\n    const MAX_SEGMENTS = 150;\n\n    // Calculate the normals and interpolations for our vertices\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      [MAX_SEGMENTS * 2 + 2]: -1\n    };\n\n    const vertexInterpolation: { [key: number]: number } = {\n      0: 0,\n      [MAX_SEGMENTS * 2 + 2]: 1\n    };\n\n    let sign = 1;\n    for (let i = 0; i < MAX_SEGMENTS * 2; ++i) {\n      vertexToNormal[i + 1] = sign;\n      vertexInterpolation[i + 1] = Math.floor(i / 2) / (MAX_SEGMENTS - 1);\n      sign *= -1;\n    }\n\n    const vs =\n      scaleType === ArcScaleType.NONE\n        ? require(\"./arc-layer.vs\")\n        : require(\"./arc-layer-screen-space.vs\");\n\n    return {\n      fs: require(\"./arc-layer.fs\"),\n      instanceAttributes: [\n        {\n          easing: animateCenter,\n          name: ArcLayer.attributeNames.center,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.center\n        },\n        {\n          easing: animateRadius,\n          name: ArcLayer.attributeNames.radius,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.radius]\n        },\n        {\n          name: ArcLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        {\n          easing: animateThickness,\n          name: ArcLayer.attributeNames.thickness,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.thickness\n        },\n        {\n          easing: animateAngle,\n          name: ArcLayer.attributeNames.angle,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.angle\n        },\n        {\n          easing: animateColorStart,\n          name: ArcLayer.attributeNames.colorStart,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.colorStart\n        },\n        {\n          easing: animateColorEnd,\n          name: ArcLayer.attributeNames.colorEnd,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.colorEnd\n        }\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: _u => [1]\n        }\n      ],\n      vertexAttributes: [\n        // TODO: This is from the heinous evils of THREEJS and their inability to fix a bug within our lifetimes.\n        // Right now position is REQUIRED in order for rendering to occur, otherwise the draw range gets updated to\n        // Zero against your wishes.\n        {\n          name: \"position\",\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexInterpolation[vertex],\n            // The number of vertices\n            MAX_SEGMENTS * 2\n          ]\n        }\n      ],\n      vertexCount: MAX_SEGMENTS * 2 + 2,\n      vs\n    };\n  }\n\n  getModelType(): IModelType {\n    return {\n      drawMode: Three.TriangleStripDrawMode,\n      modelType: Three.Mesh\n    };\n  }\n\n  getMaterialOptions(): IMaterialOptions {\n    return Object.assign({}, CommonMaterialOptions.transparentShape, {\n      side: Three.DoubleSide\n    } as IMaterialOptions);\n  }\n}\n","export * from \"./arc-layer\";\nexport * from \"./arc-instance\";\n","export * from \"./arcs\";\nexport * from \"./circles\";\nexport * from \"./edges\";\nexport * from \"./images\";\nexport * from \"./labels\";\nexport * from \"./rectangle\";\nexport * from \"./rings\";\nexport * from \"./types\";\n","import { Instance } from \"../instance-provider/instance\";\nimport { Bounds } from \"../primitives/bounds\";\nimport { isVec2, Vec2 } from \"../util/vector\";\n\n// A configuration that controls how readily a quadtree will split to another level\n// Adjusting this number can improve or degrade your performance significantly and\n// Must be tested for specific use cases\nconst maxPopulation: number = 5;\nconst maxDepth: number = 10;\n\nexport type BoundsAccessor<T extends Instance> = (o: T) => Bounds | null;\n\n/**\n * Allows typing of a callback argument\n */\nexport interface IVisitFunction<T extends Instance> {\n  /**\n   * A callback to use during add or query\n   *\n   * Called do provide aggregation or filtering like Array.reduce or\n   * Array.filter, but in a QuadTree instead.\n   *\n   * @param node  The node to effect the function upon\n   * @param child The child to add to the node\n   */\n  (node: Node<T>, child?: Bounds): void;\n}\n\n/**\n * This is a class used specifically by the quad tree nodes to indicate split space\n * within the quad tree.\n */\nexport class Quadrants<T extends Instance> {\n  TL: Node<T>;\n  TR: Node<T>;\n  BL: Node<T>;\n  BR: Node<T>;\n\n  /**\n   * Ensures all memory is released for all nodes and all references are removed\n   * to potentially high memory consumption items\n   */\n  destroy() {\n    this.TL.destroy();\n    this.TR.destroy();\n    this.BL.destroy();\n    this.BR.destroy();\n    delete this.TL;\n    delete this.TR;\n    delete this.BL;\n    delete this.BR;\n  }\n\n  /**\n   * Creates an instance of Quadrants.\n   *\n   * @param bounds The bounds this will create quandrants for\n   * @param depth  The child depth of this element\n   */\n  constructor(\n    bounds: Bounds,\n    depth: number,\n    getBounds: BoundsAccessor<T>,\n    childToNode: Map<T, Node<T>>,\n    childToBounds: Map<T, Bounds | null>\n  ) {\n    const mid = bounds.mid;\n    this.TL = new Node<T>(bounds.x, mid[0], bounds.y, mid[1], getBounds, depth);\n    this.TR = new Node<T>(\n      mid[0],\n      bounds.right,\n      bounds.y,\n      mid[1],\n      getBounds,\n      depth\n    );\n    this.BL = new Node<T>(\n      bounds.x,\n      mid[0],\n      mid[1],\n      bounds.bottom,\n      getBounds,\n      depth\n    );\n    this.BR = new Node<T>(\n      mid[0],\n      bounds.right,\n      mid[1],\n      bounds.bottom,\n      getBounds,\n      depth\n    );\n    this.TL.childToNode = childToNode;\n    this.TR.childToNode = childToNode;\n    this.BL.childToNode = childToNode;\n    this.BR.childToNode = childToNode;\n    this.TL.childToBounds = childToBounds;\n    this.TR.childToBounds = childToBounds;\n    this.BL.childToBounds = childToBounds;\n    this.BR.childToBounds = childToBounds;\n  }\n}\n\n/**\n * The quad tree node. This Node will take in a certain population before dividing itself into\n * 4 quadrants which it will attempt to inject it's population into. If a member of the population\n * does not completely get injected into one of the quadrants it remains as a member of this node.\n */\nexport class Node<T extends Instance> {\n  /** This is the amount of space this node covers */\n  bounds: Bounds;\n  /** These are the child Instances of the node. */\n  children: T[] = [];\n  /**\n   * This tracks a quick lookup of a child to it's parent node. This is used so the child can\n   * be removed with ease and not require a traversal of the tree.\n   */\n  childToNode: Map<T, Node<T>>;\n  /** This tracks the bounds calcuated for the given instance */\n  childToBounds: Map<T, Bounds | null>;\n  /** This is how deep the node is within the tree */\n  depth: number = 0;\n  /** This is the accessor method that retrieves the bounds for an injected instance */\n  getBounds: BoundsAccessor<T>;\n  /** These are the child nodes of this quad node when this node is split. It is null if the node is not split yet */\n  nodes: Quadrants<T> | null = null;\n  /**\n   * These are children with null bounds that do not affect the splitting and ALWAYS get checked every query.\n   * They should only reside on the top node.\n   */\n  nullBounded: T[];\n\n  /**\n   * Destroys this node and ensures all child nodes are destroyed as well.\n   */\n  destroy() {\n    delete this.children;\n    delete this.bounds;\n\n    if (this.nodes) {\n      this.nodes.destroy();\n      this.nodes = null;\n    }\n  }\n\n  /**\n   * Creates an instance of Node.\n   */\n  constructor(\n    left: number,\n    right: number,\n    top: number,\n    bottom: number,\n    getBounds: BoundsAccessor<T>,\n    depth: number = 0\n  ) {\n    // If params insertted\n    if (arguments.length >= 4) {\n      this.bounds = new Bounds({ left, right, top, bottom });\n    } else {\n      // Otherwise, make tiny start area\n      this.bounds = new Bounds({ left: 0, right: 1, top: 1, bottom: 0 });\n    }\n\n    // Ensure the depth is set\n    this.depth = depth;\n    // Apply the bounds accessor method for instances\n    this.getBounds = getBounds;\n\n    // If this is the top level node, we need to instantiate the lookup that will be used\n    // Across all nodes.\n    if (this.depth === 0) {\n      this.nullBounded = [];\n      this.childToNode = new Map<T, Node<T>>();\n      this.childToBounds = new Map<T, Bounds>();\n    }\n  }\n\n  /**\n   * Adds an object that extends Bounds (or is Bounds) and properly injects it into this node\n   * or into a sub quadrant if this node is split already. If the child is outside the boundaries\n   * this quad tree spans (and this is the root node), the quad tree will expand to include\n   * the new child.\n   *\n   * @param child The Bounds type object to inject\n   * @param props Properties that can be retrieved with the child object if applicable\n   *\n   * @returns True if the insertion was successful\n   */\n  add(child: T): boolean {\n    let bounds = this.childToBounds.get(child);\n\n    if (!bounds) {\n      // First we access the bounds of the child and store it\n      bounds = this.getBounds(child);\n      this.childToBounds.set(child, bounds);\n    }\n\n    // This is the entry function for adding children, so we must first expand our top node\n    // To cover the area that the child is located.\n    // If we're in bounds, then let's just add the child\n    if (!bounds || bounds.isInside(this.bounds)) {\n      return this.doAdd(child, bounds);\n    } else {\n      // Otherwise, we need to expand first\n      this.cover(bounds);\n      return this.add(child);\n    }\n  }\n\n  /**\n   * Adds a list of new children to this quad tree. It performs the same operations as\n   * addChild for each child in the list, however, it more efficiently recalculates the\n   * bounds necessary to cover the area the children cover.\n   *\n   * @param children      List of Bounds objects to inject\n   */\n  addAll(children: T[]) {\n    // Make sure we cover the entire area of all the children.\n    // We can speed this up a lot if we first calculate the total bounds the new children covers\n    let minX = Number.MAX_VALUE;\n    let minY = Number.MAX_VALUE;\n    let maxX = -Number.MAX_VALUE;\n    let maxY = -Number.MAX_VALUE;\n\n    // Get the dimensions of the new bounds\n    children.forEach(child => {\n      const bounds = this.getBounds(child);\n      this.childToBounds.set(child, bounds);\n      if (!bounds) return;\n\n      if (bounds.x < minX) {\n        minX = bounds.x;\n      }\n      if (bounds.right > maxX) {\n        maxX = bounds.right;\n      }\n      if (bounds.bottom > maxY) {\n        maxY = bounds.bottom;\n      }\n      if (bounds.y < minY) {\n        minY = bounds.y;\n      }\n    });\n\n    // Ensure a valid cover dimension was established. If no valid dimension is established\n    // Then we don't cover, but we can still add the children as that have null Bounds which\n    // Means injecting at the top level.\n    if (\n      minX !== Number.MAX_VALUE &&\n      minY !== Number.MAX_VALUE &&\n      maxX !== -Number.MAX_VALUE &&\n      maxY !== -Number.MAX_VALUE\n    ) {\n      // Make sure our bounds includes the specified bounds\n      this.cover(\n        new Bounds({ left: minX, right: maxX, bottom: maxY, top: minY })\n      );\n    }\n\n    // Add all of the children into the tree.\n    children.forEach(child =>\n      this.doAdd(child, this.childToBounds.get(child) || null, true)\n    );\n  }\n\n  /**\n   * Ensures this quad tree includes the bounds specified in it's spatial coverage.\n   * This will cause all children to be re-injected into the tree.\n   *\n   * @param bounds The bounds to include in the tree's coverage\n   */\n  cover(bounds: Bounds) {\n    // If we are already covering the area: abort\n    if (bounds.isInside(this.bounds)) {\n      return;\n    }\n\n    // Make our bounds cover the new area\n    this.bounds.encapsulate(bounds);\n    this.bounds.x -= 1;\n    this.bounds.y -= 1;\n    this.bounds.width += 2;\n    this.bounds.height += 2;\n    // Get all of the children underneath this node\n    const allChildren = this.gatherChildren([]);\n    this.children = [];\n\n    // Destroy the split nodes\n    if (this.nodes) {\n      // Completely...destroy...\n      this.nodes.destroy();\n      this.nodes = null;\n    }\n\n    // Clear out the child to node relations\n    this.childToNode.clear();\n    // Reinsert all children with the new dimensions in place\n    allChildren.forEach(child =>\n      this.doAdd(child, this.childToBounds.get(child) || null)\n    );\n  }\n\n  /**\n   * When adding children, this performs the actual action of injecting the child into the tree\n   * without the process of seeing if the tree needs a spatial adjustment to account for the child.\n   *\n   * @param child The Bounds item to inject into the tree\n   * @param props The props to remain associated with the child\n   *\n   * @returns True if the injection was successful\n   */\n  private doAdd(child: T, bounds: Bounds | null, fromSplit?: boolean): boolean {\n    // If this is the top level node and the bounds are null, then we add to the null list\n    if (!bounds && this.depth === 0) {\n      this.nullBounded.push(child);\n      this.childToNode.set(child, this);\n\n      return true;\n    }\n\n    // If no bounds is available at this point, something went terribly wrong\n    if (!bounds) {\n      console.warn(\n        \"A null bounds was added to a Quad Tree node below the top node, which is invalid.\"\n      );\n      return false;\n    }\n\n    // If bounds are null, then just immediately add\n    // If nodes are present, then we have already exceeded the population of this node\n    if (this.nodes) {\n      if (bounds.isInside(this.nodes.TL.bounds)) {\n        return this.nodes.TL.doAdd(child, bounds, fromSplit);\n      }\n\n      if (bounds.isInside(this.nodes.TR.bounds)) {\n        return this.nodes.TR.doAdd(child, bounds, fromSplit);\n      }\n\n      if (bounds.isInside(this.nodes.BL.bounds)) {\n        return this.nodes.BL.doAdd(child, bounds, fromSplit);\n      }\n\n      if (bounds.isInside(this.nodes.BR.bounds)) {\n        return this.nodes.BR.doAdd(child, bounds, fromSplit);\n      }\n\n      // Otherwise, this is a child overlapping this border\n      this.children.push(child);\n      this.childToNode.set(child, this);\n\n      return true;\n    } else if (bounds.isInside(this.bounds)) {\n      // Otherwise, we have not had a split due to population limits being exceeded\n      this.children.push(child);\n      this.childToNode.set(child, this);\n\n      // If we exceeded our population for this quadrant, it is time to split up\n      if (this.children.length > maxPopulation && this.depth < maxDepth) {\n        this.split();\n      }\n\n      return true;\n    }\n\n    // This is when there is something wrong with the insertted child. The bounds\n    // For the quad should have grown without issue, but in this case the bounds\n    // Could not grow to accomodate the child.\n    if (isNaN(bounds.width + bounds.height + bounds.x + bounds.y)) {\n      console.error(\n        \"Child did not fit into bounds because a dimension is NaN\",\n        child,\n        bounds\n      );\n    } else if (bounds.area === 0) {\n      console.error(\n        \"Child did not fit into bounds because the area is zero\",\n        child,\n        bounds\n      );\n    } else {\n      console.error(\n        \"Child did not get insertted.\",\n        \"Parent:\",\n        this.bounds.toString(),\n        \"Child:\",\n        bounds.toString(),\n        \"Inside Checks:\",\n        bounds.x >= this.bounds.x,\n        bounds.right <= this.bounds.right,\n        bounds.y >= this.bounds.y,\n        bounds.bottom <= this.bounds.bottom\n      );\n    }\n\n    // Don't insert the child and continue\n    return true;\n  }\n\n  private doRemove(child: T) {\n    const index = this.children.indexOf(child);\n\n    if (index > -1) {\n      this.children.splice(index, 1);\n      this.childToNode.delete(child);\n      this.childToBounds.delete(child);\n    }\n  }\n\n  /**\n   * Collects all children of all the current and sub nodes into a single list.\n   *\n   * @param list The list we must aggregate children into\n   *\n   * @return The list specified as the list parameter\n   */\n  gatherChildren(list: T[]): T[] {\n    this.children.forEach(child => list.push(child));\n\n    if (this.nodes) {\n      this.nodes.TL.gatherChildren(list);\n      this.nodes.TR.gatherChildren(list);\n      this.nodes.BL.gatherChildren(list);\n      this.nodes.BR.gatherChildren(list);\n    }\n\n    return list;\n  }\n\n  /**\n   * Entry query for determining query type based on input object\n   *\n   * @param bounds Can be a Bounds or a Point object\n   * @param visit  A callback function that will receive the Node as it is analyzed. This gives\n   *               information on a spatial scale, how a query reaches it's target intersections.\n   *\n   * @return An array of children that intersects with the query\n   */\n  query(bounds: Bounds | Vec2, visit?: IVisitFunction<T>): T[] {\n    // This stores all of the found Instances when querying by bounds or point\n    let found: T[] = [];\n\n    // If this is the top level node then add in the null bunded items as the start\n    if (this.depth === 0) {\n      found = this.nullBounded.slice(0);\n    }\n\n    // Query a rectangle\n    if (bounds instanceof Bounds) {\n      if (bounds.hitBounds(this.bounds)) {\n        return this.queryBounds(bounds, found, visit);\n      }\n    }\n\n    if (isVec2(bounds)) {\n      // Query a point\n      if (this.bounds.containsPoint(bounds)) {\n        return this.queryPoint(bounds, found, visit);\n      }\n    }\n\n    // Return an empty array when nothing is collided with\n    return found;\n  }\n\n  /**\n   * Queries children for intersection with a bounds object\n   *\n   * @param b     The Bounds to test children against\n   * @param list  The list of children to aggregate into the query\n   * @param visit A callback function that will receive the Node as it is analyzed. This gives\n   *              information on a spatial scale, how a query reaches it's target intersections.\n   *\n   * @return     Returns the exact same list that was input as the list param\n   */\n  queryBounds(b: Bounds, list: T[], visit?: IVisitFunction<T>): T[] {\n    this.children.forEach(c => {\n      const bounds = this.childToBounds.get(c);\n\n      if (bounds && bounds.hitBounds(b)) {\n        list.push(c);\n      }\n    });\n\n    if (visit) {\n      visit(this);\n    }\n\n    if (this.nodes) {\n      if (b.hitBounds(this.nodes.TL.bounds)) {\n        this.nodes.TL.queryBounds(b, list, visit);\n      }\n\n      if (b.hitBounds(this.nodes.TR.bounds)) {\n        this.nodes.TR.queryBounds(b, list, visit);\n      }\n\n      if (b.hitBounds(this.nodes.BL.bounds)) {\n        this.nodes.BL.queryBounds(b, list, visit);\n      }\n\n      if (b.hitBounds(this.nodes.BR.bounds)) {\n        this.nodes.BR.queryBounds(b, list, visit);\n      }\n    }\n\n    return list;\n  }\n\n  /**\n   * Queries children for intersection with a point\n   *\n   * @param p     The Point to test children against\n   * @param list  The list of children to aggregate into the query\n   * @param visit A callback function that will receive the Node as it is analyzed. This gives\n   *              information on a spatial scale, how a query reaches it's target intersections.\n   *\n   * @return      Returns the exact same list that was input as the list param\n   */\n  queryPoint(p: any, list: T[], visit?: IVisitFunction<T>): T[] {\n    this.children.forEach(c => {\n      const bounds = this.childToBounds.get(c);\n\n      if (bounds && bounds.containsPoint(p)) {\n        list.push(c);\n      }\n    });\n\n    if (visit) {\n      visit(this);\n    }\n\n    if (this.nodes) {\n      if (this.nodes.TL.bounds.containsPoint(p)) {\n        this.nodes.TL.queryPoint(p, list, visit);\n      }\n\n      if (this.nodes.TR.bounds.containsPoint(p)) {\n        this.nodes.TR.queryPoint(p, list, visit);\n      }\n\n      if (this.nodes.BL.bounds.containsPoint(p)) {\n        this.nodes.BL.queryPoint(p, list, visit);\n      }\n\n      if (this.nodes.BR.bounds.containsPoint(p)) {\n        this.nodes.BR.queryPoint(p, list, visit);\n      }\n    }\n\n    return list;\n  }\n\n  /**\n   * Remove the provided item from the tree.\n   */\n  remove(child: T) {\n    if (this.childToNode) {\n      const node = this.childToNode.get(child);\n\n      // If the node is getting removed from the top level node, then it MAY be a null bounded item\n      // Which gets removed from the list\n      if (node && node.depth === 0) {\n        const index = node.nullBounded.indexOf(child);\n\n        if (index > -1) {\n          node.nullBounded.splice(index);\n          this.childToNode.delete(child);\n          this.childToBounds.delete(child);\n\n          return;\n        }\n      }\n\n      // Otherwise, just remove the node normally\n      if (node) {\n        node.doRemove(child);\n      }\n    }\n  }\n\n  /**\n   * Creates four sub quadrants for this node.\n   */\n  split() {\n    // Gather all items to be handed down\n    const allChildren = this.gatherChildren([]);\n    // Gather all props for the children to be handed down as well\n    this.nodes = new Quadrants<T>(\n      this.bounds,\n      this.depth + 1,\n      this.getBounds,\n      this.childToNode,\n      this.childToBounds\n    );\n    // Empty out the children as they are being re-injected\n    this.children = [];\n\n    for (let i = 0, end = allChildren.length; i < end; ++i) {\n      const child = allChildren[i];\n      this.doAdd(child, this.childToBounds.get(child) || null, true);\n    }\n  }\n\n  /**\n   * Traverses the quad tree returning every quadrant encountered\n   *\n   * @param cb A callback that has the parameter (node) which is a quadrant in the tree\n   */\n  visit(cb: IVisitFunction<T>): void {\n    const finished = Boolean(cb(this));\n\n    if (this.nodes && !finished) {\n      this.nodes.TL.visit(cb);\n      this.nodes.TR.visit(cb);\n      this.nodes.BL.visit(cb);\n      this.nodes.BR.visit(cb);\n    }\n  }\n}\n\nexport class TrackedQuadTree<T extends Instance> extends Node<T> {}\n","import { ChartCamera } from \"./chart-camera\";\n\nexport interface IReferenceCameraOptions {\n  /** This is the base camera to monitor */\n  base: ChartCamera;\n  /**\n   * This is a filter applied to the offset that comes from the chart camera.\n   */\n  offsetFilter?(offset: [number, number, number]): [number, number, number];\n  /**\n   * This is a filter applied to the scale that comes from the chart camera.\n   */\n  scaleFilter?(scale: [number, number, number]): [number, number, number];\n}\n\n/**\n * This is a camera that is based on another camera. This can apply filters\n * to the information provided from the base camera.\n *\n * Useful for situations such as a chart having a chart area and a list on the\n * left. This can use the same camera the chart area uses, but filter the response\n * to only track the y offset of the base camera.\n *\n * That would allow easy tracking of the left list to track with elements in the\n * chart and only manipulate a single camera instead of managing many cameras and\n * tie them together with lots of events.\n */\nexport class ReferenceCamera extends ChartCamera {\n  private base: ChartCamera;\n  private offsetFilter = (offset: [number, number, number]) => offset;\n  private scaleFilter = (scale: [number, number, number]) => scale;\n\n  set offset(_val: any) {\n    /** no-op */\n  }\n\n  get offset() {\n    return this.offsetFilter(this.base.offset);\n  }\n\n  set scale(_val: any) {\n    /** no-op */\n  }\n\n  get scale() {\n    return this.scaleFilter(this.base.scale);\n  }\n\n  constructor(options: IReferenceCameraOptions) {\n    super();\n    Object.assign(this, options);\n  }\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","module.exports = __WEBPACK_EXTERNAL_MODULE__157__;","import { Instance } from \"../instance-provider/instance\";\nimport { extendShader } from \"../shaders/util/extend-shader\";\nimport { IShaderInitialization, IShaderIOExtension } from \"../types\";\n\nexport function extendShaderInitialization<T extends Instance>(\n  shaderIO: IShaderInitialization<T>,\n  extend: IShaderIOExtension<T>\n): IShaderInitialization<T> {\n  const extendedShaders = extendShader(shaderIO, extend.vs, extend.fs);\n\n  return {\n    fs: extendedShaders.fs,\n    instanceAttributes: (shaderIO.instanceAttributes || []).concat(\n      extend.instanceAttributes || []\n    ),\n    uniforms: (shaderIO.uniforms || []).concat(extend.uniforms || []),\n    vertexAttributes: (shaderIO.vertexAttributes || []).concat(\n      extend.vertexAttributes || []\n    ),\n    vertexCount: shaderIO.vertexCount,\n    vs: extendedShaders.vs\n  };\n}\n","import { LayerSurface } from \"../surface\";\nimport { IAutoEasingMethod } from \"./auto-easing-method\";\nimport { Vec } from \"./vector\";\n\nexport type AnimationDelayAccessor = (\n  groupIndex: number,\n  currentDelay: number\n) => number;\nexport type AnimationInstanceModificationCallback = (\n  groupIndex: number\n) => void;\n\nfunction isNumber(val: any): val is number {\n  return !isNaN(val);\n}\n\n/**\n * This provides some methods that aids in more complicated animation tasks, such as\n * adjusting gpu animated properties with differing time delay values for each change.\n */\nexport class AnimationHelper {\n  surface: LayerSurface;\n\n  constructor(surface: LayerSurface) {\n    this.surface = surface;\n  }\n\n  /**\n   * When you want to animate properties of instances but you want them to start at differing times,\n   * use this method to ensure the timings starting between the elements is correct.\n   *\n   * @param easingMethod This is the easing method used for the layer's property to animate\n   * @param groupCount This is the number of animations desired for a given delay level\n   * @param delayGap This is the amount of delay between each group. This can be a static value or\n   *                 can be a dynamic callback\n   */\n  groupAnimation(\n    easingMethod: IAutoEasingMethod<Vec>,\n    groupCount: number,\n    baseDelay: number,\n    delayGap: number | AnimationDelayAccessor,\n    modifyInstances: AnimationInstanceModificationCallback\n  ) {\n    // Get the time of the current frame as our timing basis\n    const startFrameTime = this.surface.frameMetrics.currentTime;\n    // Do an initial commit to ensure all previous animated properties are committed based on the\n    // Delay specified for them\n    this.surface.commit(startFrameTime);\n\n    // Loop through the the number of grouped animations to work with\n    for (let i = 0; i < groupCount; ++i) {\n      // Determine how much extra delay is applied for the provided group\n      const gap = isNumber(delayGap)\n        ? delayGap\n        : delayGap(i, easingMethod.delay);\n      // Apply the delay\n      easingMethod.delay = baseDelay + gap * i;\n      // Make the instance modifications\n      modifyInstances(i);\n      // Commit the instance modifications based on the current delay settings\n      this.surface.commit(startFrameTime);\n    }\n  }\n}\n","import { Bounds } from \"../primitives/bounds\";\nimport { EventManager } from \"../surface/event-manager\";\nimport {\n  IDragMetrics,\n  IMouseInteraction,\n  IWheelMetrics\n} from \"../surface/mouse-event-manager\";\nimport { View } from \"../surface/view\";\nimport {\n  add3,\n  divide2,\n  max3,\n  min3,\n  subtract2,\n  subtract3,\n  Vec3,\n  vec3\n} from \"../util\";\nimport { ChartCamera } from \"../util/chart-camera\";\nexport enum CameraBoundsAnchor {\n  TOP_LEFT,\n  TOP_MIDDLE,\n  TOP_RIGHT,\n  MIDDLE_LEFT,\n  MIDDLE,\n  MIDDLE_RIGHT,\n  BOTTOM_LEFT,\n  BOTTOM_MIDDLE,\n  BOTTOM_RIGHT\n}\n\n/**\n * This represents how the camera should be bounded in the world space. This gives enough information\n * to handle all cases of bounding, including screen padding and anchoring for cases where the viewed space\n * is smaller than the view.\n */\nexport interface ICameraBoundsOptions {\n  /** How the bounded world space should anchor itself within the view when the projected world space to the screen is smaller than the view */\n  anchor: CameraBoundsAnchor;\n  /** Minimum settings the camera can scale to */\n  scaleMin?: Vec3;\n  /** Maximum settings the camera can scale to */\n  scaleMax?: Vec3;\n  /** The actual screen pixels the bounds can exceed when the camera's view has reached the bounds of the world */\n  screenPadding: { left: number; right: number; top: number; bottom: number };\n  /** This is the view for which the bounds applies towards */\n  view: string;\n  /** The area the camera is bound inside */\n  worldBounds: Bounds;\n}\n\nexport interface IBasicCameraControllerOptions {\n  /** Takes in the options to be used for creating a new ViewBounds object on this controller. */\n  bounds?: ICameraBoundsOptions;\n  /** This is the camera this controller will manipulate */\n  camera: ChartCamera;\n  /** When this is set to true, the start view can be targetted even when behind other views */\n  ignoreCoverViews?: boolean;\n  /**\n   * This provides a control to filter panning that will be applied to the camera. The input and\n   * output of this will be the delta value to be applied.\n   */\n  panFilter?(\n    offset: [number, number, number],\n    view: View,\n    allViews: View[]\n  ): [number, number, number];\n  /**\n   * This adjusts how fast scaling is applied from the mouse wheel\n   */\n  scaleFactor?: number;\n  /**\n   * This provides a control to filter scaling that will be applied to the camera. The input and\n   * output of this will be the delta value to be applied.\n   */\n  scaleFilter?(\n    scale: [number, number, number],\n    view: View,\n    allViews: View[]\n  ): [number, number, number];\n  /**\n   * This is the view that MUST be the start view from the events.\n   * If not provided, then dragging anywhere will adjust the camera\n   */\n  startView?: string | string[];\n\n  /**\n   * This is a handler for when the camera has applied changes to the visible range of what is seen.\n   * Which most likely means offset or scale has been altered.\n   */\n  onRangeChanged?(camera: ChartCamera, targetView: View): void;\n  /**\n   * This specifies whether a view can be scrolled by wheel\n   * If this is not specified or set false, the view can be zoomed by wheel\n   */\n  wheelShouldScroll?: boolean;\n}\n\n/**\n * This provides some very basic common needs for a camera control system. This is not a total solution\n * very every scenario. This should just often handle most basic needs.\n */\nexport class BasicCameraController extends EventManager {\n  /**\n   * If total bounds of worldbounds + screenpadding is smaller\n   * than width or height of view, anchor dictates placement.\n   */\n  bounds?: ICameraBoundsOptions;\n  /** This is the camera that this controller will manipulate */\n  camera: ChartCamera;\n  /** When this is set to true, the start view can be targetted even when behind other views */\n  ignoreCoverViews?: boolean;\n  /** Informative property indicating the controller is panning the chart or not */\n  isPanning: boolean = false;\n  /** This is the filter applied to panning operations */\n  private panFilter = (\n    offset: [number, number, number],\n    _view: View,\n    _allViews: View[]\n  ) => offset;\n  /** The rate scale is adjusted with the mouse wheel */\n  scaleFactor: number;\n  /** THis is the filter applied to tscaling operations */\n  private scaleFilter = (\n    scale: [number, number, number],\n    _view: View,\n    _allViews: View[]\n  ) => scale;\n  /** The view that must be the start or focus of the interactions in order for the interactions to occur */\n  startViews: string[] = [];\n  /** Whether a view can be scrolled by wheel */\n  wheelShouldScroll: boolean;\n\n  /**\n   * If an unconvered start view is not available, this is the next available covered view, if present\n   */\n  private coveredStartView: View;\n  /**\n   * Callback for when the range has changed for the camera in a view\n   */\n  private onRangeChanged = (_camera: ChartCamera, _targetView: View) => {\n    /* no-op */\n  };\n\n  /**\n   * This flag is set to true when a start view is targetted on mouse down even if it is not\n   * the top most view.\n   */\n  private startViewDidStart: boolean = false;\n\n  constructor(options: IBasicCameraControllerOptions) {\n    super();\n    if (options.bounds) {\n      this.setBounds(options.bounds);\n    }\n    this.camera = options.camera;\n    this.scaleFactor = options.scaleFactor || 1000.0;\n    this.ignoreCoverViews = options.ignoreCoverViews || false;\n\n    if (options.startView) {\n      this.startViews = Array.isArray(options.startView)\n        ? options.startView\n        : [options.startView];\n    }\n\n    this.panFilter = options.panFilter || this.panFilter;\n    this.scaleFilter = options.scaleFilter || this.scaleFilter;\n    this.onRangeChanged = options.onRangeChanged || this.onRangeChanged;\n\n    if (options.wheelShouldScroll) {\n      this.wheelShouldScroll = options.wheelShouldScroll;\n    }\n  }\n\n  /**\n   * Corrects camera offset to respect current bounds and anchor.\n   */\n  applyBounds = () => {\n    if (this.bounds && this.camera) {\n      const targetView = this.getView(this.bounds.view);\n      this.applyScaleBounds();\n\n      // Next bound the positioning\n      if (targetView) {\n        this.camera.offset[0] = this.boundsHorizontalOffset(\n          targetView,\n          this.bounds\n        );\n\n        this.camera.offset[1] = this.boundsVerticalOffset(\n          targetView,\n          this.bounds\n        );\n      }\n    }\n  };\n\n  applyScaleBounds = () => {\n    if (this.camera && this.bounds) {\n      // First bound the scaling\n      if (this.bounds.scaleMin) {\n        this.camera.setScale(max3(this.camera.scale, this.bounds.scaleMin));\n      }\n\n      if (this.bounds.scaleMax) {\n        this.camera.setScale(min3(this.camera.scale, this.bounds.scaleMax));\n      }\n    }\n  };\n\n  /**\n   * Calculation for adhering to an anchor - x-axis offset only.\n   */\n  anchoredByBoundsHorizontal(targetView: View, bounds: ICameraBoundsOptions) {\n    switch (bounds.anchor) {\n      case CameraBoundsAnchor.TOP_LEFT:\n      case CameraBoundsAnchor.MIDDLE_LEFT:\n      case CameraBoundsAnchor.BOTTOM_LEFT:\n        return -(\n          bounds.worldBounds.left -\n          bounds.screenPadding.left / this.camera.scale[0]\n        );\n\n      case CameraBoundsAnchor.TOP_MIDDLE:\n      case CameraBoundsAnchor.MIDDLE:\n      case CameraBoundsAnchor.BOTTOM_MIDDLE:\n        return -(\n          bounds.worldBounds.right -\n          bounds.worldBounds.width / 2 -\n          0.5 *\n            ((targetView.screenBounds.width + bounds.screenPadding.right) /\n              this.camera.scale[0])\n        );\n\n      case CameraBoundsAnchor.TOP_RIGHT:\n      case CameraBoundsAnchor.MIDDLE_RIGHT:\n      case CameraBoundsAnchor.BOTTOM_RIGHT:\n        return -(\n          bounds.worldBounds.right -\n          (targetView.screenBounds.width - bounds.screenPadding.right) /\n            this.camera.scale[0]\n        );\n    }\n  }\n\n  /**\n   * Calculation for adhering to an anchor - y-axis offset only.\n   */\n  anchoredByBoundsVertical(targetView: View, bounds: ICameraBoundsOptions) {\n    switch (bounds.anchor) {\n      case CameraBoundsAnchor.TOP_LEFT:\n      case CameraBoundsAnchor.TOP_MIDDLE:\n      case CameraBoundsAnchor.TOP_RIGHT:\n        return (\n          -bounds.worldBounds.top - -bounds.screenPadding.top / this.scale[1]\n        );\n\n      case CameraBoundsAnchor.MIDDLE_LEFT:\n      case CameraBoundsAnchor.MIDDLE:\n      case CameraBoundsAnchor.MIDDLE_RIGHT:\n        return (\n          -(bounds.worldBounds.bottom - bounds.worldBounds.height / 2) +\n          0.5 *\n            (targetView.screenBounds.height - bounds.screenPadding.bottom) /\n            this.scale[1]\n        );\n\n      case CameraBoundsAnchor.BOTTOM_LEFT:\n      case CameraBoundsAnchor.BOTTOM_MIDDLE:\n      case CameraBoundsAnchor.BOTTOM_RIGHT:\n        return -(\n          bounds.worldBounds.bottom -\n          (targetView.screenBounds.height - bounds.screenPadding.bottom) /\n            this.scale[1]\n        );\n    }\n  }\n\n  /**\n   * Returns offset on x-axis due to current bounds and anchor.\n   */\n  boundsHorizontalOffset(targetView: View, bounds: ICameraBoundsOptions) {\n    const worldTLinScreenSpace = targetView.worldToScreen([\n      bounds.worldBounds.left,\n      bounds.worldBounds.top\n    ]);\n    const worldBRinScreenSpace = targetView.worldToScreen([\n      bounds.worldBounds.right,\n      bounds.worldBounds.bottom\n    ]);\n\n    const widthDifference =\n      worldBRinScreenSpace[0] -\n      worldTLinScreenSpace[0] +\n      bounds.screenPadding.left +\n      bounds.screenPadding.right -\n      targetView.screenBounds.width;\n\n    // If the worldBounds are smaller than the screenBounds,\n    // We offset according to the anchoring\n    if (widthDifference < 0) {\n      return this.anchoredByBoundsHorizontal(targetView, bounds);\n    }\n\n    if (\n      worldBRinScreenSpace[0] <\n      targetView.screenBounds.right - bounds.screenPadding.right\n    ) {\n      return (\n        -bounds.worldBounds.right +\n        (targetView.screenBounds.width - bounds.screenPadding.right) /\n          this.camera.scale[0]\n      );\n    }\n\n    if (\n      worldTLinScreenSpace[0] >\n      targetView.screenBounds.left + bounds.screenPadding.left\n    ) {\n      return (\n        -bounds.worldBounds.left +\n        bounds.screenPadding.left / this.camera.scale[0]\n      );\n    }\n\n    return this.camera.offset[0];\n  }\n\n  /**\n   * Returns offset on y-axis due to current bounds and anchor.\n   */\n  boundsVerticalOffset(targetView: View, bounds: ICameraBoundsOptions) {\n    const worldTLinScreenSpace = targetView.worldToScreen([\n      bounds.worldBounds.left,\n      bounds.worldBounds.top\n    ]);\n    const worldBRinScreenSpace = targetView.worldToScreen([\n      bounds.worldBounds.right,\n      bounds.worldBounds.bottom\n    ]);\n\n    const heightDifference =\n      worldBRinScreenSpace[1] -\n      worldTLinScreenSpace[1] +\n      bounds.screenPadding.top +\n      bounds.screenPadding.bottom -\n      targetView.screenBounds.height;\n\n    // If the viewBounds are larger than the screenBounds,\n    // We offset according to the anchoring\n    if (heightDifference < 0) {\n      return this.anchoredByBoundsVertical(targetView, bounds);\n    }\n\n    if (\n      worldTLinScreenSpace[1] >\n      targetView.screenBounds.top - bounds.screenPadding.top\n    ) {\n      return -(\n        bounds.worldBounds.top -\n        bounds.screenPadding.top / this.camera.scale[1]\n      );\n    }\n\n    if (\n      worldBRinScreenSpace[1] <\n      targetView.screenBounds.bottom + bounds.screenPadding.bottom\n    ) {\n      return -(\n        bounds.worldBounds.bottom +\n        (-targetView.screenBounds.height + bounds.screenPadding.bottom) /\n          this.camera.scale[1]\n      );\n    }\n\n    return this.camera.offset[1];\n  }\n\n  private canStart(viewId: string) {\n    return (\n      this.startViews.length === 0 ||\n      (this.startViews && this.startViews.indexOf(viewId) > -1) ||\n      (this.startViewDidStart && this.ignoreCoverViews)\n    );\n  }\n\n  private findCoveredStartView(e: IMouseInteraction) {\n    const found = e.viewsUnderMouse.find(\n      under => this.startViews.indexOf(under.view.id) > -1\n    );\n    this.startViewDidStart = Boolean(found);\n\n    if (found) {\n      this.coveredStartView = found.view;\n    }\n  }\n\n  private getTargetView(e: IMouseInteraction) {\n    // If we have a start view and we do not ignore covering views,\n    // Then our target view is the view we started with\n    if (this.startViews && !this.ignoreCoverViews) {\n      return e.target.view;\n    } else {\n      // Otherwise, we use the covered start view\n      return this.coveredStartView;\n    }\n  }\n\n  /**\n   * Used to aid in handling the pan effect and determine the contextual view targetted.\n   */\n  handleMouseDown(e: IMouseInteraction, _button: number) {\n    if (this.startViews) {\n      // We look for valid covered views on mouse down so dragging will work\n      this.findCoveredStartView(e);\n      // If this is a valid start view, then we enter a panning state with the mouse down\n      if (e.start) {\n        this.isPanning = this.canStart(e.start.view.id) || this.isPanning;\n      }\n    }\n  }\n\n  /**\n   * Used to aid in handling the pan effect\n   */\n  handleMouseUp(_e: IMouseInteraction) {\n    this.startViewDidStart = false;\n    this.isPanning = false;\n  }\n\n  private doPan(\n    e: IMouseInteraction,\n    view: View,\n    delta: [number, number],\n    drag: boolean\n  ) {\n    let pan: Vec3 = vec3(divide2(delta, this.camera.scale), 0);\n\n    if (this.panFilter) {\n      pan = this.panFilter(pan, view, e.viewsUnderMouse.map(v => v.view));\n    }\n\n    if (drag) this.camera.offset[0] += pan[0];\n    this.camera.offset[1] += pan[1];\n\n    // Add additional correction for bounds\n    this.applyBounds();\n    // Broadcast the change occurred\n    if (e.start) this.onRangeChanged(this.camera, e.start.view);\n    // Add additional correction for bounds\n    this.applyBounds();\n    // Indicate the camera needs a refresh\n    this.camera.update();\n  }\n\n  /**\n   * Applies a panning effect by adjusting the camera's offset.\n   */\n  handleDrag(e: IMouseInteraction, drag: IDragMetrics) {\n    if (e.start) {\n      if (this.canStart(e.start.view.id)) {\n        this.doPan(e, e.start.view, drag.screen.delta, true);\n      }\n    }\n  }\n\n  /**\n   * Applies a scaling effect to the camera for mouse wheel events\n   */\n  handleWheel(e: IMouseInteraction, wheelMetrics: IWheelMetrics) {\n    // Every mouse wheel event must look to see if it's over a valid covered start view\n    this.findCoveredStartView(e);\n\n    if (this.canStart(e.target.view.id)) {\n      if (this.wheelShouldScroll) {\n        const targetView = this.getTargetView(e);\n        const panFactor = 100;\n\n        const currentZoomX = this.camera.scale[0] || 1.0;\n        const currentZoomY = this.camera.scale[1] || 1.0;\n\n        const deltaScale: [number, number] = [\n          wheelMetrics.wheel[1] * panFactor / this.scaleFactor * currentZoomX,\n          wheelMetrics.wheel[1] * panFactor / this.scaleFactor * currentZoomY\n        ];\n\n        this.doPan(e, targetView, deltaScale, false);\n      } else {\n        const targetView = this.getTargetView(e);\n        const beforeZoom = targetView.screenToWorld(e.screen.mouse);\n        const currentZoomX = this.camera.scale[0] || 1.0;\n        const currentZoomY = this.camera.scale[1] || 1.0;\n\n        let deltaScale: [number, number, number] = [\n          wheelMetrics.wheel[1] / this.scaleFactor * currentZoomX,\n          wheelMetrics.wheel[1] / this.scaleFactor * currentZoomY,\n          1\n        ];\n\n        if (this.scaleFilter) {\n          deltaScale = this.scaleFilter(\n            deltaScale,\n            targetView,\n            e.viewsUnderMouse.map(v => v.view)\n          );\n        }\n\n        this.camera.scale[0] = currentZoomX + deltaScale[0];\n        this.camera.scale[1] = currentZoomY + deltaScale[1];\n\n        // Ensure the new scale values are within bounds before attempting to correct offsets\n        this.applyScaleBounds();\n\n        const afterZoom = targetView.screenToWorld(e.screen.mouse);\n        const deltaZoom = subtract2(beforeZoom, afterZoom);\n        this.camera.offset[0] -= deltaZoom[0];\n        this.camera.offset[1] -= deltaZoom[1];\n\n        // Add additional correction for bounds\n        this.applyBounds();\n        // Broadcast the change occurred\n        this.onRangeChanged(this.camera, targetView);\n        // Add additional correction for bounds\n        this.applyBounds();\n\n        // Make sure the camera updates\n        this.camera.update();\n      }\n    }\n  }\n\n  // These are the currently Unused responses for this controller\n  handleMouseOut(_e: IMouseInteraction) {\n    /*no-op*/\n  }\n  handleClick(_e: IMouseInteraction) {\n    /*no-op*/\n  }\n  handleMouseMove(_e: IMouseInteraction) {\n    /*no-op*/\n  }\n  handleMouseOver(_e: IMouseInteraction) {\n    /*no-op*/\n  }\n\n  /**\n   * Evaluates the world bounds the specified view is observing\n   *\n   * @param viewId The id of the view when the view was generated when the surface was made\n   */\n  getRange(viewId: string): Bounds {\n    /** Get the projections for the provided view */\n    const projection = this.getProjection(viewId);\n    /** Get the bounds on the screen for the indicated view */\n    const screenBounds = this.getViewScreenBounds(viewId);\n\n    // Make sure we have a valid projection and screen bounds to make the adjustment\n    if (projection && screenBounds) {\n      /** Get the current viewed world bounds of the view */\n      const topLeft = projection.screenToWorld([\n        screenBounds.x,\n        screenBounds.y\n      ]);\n      const bottomRight = projection.screenToWorld([\n        screenBounds.right,\n        screenBounds.bottom\n      ]);\n\n      return new Bounds({\n        height: bottomRight[1] - topLeft[1],\n        width: bottomRight[0] - topLeft[0],\n        x: topLeft[0],\n        y: topLeft[1]\n      });\n    }\n\n    return new Bounds({ x: 0, y: 0, width: 1, height: 1 });\n  }\n\n  /**\n   * Retrieves the current pan of the controlled camera\n   */\n  get pan(): Vec3 {\n    return this.camera.offset;\n  }\n\n  /**\n   * Sets bounds applicable to the supplied view.\n   * If no view is supplied, it uses the first in the startViews array\n   */\n  setBounds(bounds: ICameraBoundsOptions) {\n    if (!this.wheelShouldScroll) {\n      this.bounds = bounds;\n      this.applyBounds();\n    }\n  }\n\n  /**\n   * Retrieves the current scale of the camera\n   */\n  get scale(): Vec3 {\n    return this.camera.scale;\n  }\n\n  /**\n   * This lets you set the visible range of a view based on the view's camera. This will probably not work\n   * as expected if the view indicated and this controller do not share the same camera.\n   *\n   * @param viewId The id of the view when the view was generated when the surface was made\n   */\n  setRange(newWorld: Bounds, viewId: string) {\n    console.warn(\"setRange\");\n    /** Get the projections for the provided view */\n    const projection = this.getProjection(viewId);\n    /** Get the bounds on the screen for the indicated view */\n    const screenBounds = this.getViewScreenBounds(viewId);\n    /** Get the view the range is being applied towards */\n    const view = this.getView(viewId);\n\n    // Make sure we have a valid projection and screen bounds to make the adjustment\n    if (projection && screenBounds && view) {\n      const deltaScale = subtract3(\n        [\n          screenBounds.width / newWorld.width,\n          screenBounds.height / newWorld.height,\n          1\n        ],\n        this.camera.scale\n      );\n\n      this.camera.setScale(\n        add3(this.camera.scale, this.scaleFilter(deltaScale, view, [view]))\n      );\n\n      const deltaPan = subtract3(\n        [-newWorld.x, -newWorld.y, 0],\n        this.camera.offset\n      );\n\n      this.camera.setOffset(\n        add3(this.camera.offset, this.scaleFilter(deltaPan, view, [view]))\n      );\n\n      // Bound the camera to the specified bounding range\n      this.applyBounds();\n      // Broadcast the change occurred\n      this.onRangeChanged(this.camera, view);\n      // Bound the camera to the specified bounding range\n      this.applyBounds();\n    }\n  }\n}\n","export * from \"./basic-camera-controller\";\n","export * from \"./base-event-managers\";\nexport * from \"./base-layers\";\nexport * from \"./instance-provider\";\nexport * from \"./primitives\";\nexport * from \"./surface\";\nexport * from \"./types\";\nexport * from \"./util\";\nexport * from \"./shaders\";\n","export * from \"./voidgl\";\n"],"sourceRoot":""}