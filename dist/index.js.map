{"version":3,"sources":["webpack://network-bubble-chart/webpack/universalModuleDefinition","webpack://network-bubble-chart/webpack/bootstrap","webpack://network-bubble-chart/./src/types.ts","webpack://network-bubble-chart/./src/util/index.ts","webpack://network-bubble-chart/./src/instance-provider/index.ts","webpack://network-bubble-chart/./src/math/vector.ts","webpack://network-bubble-chart/./node_modules/debug/src/browser.js","webpack://network-bubble-chart/./src/2d/view/layer-2d.ts","webpack://network-bubble-chart/./src/gl/index.ts","webpack://network-bubble-chart/./src/math/primitives/bounds.ts","webpack://network-bubble-chart/./src/shaders/processing/index.ts","webpack://network-bubble-chart/./src/instance-provider/instance.ts","webpack://network-bubble-chart/./src/util/uid.ts","webpack://network-bubble-chart/./src/gl/gl-settings.ts","webpack://network-bubble-chart/./src/math/index.ts","webpack://network-bubble-chart/./src/util/camera.ts","webpack://network-bubble-chart/./src/2d/types.ts","webpack://network-bubble-chart/./src/surface/index.ts","webpack://network-bubble-chart/./src/resources/index.ts","webpack://network-bubble-chart/./src/resources/texture/sub-texture.ts","webpack://network-bubble-chart/./src/instance-provider/observable.ts","webpack://network-bubble-chart/./src/gl/texture.ts","webpack://network-bubble-chart/./src/util/create-util.ts","webpack://network-bubble-chart/./src/gl/webgl-stat.ts","webpack://network-bubble-chart/./src/util/identify-by-key.ts","webpack://network-bubble-chart/./src/resources/texture/pack-node.ts","webpack://network-bubble-chart/./src/surface/layer-processing/generate-layer-model.ts","webpack://network-bubble-chart/./src/surface/buffer-management/buffer-manager-base.ts","webpack://network-bubble-chart/./src/math/matrix.ts","webpack://network-bubble-chart/./src/util/promise-resolver.ts","webpack://network-bubble-chart/./src/util/shader-templating.ts","webpack://network-bubble-chart/./src/gl/types.ts","webpack://network-bubble-chart/./src/2d/index.ts","webpack://network-bubble-chart/./src/2d/view/camera-2d.ts","webpack://network-bubble-chart/./src/2d/view/control-2d.ts","webpack://network-bubble-chart/./src/resources/base-resource-manager.ts","webpack://network-bubble-chart/./src/surface/layer-processing/base-io-expansion.ts","webpack://network-bubble-chart/./src/shaders/index.ts","webpack://network-bubble-chart/./src/event-management/event-manager.ts","webpack://network-bubble-chart/./src/event-management/simple-event-handler.ts","webpack://network-bubble-chart/./src/gl/gl-decode.ts","webpack://network-bubble-chart/./src/3d/scene-graph/transform.ts","webpack://network-bubble-chart/./src/math/auto-easing-method.ts","webpack://network-bubble-chart/./src/math/base-projection.ts","webpack://network-bubble-chart/./src/math/primitives/index.ts","webpack://network-bubble-chart/./src/util/common-options.ts","webpack://network-bubble-chart/./src/util/frame.ts","webpack://network-bubble-chart/./src/util/reactive-diff.ts","webpack://network-bubble-chart/./src/surface/view.ts","webpack://network-bubble-chart/./src/surface/layer-scene.ts","webpack://network-bubble-chart/./src/resources/text/font-resource-request.ts","webpack://network-bubble-chart/./src/resources/texture/texture-io-expansion.ts","webpack://network-bubble-chart/./src/resources/texture/atlas.ts","webpack://network-bubble-chart/./src/constants.ts","webpack://network-bubble-chart/./src/instance-provider/instance-provider.ts","webpack://network-bubble-chart/./src/2d/layers/labels/label-instance.ts","webpack://network-bubble-chart/./src/event-management/user-input-event-manager.ts","webpack://network-bubble-chart/./src/gl/gl-proxy.ts","webpack://network-bubble-chart/./src/math/quaternion.ts","webpack://network-bubble-chart/./src/math/primitives/absolute-position.ts","webpack://network-bubble-chart/./src/util/shallow-compare.ts","webpack://network-bubble-chart/./src/util/common-filters.ts","webpack://network-bubble-chart/./src/util/mouse.ts","webpack://network-bubble-chart/./src/util/quad-tree.ts","webpack://network-bubble-chart/./src/util/wait-for-valid-dimensions.ts","webpack://network-bubble-chart/./src/gl/gl-state.ts","webpack://network-bubble-chart/./src/gl/render-target.ts","webpack://network-bubble-chart/./src/gl/scene.ts","webpack://network-bubble-chart/./src/gl/webgl-renderer.ts","webpack://network-bubble-chart/./src/surface/layer-processing/generate-default-scene.ts","webpack://network-bubble-chart/./src/shaders/processing/base-shader-io-injection.ts","webpack://network-bubble-chart/./src/shaders/processing/shader-module-unit.ts","webpack://network-bubble-chart/./src/shaders/processing/shader-module.ts","webpack://network-bubble-chart/./src/resources/text/font-manager.ts","webpack://network-bubble-chart/./src/resources/text/font-map.ts","webpack://network-bubble-chart/./src/resources/text/font-renderer.ts","webpack://network-bubble-chart/./src/resources/text/glyph-renderer.ts","webpack://network-bubble-chart/./src/resources/texture/atlas-manager.ts","webpack://network-bubble-chart/./src/resources/texture/image-rasterizer.ts","webpack://network-bubble-chart/./src/resources/texture/atlas-resource-manager.ts","webpack://network-bubble-chart/./src/util/easing-props.ts","webpack://network-bubble-chart/./src/surface/layer-processing/generate-layer-geometry.ts","webpack://network-bubble-chart/./src/surface/layer-processing/generate-layer-material.ts","webpack://network-bubble-chart/./src/surface/layer-processing/inject-shader-io.ts","webpack://network-bubble-chart/./src/surface/layer.ts","webpack://network-bubble-chart/./src/util/emit-once.ts","webpack://network-bubble-chart/./src/surface/buffer-management/uniform-buffering/uniform-buffer-manager.ts","webpack://network-bubble-chart/./src/surface/buffer-management/base-diff-processor.ts","webpack://network-bubble-chart/./src/2d/shader-modules/shader-fragments/world-2d-projection.vs","webpack://network-bubble-chart/./src/2d/view/index.ts","webpack://network-bubble-chart/./src/2d/layers/edges/types.ts","webpack://network-bubble-chart/./src/2d/layers/labels/label-layer.ts","webpack://network-bubble-chart/./src/2d/layers/labels/glyph-instance.ts","webpack://network-bubble-chart/./src/2d/layers/labels/glyph-layer.ts","webpack://network-bubble-chart/./src/2d/layers/labels/glyph-layer-always.fs","webpack://network-bubble-chart/./src/2d/layers/labels/glyph-layer-always.vs","webpack://network-bubble-chart/./src/2d/layers/labels/text-area-instance.ts","webpack://network-bubble-chart/./src/2d/layers/rectangle/rectangle-instance.ts","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/hsv.vs","webpack://network-bubble-chart/./src/3d/view/view-3d.ts","webpack://network-bubble-chart/./src/3d/view/projection-3d.ts","webpack://network-bubble-chart/./src/3d/scene-graph/index.ts","webpack://network-bubble-chart/./src/3d/layers/base/instance-3d.ts","webpack://network-bubble-chart/./src/index.ts","webpack://network-bubble-chart/./src/util/webgl2-type-shim.ts","webpack://network-bubble-chart/./src/event-management/index.ts","webpack://network-bubble-chart/./src/event-management/types.ts","webpack://network-bubble-chart/./src/gl/attribute.ts","webpack://network-bubble-chart/./src/gl/geometry.ts","webpack://network-bubble-chart/./src/math/ray.ts","webpack://network-bubble-chart/./src/util/common-operations.ts","webpack://network-bubble-chart/./src/util/easing-util.ts","webpack://network-bubble-chart/./src/util/extend-shader.ts","webpack://network-bubble-chart/./src/util/normalize-wheel/index.ts","webpack://network-bubble-chart/./src/util/normalize-wheel/normalizeWheel.ts","webpack://network-bubble-chart/./src/util/normalize-wheel/UserAgent_DEPRECATED.js","webpack://network-bubble-chart/./src/util/normalize-wheel/isEventSupported.js","webpack://network-bubble-chart/./src/util/normalize-wheel/ExecutionEnvironment.js","webpack://network-bubble-chart/./src/util/wait.ts","webpack://network-bubble-chart/./node_modules/process/browser.js","webpack://network-bubble-chart/./node_modules/debug/src/debug.js","webpack://network-bubble-chart/./node_modules/ms/index.js","webpack://network-bubble-chart/./src/gl/material.ts","webpack://network-bubble-chart/./src/gl/model.ts","webpack://network-bubble-chart/./src/2d/shader-modules/index.ts","webpack://network-bubble-chart/./src/2d/shader-modules/world-2d.shader.ts","webpack://network-bubble-chart/./src/surface/surface.ts","webpack://network-bubble-chart/./src/resources/resource-router.ts","webpack://network-bubble-chart/./src/resources/text/index.ts","webpack://network-bubble-chart/./src/resources/text/cpu-sdf.ts","webpack://network-bubble-chart/./src/resources/text/svg-to-data.ts","webpack://network-bubble-chart/./src/resources/text/font-resource-manager.ts","webpack://network-bubble-chart/./src/resources/texture/index.ts","webpack://network-bubble-chart/./src/resources/texture/video-texture-monitor.ts","webpack://network-bubble-chart/./src/resources/texture/atlas-resource-request.ts","webpack://network-bubble-chart/./src/surface/layer-processing/base-io-expanders/active-io-expansion.ts","webpack://network-bubble-chart/./src/surface/layer-processing/base-io-expanders/fragments/active-attribute-handler.vs","webpack://network-bubble-chart/./src/util/color-picking-analysis.ts","webpack://network-bubble-chart/./src/surface/base-io-sorting.ts","webpack://network-bubble-chart/./src/surface/event-managers/layer-mouse-events.ts","webpack://network-bubble-chart/./src/surface/layer-processing/base-io-expanders/basic-io-expansion.ts","webpack://network-bubble-chart/./src/surface/layer-processing/base-io-expanders/easing-io-expansion.ts","webpack://network-bubble-chart/./src/surface/layer-processing/pack-attributes.ts","webpack://network-bubble-chart/./src/shaders/processing/shader-processor.ts","webpack://network-bubble-chart/./src/shaders/template-vars.ts","webpack://network-bubble-chart/./src/shaders/processing/metrics-processing.ts","webpack://network-bubble-chart/./src/surface/buffer-management/index.ts","webpack://network-bubble-chart/./src/surface/buffer-management/instance-attribute-buffering/instance-attribute-buffer-manager.ts","webpack://network-bubble-chart/./src/instance-provider/basic-instance.ts","webpack://network-bubble-chart/./src/surface/buffer-management/instance-attribute-packed-buffering/instance-attribute-packing-buffer-manager.ts","webpack://network-bubble-chart/./src/surface/buffer-management/instance-diff-manager.ts","webpack://network-bubble-chart/./src/surface/buffer-management/instance-attribute-buffering/instance-attribute-diff-processor.ts","webpack://network-bubble-chart/./src/surface/buffer-management/uniform-buffering/uniform-diff-processor.ts","webpack://network-bubble-chart/./src/surface/layer-interaction-handler.ts","webpack://network-bubble-chart/./src/2d/view/basic-camera-2d-controller.ts","webpack://network-bubble-chart/./src/2d/view/reference-camera-2d.ts","webpack://network-bubble-chart/./src/2d/view/view-2d.ts","webpack://network-bubble-chart/./src/2d/view/projection-2d.ts","webpack://network-bubble-chart/./src/2d/layers/index.ts","webpack://network-bubble-chart/./src/2d/layers/arcs/index.ts","webpack://network-bubble-chart/./src/2d/layers/arcs/arc-layer.ts","webpack://network-bubble-chart/./src/2d/layers/arcs/arc-layer.vs","webpack://network-bubble-chart/./src/2d/layers/arcs/arc-layer-screen-space.vs","webpack://network-bubble-chart/./src/2d/layers/arcs/arc-layer.fs","webpack://network-bubble-chart/./src/2d/layers/arcs/arc-instance.ts","webpack://network-bubble-chart/./src/2d/layers/circles/index.ts","webpack://network-bubble-chart/./src/2d/layers/circles/circle-layer.ts","webpack://network-bubble-chart/./src/2d/layers/circles/circle-layer-points.fs","webpack://network-bubble-chart/./src/2d/layers/circles/circle-layer.fs","webpack://network-bubble-chart/./src/2d/layers/circles/circle-layer-points.vs","webpack://network-bubble-chart/./src/2d/layers/circles/circle-layer.vs","webpack://network-bubble-chart/./src/2d/layers/circles/circle-instance.ts","webpack://network-bubble-chart/./src/2d/layers/edges/index.ts","webpack://network-bubble-chart/./src/2d/layers/edges/edge-layer.ts","webpack://network-bubble-chart/./src/2d/layers/edges/shader/edge-layer-line.vs","webpack://network-bubble-chart/./src/2d/layers/edges/shader/edge-layer-bezier.vs","webpack://network-bubble-chart/./src/2d/layers/edges/shader/edge-layer-bezier2.vs","webpack://network-bubble-chart/./src/2d/layers/edges/shader/edge-layer.vs","webpack://network-bubble-chart/./src/2d/layers/edges/shader/edge-layer-screen-curve.vs","webpack://network-bubble-chart/./src/2d/layers/edges/shader/edge-layer.fs","webpack://network-bubble-chart/./src/2d/layers/edges/edge-instance.ts","webpack://network-bubble-chart/./src/2d/layers/images/index.ts","webpack://network-bubble-chart/./src/2d/layers/images/image-layer.ts","webpack://network-bubble-chart/./src/2d/layers/images/debug-video.ts","webpack://network-bubble-chart/./src/2d/layers/images/image-render-layer.ts","webpack://network-bubble-chart/./src/2d/layers/images/image-layer.fs","webpack://network-bubble-chart/./src/2d/layers/images/image-layer.vs","webpack://network-bubble-chart/./src/2d/layers/images/image-instance.ts","webpack://network-bubble-chart/./src/2d/layers/labels/index.ts","webpack://network-bubble-chart/./src/2d/layers/labels/text-area-layer-bound-max.fs","webpack://network-bubble-chart/./src/2d/layers/labels/glyph-layer-bound-max.fs","webpack://network-bubble-chart/./src/2d/layers/labels/text-area-layer-bound-max.vs","webpack://network-bubble-chart/./src/2d/layers/labels/glyph-layer-bound-max.vs","webpack://network-bubble-chart/./src/2d/layers/labels/glyph-layer-never.fs","webpack://network-bubble-chart/./src/2d/layers/labels/text-area-layer-never.fs","webpack://network-bubble-chart/./src/2d/layers/labels/text-area-layer-never.vs","webpack://network-bubble-chart/./src/2d/layers/labels/glyph-layer-never.vs","webpack://network-bubble-chart/./src/2d/layers/labels/text-area-layer-always.fs","webpack://network-bubble-chart/./src/2d/layers/labels/text-area-layer-always.vs","webpack://network-bubble-chart/./src/2d/layers/labels/text-area-layer.ts","webpack://network-bubble-chart/./src/2d/layers/labels/border-instance.ts","webpack://network-bubble-chart/./src/2d/layers/labels/border-layer.ts","webpack://network-bubble-chart/./src/2d/layers/labels/border-layer.fs","webpack://network-bubble-chart/./src/2d/layers/labels/border-layer.vs","webpack://network-bubble-chart/./src/2d/layers/rectangle/index.ts","webpack://network-bubble-chart/./src/2d/layers/rectangle/rectangle-layer.ts","webpack://network-bubble-chart/./src/2d/layers/rectangle/rectangle-layer.fs","webpack://network-bubble-chart/./src/2d/layers/rectangle/rectangle-layer.vs","webpack://network-bubble-chart/./src/2d/layers/rings/index.ts","webpack://network-bubble-chart/./src/2d/layers/rings/ring-instance.ts","webpack://network-bubble-chart/./src/2d/layers/rings/ring-layer.ts","webpack://network-bubble-chart/./src/2d/layers/rings/ring-layer.fs","webpack://network-bubble-chart/./src/2d/layers/rings/ring-layer.vs","webpack://network-bubble-chart/./src/3d/index.ts","webpack://network-bubble-chart/./src/3d/shader-modules/index.ts","webpack://network-bubble-chart/./src/3d/shader-modules/world-2d-xy.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/index.ts","webpack://network-bubble-chart/./src/shaders/base-modules/camera-metrics.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/projection.vs","webpack://network-bubble-chart/./src/shaders/base-modules/dim-color.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/frame-metrics.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/hsv.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/instancing.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/math.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/constants/pi_inv.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/constants/pi2_inv.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/constants/pi_2.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/constants/pi_4.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/constants/pi.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/constants/pi2.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/constants/to-degrees.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/constants/to-radians.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/bezier1.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/bezier2.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/arc.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/fmod.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/wrap.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/fcos.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/fsin.vs","webpack://network-bubble-chart/./src/shaders/base-modules/matrix.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/matrix/translation.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/matrix/rotation.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/matrix/scale.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/matrix/transform.vs","webpack://network-bubble-chart/./src/shaders/base-modules/picking.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/picking.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/picking.fs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/no-picking.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/no-picking.fs","webpack://network-bubble-chart/./src/shaders/base-modules/util.shader.ts","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/no-op.vs","webpack://network-bubble-chart/./src/shaders/base-modules/shader-fragments/no-op.fs","webpack://network-bubble-chart/./src/3d/shader-modules/world-2d-xz.shader.ts","webpack://network-bubble-chart/./src/3d/shader-modules/shader-fragments/world-2d-xz-projection.vs","webpack://network-bubble-chart/./src/3d/shader-modules/world-2d-yz.shader.ts","webpack://network-bubble-chart/./src/3d/shader-modules/shader-fragments/world-2d-yz-projection.vs","webpack://network-bubble-chart/./src/3d/view/index.ts","webpack://network-bubble-chart/./src/3d/view/layer-2d-in-3d.ts","webpack://network-bubble-chart/./src/3d/scene-graph/node-3d.ts","webpack://network-bubble-chart/./src/3d/scene-graph/node.ts","webpack://network-bubble-chart/./src/3d/layers/index.ts","webpack://network-bubble-chart/./src/3d/layers/base/index.ts","webpack://network-bubble-chart/./src/3d/layers/cube/index.ts","webpack://network-bubble-chart/./src/3d/layers/cube/cube-layer.ts","webpack://network-bubble-chart/./src/3d/layers/cube/cube-layer.fs","webpack://network-bubble-chart/./src/3d/layers/cube/cube-layer.vs","webpack://network-bubble-chart/./src/3d/layers/cube/cube-instance.ts","webpack://network-bubble-chart/./src/base-surfaces/index.ts","webpack://network-bubble-chart/./src/base-surfaces/basic-surface.ts","webpack://network-bubble-chart/./src/util-layers/index.ts","webpack://network-bubble-chart/./src/util-layers/log-changes-layer.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","sqrt","max","min","floor","ceil","abs","acos","sin","load","storage","debug","e","process","env","DEBUG","log","console","Function","apply","arguments","formatArgs","args","useColors","this","namespace","humanize","diff","color","splice","index","lastC","replace","match","save","namespaces","removeItem","type","navigator","userAgent","toLowerCase","document","documentElement","style","WebkitAppearance","firebug","exception","table","parseInt","RegExp","$1","chrome","local","localStorage","localstorage","colors","formatters","j","v","JSON","stringify","err","message","enable","Layer2D","x","y","Bounds","Instance","Texture","Camera","SubTexture","ObservableMonitoring","WebGLStat","IdentifyByKey","IdentifiableData","PackNode","BufferManagerBase","cos","tan","PromiseResolver","shader","options","required","onError","onToken","onMain","Camera2D","Control2D","BaseResourceManager","InvalidResourceManager","BaseIOExpansion","EventManager","SimpleEventHandler","Transform","pow","round","PI","delay","loop","add","scale","subtract","slerpQuat","vec","AutoEasingMethod","BaseProjection","SimpleProjection","CommonMaterialOptions","commandFn","command","interval","intervalStartTime","duration","durationStartTime","startTime","ReactiveDiff","View","NoView","LayerScene","list","TextureIOExpansion","Atlas","instance","InstanceProvider","LabelInstance","UserInputEventManager","vsId","programId","ext","stat","GLProxy","exp","atan2","roll","pitch","yaw","Boolean","touch","normalizeWheel","eventElementPosition","QuadTreeQuadrants","QuadTreeNode","QuadTree","uniform","GLState","RenderTarget","Scene","target","canvas","width","height","pixelRatio","WebGLRenderer","BaseShaderIOInjection","ShaderModuleUnit","ShaderModule","FontManager","FontMap","FontRenderer","AtlasManager","ImageRasterizer","layer","AtlasResourceManager","EasingProps","vertexAttributes","instanceAttributes","uniforms","streamChanges","stream","streamIndex","Layer","UniformBufferManager","BaseDiffProcessor","diffType","changed","LabelLayer","GlyphInstance","GlyphLayer","TextAreaInstance","RectangleInstance","View3D","projectionOptions","fov","near","Projection3D","Instance3D","isDynamic","isInstanced","Attribute","Geometry","EasingUtil","_ie","_firefox","_opera","_webkit","_chrome","_ie_real_version","_osx","_windows","_linux","_android","_win64","_iphone","_ipad","_native","_mobile","_populated","_populate","uas","agent","exec","os","parseFloat","NaN","documentMode","trident","ver","UserAgent_DEPRECATED","ie","ieCompatibilityMode","ie64","firefox","opera","webkit","safari","windows","osx","linux","iphone","mobile","nativeApp","android","ipad","useHasFeature","ExecutionEnvironment","canUseDOM","implementation","hasFeature","eventNameSuffix","capture","eventName","isSupported","element","createElement","setAttribute","canUseWorkers","Worker","canUseEventListeners","addEventListener","attachEvent","canUseViewport","screen","isInWorker","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","Array","push","title","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","createDebug","prevTime","enabled","self","curr","Date","ms","prev","coerce","unshift","format","formatter","val","logFn","hash","charCodeAt","Math","selectColor","destroy","init","instances","indexOf","stack","disable","names","skips","split","substr","test","h","plural","str","String","parse","isNaN","long","fmtShort","Material","Model","view","pickingPass","mouse","Surface","ResourceRouter","log2","negate","mapMethod","FontResourceManager","VideoTextureMonitor","ActiveIOExpansion","BaseIOSorting","LayerMouseEvents","BasicIOExpansion","size","update","EasingIOExpansion","ShaderProcessor","MetricsProcessing","InstanceAttributeBufferManager","BasicInstance","attributes","InstanceAttributePackingBufferManager","InstanceDiffManager","InstanceAttributeDiffProcessor","UniformDiffProcessor","onMouseDown","onTouchDown","onTouchOver","onMouseOut","onTouchOut","onMouseUp","onMouseUpOutside","onTouchUp","onTouchUpOutside","onTouchAllEnd","onMouseOver","onMouseMove","onTouchMove","onMouseClick","onTap","LayerInteractionHandler","BasicCamera2DController","ReferenceCamera2D","View2D","Projection2D","scaleType","ArcLayer","ArcInstance","animate","scaleFactor","usePoints","opacity","CircleLayer","CircleInstance","EdgeLayer","EdgeInstance","ImageLayer","ImageRenderLayer","ImageInstance","TextAreaLayer","BorderInstance","BorderLayer","RectangleLayer","RingInstance","RingLayer","Node3D","Node","CubeLayer","CubeInstance","BasicSurface","messageHeader"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"network-bubble-chart\"] = factory();\n\telse\n\t\troot[\"network-bubble-chart\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 101);\n","import {\n  IMouseInteraction,\n  ISingleTouchInteraction,\n  ITouchInteraction\n} from \"./event-management\";\nimport {\n  Attribute,\n  GLSettings,\n  IMaterialUniform,\n  MaterialOptions,\n  MaterialUniformType,\n  Texture\n} from \"./gl\";\nimport { Instance } from \"./instance-provider/instance\";\nimport { BaseProjection } from \"./math\";\nimport {\n  Mat3x3,\n  Mat4x4,\n  Vec,\n  Vec1,\n  Vec2,\n  Vec2Compat,\n  Vec3,\n  Vec4\n} from \"./math\";\nimport { IAutoEasingMethod } from \"./math/auto-easing-method\";\nimport { BaseResourceOptions } from \"./resources/base-resource-manager\";\nimport { IViewProps } from \"./surface\";\nimport { ISceneOptions } from \"./surface/layer-scene\";\n\nexport type Diff<T extends string, U extends string> = ({ [P in T]: P } &\n  { [P in U]: never } & { [x: string]: never })[T];\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\nexport type ShaderIOValue = Vec1 | Vec2 | Vec3 | Vec4 | Vec4[] | Float32Array;\nexport type InstanceIOValue = Vec1 | Vec2 | Vec3 | Vec4 | Mat4x4;\nexport type InstanceIOVectorValue = Vec1 | Vec2 | Vec3 | Vec4;\nexport type UniformIOValue =\n  | number\n  | InstanceIOValue\n  | Mat3x3\n  | Mat4x4\n  | Float32Array\n  | Texture\n  | number[];\n\nexport enum InstanceBlockIndex {\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4\n}\n\nexport enum InstanceAttributeSize {\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4,\n  MAT4X4 = 16,\n  /** Special case for making instance attributes that can target Atlas resources */\n  ATLAS = 99\n}\n\nexport const instanceAttributeSizeFloatCount: { [key: number]: number } = {\n  [InstanceAttributeSize.ONE]: 1,\n  [InstanceAttributeSize.TWO]: 2,\n  [InstanceAttributeSize.THREE]: 3,\n  [InstanceAttributeSize.FOUR]: 4,\n  [InstanceAttributeSize.MAT4X4]: 16,\n  [InstanceAttributeSize.ATLAS]: 4\n};\n\nexport enum UniformSize {\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4,\n  MATRIX3 = 9,\n  MATRIX4 = 16,\n  VEC4_ARRAY = 98,\n  ATLAS = 99\n}\n\nexport enum VertexAttributeSize {\n  ONE = 1,\n  TWO = 2,\n  THREE = 3,\n  FOUR = 4\n}\n\n/**\n * These are valid atlas sizes available. We force a power of 2 to be utilized.\n * We do not allow crazy large sizes as browsers have very real caps on resources.\n * This helps implementations be a little smarter about what they are using. Future\n * versions may increase this number as GPUs improve and standards allow greater\n * flexibility.\n */\nexport enum TextureSize {\n  _2 = 0x01 << 1,\n  _4 = 0x01 << 2,\n  _8 = 0x01 << 3,\n  _16 = 0x01 << 4,\n  _32 = 0x01 << 5,\n  _64 = 0x01 << 6,\n  _128 = 0x01 << 7,\n  _256 = 0x01 << 8,\n  _512 = 0x01 << 9,\n  _1024 = 0x01 << 10,\n  _2048 = 0x01 << 11,\n  _4096 = 0x01 << 12\n}\n\n/**\n * Types of reesources that can be generated and provided via the resource manager\n */\nexport enum ResourceType {\n  ATLAS = 0,\n  FONT = 1\n}\n\n/**\n * Base options needed for a resource to be considered a viable resource\n */\nexport interface IResourceType {\n  type: number;\n}\n\n/**\n * This represents a color in the VoidGL system. Ranges are [0 - 1, 0 - 1, 0 - 1, 0 - 1]\n */\nexport type Color = Vec4;\n\n/**\n * This represents a rotation in Euler angles [X axis, Y axis, Z axis]\n */\nexport type EulerRotation = Vec3;\n\n/**\n * Order description of the way a euler angle is supposed to be applied\n */\nexport enum EulerOrder {\n  zyx,\n  zyz,\n  zxy,\n  zxz,\n  yxz,\n  yxy,\n  yzx,\n  yzy,\n  xyz,\n  xyx,\n  xzy,\n  xzx\n}\n\n/**\n * Represents something with a unique id\n */\nexport interface IdentifiableById {\n  /** A unique identifier */\n  id: string | number;\n}\n\n/**\n * Represents something with a unique key\n */\nexport interface IdentifiableByKey {\n  /** A unique identifier */\n  key: string | number;\n}\n\n/**\n * Information provided in user interaction events interacting with instances and\n * layers.\n */\nexport interface IPickInfo<T extends Instance> {\n  /** The interaction that created this picking information */\n  readonly interaction?: IMouseInteraction | ITouchInteraction;\n  /** This is the parent layer id of the instances interacted with */\n  readonly layer: string;\n  /** This is the list of instances that were detected in the interaction */\n  readonly instances: T[];\n  /** This is the screen coordinates of the interaction point that interacted with the instances */\n  readonly screen: Vec2;\n  /** This is the world coordinates of the ineraction point that interacted with the instances */\n  readonly world: Vec2Compat;\n  /** Projection methods to easily go between coordinate spaces */\n  readonly projection: BaseProjection<any>;\n}\n\n/**\n * Picking info associated with mouse events\n */\nexport interface IMousePickInfo<T extends Instance> extends IPickInfo<T> {\n  /** The mouse interaction that created this picking information */\n  readonly interaction: IMouseInteraction;\n}\n\n/**\n * Picking info associated with touch events\n */\nexport interface ITouchPickInfo<T extends Instance> extends IPickInfo<T> {\n  /** The touch interaction that created this picking information. Contains all touch interactive information for the event */\n  readonly interaction: ITouchInteraction;\n  /** The specific touch that caused the event to occur */\n  readonly touch: ISingleTouchInteraction;\n}\n\nexport interface IVertexAttribute {\n  /**\n   * When initWithBuffer and customFill are not specified, this is was the system will initially\n   * load each vertex attribute with.\n   */\n  defaults?: number[];\n  /**\n   * When this is specified it will initialize the model's attribute with the data in this buffer.\n   */\n  initWithBuffer?: Float32Array;\n  /**\n   * When generating this attribute in the shader this will be the prefix to the attribute:\n   * For instance, if you specify 'highp' as the modifier, then the attribute that appears\n   * in the shader will be:\n   * attribute highp vec3 position;\n   */\n  qualifier?: string;\n  /**\n   * This is the name the attribute will be for the model.\n   */\n  name: string;\n  /**\n   * This is the number of floats the attribute will consume. For now, we only allow for up\n   * to four floats per attribute.\n   */\n  size: VertexAttributeSize;\n  /**\n   * This lets you populate the buffer with an automatically called method. This will fire when\n   * necessary updates are detected or on initialization.\n   */\n  update(vertex: number): ShaderIOValue;\n}\n\nexport interface IVertexAttributeInternal extends IVertexAttribute {\n  /** This is the actual attribute generated internally for the GL interfacing */\n  materialAttribute: Attribute | null;\n}\n\nexport interface IInstanceAttribute<T extends Instance> {\n  /**\n   * If this is specified, this attribute becomes a size of 4 and will have a block index of\n   * 0. This makes this attribute and layer become compatible with reading atlas resources.\n   * The value provided for this property should be the name of the atlas that is created.\n   */\n  resource?: {\n    /** This is a method that should return the string key identifier of the resource to be used */\n    key(): string;\n    /** Specify the name that will be injected that will be the sampler2D in the shader */\n    name: string;\n    /**\n     * This specifies which of the shaders the sampler2D will be injected into.\n     * Defaults to the Fragment shader only.\n     */\n    shaderInjection?: ShaderInjectionTarget;\n  };\n  /**\n   * This is a block index helping describe the instancing process. It can be any number as\n   * the system will sort and organize them for you. This only helps the system detect when\n   * you cram too much info into a single block. The tighter you pack your blocks the better\n   * your program will perform.\n   *\n   * Note: It's best to leave this blank as the system now packs your attributes for you and\n   * will determine this number for you.\n   */\n  block?: number;\n  /**\n   * This is the index within the block this attribute will be available.\n   */\n  blockIndex?: InstanceBlockIndex;\n  /**\n   * Child attributes are attributes that are guaranteed to update when the parent attribute\n   * is updated. This is useful for attributes with special properties that get expanded to\n   * other types of attributes such as easing attributes which gain start, duration, and other values\n   * to make the attribute work.\n   *\n   * If the settings on this attrubute spawns additional attributes, those attributes shall\n   * be populated here. Otherwise this remains undefined.\n   */\n  childAttributes?: IInstanceAttribute<T>[];\n  /**\n   * When this is set, the system will automatically inject necessary Shader IO to facilitate\n   * performing the easing on the GPU, which saves enormous amounts of CPU processing time\n   * trying to calcuate animations and tweens for properties.\n   *\n   * NOTE: Setting this increases the amount of data per instance by: size * 2 + ;\n   * as it injects in a start value, start time, and duration\n   */\n  easing?: IAutoEasingMethod<Vec>;\n  /**\n   * This is the name that will be available in your shader for use. This will only be\n   * available after the ${attributes} declaration.\n   */\n  name: string;\n  /**\n   * If this attribute is created automatically by the system based on the settings of another\n   * attribute, that parent attribute will be set here. Otherwise this remains undefined.\n   */\n  parentAttribute?: IInstanceAttribute<T>;\n  /**\n   * When generating this attribute in the shader this will be the prefix to the attribute:\n   * For instance, if you specify 'highp' as the modifier, then the attribute that appears\n   * in the shader will be:\n   * attribute highp vec3 position;\n   */\n  qualifier?: string;\n  /**\n   * This is how many floats the instance attribute takes up. Due to how instancing is\n   * implemented, we can only take up to 4 floats per variable right now.\n   */\n  size?: InstanceAttributeSize;\n  /**\n   * This is the accessor that executes when the instance needs updating. Simply return the\n   * value that should be populated for this attribute.\n   */\n  update(instance: T): InstanceIOValue;\n}\n\n/**\n * Internal Instance Attributes are ones that actually map to an attribute in the shader and use\n * hardware instancing.\n */\nexport interface IInstanceAttributeInternal<T extends Instance>\n  extends IInstanceAttribute<T> {\n  /** We will keep an internal uid for the  */\n  uid: number;\n  /**\n   * Sometimes an attribute is actually a sub attribute to another attribute, such as in the cases of\n   * attribute packing (in uniforms or in attribute packing). This UID indicates the parental attribute\n   * UID. This parent identifier may be an actual InstanceAttribute or not. It could just indicate this\n   * attribute is packed into SOMETHING.\n   */\n  packUID?: number;\n  /** This is the actual attribute mapped to a buffer */\n  bufferAttribute: Attribute;\n}\n\n/**\n * This is specifically a deduced type of instance attribute that is specially dealing with Vec1-4 values. These types\n * of vectors can be dealt with in special ways, thus they get this special case.\n */\nexport interface IInstanceAttributeVector<T extends Instance>\n  extends IInstanceAttribute<T> {\n  update(instance: T): InstanceIOVectorValue;\n}\n\n/**\n * Typeguard to determine if an instance attribute provides vectors or something larger\n */\nexport function isInstanceAttributeVector<T extends Instance>(\n  val: IInstanceAttribute<T>\n): val is IInstanceAttributeVector<T> {\n  return val.size !== undefined && val.size <= 4;\n}\n\n/**\n * This is an attribute where the resource is definitely declared.\n */\nexport interface IResourceInstanceAttribute<T extends Instance>\n  extends IInstanceAttribute<T> {\n  /**\n   * If this is specified, this attribute becomes a size of 4 and will have a block index of\n   * 0. This makes this attribute and layer become compatible with reading resources.\n   * The value provided for this property should be the name of the resource that is created.\n   */\n  resource: {\n    /** This retrieves the key of the resource that is to be used by the attribute */\n    key(): string;\n    /** Specify the name that will be injected that will be the sampler2D in the shader */\n    name: string;\n    /**\n     * This specifies which of the shaders the sampler2D will be injected into.\n     * Defaults to the Fragment shader only.\n     */\n    shaderInjection?: ShaderInjectionTarget;\n  };\n}\n\n/**\n * This represents the minimum information to target a specific resource.\n */\nexport interface IResourceContext {\n  /** Indicates a resource is specified */\n  resource: {\n    /** The resource type. This is the type a manager is registered with when setting up a surface. */\n    type: number;\n    /** This is the identifier of the specific resource within the manager */\n    key: string;\n  };\n}\n\n/**\n * Type guard for resource instance attributes\n */\nexport function isResourceAttribute<T extends Instance>(\n  val: IInstanceAttribute<T>\n): val is IResourceInstanceAttribute<T> {\n  return Boolean(val && val.resource);\n}\n\n/**\n * This is an attribute that is simply a value\n */\nexport interface IEasingInstanceAttribute<T extends Instance>\n  extends IInstanceAttribute<T> {\n  /**\n   * This MUST be defined to be an Easing attribute\n   */\n  easing: IAutoEasingMethod<Vec> & { uid?: number };\n  /**\n   * Easing attributes requires size to be present\n   */\n  size: InstanceAttributeSize;\n  /** If this is an easing attribute, then the instance will only provide Vec1-4 values */\n  update(o: T): InstanceIOVectorValue;\n}\n\n/**\n * This is an attribute that is simply a value\n */\nexport interface IValueInstanceAttribute<T extends Instance>\n  extends IInstanceAttribute<T> {\n  /**\n   * If this is specified, this attribute becomes a size of 4 and will have a block index of\n   * 0. This makes this attribute and layer become compatible with reading atlas resources.\n   * The value provided for this property should be the name of the atlas that is created.\n   */\n  atlas: undefined;\n}\n\n/** These are flags for indicating which shaders receive certain injection elements */\nexport enum ShaderInjectionTarget {\n  /** ONLY the vertex shader will receive the injection */\n  VERTEX = 1,\n  /** ONLY the fragment shader will receive the injection */\n  FRAGMENT = 2,\n  /** Both the fragment and vertex shader will receive the injection */\n  ALL = 3\n}\n\nexport interface IUniform {\n  /**\n   * This lets you specify which of the shaders will receive this uniform as available.\n   * This defaults to only injecting into the vertex shader.\n   */\n  shaderInjection?: ShaderInjectionTarget;\n  /** Name of the uniform as will be available in the shaders */\n  name: string;\n  /** How many floats the uniform shall encompass */\n  size: UniformSize;\n  /**\n   * When generating this uniform in the shader this will be the prefix to the uniform:\n   * For instance, if you specify 'highp' as the modifier, then the uniform that appears\n   * in the shader will be:\n   * uniform highp vec3 position;\n   */\n  qualifier?: string;\n  /**\n   * This is the accessor that executes every frame before this layer is drawn. It gives\n   * opportunity to update the uniform's value before every draw.\n   */\n  update(uniform: IUniform): UniformIOValue;\n}\n\nexport interface IUniformInternal extends IUniform {\n  /**\n   * All layers will have many many ShaderMaterials generated per each instance buffer as a single buffer\n   * can only render so many instances. This tracks across all generated ShaderMaterials for each buffer\n   * the material uniforms that need to be updated as a Uniform for a layer is dictated as uniform across\n   * all instances.\n   */\n  materialUniforms: IMaterialUniform<MaterialUniformType>[];\n}\n\n/**\n * This is the structure of a uniform generated for the sake of instancing\n */\nexport interface IInstancingUniform {\n  name: string;\n  type:\n    | MaterialUniformType.FLOAT\n    | MaterialUniformType.VEC2\n    | MaterialUniformType.VEC3\n    | MaterialUniformType.VEC4\n    | MaterialUniformType.VEC4_ARRAY;\n  value: ShaderIOValue;\n}\n\n/**\n * Represents a complete shader object set.\n */\nexport interface IShaders {\n  fs: string;\n  vs: string;\n}\n\n/**\n * Represents an element that has a full list of projection methods\n */\nexport interface IProjection {\n  /** SInce projections are the views (just interface stripping functionality) we should provide the id for added flexibility to events */\n  id: string;\n  /** This is the chart camera utilized in the projection of elements */\n  props: IViewProps;\n  /** Converts from the pixel density layer to the screen space */\n  pixelSpaceToScreen(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n  /** Converts from the screen coordinates to the pixel density layer */\n  screenToPixelSpace(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n  /** Converts from screen space to the view's relative coordinates */\n  screenToView(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n  /** Converts from screen space to the world space of a scene */\n  screenToWorld(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n  /** Converts from a view's space to the screen */\n  viewToScreen(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n  /** Converts from a views space to the world coordinates */\n  viewToWorld(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n  /** Converts from world coordinate space of a scene to the screen */\n  worldToScreen(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n  /** Converts from world coordinate space of a scene to the view's space */\n  worldToView(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n}\n\n/**\n * The empty, do-nothing, method we devs find ourselves using too much.\n */\nexport function NOOP() {\n  /** No-op */\n}\n\n/**\n * White space character test\n */\nexport const whiteSpaceRegEx = /\\s/g;\nexport const whiteSpaceCharRegEx = /\\s/;\nexport const isWhiteSpace = whiteSpaceCharRegEx.test.bind(whiteSpaceCharRegEx);\n\n/**\n * Newline character test\n */\nexport const newLineRegEx = /\\r\\n|\\n|\\r/g;\nexport const newLineCharRegEx = /\\r\\n|\\n|\\r/;\nexport const isNewline = newLineCharRegEx.test.bind(newLineCharRegEx);\n\n/**\n * Options a layer can provide for a material\n */\nexport type ILayerMaterialOptions = Partial<\n  Omit<MaterialOptions, \"uniforms\" | \"vertexShader\" | \"fragmentShader\">\n>;\n\n/**\n * A wrapper to make declaring layer material options easier and clearer\n */\nexport function createMaterialOptions(options: ILayerMaterialOptions) {\n  return options;\n}\n\n/**\n * This is the type of picking assigned to a layer. Each mode has performance and functionality\n * tradeoffs.\n */\nexport enum PickType {\n  /** Disable any picking methodology */\n  NONE,\n  /**\n   * NOTE: NOT IMPLEMENTED YET\n   *\n   * Uses highly efficient color rendering method to detect an instance on a pixel by pixel check. Since it is\n   * based on rendering, it will only select the 'visually' top most rendered instance. This means instances can be occluded\n   * by other instances is an instance renders behind another.\n   *\n   * This is vastly more efficient and accurate than ALL. This also will be more readily supported than ALL.\n   */\n  SINGLE\n}\n\n/**\n * This represents the settings and objects used to facilitate picking in a layer.\n */\nexport interface IPickingMetrics {\n  /** This is the current pick mode that is active during the draw pass of the layer */\n  currentPickMode: PickType;\n  /** This is the picking style to be used */\n  type: PickType;\n}\n\n/**\n * This is the picking settings and objects to facilitate PickType.SINGLE so we can get\n * a single instance underneath the mouse.\n */\nexport interface ISinglePickingMetrics<T extends Instance>\n  extends IPickingMetrics {\n  /** Set the enum for the type */\n  type: PickType.SINGLE;\n  /**\n   * This is a lookup of the instance by it's UID which is all that is needed to decode a color to an instance\n   * The color UINT8 components composited into a single UINT32 IS the UID of the instance\n   */\n  uidToInstance: Map<number, T>;\n}\n\n/**\n * This is the picking settings and objects to facilitate PickType.NONE where no information\n * is retrieved for mouse interactions.\n */\nexport interface INonePickingMetrics extends IPickingMetrics {\n  // Single Picking does not require any special helper information\n  type: PickType.NONE;\n}\n\nexport interface IColorPickingData {\n  /** The mouse target position where the data is rendered */\n  mouse: Vec2;\n  /** The color data loaded for last picking rendering */\n  colorData: Uint8Array;\n  /** The height of the data array */\n  dataHeight: number;\n  /** The width of the data array */\n  dataWidth: number;\n  /** The nearest found color */\n  nearestColor: number;\n  /** The nearest found color in byte form */\n  nearestColorBytes: Vec4;\n  /** All colors in the data */\n  allColors: number[];\n}\n\n/**\n * Diff types that an instance can go through. Used to help the system consume the diff\n * and apply it to the GL framework.\n */\nexport enum InstanceDiffType {\n  CHANGE = 0,\n  INSERT = 1,\n  REMOVE = 2\n}\n\n/**\n * This is the metrics associated with a frame. Mostly dealing with timing values.\n */\nexport type FrameMetrics = {\n  /** The frame number rendered. Increases by 1 every surface draw */\n  currentFrame: number;\n  /** The start time of the current frame */\n  currentTime: number;\n  /** This is the duration of the previous frame */\n  frameDuration: number;\n  /** The start time of the previous frame */\n  previousTime: number;\n};\n\n/**\n * This represents controls that can be utilized when adjustig easing\n */\nexport interface IEasingControl {\n  /** A value in ms that expresses how long the system should wait before beginning the animation */\n  readonly delay?: number;\n  /** Indicates how long the easing should take to complete in ms */\n  readonly duration: number;\n  /** The end value the easing should approach */\n  readonly end: Vec;\n  /** The starting value of the easing object */\n  readonly start: Vec;\n  /** The start time in ms the easing object utilizes */\n  readonly startTime: number;\n\n  /**\n   * If you manually set values for the easing properties, then you use this to return\n   * the easing object back to an automated state which is where the start value is\n   * the calculated current position of the output and the delay and duration is determined\n   * by the easing set to the layer's IAutomatedEasingMethod value set to the layer.\n   */\n  setAutomatic(): void;\n\n  /**\n   * This controls the start value of the easing. This should be used to force a starting\n   * value of the animation.\n   *\n   * Use setAutomatic() to return to default easing behavior.\n   */\n  setStart(start?: Vec): void;\n\n  /**\n   * This controls of the timing of the easing equation. This should be used to adjust\n   * when a value is to be adjusted\n   *\n   * Use setAutomatic() to return to default easing behavior.\n   */\n  setTiming(delay?: number, duration?: number): void;\n}\n\n/**\n * This is the minimum properties required to make all easing functions operate.\n */\nexport interface IEasingProps {\n  /** A value in ms that expresses how long the system should wait before beginning the animation */\n  delay?: number;\n  /** Indicates how long the easing should take to complete in ms */\n  duration: number;\n  /** The end value the easing should approach */\n  end: Vec;\n  /** A flag indicating if the easing start value is manually set, thus prioritizing the values already set in this object */\n  isManualStart?: boolean;\n  /** A flag indicating if the easing timing is manually set, thus prioritizing the values already set in this object */\n  isTimeSet?: boolean;\n  /** The starting value of the easing object */\n  start: Vec;\n  /** The start time in ms the easing object utilizes */\n  startTime: number;\n}\n\n/**\n * This is the Shader IO information a layer will provide.\n */\nexport interface IShaderInputs<T extends Instance> {\n  /** Specifies how the vertices are laid out in the model. This defaults to Triangle Strip if not specified */\n  drawMode?: GLSettings.Model.DrawMode;\n  /** These are very frequently changing attributes and are uniform across all vertices in the model */\n  instanceAttributes?: (IInstanceAttribute<T> | null)[];\n  /** These are attributes that should be static on a vertex. These are considered unique per vertex. */\n  vertexAttributes?: (IVertexAttribute | null)[];\n  /**\n   * Specify how many vertices there are per instance. If vertex count is 0, then the layer will render without\n   * instancing and draw the buffers straight.\n   */\n  vertexCount: number;\n  /** These are uniforms in the shader. These are uniform across all vertices and all instances for this layer. */\n  uniforms?: (IUniform | null)[];\n}\n\n/**\n * This is the initialization of the shader.\n */\nexport type IShaderInitialization<T extends Instance> = IShaderInputs<T> &\n  IShaders;\n\nexport interface IShaderExtension {\n  header?: string;\n  main?: {\n    pre?: string;\n    post?: string;\n  };\n}\n\nexport type IShaderIOExtension<T extends Instance> = Partial<\n  IShaderInputs<T>\n> & {\n  vs?: IShaderExtension;\n  fs?: IShaderExtension;\n};\n\n/**\n * A convenience for making short lists of items that are of the same type, such as the\n * common scenario of [boolean, boolean, boolean, boolean]\n */\nexport type TypeVec<T> = [T] | [T, T] | [T, T, T] | [T, T, T, T];\n\n/**\n * Depicts a two or three dimensional size:\n * [width, height, depth]\n */\nexport type Size = Vec2 | Vec3;\n\n/**\n * When creating a surface you must make it declare a pipeline. This makes a centralized easy\n * entry point for expressively declaring how the application will utilize resources to render\n * to various scenes and contexts.\n *\n * This is also used in a reactive diff manner so elements can be easily updated/added/removed\n * by providing all of the initializer elements. Thus to add an item call the method including\n * the element you wish to create. To remove an element, simply exclude the element next time\n * you call the method.\n */\nexport interface IPipeline {\n  /**\n   * These are the resources we want available that our layers can be provided to utilize\n   * for their internal processes.\n   */\n  resources?: BaseResourceOptions[];\n  /**\n   * This sets up the available scenes the surface will have to work with. Layers then can\n   * reference the scene by it's scene property. The order of the scenes here is the drawing\n   * order of the scenes.\n   */\n  scenes?: ISceneOptions[];\n}\n\n/**\n * Errors emitted by the surface\n */\nexport enum SurfaceErrorType {\n  /** Error is thrown when no web gl context can be established for the canvas */\n  NO_WEBGL_CONTEXT\n}\n\n/**\n * Errors emitted by the surface\n */\nexport type SurfaceError = {\n  error: SurfaceErrorType;\n  message: string;\n};\n\n/**\n * A numerical or string identifier. Use this type to make your intent a little clearer when you want a resource\n * identified.\n */\nexport type SimpleId = string | number;\n\n/**\n * An alias for a string. Use this type to make your intent a little clearer when you want a string specifically for\n * identifying a resource.\n */\nexport type StringId = string;\n\n/**\n * An alias for a number. Use this type to make your intent a little clearer when you want a number specifically for\n * identifying a resource.\n */\nexport type NumberId = number;\n\n/**\n * This is a massively useful type to express an object that can have numeric or sttring identifiers in recursive\n * amounts to define an object with many pathways to various items of the same type (that can be varied by generic)\n *\n * const o: Lookup<InstanceProvider<Instance>> = {\n *   circles: new InstanceProvider<CircleInstance>(),\n *   category: {\n *     special: new InstanceProvider<LabelInstance>(),\n *   }\n * }\n */\nexport type Lookup<T> = { [key: string]: T | Lookup<T> };\n\n/**\n * This expresses determined buffer types that already exists within the framework.\n */\nexport enum LayerBufferType {\n  /**\n   * This is a compatibility mode for instance attributes. This is used when:\n   * 1. It would perform better\n   * 2. When instance attributes are not available for the gl context (ANGLE draw instanced arrays)\n   * 3. When the instance attributes + vertex attributes exceeds the max Vertex Attributes for the hardware and Attribute\n   *    packing still can not fit all of the attributes for the item.\n   */\n  UNIFORM = 0,\n  /* This is a fast and zippy buffering strategy used when the hardware supports it for a provided layer!  */\n  INSTANCE_ATTRIBUTE = 1,\n  /**\n   * This is a slight degradation from the normal INSTANCE_ATTRIBUTE buffering strategy. If provided attributes do\n   * not fit the limited amount of vertex attributes supported by the hardware, then we have one last strategy\n   * to utilize the highly optimized hardware instancing, which is to cram multiple attributes within single\n   * attribute blocks. An attribute block is considered to be 4 32 bit floats. These packed attributes will then\n   * get dereferenced in the shader.\n   */\n  INSTANCE_ATTRIBUTE_PACKING = 2\n}\n\n/**\n * This is an entry within the change list of the provider. It represents the type of change\n * and stores the property id's of the properties on the instance that have changed.\n */\nexport type InstanceDiff<T extends Instance> = [\n  T,\n  InstanceDiffType,\n  { [key: number]: number }\n];\n\n/**\n * Bare minimum required features a provider must provide to be the data for the layer.\n */\nexport interface IInstanceProvider<T extends Instance> {\n  /**\n   * This indicates the context this provider was handled within. Currently, only one context is allowed per provider,\n   * so we use this to detect when multiple contexts have attempted use of this provider.\n   */\n  resolveContext: string;\n  /** A unique number making it easier to identify this object */\n  uid: number;\n  /** A list of changes to instances */\n  changeList: InstanceDiff<T>[];\n  /** Removes an instance from the list */\n  remove(instance: T): void;\n  /** Resolves the changes as consumed */\n  resolve(context: string): void;\n  /** Forces the provider to make a change list that ensures all elements are added */\n  sync(): void;\n}\n\n/**\n * This is the types of strategies available for streaming in changes to the GPU.\n */\nexport enum StreamChangeStrategy {\n  /** This takes the changes as they are discovered  */\n  LINEAR\n  // TODO: There currently isn't a good solution to make the randomized streaming happen without some serious\n  // performance concerns. Some strategies are in mind but aren't great. So we'll leave this commented out while\n  // strategies are considered.\n  // RANDOM\n}\n\n/**\n * This is a reference to pass into a layer which will provide insight into the layer's easing timing information so\n * there can be better control and better informed decisions on the rendering of elements that animate on the GPU.\n */\nexport interface ILayerEasingManager {\n  /**\n   * This is an async method that resolves when the current batch or stream has completed it's easing animation in full.\n   */\n  complete(): Promise<void>;\n}\n\n/**\n * This is a reference object that is populated with controllers and relevant exposed information regarding a layer.\n */\nexport interface ILayerRef {\n  /**\n   * The easing controller for the layer. This can be used to get precise timings for completion of easing animations\n   * and other easing metrics.\n   */\n  easing: ILayerEasingManager | null;\n}\n","export * from \"./camera\";\nexport * from \"./common-filters\";\nexport * from \"./common-operations\";\nexport * from \"./common-options\";\nexport * from \"./easing-util\";\nexport * from \"./extend-shader\";\nexport * from \"./frame\";\nexport * from \"./mouse\";\nexport * from \"./promise-resolver\";\nexport * from \"./quad-tree\";\nexport * from \"./reactive-diff\";\nexport * from \"./shader-templating\";\nexport * from \"./shallow-compare\";\nexport * from \"./uid\";\nexport * from \"./wait\";\nexport * from \"./create-util\";\nexport * from \"./wait-for-valid-dimensions\";\n","export * from \"./observable\";\nexport * from \"./instance-provider\";\nexport * from \"./instance\";\nexport * from \"./basic-instance\";\n","const { sqrt, max, min, floor, ceil, abs, acos, sin } = Math;\n\n/** Explicit Vec1 */\nexport interface IVec1 extends Array<number> {\n  0: number;\n  length: 1;\n}\n\n/** Explicit Vec2 */\nexport interface IVec2 extends Array<number> {\n  0: number;\n  1: number;\n  length: 2;\n}\n\n/** Explicit Vec3 */\nexport interface IVec3 extends Array<number> {\n  0: number;\n  1: number;\n  2: number;\n  length: 3;\n}\n\n/** Explicit Vec4 */\nexport interface IVec4 extends Array<number> {\n  0: number;\n  1: number;\n  2: number;\n  3: number;\n  length: 4;\n}\n\n/** Vector of 1 components */\nexport type Vec1 = [number];\n/** Vector of 2 components */\nexport type Vec2 = [number, number];\n/** Vector of 3 components */\nexport type Vec3 = [number, number, number];\n/** Vector of 4 components */\nexport type Vec4 = [number, number, number, number];\n\n/** Compatible types with Vec1 for operations (just not iterating) */\nexport type Vec1Compat = Vec1 | Vec2 | Vec3 | Vec4;\n/** Compatible types with Vec2 for operations (just not iterating) */\nexport type Vec2Compat = Vec2 | Vec3 | Vec4;\n/** Compatible types with Vec3 for operations (just not iterating) */\nexport type Vec3Compat = Vec3 | Vec4;\n/** Compatible types with Vec4 for operations (just not iterating) */\nexport type Vec4Compat = Vec4;\n\n/** This type defines any possible explicit vector */\nexport type IVec = IVec1 | IVec2 | IVec3 | IVec4;\n/** This type defines any possible vector */\nexport type Vec = Vec1 | Vec2 | Vec3 | Vec4;\n\n// Type guards for Vecs\n\nexport function isVec1(val: any): val is Vec1 {\n  return val && Array.isArray(val) && val.length === 1;\n}\n\nexport function isVec2(val: any): val is Vec2 {\n  return val && Array.isArray(val) && val.length === 2;\n}\n\nexport function isVec3(val: any): val is Vec3 {\n  return val && Array.isArray(val) && val.length === 3;\n}\n\nexport function isVec4(val: any): val is Vec4 {\n  return val && Array.isArray(val) && val.length === 4;\n}\n\n// Vec1 methods\n\nexport function apply1(v: Vec1Compat | undefined, v0: number): Vec1 {\n  v = v || (([] as any) as Vec1);\n  v[0] = v0;\n\n  return v as Vec1;\n}\n\nexport function add1(\n  left: Vec1Compat,\n  right: Vec1Compat,\n  out?: Vec1Compat\n): Vec1 {\n  return apply1(out, left[0] + right[0]);\n}\n\nexport function ceil1(vec: Vec1Compat, out?: Vec1Compat): Vec1 {\n  return apply1(out, ceil(vec[0]));\n}\n\nexport function compare1(left: Vec1Compat, right: Vec1Compat): boolean {\n  return left[0] === right[0];\n}\n\nexport function fuzzyCompare1(\n  left: Vec1Compat,\n  right: Vec1Compat,\n  epsilon: number\n): boolean {\n  return abs(left[0] - right[0]) <= epsilon;\n}\n\nexport function copy1(vec: Vec1Compat, out?: Vec1Compat): Vec1 {\n  return apply1(out, vec[0]);\n}\n\n/**\n * Cross product of 1 dimensional vectors could be easiest to visualize as two\n * parallel or anti-parallel vectors that are in the 2D plane. This would result in a vector that is of zero magnitude\n * going into the Z direction. Or essentially [0, 0, 0]. Thus for consistency of <vec method><vec component length>()\n * We will take the one dimension inference of this result and provide [0]\n */\nexport function cross1(\n  _left: Vec1Compat,\n  _right: Vec1Compat,\n  out?: Vec1Compat\n): Vec1 {\n  return apply1(out, 0);\n}\n\nexport function divide1(\n  top: Vec1Compat,\n  bottom: Vec1Compat,\n  out?: Vec1Compat\n): Vec1 {\n  return apply1(out, top[0] / bottom[0]);\n}\n\nexport function empty1(out?: Vec1) {\n  return apply1(out, 0);\n}\n\nexport function flatten1(list: Vec1Compat[], out?: number[]): number[] {\n  out = out || [];\n\n  for (let i = 0, iMax = list.length; i < iMax; ++i) {\n    out.push(list[i][0]);\n  }\n\n  return out;\n}\n\nexport function floor1(vec: Vec1Compat, out?: Vec1Compat): Vec1 {\n  return apply1(out, floor(vec[0]));\n}\n\nexport function inverse1(vec: Vec1Compat, out?: Vec1Compat): Vec1 {\n  return apply1(out, 1 / vec[0]);\n}\n\nexport function scale1(vec: Vec1Compat, scale: number, out?: Vec1Compat): Vec1 {\n  return apply1(out, vec[0] * scale);\n}\n\nexport function subtract1(\n  left: Vec1Compat,\n  right: Vec1Compat,\n  out?: Vec1Compat\n): Vec1 {\n  return apply1(out, left[0] - right[0]);\n}\n\nexport function max1(\n  left: Vec1Compat,\n  right: Vec1Compat,\n  out?: Vec1Compat\n): Vec1 {\n  return apply1(out, max(left[0], right[0]));\n}\n\nexport function min1(\n  left: Vec1Compat,\n  right: Vec1Compat,\n  out?: Vec1Compat\n): Vec1 {\n  return apply1(out, min(left[0], right[0]));\n}\n\nexport function multiply1(\n  left: Vec1Compat,\n  right: Vec1Compat,\n  out?: Vec1Compat\n): Vec1 {\n  return apply1(out, left[0] * right[0]);\n}\n\nexport function normalize1(_left: Vec1Compat, out?: Vec1Compat): Vec1 {\n  return apply1(out, 1);\n}\n\nexport function dot1(left: Vec1Compat, right: Vec1Compat): number {\n  return left[0] * right[0];\n}\n\nexport function linear1(\n  start: Vec1Compat,\n  end: Vec1Compat,\n  t: number,\n  out?: Vec1Compat\n): Vec1 {\n  return add1(scale1(subtract1(end, start), t), start, out);\n}\n\nexport function length1(start: Vec1Compat): number {\n  return sqrt(dot1(start, start));\n}\n\nexport function vec1(\n  values: number[] | number,\n  ...args: (number | number[])[]\n): Vec1 {\n  let out: number[];\n  args = args || [];\n\n  if (Array.isArray(values)) {\n    out = values.slice(0, 1) as Vec1;\n  } else {\n    out = [values];\n  }\n\n  if (out.length < 1) {\n    for (let i = 0, iMax = args.length; i < iMax && out.length < 1; ++i) {\n      const next = args[i];\n      if (Array.isArray(next)) {\n        out.push(...next.slice(0, 1 - out.length));\n      } else {\n        out.push(next);\n      }\n    }\n  }\n\n  while (out.length < 1) out.push(0);\n\n  return out as Vec1;\n}\n\n// Vec2 methods\n\nexport function apply2(\n  v: Vec2Compat | undefined,\n  v0: number,\n  v1: number\n): Vec2 {\n  v = v || (([] as any) as Vec2);\n  v[0] = v0;\n  v[1] = v1;\n\n  return v as Vec2;\n}\n\nexport function add2(\n  left: Vec2Compat,\n  right: Vec2Compat,\n  out?: Vec2Compat\n): Vec2 {\n  return apply2(out, left[0] + right[0], left[1] + right[1]);\n}\n\nexport function ceil2(vec: Vec2Compat, out?: Vec2Compat): Vec2 {\n  return apply2(out, ceil(vec[0]), ceil(vec[1]));\n}\n\nexport function copy2(vec: Vec2Compat, out?: Vec2Compat): Vec2 {\n  return apply2(out, vec[0], vec[1]);\n}\n\n/**\n * Cross product of a 2D vector would result in [0, 0, <magnitude>] within the 2D plane. In keeping with the format of\n * vector methods in this document <method name><vector component length>() we return only the 2D result of the product\n * [0, 0].\n * In order to get the results of the actual 2D vectors in a 3D world, you must use cross3() to retrieve the Z result.\n */\nexport function cross2(\n  _left: Vec2Compat,\n  _right: Vec2Compat,\n  out?: Vec2Compat\n): Vec2 {\n  return apply2(out, 0, 0);\n}\n\nexport function compare2(left: Vec2Compat, right: Vec2Compat): boolean {\n  return left[0] === right[0] && left[1] === right[1];\n}\n\nexport function fuzzyCompare2(\n  left: Vec2Compat,\n  right: Vec2Compat,\n  epsilon: number\n): boolean {\n  return (\n    abs(left[0] - right[0]) <= epsilon && abs(left[1] - right[1]) <= epsilon\n  );\n}\n\nexport function divide2(\n  top: Vec2Compat,\n  bottom: Vec2Compat,\n  out?: Vec2Compat\n): Vec2 {\n  return apply2(out, top[0] / bottom[0], top[1] / bottom[1]);\n}\n\nexport function empty2(out?: Vec2) {\n  return apply2(out, 0, 0);\n}\n\nexport function flatten2(list: Vec2Compat[], out?: number[]): number[] {\n  out = out || [];\n\n  for (let i = 0, iMax = list.length; i < iMax; ++i) {\n    const v = list[i];\n    out.push(v[0]);\n    out.push(v[1]);\n  }\n\n  return out;\n}\n\nexport function floor2(vec: Vec2Compat, out?: Vec2Compat): Vec2 {\n  return apply2(out, floor(vec[0]), floor(vec[1]));\n}\n\nexport function inverse2(vec: Vec2Compat, out?: Vec2Compat): Vec2 {\n  return apply2(out, 1 / vec[0], 1 / vec[1]);\n}\n\nexport function max2(\n  left: Vec2Compat,\n  right: Vec2Compat,\n  out?: Vec2Compat\n): Vec2 {\n  return apply2(out, max(left[0], right[0]), max(left[1], right[1]));\n}\n\nexport function min2(\n  left: Vec2Compat,\n  right: Vec2Compat,\n  out?: Vec2Compat\n): Vec2 {\n  return apply2(out, min(left[0], right[0]), min(left[1], right[1]));\n}\n\nexport function scale2(\n  left: Vec2Compat,\n  scale: number,\n  out?: Vec2Compat\n): Vec2 {\n  return apply2(out, left[0] * scale, left[1] * scale);\n}\n\nexport function subtract2(\n  left: Vec2Compat,\n  right: Vec2Compat,\n  out?: Vec2Compat\n): Vec2 {\n  return apply2(out, left[0] - right[0], left[1] - right[1]);\n}\n\nexport function multiply2(\n  left: Vec2Compat,\n  right: Vec2Compat,\n  out?: Vec2Compat\n): Vec2 {\n  return apply2(out, left[0] * right[0], left[1] * right[1]);\n}\n\nexport function normalize2(left: Vec2Compat, out?: Vec2Compat): Vec2 {\n  const length = length2(left);\n  return apply2(out, left[0] / length, left[1] / length);\n}\n\nexport function dot2(left: Vec2Compat, right: Vec2Compat): number {\n  return left[0] * right[0] + left[1] * right[1];\n}\n\nexport function linear2(\n  start: Vec2Compat,\n  end: Vec2Compat,\n  t: number,\n  out?: Vec2Compat\n): Vec2 {\n  return add2(scale2(subtract2(end, start), t), start, out);\n}\n\nexport function length2(start: Vec2Compat): number {\n  return sqrt(dot2(start, start));\n}\n\nexport function vec2(\n  values: number[] | number,\n  ...args: (number | number[])[]\n): Vec2 {\n  let out: number[];\n  args = args || [];\n\n  if (Array.isArray(values)) {\n    out = values.slice(0, 2) as Vec2;\n  } else {\n    out = [values];\n  }\n\n  if (out.length < 2) {\n    for (let i = 0, iMax = args.length; i < iMax && out.length < 2; ++i) {\n      const next = args[i];\n      if (Array.isArray(next)) {\n        out.push(...next.slice(0, 2 - out.length));\n      } else {\n        out.push(next);\n      }\n    }\n  }\n\n  while (out.length < 2) out.push(0);\n\n  return out as Vec2;\n}\n\n// Vec3 methods\n\nexport function apply3(\n  v: Vec3Compat | undefined,\n  v0: number,\n  v1: number,\n  v2: number\n): Vec3 {\n  v = v || (([] as any) as Vec3);\n  v[0] = v0;\n  v[1] = v1;\n  v[2] = v2;\n\n  return v as Vec3;\n}\n\nexport function add3(\n  left: Vec3Compat,\n  right: Vec3Compat,\n  out?: Vec3Compat\n): Vec3 {\n  return apply3(\n    out,\n    left[0] + right[0],\n    left[1] + right[1],\n    left[2] + right[2]\n  );\n}\n\nexport function ceil3(vec: Vec3Compat, out?: Vec3Compat): Vec3 {\n  return apply3(out, ceil(vec[0]), ceil(vec[1]), ceil(vec[2]));\n}\n\nexport function copy3(vec: Vec3Compat, out?: Vec3Compat): Vec3 {\n  return apply3(out, vec[0], vec[1], vec[2]);\n}\n\nexport function compare3(left: Vec3Compat, right: Vec3Compat): boolean {\n  return left[0] === right[0] && left[1] === right[1] && left[2] === right[2];\n}\n\nexport function fuzzyCompare3(\n  left: Vec3Compat,\n  right: Vec3Compat,\n  epsilon: number\n): boolean {\n  return (\n    abs(left[0] - right[0]) <= epsilon &&\n    abs(left[1] - right[1]) <= epsilon &&\n    abs(left[2] - right[2]) <= epsilon\n  );\n}\n\nexport function cross3(\n  left: Vec3Compat,\n  right: Vec3Compat,\n  out?: Vec3Compat\n): Vec3 {\n  return apply3(\n    out,\n    left[1] * right[2] - left[2] * right[1],\n    left[2] * right[0] - left[0] * right[2],\n    left[0] * right[1] - left[1] * right[0]\n  );\n}\n\nexport function divide3(\n  top: Vec3Compat,\n  bottom: Vec3Compat,\n  out?: Vec3Compat\n): Vec3 {\n  return apply3(\n    out,\n    top[0] / bottom[0],\n    top[1] / bottom[1],\n    top[2] / bottom[2]\n  );\n}\n\nexport function empty3(out?: Vec3) {\n  return apply3(out, 0, 0, 0);\n}\n\nexport function flatten3(list: Vec3Compat[], out?: number[]): number[] {\n  out = out || [];\n\n  for (let i = 0, iMax = list.length; i < iMax; ++i) {\n    const v = list[i];\n    out.push(v[0]);\n    out.push(v[1]);\n    out.push(v[2]);\n  }\n\n  return out;\n}\n\nexport function floor3(vec: Vec3Compat, out?: Vec3Compat): Vec3 {\n  return apply3(out, floor(vec[0]), floor(vec[1]), floor(vec[2]));\n}\n\nexport function inverse3(vec: Vec3Compat, out?: Vec3Compat): Vec3 {\n  return apply3(out, 1 / vec[0], 1 / vec[1], 1 / vec[2]);\n}\n\nexport function scale3(\n  left: Vec3Compat,\n  scale: number,\n  out?: Vec3Compat\n): Vec3 {\n  return apply3(out, left[0] * scale, left[1] * scale, left[2] * scale);\n}\n\nexport function subtract3(\n  left: Vec3Compat,\n  right: Vec3Compat,\n  out?: Vec3Compat\n): Vec3 {\n  return apply3(\n    out,\n    left[0] - right[0],\n    left[1] - right[1],\n    left[2] - right[2]\n  );\n}\n\nexport function multiply3(\n  left: Vec3Compat,\n  right: Vec3Compat,\n  out?: Vec3Compat\n): Vec3 {\n  return apply3(\n    out,\n    left[0] * right[0],\n    left[1] * right[1],\n    left[2] * right[2]\n  );\n}\n\nexport function linear3(\n  start: Vec3Compat,\n  end: Vec3Compat,\n  t: number,\n  out?: Vec3Compat\n): Vec3 {\n  return add3(scale3(subtract3(end, start), t), start, out);\n}\n\nexport function length3(start: Vec3Compat): number {\n  return sqrt(dot3(start, start));\n}\n\nexport function max3(\n  left: Vec3Compat,\n  right: Vec3Compat,\n  out?: Vec3Compat\n): Vec3 {\n  return apply3(\n    out,\n    max(left[0], right[0]),\n    max(left[1], right[1]),\n    max(left[2], right[2])\n  );\n}\n\nexport function min3(\n  left: Vec3Compat,\n  right: Vec3Compat,\n  out?: Vec3Compat\n): Vec3 {\n  return apply3(\n    out,\n    min(left[0], right[0]),\n    min(left[1], right[1]),\n    min(left[2], right[2])\n  );\n}\n\nexport function normalize3(left: Vec3Compat, out?: Vec3Compat): Vec3 {\n  const length = length3(left);\n  return apply3(out, left[0] / length, left[1] / length, left[2] / length);\n}\n\nexport function dot3(left: Vec3Compat, right: Vec3Compat): number {\n  return left[0] * right[0] + left[1] * right[1] + left[2] * right[2];\n}\n\nexport function vec3(\n  values: number[] | number,\n  ...args: (number | number[])[]\n): Vec3 {\n  let out: number[];\n  args = args || [];\n\n  if (Array.isArray(values)) {\n    out = values.slice(0, 3) as Vec3;\n  } else {\n    out = [values];\n  }\n\n  if (out.length < 3) {\n    for (let i = 0, iMax = args.length; i < iMax && out.length < 3; ++i) {\n      const next = args[i];\n      if (Array.isArray(next)) {\n        out.push(...next.slice(0, 3 - out.length));\n      } else {\n        out.push(next);\n      }\n    }\n  }\n\n  while (out.length < 3) out.push(0);\n\n  return out as Vec3;\n}\n\n/**\n * Produces a directional vector that is straight up from the provided reference vectors (90 degress elevated from\n * the forward vector)\n */\nexport function up3(forward: Vec3Compat, up: Vec3Compat, out?: Vec3Compat) {\n  out = out || [0, 0, 0];\n  return normalize3(cross3(cross3(forward, up, out), forward, out), out);\n}\n\n/**\n * Produces a directional vector that is directly to the right of the reference vectors (90 degress rotated from the\n * forrward vector)\n */\nexport function right3(forward: Vec3Compat, up: Vec3Compat, out?: Vec3Compat) {\n  out = out || [0, 0, 0];\n  return normalize3(cross3(forward, up, out), out);\n}\n\n/**\n * Produces a directional vector that is directly to the left of the reference vectors (90 degress rotated from the\n * forrward vector)\n */\nexport function left3(forward: Vec3Compat, up: Vec3Compat, out?: Vec3Compat) {\n  out = out || [0, 0, 0];\n  return normalize3(cross3(up, forward, out), out);\n}\n\n/**\n * Produces a directional vector that is straight down from the provided reference vectors (90 degress declined from\n * the forward vector)\n */\nexport function down3(forward: Vec3Compat, up: Vec3Compat, out?: Vec3Compat) {\n  out = out || [0, 0, 0];\n  return normalize3(cross3(forward, cross3(forward, up, out), out), out);\n}\n\n// Vec4 methods\n\nexport function apply4(\n  v: Vec4Compat | undefined,\n  v0: number,\n  v1: number,\n  v2: number,\n  v3: number\n): Vec4 {\n  v = v || (([] as any) as Vec4);\n  v[0] = v0;\n  v[1] = v1;\n  v[2] = v2;\n  v[3] = v3;\n\n  return v as Vec4;\n}\n\nexport function add4(left: Vec4, right: Vec4, out?: Vec4Compat): Vec4 {\n  return apply4(\n    out,\n    left[0] + right[0],\n    left[1] + right[1],\n    left[2] + right[2],\n    left[3] + right[3]\n  );\n}\n\nexport function add4by3(left: Vec4, right: Vec3Compat, out?: Vec4Compat): Vec4 {\n  return apply4(\n    out,\n    left[0] + right[0],\n    left[1] + right[1],\n    left[2] + right[2],\n    left[3]\n  );\n}\n\nexport function ceil4(vec: Vec4Compat, out?: Vec4Compat): Vec4 {\n  return apply4(out, ceil(vec[0]), ceil(vec[1]), ceil(vec[2]), ceil(vec[3]));\n}\n\nexport function copy4(vec: Vec4, out?: Vec4Compat): Vec4 {\n  return apply4(out, vec[0], vec[1], vec[2], vec[3]);\n}\n\nexport function compare4(left: Vec4Compat, right: Vec4Compat): boolean {\n  return (\n    left[0] === right[0] &&\n    left[1] === right[1] &&\n    left[2] === right[2] &&\n    left[3] === right[3]\n  );\n}\n\nexport function fuzzyCompare4(\n  left: Vec4Compat,\n  right: Vec4Compat,\n  epsilon: number\n): boolean {\n  return (\n    abs(left[0] - right[0]) <= epsilon &&\n    abs(left[1] - right[1]) <= epsilon &&\n    abs(left[2] - right[2]) <= epsilon &&\n    abs(left[3] - right[3]) <= epsilon\n  );\n}\n\n/**\n * 4D cross product? Lots of issues here. If you need a proper cross product for 3D, please use cross3. What\n * this method should do is up for debate for now and will return a unit 4D vector.\n */\nexport function cross4(_left: Vec4, _right: Vec4, out?: Vec4Compat): Vec4 {\n  return apply4(out, 0, 0, 0, 1);\n}\n\nexport function divide4(\n  top: Vec4Compat,\n  bottom: Vec4Compat,\n  out?: Vec4Compat\n): Vec4 {\n  return apply4(\n    out,\n    top[0] / bottom[0],\n    top[1] / bottom[1],\n    top[2] / bottom[2],\n    top[3] / bottom[3]\n  );\n}\n\nexport function empty4(out?: Vec4) {\n  return apply4(out, 0, 0, 0, 0);\n}\n\nexport function flatten4(list: Vec4Compat[], out?: number[]): number[] {\n  out = out || [];\n\n  for (let i = 0, iMax = list.length; i < iMax; ++i) {\n    const v = list[i];\n    out.push(v[0]);\n    out.push(v[1]);\n    out.push(v[2]);\n    out.push(v[3]);\n  }\n\n  return out;\n}\n\nexport function floor4(vec: Vec4Compat, out?: Vec4Compat): Vec4 {\n  return apply4(\n    out,\n    floor(vec[0]),\n    floor(vec[1]),\n    floor(vec[2]),\n    floor(vec[3])\n  );\n}\n\nexport function inverse4(vec: Vec4, out?: Vec4Compat): Vec4 {\n  return apply4(out, 1 / vec[0], 1 / vec[1], 1 / vec[2], 1 / vec[3]);\n}\n\nexport function scale4(left: Vec4, scale: number, out?: Vec4Compat): Vec4 {\n  return apply4(\n    out,\n    left[0] * scale,\n    left[1] * scale,\n    left[2] * scale,\n    left[3] * scale\n  );\n}\n\nexport function subtract4(left: Vec4, right: Vec4, out?: Vec4Compat): Vec4 {\n  return apply4(\n    out,\n    left[0] - right[0],\n    left[1] - right[1],\n    left[2] - right[2],\n    left[3] - right[3]\n  );\n}\n\nexport function multiply4(left: Vec4, right: Vec4, out?: Vec4Compat): Vec4 {\n  return apply4(\n    out,\n    left[0] * right[0],\n    left[1] * right[1],\n    left[2] * right[2],\n    left[3] * right[3]\n  );\n}\n\nexport function dot4(left: Vec4, right: Vec4): number {\n  return (\n    left[0] * right[0] +\n    left[1] * right[1] +\n    left[2] * right[2] +\n    left[3] * right[3]\n  );\n}\n\nexport function linear4(\n  start: Vec4,\n  end: Vec4,\n  t: number,\n  out?: Vec4Compat\n): Vec4 {\n  return add4(scale4(subtract4(end, start), t), start, out);\n}\n\nexport function length4(start: Vec4): number {\n  return sqrt(dot4(start, start));\n}\n\nexport function max4(\n  left: Vec4Compat,\n  right: Vec4Compat,\n  out?: Vec4Compat\n): Vec4 {\n  return apply4(\n    out,\n    max(left[0], right[0]),\n    max(left[1], right[1]),\n    max(left[2], right[2]),\n    max(left[3], right[3])\n  );\n}\n\nexport function min4(\n  left: Vec4Compat,\n  right: Vec4Compat,\n  out?: Vec4Compat\n): Vec4 {\n  return apply4(\n    out,\n    min(left[0], right[0]),\n    min(left[1], right[1]),\n    min(left[2], right[2]),\n    min(left[3], right[3])\n  );\n}\n\nexport function normalize4(left: Vec4Compat, out?: Vec4Compat): Vec4 {\n  const length = length4(left);\n  return apply4(\n    out,\n    left[0] / length,\n    left[1] / length,\n    left[2] / length,\n    left[3] / length\n  );\n}\n\nexport function vec4(\n  values: number[] | number,\n  ...args: (number | number[])[]\n): Vec4 {\n  let out: number[];\n  args = args || [];\n\n  if (Array.isArray(values)) {\n    out = values.slice(0, 4) as Vec4;\n  } else {\n    out = [values];\n  }\n\n  if (out.length < 4) {\n    for (let i = 0, iMax = args.length; i < iMax && out.length < 4; ++i) {\n      const next = args[i];\n      if (Array.isArray(next)) {\n        out.push(...next.slice(0, 4 - out.length));\n      } else {\n        out.push(next);\n      }\n    }\n  }\n\n  while (out.length < 4) out.push(0);\n\n  return out as Vec4;\n}\n\nexport function color4FromHex3(hex: number, out?: Vec4) {\n  out = out || [0, 0, 0, 0];\n\n  return apply4(\n    out,\n    ((hex & 0xff0000) >> 16) / 255,\n    ((hex & 0xff00) >> 8) / 255,\n    (hex & 0xff) / 255,\n    1\n  );\n}\n\nexport function color4FromHex4(hex: number, out?: Vec4) {\n  out = out || [0, 0, 0, 0];\n\n  return apply4(\n    out,\n    ((hex & 0xff000000) >> 24) / 255,\n    ((hex & 0xff0000) >> 16) / 255,\n    ((hex & 0xff00) >> 8) / 255,\n    (hex & 0xff) / 255\n  );\n}\n\nexport function slerpQuat(from: Vec4, to: Vec4, t: number, out?: Vec4): Vec4 {\n  out = out || [0, 0, 0, 0];\n  const to1: Vec4 = [0, 0, 0, 0];\n  let omega, cosom, sinom, scale0, scale1;\n  cosom = from[1] * to[1] + from[2] * to[2] + from[3] * to[3] + from[0] * to[0];\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    to1[0] = -to[1];\n    to1[1] = -to[2];\n    to1[2] = -to[3];\n    to1[3] = -to[0];\n  } else {\n    to1[0] = to[1];\n    to1[1] = to[2];\n    to1[2] = to[3];\n    to1[3] = to[0];\n  }\n\n  // Calculate coefficients for final values. We use SLERP if the difference between the two angles isn't too big.\n  if (1.0 - cosom > 0.0000001) {\n    omega = acos(cosom);\n    sinom = sin(omega);\n    scale0 = sin((1.0 - t) * omega) / sinom;\n    scale1 = sin(t * omega) / sinom;\n  }\n\n  // We linear interpolate for quaternions that are very close together in angle.\n  else {\n    scale0 = 1.0 - t;\n    scale1 = t;\n  }\n\n  // calculate final values\n  out[1] = scale0 * from[1] + scale1 * to1[0];\n  out[2] = scale0 * from[2] + scale1 * to1[1];\n  out[3] = scale0 * from[3] + scale1 * to1[2];\n  out[0] = scale0 * from[0] + scale1 * to1[3];\n\n  return out;\n}\n\n// Vec method aggregations\n\nexport type VecMethods<T extends Vec> = {\n  add(left: T, right: T, out?: T): T;\n  ceil(vec: T, out?: T): T;\n  copy(vec: T, out?: T): T;\n  compare(left: T, right: T): boolean;\n  cross(left: T, right: T, out?: T): T;\n  divide(top: T, bottom: T, out?: T): T;\n  dot(left: T, right: T): number;\n  empty(out?: T): T;\n  flatten(list: T[], out?: number[]): number[];\n  floor(vec: T, out?: T): T;\n  inverse(vec: T, out?: T): T;\n  length(vec: T): number;\n  linear(start: T, end: T, t: number, out?: T): T;\n  max(left: T, right: T, out?: T): T;\n  min(left: T, right: T, out?: T): T;\n  multiply(left: T, right: T, out?: T): T;\n  normalize(vec: T, out?: T): T;\n  scale(vec: T, scale: number, out?: T): T;\n  subtract(left: T, right: T, out?: T): T;\n  vec(values: number[] | number, ...args: (number | number[])[]): T;\n  slerpQuat?(start: T, end: T, t: number, out?: T): T;\n};\n\nexport const vec1Methods: VecMethods<Vec1> = {\n  add: add1,\n  ceil: ceil1,\n  copy: copy1,\n  compare: compare1,\n  cross: cross1,\n  divide: divide1,\n  dot: dot1,\n  empty: empty1,\n  flatten: flatten1,\n  floor: floor1,\n  inverse: inverse1,\n  length: length1,\n  linear: linear1,\n  max: max1,\n  min: min1,\n  multiply: multiply1,\n  normalize: normalize1,\n  scale: scale1,\n  subtract: subtract1,\n  vec: vec1\n};\n\nexport const vec2Methods: VecMethods<Vec2> = {\n  add: add2,\n  ceil: ceil2,\n  copy: copy2,\n  compare: compare2,\n  cross: cross2,\n  divide: divide2,\n  dot: dot2,\n  empty: empty2,\n  flatten: flatten2,\n  floor: floor2,\n  inverse: inverse2,\n  length: length2,\n  linear: linear2,\n  max: max2,\n  min: min2,\n  multiply: multiply2,\n  normalize: normalize2,\n  scale: scale2,\n  subtract: subtract2,\n  vec: vec2\n};\n\nexport const vec3Methods: VecMethods<Vec3> = {\n  add: add3,\n  ceil: ceil3,\n  copy: copy3,\n  compare: compare3,\n  cross: cross3,\n  divide: divide3,\n  dot: dot3,\n  empty: empty3,\n  flatten: flatten3,\n  floor: floor3,\n  inverse: inverse3,\n  length: length3,\n  linear: linear3,\n  max: max3,\n  min: min3,\n  multiply: multiply3,\n  normalize: normalize3,\n  scale: scale3,\n  subtract: subtract3,\n  vec: vec3\n};\n\nexport const vec4Methods: VecMethods<Vec4> = {\n  add: add4,\n  ceil: ceil4,\n  copy: copy4,\n  compare: compare4,\n  cross: cross4,\n  divide: divide4,\n  dot: dot4,\n  empty: empty4,\n  flatten: flatten4,\n  floor: floor4,\n  inverse: inverse4,\n  length: length4,\n  linear: linear4,\n  max: max4,\n  min: min4,\n  multiply: multiply4,\n  normalize: normalize4,\n  scale: scale4,\n  subtract: subtract4,\n  vec: vec4,\n  slerpQuat: slerpQuat\n};\n\nexport function VecMath<T extends IVec>(vec: T): VecMethods<T> {\n  let methods: VecMethods<T>;\n\n  if (vec.length === 1) {\n    methods = vec1Methods as VecMethods<T>;\n    return methods;\n  } else if (vec.length === 2) {\n    methods = vec2Methods as VecMethods<T>;\n    return methods;\n  } else if (vec.length === 3) {\n    methods = vec3Methods as VecMethods<T>;\n    return methods;\n  }\n\n  methods = vec4Methods as VecMethods<T>;\n\n  return methods;\n}\n\nexport function toString1(v: Vec1Compat): string {\n  return `[${v[0]}]`;\n}\n\nexport function toString2(v: Vec2Compat): string {\n  return `[${v[0]}, ${v[1]}]`;\n}\n\nexport function toString3(v: Vec3Compat): string {\n  return `[${v[0]}, ${v[1]}, ${v[2]}]`;\n}\n\nexport function toString4(v: Vec4Compat): string {\n  return `[${v[0]}, ${v[1]}, ${v[2]}, ${v[3]}]`;\n}\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","import { Instance } from \"../../instance-provider\";\nimport { ILayerProps, Layer } from \"../../surface\";\nimport { IShaderInitialization } from \"../../types\";\n\nexport interface ILayer2DProps<TInstance extends Instance>\n  extends ILayerProps<TInstance> {}\n\n/**\n * Base layer for the 2D world layering system. This essentially just requires the Camera2D to be an available\n * property of the Layer2D as well as provide the 2D projection methods to the layers.\n */\nexport class Layer2D<\n  TInstance extends Instance,\n  UProps extends ILayer2DProps<TInstance>\n> extends Layer<TInstance, UProps> {\n  /**\n   * Force the world2D methods as the base methods\n   */\n  baseShaderModules(shaderIO: IShaderInitialization<TInstance>) {\n    const modules = super.baseShaderModules(shaderIO);\n    modules.vs.push(\"world2D\");\n\n    return modules;\n  }\n}\n","export * from \"./attribute\";\nexport * from \"./geometry\";\nexport * from \"./gl-decode\";\nexport * from \"./gl-proxy\";\nexport * from \"./gl-settings\";\nexport * from \"./gl-state\";\nexport * from \"./material\";\nexport * from \"./model\";\nexport * from \"./render-target\";\nexport * from \"./scene\";\nexport * from \"./texture\";\nexport * from \"./types\";\nexport * from \"./webgl-renderer\";\nexport * from \"./webgl-stat\";\n","import { Vec2 } from \"../vector\";\n\nconst { min, max } = Math;\n\nexport interface IBoundsOptions {\n  /** Top left x position */\n  x?: number;\n  /** Top left y position */\n  y?: number;\n  /** Width covered */\n  width?: number;\n  /** height covered */\n  height?: number;\n\n  /** Specify the left */\n  left?: number;\n  /** Specify the right */\n  right?: number;\n  /** Specify the top */\n  top?: number;\n  /** Specify the bottom */\n  bottom?: number;\n}\n\n/**\n * Class to manage the x, y, width, and height of an object\n *\n * @template T This specifies the data type associated with this shape and is accessible\n *             via the property 'd'\n */\nexport class Bounds<T> {\n  x: number = 0;\n  y: number = 0;\n  width: number = 0;\n  height: number = 0;\n  d?: T;\n\n  get area() {\n    return this.width * this.height;\n  }\n\n  get bottom() {\n    return this.y + this.height;\n  }\n\n  get left() {\n    return this.x;\n  }\n\n  get mid(): Vec2 {\n    return [this.x + this.width / 2.0, this.y + this.height / 2.0];\n  }\n\n  get right() {\n    return this.x + this.width;\n  }\n\n  get top() {\n    return this.y;\n  }\n\n  static emptyBounds<T>() {\n    return new Bounds<T>({\n      height: 0,\n      width: 0,\n      x: 0,\n      y: 0\n    });\n  }\n\n  /**\n   * Create a new instance\n   *\n   * @param left  The left side (x coordinate) of the instance\n   * @param right The right side of the instance\n   * @param top The top (y coordinate) of the instance\n   * @param bottom The bottom of the instance\n   */\n  constructor(options: IBoundsOptions) {\n    this.x = options.x || options.left || 0;\n    this.y = options.y || options.top || 0;\n    this.height = options.height || (options.bottom || 0) - this.y || 0;\n    this.width = options.width || (options.right || 0) - this.x || 0;\n  }\n\n  /**\n   * Checks to see if a point is within this bounds object.\n   *\n   * @param point\n   */\n  containsPoint(point: Vec2) {\n    return !(\n      point[0] < this.x ||\n      point[1] < this.y ||\n      point[0] > this.right ||\n      point[1] > this.bottom\n    );\n  }\n\n  /**\n   * Grows this bounds object to cover the space of the provided bounds object\n   *\n   * @param item\n   */\n  encapsulate(item: Bounds<any> | Vec2) {\n    if (item instanceof Bounds) {\n      if (item.x < this.x) {\n        this.width += Math.abs(item.x - this.x);\n        this.x = item.x;\n      }\n\n      if (item.y < this.y) {\n        this.height += Math.abs(item.y - this.y);\n        this.y = item.y;\n      }\n\n      if (this.right < item.right) {\n        this.width += item.right - this.right;\n      }\n\n      if (this.bottom < item.bottom) {\n        this.height += item.bottom - this.bottom;\n      }\n\n      return true;\n    } else {\n      if (item[0] < this.x) {\n        this.width += this.x - item[0];\n        this.x = item[0];\n      }\n\n      if (item[0] > this.right) {\n        this.width += item[0] - this.x;\n      }\n\n      if (item[1] < this.y) {\n        this.height += this.y - item[1];\n        this.y = item[1];\n      }\n\n      if (item[1] > this.bottom) {\n        this.height += item[1] - this.y;\n      }\n\n      return true;\n    }\n  }\n\n  /**\n   * Grows the bounds (if needed) to encompass all bounds or points provided. This\n   * performs much better than running encapsulate one by one.\n   */\n  encapsulateAll(all: Bounds<any>[] | Vec2[]) {\n    // Nothing provided, nothing to do\n    if (all.length <= 0) return;\n    // Stores max boundaries found\n    let minX = Number.MAX_SAFE_INTEGER,\n      maxX = Number.MIN_SAFE_INTEGER,\n      minY = Number.MAX_SAFE_INTEGER,\n      maxY = Number.MIN_SAFE_INTEGER;\n\n    // Handle list of bounds\n    if (all[0] instanceof Bounds) {\n      const boundsList = all as Bounds<T>[];\n\n      for (let i = 0, iMax = boundsList.length; i < iMax; ++i) {\n        const bounds = boundsList[i];\n        minX = min(minX, bounds.left);\n        maxX = max(maxX, bounds.right);\n        minY = min(minY, bounds.top);\n        maxY = max(maxY, bounds.bottom);\n      }\n    }\n\n    // Handle list of points\n    else {\n      const pointsList = all as Vec2[];\n\n      for (let i = 0, iMax = pointsList.length; i < iMax; ++i) {\n        const [x, y] = pointsList[i];\n        minX = min(minX, x);\n        maxX = max(maxX, x);\n        minY = min(minY, y);\n        maxY = max(maxY, y);\n      }\n    }\n\n    this.x = Math.min(this.x, minX);\n    this.y = Math.min(this.y, minY);\n    this.width = Math.max(this.width, maxX - minX);\n    this.height = Math.max(this.height, maxY - minY);\n  }\n\n  /**\n   * Checks to see if the provided bounds object could fit within the dimensions of this bounds object\n   * This ignores position and just checks width and height.\n   *\n   * @param bounds\n   *\n   * @return {number} 0 if it doesn't fit. 1 if it fits perfectly. 2 if it just fits.\n   */\n  fits(bounds: Bounds<T>): 0 | 1 | 2 {\n    // If the same, the bounds fits exactly into this bounds\n    if (this.width === bounds.width && this.height === bounds.height) {\n      return 1;\n    }\n\n    // The bounds can fit within this, then it just fits\n    if (this.width >= bounds.width && this.height >= bounds.height) {\n      return 2;\n    }\n\n    // Otherwise, the bounds does not fit within this bounds\n    return 0;\n  }\n\n  /**\n   * Checks if a bounds object intersects another bounds object.\n   *\n   * @param bounds\n   */\n  hitBounds(bounds: Bounds<any>) {\n    return !(\n      this.right < bounds.x ||\n      this.x > bounds.right ||\n      this.bottom < bounds.y ||\n      this.y > bounds.bottom\n    );\n  }\n\n  /**\n   * Sees if the provided bounds is completely within this bounds object. Unlike fits() this takes\n   * position into account.\n   *\n   * @param bounds\n   */\n  isInside(bounds: Bounds<any>): boolean {\n    return (\n      this.x >= bounds.x &&\n      this.right <= bounds.right &&\n      this.y >= bounds.y &&\n      this.bottom <= bounds.bottom\n    );\n  }\n\n  /**\n   * Top left position of the bounds\n   */\n  get location(): Vec2 {\n    return [this.x, this.y];\n  }\n\n  /**\n   * Easy readout of this Bounds object.\n   */\n  toString() {\n    return `{x: ${this.x} y:${this.y} w:${this.width} h:${this.height}}`;\n  }\n}\n","export * from \"./base-shader-io-injection\";\nexport * from \"./shader-module-unit\";\nexport * from \"./shader-module\";\n","import { IdentifiableById, IEasingControl, IEasingProps } from \"../types\";\nimport { EasingProps } from \"../util/easing-props\";\nimport { InstanceProvider } from \"./instance-provider\";\nimport { observable } from \"./observable\";\n\nlet instanceUID = 0;\n\nexport interface IInstanceOptions {\n  /** The instance can be declared with an initial active state */\n  active?: boolean;\n  /** An instance must be declared with an identifier */\n  id?: string;\n}\n\nexport class Instance implements IdentifiableById {\n  static get newUID() {\n    return (instanceUID = ++instanceUID % 0xffffff);\n  }\n\n  /** This indicates when the instance is active / rendering */\n  get active() {\n    return this._active;\n  }\n  set active(val: boolean) {\n    this._active = val;\n    this.reactivate = true;\n  }\n  @observable _active: boolean;\n  /** The property changes on the instance */\n  changes: { [key: number]: number } = {};\n  /**\n   * This is a lookup that provides a means to retrieve the id of an easing type currently available to the instance.\n   * This is populated when the instance becomes a part of a layer with easing attributes.\n   *\n   * This property is to NOT be mutated except by the system.\n   */\n  easingId: { [key: string]: number } | undefined;\n  /** This is an internal easing object to track properties for automated easing */\n  easing?: Map<number, IEasingProps>;\n  /** Internal, non-changeable id */\n  private _id: string;\n  /** This is the observer of the Instance's observable properties */\n  private _observer: InstanceProvider<this> | null;\n  /** This is where observables store their data for the instance */\n  observableStorage: any[] = [];\n  /** A numerical look up for the instance. Numerical identifiers run faster than objects or strings */\n  @observable private _uid = Instance.newUID;\n  /** This is the flag indicating this instance was reactivated. When true, this performs a full update of all properties on the instance */\n  reactivate: boolean = false;\n\n  /**\n   * Retrieves a method for disposing the link between observables and observer.\n   */\n  get observableDisposer(): () => void {\n    return () => delete this._observer;\n  }\n\n  /**\n   * Retrieves the observer of the observables.\n   */\n  get observer(): InstanceProvider<this> | null {\n    return this._observer || null;\n  }\n\n  /**\n   * Applies an observer for changes to the observables.\n   */\n  set observer(val: InstanceProvider<this> | null) {\n    // If an observer already is present, we should inform it, that it is being removed\n    // in favor of a new observer\n    const oldObserver = this._observer;\n\n    // If we're switching observers, then we have to dump out assumptions made within other observers\n    if (oldObserver && oldObserver !== val) {\n      if (this.easing) this.easing.clear();\n      oldObserver.remove(this);\n    }\n\n    // Apply the new observer as the current observer\n    this._observer = val;\n  }\n\n  /**\n   * This attempts to get the easing object for this instance for a given attribute that it MIGHT be associated with.\n   *\n   * When an instance is added to a layer and the layer has attributes with easing applied to them, the instance gains easing values\n   * for the attributes in the layer with applied easing.\n   *\n   * You can access the easing values by requesting the attribute's \"name\" property value using this method.\n   *\n   * There is NO WAY TO GUARANTEE this value is set or available, so this method WILL return undefined if you did\n   * not use the correct name, or no such value exists, or the layer decided to not make the attribute animateable.\n   *\n   * Thus ALWAYS check the returned value to ensure it is defined before attempting to use it's results.\n   *\n   * PERFORMANCE: You can probably get much better performance NOT using this to manipulate the easing object directly.\n   * The system is designed to automatically animate an item from it's current rendered location to the next location\n   * seamlessly thus accounting for most situations. This method is provided to commit much more complex start, duration,\n   * and delay animations within a given frame to prevent the need for complicated setTimeout patterns.\n   *\n   * This CAN be faster than the default behavior if it avoids causing complicated easing computations to determine where\n   * the rendering should be at the moment (complicated cpu methods within the IAutoEasingMethod used).\n   */\n  getEasing(attributeName: string): IEasingControl | undefined {\n    if (this.easingId) {\n      // If easing has been applied to an attribute, the attribute that will have it is the name mangled\n      // _{base name}_end format.\n      const easingId = this.easingId[`_${attributeName}_end`];\n\n      if (easingId && this.easing) {\n        const easing = this.easing.get(easingId);\n\n        if (easing instanceof EasingProps) {\n          return easing;\n        }\n      }\n    }\n\n    return;\n  }\n\n  /**\n   * Get the applied id of this instance\n   */\n  get id() {\n    return this._id;\n  }\n\n  /**\n   * Get the auto generated ID of this instance\n   */\n  get uid() {\n    return this._uid;\n  }\n\n  /**\n   * This method is utilized internally to indicate when requested resources are ready.\n   * If you have a property that will be requesting a resource, you should implement this method\n   * to cause a trigger for the property to activate such that the property will update it's buffer.\n   */\n  resourceTrigger() {\n    // No default behavior, subclasses must override and provide behavior.\n    console.warn(\n      \"resourceTrigger called on an instance that did not override resourceTrigger. resourceTrigger MUST be overridden for instances\",\n      \"that utilize a resource. The observable that is tied to committing the resource should be 'triggered' in this method.\"\n    );\n  }\n\n  constructor(options: IInstanceOptions) {\n    this._id = options.id || \"\";\n    this.active = options.active || this.active;\n  }\n}\n","/** Important to start UIDs at 1 so that falsey evaluations do not pass when examining UIDs */\nlet UID = 1;\n\n/**\n * Provides a 64 bit UID.\n *\n * Note: all uids generated with uid() are unique amongst uid() calls and NOT unique amongst\n * other types of uid calls.\n */\nexport function uid() {\n  return ++UID;\n}\n\nlet CUID = 0;\n\n/**\n * Provides a 24 bit UID (keeps the UID within non-alpha color ranges)\n *\n * Note: all uids generated with colorUID() are unique amongst colorUID() calls and NOT unique amongst\n * other types of uid calls.\n */\nexport function colorUID() {\n  return ++CUID % 0xffffff;\n}\n","/**\n * These are all of the settings that can be used to configure the GL state of the system\n */\nexport namespace GLSettings {\n  /**\n   * Settings used when defining render target parameters\n   */\n  export namespace RenderTarget {\n    /**\n     * Specifies the internal format of the color buffer for a render target\n     * when not using a Texture. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/renderbufferStorage\n     */\n    export enum ColorBufferFormat {\n      RGBA4,\n      RGB565,\n      RGB5_A1\n    }\n\n    /**\n     * Specifies the internal format of the depth buffer for a render target\n     * when not using a Texture. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/renderbufferStorage\n     */\n    export enum DepthBufferFormat {\n      DEPTH_COMPONENT16,\n      DEPTH_STENCIL\n    }\n\n    /**\n     * Specifies the internal format of the stencil buffer for a render target\n     * when not using a Texture. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/renderbufferStorage\n     */\n    export enum StencilBufferFormat {\n      STENCIL_INDEX8\n    }\n  }\n\n  export namespace Material {\n    /**\n     * Sets the blending function to be either a preset blending function or enables the\n     * use of a Custom blending equation. WHen custom is set, the Dst, Src factors, and blending\n     * equation settings come into play\n     */\n    export enum Blending {\n      NoBlending = 0,\n      NormalBlending = 1,\n      AdditiveBlending = 2,\n      SubtractiveBlending = 3,\n      MultiplyBlending = 4\n    }\n\n    /**\n     * Specifies the Destination factor for the blending equation see:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendFunc\n     */\n    export enum BlendingDstFactor {\n      Zero = 0,\n      One = 1,\n      SrcColor = 2,\n      OneMinusSrcColor = 3,\n      SrcAlpha = 4,\n      OneMinusSrcAlpha = 5,\n      DstAlpha = 6,\n      OneMinusDstAlpha = 7,\n      DstColor = 8,\n      OneMinusDstColor = 9\n    }\n\n    /**\n     * Specifies the Source factor for the blending equation see:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendFunc\n     */\n    export enum BlendingSrcFactor {\n      Zero = 0,\n      One = 1,\n      SrcColor = 2,\n      OneMinusSrcColor = 3,\n      SrcAlpha = 4,\n      OneMinusSrcAlpha = 5,\n      DstAlpha = 6,\n      OneMinusDstAlpha = 7,\n      DstColor = 8,\n      OneMinusDstColor = 9,\n      SrcAlphaSaturate = 10\n    }\n\n    /**\n     * Specifies the blending equation see:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendEquation\n     */\n    export enum BlendingEquations {\n      Add = 0,\n      Subtract = 1,\n      ReverseSubtract = 2\n      /** Requires extension for Webgl 1.0 */\n      // Min = 3,\n      // Max = 4\n    }\n\n    /**\n     * Specifies the Depth comparison function for determining if a fragment should be drawn when it's\n     * depth is compared against the depth buffer see:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/depthFunc\n     */\n    export enum DepthFunctions {\n      NEVER = 0,\n      LESS = 1,\n      EQUAL = 2,\n      LESS_OR_EQUAL = 3,\n      GREATER = 4,\n      NOTEQUAL = 5,\n      GREATER_OR_EQUAL = 6,\n      ALWAYS = 7\n    }\n\n    /**\n     * Specifies which side of the polygon should be culled or not. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/cullFace\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/frontFace\n     */\n    export enum CullSide {\n      NONE = 0,\n      CW = 1,\n      CCW = 2,\n      BOTH = 3\n    }\n  }\n\n  /**\n   * These are settings applied to a model\n   */\n  export namespace Model {\n    export enum DrawMode {\n      LINE_LOOP,\n      LINE_STRIP,\n      LINES,\n      POINTS,\n      TRIANGLE_FAN,\n      TRIANGLE_STRIP,\n      TRIANGLES\n    }\n  }\n\n  /**\n   * Settings that are applied to textures\n   */\n  export namespace Texture {\n    /**\n     * Specifies which target to bind the texture to. 2D or a cubemap.\n     */\n    export enum TextureBindingTarget {\n      TEXTURE_2D,\n      CUBE_MAP\n    }\n\n    /**\n     * The wrap mode when reading values outside of 0 - 1 when sampling the texture. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n     */\n    export enum Wrapping {\n      REPEAT = 0,\n      CLAMP_TO_EDGE = 1,\n      MIRRORED_REPEAT = 2\n    }\n\n    /**\n     * The interpolation method to use when sampling between texels when the render space is smaller than the texture. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n     */\n    export enum TextureMinFilter {\n      Nearest = 0,\n      NearestMipMapNearest = 1,\n      NearestMipMapLinear = 2,\n      Linear = 3,\n      LinearMipMapNearest = 4,\n      LinearMipMapLinear = 5\n    }\n\n    /**\n     * The interpolation method to use when sampling between texels when the render space is larger than the texture. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n     */\n    export enum TextureMagFilter {\n      Nearest = 0,\n      Linear = 1\n    }\n\n    /**\n     * This is the format of the input texture. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n     */\n    export enum SourcePixelFormat {\n      /**\n       * Highly supported webgl 1\n       * Pairs with: TexelDataType.RGBA, RGB, LuminanceAlpha, Luminance, Alpha\n       */\n      UnsignedByte = 0,\n      /**\n       * Highly supported webgl 1\n       * Pairs with: TexelDataType.RGB\n       */\n      UnsignedShort_5_6_5 = 1,\n      /**\n       * Highly supported webgl 1\n       * Pairs with: TexelDataType.RGBA\n       */\n      UnsignedShort_4_4_4_4 = 2,\n      /**\n       * Highly supported webgl 1\n       * Pairs with: TexelDataType.RGBA\n       */\n      UnsignedShort_5_5_5_1 = 3,\n      /** Depth texture or Webgl 2 */\n      UnsignedShort = 4,\n      /** Depth texture or Webgl 2 */\n      UnsignedInt = 5,\n      /** Depth texture extension or Webgl 2 */\n      UnsignedInt_24_8 = 6,\n      /** Webgl 2 */\n      Byte = 7,\n      /** Webgl 2 */\n      Short = 8,\n      /** Webgl 2 */\n      Int = 9,\n      /** Webgl 2 */\n      Float = 10,\n      /** Webgl 2 */\n      HalfFloat = 11,\n      /** Webgl 2 */\n      UnsignedInt_2_10_10_10_REV = 12,\n      /** Webgl 2 */\n      UnsignedInt_10F_11F_11F_REV = 13,\n      /** Webgl 2 */\n      UnsignedInt_5_9_9_9_REV = 14,\n      /** Webgl 2 */\n      Float32UnsignedInt_24_8_REV = 15\n    }\n\n    /**\n     * This is the data format the texels in the texture will take on. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n     */\n    export enum TexelDataType {\n      /**\n       * Discards the red, green and blue components and reads the alpha component.\n       * Pairs with: UNSIGNED_BYTE\n       */\n      Alpha = 0,\n      /**\n       * Requires Depth extension or webgl2\n       */\n      DepthComponent = 1,\n      /**\n       * Requires Depth extension or webgl2\n       */\n      DepthStencil = 2,\n      /**\n       * Each color component is a luminance component, alpha is 1.0.\n       * Pairs with:\n       */\n      Luminance = 3,\n      /**\n       * Each component is a luminance/alpha component.\n       */\n      LuminanceAlpha = 4,\n      /**\n       * Discards the alpha components and reads the red, green and blue components.\n       * Pairs with:\n       */\n      RGB = 5,\n      /**\n       * Red, green, blue and alpha components are read from the color buffer.\n       */\n      RGBA = 6,\n      RGBE = 7\n    }\n\n    /**\n     * This specifies hwo the texture data is unpacked when using gl.readPixels. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei\n     * https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glPixelStorei.xml\n     */\n    export enum PackAlignment {\n      /** Byte-alignment */\n      ONE = 1,\n      /** Rows aligned to even-numbered bytes */\n      TWO = 2,\n      /** Word-alignment */\n      FOUR = 4,\n      /** Rows start on double-word boundaries */\n      EIGHT = 8\n    }\n\n    /**\n     * This specifies how the texture data is packed into memory (for gl.texImage2D and gl.texSubImage2D) See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei\n     * https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glPixelStorei.xml\n     */\n    export enum UnpackAlignment {\n      /** Byte-alignment */\n      ONE = 1,\n      /** Rows aligned to even-numbered bytes */\n      TWO = 2,\n      /** Word-alignment */\n      FOUR = 4,\n      /** Rows start on double-word boundaries */\n      EIGHT = 8\n    }\n  }\n\n  /**\n   * Settings associated with the Renderer\n   */\n  export namespace Renderer {\n    /**\n     * This specifies what data is read out and how\n     */\n    export enum ReadFilter {\n      ALPHA,\n      RGB,\n      RGBA\n    }\n\n    /**\n     * Specifies the data format of the array buffer the data is read into\n     */\n    export enum ReadTargetArrayFormat {\n      UNSIGNED_BYTE,\n      UNSIGNED_SHORT_5_6_5,\n      UNSIGNED_SHORT_4_4_4_4,\n      UNSIGNED_SHORT_5_5_5_1,\n      FLOAT\n    }\n  }\n}\n","export * from \"./auto-easing-method\";\nexport * from \"./base-projection\";\nexport * from \"./matrix\";\nexport * from \"./quaternion\";\nexport * from \"./vector\";\nexport * from \"./primitives\";\nexport * from \"./ray\";\n\nimport * as matrix from \"./matrix\";\nimport * as quaternion from \"./quaternion\";\nimport * as vector from \"./vector\";\n\n/**\n * This is a convenience lookup to see all of the math methods available for manipulating matrices. All of the methods\n * can be imported directly if you know which method you are looking for. This Just helps you find a method you may not\n * know the name of.\n */\nexport const MatrixMath = matrix;\n/**\n * This is a convenience lookup to see all of the math methods available for manipulating vectors. All of the methods\n * can be imported directly if you know which method you are looking for. This Just helps you find a method you may not\n * know the name of.\n */\nexport const VectorMath = vector;\n/**\n * This is a convenience lookup to see all of the math methods available for manipulating quaternions. All of the methods\n * can be imported directly if you know which method you are looking for. This Just helps you find a method you may not\n * know the name of.\n */\nexport const QuaternionMath = quaternion;\n","import { Transform } from \"../3d/scene-graph/transform\";\nimport {\n  compare4x4,\n  copy4x4,\n  identity4,\n  Mat4x4,\n  multiply4x4,\n  orthographic4x4,\n  perspective4x4\n} from \"../math/matrix\";\nimport { compare3, Vec3 } from \"../math/vector\";\nimport { shallowCompare } from \"./shallow-compare\";\nimport { uid } from \"./uid\";\n\nexport enum CameraProjectionType {\n  PERSPECTIVE,\n  ORTHOGRAPHIC\n}\n\n/**\n * Options for generating a camera that has orthographic properties.\n */\nexport interface ICameraOrthographicOptions {\n  /** Forced type requirement, indicates orthographic projection */\n  type: CameraProjectionType.ORTHOGRAPHIC;\n\n  /** Left border of the view range */\n  left: number;\n  /** Right border of the view range */\n  right: number;\n  /** Top border of the view range */\n  top: number;\n  /** Bottom border of the view range */\n  bottom: number;\n  /** Near border of the view range */\n  near: number;\n  /** Far border of the view range */\n  far: number;\n}\n\n/**\n * Options for generating a camera that has perspective properties.\n */\nexport interface ICameraPerspectiveOptions {\n  /** Forced type requirement, indicates perspective projection */\n  type: CameraProjectionType.PERSPECTIVE;\n\n  /** Field of view in radians */\n  fov: number;\n  /** Width of the render space */\n  width: number;\n  /** Height of the render space */\n  height: number;\n  /** The near clipping plane */\n  near: number;\n  /** The far clipping plane */\n  far: number;\n}\n\n/**\n * Base options for camera construction\n */\nexport type ICameraOptions = (\n  | ICameraOrthographicOptions\n  | ICameraPerspectiveOptions\n) & {\n  onViewChange?(camera: Camera, viewId: string): void;\n};\n\nexport interface IOrthoGraphicCamera extends Camera {\n  projectionOptions: ICameraOrthographicOptions;\n}\n\nexport interface IPerspectiveCamera extends Camera {\n  projectionOptions: ICameraPerspectiveOptions;\n}\n\nexport function isOrthographic(camera: Camera): camera is IOrthoGraphicCamera {\n  return (\n    camera.projectionOptions.type === CameraProjectionType.ORTHOGRAPHIC &&\n    \"left\" in camera.projectionOptions\n  );\n}\n\nexport function isPerspective(camera: Camera): camera is IPerspectiveCamera {\n  return (\n    camera.projectionOptions.type === CameraProjectionType.PERSPECTIVE &&\n    \"fov\" in camera.projectionOptions\n  );\n}\n\n/**\n * This class is present to simplify the concepts of Matrix math down to simpler camera concepts. A camera is two things:\n * - An object that can be placed within the world and be a part of a scene graph\n * - A mathematical structure that defines the viewing\n */\nexport class Camera {\n  /** Provide an identifier for the camera to follow the pattern of most everything in this framework. */\n  get id() {\n    return this._id;\n  }\n  private _id: number = uid();\n\n  /** This is the calculated timestamp at which this camera is 'at rest' and will no longer trigger updates */\n  animationEndTime: number = 0;\n  /** Indicates the view's associated with this camera should be redrawn */\n  needsViewDrawn: boolean = true;\n  /** Flag indicating the camera needs to broadcast changes applied to it */\n  needsBroadcast: boolean = false;\n  /** The id of the view to be broadcasted for the sake of a change */\n  viewChangeViewId: string = \"\";\n  /** This is the transform that places the camera within world space */\n  transform: Transform = new Transform();\n\n  /** Handler  */\n  onChange?(camera: Camera, viewId: string): void;\n\n  /**\n   * Performs the broadcast of changes for the camera if the camera needed a broadcast.\n   */\n  broadcast(viewId: string) {\n    // Emit changes for the view indicated that this camera affects\n    if (this.onChange) this.onChange(this, viewId);\n  }\n\n  /**\n   * Quick generation of a camera with properties. None make any sense and should be set appropriately.\n   * ie - View2D handles setting these values correctly for you.\n   */\n  static makeOrthographic() {\n    return new Camera({\n      left: -100,\n      right: 100,\n      top: -100,\n      bottom: 100,\n      near: -100,\n      far: 100000,\n      type: CameraProjectionType.ORTHOGRAPHIC\n    });\n  }\n\n  /**\n   * Quick generation of a camera with perspective properties.\n   */\n  static makePerspective(options?: Partial<ICameraPerspectiveOptions>) {\n    return new Camera(\n      Object.assign(\n        {\n          type: CameraProjectionType.PERSPECTIVE,\n          far: 10000,\n          near: 1,\n          fov: (90 * Math.PI) / 180,\n          height: 1000,\n          width: 1000\n        },\n        options\n      )\n    );\n  }\n\n  /** The expected projection style of the Camera. */\n  get projectionType() {\n    return this._projectionOptions.type;\n  }\n\n  /** The computed projection of the camera. */\n  get projection() {\n    this.update();\n    return this._projection;\n  }\n  private _projection: Mat4x4 = identity4();\n\n  /** The computed view transform of the camera. */\n  get view() {\n    return this.transform.viewMatrix;\n  }\n\n  /** Flag indicating the transforms for this camera need updating. */\n  get needsUpdate() {\n    return this._needsUpdate;\n  }\n  private _needsUpdate = true;\n\n  /** This is the position of the camera within the world. */\n  get position() {\n    return this.transform.position;\n  }\n  set position(val: Vec3) {\n    this._needsUpdate =\n      this._needsUpdate || !compare3(val, this.transform.position);\n    this.transform.position = val;\n  }\n\n  /**\n   * The camera must always look at a position within the world. This in conjunction with 'roll' defines the orientation\n   * of the camera viewing the world.\n   */\n  lookAt(position: Vec3, up: Vec3) {\n    const old: Mat4x4 = copy4x4(this.transform.matrix);\n    this.transform.lookAt(position, up);\n    this._needsUpdate =\n      this._needsUpdate || !compare4x4(old, this.transform.matrix);\n  }\n\n  /**\n   * This is a scale distortion the camera views the world with. A scale of 2 along an axis, means the camera will view\n   * 2x the amount of the world along that axis (thus having a visual compression if the screen dimensions do\n   * not change).\n   *\n   * This also has the added benefit of quickly and easily swapping axis directions by simply making the scale -1 for\n   * any of the axis.\n   */\n  get scale() {\n    return this.transform.scale;\n  }\n  set scale(val: Vec3) {\n    this._needsUpdate =\n      this._needsUpdate || !compare3(val, this.transform.scale);\n    this.transform.scale = val;\n  }\n\n  /**\n   * Options used for making the projection of the camera. Set new options to update the projection.\n   * Getting the options returns a copy of the object and is not the internal object itself.\n   */\n  get projectionOptions() {\n    return this._projectionOptions;\n  }\n  set projectionOptions(val: ICameraOptions) {\n    this._needsUpdate =\n      this._needsUpdate || !shallowCompare(val, this._projectionOptions);\n    this._projectionOptions = val;\n  }\n  private _projectionOptions: ICameraOptions;\n\n  /**\n   * Provides the combined view projection matrices. Applies view first then the projection multiply(P, V).\n   */\n  get viewProjection() {\n    if (this.transform.changed || this._needsUpdate) {\n      this.update(true);\n    }\n\n    return this._viewProjection;\n  }\n  private _viewProjection: Mat4x4 = identity4();\n\n  constructor(options: ICameraOptions) {\n    this._projectionOptions = options;\n    this._needsUpdate = true;\n    this.onChange = options.onViewChange;\n    this.update();\n  }\n\n  /**\n   * This marks the camera's changes as resolved and responded to.\n   */\n  resolve() {\n    this._needsUpdate = false;\n    this.needsViewDrawn = false;\n    this.needsBroadcast = false;\n  }\n\n  /**\n   * Updates the transform matrices associated with this camera.\n   */\n  update(force?: boolean) {\n    if (this._needsUpdate || force) {\n      this.updateProjection();\n      this._needsUpdate = false;\n      this.needsViewDrawn = true;\n    }\n  }\n\n  /**\n   * Takes the current projection options and produces the projection matrix needed to project elements to the screen.\n   */\n  updateProjection() {\n    if (isOrthographic(this)) {\n      orthographic4x4(\n        this.projectionOptions.left,\n        this.projectionOptions.right,\n        this.projectionOptions.bottom,\n        this.projectionOptions.top,\n        this.projectionOptions.near,\n        this.projectionOptions.far,\n        this._projection\n      );\n    } else if (isPerspective(this)) {\n      perspective4x4(\n        this.projectionOptions.fov,\n        this.projectionOptions.width,\n        this.projectionOptions.height,\n        this.projectionOptions.near,\n        this.projectionOptions.far,\n        this._projection\n      );\n    }\n\n    multiply4x4(\n      this._projection,\n      this.transform.viewMatrix,\n      this._viewProjection\n    );\n  }\n}\n","import { Vec2 } from \"../math/vector\";\n\nexport enum AnchorType {\n  BottomLeft,\n  BottomMiddle,\n  BottomRight,\n  Custom,\n  Middle,\n  MiddleLeft,\n  MiddleRight,\n  TopLeft,\n  TopMiddle,\n  TopRight\n}\n\nexport type Anchor = {\n  /** When the anchor gets calculated on the image, this allows the anchor to go beyond the borders of the image by this amount */\n  padding: number;\n  /**\n   * A padding must contain dimensions for all axis involved. Padding as a scalar is too ambiguous. This holds the calculated\n   * direction the padding applies. The padding value you would provide is just a magnitude that is used to inevitably calculate\n   * this value.\n   */\n  paddingDirection?: Vec2;\n  /** This is the location of the anchor. If a custom anchor is specified, then the x and y are not automatically populated */\n  type: AnchorType;\n  /** This is populated with the anchor's location relative to the image's surface */\n  x?: number;\n  /** This is populated with the anchor's location relative to the image's surface */\n  y?: number;\n};\n\nexport enum ScaleMode {\n  /** The size of the image will be tied to world space */\n  ALWAYS = 1,\n  /** The image will scale to it's font size then stop growing */\n  BOUND_MAX = 2,\n  /** The image will alwyas retain it's font size on screen */\n  NEVER = 3\n}\n","export * from \"./surface\";\nexport * from \"./layer-processing/generate-default-scene\";\nexport * from \"./layer-processing/generate-layer-geometry\";\nexport * from \"./layer-processing/generate-layer-material\";\nexport * from \"./layer-processing/generate-layer-model\";\nexport * from \"./layer-processing/inject-shader-io\";\nexport * from \"./layer\";\nexport * from \"./layer-scene\";\nexport * from \"./view\";\n","export * from \"./base-resource-manager\";\nexport * from \"./resource-router\";\nexport * from \"./text\";\nexport * from \"./texture\";\n","import { Texture } from \"../../gl/texture\";\nimport { Bounds } from \"../../math/primitives/bounds\";\nimport { Vec2 } from \"../../math/vector\";\nimport { InstanceIOValue, Omit } from \"../../types\";\nimport { uid } from \"../../util\";\nimport { VideoTextureMonitor } from \"./video-texture-monitor\";\n\n/**\n * Converts a SubTexture reference to a valid Instance IO value where:\n * [top left x, top left y, bottom right x, bottom right y]\n *\n * This also handles falsey texture values where invalid is a zero vector\n */\nexport function subTextureIOValue(\n  texture?: SubTexture | null\n): InstanceIOValue {\n  // If the texture is not defined we just output an empty reference\n  if (!texture) {\n    return [0, 0, 0, 0];\n  }\n\n  // Otherwise, we return the atlas information of the texture\n  return [\n    texture.atlasTL[0],\n    texture.atlasTL[1],\n    texture.atlasBR[0],\n    texture.atlasBR[1]\n  ];\n}\n\n/**\n * Defines a texture that is located on an atlas\n */\nexport class SubTexture {\n  /** A unique identifier for the sub texture to aid in debugging issues */\n  get uid() {\n    return this._uid;\n  }\n  private _uid: number = uid();\n  /** Stores the aspect ratio of the image for quick reference */\n  aspectRatio: number = 1.0;\n  /** This is the top left UV coordinate of the sub texture on the atlas */\n  atlasTL: Vec2 = [0, 0];\n  /** This is the top right UV coordinate of the sub texture on the atlas */\n  atlasTR: Vec2 = [0, 0];\n  /** This is the bottom left UV coordinate of the sub texture on the atlas */\n  atlasBL: Vec2 = [0, 0];\n  /** This is the bottom right UV coordinate of the sub texture on the atlas */\n  atlasBR: Vec2 = [0, 0];\n  /** This is the normalized height of the sub texture on the atlas */\n  heightOnAtlas: number = 0;\n  /** This flag is set to false when the underlying texture is no longer valid */\n  isValid: boolean = false;\n  /** Width in pixels of the image on the atlas */\n  pixelWidth: number = 0;\n  /** Height in pixels of the image on the atlas */\n  pixelHeight: number = 0;\n  /** The region information of the subtexture on the atlas' texture. */\n  atlasRegion?: { x: number; y: number; width: number; height: number };\n  /** This is the source image/data that this sub texture applied to the atlas */\n  source?: TexImageSource;\n  /** This is the actual texture this resource is located within */\n  texture: Texture | null = null;\n  /**\n   * If this is a subtexture that references a video, this will be populated with it's monitor that ensures the portion\n   * of the texture is kept up to date with the latest from the video's playback.\n   */\n  video?: {\n    monitor: VideoTextureMonitor;\n  };\n  /** This is the normalized width of the sub texture on the atlas */\n  widthOnAtlas: number = 0;\n\n  constructor(options?: Omit<Partial<SubTexture>, \"update\">) {\n    Object.assign(this, options);\n  }\n\n  /**\n   * Generates a SubTexture object based on the texture and region provided.\n   */\n  static fromRegion(source: Texture, region: Bounds<any>) {\n    if (!source.data) return null;\n\n    const ux = region.x / source.data.width;\n    const uy = region.y / source.data.height;\n    const uw = region.width / source.data.width;\n    const uh = region.height / source.data.height;\n\n    const atlasDimensions: Bounds<never> = new Bounds({\n      bottom: uy + uh,\n      left: ux,\n      right: ux + uw,\n      top: uy\n    });\n\n    const bottom = atlasDimensions.bottom;\n    const top = atlasDimensions.y;\n    const left = atlasDimensions.x;\n    const right = atlasDimensions.x + atlasDimensions.width;\n\n    const sub = new SubTexture();\n    sub.atlasTL = [left, top];\n    sub.atlasBR = [right, bottom];\n    sub.atlasBL = [left, bottom];\n    sub.atlasTR = [right, top];\n\n    return sub;\n  }\n\n  /**\n   * Forces an update of this sub texture on the texture it is located.\n   *\n   * NOTE: Use this WISELY. This does NOT smartly determine if the update would do nothing. This WILL cause the source\n   * to be uploaded to the Atlas when this is called.\n   */\n  update() {\n    if (!this.texture || !this.source || !this.atlasRegion) return;\n    this.texture.update(this.source, this.atlasRegion);\n  }\n\n  toString(): string {\n    return JSON.stringify(\n      {\n        atlas: {\n          TL: this.atlasTL,\n          TR: this.atlasTR,\n          BL: this.atlasBL,\n          BR: this.atlasBR\n        },\n        width: this.pixelWidth,\n        height: this.pixelHeight\n      },\n      null,\n      2\n    );\n  }\n}\n","import { uid } from \"../util/uid\";\nimport { Instance } from \"./instance\";\n\nexport class ObservableMonitoring {\n  static gatherIds: boolean = false;\n  static observableIds: number[] = [];\n  static observableNamesToUID = new Map<string, number>();\n\n  /**\n   * This activates all observables to gather their UIDs when they are retrieved via their getter.\n   * All of the ID's gathered can be accessed via getObservableMonitorIds. It is REQUIRED that this\n   * is disabled again to prevent a MASSIVE memory leak.\n   */\n  static setObservableMonitor(enabled: boolean) {\n    ObservableMonitoring.gatherIds = enabled;\n    ObservableMonitoring.observableIds = [];\n  }\n\n  /**\n   * This retrieves the observables monitored IDs that were gathered when setObservableMonitor was\n   * enabled.\n   */\n  static getObservableMonitorIds(clear?: boolean) {\n    const values = ObservableMonitoring.observableIds.slice(0);\n    if (clear) ObservableMonitoring.observableIds = [];\n\n    return values;\n  }\n}\n\n/**\n * This is a custom decorator intended for single properties on Instances only! It will\n * facilitate automatic updates and stream the updates through an InstanceProvider to properly\n * update the Instances values in the appropriate and corresponding buffers that will get committed\n * to the GPU.\n */\nexport function observable<T extends Instance>(target: T, key: string) {\n  // Here we store the name of the observable to a UID. This mapping allows us to have a UID\n  // per NAME of an observable. A UID for a name can produce MUCH faster lookups than the name itself.\n  // Matching against the name allows us to have instances with their own property sets but have matching\n  // name mappings to improve compatibility of Instances with varying Layers.\n  let propertyUID: number =\n    ObservableMonitoring.observableNamesToUID.get(key) || 0;\n\n  if (!propertyUID) {\n    propertyUID = uid();\n    ObservableMonitoring.observableNamesToUID.set(key, propertyUID);\n  }\n\n  /**\n   * New property getter to get the property's alternative storage since we overrode\n   * the initial storage with a custom getter and setter.\n   */\n  function getter(this: T) {\n    if (ObservableMonitoring.gatherIds) {\n      ObservableMonitoring.observableIds.push(propertyUID);\n    }\n    return this.observableStorage[propertyUID];\n  }\n\n  /**\n   * New property setter to replace the property marked as observable. This allows\n   * us to broadcast a change to our current observer.\n   */\n  function setter(this: T, newVal: any) {\n    // Update the privatized value\n    this.observableStorage[propertyUID] = newVal;\n    // Broadcast change\n    this.changes[propertyUID] = propertyUID;\n    this.observer && this.observer.instanceUpdated(this);\n  }\n\n  /**\n   * Make sure the desired property is declared on the class with our custom getter and\n   * setter.\n   */\n  Object.defineProperty(target, key, {\n    configurable: true,\n    enumerable: true,\n    get: getter,\n    set: setter\n  });\n}\n","import { Omit } from \"../types\";\nimport { uid } from \"../util\";\nimport { GLProxy } from \"./gl-proxy\";\nimport { GLSettings } from \"./gl-settings\";\n\n/**\n * This is the options to apply to a texture\n */\nexport type TextureOptions = Omit<\n  Partial<Texture>,\n  \"dispose\" | \"update\" | \"updateRegions\"\n>;\n\n/**\n * This represents a texture that is loaded into the GPU.\n */\nexport class Texture {\n  /** Unique identifier of the texture to aid in debugging and referencing */\n  get uid() {\n    return this._uid;\n  }\n  private _uid: number = uid();\n\n  /**\n   * Anisotropic filtering level. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n   * https://blog.tojicode.com/2012/03/anisotropic-filtering-in-webgl.html\n   */\n  get anisotropy() {\n    return this._anisotropy;\n  }\n  set anisotropy(val: Texture[\"_anisotropy\"]) {\n    this.needsSettingsUpdate = true;\n    this._anisotropy = val;\n  }\n  private _anisotropy: number;\n\n  /**\n   * The data to apply to the GPU for the image. If no data is to be uploaded to the texture,\n   * use width and height object. You would do this for render target textures such as depth textures\n   * or color buffer textures where the GPU writes the initial data into the texture. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n   */\n  get data() {\n    return this._data;\n  }\n  set data(val: Texture[\"_data\"]) {\n    this.needsDataUpload = true;\n    this._data = val;\n  }\n  private _data?:\n    | TexImageSource\n    | {\n        width: number;\n        height: number;\n        buffer: ArrayBufferView | null;\n      };\n\n  /**\n   * Indicates the data gets flipped vertically when uploaded to the GPU.\n   */\n  get flipY() {\n    return this._flipY;\n  }\n  set flipY(val: boolean) {\n    this.needsDataUpload = true;\n    this._flipY = val;\n  }\n  private _flipY: boolean = false;\n\n  /**\n   * Source format of the input. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n   */\n  get format() {\n    return this._format;\n  }\n  set format(val: Texture[\"_format\"]) {\n    this.needsDataUpload = true;\n    this._format = val;\n  }\n  private _format: GLSettings.Texture.TexelDataType =\n    GLSettings.Texture.TexelDataType.RGBA;\n\n  /**\n   * Auto generates mipmaps. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/generateMipmap\n   */\n  get generateMipMaps() {\n    return this._generateMipmaps;\n  }\n  set generateMipMaps(val: Texture[\"_generateMipmaps\"]) {\n    this.needsSettingsUpdate = true;\n    this._generateMipmaps = val;\n  }\n  private _generateMipmaps: boolean = false;\n\n  /**\n   * This stores any gl state associated with this object. Modifying this object will cause the system to get out\n   * of sync with the GPU; however, the values inside this object can be read and used for custom WebGL calls as needed.\n   */\n  gl?: {\n    /** The identifier used by gl to target this texture. */\n    textureId: WebGLTexture | null;\n    /** The texture unit this texture is assocviated with. This is -1 if no unit is currently associated */\n    textureUnit: number;\n    /** This is the proxy communicator with the context that generates and destroys Textures */\n    proxy: GLProxy;\n  };\n\n  /**\n   * Filter used when sampling has to magnify the image see:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n   */\n  get magFilter() {\n    return this._magFilter;\n  }\n  set magFilter(val: Texture[\"_magFilter\"]) {\n    this.needsSettingsUpdate = true;\n    this._magFilter = val;\n  }\n  private _magFilter: GLSettings.Texture.TextureMagFilter =\n    GLSettings.Texture.TextureMagFilter.Linear;\n\n  /**\n   * Filter used when sampling has to shrink the image. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n   */\n  get minFilter() {\n    return this._minFilter;\n  }\n  set minFilter(val: Texture[\"_minFilter\"]) {\n    this.needsSettingsUpdate = true;\n    this._minFilter = val;\n  }\n  private _minFilter: GLSettings.Texture.TextureMinFilter =\n    GLSettings.Texture.TextureMinFilter.LinearMipMapLinear;\n\n  /** Flag indicates if the texture object needs to have it's data modified */\n  needsDataUpload: boolean = false;\n  /** Flag indicates if the texture object has sub texture updates needed to be applied to it */\n  needsPartialDataUpload: boolean = false;\n  /** Flag indicates if the texture object needs it's settings modified */\n  needsSettingsUpdate: boolean = false;\n\n  /**\n   * Sets the readPixels data alignment. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei\n   * https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glPixelStorei.xml\n   */\n  get packAlignment() {\n    return this._packAlignment;\n  }\n  set packAlignment(val: Texture[\"_packAlignment\"]) {\n    this.needsSettingsUpdate = true;\n    this._packAlignment = val;\n  }\n  private _packAlignment: GLSettings.Texture.PackAlignment =\n    GLSettings.Texture.PackAlignment.FOUR;\n\n  /**\n   * Tells the input packing to premultiply the alpha values with the other channels as the texture is generated. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei\n   */\n  get premultiplyAlpha() {\n    return this._premultiplyAlpha;\n  }\n  set premultiplyAlpha(val: Texture[\"_premultiplyAlpha\"]) {\n    this.needsSettingsUpdate = true;\n    this._premultiplyAlpha = val;\n  }\n  private _premultiplyAlpha: boolean = false;\n\n  /**\n   * The source pixel data type.\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n   */\n  get type() {\n    return this._type;\n  }\n  set type(val: Texture[\"_type\"]) {\n    this.needsDataUpload = true;\n    this._type = val;\n  }\n  private _type = GLSettings.Texture.SourcePixelFormat.UnsignedByte;\n\n  /**\n   * Sets the data alignment for packing the pixels. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei\n   * https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glPixelStorei.xml\n   */\n  get unpackAlignment() {\n    return this._unpackAlignment;\n  }\n  set unpackAlignment(val: Texture[\"_unpackAlignment\"]) {\n    this.needsSettingsUpdate = true;\n    this._unpackAlignment = val;\n  }\n  private _unpackAlignment: GLSettings.Texture.UnpackAlignment =\n    GLSettings.Texture.UnpackAlignment.FOUR;\n\n  /**\n   * These are the regions that have been requested to be applied to the Texture along\n   * with the data that should be buffered into that region.\n   */\n  get updateRegions() {\n    return this._updateRegions;\n  }\n  private _updateRegions: [\n    Texture[\"data\"],\n    { x: number; y: number; width: number; height: number }\n  ][] = [];\n\n  /**\n   * Specifies sample wrapping for when samples fall outside the 0 - 1 range See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n   */\n  get wrapHorizontal() {\n    return this._wrapHorizontal;\n  }\n  set wrapHorizontal(val: Texture[\"_wrapHorizontal\"]) {\n    this.needsSettingsUpdate = true;\n    this._wrapHorizontal = val;\n  }\n  private _wrapHorizontal: GLSettings.Texture.Wrapping =\n    GLSettings.Texture.Wrapping.CLAMP_TO_EDGE;\n\n  /**\n   * Specifies sample wrapping for when samples fall outside the 0 - 1 range. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n   */\n  get wrapVertical() {\n    return this._wrapVertical;\n  }\n  set wrapVertical(val: Texture[\"_wrapVertical\"]) {\n    this.needsSettingsUpdate = true;\n    this._wrapVertical = val;\n  }\n  private _wrapVertical: GLSettings.Texture.Wrapping =\n    GLSettings.Texture.Wrapping.CLAMP_TO_EDGE;\n\n  constructor(options: TextureOptions) {\n    this.anisotropy = options.anisotropy || this.anisotropy;\n    this.data = options.data || this.data;\n    this.flipY = options.flipY || this.flipY;\n    this.format = options.format || this.format;\n    this.generateMipMaps = options.generateMipMaps || this.generateMipMaps;\n    this.magFilter = options.magFilter || this.magFilter;\n    this.minFilter = options.minFilter || this.minFilter;\n    this.packAlignment = options.packAlignment || this.packAlignment;\n    this.premultiplyAlpha = options.premultiplyAlpha || this.premultiplyAlpha;\n    this.type = options.type || this.type;\n    this.unpackAlignment = options.unpackAlignment || this.unpackAlignment;\n    this.wrapHorizontal = options.wrapHorizontal || this.wrapHorizontal;\n    this.wrapVertical = options.wrapVertical || this.wrapVertical;\n  }\n\n  /**\n   * Frees resources associated with this texture.\n   */\n  dispose() {\n    // Clear the gl context\n    if (this.gl) {\n      this.gl.proxy.disposeTexture(this);\n    }\n\n    // Ensure the large data object for the texture is cleared\n    delete this._data;\n  }\n\n  /**\n   * Clears all update flags and clears out requested updates to the texture object.\n   *\n   * NOTE: Calling this does not perform any actions, but instead prevents actions from\n   * being taken again. The system uses this to clear up any changes requested for the texture\n   * after the texture has been updated with the GPU.\n   */\n  resolve() {\n    this.needsDataUpload = false;\n    this.needsPartialDataUpload = false;\n    this.needsSettingsUpdate = false;\n    this._updateRegions = [];\n  }\n\n  /**\n   * This updates a portion of the texture object.\n   */\n  update(\n    data: Texture[\"data\"],\n    region: { x: number; y: number; width: number; height: number }\n  ) {\n    this.needsPartialDataUpload = true;\n    this._updateRegions.push([data, region]);\n  }\n}\n","/**\n * This file contains all of the utilities for creating common object types\n */\nimport { Instance } from \"../instance-provider/instance\";\nimport {\n  ILayerConstructable,\n  ILayerProps,\n  LayerInitializer\n} from \"../surface/layer\";\nimport { IInstanceAttribute, IUniform, IVertexAttribute, Omit } from \"../types\";\n\n/**\n * Makes it easier to type out and get better editor help in establishing initShader\n */\nexport function createAttribute<T extends Instance>(\n  options: IInstanceAttribute<T>\n) {\n  return options;\n}\n\n/**\n * Makes it easier to type out and get better editor help in establishing initShader\n */\nexport function createUniform(options: IUniform) {\n  return options;\n}\n\n/**\n * Makes it easier to type out and get better editor help in establishing initShader\n */\nexport function createVertex(options: IVertexAttribute) {\n  return options;\n}\n\n/**\n * Used for reactive layer generation and updates.\n */\nexport function createLayer<T extends Instance, U extends ILayerProps<T>>(\n  layerClass: ILayerConstructable<T> & { defaultProps: U },\n  props: Omit<U, \"key\"> & Partial<Pick<U, \"key\">>\n): LayerInitializer {\n  const keyedProps = Object.assign(props, { key: props.key || \"\" });\n\n  return {\n    get key() {\n      return props.key || \"\";\n    },\n    init: [layerClass, keyedProps]\n  };\n}\n","export function getProgramInfo(gl: WebGLRenderingContext, program: any) {\n  const result = {\n      attributeCount: 0,\n      attributes: new Array(),\n      uniformCount: 0,\n      uniforms: new Array()\n    },\n    activeUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS),\n    activeAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\n  // Taken from the WebGl spec:\n  // Http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14\n  const enums: { [key: number]: string } = {\n    0x8b50: \"FLOAT_VEC2\",\n    0x8b51: \"FLOAT_VEC3\",\n    0x8b52: \"FLOAT_VEC4\",\n    0x8b53: \"INT_VEC2\",\n    0x8b54: \"INT_VEC3\",\n    0x8b55: \"INT_VEC4\",\n    0x8b56: \"BOOL\",\n    0x8b57: \"BOOL_VEC2\",\n    0x8b58: \"BOOL_VEC3\",\n    0x8b59: \"BOOL_VEC4\",\n    0x8b5a: \"FLOAT_MAT2\",\n    0x8b5b: \"FLOAT_MAT3\",\n    0x8b5c: \"FLOAT_MAT4\",\n    0x8b5e: \"SAMPLER_2D\",\n    0x8b60: \"SAMPLER_CUBE\",\n    0x1400: \"BYTE\",\n    0x1401: \"UNSIGNED_BYTE\",\n    0x1402: \"SHORT\",\n    0x1403: \"UNSIGNED_SHORT\",\n    0x1404: \"INT\",\n    0x1405: \"UNSIGNED_INT\",\n    0x1406: \"FLOAT\"\n  };\n\n  const blocks: { [key: number]: number } = {\n    0x8b50: 1,\n    0x8b51: 1,\n    0x8b52: 1,\n    0x8b53: 1,\n    0x8b54: 1,\n    0x8b55: 1,\n    0x8b56: 1,\n    0x8b57: 1,\n    0x8b58: 1,\n    0x8b59: 1,\n    0x8b5a: 1,\n    0x8b5b: 3,\n    0x8b5c: 4,\n    0x8b5e: 1,\n    0x8b60: 1,\n    0x1400: 1,\n    0x1401: 1,\n    0x1402: 1,\n    0x1403: 1,\n    0x1404: 1,\n    0x1405: 1,\n    0x1406: 1\n  };\n\n  // Loop through active uniforms\n  for (let i = 0; i < activeUniforms; ++i) {\n    const uniform: any = gl.getActiveUniform(program, i);\n    uniform.typeName = enums[uniform.type];\n    result.uniforms.push(uniform);\n    result.uniformCount += uniform.size;\n    uniform.size = uniform.size * blocks[uniform.type];\n  }\n\n  // Loop through active attributes\n  for (let i = 0; i < activeAttributes; i++) {\n    const attribute: any = gl.getActiveAttrib(program, i);\n    attribute.typeName = enums[attribute.type];\n    result.attributes.push(attribute);\n    result.attributeCount += attribute.size;\n  }\n\n  return result;\n}\n\nexport class WebGLStat {\n  static MAX_VERTEX_UNIFORMS = 0;\n  static MAX_FRAGMENT_UNIFORMS = 0;\n  static MAX_VERTEX_ATTRIBUTES = 0;\n  static WEBGL_SUPPORTED: boolean = false;\n  static MAX_TEXTURE_SIZE = 0;\n  static HARDWARE_INSTANCING = false;\n  static HARDWARE_INSTANCING_ANGLE = false;\n}\n\nfunction initStats() {\n  // Let's perform some immediate operations to do some gl querying for useful information\n  function getAContext() {\n    try {\n      const canvas = document.createElement(\"canvas\");\n      return (\n        (window as any).WebGLRenderingContext &&\n        (canvas.getContext(\"webgl\") ||\n          (canvas.getContext(\"experimental-webgl\") as WebGLRenderingContext))\n      );\n    } catch (e) {\n      return null;\n    }\n  }\n\n  // Attempt to retrieve a context for webgl\n  const gl = getAContext();\n\n  // If the context exists, then we know gl is supported and we can fill in some metrics\n  if (gl) {\n    WebGLStat.WEBGL_SUPPORTED = true;\n    WebGLStat.MAX_VERTEX_UNIFORMS = gl.getParameter(\n      gl.MAX_VERTEX_UNIFORM_VECTORS\n    );\n    WebGLStat.MAX_FRAGMENT_UNIFORMS = gl.getParameter(\n      gl.MAX_FRAGMENT_UNIFORM_VECTORS\n    );\n    WebGLStat.MAX_VERTEX_ATTRIBUTES = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n    WebGLStat.MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    WebGLStat.HARDWARE_INSTANCING_ANGLE = Boolean(\n      gl.getExtension(\"ANGLE_instanced_arrays\")\n    );\n    WebGLStat.HARDWARE_INSTANCING = WebGLStat.HARDWARE_INSTANCING_ANGLE;\n  }\n}\n\ninitStats();\n","export interface IdentifyByKeyOptions {\n  /** The identifier of the object */\n  key: string;\n}\n\n/**\n * This is an object that specifically is generated with a 'key' option that can never\n * be modified on the object and is identified henceforth with the key applied as the\n * 'id' of the object.\n */\nexport class IdentifyByKey {\n  /** Internal key held by the object */\n  private _key: string;\n\n  /** READONLY id of the object. */\n  get id() {\n    return this._key;\n  }\n\n  /** READONLY key of the object */\n  get key() {\n    return this._key;\n  }\n\n  constructor(options: IdentifyByKeyOptions) {\n    this._key = options.key;\n  }\n}\n\nexport class IdentifiableData<T> extends IdentifyByKey {\n  data: T;\n\n  constructor(options: IdentifyByKeyOptions & { data: T }) {\n    super(options);\n    this.data = options.data;\n  }\n}\n","import { Bounds } from \"../../math/primitives/bounds\";\nimport { SubTexture } from \"./sub-texture\";\n\n/**\n * Helps us track the bounds of the image being loaded in tied in with the\n * texture it represents\n */\nexport interface IPackNodeDimensions<T> {\n  data: T;\n  bounds: Bounds<any>;\n}\n\n/**\n * This is used specifically by the atlas manager to aid in packing\n * in textures within an area. This will guarantee boundaries of textures are\n * not violated and provide proper feedback for where to draw a given image\n */\nexport class PackNode<T> {\n  child: [PackNode<T> | null, PackNode<T> | null] = [null, null];\n  isLeaf: boolean = true;\n  bounds: Bounds<any>;\n  data: T | null = null;\n\n  constructor(x: number, y: number, width: number, height: number) {\n    this.bounds = new Bounds({\n      height,\n      width,\n      x,\n      y\n    });\n  }\n\n  /**\n   * Deletes all of the sub nodes in this Mapping, thus clearing up memory usage\n   */\n  destroy() {\n    const child0 = this.child[0];\n    const child1 = this.child[1];\n    this.data = null;\n    if (child0) {\n      child0.destroy();\n    }\n    if (child1) {\n      child1.destroy();\n    }\n    this.child[0] = null;\n    this.child[1] = null;\n  }\n\n  /**\n   * Indicates if there is a child\n   */\n  hasChild(): boolean {\n    const child0 = this.child[0];\n    const child1 = this.child[1];\n    if (child0 && !child0.data) {\n      return !child0.isLeaf;\n    }\n    if (child1 && !child1.data) {\n      return !child1.isLeaf;\n    }\n    return false;\n  }\n\n  /**\n   * Inserts images into our mapping, fitting them appropriately\n   */\n  insert(image: IPackNodeDimensions<T>): PackNode<T> | null {\n    let child0 = this.child[0];\n    let child1 = this.child[1];\n\n    if (!this.isLeaf && child0 && child1) {\n      // Try inserting into first child\n      const newNode: PackNode<T> | null = child0.insert(image);\n      if (newNode !== null) return newNode;\n      // No room in first so insert into second\n      return child1.insert(image);\n    } else {\n      // If there's already an image here, return\n      if (this.data) return null;\n      // Check the fit status of the image in this nodes rectangle space\n      const fitFlag: number = this.bounds.fits(image.bounds);\n      // If we're too small, return null indicating can not fit\n      if (fitFlag === 0) return null;\n\n      // If we're just right, accept\n      if (fitFlag === 1) {\n        this.data = image.data;\n        return this;\n      }\n\n      // Otherwise, gotta split this node and create some leaves\n      this.isLeaf = false;\n      // Get the image width\n      const imgWidth: number = image.bounds.width;\n      const imgHeight: number = image.bounds.height;\n      // Decide which way to split\n      const dWidth: number = this.bounds.width - imgWidth;\n      const dHeight: number = this.bounds.height - image.bounds.height;\n\n      if (dWidth > dHeight) {\n        child0 = this.child[0] = new PackNode(\n          this.bounds.x,\n          this.bounds.y,\n          imgWidth,\n          this.bounds.height\n        );\n        child1 = this.child[1] = new PackNode(\n          this.bounds.x + imgWidth,\n          this.bounds.y,\n          dWidth,\n          this.bounds.height\n        );\n      } else {\n        child0 = this.child[0] = new PackNode(\n          this.bounds.x,\n          this.bounds.y,\n          this.bounds.width,\n          imgHeight\n        );\n        child1 = this.child[1] = new PackNode(\n          this.bounds.x,\n          this.bounds.y + imgHeight,\n          this.bounds.width,\n          dHeight\n        );\n      }\n    }\n\n    // Insert into first child we created\n    return child0.insert(image);\n  }\n\n  /**\n   * Removes the image from the mapping and tries to open up as much space as possible.\n   *\n   * @param {AtlasTexture} data The image to insert into the\n   */\n  remove(data: T): boolean {\n    const child0 = this.child[0];\n    const child1 = this.child[1];\n\n    if (child1 && child0 && !this.isLeaf) {\n      // Try removing from first child\n      let removed: boolean = child0.remove(data);\n      if (removed) return true;\n      // Try remove from second\n      removed = child1.remove(data);\n\n      if (!child0.hasChild()) {\n        if (!child1.hasChild()) {\n          this.child[0] = null;\n          this.child[1] = null;\n        }\n      }\n\n      return removed;\n    } else {\n      if (this.data === data) {\n        this.data = null;\n\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Applies a node's bounds to SubTexture.\n   */\n  static applyToSubTexture<T>(\n    root: PackNode<T>,\n    node: PackNode<T> | Bounds<T>,\n    texture?: SubTexture,\n    padding?: { top: number; left: number; right: number; bottom: number },\n    flipY?: boolean\n  ) {\n    if (!texture) return;\n\n    padding = padding || {\n      top: 0,\n      left: 0,\n      bottom: 0,\n      right: 0\n    };\n\n    const bounds = node instanceof PackNode ? node.bounds : node;\n\n    // Set our image's atlas properties\n    const ux = (bounds.x + padding.left) / root.bounds.width;\n    const uy = (bounds.y + padding.top) / root.bounds.height;\n    const uw =\n      (bounds.width - padding.left - padding.right) / root.bounds.width;\n    const uh =\n      (bounds.height - padding.top - padding.bottom) / root.bounds.height;\n\n    let atlasDimensions: Bounds<never>;\n\n    if (flipY) {\n      atlasDimensions = new Bounds({\n        bottom: 1.0 - uy,\n        left: ux,\n        right: ux + uw,\n        top: 1.0 - (uy + uh)\n      });\n    } else {\n      atlasDimensions = new Bounds({\n        top: 1.0 - uy,\n        left: ux,\n        right: ux + uw,\n        bottom: 1.0 - (uy + uh)\n      });\n    }\n\n    const bottom = atlasDimensions.bottom;\n    const top = atlasDimensions.y;\n    const left = atlasDimensions.x;\n    const right = atlasDimensions.x + atlasDimensions.width;\n\n    texture.atlasTL = [left, top];\n    texture.atlasBR = [right, bottom];\n    texture.atlasBL = [left, bottom];\n    texture.atlasTR = [right, top];\n    texture.widthOnAtlas = Math.abs(texture.atlasTR[0] - texture.atlasTL[0]);\n    texture.heightOnAtlas = Math.abs(texture.atlasTR[1] - texture.atlasBR[1]);\n    texture.pixelWidth = uw * root.bounds.width;\n    texture.pixelHeight = uh * root.bounds.height;\n  }\n}\n","import { Geometry, GLSettings, Material, Model } from \"../../gl\";\n\nexport function generateLayerModel(\n  geometry: Geometry,\n  material: Material,\n  drawMode?: GLSettings.Model.DrawMode\n): Model {\n  const model = new Model(geometry, material);\n  model.drawMode = drawMode || GLSettings.Model.DrawMode.TRIANGLE_STRIP;\n\n  return model;\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport { Vec2, Vec4 } from \"../../math\";\nimport { IInstanceAttributeInternal, InstanceDiff } from \"../../types\";\nimport { Layer } from \"../layer\";\nimport { LayerScene } from \"../layer-scene\";\n\nexport function isBufferLocation(val: any): val is IBufferLocation {\n  return val && val.buffer && val.buffer.value;\n}\n\nexport function isBufferLocationGroup(\n  val: any\n): val is IBufferLocationGroup<IBufferLocation> {\n  return val && val.propertyToBufferLocation;\n}\n\n/**\n * This defines a base information object that explains where in a buffer a value\n * is represented.\n */\nexport interface IBufferLocation {\n  /** This is the parent attribute of this location */\n  attribute: IInstanceAttributeInternal<Instance>;\n  /** For some buffer strategies, there is a concept of block that is used to tightly pack attributes together. */\n  block?: number;\n  /**\n   * This is the generic buffer object interface for accessing the actual buffer.\n   */\n  buffer: {\n    value: Float32Array | Uint8Array | Vec4[];\n  };\n  /**\n   * If the attribute has child attributes (attributes auto generated as a consequence of the attributes settings)\n   * then the children's buffer locations can be found here.\n   */\n  childLocations?: IBufferLocation[];\n  /**\n   * This is the instance index indicative of the instance positioning within the buffer.\n   * Keep in mind: This does NOT correlate to a lookup for an Instance object but rather for\n   * the instancing concept designed for GL Buffers.\n   */\n  instanceIndex: number;\n  /**\n   * This is the range within the buffer values should be injected for this location.\n   */\n  range: Vec2;\n}\n\n/**\n * Each instance that comes in can be associated with a group of buffer locations. A buffer location for each\n * instance attribute used in updates. So a grouping is several buffer locations that are keyed by\n * the instance's property's UIDs.\n */\nexport interface IBufferLocationGroup<T extends IBufferLocation> {\n  /** This is the instance index WITHIN THE BUFFERS. This does NOT have relevance to Instance type objects */\n  instanceIndex: number;\n  /** This is a map of property UIDs to an associated buffer location */\n  propertyToBufferLocation: { [key: number]: T };\n}\n\n/**\n * Layers manage instances and those instances require a form of binding to their associated buffers.\n * The buffers have to be intelligently created and managed in this tieing to maximize performance.\n * One can not have a buffer for every instance in most cases, so the buffer manager has to get instances\n * to cooperate sharing a buffer in whatever strategy possible that best suits the hardware and it's limitations.\n *\n * This provides a uniform interface between instances and their corresponding buffer.\n */\nexport abstract class BufferManagerBase<\n  T extends Instance,\n  U extends IBufferLocation\n> {\n  /** This is the list of changes in effect while this manager is processing requests */\n  changeListContext: InstanceDiff<T>[];\n  /** The layer this manager glues Instances to Buffers */\n  layer: Layer<T, any>;\n  /** The scene the layer is injecting elements into */\n  scene: LayerScene;\n\n  /**\n   * Base constructor. A manager always needs to be associated with it's layer and it's scene.\n   */\n  constructor(layer: Layer<T, any>, scene: LayerScene) {\n    this.layer = layer;\n    this.scene = scene;\n  }\n\n  /**\n   * This adds an instance to the manager and thus ties the instance to an IBuffer location\n   */\n  add: (instance: T) => U | IBufferLocationGroup<U> | undefined;\n\n  /**\n   * This allows a manager to clean up any contextual information it may have stored while processing changes.\n   */\n  changesProcessed() {\n    delete this.changeListContext;\n  }\n\n  /**\n   * Destroy all elements that consume GPU resources or consumes otherwise unreleaseable resources.\n   */\n  abstract destroy(): void;\n\n  /**\n   * Retrieves the buffer locations for the instance provided\n   */\n  abstract getBufferLocations(\n    instance: T\n  ): U | IBufferLocationGroup<U> | undefined;\n\n  /**\n   * This retrieves the property ID for the active attribute. This is necessary to prevent\n   * the need for lookups to find the active attribute.\n   */\n  abstract getActiveAttributePropertyId(): number;\n\n  /**\n   * This returns how many instances this buffer manager has grown to accommodate.\n   */\n  abstract getInstanceCount(): number;\n\n  /**\n   * This should provide a minimum property id list that represents a set of properties that if triggered\n   * for update, would cause all of the attributes to be updated for the layer.\n   */\n  abstract getUpdateAllPropertyIdList(): number[];\n\n  /**\n   * This will be called with the changes that WILL be processed. This allows this manager to make extra judgement calls on\n   * how it will process the changes and let's it optimize itself before changes are actually processed. An example optimization:\n   *\n   * The manager is receiving add requests. The manager receives an add request that triggers a resize of the buffer. Ideally,\n   * the buffer should perform a single resize operation to accommodate ALL add requests getting ready to stream in plus the\n   * current size of of the buffer. With this method, the changes will be available to the manager and let the manager make this\n   * important decision instead of reflexively grow the buffer as requests stream in, which can cause a large number of costly\n   * resize operations.\n   */\n  incomingChangeList(changes: InstanceDiff<T>[]) {\n    this.changeListContext = changes;\n  }\n\n  /**\n   * This method checks to see if this buffer manager has linked an instance to a buffer\n   * location managed by this object.\n   */\n  abstract managesInstance(instance: T): boolean;\n\n  /**\n   * Disassociates an instance with it's buffer location and makes the instance\n   * in the buffer no longer drawable.\n   */\n  remove: (instance: T) => T;\n\n  /**\n   * Removes the manager from the scene it applied itself to.\n   */\n  abstract removeFromScene(): void;\n}\n","import { apply2, apply3, apply4, Vec2, Vec3, Vec3Compat, Vec4 } from \"./vector\";\n\nconst { cos, sin, tan } = Math;\n\n// prettier-ignore\nexport type Mat2x2 = [\n  number, number,\n  number, number\n];\n\n// prettier-ignore\nexport type Mat3x3 = [\n  number, number, number,\n  number, number, number,\n  number, number, number\n];\n\n// prettier-ignore\nexport type Mat4x4 = [\n  number, number, number, number,\n  number, number, number, number,\n  number, number, number, number,\n  number, number, number, number\n];\n\n/** Mat2x2 row column index for convenience M2<row><column> or M2<Y><X> */\nexport const M200 = 0;\n/** Mat2x2 row column index for convenience M2<row><column> or M2<Y><X> */\nexport const M201 = 1;\n/** Mat2x2 row column index for convenience M2<row><column> or M2<Y><X> */\nexport const M210 = 2;\n/** Mat2x2 row column index for convenience M2<row><column> or M2<Y><X> */\nexport const M211 = 3;\n\n/** Mat3x3 row column index for convenience M3<row><column> or M3<Y><X> */\nexport const M300 = 0;\n/** Mat3x3 row column index for convenience M3<row><column> or M3<Y><X> */\nexport const M301 = 1;\n/** Mat3x3 row column index for convenience M3<row><column> or M3<Y><X> */\nexport const M302 = 2;\n/** Mat3x3 row column index for convenience M3<row><column> or M3<Y><X> */\nexport const M310 = 3;\n/** Mat3x3 row column index for convenience M3<row><column> or M3<Y><X> */\nexport const M311 = 4;\n/** Mat3x3 row column index for convenience M3<row><column> or M3<Y><X> */\nexport const M312 = 5;\n/** Mat3x3 row column index for convenience M3<row><column> or M3<Y><X> */\nexport const M320 = 6;\n/** Mat3x3 row column index for convenience M3<row><column> or M3<Y><X> */\nexport const M321 = 7;\n/** Mat3x3 row column index for convenience M3<row><column> or M3<Y><X> */\nexport const M322 = 8;\n\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M400 = 0;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M401 = 1;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M402 = 2;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M403 = 3;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M410 = 4;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M411 = 5;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M412 = 6;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M413 = 7;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M420 = 8;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M421 = 9;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M422 = 10;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M423 = 11;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M430 = 12;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M431 = 13;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M432 = 14;\n/** Mat4x4 row column index for convenience M4<row><column> or M4<Y><X> */\nexport const M433 = 15;\n\n/**\n * It's often much faster to apply values to an existing matrix than to declare a new matrix inline. But it can be\n * annoying and bulky to write the complete array to value sequence to perform such an application. Thus, this method\n * exists to make the process a little more bearable.\n */\nexport function apply2x2(\n  m: Mat2x2 | undefined,\n  m00: number,\n  m01: number,\n  m10: number,\n  m11: number\n) {\n  m = m || (([] as any) as Mat2x2);\n  m[0] = m00;\n  m[1] = m01;\n  m[2] = m10;\n  m[3] = m11;\n\n  return m;\n}\n\n/**\n * It's often much faster to apply values to an existing matrix than to declare a new matrix inline. But it can be\n * annoying and bulky to write the complete array to value sequence to perform such an application. Thus, this method\n * exists to make the process a little more bearable.\n */\nexport function apply3x3(\n  m: Mat3x3 | undefined,\n  m00: number,\n  m01: number,\n  m02: number,\n  m10: number,\n  m11: number,\n  m12: number,\n  m20: number,\n  m21: number,\n  m22: number\n) {\n  m = m || (([] as any) as Mat3x3);\n  m[0] = m00;\n  m[1] = m01;\n  m[2] = m02;\n  m[3] = m10;\n  m[4] = m11;\n  m[5] = m12;\n  m[6] = m20;\n  m[7] = m21;\n  m[8] = m22;\n\n  return m;\n}\n\n/**\n * It's often much faster to apply values to an existing matrix than to declare a new matrix inline. But it can be\n * annoying and bulky to write the complete array to value sequence to perform such an application. Thus, this method\n * exists to make the process a little more bearable.\n */\nexport function apply4x4(\n  m: Mat4x4 | undefined,\n  m00: number,\n  m01: number,\n  m02: number,\n  m03: number,\n  m10: number,\n  m11: number,\n  m12: number,\n  m13: number,\n  m20: number,\n  m21: number,\n  m22: number,\n  m23: number,\n  m30: number,\n  m31: number,\n  m32: number,\n  m33: number\n) {\n  m = m || (([] as any) as Mat4x4);\n\n  m[0] = m00;\n  m[1] = m01;\n  m[2] = m02;\n  m[3] = m03;\n\n  m[4] = m10;\n  m[5] = m11;\n  m[6] = m12;\n  m[7] = m13;\n\n  m[8] = m20;\n  m[9] = m21;\n  m[10] = m22;\n  m[11] = m23;\n\n  m[12] = m30;\n  m[13] = m31;\n  m[14] = m32;\n  m[15] = m33;\n\n  return m;\n}\n\n/**\n * In many of these methods, there are moments that temporary matrices are needed to store some results. Rather than\n * allot and consume memory for temp matrices and degrade performance, these will provide some containers to work with.\n * The values in these containers should never be assumed upon entry of a method, nor shall these be used to make two\n * methods operate together.\n */\n\nconst TEMP_M30 = identity3();\nconst TEMP_M31 = identity3();\nconst TEMP_M32 = identity3();\nconst TEMP_M33 = identity3();\n\n/**\n * Determinant value of a 2x2 matrix\n *\n * 3 OPS\n */\nexport function determinant2x2(mat: Mat2x2): number {\n  return mat[3] * mat[0] - mat[1] * mat[2];\n}\n\n/**\n * Determinant value of a 3x3 matrix\n *\n * 17 OPS\n */\nexport function determinant3x3(mat: Mat3x3): number {\n  return (\n    mat[0] * mat[4] * mat[8] -\n    mat[0] * mat[5] * mat[7] +\n    mat[1] * mat[5] * mat[6] -\n    mat[1] * mat[3] * mat[8] +\n    mat[2] * mat[3] * mat[7] -\n    mat[2] * mat[4] * mat[6]\n  );\n}\n\n/**\n * Determinant value of a 4x4 matrix\n *\n * 75 OPS, 4 temp Mat3x3, 8 method calls\n */\nexport function determinant4x4(mat: Mat4x4): number {\n  // prettier-ignore\n  apply3x3(TEMP_M30,\n     mat[5],  mat[6],  mat[7],\n     mat[9], mat[10], mat[11],\n    mat[13], mat[14], mat[15]\n  );\n\n  // prettier-ignore\n  apply3x3(TEMP_M31,\n     mat[4],  mat[6],  mat[7],\n     mat[8], mat[10], mat[11],\n    mat[12], mat[14], mat[15]\n  );\n\n  // prettier-ignore\n  apply3x3(TEMP_M32,\n     mat[4],  mat[5],  mat[7],\n     mat[8],  mat[9], mat[11],\n    mat[12], mat[13], mat[15]\n  );\n\n  // prettier-ignore\n  apply3x3(TEMP_M32,\n     mat[4],  mat[5],  mat[6],\n     mat[8],  mat[9], mat[10],\n    mat[12], mat[13], mat[14]\n  );\n\n  return (\n    mat[0] * determinant3x3(TEMP_M30) -\n    mat[1] * determinant3x3(TEMP_M31) +\n    mat[2] * determinant3x3(TEMP_M32) -\n    mat[3] * determinant3x3(TEMP_M33)\n  );\n}\n\n/**\n * Calculates the inverse of ONLY purely affine transforms. A general inverse is considered too\n * computationally expensive and alternative strategies should be considered.\n *\n * 9 OPS, 1 method call\n */\nexport function affineInverse2x2(mat: Mat2x2, out?: Mat2x2): Mat2x2 | null {\n  const determinant = determinant2x2(mat);\n  if (determinant === 0) return null;\n\n  // prettier-ignore\n  return apply2x2(out,\n     mat[3] / determinant, -mat[1] / determinant,\n    -mat[2] / determinant,  mat[0] / determinant\n  );\n}\n\n/**\n * Calculates the inverse of ONLY purely affine transforms. A general inverse is considered too\n * computationally expensive and alternative strategies should be considered.\n *\n * 56 OPS, 10 method calls\n */\nexport function affineInverse3x3(mat: Mat3x3, out?: Mat3x3): Mat3x3 | null {\n  // 17 OPS\n  const determiant = determinant3x3(mat);\n  if (determiant === 0) return null;\n\n  // 27 OPS 9 method calls\n  const m0 = determinant2x2([mat[4], mat[5], mat[7], mat[8]]);\n  const m1 = determinant2x2([mat[3], mat[5], mat[6], mat[8]]);\n  const m2 = determinant2x2([mat[3], mat[4], mat[6], mat[7]]);\n  const m3 = determinant2x2([mat[1], mat[2], mat[7], mat[8]]);\n  const m4 = determinant2x2([mat[0], mat[2], mat[6], mat[8]]);\n  const m5 = determinant2x2([mat[0], mat[1], mat[6], mat[7]]);\n  const m6 = determinant2x2([mat[1], mat[2], mat[4], mat[5]]);\n  const m7 = determinant2x2([mat[0], mat[2], mat[3], mat[5]]);\n  const m8 = determinant2x2([mat[0], mat[1], mat[3], mat[4]]);\n\n  // prettier-ignore\n  return apply3x3(out,\n     m0 / determiant, -m3 / determiant, m6 / determiant,\n    -m1 / determiant,  m4 / determiant, m7 / determiant,\n     m2 / determiant, -m5 / determiant, m8 / determiant\n  );\n}\n\n/**\n * Calculates the inverse of ONLY purely affine transforms. A general inverse is considered too\n * computationally expensive and alternative strategies should be considered.\n *\n * 164 OPS + 3 temp 3x3 uses + 13 method calls\n */\nexport function affineInverse4x4(mat: Mat4x4, out?: Mat4x4): Mat4x4 | null {\n  const determiant = determinant4x4(mat);\n  if (determiant === 0) return null;\n\n  const s0 = determinant2x2([mat[0], mat[1], mat[4], mat[5]]);\n  const s1 = determinant2x2([mat[0], mat[2], mat[4], mat[6]]);\n  const s2 = determinant2x2([mat[0], mat[3], mat[4], mat[7]]);\n  const s3 = determinant2x2([mat[1], mat[2], mat[5], mat[6]]);\n  const s4 = determinant2x2([mat[1], mat[3], mat[5], mat[7]]);\n  const s5 = determinant2x2([mat[2], mat[3], mat[6], mat[7]]);\n\n  const c5 = determinant2x2([mat[10], mat[11], mat[14], mat[15]]);\n  const c4 = determinant2x2([mat[9], mat[11], mat[13], mat[15]]);\n  const c3 = determinant2x2([mat[9], mat[10], mat[13], mat[14]]);\n  const c2 = determinant2x2([mat[8], mat[11], mat[12], mat[15]]);\n  const c1 = determinant2x2([mat[8], mat[10], mat[12], mat[14]]);\n  const c0 = determinant2x2([mat[8], mat[9], mat[12], mat[13]]);\n\n  // prettier-ignore\n  return apply4x4(out,\n    //                                                     |                                                        |                                                           |\n     (mat[5] * c5 - mat[6] * c4 + mat[7] * c3) / determiant, (-mat[1] * c5 + mat[2] * c4 - mat[3] * c3) / determiant,  (mat[12] * s5 - mat[13] * s4 + mat[14] * s3) / determiant, (-mat[9] * s5 + mat[10] * s4 - mat[11] * s3) / determiant,\n    (-mat[4] * c5 + mat[6] * c2 - mat[7] * c1) / determiant,  (mat[0] * c5 - mat[2] * c2 + mat[3] * c1) / determiant, (-mat[12] * s5 + mat[14] * s2 - mat[15] * s1) / determiant,  (mat[8] * s5 - mat[10] * s2 + mat[11] * s1) / determiant,\n     (mat[4] * c4 - mat[5] * c2 + mat[7] * c0) / determiant, (-mat[0] * c4 + mat[1] * c2 - mat[3] * c0) / determiant,  (mat[12] * s4 - mat[13] * s2 + mat[15] * s0) / determiant,  (-mat[8] * s4 + mat[9] * s2 - mat[11] * s0) / determiant,\n    (-mat[4] * c3 + mat[5] * c1 - mat[6] * c0) / determiant,  (mat[0] * c3 - mat[1] * c1 + mat[2] * c0) / determiant, (-mat[12] * s3 + mat[13] * s1 - mat[14] * s0) / determiant,   (mat[8] * s3 - mat[9] * s1 + mat[10] * s0) / determiant\n  );\n}\n\n/**\n * 4 OPS\n */\nexport function multiplyScalar2x2(\n  mat: Mat2x2,\n  scale: number,\n  out?: Mat2x2\n): Mat2x2 {\n  // prettier-ignore\n  return apply2x2(out,\n    mat[0] * scale, mat[1] * scale,\n    mat[2] * scale, mat[3] * scale\n  );\n}\n\n/**\n * 9 OPS\n */\nexport function multiplyScalar3x3(\n  mat: Mat3x3,\n  scale: number,\n  out?: Mat3x3\n): Mat3x3 {\n  // prettier-ignore\n  return apply3x3(out,\n    mat[0] * scale, mat[1] * scale, mat[2] * scale,\n    mat[3] * scale, mat[4] * scale, mat[5] * scale,\n    mat[6] * scale, mat[7] * scale, mat[8] * scale\n  );\n}\n\n/**\n * 16 OPS\n */\nexport function multiplyScalar4x4(\n  mat: Mat4x4,\n  scale: number,\n  out?: Mat4x4\n): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n     mat[0] * scale,  mat[1] * scale,  mat[2] * scale,  mat[3] * scale,\n     mat[4] * scale,  mat[5] * scale,  mat[6] * scale,  mat[7] * scale,\n     mat[8] * scale,  mat[9] * scale, mat[10] * scale, mat[11] * scale,\n    mat[12] * scale, mat[13] * scale, mat[14] * scale, mat[15] * scale\n  );\n}\n\n/**\n * Convert or produce a 2x2 identity matrix\n */\nexport function identity2(out?: Mat2x2): Mat2x2 {\n  // prettier-ignore\n  return apply2x2(out,\n    1, 0,\n    0, 1\n  );\n}\n\n/**\n * Convert or produce a 3x3 identity matrix\n */\nexport function identity3(out?: Mat3x3): Mat3x3 {\n  // prettier-ignore\n  return apply3x3(out,\n    1, 0, 0,\n    0, 1, 0,\n    0, 0, 1\n  );\n}\n\n/**\n * Convert or produce a 4x4 identity matrix\n */\nexport function identity4(out?: Mat4x4): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  );\n}\n\n/**\n * Concat two 2x2 matrices. T = left x right\n * 12 OPS\n */\nexport function multiply2x2(left: Mat2x2, right: Mat2x2, out?: Mat2x2): Mat2x2 {\n  // prettier-ignore\n  return apply2x2(out,\n    right[M200] * left[M200] + right[M201] * left[M210], right[M200] * left[M201] + right[M201] * left[M211],\n    right[M210] * left[M200] + right[M211] * left[M210], right[M210] * left[M201] + right[M211] * left[M211],\n  );\n}\n\n/**\n * Concat two 3x3 matrices. T = left x right\n * 45 OPS\n */\nexport function multiply3x3(left: Mat3x3, right: Mat3x3, out?: Mat3x3): Mat3x3 {\n  // prettier-ignore\n  return apply3x3(out,\n    right[0] * left[0] + right[1] * left[3] + right[2] * left[6], right[0] * left[1] + right[1] * left[4] + right[2] * left[7], right[0] * left[2] + right[1] * left[5] + right[2] * left[8],\n    right[3] * left[0] + right[4] * left[3] + right[5] * left[6], right[3] * left[1] + right[4] * left[4] + right[5] * left[7], right[3] * left[2] + right[4] * left[5] + right[5] * left[8],\n    right[6] * left[0] + right[7] * left[3] + right[8] * left[6], right[6] * left[1] + right[7] * left[4] + right[8] * left[7], right[6] * left[2] + right[7] * left[5] + right[8] * left[8]\n  );\n}\n\n/**\n * Concat two 4x4 matrices. T = left x right\n * 112 OPS\n */\nexport function multiply4x4(left: Mat4x4, right: Mat4x4, out?: Mat4x4): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n        right[0] * left[0] + right[1] * left[4] + right[2] * left[8] + right[3] * left[12],     right[0] * left[1] + right[1] * left[5] + right[2] * left[9] + right[3] * left[13],     right[0] * left[2] + right[1] * left[6] + right[2] * left[10] + right[3] * left[14],     right[0] * left[3] + right[1] * left[7] + right[2] * left[11] + right[3] * left[15],\n        right[4] * left[0] + right[5] * left[4] + right[6] * left[8] + right[7] * left[12],     right[4] * left[1] + right[5] * left[5] + right[6] * left[9] + right[7] * left[13],     right[4] * left[2] + right[5] * left[6] + right[6] * left[10] + right[7] * left[14],     right[4] * left[3] + right[5] * left[7] + right[6] * left[11] + right[7] * left[15],\n      right[8] * left[0] + right[9] * left[4] + right[10] * left[8] + right[11] * left[12],   right[8] * left[1] + right[9] * left[5] + right[10] * left[9] + right[11] * left[13],   right[8] * left[2] + right[9] * left[6] + right[10] * left[10] + right[11] * left[14],   right[8] * left[3] + right[9] * left[7] + right[10] * left[11] + right[11] * left[15],\n    right[12] * left[0] + right[13] * left[4] + right[14] * left[8] + right[15] * left[12], right[12] * left[1] + right[13] * left[5] + right[14] * left[9] + right[15] * left[13], right[12] * left[2] + right[13] * left[6] + right[14] * left[10] + right[15] * left[14], right[12] * left[3] + right[13] * left[7] + right[14] * left[11] + right[15] * left[15]\n  );\n}\n\n/**\n * Concat a list of matrices in this order:\n * concat4x4(A, B, C, D, E, ..., N);\n * T = A * B * C * E * ... * N\n *\n * Thus the far right is considered the 'first' operation and the far left is the last.\n */\nexport function concat4x4(out?: Mat4x4, ...m: Mat4x4[]): Mat4x4 {\n  if (m.length <= 0) return identity4();\n  out = out || identity4();\n  apply4x4.call(null, out, ...m[m.length - 1]);\n\n  for (let i = m.length - 2; i >= 0; --i) {\n    const next = m[i];\n    multiply4x4(next, out, out);\n  }\n\n  return out;\n}\n\n/**\n * Add each element by each element in two matrices\n * 4 OPS\n */\nexport function add2x2(left: Mat2x2, right: Mat2x2, out?: Mat2x2): Mat2x2 {\n  // prettier-ignore\n  return apply2x2(out,\n    left[0] + right[0], left[1] + right[1],\n    left[2] + right[2], left[3] + right[3]\n  );\n}\n\n/**\n * Add each element by each element in two matrices\n * 9 OPS\n */\nexport function add3x3(left: Mat3x3, right: Mat3x3, out?: Mat3x3): Mat3x3 {\n  // prettier-ignore\n  return apply3x3(out,\n    left[0] + right[0], left[1] + right[1], left[2] + right[2],\n    left[3] + right[3], left[4] + right[4], left[5] + right[5],\n    left[6] + right[6], left[7] + right[7], left[8] + right[8]\n  );\n}\n\n/**\n * Add each element by each element in two matrices\n * 16 OPS\n */\nexport function add4x4(left: Mat4x4, right: Mat4x4, out?: Mat4x4): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n      left[0] + right[0],   left[1] + right[1],   left[2] + right[2],   left[3] + right[3],\n      left[4] + right[4],   left[5] + right[5],   left[6] + right[6],   left[7] + right[7],\n      left[8] + right[8],   left[9] + right[9], left[10] + right[10], left[11] + right[11],\n    left[12] + right[12], left[13] + right[13], left[14] + right[14], left[15] + right[15]\n  );\n}\n\n/**\n * Subtract each element by each element in two matrices\n * 4 OPS\n */\nexport function subtract2x2(left: Mat2x2, right: Mat2x2, out?: Mat2x2): Mat2x2 {\n  // prettier-ignore\n  return apply2x2(out,\n    left[0] - right[0], left[1] - right[1],\n    left[2] - right[2], left[3] - right[3]\n  );\n}\n\n/**\n * Subtract each element by each element in two matrices\n * 9 OPS\n */\nexport function subtract3x3(left: Mat3x3, right: Mat3x3, out?: Mat3x3): Mat3x3 {\n  // prettier-ignore\n  return apply3x3(out,\n    left[0] - right[0], left[1] - right[1], left[2] - right[2],\n    left[3] - right[3], left[4] - right[4], left[5] - right[5],\n    left[6] - right[6], left[7] - right[7], left[8] - right[8]\n  );\n}\n\n/**\n * Subtract each element by each element in two matrices\n * 16 OPS\n */\nexport function subtract4x4(left: Mat4x4, right: Mat4x4, out?: Mat4x4): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n      left[0] - right[0],   left[1] - right[1],   left[2] - right[2],   left[3] - right[3],\n      left[4] - right[4],   left[5] - right[5],   left[6] - right[6],   left[7] - right[7],\n      left[8] - right[8],   left[9] - right[9], left[10] - right[10], left[11] - right[11],\n    left[12] - right[12], left[13] - right[13], left[14] - right[14], left[15] - right[15]\n  );\n}\n\n/**\n * Hadamard product of two matrices. This is essentially multiplying each element by each element between the two.\n * 4 OPS\n */\nexport function Hadamard2x2(left: Mat2x2, right: Mat2x2, out?: Mat2x2): Mat2x2 {\n  // prettier-ignore\n  return apply2x2(out,\n    left[0] * right[0], left[1] * right[1],\n    left[2] * right[2], left[3] * right[3]\n  );\n}\n\n/**\n * Hadamard product of two matrices. This is essentially multiplying each element by each element between the two.\n * 9 OPS\n */\nexport function Hadamard3x3(left: Mat3x3, right: Mat3x3, out?: Mat3x3): Mat3x3 {\n  // prettier-ignore\n  return apply3x3(out,\n    left[0] * right[0], left[1] * right[1], left[2] * right[2],\n    left[3] * right[3], left[4] * right[4], left[5] * right[5],\n    left[6] * right[6], left[7] * right[7], left[8] * right[8]\n  );\n}\n\n/**\n * Hadamard product of two matrices. This is essentially multiplying each element by each element between the two.\n * 16 OPS\n */\nexport function Hadamard4x4(left: Mat4x4, right: Mat4x4, out?: Mat4x4): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n      left[0] * right[0],   left[1] * right[1],   left[2] * right[2],   left[3] * right[3],\n      left[4] * right[4],   left[5] * right[5],   left[6] * right[6],   left[7] * right[7],\n      left[8] * right[8],   left[9] * right[9], left[10] * right[10], left[11] * right[11],\n    left[12] * right[12], left[13] * right[13], left[14] * right[14], left[15] * right[15]\n  );\n}\n\n/**\n * Transposes a 2x2 matrix:\n * [a, b] -> [a, c]\n * [c, d]    [b, d]\n */\nexport function transpose2x2(mat: Mat2x2, out?: Mat2x2): Mat2x2 {\n  // prettier-ignore\n  return apply2x2(out,\n    mat[0], mat[2],\n    mat[1], mat[3]\n  );\n}\n\n/**\n * Transposes a 3x3 matrix:\n * [a, b, c] -> [a, d, g]\n * [d, e, f]    [b, e, h]\n * [g, h, i]    [c, f, i]\n */\nexport function transpose3x3(mat: Mat3x3, out?: Mat3x3): Mat3x3 {\n  // prettier-ignore\n  return apply3x3(out,\n    mat[0], mat[3], mat[6],\n    mat[1], mat[4], mat[7],\n    mat[2], mat[5], mat[8]\n  );\n}\n\n/**\n * Transposes a 4x4 matrix:\n * [a, b, c, d] -> [a, e, i, m]\n * [e, f, g, h]    [b, f, j, n]\n * [i, j, k, l]    [c, g, k, o]\n * [m, n, o, p]    [d, h, l, p]\n */\nexport function transpose4x4(mat: Mat4x4, out?: Mat4x4): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n    mat[0], mat[4], mat[8],  mat[12],\n    mat[1], mat[5], mat[9],  mat[13],\n    mat[2], mat[6], mat[10], mat[14],\n    mat[3], mat[7], mat[11], mat[15]\n  );\n}\n\n/**\n * This makes a shear 2d matrix that shears parallel to the x-axis.\n * The radians should be input as a value between, non inclusive (-90 degrees, 90 degrees).\n * A shear >= 90 degrees is non-sensical as it would shear to infinity and beyond.\n */\nexport function shearX2x2(radians: number, out?: Mat2x2): Mat2x2 {\n  if (radians >= Math.PI / 2 || radians <= -Math.PI / 2) {\n    console.warn(\"A shear matrix can not have radians >= PI / 2 or <= -PI / 2\");\n  }\n\n  out = out || identity2();\n\n  // prettier-ignore\n  return apply2x2(out,\n    1, 0,\n    tan(radians), 1\n  );\n}\n\n/**\n * This makes a shear 2d matrix that shears parallel to the y-axis.\n * The radians should be input as a value between, non inclusive (-90 degrees, 90 degrees).\n * A shear >= 90 degrees is non-sensical as it would shear to infinity and beyond.\n */\nexport function shearY2x2(radians: number, out?: Mat2x2): Mat2x2 {\n  if (radians >= Math.PI / 2 || radians <= -Math.PI / 2) {\n    console.warn(\"A shear matrix can not have radians >= PI / 2 or <= -PI / 2\");\n  }\n\n  out = out || identity2();\n\n  // prettier-ignore\n  return apply2x2(out,\n    1, tan(radians),\n    0, 1\n  );\n}\n\n/**\n * This makes a shear 3d matrix that shears parallel to the x-axis.\n * The radians should be input as a value between, non inclusive (-90 degrees, 90 degrees).\n * A shear >= 90 degrees is non-sensical as it would shear to infinity and beyond.\n */\nexport function shearX4x4(radians: number, out?: Mat4x4): Mat4x4 {\n  if (radians >= Math.PI / 2 || radians <= -Math.PI / 2) {\n    console.warn(\"A shear matrix can not have radians >= PI / 2 or <= -PI / 2\");\n  }\n\n  out = out || identity4();\n  const shear = tan(radians);\n\n  // prettier-ignore\n  return apply4x4(\n    out,\n    1, shear, shear, 0,\n    shear, 1, 0, 0,\n    shear, 0, 1, 0,\n    0, 0, 0, 1\n  );\n}\n\n/**\n * This makes a shear 3d matrix that shears parallel to the y-axis.\n * The radians should be input as a value between, non inclusive (-90 degrees, 90 degrees).\n * A shear >= 90 degrees is non-sensical as it would shear to infinity and beyond.\n */\nexport function shearY4x4(radians: number, out?: Mat4x4): Mat4x4 {\n  if (radians >= Math.PI / 2 || radians <= -Math.PI / 2) {\n    console.warn(\"A shear matrix can not have radians >= PI / 2 or <= -PI / 2\");\n  }\n\n  out = out || identity4();\n  const shear = tan(radians);\n\n  // prettier-ignore\n  return apply4x4(\n    out,\n    1, shear, 0, 0,\n    shear, 1, shear, 0,\n    0, shear, 1, 0,\n    0, 0, 0, 1\n  );\n}\n\n/**\n * This makes a shear 3d matrix that shears parallel to the z-axis.\n * The radians should be input as a value between, non inclusive (-90 degrees, 90 degrees).\n * A shear >= 90 degrees is non-sensical as it would shear to infinity and beyond.\n */\nexport function shearZ4x4(radians: number, out?: Mat4x4): Mat4x4 {\n  if (radians >= Math.PI / 2 || radians <= -Math.PI / 2) {\n    console.warn(\"A shear matrix can not have radians >= PI / 2 or <= -PI / 2\");\n  }\n\n  out = out || identity4();\n  const shear = tan(radians);\n\n  // prettier-ignore\n  return apply4x4(\n    out,\n    1, 0, shear, 0,\n    0, 1, shear, 0,\n    shear, shear, 1, 0,\n    0, 0, 0, 1\n  );\n}\n\n/**\n * Transforms a Vec2 by a matrix\n */\nexport function transform2(m: Mat2x2, v: Vec2, out?: Vec2): Vec2 {\n  return apply2(\n    out,\n    m[M200] * v[0] + m[M210] * v[1],\n    m[M201] * v[0] + m[M211] * v[1]\n  );\n}\n\n/**\n * Transforms a Vec3 by a matrix.\n */\nexport function transform3(m: Mat3x3, v: Vec3, out?: Vec3): Vec3 {\n  return apply3(\n    out,\n    m[M300] * v[0] + m[M310] * v[1] + m[M320] * v[2],\n    m[M301] * v[0] + m[M311] * v[1] + m[M321] * v[2],\n    m[M302] * v[0] + m[M312] * v[1] + m[M322] * v[2]\n  );\n}\n\n/**\n * Transforms a Vec3 by the provided matrix but treats the Vec3 as a [x, y, z, 1] Vec4.\n */\nexport function transform3as4(m: Mat4x4, v: Vec3, out?: Vec4): Vec4 {\n  return apply4(\n    out,\n    m[M400] * v[0] + m[M410] * v[1] + m[M420] * v[2] + m[M430] * 1,\n    m[M401] * v[0] + m[M411] * v[1] + m[M421] * v[2] + m[M431] * 1,\n    m[M402] * v[0] + m[M412] * v[1] + m[M422] * v[2] + m[M432] * 1,\n    m[M403] * v[0] + m[M413] * v[1] + m[M423] * v[2] + m[M433] * 1\n  );\n}\n\n/**\n * Transforms a vector by the provided matrix\n */\nexport function transform4(m: Mat4x4, v: Vec4, out?: Vec4): Vec4 {\n  return apply4(\n    out,\n    m[M400] * v[0] + m[M410] * v[1] + m[M420] * v[2] + m[M430] * v[3],\n    m[M401] * v[0] + m[M411] * v[1] + m[M421] * v[2] + m[M431] * v[3],\n    m[M402] * v[0] + m[M412] * v[1] + m[M422] * v[2] + m[M432] * v[3],\n    m[M403] * v[0] + m[M413] * v[1] + m[M423] * v[2] + m[M433] * v[3]\n  );\n}\n\n/**\n * Converts a 2x2 to a pretty print string\n */\nexport function toString2x2(mat: Mat2x2): string {\n  // prettier-ignore\n  return `Matrix: [\n  ${mat[0]}, ${mat[1]},\n  ${mat[2]}, ${mat[3]},\n]`;\n}\n\n/**\n * Converts a 3x3 to a pretty print string\n */\nexport function toString3x3(mat: Mat3x3): string {\n  // prettier-ignore\n  return `Matrix: [\n  ${mat[0]}, ${mat[1]}, ${mat[2]},\n  ${mat[3]}, ${mat[4]}, ${mat[5]},\n  ${mat[6]}, ${mat[7]}, ${mat[8]},\n]`;\n}\n\n/**\n * Converts a 4x4 to a pretty print string\n */\nexport function toString4x4(mat: Mat4x4): string {\n  // prettier-ignore\n  return `Matrix: [\n  ${mat[0]}, ${mat[1]}, ${mat[2]}, ${mat[3]},\n  ${mat[4]}, ${mat[5]}, ${mat[6]}, ${mat[7]},\n  ${mat[8]}, ${mat[9]}, ${mat[10]}, ${mat[11]},\n  ${mat[12]}, ${mat[13]}, ${mat[14]}, ${mat[15]},\n]`;\n}\n\n/**\n * We only support Euler X then Y then Z rotations. Specify the rotation values for each axis to\n * receive a matrix that will perform rotations by that amount in that order.\n *\n * All of these rotations follow the right hand rule. If you need a different mixture of ordered\n * rotations, then consider simply concatenating 3 rotations like so (for a ZYZ example):\n *\n * multiply4x4(\n *   rotation4x4(0, 0, Z),\n *   multiply4x4(\n *     rotation4x4(0, Y, 0),\n *     rotation4x4(0, 0, Z),\n *   )\n * );\n *\n * This will create a ZYZ rotation (with the right handed rule). If you need the operations to be left handed you will\n * have to use the transpose and do a little extra math to make it happen or hand craft your own method for generating\n * rotational matrices.\n */\nexport function rotation4x4(x: number, y: number, z: number, out?: Mat4x4) {\n  if (x) {\n    if (y) {\n      if (z) {\n        // x, y, z\n        const cx = cos(x);\n        const cy = cos(y);\n        const cz = cos(z);\n        const sx = sin(x);\n        const sy = sin(y);\n        const sz = sin(z);\n\n        // prettier-ignore\n        /*return apply4x4(out,\n          c1 * c2,  - c1 * s2, s1, 0,\n          s0 * s1 * c2 + c0 * s2, -s0 * s1 * s2 + c0 * c2, -s0 * c1, 0,\n          s0 * s2 - c0 * s1 * c2, s0 * c2 + c0 * s1 * s2, c0 * c1, 0,\n          0, 0, 0, 1\n        );*/\n        return apply4x4(out,\n          cy * cz, cy * sz, -sy, 0,\n          sx * sy * cz - cx * sz, sx * sy * sz + cx * cz, sx * cy, 0,\n          cx * sy * cz + sx * sz, cx * sy * sz - sx * cz, cx * cy, 0,\n          0, 0, 0, 1\n        );\n      } else {\n        // x, y\n        const cx = cos(x);\n        const cy = cos(y);\n        const sx = sin(x);\n        const sy = sin(y);\n\n        // prettier-ignore\n        return apply4x4(out,\n          cy, 0, -sy, 0,\n          sx * sy, cx, sx * cy, 0,\n          cx * sy, -sx, cx * cy, 0,\n          0, 0, 0, 1\n        );\n      }\n    } else {\n      if (z) {\n        // x, z\n        const cx = cos(x);\n        const cz = cos(z);\n        const sx = sin(x);\n        const sz = sin(z);\n\n        // prettier-ignore\n        return apply4x4(out,\n          cz, sz, 0, 0,\n          -cx * sz, cx * cz, sx, 0,\n          sx * sz, -sx * cz, cx, 0,\n          0, 0, 0, 1\n        );\n      } else {\n        // x\n        const cx = cos(x);\n        const sx = sin(x);\n\n        // prettier-ignore\n        return apply4x4(out,\n           1,  0,  0, 0,\n           0,  cx, sx, 0,\n           0,  -sx, cx, 0,\n           0,  0,  0,  1\n        );\n      }\n    }\n  } else {\n    if (y) {\n      if (z) {\n        // y, z\n        const cy = cos(y);\n        const cz = cos(z);\n        const sy = sin(y);\n        const sz = sin(z);\n\n        // prettier-ignore\n        return apply4x4(out,\n          cy * cz, cy * sz, -sy, 0,\n          -sz, cz, 0, 0,\n          sy * cz, sy * sz, cy, 0,\n          0, 0, 0, 1\n       );\n      } else {\n        // y\n        const cy = cos(y);\n        const sy = sin(y);\n\n        // prettier-ignore\n        return apply4x4(out,\n          cy, 0, -sy, 0,\n           0, 1,   0, 0,\n          sy, 0,  cy, 0,\n           0, 0,   0, 1\n        );\n      }\n    } else {\n      if (z) {\n        // z\n        const cz = cos(z);\n        const sz = sin(z);\n\n        // prettier-ignore\n        return apply4x4(out,\n          cz, sz, 0, 0,\n         -sz, cz, 0, 0,\n           0,  0, 1, 0,\n           0,  0, 0, 1\n        );\n      } else {\n        // no x, y, z\n        return identity4(out);\n      }\n    }\n  }\n}\n\n/**\n * We only support Euler X then Y then Z rotations. Specify the rotation values for each axis to\n * receive a matrix that will perform rotations by that amount in that order.\n */\nexport function rotation4x4by3(v: Vec3, out?: Mat4x4) {\n  return rotation4x4(v[0], v[1], v[2], out);\n}\n\n/**\n * Creates a scaling matrix from a vector\n */\nexport function scale4x4by3(p: Vec3Compat, out?: Mat4x4): Mat4x4 {\n  return scale4x4(p[0], p[1], p[2], out);\n}\n\n/**\n * Creates a 4x4 scaling matrix\n */\nexport function scale4x4(\n  x: number,\n  y: number,\n  z: number,\n  out?: Mat4x4\n): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n    x, 0, 0, 0,\n    0, y, 0, 0,\n    0, 0, z, 0,\n    0, 0, 0, 1\n  );\n}\n\n/**\n * Creates a translation Matrix from a vector\n */\nexport function translation4x4by3(t: Vec3Compat, out?: Mat4x4): Mat4x4 {\n  return translation4x4(t[0], t[1], t[2], out);\n}\n\n/**\n * Creates a translation Matrix\n */\nexport function translation4x4(\n  x: number,\n  y: number,\n  z: number,\n  out?: Mat4x4\n): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    x, y, z, 1\n  );\n}\n\n/**\n * Produces a perspective matrix for a given frustum:\n * n: near,\n * f: far,\n * l: left,\n * r: right,\n * b: bottom,\n * t: top\n */\nexport function perspectiveFrustum4x4(\n  n: number,\n  f: number,\n  l: number,\n  r: number,\n  t: number,\n  b: number,\n  out?: Mat4x4\n) {\n  out = out || identity4();\n\n  // This is a column major matrix that should homogenize coordinates to within unit cube if the specified point is\n  // within the expressed frustum.\n  // prettier-ignore\n  return apply4x4(out,\n      2 * n / (r - l),                 0,                      0,  0,\n                    0,   2 * n / (t - b),                      0,  0,\n    (r + l) / (r - l), (t + b) / (t - b),     -(f + n) / (f - n), -1,\n                    0,                 0, -(2 * f * n) / (f - n),  0\n  );\n}\n\n/**\n * Generate a projection matrix with perspective.\n * The provided FOV is for the horizontal FOV.\n */\nexport function perspective4x4(\n  fovRadians: number,\n  width: number,\n  height: number,\n  near: number,\n  far: number,\n  out?: Mat4x4\n): Mat4x4 {\n  const aspect = height / width;\n  const r = tan(fovRadians / 2) * near;\n  const l = -r;\n  const t = aspect * r;\n  const b = -t;\n\n  return perspectiveFrustum4x4(near, far, l, r, t, b, out);\n}\n\n/**\n * Generate a projection matrix with perspective.\n * The provided FOV is for the vertical FOV.\n */\nexport function perspectiveFOVY4x4(\n  fovRadians: number,\n  width: number,\n  height: number,\n  near: number,\n  far: number,\n  out?: Mat4x4\n): Mat4x4 {\n  const aspect = width / height;\n  const t = tan(fovRadians / 2) * near;\n  const b = -t;\n  const r = aspect * t;\n  const l = -r;\n\n  return perspectiveFrustum4x4(near, far, l, r, t, b, out);\n}\n\n/**\n * Generate a projection matrix with no perspective. Useful for flat 2D or isometric rendering or other similar special\n * case renderings.\n */\nexport function orthographic4x4(\n  left: number,\n  right: number,\n  bottom: number,\n  top: number,\n  near: number,\n  far: number,\n  out?: Mat4x4\n): Mat4x4 {\n  // prettier-ignore\n  return apply4x4(out,\n                 2 / (right - left),                               0,                    0, 0,\n                                  0,              2 / (top - bottom),                    0, 0,\n                                  0,                               0,    -1 / (far - near), 0,\n    (right + left) / (left - right), (top + bottom) / (bottom - top), -near / (near - far), 1\n  );\n}\n\n/**\n * Performs the operations to project a Vec4 to screen coordinates using a projection matrix. The x and y of the out\n * Vec4 will be the final projection, w should be resolved to 1, and the z coordinate will be in homogenous coordinates\n * where -1 <= z <= 1 iff z lies within frustum near and far planes.\n */\nexport function projectToScreen(\n  proj: Mat4x4,\n  point: Vec4,\n  width: number,\n  height: number,\n  out?: Vec4\n): Vec4 {\n  out = out || [0, 0, 0, 0];\n  transform4(proj, point, out);\n\n  return apply4(\n    out,\n    (out[0] / out[3] + 1) * 0.5 * width,\n    (out[1] / out[3] + 1) * 0.5 * height,\n    out[2] / out[3],\n    1\n  );\n}\n\n/**\n * Performs the operations to project a Vec3 to screen coordinates as a Vec4 with a w of value 1.\n * using a projection matrix. The x and y of the out Vec4 will be the final projection, w should be resolved to 1,\n * and the z coordinate will be in homogenous coordinates where -1 <= z <= 1 iff z lies within frustum near and\n * far planes.\n */\nexport function project3As4ToScreen(\n  proj: Mat4x4,\n  point: Vec3Compat,\n  width: number,\n  height: number,\n  out?: Vec4\n) {\n  return projectToScreen(\n    proj,\n    [point[0], point[1], point[2], 1],\n    width,\n    height,\n    out\n  );\n}\n\n/**\n * Determines equality of two 2x2 matrices\n */\nexport function compare2x2(m1: Mat2x2, m2: Mat2x2): boolean {\n  return (\n    Math.abs(m1[0] - m2[0]) <= 1e-7 &&\n    Math.abs(m1[1] - m2[1]) <= 1e-7 &&\n    Math.abs(m1[2] - m2[2]) <= 1e-7 &&\n    Math.abs(m1[3] - m2[3]) <= 1e-7\n  );\n}\n\n/**\n * Determines equality of two 3x3 matrices.\n */\nexport function compare3x3(m1: Mat3x3, m2: Mat3x3): boolean {\n  return (\n    Math.abs(m1[0] - m2[0]) <= 1e-7 &&\n    Math.abs(m1[1] - m2[1]) <= 1e-7 &&\n    Math.abs(m1[2] - m2[2]) <= 1e-7 &&\n    Math.abs(m1[3] - m2[3]) <= 1e-7 &&\n    Math.abs(m1[4] - m2[4]) <= 1e-7 &&\n    Math.abs(m1[5] - m2[5]) <= 1e-7 &&\n    Math.abs(m1[6] - m2[6]) <= 1e-7 &&\n    Math.abs(m1[7] - m2[7]) <= 1e-7 &&\n    Math.abs(m1[8] - m2[8]) <= 1e-7\n  );\n}\n\n/**\n * Determines equality of two 4x4 matrices.\n */\nexport function compare4x4(m1: Mat4x4, m2: Mat4x4): boolean {\n  return (\n    Math.abs(m1[0] - m2[0]) <= 1e-7 &&\n    Math.abs(m1[1] - m2[1]) <= 1e-7 &&\n    Math.abs(m1[2] - m2[2]) <= 1e-7 &&\n    Math.abs(m1[3] - m2[3]) <= 1e-7 &&\n    Math.abs(m1[4] - m2[4]) <= 1e-7 &&\n    Math.abs(m1[5] - m2[5]) <= 1e-7 &&\n    Math.abs(m1[6] - m2[6]) <= 1e-7 &&\n    Math.abs(m1[7] - m2[7]) <= 1e-7 &&\n    Math.abs(m1[8] - m2[8]) <= 1e-7 &&\n    Math.abs(m1[9] - m2[9]) <= 1e-7 &&\n    Math.abs(m1[10] - m2[10]) <= 1e-7 &&\n    Math.abs(m1[11] - m2[11]) <= 1e-7 &&\n    Math.abs(m1[12] - m2[12]) <= 1e-7 &&\n    Math.abs(m1[13] - m2[13]) <= 1e-7 &&\n    Math.abs(m1[14] - m2[14]) <= 1e-7 &&\n    Math.abs(m1[15] - m2[15]) <= 1e-7\n  );\n}\n\n/**\n * Copies a Mat2x2 into a new storage object\n */\nexport function copy2x2(m: Mat2x2): Mat2x2 {\n  return [m[0], m[1], m[2], m[3]];\n}\n\n/**\n * Copies a Mat3x3 into a new storage object\n */\nexport function copy3x3(m: Mat3x3): Mat3x3 {\n  return [m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]];\n}\n\n/**\n * Copies a Mat4x4 into a new storage object\n */\nexport function copy4x4(m: Mat4x4): Mat4x4 {\n  return [\n    m[0],\n    m[1],\n    m[2],\n    m[3],\n    m[4],\n    m[5],\n    m[6],\n    m[7],\n    m[8],\n    m[9],\n    m[10],\n    m[11],\n    m[12],\n    m[13],\n    m[14],\n    m[15]\n  ];\n}\n","/**\n * This is a convenience object for creating a promise and retrieving it's resolve method for\n * later use in resolving a situation. Very handy for making a method asynchronous.\n */\nexport class PromiseResolver<T> {\n  resolver: (val: T | undefined) => void;\n  rejector: Function;\n  promise: Promise<T>;\n\n  constructor() {\n    this.promise = new Promise(\n      (resolve, reject) => ((this.resolver = resolve), (this.rejector = reject))\n    );\n  }\n\n  resolve(val?: T) {\n    this.resolver(val);\n  }\n\n  reject<U>(reason: U) {\n    this.rejector(reason);\n  }\n}\n","export interface IShaderTemplateResults {\n  /** This is the resulting shader string generated from the templating */\n  shader: string;\n  /** This is the template options provided by the shader. {option: num occurrences} */\n  shaderProvidedOptions: Map<string, number>;\n  /**\n   * This is the template options provided by the shader that were not resolved by the options parameter\n   * {option: num occurrences}\n   */\n  unresolvedShaderOptions: Map<string, number>;\n  /** This is the options provided to the template that did not get resolved by the shader {option: 1} */\n  unresolvedProvidedOptions: Map<string, number>;\n  /** This is the list of options that DID get resolved by the options provided {option: num occurrences} */\n  resolvedShaderOptions: Map<string, number>;\n}\n\nexport interface IShaderTemplateRequirements {\n  /** A string identifier to make it easier to identify which shader template failed requirements */\n  name: string;\n  /** The options that must be present within both provided options AND within the template */\n  values: string[];\n}\n\nexport interface IShaderTemplateOptions {\n  /** Callback for 'required' errors being emitted */\n  onError?(msg: string): void;\n  /** Callback that allows overrides for token replacement. Provides the token found and the suggested replacement for it */\n  onToken?(token: string, replace: string): string;\n  /**\n   * If this is provided, the shader templater will search out the void main method of the shader and provide the body\n   * contents of that main() method. You can edit those body contents and return the edited value to replace the body\n   * with those contents.\n   *\n   * If the body in the callback is null, then that means a main() method could NOT be determined.\n   */\n  onMain?(body: string | null): string | { main: string; header: string };\n\n  /** This is a key value pair the template uses to match tokens found to replacement values */\n  options: { [key: string]: string };\n  /** This is used to indicate which tokens are required both within the shader AND within the 'options' */\n  required?: IShaderTemplateRequirements;\n  /** This is the shader written with templating information */\n  shader: string;\n}\n\n/**\n * This is a method that aids in making shaders a bit more dynamic with simple string replacement based on tokens written\n * into the shader. Tokens in the shader will appear as ${token} and will either be ignored by this method and thus removed\n * or will be replaced with a provided value.\n *\n * This method will give feedback on the replacements taking place and simplify the process of detecting errors within the process.\n */\nexport function shaderTemplate(\n  templateOptions: IShaderTemplateOptions\n): IShaderTemplateResults {\n  const {\n    shader,\n    options,\n    required,\n    onError,\n    onToken,\n    onMain\n  } = templateOptions;\n  const matched = new Map<string, number>();\n  const noValueProvided = new Map<string, number>();\n  const notFound = new Map<string, number>();\n  const shaderOptions = new Map<string, number>();\n\n  const shaderResults = shader.replace(\n    /\\$\\{([^\\}]*)\\}/g,\n    (_x: string, match: string) => {\n      let replace = \"\";\n      shaderOptions.set(match, (shaderOptions.get(match) || 0) + 1);\n\n      if (match in options) {\n        matched.set(match, (matched.get(match) || 0) + 1);\n        replace = options[match];\n      } else {\n        noValueProvided.set(match, (noValueProvided.get(match) || 0) + 1);\n      }\n\n      if (onToken) {\n        replace = onToken(match, replace);\n      }\n\n      return replace;\n    }\n  );\n\n  Object.keys(options).forEach(option => {\n    if (!matched.get(option)) {\n      notFound.set(option, (notFound.get(option) || 0) + 1);\n    }\n  });\n\n  // Provide metrics\n  const results = {\n    resolvedShaderOptions: matched,\n    shader: shaderResults,\n    shaderProvidedOptions: shaderOptions,\n    unresolvedProvidedOptions: notFound,\n    unresolvedShaderOptions: noValueProvided\n  };\n\n  if (required) {\n    // This will ensure that BOTH the parameter input AND the shader provided the required options.\n    required.values.forEach(require => {\n      if (results.unresolvedProvidedOptions.get(require)) {\n        const msg = `${required.name}: Could not resolve all the required inputs. Input: ${require}`;\n        if (onError) onError(msg);\n        else console.error(msg);\n      } else if (results.unresolvedShaderOptions.get(require)) {\n        const msg = `${required.name}: A required option was not provided in the options parameter. Option: ${require}`;\n        if (onError) onError(msg);\n        else console.error(msg);\n      } else if (!results.resolvedShaderOptions.get(require)) {\n        const msg = `${required.name}: A required option was not provided in the options parameter. Option: ${require}`;\n        if (onError) onError(msg);\n        else console.error(msg);\n      }\n    });\n  }\n  // If onMain is specified, then the caller is wanting to manipulate the body of the main method of the shader\n  if (onMain) {\n    const shader = results.shader;\n    // Use this regex to find the beginning of the main method up to it's opening bracket.\n    const found = shader.match(\n      /void((.+)|\\s)(main(\\s+)\\(\\)|main\\(\\))(((.+)(\\s*)\\{)|(\\s*)\\{)/gm\n    );\n    if (found && found.length > 0) {\n      const start = shader.indexOf(found[0]);\n      // Validate we found something useful\n      if (start < 0) onMain(null);\n      // At this point, we can take the shader and get a string that starts with the body of the void main() method.\n      else {\n        const bodyStart = shader.substr(start + found[0].length);\n        // We now must count valid context brackets till we find a bracket that would close the context of the main\n        // body.\n        let insideMultiLine = false;\n        let insideSingleLine = false;\n        let openBracket = 1;\n        let closeBracket = 0;\n        let endBody = -1;\n\n        // When openBracket === close bracket, we have the location of the end of the body of the main method\n        for (let i = 0, iMax = bodyStart.length; i < iMax; ++i) {\n          const char = bodyStart[i];\n          const nextChar = bodyStart[i + 1];\n\n          // Analyze each character for comments and valid bracket contexts\n          switch (char) {\n            case \"/\":\n              switch (nextChar) {\n                case \"*\":\n                  if (!insideMultiLine && !insideSingleLine) {\n                    insideMultiLine = true;\n                    i++;\n                  }\n                  break;\n\n                case \"/\":\n                  if (!insideMultiLine && !insideSingleLine) {\n                    insideSingleLine = true;\n                    i++;\n                  }\n                  break;\n              }\n              break;\n\n            case \"*\":\n              if (nextChar === \"/\") {\n                if (!insideSingleLine) {\n                  insideMultiLine = false;\n                  i++;\n                }\n              }\n              break;\n\n            case \"\\n\":\n            case \"\\r\":\n              if (!insideMultiLine) {\n                insideSingleLine = false;\n              }\n              break;\n\n            case \"{\":\n              if (!insideMultiLine && !insideSingleLine) {\n                openBracket++;\n              }\n              break;\n\n            case \"}\":\n              if (!insideMultiLine && !insideSingleLine) {\n                closeBracket++;\n              }\n\n              if (openBracket === closeBracket) {\n                endBody = i;\n              }\n              break;\n          }\n\n          // If end body is detected, then we stop looping\n          if (endBody !== -1) {\n            break;\n          }\n        }\n\n        if (endBody !== -1) {\n          const body = bodyStart.substr(0, endBody);\n          const modifiedBody = onMain(body);\n\n          if (typeof modifiedBody === \"string\") {\n            results.shader =\n              shader.substr(0, start + found[0].length) +\n              modifiedBody +\n              shader.substr(start + found[0].length + endBody);\n          } else {\n            results.shader =\n              shader.substr(0, start) +\n              modifiedBody.header +\n              shader.substr(start, found[0].length) +\n              modifiedBody.main +\n              shader.substr(start + found[0].length + endBody);\n          }\n        } else {\n          onMain(null);\n        }\n      }\n    }\n  }\n\n  return results;\n}\n","import { Mat3x3, Mat4x4, Vec2, Vec3, Vec4 } from \"../math\";\nimport { NOOP } from \"../types\";\nimport { Texture } from \"./texture\";\n\nexport enum MaterialUniformType {\n  /** A single float */\n  FLOAT,\n  /** A single vec2 */\n  VEC2,\n  /** A single vec3 */\n  VEC3,\n  /** A single vec4 */\n  VEC4,\n  /** An array of vec4s (uniform vec4 name[count] in the shader) */\n  VEC4_ARRAY,\n  /** An array of floats */\n  FLOAT_ARRAY,\n  /** A single 3x3 matrix of floats */\n  MATRIX3x3,\n  /** A single 4x4 matrix of floats */\n  MATRIX4x4,\n  /** The uniform refers to a texture that should be bound to an active texture unit */\n  TEXTURE\n}\n\n// Uniform type guards\n\nexport function isUniformVec2(\n  val: IMaterialUniform<MaterialUniformType>\n): val is IMaterialUniform<MaterialUniformType.VEC2> {\n  return val.type === MaterialUniformType.VEC2;\n}\n\nexport function isUniformVec3(\n  val: IMaterialUniform<MaterialUniformType>\n): val is IMaterialUniform<MaterialUniformType.VEC3> {\n  return val.type === MaterialUniformType.VEC3;\n}\n\nexport function isUniformVec4(\n  val: IMaterialUniform<MaterialUniformType>\n): val is IMaterialUniform<MaterialUniformType.VEC4> {\n  return val.type === MaterialUniformType.VEC4;\n}\n\nexport function isUniformVec4Array(\n  val: IMaterialUniform<MaterialUniformType>\n): val is IMaterialUniform<MaterialUniformType.VEC4_ARRAY> {\n  return val.type === MaterialUniformType.VEC4_ARRAY;\n}\n\nexport function isUniformMat3(\n  val: IMaterialUniform<MaterialUniformType>\n): val is IMaterialUniform<MaterialUniformType.MATRIX3x3> {\n  return val.type === MaterialUniformType.MATRIX3x3;\n}\n\nexport function isUniformMat4(\n  val: IMaterialUniform<MaterialUniformType>\n): val is IMaterialUniform<MaterialUniformType.MATRIX4x4> {\n  return val.type === MaterialUniformType.MATRIX4x4;\n}\n\nexport function isUniformTexture(\n  val: IMaterialUniform<MaterialUniformType>\n): val is IMaterialUniform<MaterialUniformType.TEXTURE> {\n  return val.type === MaterialUniformType.TEXTURE;\n}\n\nexport function isUniformFloat(\n  val: IMaterialUniform<MaterialUniformType>\n): val is IMaterialUniform<MaterialUniformType.FLOAT> {\n  return val.type === MaterialUniformType.FLOAT;\n}\n\n/**\n * Special enum analyzing material uniforms\n */\nexport type MaterialUniformValue<T> = T extends MaterialUniformType.FLOAT\n  ? number\n  : T extends MaterialUniformType.VEC2\n  ? Vec2\n  : T extends MaterialUniformType.VEC3\n  ? Vec3\n  : T extends MaterialUniformType.VEC4\n  ? Vec4\n  : T extends MaterialUniformType.VEC4_ARRAY\n  ? Vec4[]\n  : T extends MaterialUniformType.MATRIX3x3\n  ? Mat3x3\n  : T extends MaterialUniformType.MATRIX4x4\n  ? Mat4x4\n  : T extends MaterialUniformType.TEXTURE\n  ? Texture\n  : T extends MaterialUniformType.FLOAT_ARRAY\n  ? number[] | Float32Array\n  : number;\n\n/**\n * Defines a uniform applied to a material\n */\nexport interface IMaterialUniform<T extends MaterialUniformType> {\n  /** Indictaes which uniform to utilize */\n  type: T;\n  /** Indicates the value to upload  */\n  value: MaterialUniformValue<T>;\n\n  /**\n   * State stored in the uniform defining gl specific state.\n   * Modifying this outside of the framework is bound to break something.\n   */\n  gl?: Map<\n    WebGLProgram,\n    {\n      location: WebGLUniformLocation;\n    }\n  >;\n}\n\n/** The GL Context which will be either WebGL1 or WebGL2 */\nexport type GLContext = WebGLRenderingContext | WebGL2RenderingContext;\n/**\n * There are now two types of Canvas Element that should be considered. So we harmonize those two into a single type\n * for whenever a canvas of any sort is needed.\n */\nexport type CanvasElement = HTMLCanvasElement | OffscreenCanvas;\n\n/**\n * There is no strong support for OffscreenCanvas in browsers yet, so we must warily utilize the feature and ensure we\n * don't have an undefined variable get used.\n */\nconst OffscreenCanvas = window.OffscreenCanvas || NOOP;\n\n/**\n * Typeguards to see if the canvas is specifically an offscreen canvas or not.\n */\nexport function isOffscreenCanvas(\n  canvas: CanvasElement\n): canvas is OffscreenCanvas {\n  return canvas instanceof OffscreenCanvas;\n}\n\n/**\n * This defines the extensions the framework works with\n */\nexport interface IExtensions {\n  /** Extension for anisotropic filtering */\n  anisotropicFiltering?: {\n    ext: EXT_texture_filter_anisotropic;\n    stat: {\n      maxAnistropicFilter: number;\n    };\n  };\n  /** Extension for MRT (Multiple render targets) */\n  drawBuffers?: WebGL2RenderingContext | WEBGL_draw_buffers;\n  /** Extension for hardware instancing */\n  instancing?: WebGL2RenderingContext | ANGLE_instanced_arrays;\n}\n","// Shader mdoules have no exports and should simply be imported to execute\nimport \"./shader-modules\";\n\nexport * from \"./types\";\nexport * from \"./view\";\nexport * from \"./layers\";\n","import { Camera, CameraProjectionType } from \"../../util/camera\";\nimport { Control2D, IControl2DOptions } from \"./control-2d\";\n\n/**\n * This is a complex camera that layers simpler 2D concepts over an actual 3D projection camera. This camera FORCES the\n * orthographic projection type to work with the 2D layering system created.\n *\n * Essentially this Camera is a two layer concept rolled into one. This is done this way to make the front end API\n * simpler to use and understand while providing ease of use and conveniences for the 2D layer system.\n */\nexport class Camera2D extends Camera {\n  /** These are the 2d controls to make manipulating a 2D world easier */\n  control2D: Control2D;\n\n  get scale2D() {\n    return this.control2D.scale;\n  }\n\n  get offset() {\n    return this.control2D.offset;\n  }\n\n  constructor(options?: IControl2DOptions) {\n    // Force this 2d camera to be an orthographic projection type\n    super({\n      left: -100,\n      right: 100,\n      top: -100,\n      bottom: 100,\n      near: -100,\n      far: 100000,\n      type: CameraProjectionType.ORTHOGRAPHIC\n    });\n\n    // Generate the controller that manipulates our 2D world\n    this.control2D = new Control2D(this, options);\n  }\n}\n","import {\n  AutoEasingMethod,\n  IAutoEasingMethod\n} from \"../../math/auto-easing-method\";\nimport { copy3, divide3, scale3, subtract3, Vec3 } from \"../../math/vector\";\nimport { Surface } from \"../../surface\";\nimport { uid } from \"../../util/uid\";\nimport { Camera2D } from \"./camera-2d\";\n\nexport interface IControl2DOptions {\n  /** The world space offset of elements in the chart */\n  offset?: Vec3;\n  /** The world space scaling present in the chart */\n  scale?: Vec3;\n}\n\nconst immediateAnimation = AutoEasingMethod.immediate<Vec3>(0);\n\n/**\n * Controls for 2D world manipulation\n */\nexport class Control2D {\n  get id() {\n    return this._id;\n  }\n  private _id: number = uid();\n\n  /** The animation set to this camera to animate it's scale and offset */\n  animation: IAutoEasingMethod<Vec3> = AutoEasingMethod.immediate(0);\n  /** This records when the end of the animation for the camera will be completed */\n  animationEndTime: number = 0;\n  /** The 2d camera to work with */\n  camera: Camera2D;\n  /** Indicates which time frame the offset was retrieved so it will only broadcast a change event once for that timeframe */\n  private offsetBroadcastTime: number = 0;\n  /** Indicates which time frame the scale was retrieved so it will only broadcast a change event once for that timeframe */\n  private scaleBroadcastTime: number = 0;\n  /** Represents how much an element should be offset in world space */\n  private _offset: Vec3 = [0, 0, 0];\n  private startOffset: Vec3 = [0, 0, 0];\n  private startOffsetTime: number = 0;\n  private offsetEndTime: number = 0;\n  /** Represents how scaled each axis should be in world space */\n  private _scale: Vec3 = [1, 1, 1];\n  private startScale: Vec3 = [1, 1, 1];\n  private startScaleTime: number = 0;\n  private scaleEndTime: number = 0;\n  /** This is the surface the camera is controlled by */\n  surface: Surface;\n  /** When set, this will broadcast any change in the camera that will affect the view range */\n  private onViewChange?: (camera: Camera2D, view: string) => void;\n  /** Flag indicating the camera needs to broadcast it's changes */\n  private needsBroadcast = false;\n\n  constructor(camera: Camera2D, options?: IControl2DOptions) {\n    this.camera = camera;\n\n    if (options) {\n      this._offset = copy3(options.offset || this._offset);\n      this._scale = copy3(options.scale || this._scale);\n    }\n  }\n\n  /**\n   * Performs the broadcast of changes for the camera if the camera needed a broadcast.\n   */\n  broadcast(viewId: string) {\n    // First we do a simple get of the animated properties. This will cause the broadcast flag to\n    // be set if there are any changes for the current frame.\n    this.offset;\n    this.scale;\n\n    // If the broadcast flag get's set, we should emit the event for the change.\n    if (this.needsBroadcast) {\n      this.needsBroadcast = false;\n      if (this.onViewChange) this.onViewChange(this.camera, viewId);\n    }\n  }\n\n  /**\n   * Adjusts offset to set the middle at the provided location relative to a provided view.\n   */\n  centerOn(viewId: string, position: Vec3) {\n    const viewBounds = this.surface.getViewSize(viewId);\n    if (!viewBounds) return;\n    const midScreen: Vec3 = [viewBounds.width / 2, viewBounds.height / 2, 0];\n    const fromScreenCenter: Vec3 = subtract3(\n      position,\n      divide3(midScreen, this._scale)\n    );\n\n    const currentAnimation = this.animation;\n    this.setOffset(copy3(this.offset));\n    this.animation = immediateAnimation;\n    this.setOffset(scale3(fromScreenCenter, -1));\n    this.animation = currentAnimation;\n  }\n\n  /**\n   * Retrieves the current frame's time from the surface this camera is managed under.\n   */\n  private getCurrentTime() {\n    if (this.surface) {\n      return this.surface.frameMetrics.currentTime;\n    }\n\n    return 0;\n  }\n\n  /**\n   * Gets the source offset value\n   */\n  getOffset() {\n    return this._offset;\n  }\n\n  /**\n   * Gets the source scale value\n   */\n  getScale() {\n    return this._scale;\n  }\n\n  /**\n   * Retrieves the animated value of the offset of the camera.\n   * To get a non-animated version of the offset use getOffset()\n   */\n  get offset() {\n    const currentTime = this.getCurrentTime();\n\n    if (this.onViewChange) {\n      if (this.offsetBroadcastTime < this.offsetEndTime) {\n        this.offsetBroadcastTime = currentTime;\n        this.needsBroadcast = true;\n      }\n    }\n\n    return this.animation.cpu(\n      this.startOffset,\n      this._offset,\n      (currentTime - this.startOffsetTime) / this.animation.duration\n    );\n  }\n\n  /**\n   * Sets the id of this camera\n   */\n  setId(id: number) {\n    this._id = id;\n    this.camera.needsViewDrawn = true;\n  }\n\n  /**\n   * Sets the location of the camera by adjusting the offsets to match.\n   * Whatever is set for the \"animation\" property determines the animation.\n   */\n  setOffset(offset: Vec3) {\n    // Start offset is the offset of the camera at the current evaluated time\n    this.startOffset = copy3(this.offset);\n    // Copy the new end offset value\n    this._offset = copy3(offset);\n    // Get the current time as our starter time of the animating\n    this.startOffsetTime = this.getCurrentTime();\n    // Get the time the offset will complete\n    this.offsetEndTime = this.startOffsetTime + this.animation.duration;\n    // The total animation end time will be the max end time of all animateable properties\n    this.updateEndTime();\n    // Flag the view for a redraw\n    this.camera.needsViewDrawn = true;\n\n    // Broadcast change\n    if (this.onViewChange) {\n      this.offsetBroadcastTime = this.startOffsetTime;\n      this.needsBroadcast = true;\n    }\n  }\n\n  /**\n   * Retrieves the animated scale. If you want straight end scale value, use getScale()\n   */\n  get scale() {\n    const currentTime = this.getCurrentTime();\n\n    if (this.onViewChange) {\n      if (this.scaleBroadcastTime < this.scaleEndTime) {\n        this.scaleBroadcastTime = currentTime;\n        this.needsBroadcast = true;\n      }\n    }\n\n    return this.animation.cpu(\n      this.startScale,\n      this._scale,\n      (currentTime - this.startScaleTime) / this.animation.duration\n    );\n  }\n\n  /**\n   * Applies the handler for broadcasting view changes from the camera.\n   */\n  setViewChangeHandler(handler: Control2D[\"onViewChange\"]) {\n    this.onViewChange = handler;\n  }\n\n  /**\n   * Sets and animates the scale of the camera.\n   * Whatever is set for the \"animation\" property determines the animation.\n   */\n  setScale(scale: Vec3) {\n    // Start scale is the scale of the camera at the current evaluated time\n    this.startScale = copy3(this.scale);\n    // Store the destination value of the scale\n    this._scale = copy3(scale);\n    // Start of the animation is now\n    this.startScaleTime = this.getCurrentTime();\n    // Get the time the scale will complete animation\n    this.scaleEndTime = this.startScaleTime + this.animation.duration;\n    // Update end animation time\n    this.updateEndTime();\n    // Flag this as needing a redraw so all views using it will update.\n    this.camera.needsViewDrawn = true;\n\n    // Broadcast change\n    if (this.onViewChange) {\n      this.scaleBroadcastTime = this.startScaleTime;\n      this.needsBroadcast = true;\n    }\n  }\n\n  /**\n   * Resolves all flags indicating updates needed.\n   */\n  resolve() {\n    this.camera.needsViewDrawn = false;\n    this.needsBroadcast = false;\n  }\n\n  update() {\n    this.camera.needsViewDrawn = true;\n  }\n\n  private updateEndTime() {\n    this.animationEndTime = Math.max(this.scaleEndTime, this.offsetEndTime);\n  }\n}\n","import { WebGLRenderer } from \"../gl\";\nimport { Instance } from \"../instance-provider/instance\";\nimport { ILayerProps, Layer } from \"../surface/layer\";\nimport { BaseIOExpansion } from \"../surface/layer-processing/base-io-expansion\";\nimport {\n  InstanceIOValue,\n  IResourceContext,\n  IResourceInstanceAttribute,\n  IResourceType\n} from \"../types\";\nimport { ResourceRouter } from \"./resource-router\";\n\n/**\n * The Base Options for initializing a resource.\n */\nexport type BaseResourceOptions = IResourceType & { key: string };\n\n/**\n * The base needs for making a resource request.\n */\nexport type BaseResourceRequest = IResourceType & { key: string };\n\n/**\n * This represents a manager that is capable of handling requests for resources that come from Layers\n * that needs the resaource for updating it's Shader IO.\n */\nexport abstract class BaseResourceManager<\n  T extends IResourceType,\n  S extends BaseResourceRequest\n> {\n  /**\n   * Every resource manager will have access to the parent ResourceManager system that pipes resources and requests\n   * to the proper location.\n   */\n  router: ResourceRouter;\n  /** Every resource manager will receive the utilized renderer so the manager can perform basic GL tasks if needed */\n  webGLRenderer?: WebGLRenderer;\n\n  /**\n   * This is called by the system for the manager to dequeue it's requests in an asynchronous\n   * manner, thus allowing the system to have it's resources changed and dequeued without hanging up\n   * the system.\n   */\n  abstract async dequeueRequests(): Promise<boolean>;\n\n  /**\n   * This expects a resource manager to free all of it's resources it is hanging onto.\n   */\n  abstract destroy(): void;\n\n  /**\n   * Indicates a resource needs to be freed or destroyed.\n   */\n  abstract destroyResource(resource: BaseResourceOptions): void;\n\n  /**\n   * Allows a resource manager to provide it's own IO Expansion to handle special attributes\n   * the layer may have for handling.\n   */\n  getIOExpansion(): BaseIOExpansion[] {\n    return [];\n  }\n\n  /**\n   * The method to access a resource initialized by this resource manager.\n   */\n  abstract getResource(resourceKey: string): T | null;\n\n  /**\n   * This is called to initialize a resource that the system has determined needs to be constructed.\n   */\n  abstract async initResource(resource: BaseResourceOptions): Promise<void>;\n\n  /**\n   * This will trigger a request of a resource to be generated. It will immediately return either a\n   * value refelecting the resource is in a Pending state (such as [0, 0, 0, 0]) or it will return\n   * metrics indicative of expected resource's metrics, but will always be in InstanceIOValue format.\n   */\n  abstract request<U extends Instance, V extends ILayerProps<U>>(\n    layer: Layer<U, V>,\n    instance: Instance,\n    resourceRequest: S,\n    context?: IResourceContext\n  ): InstanceIOValue;\n\n  /**\n   * This applies an attribute as the current context\n   */\n  setAttributeContext(_attribute: IResourceInstanceAttribute<Instance>) {\n    // Implemented by sub classes if needed\n  }\n\n  /**\n   * This indicates the resource should be updated.\n   */\n  abstract updateResource(resource: BaseResourceOptions): void;\n}\n\n/**\n * This is a resource manager that implements all of the functionality but returns\n * invalid empty results. This allows the system to have requests for a manager but\n * prevent returning null or undefined states.\n */\nexport class InvalidResourceManager extends BaseResourceManager<\n  IResourceType,\n  BaseResourceRequest\n> {\n  resources = new Map<string, BaseResourceOptions>();\n\n  async dequeueRequests() {\n    return false;\n  }\n\n  destroy() {\n    return;\n  }\n\n  destroyResource(resourceKey: BaseResourceOptions) {\n    this.resources.delete(resourceKey.key);\n  }\n\n  getResource(resourceKey: string) {\n    return this.resources.get(resourceKey) || { key: \"\", type: -1 };\n  }\n\n  async initResource(resource: BaseResourceOptions) {\n    this.resources.set(resource.key, resource);\n  }\n\n  request<U extends Instance, V extends ILayerProps<U>>(\n    _layer: Layer<U, V>,\n    _instance: Instance,\n    _resource: IResourceType\n  ): InstanceIOValue {\n    return [0, 0, 0, 0];\n  }\n\n  updateResource(_resource: BaseResourceOptions) {\n    // NO-OP\n  }\n}\n\nexport const INVALID_RESOURCE_MANAGER = new InvalidResourceManager();\n","import { Instance } from \"../../instance-provider/instance\";\nimport {\n  BaseShaderIOInjection,\n  ShaderIOHeaderInjectionResult\n} from \"../../shaders/processing/base-shader-io-injection\";\nimport { MetricsProcessing } from \"../../shaders/processing/metrics-processing\";\nimport {\n  IInstanceAttribute,\n  IUniform,\n  IVertexAttribute,\n  ShaderInjectionTarget\n} from \"../../types\";\nimport { ILayerProps, Layer } from \"../layer\";\n\nexport type ShaderIOExpansion<T extends Instance> = {\n  /** The additional instance attributes to add to the layer's Shader IO */\n  instanceAttributes: IInstanceAttribute<T>[];\n  /** The additional uniforms to add to the layer's Shader IO */\n  uniforms: IUniform[];\n  /** The additional vertex attributes to add to the layer's Shader IO */\n  vertexAttributes: IVertexAttribute[];\n};\n\n/**\n * When processing attributes, uniforms, etc, it is a common event that special ShaderIO types\n * can be declared that requires additional ShaderIO configuration to be added.\n *\n * This type of object can be added to the layer surface to provide a means to process special\n * attributes the current system or customized system will want to handle.\n */\nexport abstract class BaseIOExpansion extends BaseShaderIOInjection {\n  /**\n   * This is called with the Layer's currently declared Shader IO configuration.\n   * The returned IO configuration will be added to the existing IO.\n   * Each BaseIOExpansion object will receive the expanded IO configuration of other\n   * expansion objects if the object is processed after another expansion object.\n   *\n   * NOTE: The inputs should NOT be modified in any way\n   */\n  expand<T extends Instance, U extends ILayerProps<T>>(\n    _layer: Layer<T, U>,\n    _instanceAttributes: IInstanceAttribute<T>[],\n    _vertexAttributes: IVertexAttribute[],\n    _uniforms: IUniform[]\n  ): ShaderIOExpansion<T> {\n    return {\n      instanceAttributes: [],\n      uniforms: [],\n      vertexAttributes: []\n    };\n  }\n\n  /**\n   * Every expansion object will be given the opportunity to validate the IO presented to it\n   * here, thus allowing unique IO configuration types to be confirmed before getting  completely processed.\n   *\n   * It will be expected that a unique Expansion object will have special requirements centered around the\n   * configuration object, thus it is expected this be implemented in a meaningful way to make devlopment\n   * clearer by making mistakes clearer to the developer.\n   *\n   * Messages should be logged within this method as warnings or errors when validations fail and\n   * then this method should return false indicating the validation failed.\n   *\n   * NOTE: The inputs should NOT be modified in any way\n   */\n  validate<T extends Instance, U extends ILayerProps<T>>(\n    _layer: Layer<T, U>,\n    _instanceAttributes: IInstanceAttribute<T>[],\n    _vertexAttributes: IVertexAttribute[],\n    _uniforms: IUniform[]\n  ): boolean {\n    return true;\n  }\n\n  /**\n   * This allows for injection into the header of the shader.\n   *\n   * The order these controllers are injected\n   * into the system determines the order the contents are written to the header. So dependent injections\n   * must be sorted appropriately.\n   *\n   * @param target The targetted shader object to receive the header. This will be VERTEX or FRAGMENT but never ALL\n   * @param layer The layer that is currently being processed\n   * @param metrics Some metrics processed that are useful for making decisions about buffering strategies etc.\n   */\n  processHeaderInjection(\n    _target: ShaderInjectionTarget,\n    _declarations: Map<string, string>,\n    _layer: Layer<Instance, ILayerProps<Instance>>,\n    _metrics: MetricsProcessing,\n    _vertexAttributes: IVertexAttribute[],\n    _instanceAttributes: IInstanceAttribute<Instance>[],\n    _uniforms: IUniform[]\n  ): ShaderIOHeaderInjectionResult {\n    return {\n      injection: \"\"\n    };\n  }\n\n  /**\n   * This allows for injection into the shader AFTER attribute destructuring has taken place.\n   *\n   * The order these controllers are injected\n   * into the system determines the order the contents are written to the header. So dependent injections\n   * must be sorted appropriately.\n   *\n   * @param layer The layer that is currently being processed\n   * @param metrics Some metrics processed that are useful for making decisions about buffering strategies etc.\n   */\n  processAttributeDestructuring(\n    _layer: Layer<Instance, ILayerProps<Instance>>,\n    _declarations: Map<string, string>,\n    _metrics: MetricsProcessing,\n    _vertexAttributes: IVertexAttribute[],\n    _instanceAttributes: IInstanceAttribute<Instance>[],\n    _uniforms: IUniform[]\n  ): string {\n    return \"\";\n  }\n}\n","import \"./base-modules\";\nexport * from \"./processing\";\n","import { BaseProjection } from \"../math\";\nimport { Bounds } from \"../math/primitives\";\nimport { IViewProps, View } from \"../surface/view\";\nimport { IMouseInteraction, ITouchInteraction } from \"./types\";\nimport { UserInputEventManager } from \"./user-input-event-manager\";\n\n/**\n * Classes can extend this and override the methods to respond to events.\n */\nexport abstract class EventManager {\n  private userInputManager: UserInputEventManager;\n\n  /** Allows an event manager to access it's governing surface */\n  get surface() {\n    return this.userInputManager.surface;\n  }\n\n  // MOUSE EVENTS\n\n  abstract handleMouseDown(e: IMouseInteraction): void;\n  abstract handleMouseUp(e: IMouseInteraction): void;\n  abstract handleMouseOver(e: IMouseInteraction): void;\n  abstract handleMouseOut(e: IMouseInteraction): void;\n  abstract handleMouseMove(e: IMouseInteraction): void;\n  abstract handleClick(e: IMouseInteraction): void;\n  abstract handleDrag(e: IMouseInteraction): void;\n  abstract handleWheel(e: IMouseInteraction): void;\n\n  // TOUCH EVENTS\n\n  /** Handles when a touch first interacts with the screen */\n  abstract handleTouchDown(e: ITouchInteraction): void;\n  /** Handles when a touch is no longer interacting with the screen */\n  abstract handleTouchUp(e: ITouchInteraction): void;\n  /** Handles when an existing touch slides off of it's start view. */\n  abstract handleTouchOut(e: ITouchInteraction): void;\n  /**\n   * Handles when the system nukes your touch whether you like it or not. Some examples of when this 'might' happen:\n   * Hand gestures in iOS Safari that causes the window to be closed or open up multitasking in some fashion.\n   * Basically, more and more convenience gestures in the OS has more and more potential to kill your touches.\n   * So make sure you are using this.\n   */\n  abstract handleTouchCancelled(e: ITouchInteraction): void;\n\n  /** Handles when a touch is dragged across the screen */\n  abstract handleTouchDrag(e: ITouchInteraction): void;\n  /** Handles when a touch has tapped the screen quickly */\n  abstract handleTap(e: ITouchInteraction): void;\n  /** Handles when a touch double taps quickly on the screen */\n  abstract handleDoubleTap(e: ITouchInteraction): void;\n  /** Handles when a touch is left in a location for an extended period of time */\n  abstract handleLongTouch(e: ITouchInteraction): void;\n  /** Handles when a touch taps a location with a lengthy delay */\n  abstract handleLongTap(e: ITouchInteraction): void;\n  /** Handles when multiple touches converge toward each other */\n  abstract handlePinch(e: ITouchInteraction): void;\n  /** Handles when multiple touches spread away from each other */\n  abstract handleSpread(e: ITouchInteraction): void;\n  /** Handles when multiple touches rotate about a point */\n  abstract handleTouchRotate(e: ITouchInteraction): void;\n  /** Handles when a single touch or multiple touches swipe quickly in a direction */\n  abstract handleSwipe(e: ITouchInteraction): void;\n\n  /**\n   * This retrieves the projections for the view specified by the provided viewId.\n   */\n  getProjection(viewId: string): BaseProjection<any> | null {\n    const view = this.userInputManager.getView(viewId);\n    if (view) return view.projection;\n    return null;\n  }\n\n  /**\n   * This retrieves the actual view for the view specified by the provided viewId.\n   */\n  getView(viewId: string): View<IViewProps> | null {\n    return (\n      (this.userInputManager && this.userInputManager.getView(viewId)) || null\n    );\n  }\n\n  /**\n   * This retrieves the screen bounds for the view specified by the provided viewId.\n   */\n  getViewScreenBounds(viewId: string): Bounds<View<IViewProps>> | null {\n    const view = this.userInputManager.getView(viewId);\n\n    if (view) {\n      return view.screenBounds;\n    }\n\n    return null;\n  }\n\n  /**\n   * This is used internally which provides the parent MouseEventManager via the param mouseManager for this\n   * EventManager.\n   */\n  setUserInputManager(mouseManager: UserInputEventManager) {\n    this.userInputManager = mouseManager;\n  }\n}\n","import { EventManager } from \"./event-manager\";\nimport { IMouseInteraction, ITouchInteraction } from \"./types\";\n\n/**\n * This is a simple way to access the events executing on the chart.\n */\nexport class SimpleEventHandler extends EventManager {\n  constructor(handlers: Partial<EventManager>) {\n    super();\n    Object.assign(this, handlers);\n  }\n\n  handleMouseDown(_e: IMouseInteraction): void {\n    /* No op */\n  }\n\n  handleMouseUp(_e: IMouseInteraction): void {\n    /* No op */\n  }\n\n  handleMouseOver(_e: IMouseInteraction): void {\n    /* No op */\n  }\n\n  handleMouseOut(_e: IMouseInteraction): void {\n    /* No op */\n  }\n\n  handleMouseMove(_e: IMouseInteraction): void {\n    /* No op */\n  }\n\n  handleClick(_e: IMouseInteraction): void {\n    /* No op */\n  }\n\n  handleDrag(_e: IMouseInteraction): void {\n    /* No op */\n  }\n\n  handleWheel(_e: IMouseInteraction): void {\n    /* No op */\n  }\n\n  handleTouchCancelled(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleTouchDown(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleTouchUp(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleTouchOut(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleTouchDrag(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleTap(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleDoubleTap(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleLongTouch(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleLongTap(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handlePinch(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleSpread(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleTouchRotate(_e: ITouchInteraction): void {\n    /* No op */\n  }\n\n  handleSwipe(_e: ITouchInteraction): void {\n    /* No op */\n  }\n}\n","import { GLSettings } from \"./gl-settings\";\nimport { GLContext, IExtensions } from \"./types\";\n\n/**\n * This file contains all method used to decode/encode GLSettings to GL types\n */\n\n/**\n * Decodes a DrawMode to a GL setting\n */\nexport function drawMode(gl: GLContext, mode: GLSettings.Model.DrawMode) {\n  switch (mode) {\n    case GLSettings.Model.DrawMode.LINES:\n      return gl.LINES;\n    case GLSettings.Model.DrawMode.LINE_LOOP:\n      return gl.LINE_LOOP;\n    case GLSettings.Model.DrawMode.LINE_STRIP:\n      return gl.LINE_STRIP;\n    case GLSettings.Model.DrawMode.POINTS:\n      return gl.POINTS;\n    case GLSettings.Model.DrawMode.TRIANGLES:\n      return gl.TRIANGLES;\n    case GLSettings.Model.DrawMode.TRIANGLE_FAN:\n      return gl.TRIANGLE_FAN;\n    case GLSettings.Model.DrawMode.TRIANGLE_STRIP:\n      return gl.TRIANGLE_STRIP;\n\n    default:\n      return gl.TRIANGLES;\n  }\n}\n\n/**\n * Decodes the TexelDataType to a GL setting\n */\nexport function texelFormat(\n  gl: GLContext,\n  format: GLSettings.Texture.TexelDataType\n) {\n  switch (format) {\n    case GLSettings.Texture.TexelDataType.Alpha:\n      return gl.ALPHA;\n    case GLSettings.Texture.TexelDataType.DepthComponent:\n      return gl.DEPTH_COMPONENT;\n    case GLSettings.Texture.TexelDataType.DepthStencil:\n      return gl.DEPTH_STENCIL;\n    case GLSettings.Texture.TexelDataType.Luminance:\n      return gl.LUMINANCE;\n    case GLSettings.Texture.TexelDataType.LuminanceAlpha:\n      return gl.LUMINANCE_ALPHA;\n    case GLSettings.Texture.TexelDataType.RGB:\n      return gl.RGB;\n    case GLSettings.Texture.TexelDataType.RGBA:\n      return gl.RGBA;\n\n    default:\n      console.warn(\"An Unsupported texel format was provided\", format);\n      return gl.RGBA;\n  }\n}\n\n/**\n * Decodes the SourcePixelFormat to a GL setting\n */\nexport function inputImageFormat(\n  gl: GLContext,\n  format: GLSettings.Texture.SourcePixelFormat\n) {\n  switch (format) {\n    case GLSettings.Texture.SourcePixelFormat.Byte:\n      return gl.BYTE;\n    case GLSettings.Texture.SourcePixelFormat.Float:\n      return gl.FLOAT;\n    case GLSettings.Texture.SourcePixelFormat.HalfFloat:\n      console.warn(\"Unsupported HALF_FLOAT\");\n      return gl.BYTE;\n    case GLSettings.Texture.SourcePixelFormat.Int:\n      return gl.INT;\n    case GLSettings.Texture.SourcePixelFormat.Short:\n      return gl.SHORT;\n    case GLSettings.Texture.SourcePixelFormat.UnsignedByte:\n      return gl.UNSIGNED_BYTE;\n    case GLSettings.Texture.SourcePixelFormat.UnsignedInt:\n      return gl.UNSIGNED_INT;\n    case GLSettings.Texture.SourcePixelFormat.UnsignedShort:\n      return gl.UNSIGNED_SHORT;\n    case GLSettings.Texture.SourcePixelFormat.UnsignedShort_4_4_4_4:\n      return gl.UNSIGNED_SHORT_4_4_4_4;\n    case GLSettings.Texture.SourcePixelFormat.UnsignedShort_5_5_5_1:\n      return gl.UNSIGNED_SHORT_5_5_5_1;\n    case GLSettings.Texture.SourcePixelFormat.UnsignedShort_5_6_5:\n      return gl.UNSIGNED_SHORT_5_6_5;\n\n    default:\n      console.warn(\"An Unsupported input image format was provided\", format);\n      return gl.BYTE;\n  }\n}\n\n/**\n * Decodes TextureMagFilter to a GL setting\n */\nexport function magFilter(\n  gl: GLContext,\n  filter: GLSettings.Texture.TextureMagFilter,\n  isPowerOf2: boolean\n) {\n  if (!isPowerOf2) {\n    return gl.LINEAR;\n  }\n\n  switch (filter) {\n    case GLSettings.Texture.TextureMagFilter.Linear:\n      return gl.LINEAR;\n    case GLSettings.Texture.TextureMagFilter.Nearest:\n      return gl.NEAREST;\n  }\n}\n\n/**\n * Decodes TextureMinFilter to a GL setting\n */\nexport function minFilter(\n  gl: GLContext,\n  filter: GLSettings.Texture.TextureMinFilter,\n  isPowerOf2: boolean,\n  hasMipMaps: boolean\n) {\n  if (!isPowerOf2) {\n    return gl.LINEAR;\n  }\n\n  switch (filter) {\n    case GLSettings.Texture.TextureMinFilter.Linear:\n      return gl.LINEAR;\n    case GLSettings.Texture.TextureMinFilter.Nearest:\n      return gl.NEAREST;\n    case GLSettings.Texture.TextureMinFilter.LinearMipMapLinear:\n      return hasMipMaps ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR;\n    case GLSettings.Texture.TextureMinFilter.LinearMipMapNearest:\n      return hasMipMaps ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR;\n    case GLSettings.Texture.TextureMinFilter.NearestMipMapLinear:\n      return hasMipMaps ? gl.NEAREST_MIPMAP_LINEAR : gl.NEAREST;\n    case GLSettings.Texture.TextureMinFilter.NearestMipMapNearest:\n      return hasMipMaps ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST;\n\n    default:\n      return gl.LINEAR;\n  }\n}\n\n/**\n * Decodes a ColorBufferFormat to valid color render buffer storage formats\n */\nexport function colorBufferFormat(\n  gl: GLContext,\n  format: GLSettings.RenderTarget.ColorBufferFormat\n) {\n  switch (format) {\n    case GLSettings.RenderTarget.ColorBufferFormat.RGB565:\n      return gl.RGB565;\n    case GLSettings.RenderTarget.ColorBufferFormat.RGB5_A1:\n      return gl.RGB5_A1;\n    case GLSettings.RenderTarget.ColorBufferFormat.RGBA4:\n      return gl.RGBA4;\n\n    default:\n      return gl.RGBA4;\n  }\n}\n\n/**\n * Decodes a DepthBufferFormat to valid color depth buffer storage formats\n */\nexport function depthBufferFormat(\n  gl: GLContext,\n  format: GLSettings.RenderTarget.DepthBufferFormat\n) {\n  switch (format) {\n    case GLSettings.RenderTarget.DepthBufferFormat.DEPTH_COMPONENT16:\n      return gl.DEPTH_COMPONENT16;\n    case GLSettings.RenderTarget.DepthBufferFormat.DEPTH_STENCIL:\n      return gl.DEPTH_STENCIL;\n\n    default:\n      return gl.DEPTH_COMPONENT16;\n  }\n}\n\n/**\n * Decodes a StencilBufferFormat to valid stencil render buffer storage formats\n */\nexport function stencilBufferFormat(\n  gl: GLContext,\n  format: GLSettings.RenderTarget.StencilBufferFormat\n) {\n  switch (format) {\n    case GLSettings.RenderTarget.StencilBufferFormat.STENCIL_INDEX8:\n      return gl.STENCIL_INDEX8;\n\n    default:\n      return gl.STENCIL_INDEX8;\n  }\n}\n\n/**\n * Decodes Wrapping to a GL setting\n */\nexport function wrapMode(gl: GLContext, mode: GLSettings.Texture.Wrapping) {\n  switch (mode) {\n    case GLSettings.Texture.Wrapping.CLAMP_TO_EDGE:\n      return gl.CLAMP_TO_EDGE;\n    case GLSettings.Texture.Wrapping.MIRRORED_REPEAT:\n      return gl.MIRRORED_REPEAT;\n    case GLSettings.Texture.Wrapping.REPEAT:\n      return gl.REPEAT;\n  }\n}\n\n/**\n * Decodes an index to an appropriate color attachment for a frame buffer\n */\nexport function indexToColorAttachment(\n  gl: GLContext,\n  extensions: IExtensions,\n  index: number,\n  isSingleBuffer: boolean\n) {\n  if (isSingleBuffer) {\n    return gl.COLOR_ATTACHMENT0;\n  }\n\n  const glExt = extensions.drawBuffers;\n\n  if (glExt instanceof WebGL2RenderingContext) {\n    switch (index) {\n      case 0:\n        return glExt.COLOR_ATTACHMENT0;\n      case 1:\n        return glExt.COLOR_ATTACHMENT1;\n      case 2:\n        return glExt.COLOR_ATTACHMENT2;\n      case 3:\n        return glExt.COLOR_ATTACHMENT3;\n      case 4:\n        return glExt.COLOR_ATTACHMENT4;\n      case 5:\n        return glExt.COLOR_ATTACHMENT5;\n      case 6:\n        return glExt.COLOR_ATTACHMENT6;\n      case 7:\n        return glExt.COLOR_ATTACHMENT7;\n      case 8:\n        return glExt.COLOR_ATTACHMENT8;\n      case 9:\n        return glExt.COLOR_ATTACHMENT9;\n      case 10:\n        return glExt.COLOR_ATTACHMENT10;\n      case 11:\n        return glExt.COLOR_ATTACHMENT11;\n      case 12:\n        return glExt.COLOR_ATTACHMENT12;\n      case 13:\n        return glExt.COLOR_ATTACHMENT13;\n      case 14:\n        return glExt.COLOR_ATTACHMENT14;\n      case 15:\n        return glExt.COLOR_ATTACHMENT15;\n    }\n  } else if (glExt) {\n    switch (index) {\n      case 0:\n        return glExt.COLOR_ATTACHMENT0_WEBGL;\n      case 1:\n        return glExt.COLOR_ATTACHMENT1_WEBGL;\n      case 2:\n        return glExt.COLOR_ATTACHMENT2_WEBGL;\n      case 3:\n        return glExt.COLOR_ATTACHMENT3_WEBGL;\n      case 4:\n        return glExt.COLOR_ATTACHMENT4_WEBGL;\n      case 5:\n        return glExt.COLOR_ATTACHMENT5_WEBGL;\n      case 6:\n        return glExt.COLOR_ATTACHMENT6_WEBGL;\n      case 7:\n        return glExt.COLOR_ATTACHMENT7_WEBGL;\n      case 8:\n        return glExt.COLOR_ATTACHMENT8_WEBGL;\n      case 9:\n        return glExt.COLOR_ATTACHMENT9_WEBGL;\n      case 10:\n        return glExt.COLOR_ATTACHMENT10_WEBGL;\n      case 11:\n        return glExt.COLOR_ATTACHMENT11_WEBGL;\n      case 12:\n        return glExt.COLOR_ATTACHMENT12_WEBGL;\n      case 13:\n        return glExt.COLOR_ATTACHMENT13_WEBGL;\n      case 14:\n        return glExt.COLOR_ATTACHMENT14_WEBGL;\n      case 15:\n        return glExt.COLOR_ATTACHMENT15_WEBGL;\n    }\n  }\n\n  return gl.COLOR_ATTACHMENT0;\n}\n\n/**\n * Maps an index to a texture units Enum key to use on a WebGLRenderingContext object\n */\nexport function indexToTextureUnit(gl: GLContext, index: number) {\n  // This is the proper conversion instead of unsing the built in enums. The indices\n  // are controlled via gl.max_texture_image_units. This number can be higher than\n  // the enums indicate.\n  return gl.TEXTURE0 + index;\n}\n\n/**\n * Maps a texture unit to an index that can be used for a uniform.\n */\nexport function textureUnitToIndex(gl: GLContext, unit: number) {\n  // This is the proper conversion instead of unsing the built in enums. The indices\n  // are controlled via gl.max_texture_image_units. This number can be higher than\n  // the enums indicate.\n  return unit - gl.TEXTURE0;\n}\n","import {\n  concat4x4,\n  identity4,\n  inverse3,\n  lookAtQuat,\n  Mat4x4,\n  matrix4x4FromUnitQuatModel,\n  matrix4x4FromUnitQuatView,\n  multiply4x4,\n  oneQuat,\n  Quaternion,\n  scale3,\n  scale4x4by3,\n  subtract3,\n  translation4x4by3,\n  Vec3\n} from \"../../math\";\n\n/**\n * This is a wrapper for a 3D matrix for transforming coordinates from one vector space to another. Follows the order\n * of ISROT: Identity, Scale, Rotation, Origin, Translation. However, this only provides the SRT properties for simpler\n * affine transforms.\n */\nexport class Transform {\n  /**\n   * Flag indicating this transform has changed properties. Will remain in a changed state until the transform has it's\n   * resolve() called.\n   */\n  get changed() {\n    return this._changed;\n  }\n  private _changed: boolean = false;\n  /** Flag that indicates if the transform needs to be updated */\n  private needsUpdate: boolean = false;\n  /**\n   * Flag that indicates this transform has a matrix that performs the operations in reverse (such as for a camera.)\n   */\n  private hasViewMatrix: boolean = false;\n\n  /**\n   * This is the inner matrix that represents the culmination of all the properties into a single transform matrix. It\n   * is invalid and will cause undefined behavior if the elements of this matrix are modified. You should use the\n   * provided methods of this Transform class to manipulate this matrix.\n   */\n  get matrix(): Mat4x4 {\n    this.update();\n    return this._matrix;\n  }\n  private _matrix: Mat4x4 = identity4();\n\n  /**\n   * This is the transform matrix that contains the operations in reverse order. This produces a 'view matrix' for the\n   * transform and shouldn't be considered an inverse matrix.\n   */\n  get viewMatrix(): Mat4x4 {\n    this.hasViewMatrix = true;\n    if (!this._viewMatrix) this.needsUpdate = true;\n    this.update();\n    if (!this._viewMatrix) return identity4();\n    return this._viewMatrix;\n  }\n  private _viewMatrix?: Mat4x4;\n\n  /** Orientation of this transform */\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(val: Quaternion) {\n    this._rotation = val;\n    this.needsUpdate = true;\n    this.needsRotationUpdate = true;\n    this._changed = true;\n  }\n  private _rotation: Quaternion = oneQuat();\n  private rotationMatrix: Mat4x4 = identity4();\n  private needsRotationUpdate: boolean = false;\n\n  /** Scaling transform of this matrix */\n  get scale() {\n    return this._scale;\n  }\n  set scale(val: Vec3) {\n    this._scale = val;\n    this.needsUpdate = true;\n    this.needsScaleUpdate = true;\n    this._changed = true;\n  }\n  private _scale: Vec3 = [1, 1, 1];\n  private scaleMatrix: Mat4x4 = identity4();\n  private needsScaleUpdate = false;\n\n  /** Translation of this transform */\n  get position() {\n    return this._translation;\n  }\n  set position(val: Vec3) {\n    this._translation = val;\n    this.needsUpdate = true;\n    this.needsTranslationUpdate = true;\n    this._changed = true;\n  }\n  private _translation: Vec3 = [0, 0, 0];\n  private translationMatrix: Mat4x4 = identity4();\n  private needsTranslationUpdate: boolean = false;\n\n  /**\n   * Orients this transform to make the forward direction point toward another position.\n   */\n  lookAt(position: Vec3, up: Vec3) {\n    this.rotation = lookAtQuat(subtract3(position, this._translation), up);\n  }\n\n  /**\n   * Used by the system to indicate all changes for the transform are resolved, thus putting this transform into a\n   * settled state. Unresolved transforms can trigger updates in other parts of the system.\n   */\n  resolve() {\n    this._changed = false;\n  }\n\n  /**\n   * If needed, this updates the matrix for this transform. This is called automatically when the matrix is retrieved.\n   */\n  update() {\n    if (!this.needsUpdate) return;\n\n    const S = this.scaleMatrix;\n\n    if (this.needsScaleUpdate) {\n      this.needsScaleUpdate = false;\n      scale4x4by3(this._scale, S);\n    }\n\n    const R = this.rotationMatrix;\n\n    if (this.needsRotationUpdate) {\n      this.needsRotationUpdate = false;\n      matrix4x4FromUnitQuatModel(this._rotation, R);\n    }\n\n    const T = this.translationMatrix;\n\n    if (this.needsTranslationUpdate) {\n      this.needsTranslationUpdate = false;\n      translation4x4by3(this._translation, T);\n    }\n\n    // Concat the SRT transform in this order Scale -> Rotation -> Translation\n    // We utilize our existing matrix to reduce redundant allocations of matrix information.\n    multiply4x4(T, multiply4x4(R, S, this._matrix), this._matrix);\n\n    if (this.hasViewMatrix) {\n      if (!this._viewMatrix) this._viewMatrix = identity4();\n      // When generating this transform, it is important to remember that when you envision the camera looking at\n      // something, everything else is in the exact opposite orientation to the camera.\n      // Remember: this view matrix gets APPLIED to geometry to orient it correclty to the camera.\n      // Thus the world is being moved for the sake of the camera, the camera itself is not moving.\n      // THUS: all operations to make this matrix will be the INVERSE of where the camera is physically located and\n      // oriented\n      concat4x4(\n        this._viewMatrix,\n        // The world looks at the camera. The camera does not look at the world\n        matrix4x4FromUnitQuatView(this._rotation),\n        // The world moves to align itself with the camera's position\n        translation4x4by3(scale3(this._translation, -1)),\n        // The world condenses and expands to fit the camera\n        scale4x4by3(inverse3(this._scale))\n      );\n    }\n\n    this.needsUpdate = false;\n  }\n}\n\nexport const IdentityTransform: Readonly<Transform> = new Transform();\n","import { InstanceIOValue } from \"../types\";\nimport { uid } from \"../util/uid\";\nimport { isVec4, Vec, VecMath } from \"./vector\";\n\nconst { min, max, pow, round, sin, PI } = Math;\nconst GPU_PI = round(PI * 1000) / 1000;\n\nfunction clamp(x: number, minVal: number, maxVal: number) {\n  return min(max(x, minVal), maxVal);\n}\n\nexport enum AutoEasingLoopStyle {\n  /** Time will go from 0 -> 1 then stop at 1 */\n  NONE = 1,\n  /** Time will go from 0 -> infinity */\n  CONTINUOUS = 4,\n  /** Time will continuously go 0 -> 1 then 0 -> 1 then 0 -> 1 etc etc */\n  REPEAT = 2,\n  /** Time will continously go 0 -> 1 then 1 -> 0 then 0 -> 1 then 1 -> 0 etc etc */\n  REFLECT = 3\n}\n\n/**\n * This defines a GPU enabled easing method that will be executed on the GPU to maneuver\n *\n */\nexport interface IAutoEasingMethod<T extends InstanceIOValue> {\n  /** An easing method that should produce IDENTICAL values to the values of the gpu easing method using the exact same parameters */\n  cpu(start: T, end: T, t: number, out?: T): T;\n  /** This adds a delay to the starting time of an easing change */\n  delay: number;\n  /** This is how long the easing method should last */\n  duration: number;\n  /**\n   * An easing method written in shader language that should produce IDENTICAL\n   * values to the values of the cpu easing method using the exact same parameters.\n   */\n  gpu: string;\n  /**\n   * This defines the looping style of the easing.\n   */\n  loop: AutoEasingLoopStyle;\n  /**\n   * This shall be the name of the easing method as it appears in the spu shader.\n   * BE WARNED: This name is used to dedup the methods created on the shader. So,\n   * if you use the same name as another ease method used on a single layer, you run\n   * the risk of one overriding the other with an undefined chance of who wins.\n   */\n  methodName: string;\n  /**\n   * A unique identifier for the auto easing method.\n   */\n  uid: number;\n\n  /**\n   * This lets you modify some auto easing validation rules.\n   */\n  validation?: {\n    ignoreEndValueCheck?: boolean;\n    ignoreOverTimeCheck?: boolean;\n  };\n}\n\n// GPU easing methods! Written here because it's cleaner to write `` style strings\n// Against the left side of the editor\n\nconst immediateGPU = `\n$\\{easingMethod} {\n  return end;\n}\n`;\n\nconst linearGPU = `\n$\\{easingMethod} {\n  return (end - start) * t + start;\n}\n`;\n\nconst easeInQuadGPU = `\n$\\{easingMethod} {\n  float time = t * t;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeOutQuadGPU = `\n$\\{easingMethod} {\n  float time = t * (2.0 - t);\n  return (end - start) * time + start;\n}\n`;\n\nconst easeInOutQuadGPU = `\n$\\{easingMethod} {\n  float time = t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeInCubicGPU = `\n$\\{easingMethod} {\n  float time = t * t * t;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeOutCubicGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = t1 * t1 * t1 + 1.0;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeInOutCubicGPU = `\n$\\{easingMethod} {\n  float time = t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeInQuartGPU = `\n$\\{easingMethod} {\n  float time = t * t * t * t;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeOutQuartGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = 1.0 - t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeInOutQuartGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = t < 0.5 ? 8.0 * t * t * t * t : 1.0 - 8.0 * t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeInQuintGPU = `\n$\\{easingMethod} {\n  float time = t * t * t * t * t;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeOutQuintGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = 1.0 + t1 * t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeInOutQuintGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = t < 0.5 ? 16.0 * t * t * t * t * t : 1.0 + 16.0 * t1 * t1 * t1 * t1 * t1;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeOutElasticGPU = `\n$\\{easingMethod} {\n  float p = 0.3;\n  float time = pow(2.0, -10.0 * t) * sin((t - p / 4.0) * (2.0 * ${GPU_PI}) / p) + 1.0;\n  return (end - start) * time + start;\n}\n`;\n\nconst easeBackInGPU = `\n$\\{easingMethod} {\n  float time = t * t * t - t * 1.05 * sin(t * ${GPU_PI});\n  return (end - start) * time + start;\n}\n`;\n\nconst easeBackOutGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float a = 1.7;\n  float time = (t1 * t1 * ((a + 1.0) * t1 + a) + 1.0);\n  return (end - start) * time + start;\n}\n`;\n\nconst easeBackInOutGPU = `\n$\\{easingMethod} {\n  float a = 1.4;\n  float a1 = a * 1.525;\n  float t1 = t / 0.5;\n  float t2 = t1 - 2.0;\n  float time =\n    (t1 < 1.0) ? 0.5 * (t1 * t1 * (a1 + 1.0) * t1 - a1) :\n    0.5 * (t2 * t2 * ((a1 + 1.0) * t2 + a1) + 2.0)\n  ;\n\n  return (end - start) * time + start;\n}\n`;\n\nconst continuousSinusoidalGPU = `\n$\\{easingMethod} {\n  $\\{T} direction = end - start;\n  return start + direction * 0.5 + direction * sin(t * ${GPU_PI} * 2.0) * 0.5;\n}\n`;\n\nconst slerpQuatLinearGPU = `\n$\\{easingMethod} {\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - t, t),\n    vec2(sin((1.0 - t) * omega) / sinom, sin(t * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end;\n}\n`;\n\nconst slerpQuatInQuadGPU = `\n$\\{easingMethod} {\n  float time = t * t;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end;\n}\n`;\n\nconst slerpQuatOutQuadGPU = `\n$\\{easingMethod} {\n  float time = t * (2.0 - t);\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end;\n}\n`;\n\nconst slerpQuatInOutQuadGPU = `\n$\\{easingMethod} {\n  float time = t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end;\n}\n`;\n\nconst slerpQuatInCubicGPU = `\n$\\{easingMethod} {\n  float time = t * t * t;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end;\n}\n`;\n\nconst slerpQuatOutCubicGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = t1 * t1 * t1 + 1.0;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end;\n}\n`;\n\nconst slerpQuatInOutCubicGPU = `\n$\\{easingMethod} {\n  float time = t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end;\n}\n`;\n\nconst slerpQuatInQuartGPU = `\n$\\{easingMethod} {\n  float time = t * t * t * t;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end;\n}\n`;\n\nconst slerpQuatOutQuartGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = 1.0 - t1 * t1 * t1 * t1;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end;\n}\n`;\n\nconst slerpQuatInOutQuartGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = t < 0.5 ? 8.0 * t * t * t * t : 1.0 - 8.0 * t1 * t1 * t1 * t1;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end;\n}\n`;\n\nconst slerpQuatInQuintGPU = `\n$\\{easingMethod} {\n  float time = t * t * t * t * t;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end;\n}\n`;\n\nconst slerpQuatOutQuintGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = 1.0 + t1 * t1 * t1 * t1 * t1;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end;\n}\n`;\n\nconst slerpQuatInOutQuintGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float time = t < 0.5 ? 16.0 * t * t * t * t * t : 1.0 + 16.0 * t1 * t1 * t1 * t1 * t1;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end;\n}\n`;\n\nconst slerpQuatOutElasticGPU = `\n$\\{easingMethod} {\n  float p = 0.3;\n  float time = pow(2.0, -10.0 * t) * sin((t - p / 4.0) * (2.0 * ${GPU_PI}) / p) + 1.0;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end;\n}\n`;\n\nconst slerpQuatBackInGPU = `\n$\\{easingMethod} {\n  float time = t * t * t - t * 1.05 * sin(t * ${GPU_PI});\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end;\n}\n`;\n\nconst slerpQuatBackOutGPU = `\n$\\{easingMethod} {\n  float t1 = t - 1.0;\n  float a = 1.7;\n  float time = (t1 * t1 * ((a + 1.0) * t1 + a) + 1.0);\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end;\n}\n`;\n\nconst slerpQuatBackInOutGPU = `\n$\\{easingMethod} {\n  float a = 1.4;\n  float a1 = a * 1.525;\n  float t1 = t / 0.5;\n  float t2 = t1 - 2.0;\n  float time =\n    (t1 < 1.0) ? 0.5 * (t1 * t1 * (a1 + 1.0) * t1 - a1) :\n    0.5 * (t2 * t2 * ((a1 + 1.0) * t2 + a1) + 2.0)\n  ;\n  float cosom = dot(start, end);\n  $\\{T} end1 = mix(end, -end, float(cosom < 0.0));\n  cosom = mix(cosom, -cosom, float(cosom < 0.0));\n\n  float omega = acos(cosom);\n  float sinom = sin(omega);\n\n  vec2 scale = mix(\n    vec2(1.0 - time, time),\n    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),\n    float(1.0 - cosom > 0.0000001)\n  );\n\n  return scale.x * start + scale.y * end;\n}\n`;\n\n/**\n * Class of base AutoEasingMethods as well as helper constructs for making the methods.\n */\nexport class AutoEasingMethod<T extends InstanceIOValue>\n  implements IAutoEasingMethod<T> {\n  /**\n   * Autoeasing methods for linear easing\n   */\n  static immediate<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, _t: number, out?: T) => {\n        const { copy } = VecMath(start);\n        return copy(end, out);\n      },\n      delay,\n      duration,\n      gpu: immediateGPU,\n      loop,\n      methodName: \"immediate\"\n    };\n  }\n\n  /**\n   * Autoeasing methods for linear easing\n   */\n  static linear<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        const { add, scale, subtract } = VecMath(start);\n        t = clamp(t, 0, 1);\n        return add(scale(subtract(end, start), t), start, out);\n      },\n      delay,\n      duration,\n      gpu: linearGPU,\n      loop,\n      methodName: \"linear\"\n    };\n  }\n\n  /**\n   * Auto easing for Accelerating to end\n   */\n  static easeInQuad<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeInQuadGPU,\n      loop,\n      methodName: \"easeInQuad\"\n    };\n  }\n\n  /**\n   * Auto easing for decelerating to end\n   */\n  static easeOutQuad<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = t * (2 - t);\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeOutQuadGPU,\n      loop,\n      methodName: \"easeOutQuad\"\n    };\n  }\n\n  /**\n   * Auto easing for Accelerate to mid, then decelerate to end\n   */\n  static easeInOutQuad<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeInOutQuadGPU,\n      loop,\n      methodName: \"easeInOutQuad\"\n    };\n  }\n\n  /**\n   * Auto easing for Slower acceleration\n   */\n  static easeInCubic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeInCubicGPU,\n      loop,\n      methodName: \"easeInCubic\"\n    };\n  }\n\n  /**\n   * Auto easing for Slower deceleration\n   */\n  static easeOutCubic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = --t * t * t + 1;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeOutCubicGPU,\n      loop,\n      methodName: \"easeOutCubic\"\n    };\n  }\n\n  /**\n   * Auto easing for Slower acceleration to mid, and slower deceleration to end\n   */\n  static easeInOutCubic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time =\n          t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeInOutCubicGPU,\n      loop,\n      methodName: \"easeInOutCubic\"\n    };\n  }\n\n  /**\n   * Auto easing for even Slower acceleration to end\n   */\n  static easeInQuart<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeInQuartGPU,\n      loop,\n      methodName: \"easeInQuart\"\n    };\n  }\n\n  /**\n   * Auto easing for even Slower deceleration to end\n   */\n  static easeOutQuart<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = 1 - --t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeOutQuartGPU,\n      loop,\n      methodName: \"easeOutQuart\"\n    };\n  }\n\n  /**\n   * Auto easing for even Slower acceleration to mid, and even slower deceleration to end\n   */\n  static easeInOutQuart<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeInOutQuartGPU,\n      loop,\n      methodName: \"easeInOutQuart\"\n    };\n  }\n\n  /**\n   * Auto easing for super slow accelerating to the end\n   */\n  static easeInQuint<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = t * t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeInQuintGPU,\n      loop,\n      methodName: \"easeInQuint\"\n    };\n  }\n\n  /**\n   * Auto easing for super slow decelerating to the end\n   */\n  static easeOutQuint<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time = 1 + --t * t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeOutQuintGPU,\n      loop,\n      methodName: \"easeOutQuint\"\n    };\n  }\n\n  /**\n   * Auto easing for super slow accelerating to mid and super slow decelerating to the end\n   */\n  static easeInOutQuint<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const time =\n          t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeInOutQuintGPU,\n      loop,\n      methodName: \"easeInOutQuint\"\n    };\n  }\n\n  /**\n   * Auto easing for elastic effect\n   */\n  static easeOutElastic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const p = 0.3;\n        const time = pow(2, -10 * t) * sin(((t - p / 4) * (2 * PI)) / p) + 1;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeOutElasticGPU,\n      loop,\n      methodName: \"easeOutElastic\"\n    };\n  }\n\n  /**\n   * Auto easing for retracting first then shooting to the end\n   */\n  static easeBackIn<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const a = 1.05;\n        const time = t * t * t - t * a * sin(t * PI);\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeBackInGPU,\n      loop,\n      methodName: \"easeBackIn\"\n    };\n  }\n\n  /**\n   * Auto easing for overshooting at the end\n   */\n  static easeBackOut<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const a = 1.7;\n        const t1 = t - 1;\n        const time = t1 * t1 * ((a + 1) * t1 + a) + 1;\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeBackOutGPU,\n      loop,\n      methodName: \"easeBackOut\"\n    };\n  }\n\n  /**\n   * Auto easing for overshooting at the end\n   */\n  static easeBackInOut<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        t = clamp(t, 0, 1);\n        const a = 1.7;\n        const a1 = a * 1.525;\n        const t1 = t / 0.5;\n        const t2 = t1 - 2;\n        const time =\n          t1 < 1\n            ? 0.5 * (t1 * t1 * (a1 + 1) * t1 - a1)\n            : 0.5 * (t2 * t2 * ((a1 + 1) * t2 + a1) + 2);\n        const { add, scale, subtract } = VecMath(start);\n        return add(scale(subtract(end, start), time), start, out);\n      },\n      delay,\n      duration,\n      gpu: easeBackInOutGPU,\n      loop,\n      methodName: \"easeBackInOut\"\n    };\n  }\n\n  /**\n   * This is an easing method that performs a sinusoidal wave where the amplitude is\n   * (start - end) * 2 and the wave starts at the start value.\n   *\n   * This is intended to work best with the CONTINUOUS loop style.\n   */\n  static continuousSinusoidal<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.CONTINUOUS\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        const { add, scale, subtract } = VecMath(start);\n        t = clamp(t, 0, 1);\n        const direction = subtract(end, start);\n        const halfDirection = scale(direction, 0.5);\n        // const amplitude = length(direction) * 2.0;\n        return add(\n          add(start, halfDirection),\n          scale(halfDirection, sin(t * PI * 2) * 1.0),\n          out\n        );\n      },\n      delay,\n      duration,\n      gpu: continuousSinusoidalGPU,\n      loop,\n      methodName: \"repeatingSinusoidal\",\n\n      // Since this is sinusoidial and operates off of a continuous time structure\n      validation: {\n        // When time = 1 our value will = start and NOT end\n        ignoreEndValueCheck: true,\n        // When the time is > 1 our value will not clamp to the value at 1.\n        ignoreOverTimeCheck: true\n      }\n    };\n  }\n\n  static slerpQuatLinear<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n\n        t = clamp(t, 0, 1);\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, t, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatLinearGPU,\n      loop,\n      methodName: \"slerpQuatLinear\"\n    };\n  }\n\n  static slerpQuatInQuad<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = t * t;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatInQuadGPU,\n      loop,\n      methodName: \"slerpQuatInQuad\"\n    };\n  }\n\n  static slerpQuatOutQuad<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = t * (2 - t);\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatOutQuadGPU,\n      loop,\n      methodName: \"slerpQuatOutQuad\"\n    };\n  }\n\n  static slerpQuatInOutQuad<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatInOutQuadGPU,\n      loop,\n      methodName: \"slerpQuatInOutQuad\"\n    };\n  }\n\n  static slerpQuatInCubic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = t * t * t;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatInCubicGPU,\n      loop,\n      methodName: \"slerpQuatInCubic\"\n    };\n  }\n\n  static slerpQuatOutCubic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = --t * t * t + 1;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatOutCubicGPU,\n      loop,\n      methodName: \"slerpQuatOutCubic\"\n    };\n  }\n\n  static slerpQuatInOutCubic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time =\n          t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatInOutCubicGPU,\n      loop,\n      methodName: \"slerpQuatInOutCubic\"\n    };\n  }\n\n  static slerpQuatInQuart<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = t * t * t * t;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatInQuartGPU,\n      loop,\n      methodName: \"slerpQuatInQuart\"\n    };\n  }\n\n  static slerpQuatOutQuart<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = 1 - --t * t * t * t;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatOutQuartGPU,\n      loop,\n      methodName: \"slerpQuatOutQuart\"\n    };\n  }\n\n  static slerpQuatInOutQuart<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatInOutQuartGPU,\n      loop,\n      methodName: \"slerpQuatInOutQuart\"\n    };\n  }\n\n  static slerpQuatInQuint<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = t * t * t * t * t;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatInQuintGPU,\n      loop,\n      methodName: \"slerpQuatInQuint\"\n    };\n  }\n\n  static slerpQuatOutQuint<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time = 1 + --t * t * t * t * t;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatOutQuintGPU,\n      loop,\n      methodName: \"slerpQuatOutQuint\"\n    };\n  }\n\n  static slerpQuatInOutQuint<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const time =\n          t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatInOutQuintGPU,\n      loop,\n      methodName: \"slerpQuatInOutQuint\"\n    };\n  }\n\n  static slerpQuatOutElastic<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const p = 0.3;\n        const time = pow(2, -10 * t) * sin(((t - p / 4) * (2 * PI)) / p) + 1;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatOutElasticGPU,\n      loop,\n      methodName: \"slerpQuatOutElastic\"\n    };\n  }\n\n  static slerpQuatBackIn<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const a = 1.05;\n        const time = t * t * t - t * a * sin(t * PI);\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatBackInGPU,\n      loop,\n      methodName: \"slerpQuatBackIn\"\n    };\n  }\n\n  static slerpQuatBackOut<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const a = 1.7;\n        const t1 = t - 1;\n        const time = t1 * t1 * ((a + 1) * t1 + a) + 1;\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatBackOutGPU,\n      loop,\n      methodName: \"slerpQuatBackOut\"\n    };\n  }\n\n  static slerpQuatBackInOut<T extends Vec>(\n    duration: number,\n    delay: number = 0,\n    loop = AutoEasingLoopStyle.NONE\n  ): IAutoEasingMethod<T> {\n    return {\n      uid: uid(),\n      cpu: (start: T, end: T, t: number, out?: T) => {\n        if (!isVec4(start) || !isVec4(end) || !isVec4(out)) {\n          const { vec } = VecMath(end);\n          console.warn(\n            \"SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements.\"\n          );\n          return vec(1, 0, 0, 0);\n        }\n        t = clamp(t, 0, 1);\n        const a = 1.7;\n        const a1 = a * 1.525;\n        const t1 = t / 0.5;\n        const t2 = t1 - 2;\n        const time =\n          t1 < 1\n            ? 0.5 * (t1 * t1 * (a1 + 1) * t1 - a1)\n            : 0.5 * (t2 * t2 * ((a1 + 1) * t2 + a1) + 2);\n        const { slerpQuat, vec } = VecMath(start);\n        if (!slerpQuat) return vec(1, 0, 0, 0);\n        return slerpQuat(start, end, time, out);\n      },\n      delay,\n      duration,\n      gpu: slerpQuatBackInOutGPU,\n      loop,\n      methodName: \"slerpQuatBackInOut\"\n    };\n  }\n\n  /** A uid for the easing method */\n  uid = uid();\n  /** The easing method for the cpu */\n  cpu: IAutoEasingMethod<T>[\"cpu\"];\n  /** Time before a delay  */\n  delay: number = 0;\n  /** The time in ms is takes to complete the animation */\n  duration: number = 500;\n  /** The easing method on the GPU */\n  gpu: IAutoEasingMethod<T>[\"gpu\"];\n  /** The looping style of the animation */\n  loop = AutoEasingLoopStyle.NONE;\n  /** Method name of the ease function on the gpu */\n  methodName: string;\n\n  constructor(\n    cpu: IAutoEasingMethod<T>[\"cpu\"],\n    gpu: IAutoEasingMethod<T>[\"gpu\"],\n    duration?: number,\n    method?: string\n  ) {\n    this.cpu = cpu;\n    this.gpu = gpu;\n    this.duration = duration || 500;\n    this.methodName = method || \"easingMethod\";\n  }\n}\n","import { uid } from \"../util/uid\";\nimport { Bounds } from \"./primitives/bounds\";\nimport { apply2, Vec2, Vec2Compat } from \"./vector\";\n\n/**\n * This object expresses a suite of methods that aids in projecting values from screen to world and vice versa.\n * These methods can be implemented in many ways and should be customized to a view + camera configuration.\n */\nexport abstract class BaseProjection<T> {\n  /** Provides a numerical UID for this object */\n  get uid() {\n    return this._uid;\n  }\n  private _uid: number = uid();\n  /** Allows for a sensical identifier to be applied to this projection. */\n  id: string = \"\";\n\n  /** This is set to ensure the projections that happen properly translates the pixel ratio to normal Web coordinates */\n  pixelRatio: number = 1;\n  /** This is the rendering bounds within screen space */\n  screenBounds: Bounds<T>;\n  /**\n   * The bounds of the render space on the canvas this view will render on. This is the size of the render space within\n   * the context so this will include the pixelRatio as needed.\n   */\n  viewBounds: Bounds<T>;\n\n  /**\n   * This projects a point to be relative to the rendering dimensions of the view.\n   */\n  screenToRenderSpace(point: Vec2, out?: Vec2) {\n    out = this.screenToView(point, out);\n\n    return apply2(out, point[0] * this.pixelRatio, point[1] * this.pixelRatio);\n  }\n\n  /**\n   * This projects a point relative to the render space of the view to the screen coordinates\n   */\n  renderSpaceToScreen(point: Vec2, out?: Vec2) {\n    out = out || [0, 0];\n\n    return apply2(\n      out,\n      point[0] / this.pixelRatio - this.screenBounds.x,\n      point[1] / this.pixelRatio - this.screenBounds.y\n    );\n  }\n\n  /**\n   * Takes a coordinate in screen coordinates and maps it to a point that is relative to a view's viewport on\n   * the screen.\n   */\n  screenToView(point: Vec2, out?: Vec2) {\n    out = out || [0, 0];\n\n    return apply2(\n      out,\n      point[0] - this.screenBounds.x,\n      point[1] - this.screenBounds.y\n    );\n  }\n\n  /**\n   * Takes a coordinate that is relative to a view's viewport within the screen and maps it to a coordinate relative to\n   * the screen.\n   */\n  viewToScreen(point: Vec2, out?: Vec2) {\n    out = out || [0, 0];\n\n    return apply2(\n      out,\n      point[0] + this.screenBounds.x,\n      point[1] + this.screenBounds.y\n    );\n  }\n\n  /**\n   * Maps a coordinate relative to the screen to a coordinate found within the world space.\n   */\n  abstract screenToWorld(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n\n  /**\n   * Maps a coordinate found within the world to a relative coordinate within the screen space.\n   */\n  abstract worldToScreen(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n\n  /**\n   * Maps a coordinate relative to the view's viewport to a coordinate found within the world.\n   */\n  abstract viewToWorld(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n\n  /**\n   * Maps a coordinate found within the world to a relative coordinate within the view's viewport.\n   */\n  abstract worldToView(point: Vec2Compat, out?: Vec2Compat): Vec2Compat;\n}\n\n/**\n * This is an implementation of the BaseProjection with the abstract methods implmented but not functional\n */\nexport class SimpleProjection extends BaseProjection<any> {\n  screenToWorld(point: Vec2Compat, _out?: Vec2Compat): Vec2Compat {\n    return point;\n  }\n\n  worldToScreen(point: Vec2Compat, _out?: Vec2Compat): Vec2Compat {\n    return point;\n  }\n\n  viewToWorld(point: Vec2Compat, _out?: Vec2Compat): Vec2Compat {\n    return point;\n  }\n\n  worldToView(point: Vec2Compat, _out?: Vec2Compat): Vec2Compat {\n    return point;\n  }\n}\n","export * from \"./absolute-position\";\nexport * from \"./bounds\";\n","import { GLSettings } from \"../gl/gl-settings\";\nimport { ILayerMaterialOptions } from \"../types\";\n\n/**\n * These are material options you may commonly see for handling various scenarios.\n */\nexport class CommonMaterialOptions {\n  /**\n   * Sets up blending for transparent shapes.\n   * Removes need for gl_FragColor.rgb *= gl_FragColor.a in shader.\n   */\n  static transparentShapeBlending: ILayerMaterialOptions = {\n    blending: {\n      blendDst: GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha,\n      blendEquation: GLSettings.Material.BlendingEquations.Add,\n      blendSrc: GLSettings.Material.BlendingSrcFactor.SrcAlpha\n    },\n    culling: GLSettings.Material.CullSide.NONE\n  };\n\n  /**\n   * Sets up blending for transparent images. This requires the image to be premultipled alpha.\n   * Removes need for texel.rgb *= texel.a; as it assumes the value is premultiplied.\n   */\n  static transparentImageBlending: ILayerMaterialOptions = {\n    blending: {\n      blendSrc: GLSettings.Material.BlendingSrcFactor.One,\n      blendDst: GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha,\n      blendEquation: GLSettings.Material.BlendingEquations.Add\n    },\n    culling: GLSettings.Material.CullSide.NONE\n  };\n}\n","import { PromiseResolver } from \"./promise-resolver\";\n\n/**\n * The structure of a command that can be injected into the queue. The time provided is the time the command was\n * executed. endTime is a time that can be used\n */\ntype Command = (t: number, endTime?: number) => void;\n\n/** This identifier is the base requestAnimationFrame id that is used to later stop the command queues completely */\nlet animationFrameId = -1;\n/** This is the current time last frame executed. */\nlet currentTime = 0;\n\n/** Contains the commands to be executed after the next animation cycle (ie- not this frame, but next frame) */\nlet nextQueuedCommands: Command[] = [];\n/** Contains the commands to be executed immediately on next animation cycle */\nlet immediateQueuedCommands: [Command, number, number][] = [];\n/** After a frame has passed, the next queued commands filter into this queue to be executed next frame */\nlet nextFrameCommands: Command[] = [];\n/** Commands that are going to be executed repeatedly on the animation loop. [Command, interval, intervalStartTime, duration, durationStartTime] */\nconst animationLoopCommands = new Map<\n  Promise<number>,\n  [Command, number, number, number, number]\n>();\n\n/**\n * Frame loop that executes queued commands\n */\nconst loop = (time: number) => {\n  currentTime = time;\n  let keepLooping = false;\n  const stopAnimationLoops: Promise<number>[] = [];\n\n  // Execute all of the animation loop commands\n  animationLoopCommands.forEach((command, id) => {\n    keepLooping = true;\n    let [\n      commandFn,\n      interval,\n      intervalStartTime,\n      duration,\n      durationStartTime\n    ] = command;\n\n    // Check to see if the command has a specified duration\n    if (duration !== -1) {\n      if (durationStartTime === -1) {\n        durationStartTime = time;\n        command[4] = time;\n      }\n\n      // If we've exceeded the duration, we fire the command one last guaranteed time and flag it for removal from\n      // the loop\n      if (time - durationStartTime >= duration) {\n        stopAnimationLoops.push(id);\n        commandFn(time, durationStartTime + duration);\n        return;\n      }\n    }\n\n    // Check to see if the command has interval assertions\n    if (interval !== -1) {\n      // Initialize interval time start\n      if (intervalStartTime === -1) {\n        command[2] = time;\n        intervalStartTime = time;\n      }\n\n      // If we are greater than our interval we execute our command\n      if (time - intervalStartTime >= interval) {\n        commandFn(time);\n\n        while (time - intervalStartTime >= interval) {\n          command[2] += interval;\n          intervalStartTime += interval;\n        }\n      }\n    } else {\n      commandFn(time);\n    }\n  });\n\n  // Remove any commands that have exceeded their duration\n  for (let i = 0, iMax = stopAnimationLoops.length; i < iMax; ++i) {\n    const id = stopAnimationLoops[i];\n    animationLoopCommands.delete(id);\n  }\n\n  // Instant dump the commands into a separate list in case the commands have more onFrame commands called within\n  const immediate = immediateQueuedCommands.slice();\n  immediateQueuedCommands = [];\n\n  // Execute all imeediately queued commands\n  for (let i = 0, iMax = immediate.length; i < iMax; ++i) {\n    const [command, interval, startTime] = immediate[i];\n\n    // If an interval is not specified, then we simply execute the command immediately\n    if (interval <= 0) {\n      if (command) {\n        keepLooping = true;\n        command(time);\n      }\n    }\n\n    // If we have a specified interval, then we need to see if a certain amount of time has lapsed to satisfy the\n    // interval. If the interval is not satisfied, then the command is requeued to be checked next execution loop.\n    else {\n      if (time - startTime > interval) {\n        command(time);\n      } else {\n        immediateQueuedCommands.push(immediate[i]);\n      }\n    }\n  }\n\n  // Empty and execute all next frame commands\n  for (let i = 0, iMax = nextFrameCommands.length; i < iMax; ++i) {\n    const command = nextFrameCommands[i];\n\n    if (command) {\n      keepLooping = true;\n      command(time);\n    }\n  }\n\n  // Currently queued commands get put into the nextFrameCommand buffer to be\n  // executed next animation frame instead of the current frame.\n  nextFrameCommands = nextQueuedCommands.slice(0);\n  nextQueuedCommands = [];\n\n  if (nextFrameCommands.length > 0) {\n    keepLooping = true;\n  }\n\n  if (keepLooping) animationFrameId = requestAnimationFrame(loop);\n  else animationFrameId = -1;\n};\n\n// Start the next frame command loop\nrequestAnimationFrame(loop);\n\n/**\n * Method that queues up a command to be executed not on this animation frame, but the next one\n */\nexport function nextFrame(command?: Command) {\n  const resolver = new PromiseResolver<number>();\n\n  nextQueuedCommands.push((t: number) => {\n    if (command) command(t);\n    resolver.resolve(t);\n  });\n\n  if (animationFrameId === -1) {\n    animationFrameId = requestAnimationFrame(loop);\n  }\n\n  return resolver.promise;\n}\n\n/**\n * Method that queues up a command to be executed on the upcoming animation frame.\n *\n * If a time interval is specified, the command will not execute until AT LEAST the specified amount of time has lapsed.\n */\nexport function onFrame(command?: Command, interval?: number) {\n  const resolver = new PromiseResolver<number>();\n  const wrappedCommand: Command = (t: number) => {\n    if (command) command(t);\n    resolver.resolve(t);\n  };\n\n  immediateQueuedCommands.push([wrappedCommand, interval || -1, currentTime]);\n\n  if (animationFrameId === -1) {\n    animationFrameId = requestAnimationFrame(loop);\n  }\n\n  return resolver.promise;\n}\n\n/**\n * Method that queues a command to fire every animation loop. Does not stop until the returned id for the command is\n * called with stopAnimationLoop(id).\n *\n * You can specify an interval to make the loop execute on the animation frame but after a given lapse of time.\n * For example: an interval of 1000 will make the loop execute on the animation frame but only after 1 second has lapsed\n * since last time this command executed.\n *\n * You can also specify a duration so the commands will only execute so long as the duration specified has not been\n * exceeeded. Once the duration is met or exceeded, the command will be removed from the loop queue and no longer fire.\n * There will ALWAYS be a final frame that is executed for the command that will provide the time the command SHOULD\n * HAVE finished (not necessarily the actual current time).\n *\n * This method returns a promise which allows for some insight into timings on the animation loop. If NO duration is\n * specified, then the promise resolves the first time the command is executed. If a duration IS specified, then the\n * promise resolves after the duration has completed.\n */\nexport function onAnimationLoop(\n  command: Command,\n  interval?: number,\n  duration?: number\n) {\n  const id = new PromiseResolver<number>();\n\n  const wrappedCommand: Command = (t: number, endTime?: number) => {\n    command(t);\n\n    if (duration !== void 0 && duration > 0) {\n      if (endTime !== void 0) {\n        id.resolve(endTime);\n      }\n    } else {\n      id.resolve(t);\n    }\n  };\n\n  animationLoopCommands.set(id.promise, [\n    wrappedCommand,\n    interval || -1,\n    -1,\n    duration || -1,\n    -1\n  ]);\n\n  if (animationFrameId === -1) {\n    animationFrameId = requestAnimationFrame(loop);\n  }\n\n  return id.promise;\n}\n\n/**\n * Halts the animation loop for a command associated with an id.\n */\nexport function stopAnimationLoop(id: Promise<number>) {\n  animationLoopCommands.delete(id);\n\n  if (animationFrameId === -1) {\n    animationFrameId = requestAnimationFrame(loop);\n  }\n}\n\n/**\n * This method provides an ensured way to clear ALL commands queued up to fire for a frame. This includes halting all:\n * animation loops, nextFrame, and onFrame commands.\n */\nexport function stopAllFrameCommands() {\n  animationLoopCommands.clear();\n  immediateQueuedCommands = [];\n  nextQueuedCommands = [];\n  nextFrameCommands = [];\n}\n","import { IdentifiableById } from \"../types\";\n\n/**\n * These are the minimum properties required for a ReactiveDiff to monitor a set of objects.\n */\nexport type ReactiveDiffObject<U> = {\n  /** The identifier of the object which is used to determine who is added/removed/updated */\n  key: string | number;\n  /** When inline() is used, it designates the caller of inline as the parent object */\n  parent?: U;\n};\n\n/**\n * Customizes a ReactiveDiff object\n */\nexport interface IReactiveDiffOptions<U, T extends ReactiveDiffObject<U>> {\n  /** This method will execute when this controller has determined a new object should be constructed */\n  buildItem(intiializer: T): Promise<U | null>;\n  /** This method will execute when this controller has determined an object should be deconstructed */\n  destroyItem(intiializer: T, item: U): Promise<boolean | null>;\n  /** This method will execute when this controller has determined an object has potential new properties to be applied to it */\n  updateItem(initializer: T, item: U): Promise<void>;\n}\n\n/**\n * This is a helper object to monitor a set of objects\n */\nexport class ReactiveDiff<\n  U extends IdentifiableById | null,\n  T extends ReactiveDiffObject<U>\n> {\n  /** The options used to construct this controller */\n  private options: IReactiveDiffOptions<U, T>;\n  /** All items flagged for disposing */\n  private willDispose = new Set<T[\"key\"]>();\n  /** We track all items by their key for quicker processing */\n  private keyToItem = new Map<T[\"key\"], U>();\n  /** We track all initializers by their key for quicker processing */\n  private keyToInitializer = new Map<T[\"key\"], T>();\n  /** Used to faciliate and enable the inline() ability */\n  private currentInitalizerIndex = 0;\n  /**\n   * The current initializers being processed. This is used to ensure the inline() method can inject correctly without\n   * jmutating the input initializer list.\n   */\n  private currentInitializers: T[] = [];\n  /**\n   * This is the list of the items generated and managed by this diff object, this list is in the order they appear\n   * in the diff initializers injected into the diff.\n   */\n  private _items: U[] = [];\n  /**\n   * While processing, this keeps track of the currently executing initializer and object\n   */\n  private currentInitializer?: T;\n  private currentItem?: U;\n  /**\n   * This stores deferred inlined elements that are waiting for their parent to be completely created\n   */\n  private deferredInlining?: T[];\n\n  /** A list of all the items currently alive and managed by this diff */\n  get items(): U[] {\n    return this._items.slice(0);\n  }\n\n  constructor(options: IReactiveDiffOptions<U, T>) {\n    this.options = options;\n  }\n\n  /**\n   * This triggers all resources currently managed by this diff manager to process their destroy procedure\n   */\n  async destroy() {\n    const promises: Promise<boolean | null>[] = [];\n\n    for (let i = 0, iMax = this.currentInitializers.length; i < iMax; ++i) {\n      const init = this.currentInitializers[i];\n      const item = this.keyToItem.get(init.key);\n      if (!item) continue;\n      promises.push(this.options.destroyItem(init, item));\n    }\n\n    await Promise.all(promises);\n  }\n\n  /**\n   * This injects the objects into the diff to be processed for new and removed items.\n   */\n  async diff(intializers: T[]) {\n    // Make sure we don't mutate the input\n    const processing = intializers.slice(0);\n    this.currentInitializers = processing;\n    // Clear out our items listing so we can repopulate it with the correct order of elements injected\n    this._items = [];\n\n    // We loop through all items injected to see who is new, who exists already, and who no longer\n    // exists in our input list. We MUST analyze the length on the loop as this list can be expanded.\n    // We use a while loop to ensure the async pattern is honored.\n    let i = 0;\n    while (i < processing.length) {\n      const initializer = processing[i];\n      this.currentInitalizerIndex = i;\n      this.currentInitializer = initializer;\n\n      // Existing items will be in our dispose list, so since we received this item again\n      // then we merely have an update and we remove the flag that would cause it to get tossed away\n      if (this.willDispose.has(initializer.key)) {\n        let item = this.keyToItem.get(initializer.key) || null;\n\n        if (item) {\n          this.currentItem = item;\n          await this.options.updateItem(initializer, item);\n        } else {\n          item = await this.options.buildItem(initializer);\n        }\n\n        if (item) {\n          this.keyToInitializer.set(initializer.key, initializer);\n          this.willDispose.delete(initializer.key);\n          this._items.push(item);\n        }\n      }\n\n      // Items that are not existing already will not be in the dispose queue\n      else {\n        this.inline = this.inlineDeferred;\n        const item = await this.options.buildItem(initializer);\n        this.inline = this.inlineImmediate;\n\n        // Check to see if we successfully generated an item\n        if (item) {\n          this.currentItem = item;\n\n          if (this.deferredInlining) {\n            this.inline(this.deferredInlining);\n            delete this.deferredInlining;\n          }\n\n          this.keyToItem.set(initializer.key, item);\n          this.keyToInitializer.set(initializer.key, initializer);\n          this._items.push(item);\n        }\n      }\n\n      delete this.currentItem;\n      i++;\n    }\n\n    // Now that we have processed all incoming items, the remaining items in our disposal list\n    // are the items we should remove.\n    this.willDispose.forEach(async (key: string) => {\n      const item = this.keyToItem.get(key);\n      const initializer = this.keyToInitializer.get(key);\n      if (!item || !initializer) return;\n      const success = await this.options.destroyItem(initializer, item);\n\n      if (success) {\n        this.keyToItem.delete(key);\n        this.keyToInitializer.delete(key);\n      }\n    });\n\n    // Clear the disposal list so we can make it anew\n    this.willDispose.clear();\n\n    // Now we take all existing items and flag them anew for disposal\n    this.keyToInitializer.forEach(item => {\n      this.willDispose.add(item.key);\n    });\n\n    // Don't hang onto the mutated list of initializers\n    this.currentInitializers = [];\n    delete this.currentItem;\n    delete this.currentInitializer;\n  }\n\n  /**\n   * Returns a specified item by key\n   */\n  getByKey(key: string) {\n    return this.keyToItem.get(key);\n  }\n\n  /**\n   * This method is used to inline new elements at the time a creation occurs\n   */\n  private inlineDeferred = (newInitializers: T[]) => {\n    this.deferredInlining = newInitializers;\n  };\n\n  /**\n   * This method is used to inline new elements at the time an update occurs\n   */\n  private inlineImmediate = (newInitializers: T[]) => {\n    if (\n      newInitializers.length > 0 &&\n      this.currentInitializers &&\n      this.currentItem\n    ) {\n      this.currentInitializers.splice(\n        this.currentInitalizerIndex + 1,\n        0,\n        ...newInitializers\n      );\n\n      for (let i = 0, iMax = newInitializers.length; i < iMax; ++i) {\n        const init = newInitializers[i];\n        init.parent = this.currentItem;\n      }\n    }\n  };\n\n  /**\n   * Inlining new items takes on two different modes: immediate inlining for during update cycles\n   * and inlining during creation cycles which requires deferring the inline until the creation of the item has been completed.\n   */\n  inline = this.inlineImmediate;\n\n  /**\n   * Only during the updateItem phase of an item can this be called. This will cause the item\n   * to be fully destroyed, then reconstructed instead of go through an update.\n   */\n  async rebuild() {\n    // Only execute if currently running diffs and if currently in an update phase\n    if (!this.currentItem || !this.currentInitializer) return;\n    // Clear the item from any look ups\n    this.keyToItem.delete(this.currentItem.id);\n    this.keyToInitializer.delete(this.currentItem.id);\n    // Perform the destruction of the item\n    this.options.destroyItem(this.currentInitializer, this.currentItem);\n    // Rebuild the item\n    const item = await this.options.buildItem(this.currentInitializer);\n\n    // Re-add the item to the lookups if the rebuild succeeded\n    if (item) {\n      this.keyToItem.set(this.currentItem.id, item);\n      this.keyToInitializer.set(this.currentItem.id, this.currentInitializer);\n    }\n  }\n}\n","import { Vec2 } from \"../math\";\nimport { BaseProjection, SimpleProjection } from \"../math/base-projection\";\nimport { AbsolutePosition } from \"../math/primitives/absolute-position\";\nimport { Bounds } from \"../math/primitives/bounds\";\nimport { Color, Omit } from \"../types\";\nimport { Camera } from \"../util/camera\";\nimport { IdentifyByKey, IdentifyByKeyOptions } from \"../util/identify-by-key\";\nimport { LayerScene } from \"./layer-scene\";\n\nexport enum ClearFlags {\n  COLOR = 0b0001,\n  DEPTH = 0b0010,\n  STENCIL = 0b0100\n}\n\n/**\n * A type to describe the constructor of a View class.\n */\nexport interface IViewConstructable<TViewProps extends IViewProps> {\n  new (scene: LayerScene, props: TViewProps): View<TViewProps>;\n}\n\n/**\n * This specifies a class type that can be used in creating a view with createView\n */\nexport type IViewConstructionClass<\n  TViewProps extends IViewProps\n> = IViewConstructable<TViewProps> & { defaultProps: TViewProps };\n\n/**\n * This is a pair of a Class Type and the props to be applied to that class type.\n */\nexport type ViewInitializer<TViewProps extends IViewProps> = {\n  key: string;\n  init: [IViewConstructionClass<TViewProps>, IViewProps];\n};\n\n/**\n * Used for reactive view generation and updates.\n */\nexport function createView<TViewProps extends IViewProps>(\n  viewClass: IViewConstructable<TViewProps> & { defaultProps: TViewProps },\n  props: Omit<TViewProps, \"key\" | \"viewport\"> &\n    Partial<Pick<TViewProps, \"key\" | \"viewport\">>\n): ViewInitializer<TViewProps> {\n  const keyedProps = Object.assign(props, {\n    key: props.key || \"\",\n    viewport: props.viewport || {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }\n  });\n\n  return {\n    get key() {\n      return props.key || \"\";\n    },\n    init: [viewClass, keyedProps]\n  };\n}\n\n/**\n * Defines the input metrics of a view for a scene.\n */\nexport interface IViewProps extends IdentifyByKeyOptions {\n  /**\n   * The background color that gets cleared out for this view. Performance is\n   * better if this is left clear. Probably better to draw a colored quad instead.\n   * This is just convenient.\n   */\n  background?: Color;\n  /**\n   * This is the 3D camera used to create a vantage point in the 3D world and project it's viewpoint to the 2d screen.\n   */\n  camera: Camera;\n  /**\n   * This sets what buffers get cleared by webgl before the view is drawn in it's space.\n   */\n  clearFlags?: ClearFlags[];\n  /** Helps assert a guaranteed rendering order if needed. Lower numbers render first. */\n  order?: number;\n  /**\n   * This specifies the bounds on the canvas this camera will render to. This let's you render\n   * say a little square in the bottom right showing a minimap.\n   *\n   * If this is not specified, the entire canvas will be the viewport.\n   */\n  viewport: AbsolutePosition;\n}\n\n/**\n * A View renders a perspective of a scene to a given surface or surfaces.\n */\nexport abstract class View<\n  TViewProps extends IViewProps\n> extends IdentifyByKey {\n  static defaultProps: IViewProps = {\n    key: \"\",\n    camera: Camera.makeOrthographic(),\n    viewport: { left: 0, right: 0, top: 0, bottom: 0 }\n  };\n\n  /** End time of animation */\n  animationEndTime: number = 0;\n  /**\n   * This is the depth of the view. The higher the depth represents which layer is on top.\n   * Zero always represents the default view.\n   */\n  depth: number = 0;\n  /** Last frame time this view was rendered under */\n  lastFrameTime: number = 0;\n  /** This is the flag to see if a view needs draw */\n  needsDraw: boolean = false;\n  /**\n   * This is a flag for various processes to indicate the view is demanding optimal rendering performance over other processes.\n   * This is merely a hinting device and does not guarantee better performance at any given moment.\n   */\n  optimizeRendering: boolean = false;\n  /** This is set to ensure the projections that happen properly translates the pixel ratio to normal Web coordinates */\n  pixelRatio: number = 1;\n  /** The props applied to this view */\n  props: TViewProps;\n  /** The scene this view is displaying */\n  scene: LayerScene;\n  /** This establishes the projection methods that can be used to project geometry between the screen and the world */\n  projection: BaseProjection<View<TViewProps>>;\n\n  get screenBounds() {\n    return this.projection.screenBounds;\n  }\n\n  set screenBounds(val: Bounds<View<TViewProps>>) {\n    this.projection.screenBounds = val;\n  }\n\n  get viewBounds() {\n    return this.projection.viewBounds;\n  }\n\n  set viewBounds(val: Bounds<View<TViewProps>>) {\n    this.projection.viewBounds = val;\n  }\n\n  /** Retrieves the clearflag prop assigned to the view and provides a default */\n  get clearFlags() {\n    return this.props.clearFlags || [];\n  }\n\n  /** Retrieves the order prop assigned to the view and provides a default */\n  get order() {\n    return this.props.order || 0;\n  }\n\n  constructor(scene: LayerScene, props: TViewProps) {\n    super(props);\n    this.scene = scene;\n    // Keep our props within the view\n    this.props = Object.assign({}, View.defaultProps || {}, props);\n  }\n\n  /**\n   * This operation makes sure we have the view camera adjusted to the new viewport's needs.\n   * For default behavior this ensures that the coordinate system has no distortion, orthographic,\n   * top left as 0,0 with +y axis pointing down.\n   */\n  abstract fitViewtoViewport(\n    _surfaceDimensions: Bounds<never>,\n    viewBounds: Bounds<View<IViewProps>>\n  ): void;\n\n  /*\n   * This method returns a flag indicating whether or not the view should trigger a redraw.\n   * By default, a redraw is triggered (this returns true) when a shallow comparison of the current props\n   * and the incoming props are different.\n   * This method can be overridden to place custom logic at this point to indicate when redraws should happen.\n   *\n   * NOTE: This should be considered for redraw logic centered around changes in the view itself.\n   * There ARE additional triggers in the system that causes redraws. This method just aids in ensuring\n   * necessary redraws take place for view level logic and props.\n   */\n  shouldDrawView(oldProps: TViewProps, newProps: TViewProps) {\n    for (const key in newProps) {\n      if (newProps[key] !== oldProps[key]) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Lifecycle: Fires before the props object is updated with the newProps. Allows view to\n   * respond to diff changes.\n   */\n  willUpdateProps(_newProps: IViewProps) {\n    // No-op for the base behavior\n  }\n\n  /**\n   * Lifecycle: Executes after props have been updated with new contents\n   */\n  didUpdateProps() {\n    // No-op for the base behavior\n  }\n}\n\n/**\n * A view that does not view anything.\n * Useful as a placeholder view to not cause null or undefined values.\n */\nexport class NoView extends View<IViewProps> {\n  projection = new SimpleProjection();\n\n  screenToWorld(_point: Vec2, _out?: Vec2): Vec2 {\n    return [0, 0];\n  }\n\n  worldToScreen(_point: Vec2, _out?: Vec2): Vec2 {\n    return [0, 0];\n  }\n\n  viewToWorld(_point: Vec2, _out?: Vec2): Vec2 {\n    return [0, 0];\n  }\n\n  worldToView(_point: Vec2, _out?: Vec2): Vec2 {\n    return [0, 0];\n  }\n\n  fitViewtoViewport(\n    screenBounds: Bounds<never>,\n    _viewBounds: Bounds<View<IViewProps>>\n  ) {\n    /** noop */\n    this.screenBounds = screenBounds;\n  }\n\n  constructor() {\n    super(new LayerScene(undefined, { key: \"error\", layers: [], views: [] }), {\n      key: \"error\",\n      viewport: {},\n      camera: Camera.makeOrthographic()\n    });\n\n    this.screenBounds = new Bounds<never>({\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 100\n    });\n  }\n}\n","import { Scene } from \"../gl/scene\";\nimport { Instance } from \"../instance-provider/instance\";\nimport { IdentifyByKey, IdentifyByKeyOptions } from \"../util/identify-by-key\";\nimport { ReactiveDiff } from \"../util/reactive-diff\";\nimport {\n  ILayerProps,\n  ILayerPropsInternal,\n  Layer,\n  LayerInitializer,\n  LayerInitializerInternal\n} from \"./layer\";\nimport { generateDefaultElements } from \"./layer-processing/generate-default-scene\";\nimport { Surface } from \"./surface\";\nimport { IViewProps, View, ViewInitializer } from \"./view\";\n\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * Defines the input for an available scene layers can add themselves to. Each scene can be rendered with multiple\n * views.\n */\nexport interface ISceneOptions extends IdentifyByKeyOptions {\n  /**\n   * This decalres all of the layers that should be applied to this scene.\n   */\n  layers: LayerInitializer[];\n  /** Helps assert a guaranteed rendering order for scenes. Lower numbers reender first. */\n  order?: number;\n  /**\n   * This indicates all of the views this scene can be rendered with. For instance: You have a\n   * world scene and you want to render it stereoscopically for VR. Then you can specify two\n   * views with two viewports to render the scene on both halves of the canvas.\n   *\n   * Or perhaps you want an aerial shot as a minimap in the bottom right corner while the rest\n   * of the canvas renders a first person view, then you would make two views for that as well.\n   */\n  views: ViewInitializer<IViewProps>[];\n}\n\n/**\n * This defines a scene to which layers are added to. It also tracks the views that this scene\n * is rendered with.\n */\nexport class LayerScene extends IdentifyByKey {\n  static DEFAULT_SCENE_ID = \"__default__\";\n\n  /** This is the GL scene which actually sets up the rendering objects */\n  container: Scene | undefined = new Scene();\n  /** This is the diff tracker for the layers for the scene which allows us to make the pipeline easier to manage */\n  layerDiffs: ReactiveDiff<\n    Layer<Instance, ILayerProps<Instance>>,\n    LayerInitializer\n  >;\n  /** Helps assert a guaranteed render order for scenes. Lower numbers render first. */\n  order?: number;\n  /** The presiding surface over this scene */\n  surface?: Surface;\n  /** This is the diff tracker for the views for the scene which allows us to make the pip0eline easier to manage */\n  viewDiffs: ReactiveDiff<View<IViewProps>, ViewInitializer<IViewProps>>;\n\n  /** This is all of the layers attached to the scene */\n  get layers(): Layer<any, any>[] {\n    return this.layerDiffs.items;\n  }\n\n  /** This is all of the views attached to the scene */\n  get views(): View<IViewProps>[] {\n    return this.viewDiffs.items;\n  }\n\n  constructor(surface: Surface | undefined, options: ISceneOptions) {\n    super(options);\n    this.surface = surface;\n    this.init(options);\n  }\n\n  /**\n   * Initialize all that needs to be initialized\n   */\n  private init(options: ISceneOptions) {\n    // Make sure there is a rendering context set up\n    if (!this.surface || !this.surface.gl) return;\n    // Make a Scene for the GL layer to accept and render objects from\n    this.container = new Scene();\n    // Make default scene elements\n    const defaultElements = generateDefaultElements(this.surface.gl);\n\n    // Create the diff manager to handle the layers coming in.\n    this.layerDiffs = new ReactiveDiff({\n      buildItem: async (initializer: LayerInitializerInternal) => {\n        debug(\"Building layer\", initializer.key);\n        if (!this.surface) return null;\n        const layerClass = initializer.init[0];\n        const props = initializer.init[1];\n        // Generate the new layer and provide it it's initial props\n        const layer = new layerClass(\n          this.surface,\n          this,\n          Object.assign({}, layerClass.defaultProps, props)\n        );\n        // Keep the initializer object that generated the layer for reference and debugging\n        layer.initializer = initializer;\n        // Sync the data provider applied to the layer in case the provider has existing data\n        // before being applied to the layer\n        layer.props.data.sync();\n        // Look in the props of the layer for the parent of the layer\n        layer.parent = props.parent;\n\n        // If the parent is present, the parent should have the child added\n        if (props.parent) {\n          if (props.parent.children) props.parent.children.push(layer);\n          else props.parent.children = [layer];\n        }\n\n        // Add the layer to this surface\n        if (!layer.init()) {\n          console.warn(\n            \"Error initializing layer:\",\n            props.key,\n            \"A layer was unable to be added to the surface. See previous warnings (if any) to determine why they could not be instantiated\"\n          );\n\n          return null;\n        }\n\n        // Get the children for the layer\n        const children = layer.childLayers();\n        // Add in the children of the layer\n        this.layerDiffs.inline(children);\n\n        return layer;\n      },\n\n      destroyItem: async (\n        initializer: LayerInitializer,\n        layer: Layer<Instance, ILayerProps<Instance>>\n      ) => {\n        debug(\"Destroying layer\", initializer.key);\n        layer.destroy();\n        return true;\n      },\n\n      updateItem: async (\n        initializer: LayerInitializer,\n        layer: Layer<Instance, ILayerProps<Instance>>\n      ) => {\n        const props: ILayerPropsInternal<Instance> = initializer.init[1];\n        // Execute lifecycle method\n        layer.willUpdateProps(props);\n\n        // If we have a provider that is about to be newly set to the layer, then the provider\n        // needs to do a full sync in order to have existing elements in the provider\n        if (props.data !== layer.props.data) {\n          props.data.sync();\n        }\n\n        // Check to see if the layer is going to require it's view to be redrawn based on the props for the Layer changing,\n        // or by custom logic of the layer.\n        if (layer.shouldDrawView(layer.props, props)) {\n          layer.needsViewDrawn = true;\n        }\n\n        // Make sure the layer has the current props applied to it\n        Object.assign(layer.props, props);\n        // Keep the initializer up to date with the injected props\n        layer.initializer.init[1] = layer.props;\n        // Lifecycle hook\n        layer.didUpdateProps();\n\n        // If we are having a parent swap, we need to make sure the previous parent does not\n        // register this layer as a child anymore\n        if (props.parent) {\n          if (layer.parent && layer.parent !== props.parent) {\n            // RESUME: We're making sure deleted layers or regenerated layers properly have parent child relationships\n            // updated properly.\n            const children = layer.parent.children || [];\n            const index = children.indexOf(layer) || -1;\n\n            if (index > -1) {\n              children.splice(index, 1);\n            }\n          }\n        }\n\n        // Always make sure the layer's parent is set properly by the props\n        layer.parent = props.parent;\n\n        // A layer may flag itself as needing to be rebuilt. This is handled here and is completed by deleting\n        // the layer completely then generating the layer anew.\n        if (layer.willRebuildLayer) {\n          this.layerDiffs.rebuild();\n          layer.willRebuildLayer = false;\n        }\n\n        // If the layer is not regenerated, then during this render phase we add in the child layers of this layer.\n        else {\n          this.layerDiffs.inline(layer.childLayers());\n        }\n      }\n    });\n\n    // Create the diff manager to handle the views coming in.\n    this.viewDiffs = new ReactiveDiff({\n      buildItem: async (initializer: ViewInitializer<IViewProps>) => {\n        if (!this.surface) return null;\n        const newView = new initializer.init[0](this, initializer.init[1]);\n        newView.props.camera = newView.props.camera || defaultElements.camera;\n        newView.pixelRatio = this.surface.pixelRatio;\n        this.surface.mouseManager.waitingForRender = true;\n\n        return newView;\n      },\n\n      // No special needs for destroying/removing a view\n      destroyItem: async (\n        _initializer: ViewInitializer<IViewProps>,\n        _view: View<IViewProps>\n      ) => true,\n\n      // Hand off the initializer to the update of the view\n      updateItem: async (\n        initializer: ViewInitializer<IViewProps>,\n        view: View<IViewProps>\n      ) => {\n        const props = initializer.init[1];\n        view.willUpdateProps(props);\n\n        if (view.shouldDrawView(view.props, props)) {\n          view.needsDraw = true;\n        }\n\n        Object.assign(view.props, props);\n        view.didUpdateProps();\n\n        if (this.surface) {\n          this.surface.mouseManager.waitingForRender = true;\n        }\n      }\n    });\n\n    // Now add in the initial data into our diff objects\n    this.update(options);\n  }\n\n  /**\n   * Release any resources this may be hanging onto\n   */\n  destroy() {\n    delete this.container;\n    this.layerDiffs.destroy();\n    this.viewDiffs.destroy();\n  }\n\n  /**\n   * Ensures a layer is removed from the scene\n   */\n  removeLayer(layer: Layer<any, any>) {\n    if (this.layers) {\n      const index = this.layers.indexOf(layer);\n\n      if (index >= 0) {\n        this.layers.splice(index, 1);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Hand off the diff objects to our view and layer diffs\n   */\n  async update(options: ISceneOptions) {\n    this.order = options.order;\n    await this.viewDiffs.diff(options.views);\n    await this.layerDiffs.diff(options.layers);\n  }\n}\n","import { Texture } from \"../../gl/texture\";\nimport { ResourceType } from \"../../types\";\nimport { BaseResourceRequest } from \"../base-resource-manager\";\nimport { FontMap, KernedLayout } from \"./font-map\";\n\nexport enum FontResourceRequestFetch {\n  /** Retrieves the tex coordinates on the font map of the specified character glyph. Defaults to [0, 0, 0, 0] */\n  TEXCOORDS = 0,\n  /** Retrieves the pixel size of the character glyph on the font map */\n  IMAGE_SIZE = 1\n}\n\n/**\n * Properties needed to make a font resource request\n */\nexport interface IFontResourceRequest extends BaseResourceRequest {\n  /** The character being requested from the fontmap */\n  character?: string;\n  /** This changes the information retrieved as a result of the request method. */\n  fetch?: FontResourceRequestFetch;\n  /**\n   * When the request has been processed and results become available, this is populated with the FontMap object that has everything\n   * needed for the requester to get the information needed.\n   */\n  fontMap?: FontMap;\n  /**\n   * The characters for which we want to have the kerning information retrieved. This will be applied as a list of words\n   * for which we want the kerning information. We do this to prevent concating the words into a single string which can\n   * make it really difficult to preload all possible label combinations.\n   */\n  kerningPairs?: string[];\n  /** When provided, the request will fill in the metrics for the input parameters */\n  metrics?: {\n    /** The desired font size for the layout */\n    fontSize: number;\n    /**\n     * The system will populate this for you with the layout (top left is at 0,0) of the text.\n     * If maxWidth is provided, this will be the layout of the truncated text.\n     */\n    layout?: KernedLayout;\n    /** Spacing between letters in a label */\n    letterSpacing: number;\n    /** When provided, this will cause the system to see if the text should be truncated or not */\n    maxWidth?: number;\n    /** This is the source text that we wish to receive the metrics for. */\n    text: string;\n    /** These are the characters to use to indicate truncation in the event truncation takes place */\n    truncation?: string;\n    /**\n     * If maxWidth is provided, this will provide the calculated truncated text. This will be the full\n     * text if no truncation is provided.\n     */\n    truncatedText?: string;\n  };\n  /** This is to satisfy the use of the TextureIOExpansion. This is the texture within the fontmap */\n  texture?: Texture;\n  /** Establish the only type that this request shall be is a FONT type */\n  type: ResourceType.FONT;\n}\n\n/**\n * Wrapper method to create a font resource request to make typings and intellisense work better.\n */\nexport function fontRequest(\n  options: Omit<IFontResourceRequest, \"type\">\n): IFontResourceRequest {\n  return {\n    type: ResourceType.FONT,\n    ...options\n  };\n}\n\n/**\n * Provides a Preload string that can be applied to 'preload' in a FontMapSource that will cause all numbers to be able\n * to render without interruption.\n */\nexport function preloadNumber() {\n  return (\n    \".101112131415161718191.202122232425262728292.303132333435363738393.404142434445464748494.505152535455565758595.\" +\n    \"606162636465666768696.707172737475767778797.808182838485868788898.909192939495969798999.000102030405060708090.\" +\n    \"$0$1$2$3$4$5$6$7$8$9$\" +\n    \"%0%1%2%3%4%5%6%7%8%9%\" +\n    \"-0-1-2-3-4-5-6-7-8-9-\" +\n    \"+0+1+2+3+4+5+6+7+8+9+\" +\n    \")0)1)2)3)4)5)6)7)8)9)\" +\n    \"(0(1(2(3(4(5(6(7(8(9(\"\n  );\n}\n","import { Texture } from \"../../gl/texture\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport {\n  ShaderDeclarationStatements,\n  ShaderIOHeaderInjectionResult\n} from \"../../shaders/processing/base-shader-io-injection\";\nimport { MetricsProcessing } from \"../../shaders/processing/metrics-processing\";\nimport { ILayerProps, Layer } from \"../../surface/layer\";\nimport {\n  BaseIOExpansion,\n  ShaderIOExpansion\n} from \"../../surface/layer-processing/base-io-expansion\";\nimport {\n  IInstanceAttribute,\n  InstanceAttributeSize,\n  IResourceInstanceAttribute,\n  IResourceType,\n  IUniform,\n  IValueInstanceAttribute,\n  IVertexAttribute,\n  ShaderInjectionTarget,\n  UniformSize\n} from \"../../types\";\nimport { ResourceRouter } from \"../resource-router\";\n\nconst debugCtx = \"TextureIOExpansion\";\n\n/** Empty texture that will default to the zero texture and unit */\nconst emptyTexture = new Texture({\n  data: {\n    width: 2,\n    height: 2,\n    buffer: new Uint8Array(16)\n  }\n});\n\n/** Resource Attribute typeguard */\nfunction isTextureAttribute<T extends Instance>(\n  attr: any,\n  router: ResourceRouter,\n  resourceType: number\n): attr is IResourceInstanceAttribute<T> {\n  return (\n    attr &&\n    attr.resource &&\n    router.getResourceType(attr.resource.key()) === resourceType &&\n    attr.resource.name !== undefined &&\n    attr.resource.key !== undefined\n  );\n}\n\n/**\n * Minimal information a resource is required to have to operate for this expander.\n */\ninterface ITextureIOExpansionResource extends IResourceType {\n  texture: Texture;\n}\n\n/**\n * Minimal manager requirements for being applied to this expanded.\n */\ninterface ITextureResourceManager {\n  /** The router all resources flow through */\n  router: ResourceRouter;\n  /** A method for retrieving the resource by the resources key id */\n  getResource(key: string): ITextureIOExpansionResource | null;\n}\n\n/**\n * This is an expansion handler for resource attributes that requires a texture to be\n * included as a uniform on behalf of the attribute.\n */\nexport class TextureIOExpansion extends BaseIOExpansion {\n  /** The manager which will contain the texture object to be used */\n  manager: ITextureResourceManager;\n  /** The resource type this expansion filters on */\n  resourceType: number;\n\n  constructor(resourceType: number, manager: ITextureResourceManager) {\n    super();\n    this.manager = manager;\n    this.resourceType = resourceType;\n  }\n\n  /**\n   * Provides expanded IO for attributes with resource properties.\n   */\n  expand<T extends Instance, U extends ILayerProps<T>>(\n    _layer: Layer<T, U>,\n    instanceAttributes: IInstanceAttribute<T>[],\n    _vertexAttributes: IVertexAttribute[],\n    _uniforms: IUniform[]\n  ): ShaderIOExpansion<T> {\n    // Pull down the manager to this method's context\n    const manager = this.manager;\n    // Retrieve all of the instance attributes that are atlas references\n    const atlasInstanceAttributes: IResourceInstanceAttribute<T>[] = [];\n    // Key: The atlas uniform name requested\n    const requestedTextureInjections = new Map<string, [boolean, boolean]>();\n\n    // Get the atlas requests that have unique names. We only need one uniform\n    // For a single unique provided name. We also must merge the requests for\n    // Vertex and fragment injections\n    instanceAttributes.forEach(\n      (\n        attribute: IValueInstanceAttribute<T> | IResourceInstanceAttribute<T>\n      ) => {\n        if (\n          isTextureAttribute(attribute, this.manager.router, this.resourceType)\n        ) {\n          // Auto set the size of the attribute. Attribute's that are a resource automatically\n          // Consume a size of four unless otherwise stated by the attribute\n          if (attribute.size === undefined) {\n            attribute.size = InstanceAttributeSize.FOUR;\n          }\n\n          // Get the atlas resource uniform (sampler2D) injection targets. We default to only the\n          // Fragment shader as it's the most commonly used location for sampler2Ds\n          const injection: number =\n            attribute.resource.shaderInjection ||\n            ShaderInjectionTarget.FRAGMENT;\n          // See if we already have an injection for the given injected uniform name for an atlas resource.\n          const injections = requestedTextureInjections.get(\n            attribute.resource.name\n          );\n\n          if (injections) {\n            requestedTextureInjections.set(attribute.resource.name, [\n              injections[0] ||\n                injection === ShaderInjectionTarget.VERTEX ||\n                injection === ShaderInjectionTarget.ALL,\n              injections[1] ||\n                injection === ShaderInjectionTarget.FRAGMENT ||\n                injection === ShaderInjectionTarget.ALL\n            ]);\n          } else {\n            atlasInstanceAttributes.push(attribute);\n            requestedTextureInjections.set(attribute.resource.name, [\n              injection === ShaderInjectionTarget.VERTEX ||\n                injection === ShaderInjectionTarget.ALL,\n              injection === ShaderInjectionTarget.FRAGMENT ||\n                injection === ShaderInjectionTarget.ALL\n            ]);\n          }\n        }\n      }\n    );\n\n    // Make uniforms for all of the unique atlas requests.\n    const uniforms = atlasInstanceAttributes.map(\n      (instanceAttribute): IUniform[] => {\n        let injection: ShaderInjectionTarget = ShaderInjectionTarget.FRAGMENT;\n\n        if (instanceAttribute.resource) {\n          const injections = requestedTextureInjections.get(\n            instanceAttribute.resource.name\n          );\n\n          if (injections) {\n            injection =\n              (injections[0] && injections[1] && ShaderInjectionTarget.ALL) ||\n              (injections[0] &&\n                !injections[1] &&\n                ShaderInjectionTarget.VERTEX) ||\n              (!injections[0] &&\n                injections[1] &&\n                ShaderInjectionTarget.FRAGMENT) ||\n              injection;\n          }\n        }\n\n        return [\n          // This injects the sampler that the shader will use for sampling texels\n          {\n            name: instanceAttribute.resource.name,\n            shaderInjection: injection,\n            size: UniformSize.ATLAS,\n            update: () => {\n              const resource = manager.getResource(\n                instanceAttribute.resource.key()\n              );\n\n              if (resource) {\n                return resource.texture || emptyTexture;\n              }\n\n              return emptyTexture;\n            }\n          },\n          // This provides the size of the texture that is applied to the sampler.\n          {\n            name: `${instanceAttribute.resource.name}_size`,\n            shaderInjection: injection,\n            size: UniformSize.TWO,\n            update: () => {\n              const resource = manager.getResource(\n                instanceAttribute.resource.key()\n              );\n\n              if (resource) {\n                const texture = resource.texture;\n\n                if (texture && texture.data) {\n                  const { width, height } = texture.data;\n                  return [width || 1, height || 1];\n                }\n              }\n\n              return [1, 1];\n            }\n          }\n        ];\n      }\n    );\n\n    const flatten: IUniform[] = [];\n    uniforms.forEach(list => list.forEach(uniform => flatten.push(uniform)));\n\n    return {\n      instanceAttributes: [],\n      vertexAttributes: [],\n      uniforms: flatten\n    };\n  }\n\n  /**\n   * Validates the IO about to be expanded.\n   */\n  validate<T extends Instance, U extends ILayerProps<T>>(\n    _layer: Layer<T, U>,\n    instanceAttributes: IInstanceAttribute<T>[],\n    _vertexAttributes: IVertexAttribute[],\n    _uniforms: IUniform[]\n  ): boolean {\n    let foundError = false;\n\n    instanceAttributes.forEach(attribute => {\n      if (attribute.easing && attribute.resource) {\n        console.warn(\n          \"An instance attribute can not have both easing and resource properties. Undefined behavior will occur.\"\n        );\n        console.warn(attribute);\n\n        foundError = true;\n      }\n    });\n\n    return !foundError;\n  }\n\n  /**\n   * For texture resources, we need the uniforms with a size of ATLAS to be injected as a sampler2D instead\n   * of a vector sizing which the basic io expansion can only provide.\n   */\n  processHeaderInjection(\n    target: ShaderInjectionTarget,\n    declarations: ShaderDeclarationStatements,\n    _layer: Layer<Instance, ILayerProps<Instance>>,\n    _metrics: MetricsProcessing,\n    _vertexAttributes: IVertexAttribute[],\n    _instanceAttributes: IInstanceAttribute<Instance>[],\n    uniforms: IUniform[]\n  ): ShaderIOHeaderInjectionResult {\n    const out = {\n      injection: \"\"\n    };\n\n    for (let i = 0, iMax = uniforms.length; i < iMax; ++i) {\n      const uniform = uniforms[i];\n      const injection = uniform.shaderInjection || ShaderInjectionTarget.VERTEX;\n\n      if (uniform.size === UniformSize.ATLAS && injection === target) {\n        this.setDeclaration(\n          declarations,\n          uniform.name,\n          `uniform sampler2D ${uniform.name};\\n`,\n          debugCtx\n        );\n      }\n    }\n\n    return out;\n  }\n}\n","import { Texture, TextureOptions } from \"../../gl/texture\";\nimport { Vec2 } from \"../../math/vector\";\nimport { Omit, ResourceType, TextureSize } from \"../../types\";\nimport { IdentifyByKey } from \"../../util/identify-by-key\";\nimport { BaseResourceOptions } from \"../base-resource-manager\";\nimport { IAtlasResourceRequest } from \"./atlas-resource-request\";\nimport { PackNode } from \"./pack-node\";\nimport { SubTexture } from \"./sub-texture\";\nimport { VideoTextureMonitor } from \"./video-texture-monitor\";\n\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * Options required for generating an atlas.\n */\nexport interface IAtlasResource extends BaseResourceOptions {\n  /** Set the type of the resource to explicitally be an atlas resource */\n  type: ResourceType.ATLAS;\n  /** This is the height of the texture */\n  height: TextureSize;\n  /** This is the width of the atlas */\n  width: TextureSize;\n  /**\n   * This applies any desired settings to the Texture.\n   * Some noteable defaults this system sets:\n   *  - generateMipMaps is true and\n   *  - premultiply alpha is true.\n   */\n  textureSettings?: TextureOptions;\n}\n\n/**\n * Use this in the property creation of atlas'.\n */\nexport function createAtlas(\n  options: Omit<IAtlasResource, \"type\" | \"key\"> &\n    Partial<Pick<IAtlasResource, \"key\">>\n): IAtlasResource {\n  return {\n    key: \"\",\n    type: ResourceType.ATLAS,\n    ...options\n  };\n}\n\n/**\n * Type guard for the atlas resource type.\n */\nexport function isAtlasResource(val: BaseResourceOptions): val is Atlas {\n  return val && val.type === ResourceType.ATLAS;\n}\n\ntype ResourceReference = {\n  subtexture: SubTexture;\n  count: number;\n  videoMonitor?: VideoTextureMonitor;\n};\n\n/**\n * This represents a single Texture on the gpu that is composed of several smaller textures\n * as a 'look up'.\n */\nexport class Atlas extends IdentifyByKey implements IAtlasResource {\n  /** Stores the size of the atlas texture */\n  height: TextureSize;\n  /** This is the packing of the atlas with images */\n  packing: PackNode<SubTexture>;\n  /**\n   * This is storage for handling resource reference counting. When a resource's reference drops below\n   * a count of 1, then the resource is disposed and it's space on the atlas is flagged for freeing up\n   * should the atlas need to consolidate resources.\n   */\n  resourceReferences = new Map<\n    IAtlasResourceRequest[\"source\"],\n    ResourceReference\n  >();\n  /** This is the actual texture object that represents the atlas on the GPU */\n  texture: Texture;\n  /** These are the applied settings to our texture */\n  textureSettings?: TextureOptions;\n  /** The resource type for resource management */\n  type: number = ResourceType.ATLAS;\n  /** Stores the size of the atlas texture */\n  width: TextureSize;\n\n  constructor(options: IAtlasResource) {\n    super(options);\n    const canvas = document.createElement(\"canvas\");\n    this.width = canvas.width = options.width;\n    this.height = canvas.height = options.height;\n    this.textureSettings = options.textureSettings;\n\n    // Set up the packing for this atlas\n    this.packing = new PackNode(0, 0, options.width, options.height);\n    // Make sure the texture is started and updated\n    this.createTexture(canvas);\n  }\n\n  /**\n   * This generates the texture object needed for this atlas.\n   */\n  private createTexture(canvas?: HTMLCanvasElement) {\n    if (this.texture) return;\n\n    // Establish the settings to be applied to the Texture\n    let textureSettings;\n\n    if (this.textureSettings) {\n      textureSettings = {\n        generateMipMaps: true,\n        premultiplyAlpha: true,\n        ...this.textureSettings\n      };\n    } else {\n      textureSettings = {\n        generateMipMaps: true,\n        premultiplyAlpha: true\n      };\n    }\n\n    // Generate the texture\n    this.texture = new Texture({\n      data: canvas,\n      ...textureSettings\n    });\n  }\n\n  /**\n   * This frees up all the resources down to the GPU related to this atlas. It also\n   * loops through every resource and invalidates the texturing information within\n   * them so subsequent accidental renders will appear as a single color rather than\n   * an artifacted element.\n   */\n  destroy() {\n    // Delete the GPU's texture object\n    this.texture.dispose();\n\n    // Invalidate the Sub textures so they don't start rendering wild colors. Instead\n    // should render a single color at the 0, 0 mark of the texture.\n    this.resourceReferences.forEach(resource => {\n      this.invalidateTexture(resource.subtexture);\n    });\n  }\n\n  /**\n   * This invalidates the SubTexture of an atlas resource.\n   */\n  private invalidateTexture(texture: SubTexture) {\n    const zero: Vec2 = [0, 0];\n\n    // Make anything trying to render with the image not render much anything useful\n    texture.aspectRatio = 1;\n    texture.atlasBL = zero;\n    texture.atlasBR = zero;\n    texture.atlasTL = zero;\n    texture.atlasTR = zero;\n    texture.isValid = false;\n    texture.texture = null;\n    texture.pixelHeight = 0;\n    texture.pixelWidth = 0;\n    delete texture.source;\n\n    // Video monitoring should be stopped at this point.\n    if (texture.video) {\n      texture.video.monitor.destroy();\n      delete texture.video;\n    }\n  }\n\n  /**\n   * This will look through all resources in this atlas and will determine if the resource\n   * should be removed or not.\n   */\n  resolveResources() {\n    const toRemove: IAtlasResourceRequest[\"source\"][] = [];\n\n    this.resourceReferences.forEach((ref, source) => {\n      if (ref.count <= 0 && ref.subtexture) {\n        debug(\n          \"A subtexture on an atlas has been invalidated as it is deemed no longer used: %o\",\n          ref.subtexture\n        );\n        this.invalidateTexture(ref.subtexture);\n        toRemove.push(source);\n      }\n    });\n\n    for (let i = 0, iMax = toRemove.length; i < iMax; ++i) {\n      this.resourceReferences.delete(toRemove[i]);\n    }\n  }\n\n  /**\n   * This flags a resource no longeer used and decrements it's reference count.\n   * If the use of the resource drops low enough, this will clear out the resurce\n   * completely.\n   */\n  stopUsingResource(request: IAtlasResourceRequest) {\n    const reference: ResourceReference = this.resourceReferences.get(\n      request.source\n    ) || {\n      subtexture: request.texture || new SubTexture(),\n      count: 0\n    };\n\n    reference.count--;\n  }\n\n  /**\n   * This flags a resource for use and increments it's reference count.\n   */\n  useResource(request: IAtlasResourceRequest) {\n    const reference = this.resourceReferences.get(request.source) || {\n      subtexture: request.texture,\n      count: 0\n    };\n\n    reference.count++;\n  }\n}\n","/**\n * This is the name used in the shader generated by the system to handle uniform buffer instancing.\n */\nexport const uniformBufferInstanceBufferName = \"instanceData\";\n/**\n * This is the identifying name used as the active atttribute\n * that determines if an instance is rendered or not.\n */\nexport const activeAttributeName = \"_active\";\n/**\n * Constant that can convert a number expressed in degrees to radians by multiplying\n */\nexport const TO_RADIANS = Math.PI / 180;\n/**\n * Constant that can convert a number expressed in radians to degrees by multiplying\n */\nexport const TO_DEGREES = 180 / Math.PI;\n","import { IInstanceProvider, InstanceDiff, InstanceDiffType } from \"../types\";\nimport { uid } from \"../util/uid\";\nimport { Instance } from \"./instance\";\n\ntype InstanceDisposer<T extends Instance> = [T, Function];\n\n/**\n * This is an optimized provider, that can provide instances that use the internal observable system\n * to deliver updates to the framework.\n */\nexport class InstanceProvider<T extends Instance>\n  implements IInstanceProvider<T> {\n  /** A uid provided to this object to give it some easy to identify uniqueness */\n  get uid() {\n    return this._uid;\n  }\n  private _uid: number = uid();\n  /** Stores the disposers that are called when the instance is no longer listened to */\n  private cleanObservation = new Map<number, InstanceDisposer<T>>();\n  /** This stores the changes to the instances themselves */\n  private instanceChanges = new Map<number, InstanceDiff<T>>();\n  /** This flag is true when resolving changes when the change list is retrieved. it blocks changes until the current list is resolved */\n  private allowChanges = true;\n  /**\n   * This indicates the context this provider was handled within. Currently, only one context is allowed per provider,\n   * so we use this to detect when multiple contexts have attempted use of this provider.\n   */\n  resolveContext: string = \"\";\n\n  constructor(instances?: T[]) {\n    if (instances) {\n      for (let i = 0, iMax = instances.length; i < iMax; ++i) {\n        const instance = instances[i];\n        this.add(instance);\n      }\n    }\n  }\n\n  /**\n   * Retrieve all of the changes applied to instances\n   */\n  get changeList(): InstanceDiff<T>[] {\n    this.allowChanges = false;\n    const changes: InstanceDiff<T>[] = [];\n    this.instanceChanges.forEach(val => changes.push(val));\n\n    return changes;\n  }\n\n  /**\n   * Adds an instance to the provider which will stream observable changes of the instance to\n   * the framework.\n   */\n  add(instance: T) {\n    // No need to duplicate the addition\n    if (this.cleanObservation.get(instance.uid)) {\n      return instance;\n    }\n\n    if (this.allowChanges) {\n      instance.observer = this;\n      const disposer: Function = instance.observableDisposer;\n      // Store the disposers so we can clean up the observable properties\n      this.cleanObservation.set(instance.uid, [instance, disposer]);\n      // Indicate we have a new instance\n      this.instanceChanges.set(instance.uid, [\n        instance,\n        InstanceDiffType.INSERT,\n        instance.changes\n      ]);\n    }\n\n    return instance;\n  }\n\n  /**\n   * Removes all instances from this provider\n   */\n  clear() {\n    this.cleanObservation.forEach(values => {\n      this.remove(values[0]);\n    });\n  }\n\n  /**\n   * Clear all resources held by this provider. It IS valid to lose reference to all instances\n   * and to this object, which would effectively cause this object to get GC'ed. But if you\n   * desire to hang onto the instance objects, then this should be called.\n   */\n  destroy() {\n    this.cleanObservation.forEach(values => {\n      values[1]();\n    });\n\n    this.cleanObservation.clear();\n    this.instanceChanges.clear();\n  }\n\n  /**\n   * This is called from observables to indicate it's parent has been updated.\n   * This is what an instance calls when it's observable property is modified.\n   */\n  instanceUpdated(instance: T) {\n    if (this.allowChanges) {\n      // Flag the instance as having a property changed\n      this.instanceChanges.set(instance.uid, [\n        instance,\n        InstanceDiffType.CHANGE,\n        instance.changes\n      ]);\n    }\n  }\n\n  /**\n   * Stops the instance's ability to register changes with this provider and flags\n   * a final removal diff change.\n   */\n  remove(instance: T) {\n    if (this.allowChanges) {\n      const disposer = this.cleanObservation.get(instance.uid);\n\n      if (disposer) {\n        disposer[1]();\n        this.cleanObservation.delete(instance.uid);\n        this.instanceChanges.set(instance.uid, [\n          instance,\n          InstanceDiffType.REMOVE,\n          {}\n        ]);\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Flagged all changes as dealt with\n   */\n  resolve(context: string) {\n    this.allowChanges = true;\n    this.instanceChanges.clear();\n\n    if (this.resolveContext && this.resolveContext !== context) {\n      throw new Error(\n        \"An instance provider has been issued to two layers. This is not a suppported feature yet and can cause issues.\"\n      );\n    }\n\n    this.resolveContext = context;\n  }\n\n  /**\n   * This performs an operation that forces all of the instances to be flagged as an\n   * 'add' change. This allows a layer listening to this provider to ensure it has added\n   * all currently existing instances monitored by the provider.\n   *\n   * NOTE: This is a VERY poor performing method and should probably be used by the framework\n   * and not manually.\n   */\n  sync() {\n    const emptyPropertyChanges: number[] = [];\n\n    // Loop through all registered instances (which is only stored in the disposer list kept by this provider)\n    this.cleanObservation.forEach(disposer => {\n      const [instance] = disposer;\n      // Flag the instance as having a property changed\n      this.instanceChanges.set(instance.uid, [\n        instance,\n        InstanceDiffType.INSERT,\n        emptyPropertyChanges\n      ]);\n    });\n  }\n}\n","import { observable } from \"../../../instance-provider\";\nimport {\n  IInstanceOptions,\n  Instance\n} from \"../../../instance-provider/instance\";\nimport { Vec2 } from \"../../../math\";\nimport { isWhiteSpace, Size } from \"../../../types\";\nimport { Anchor, AnchorType } from \"../../types\";\nimport { GlyphInstance } from \"./glyph-instance\";\nimport { TextAreaInstance } from \"./text-area-instance\";\n\nexport interface ILabelInstanceOptions extends IInstanceOptions {\n  /**\n   * The point on the label which will be placed in world space via the x, y coords. This is also the point\n   * which the label will be scaled around.\n   */\n  anchor?: Anchor;\n  /** The color the label should render as */\n  color: [number, number, number, number];\n  /** Depth sorting of the label (or the z value of the label) */\n  depth?: number;\n  /** The font size of the label in px */\n  fontSize?: number;\n  /** When this is set labels will only draw the label up to this size. If below, the label will automatically truncate with ellipses */\n  maxWidth?: number;\n  /** When in BOUND_MAX mode, this allows the label to scale up beyond it's max size */\n  maxScale?: number;\n  /** Scales the label uniformly */\n  scale?: number;\n  /** The text rendered by this label*/\n  text: string;\n  /** The xy coordinate where the label will be anchored to in world space */\n  origin: Vec2;\n  /**\n   * Special flag for the instance that will cause the instance to not render any glyphs but will ensure the label's\n   * Kerning is calculated.\n   */\n  preload?: boolean;\n  /** Spacing width between letters in a label */\n  letterSpacing?: number;\n  /** Event when the label is completely ready to render all of it's glyphs */\n  onReady?(instance: LabelInstance): void;\n}\n\n/**\n * This generates a new label instance which will render a single line of text for a given layer.\n * There are restrictions surrounding labels due to texture sizes and rendering limitations.\n */\nexport class LabelInstance extends Instance {\n  /** This is the rendered color of the label */\n  @observable color: [number, number, number, number] = [0, 0, 0, 1];\n  /** Depth sorting of the label (or the z value of the label) */\n  @observable depth: number = 0;\n  /**\n   * Font size in world coordinates. This causes scaling relative to the base font resource available.\n   * IE- If the font resource is rendered at 32 and this is 16, then the output rendering will\n   *     be glyphs that are 50% the size of the rendered glyph in the font map. This can cause\n   *     artefacts based on the rendering strategy used.\n   */\n  @observable fontSize: number = 12;\n  /** When in BOUND_MAX mode, this controls how much scaling is allowed up to the base font size */\n  @observable maxScale: number = 1;\n  /**\n   * This is the maximum width the label can take up. If this is exceeded the label gets truncated.\n   * A max width of 0 or less is unbounded and will not truncate the text. When a max width is specified,\n   * there will always be a minimum requirement to show ellipses which inevitably causes a min width to\n   * arise and is dependent on the font in use.\n   */\n  @observable maxWidth: number = 0;\n  /** The x coordinate where the label will be anchored to in world space */\n  @observable origin: Vec2 = [0, 0];\n  /** Scales the label uniformly */\n  @observable scale: number = 1.0;\n  /** The rendered text for the label. */\n  @observable text: string = \"\";\n  /** Spacing between letters in a label */\n  @observable letterSpacing: number = 0;\n\n  /** This executes when the label is finished waiting for it's glyphs to be ready to render */\n  onReady?: (label: LabelInstance) => void;\n  /** The text area this label is associated with (may NOT be associated at all) */\n  parentTextArea?: TextAreaInstance;\n  /**\n   * Special flag for the instance that will cause the instance to not render any glyphs but will ensure the label's\n   * Kerning is calculated.\n   */\n  preload: boolean = false;\n  /**\n   * After the label has been rendered, this will be populated with all of the glyphs that\n   * have been created for the label. Using this you can manipulate each character very easily.\n   *\n   * NOTE: it helps to use nextFrame() to wait for this to be populated after the label has been mounted.\n   */\n  glyphs: GlyphInstance[] = [];\n  /**\n   * After the label has been rendered, this will be populated with the calculated width and height of the\n   * label.\n   */\n  size: Size = [0, 0];\n\n  /**\n   * If a maxWidth is specified, there is a chance the text will be truncated.\n   * This provides the calculated truncated text. If not populated, then no truncation\n   * has happened.\n   */\n  truncatedText: string = \"\";\n\n  /** This is the anchor location relative to the label's render space */\n  @observable\n  anchor: Anchor = {\n    padding: 0,\n    paddingDirection: [0, 0],\n    type: AnchorType.TopLeft,\n    x: 0,\n    y: 0\n  };\n\n  constructor(options: ILabelInstanceOptions) {\n    super(options);\n\n    this.anchor = options.anchor || this.anchor;\n    this.color = options.color || this.color;\n    this.depth = options.depth || this.depth;\n    this.fontSize = options.fontSize || this.fontSize;\n    this.maxScale = options.maxScale || this.maxScale;\n    this.maxWidth = options.maxWidth || 0;\n    this.onReady = options.onReady;\n    this.origin = options.origin;\n    this.preload = options.preload || false;\n    this.scale = options.scale || this.scale;\n    this.text = options.text || this.text;\n    this.letterSpacing = options.letterSpacing || this.letterSpacing;\n\n    // Make sure the anchor is set to the appropriate location\n    options.anchor && this.setAnchor(options.anchor);\n  }\n\n  getWidth(): number {\n    return this.size[0];\n  }\n\n  /**\n   * This applies a new anchor to this label and properly determines it's anchor position on the label\n   */\n  setAnchor(anchor: Anchor) {\n    const newAnchor = {\n      padding: anchor.padding || 0,\n      paddingDirection: anchor.paddingDirection,\n      type: anchor.type,\n      x: anchor.x || 0,\n      y: anchor.y || 0\n    };\n\n    // Apply the anchor\n    this.anchor = newAnchor;\n  }\n\n  /**\n   * Looks for the subtext provided, then provides the glyphs for that subtext if any.\n   */\n  subTextGlyphs(text: string): GlyphInstance[] {\n    const glyphs: GlyphInstance[] = [];\n    const index = this.text.indexOf(text);\n    // The substring must exist within the text.\n    if (index < 0) return glyphs;\n    // Current glyph index we are at as white space does not receive a glyph.\n    let glyphIndex = 0;\n\n    for (\n      let i = 0, iMax = Math.min(this.text.length, index + text.length);\n      i < iMax;\n      ++i\n    ) {\n      if (!isWhiteSpace(this.text[i])) {\n        glyphIndex++;\n\n        if (i >= index) {\n          glyphs.push(this.glyphs[glyphIndex]);\n        }\n      }\n    }\n\n    return glyphs;\n  }\n\n  /**\n   * Trigger for when resources are prepped for this instance\n   */\n  resourceTrigger() {\n    // No triggers are needed for the label instance as it's a wrapper for glyphs.\n    // The only trigger needed is when the active flag is altered by the manager.\n  }\n}\n","import { CanvasElement, isOffscreenCanvas } from \"../gl\";\nimport { Bounds } from \"../math/primitives\";\nimport { add2, length2, scale2, subtract2, Vec2 } from \"../math/vector\";\nimport { LayerScene } from \"../surface/layer-scene\";\nimport { Surface } from \"../surface/surface\";\nimport { IViewProps, NoView, View } from \"../surface/view\";\nimport { isDefined } from \"../util/common-filters\";\nimport { eventElementPosition, normalizeWheel } from \"../util/mouse\";\nimport { QuadTree } from \"../util/quad-tree\";\nimport { EventManager } from \"./event-manager\";\nimport {\n  IMouseInteraction,\n  IMouseMetrics,\n  IMultiTouchInteraction,\n  IMultiTouchMetrics,\n  ISingleTouchInteraction,\n  ITouchInteraction,\n  ITouchMetrics,\n  IWheelMetrics\n} from \"./types\";\n\n// If a mouse up after a mouse down happens before this many milliseconds, a click gesture will happen\nconst VALID_CLICK_DELAY = 1e3;\nconst VALID_TAP_DELAY = 200;\nconst emptyView: View<IViewProps> = new NoView();\n\nemptyView.fitViewtoViewport(\n  new Bounds({ x: 0, y: 0, width: 100, height: 100 }),\n  new Bounds({ x: 0, y: 0, width: 100, height: 100 })\n);\n\nfunction sortByDepth(a: Bounds<View<IViewProps>>, b: Bounds<View<IViewProps>>) {\n  if (b.d && a.d) return b.d.depth - a.d.depth;\n  return 0;\n}\n\n/**\n * Sorts touch metrics by the identifier for the touch\n */\nfunction sortByIdentifier(a: ITouchMetrics, b: ITouchMetrics) {\n  return a.touch.identifier - b.touch.identifier;\n}\n\n/**\n * This manages mouse events on the provided canvas and provides some higher level\n * interactions with the surface.\n */\nexport class UserInputEventManager {\n  /** This is the canvas context we are rendering to */\n  context: CanvasElement;\n  /** This is list of Event Managers that receive the events and gestures which perform the nexessary actions */\n  controllers: EventManager[];\n  /** This is the quad tree for finding intersections with the mouse */\n  quadTree: QuadTree<Bounds<View<IViewProps>>>;\n  /** The parent layer surface this event manager is beneath */\n  surface: Surface;\n  /** The events created that need to be removed */\n  eventCleanup: [string, EventListenerOrEventListenerObject][] = [];\n\n  /**\n   * This flag is set when the system is waiting to render the elements to establish bounds.\n   * No Mouse interations will happen while this is set to true.\n   */\n  private _waitingForRender: boolean = true;\n\n  get waitingForRender() {\n    return this._waitingForRender;\n  }\n\n  set waitingForRender(val: boolean) {\n    this._waitingForRender = val;\n\n    // When we're no longer waiting for render to occur we update all of our views in the quad tree\n    if (!val) {\n      this.quadTree = new QuadTree(0, 0, 0, 0);\n      const scenes = this.scenes;\n      const bounds = [];\n\n      for (let i = 0, iMax = scenes.length; i < iMax; ++i) {\n        const scene = scenes[i];\n\n        for (let k = 0, kMax = scene.views.length; k < kMax; ++k) {\n          const view = scene.views[k];\n          bounds.push(view.screenBounds);\n        }\n      }\n\n      this.quadTree.addAll(bounds);\n    }\n  }\n\n  get scenes(): LayerScene[] {\n    if (!this.surface || !this.surface.sceneDiffs) return [];\n    return this.surface.sceneDiffs.items;\n  }\n\n  constructor(\n    canvas: CanvasElement,\n    surface: Surface,\n    controllers: EventManager[],\n    handlesWheelEvents?: boolean\n  ) {\n    this.context = canvas;\n    this.surface = surface;\n    this.setControllers(controllers);\n    this.addContextListeners(handlesWheelEvents);\n  }\n\n  /**\n   * This sets up the DOM events to listen to the events that are broadcasted by the canvas.\n   * These events are set up in such a way as to continue some events when the user\n   * drags the mouse off of the browser or off the canvas without releasing.\n   */\n  addContextListeners(handlesWheelEvents?: boolean) {\n    // Enable mouse support\n    this.addMouseContextListeners(handlesWheelEvents);\n    // Enable touch support\n    this.addTouchContextListeners();\n  }\n\n  /**\n   * Adds all listeners needed to make the mouse interact with the context.\n   */\n  private addMouseContextListeners(handlesWheelEvents?: boolean) {\n    const element = this.context;\n    // If we are working with an offscreen canvas, there are no mouse events to be applied\n    if (isOffscreenCanvas(element)) return;\n    // This will store the metrics calculated and found for the mouse\n    let mouseMetrics: IMouseMetrics | undefined;\n    // This is a special flag that aids in managing when the mouse is moving over a document AND the element. Both can\n    // not calculate the movements of the mouse at the same time, lest they fry the delta information before both events\n    // get processed by the managers.\n    let elementMovedBeforeDocMoved = false;\n\n    if (handlesWheelEvents) {\n      const wheelHandler = (event: MouseWheelEvent) => {\n        const mouse = eventElementPosition(event, element);\n        const viewsUnderMouse = this.getViewsUnderPosition(mouse);\n        if (viewsUnderMouse.length <= 0) return;\n\n        mouseMetrics = {\n          canClick: false,\n          currentPosition: mouse,\n          deltaPosition: [0, 0],\n          previousPosition: mouse,\n          start: mouse,\n          startTime: Date.now(),\n          startView: viewsUnderMouse[0].d,\n          event,\n          wheel: this.makeWheel(event),\n          button: -1\n        };\n\n        const interaction = this.makeMouseInteraction(mouseMetrics);\n\n        this.controllers.forEach(controller => {\n          controller.handleWheel(interaction);\n        });\n\n        event.stopPropagation();\n        event.preventDefault();\n      };\n\n      if (\"onwheel\" in element) {\n        element.onwheel = wheelHandler;\n      }\n\n      if (\"addEventListener\" in element) {\n        element.addEventListener(\"DOMMouseScroll\", wheelHandler);\n        this.eventCleanup.push([\"DOMMouseScroll\", wheelHandler]);\n      }\n    }\n\n    element.onmouseleave = (event: any) => {\n      // No interactions while waiting for the render to update\n      if (this.waitingForRender || !mouseMetrics) return;\n\n      const mouse = eventElementPosition(event, element);\n      mouseMetrics.deltaPosition = subtract2(\n        mouse,\n        mouseMetrics.currentPosition\n      );\n      mouseMetrics.previousPosition = mouseMetrics.currentPosition;\n      mouseMetrics.currentPosition = mouse;\n      const interaction = this.makeMouseInteraction(mouseMetrics);\n\n      this.controllers.forEach(controller => {\n        controller.handleMouseOut(interaction);\n      });\n    };\n\n    element.onmousemove = (event: any) => {\n      // No interactions while waiting for the render to update\n      if (this.waitingForRender) return;\n      const mouse = eventElementPosition(event, element);\n\n      if (!mouseMetrics) {\n        const viewsUnderMouse = this.getViewsUnderPosition(mouse);\n\n        mouseMetrics = {\n          canClick: false,\n          currentPosition: mouse,\n          deltaPosition: [0, 0],\n          previousPosition: mouse,\n          start: mouse,\n          startTime: Date.now(),\n          startView: viewsUnderMouse[0].d,\n          event,\n          wheel: this.makeWheel(),\n          button: -1\n        };\n      }\n\n      mouseMetrics.deltaPosition = subtract2(\n        mouse,\n        mouseMetrics.currentPosition\n      );\n      mouseMetrics.previousPosition = mouseMetrics.currentPosition;\n      mouseMetrics.currentPosition = mouse;\n      mouseMetrics.canClick = false;\n      const interaction = this.makeMouseInteraction(mouseMetrics);\n\n      this.controllers.forEach(controller => {\n        controller.handleMouseMove(interaction);\n      });\n\n      elementMovedBeforeDocMoved = true;\n    };\n\n    element.onmousedown = (event: any) => {\n      // No interactions while waiting for the render to update\n      if (this.waitingForRender) return;\n\n      const startPosition = eventElementPosition(event, element);\n      const downViews = this.getViewsUnderPosition(startPosition);\n\n      // If no views under this view, then we just quick exit with no interactions\n      if (downViews.length <= 0) {\n        return;\n      }\n\n      mouseMetrics = {\n        canClick: true,\n        currentPosition: startPosition,\n        deltaPosition: [0, 0],\n        previousPosition: startPosition,\n        start: startPosition,\n        startTime: Date.now(),\n        startView: downViews[0].d,\n        event,\n        wheel: this.makeWheel(),\n        button: event.button\n      };\n\n      const interaction = this.makeMouseInteraction(mouseMetrics);\n\n      this.controllers.forEach(controller => {\n        controller.handleMouseDown(interaction);\n      });\n\n      event.stopPropagation();\n\n      document.onmousemove = (event: any) => {\n        if (!mouseMetrics) return;\n\n        if (!elementMovedBeforeDocMoved) {\n          const mouse = eventElementPosition(event, element);\n          mouseMetrics.deltaPosition = subtract2(\n            mouse,\n            mouseMetrics.currentPosition\n          );\n          mouseMetrics.previousPosition = mouseMetrics.currentPosition;\n          mouseMetrics.currentPosition = mouse;\n          mouseMetrics.canClick = false;\n        }\n\n        const interaction = this.makeMouseInteraction(mouseMetrics);\n\n        this.controllers.forEach(controller => {\n          controller.handleDrag(interaction);\n        });\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        // Reset the element moved flag so we can see if the doc movement needs to handle the mouse metrics\n        elementMovedBeforeDocMoved = false;\n      };\n\n      document.onmouseup = _event => {\n        document.onmousemove = null;\n        document.onmouseup = null;\n        document.onmouseover = null;\n        mouseMetrics = undefined;\n      };\n\n      document.onmouseover = event => {\n        if (!mouseMetrics) return;\n\n        const mouse = eventElementPosition(event, element);\n        mouseMetrics.deltaPosition = subtract2(\n          mouse,\n          mouseMetrics.currentPosition\n        );\n        mouseMetrics.previousPosition = mouseMetrics.currentPosition;\n        mouseMetrics.currentPosition = mouse;\n        const interaction = this.makeMouseInteraction(mouseMetrics);\n\n        this.controllers.forEach(controller => {\n          controller.handleMouseOver(interaction);\n        });\n\n        event.stopPropagation();\n      };\n\n      element.onmouseup = event => {\n        if (!mouseMetrics) return;\n        const mouse = eventElementPosition(event, element);\n        mouseMetrics.deltaPosition = subtract2(\n          mouse,\n          mouseMetrics.currentPosition\n        );\n        mouseMetrics.previousPosition = mouseMetrics.currentPosition;\n        mouseMetrics.currentPosition = mouse;\n        mouseMetrics.button = event.button;\n        const interaction = this.makeMouseInteraction(mouseMetrics);\n\n        this.controllers.forEach(controller => {\n          controller.handleMouseUp(interaction);\n        });\n\n        // If we release the mouse before the valid click delay\n        if (\n          mouseMetrics.canClick &&\n          Date.now() - mouseMetrics.startTime < VALID_CLICK_DELAY\n        ) {\n          this.controllers.forEach(controller => {\n            controller.handleClick(interaction);\n          });\n        }\n\n        mouseMetrics = undefined;\n      };\n\n      // Text will not be selected when it is being dragged\n      const experimental = element as any;\n      if (experimental.onselectstart !== undefined) {\n        experimental.onselectstart = function() {\n          return false;\n        };\n      } else {\n        element.addEventListener(\"selectstart\", function() {\n          event.preventDefault();\n        });\n      }\n    };\n  }\n\n  /**\n   * Adds all the listeners necessary to make the context interactive with multitouch support.\n   */\n  private addTouchContextListeners() {\n    // This is the element we are listening to for touch events\n    const element = this.context;\n    // If this is an offscreen canvas, no interactions will happen\n    if (isOffscreenCanvas(element)) return;\n    // This stores the most recent touch metrics associated with a touch by the touch's identifier\n    const trackedTouches = new Map<number, ITouchMetrics>();\n    // This is the most recent touch interaction event recorded for the touch, identifiable by the touch's identifier\n    const currentTouchInteractions = new Map<number, ISingleTouchInteraction>();\n\n    /**\n     * Converts Touch interaction list to touch metrics\n     */\n    function getTouchMetrics(touches: ISingleTouchInteraction[]) {\n      return touches.map(t => t.touch);\n    }\n\n    /**\n     * Gets the touch that happened the most recent.\n     */\n    function getLatestTouch(touches: ISingleTouchInteraction[]) {\n      return touches.reduce(\n        (p, n) => (n.touch.startTime > p.touch.startTime ? n : p),\n        touches[0]\n      );\n    }\n\n    /**\n     * This is the multitouch query object handed to our controllers so they can query for metrics for multiple touches\n     */\n    const multiTouchInteraction: IMultiTouchInteraction = {\n      center: (touches: ISingleTouchInteraction[]) => {\n        if (touches.length <= 0) return [0, 0];\n\n        return this.getTouchCenter(getTouchMetrics(touches));\n      },\n\n      centerDelta: (touches: ISingleTouchInteraction[]) => {\n        if (touches.length <= 0) return [0, 0];\n        const metrics = getTouchMetrics(touches);\n        const previous = this.getTouchCenter(\n          metrics,\n          (touch: ITouchMetrics) => touch.previousPosition\n        );\n        const current = this.getTouchCenter(metrics);\n\n        return subtract2(current, previous);\n      },\n\n      centerStart: (touches: ISingleTouchInteraction[]) => {\n        if (touches.length <= 0) return [0, 0];\n        const primary = getLatestTouch(touches).touch;\n\n        return this.getTouchCenter(\n          getTouchMetrics(touches),\n          (touch: ITouchMetrics) => {\n            if (touch === primary) {\n              return touch.start;\n            }\n\n            return touch.startRelative.get(primary) || [0, 0];\n          }\n        );\n      },\n\n      id: (touches: ISingleTouchInteraction[]) => {\n        const metrics = getTouchMetrics(touches);\n\n        return metrics\n          .sort(sortByIdentifier)\n          .map(m => m.touch.identifier)\n          .join(\"_\");\n      },\n\n      rotation: (touches: ISingleTouchInteraction[]) => {\n        if (touches.length <= 0) return 0;\n        const metrics = getTouchMetrics(touches);\n        const center = this.getTouchCenter(metrics);\n\n        return this.getAverageAngle(metrics, center);\n      },\n\n      rotationDelta: (touches: ISingleTouchInteraction[]) => {\n        if (touches.length <= 0) return 0;\n        const metrics = getTouchMetrics(touches);\n        const previousCenter = this.getTouchCenter(\n          metrics,\n          (touch: ITouchMetrics) => touch.previousPosition\n        );\n        const previousAngle = this.getAverageAngle(\n          metrics,\n          previousCenter,\n          (touch: ITouchMetrics) => touch.previousPosition\n        );\n        const currentCenter = this.getTouchCenter(metrics);\n        const currentAngle = this.getAverageAngle(metrics, currentCenter);\n\n        return currentAngle - previousAngle;\n      },\n\n      rotationStart: (touches: ISingleTouchInteraction[]) => {\n        if (touches.length <= 0) return 0;\n        const primary = getLatestTouch(touches).touch;\n        const metrics = getTouchMetrics(touches);\n\n        const startCenter = this.getTouchCenter(\n          metrics,\n          (touch: ITouchMetrics) => {\n            if (touch === primary) {\n              return touch.start;\n            }\n\n            return touch.startRelative.get(primary) || [0, 0];\n          }\n        );\n\n        return this.getAverageAngle(\n          metrics,\n          startCenter,\n          (touch: ITouchMetrics) => {\n            if (touch === primary) {\n              return touch.start;\n            }\n\n            return touch.startRelative.get(primary) || [0, 0];\n          }\n        );\n      },\n\n      spread: (touches: ISingleTouchInteraction[]) => {\n        if (touches.length <= 0) return 0;\n        const metrics = getTouchMetrics(touches);\n        const center = this.getTouchCenter(metrics);\n\n        return this.getAverageDistance(metrics, center);\n      },\n\n      spreadDelta: (touches: ISingleTouchInteraction[]) => {\n        if (touches.length <= 0) return 0;\n        const metrics = getTouchMetrics(touches);\n        const previousCenter = this.getTouchCenter(\n          metrics,\n          (touch: ITouchMetrics) => touch.previousPosition\n        );\n        const previousSpread = this.getAverageDistance(\n          metrics,\n          previousCenter,\n          (touch: ITouchMetrics) => touch.previousPosition\n        );\n        const currentCenter = this.getTouchCenter(metrics);\n        const currentSpread = this.getAverageDistance(metrics, currentCenter);\n\n        return currentSpread - previousSpread;\n      },\n\n      spreadStart: (touches: ISingleTouchInteraction[]) => {\n        if (touches.length <= 0) return 0;\n        const primary = getLatestTouch(touches).touch;\n        const metrics = getTouchMetrics(touches);\n\n        const startCenter = this.getTouchCenter(\n          metrics,\n          (touch: ITouchMetrics) => {\n            if (touch === primary) {\n              return touch.start;\n            }\n\n            return touch.startRelative.get(primary) || [0, 0];\n          }\n        );\n\n        return this.getAverageDistance(\n          metrics,\n          startCenter,\n          (touch: ITouchMetrics) => {\n            if (touch === primary) {\n              return touch.start;\n            }\n\n            return touch.startRelative.get(primary) || [0, 0];\n          }\n        );\n      }\n    };\n\n    element.ontouchstart = event => {\n      event.preventDefault();\n      event.stopPropagation();\n      const touches = this.getTouches(event);\n      const currentTouches: ITouchMetrics[] = [];\n      const newTouches: ITouchMetrics[] = [];\n\n      for (let i = 0, iMax = touches.length; i < iMax; ++i) {\n        const touch = touches[i];\n        const trackedTouch = trackedTouches.get(touch.identifier);\n\n        if (!trackedTouch) {\n          const position = eventElementPosition(touch);\n          const downViews = this.getViewsUnderPosition(position);\n          if (downViews.length <= 0) continue;\n          const startView = downViews[0].d;\n\n          const metrics: ITouchMetrics = {\n            canTap: true,\n            currentPosition: position,\n            deltaPosition: [0, 0],\n            startTime: Date.now(),\n            start: position,\n            startView,\n            previousPosition: position,\n            startRelative: new Map(),\n            touch\n          };\n\n          // Track the information with the touch\n          trackedTouches.set(touch.identifier, metrics);\n          // Identify which touches are new\n          newTouches.push(metrics);\n        } else {\n          // Identify existing touches\n          currentTouches.push(trackedTouch);\n        }\n      }\n\n      // If we have a change in touch count, then we have to create relative start positions for all touches that\n      // now exists\n      if (newTouches.length > 0) {\n        const allTouches = newTouches.concat(currentTouches);\n        const singleInteractions: ISingleTouchInteraction[] = [];\n\n        for (let i = 0, iMax = newTouches.length; i < iMax; ++i) {\n          const newTouch = newTouches[i];\n\n          for (let k = 0, kMax = allTouches.length; k < kMax; ++k) {\n            const touch = allTouches[k];\n\n            if (newTouch !== touch) {\n              touch.startRelative.set(newTouch, touch.currentPosition);\n            }\n          }\n\n          // Make the interaction for the single touch\n          const interaction = this.makeSingleTouchInteraction(newTouch);\n          singleInteractions.push(interaction);\n          currentTouchInteractions.set(newTouch.touch.identifier, interaction);\n        }\n\n        const downEvent: ITouchInteraction = {\n          touches: singleInteractions,\n          allTouches: allTouches\n            .map(t => currentTouchInteractions.get(t.touch.identifier))\n            .filter(isDefined),\n          multitouch: multiTouchInteraction\n        };\n\n        // Broadcast to the controllers\n        this.controllers.forEach(controller => {\n          controller.handleTouchDown(downEvent);\n        });\n      }\n\n      // Add all of the document events\n      document.ontouchend = event => {\n        documenttouchend.call(document, event);\n        document.ontouchend = null;\n        document.ontouchcancel = null;\n        document.ontouchmove = null;\n      };\n\n      document.ontouchcancel = event => {\n        documenttouchcancel.call(document, event);\n        document.ontouchend = null;\n        document.ontouchcancel = null;\n        document.ontouchmove = null;\n      };\n\n      document.ontouchmove = documenttouchmove;\n    };\n\n    const documenttouchend = (element.ontouchend = event => {\n      // Prevent document events from handling twice\n      event.stopPropagation();\n      event.preventDefault();\n\n      // The touches actually ended are in the changed list in the event\n      const touches = this.getTouches(event, \"changed\");\n      const allTouches = Array.from(currentTouchInteractions.values());\n      const upTouches: ITouchMetrics[] = [];\n\n      for (let i = 0, iMax = touches.length; i < iMax; ++i) {\n        const touch = touches[i];\n        const touchMetrics = trackedTouches.get(touch.identifier);\n        if (!touchMetrics) continue;\n\n        // Detect a tap gesture\n        if (\n          touchMetrics.canTap &&\n          Date.now() - touchMetrics.startTime < VALID_TAP_DELAY\n        ) {\n          const interactions = [this.makeSingleTouchInteraction(touchMetrics)];\n\n          const tapEvent: ITouchInteraction = {\n            touches: interactions,\n            allTouches,\n            multitouch: multiTouchInteraction\n          };\n\n          // Broadcast to the controllers\n          this.controllers.forEach(controller => {\n            controller.handleTap(tapEvent);\n          });\n        }\n\n        // Always touch up as the touch is ended\n        upTouches.push(touchMetrics);\n        trackedTouches.delete(touch.identifier);\n        currentTouchInteractions.delete(touch.identifier);\n      }\n\n      if (upTouches.length > 0) {\n        const interactions = upTouches.map(metrics =>\n          this.makeSingleTouchInteraction(metrics)\n        );\n\n        const moveEvent: ITouchInteraction = {\n          touches: interactions,\n          allTouches,\n          multitouch: multiTouchInteraction\n        };\n\n        // Broadcast to the controllers\n        this.controllers.forEach(controller => {\n          controller.handleTouchUp(moveEvent);\n        });\n      }\n    });\n\n    const documenttouchmove = (element.ontouchmove = event => {\n      // We do not want the move events bubbling to the document to have repeat events broadcasted\n      event.stopPropagation();\n      event.preventDefault();\n\n      const touches = this.getTouches(event);\n      const moved = [];\n      const unmoved = [];\n\n      for (let i = 0, iMax = touches.length; i < iMax; ++i) {\n        const touch = touches[i];\n        const trackedTouch = trackedTouches.get(touch.identifier);\n\n        if (trackedTouch) {\n          const position = eventElementPosition(touch);\n          const deltaPosition = subtract2(\n            position,\n            trackedTouch.currentPosition\n          );\n\n          if (length2(deltaPosition) <= 0) {\n            unmoved.push(trackedTouch);\n            Object.assign(trackedTouch, {\n              currentPosition: position,\n              deltaPosition,\n              previousPosition: trackedTouch.currentPosition,\n              touch\n            });\n            continue;\n          }\n\n          moved.push(trackedTouch);\n\n          Object.assign(trackedTouch, {\n            canTap: false,\n            currentPosition: position,\n            deltaPosition,\n            previousPosition: trackedTouch.currentPosition,\n            touch\n          });\n        }\n      }\n\n      if (moved.length > 0) {\n        const all = moved.concat(unmoved);\n        const interactions = moved.map(metrics =>\n          this.makeSingleTouchInteraction(metrics)\n        );\n\n        const moveEvent: ITouchInteraction = {\n          touches: interactions,\n          allTouches: all\n            .map(m => currentTouchInteractions.get(m.touch.identifier))\n            .filter(isDefined),\n          multitouch: multiTouchInteraction\n        };\n\n        // Broadcast to the controllers\n        this.controllers.forEach(controller => {\n          controller.handleTouchDrag(moveEvent);\n        });\n      }\n    });\n\n    const documenttouchcancel = (element.ontouchcancel = event => {\n      // Prevent the document events from firing twice\n      event.stopPropagation();\n      event.preventDefault();\n\n      // The touches actually ended are in the changed list in the event\n      const touches = this.getTouches(event, \"changed\");\n      const allTouches = Array.from(currentTouchInteractions.values());\n      const upTouches: ITouchMetrics[] = [];\n\n      for (let i = 0, iMax = touches.length; i < iMax; ++i) {\n        const touch = touches[i];\n        const touchMetrics = trackedTouches.get(touch.identifier);\n        if (!touchMetrics) continue;\n        // Always touch up as the touch is ended\n        upTouches.push(touchMetrics);\n        trackedTouches.delete(touch.identifier);\n        currentTouchInteractions.delete(touch.identifier);\n      }\n\n      if (upTouches.length > 0) {\n        const interactions = upTouches.map(metrics =>\n          this.makeSingleTouchInteraction(metrics)\n        );\n\n        const moveEvent: ITouchInteraction = {\n          touches: interactions,\n          allTouches,\n          multitouch: multiTouchInteraction\n        };\n\n        // Broadcast to the controllers\n        this.controllers.forEach(controller => {\n          controller.handleTouchCancelled(moveEvent);\n        });\n      }\n    });\n  }\n\n  /**\n   * This takes all of the touches and averages their distance from the center point.\n   */\n  getAverageDistance(\n    touches: ITouchMetrics[],\n    center: Vec2,\n    accessor?: (touch: ITouchMetrics) => Vec2\n  ): number {\n    let total = 0;\n    if (touches.length <= 0) return total;\n    if (!accessor) accessor = (touch: ITouchMetrics) => touch.currentPosition;\n\n    for (let i = 0, iMax = touches.length; i < iMax; ++i) {\n      const touch = touches[i];\n      total += length2(subtract2(accessor(touch), center));\n    }\n\n    return total / touches.length;\n  }\n\n  /**\n   * This takes all of the touches and averages their angle around the center point.\n   */\n  getAverageAngle(\n    touches: ITouchMetrics[],\n    center: Vec2,\n    accessor?: (touch: ITouchMetrics) => Vec2\n  ): number {\n    let total = 0;\n    if (touches.length <= 0) return total;\n    if (!accessor) accessor = (touch: ITouchMetrics) => touch.currentPosition;\n\n    for (let i = 0, iMax = touches.length; i < iMax; ++i) {\n      const touch = touches[i];\n      const direction = subtract2(accessor(touch), center);\n      let angle = Math.atan2(direction[1], direction[0]);\n      if (angle < 0) angle += Math.PI * 2;\n      total += angle;\n    }\n\n    return total / touches.length;\n  }\n\n  /**\n   * This takes a list of touches and averages their position for a mid point between all of them.\n   */\n  getTouchCenter(\n    touches: ITouchMetrics[],\n    accessor?: (touch: ITouchMetrics) => Vec2\n  ): Vec2 {\n    let total: Vec2 = [0, 0];\n    if (touches.length <= 0) return total;\n    if (!accessor) accessor = (touch: ITouchMetrics) => touch.currentPosition;\n\n    for (let i = 0, iMax = touches.length; i < iMax; ++i) {\n      const touch = touches[i];\n      const position = accessor(touch);\n      total = add2(total, position);\n    }\n\n    return scale2(total, 1 / touches.length);\n  }\n\n  /**\n   * Retrieves all touches from a touch event. This normalizes the touch information across: touches, changedTouches,\n   * and targetTouches\n   */\n  getTouches(event: TouchEvent, category?: \"touches\" | \"changed\" | \"target\") {\n    const touches = new Map<number, Touch>();\n\n    if (\n      event.touches &&\n      event.touches.length > 0 &&\n      (!category || category === \"touches\")\n    ) {\n      for (let i = 0, iMax = event.touches.length; i < iMax; ++i) {\n        const touch = event.touches.item(i);\n        if (!touch) continue;\n        touches.set(touch.identifier, touch);\n      }\n    }\n\n    if (\n      event.changedTouches &&\n      event.changedTouches.length > 0 &&\n      (!category || category === \"changed\")\n    ) {\n      for (let i = 0, iMax = event.changedTouches.length; i < iMax; ++i) {\n        const touch = event.changedTouches.item(i);\n        if (!touch) continue;\n        touches.set(touch.identifier, touch);\n      }\n    }\n\n    if (\n      event.targetTouches &&\n      event.targetTouches.length > 0 &&\n      (!category || category === \"target\")\n    ) {\n      for (let i = 0, iMax = event.targetTouches.length; i < iMax; ++i) {\n        const touch = event.targetTouches.item(i);\n        if (!touch) continue;\n        touches.set(touch.identifier, touch);\n      }\n    }\n\n    return Array.from(touches.values());\n  }\n\n  /**\n   * Retrieves the view for the provided id\n   */\n  getView(viewId: string): View<IViewProps> | null {\n    const scenes = this.scenes;\n\n    for (let i = 0, iMax = scenes.length; i < iMax; ++i) {\n      const scene = scenes[i];\n      const view = scene.viewDiffs.getByKey(viewId);\n      if (view) return view;\n    }\n\n    return null;\n  }\n\n  /**\n   * Retrieves the views underneath the mouse with the top most view as\n   * the first view in the list.\n   */\n  getViewsUnderPosition = (mouse: Vec2) => {\n    // Find the views the mouse has interacted with\n    const hitViews = this.quadTree.query(mouse);\n    // Sort them by depth\n    hitViews.sort(sortByDepth);\n\n    return hitViews;\n  };\n\n  /**\n   * This makes the metrics for interactions with the views.\n   */\n  makeMouseInteraction(mouse: IMouseMetrics): IMouseInteraction {\n    // Find the views the mouse has interacted with\n    const hitViews = this.getViewsUnderPosition(mouse.currentPosition);\n    let targetSceneView = hitViews[0] && hitViews[0].d;\n    if (!targetSceneView) targetSceneView = emptyView;\n    const startViews = this.getViewsUnderPosition(mouse.start);\n    let startView = mouse.startView;\n    if (!startView) startView = emptyView;\n\n    return {\n      mouse,\n      screen: {\n        position: mouse.currentPosition\n      },\n      start: {\n        position: startView.projection.screenToView(mouse.start),\n        view: startView,\n        views: startViews.map(v => {\n          if (!v.d) v.d = emptyView;\n\n          return {\n            position: v.d.projection.screenToView(mouse.start),\n            view: v.d\n          };\n        })\n      },\n      target: {\n        position: targetSceneView.projection.screenToView(\n          mouse.currentPosition\n        ),\n        view: targetSceneView,\n        views: hitViews.map(v => {\n          if (!v.d) v.d = emptyView;\n\n          return {\n            position: v.d.projection.screenToView(mouse.currentPosition),\n            view: v.d\n          };\n        })\n      }\n    };\n  }\n\n  /**\n   * Make an interaction depicting the interactions with the touch\n   */\n  makeSingleTouchInteraction(touch: ITouchMetrics): ISingleTouchInteraction {\n    const position = touch.currentPosition;\n    const hitViews = this.getViewsUnderPosition(position);\n    let targetSceneView = hitViews[0] && hitViews[0].d;\n    if (!targetSceneView) targetSceneView = emptyView;\n    let startView = touch.startView;\n    if (!startView) startView = emptyView;\n\n    return {\n      touch,\n      screen: {\n        position\n      },\n      start: {\n        position: startView.projection.screenToView(touch.start),\n        view: startView,\n        views: this.getViewsUnderPosition(touch.start).map(v => {\n          if (!v.d) v.d = emptyView;\n\n          return {\n            position: v.d.projection.screenToView(touch.start),\n            view: v.d\n          };\n        })\n      },\n      target: {\n        position: targetSceneView.projection.screenToView(position),\n        view: targetSceneView,\n        views: hitViews.map(v => {\n          if (!v.d) v.d = emptyView;\n\n          return {\n            position: v.d.projection.screenToView(position),\n            view: v.d\n          };\n        })\n      }\n    };\n  }\n\n  /**\n   * This produces an object for handling several touches at once. It will store all of the combinations of touches\n   * and their associative metrics into the lookup mapping provideds.\n   */\n  makeMultiTouchInteractions(\n    touchMetrics: ITouchMetrics[],\n    multiTouchLookup: Map<string, IMultiTouchMetrics>\n  ) {\n    // Make sure the identifiers come out in the same order of permutation everytime. This makes the combined identifiers\n    // stay properly maintained.\n    touchMetrics.sort(sortByIdentifier);\n    // Now make all of the combinations of touches that are possible between all of the current touches\n    const allCombinations = this.allTouchCombinations(touchMetrics);\n\n    // With all combinations in place, we can now find any combination that newly exists as a result of the new touches.\n    for (let i = 0, iMax = allCombinations.length; i < iMax; ++i) {\n      const combo = allCombinations[i];\n      const id = combo.map(metrics => metrics.touch.identifier).join(\"_\");\n      let multitouch = multiTouchLookup.get(id);\n\n      if (!multitouch) {\n        const center = this.getTouchCenter(combo);\n        multitouch = {\n          touches: combo,\n          averageSpreadDelta: 0,\n          startCenter: center,\n          currentCenter: center,\n          currentRotation: this.getAverageAngle(combo, center),\n          centerDelta: [0, 0],\n          rotationDelta: 0\n        };\n\n        multiTouchLookup.set(id, multitouch);\n      }\n    }\n  }\n\n  /**\n   * This updates all existing multitouch metrics with their new frame of data\n   */\n  updateMultiTouchInteractions(\n    touchMetrics: ITouchMetrics[],\n    multiTouchLookup: Map<string, IMultiTouchMetrics>\n  ) {\n    // Make sure the identifiers come out in the same order of permutation everytime. This makes the combined identifiers\n    // stay properly maintained.\n    touchMetrics.sort(sortByIdentifier);\n    // Now make all of the combinations of touches that are possible between all of the current touches\n    const allCombinations = this.allTouchCombinations(touchMetrics);\n\n    for (let i = 0, iMax = allCombinations.length; i < iMax; ++i) {\n      const combo = allCombinations[i];\n      const id = combo.map(metrics => metrics.touch.identifier).join(\"_\");\n      const multitouch = multiTouchLookup.get(id);\n\n      if (multitouch) {\n        const center = this.getTouchCenter(combo);\n        const rotation = this.getAverageAngle(combo, center);\n\n        multitouch.centerDelta = subtract2(center, multitouch.currentCenter);\n        multitouch.currentCenter = center;\n        multitouch.rotationDelta = rotation - multitouch.currentRotation;\n        multitouch.currentRotation = rotation;\n      }\n    }\n  }\n\n  /**\n   * This makes all of the possible combinations of touches.\n   */\n  allTouchCombinations(list: ITouchMetrics[]) {\n    const allCombinations = [];\n    const listSize = list.length;\n    const combinationsCount = 1 << listSize;\n\n    for (let i = 1; i < combinationsCount; i++) {\n      const combination = [];\n\n      for (let j = 0; j < listSize; j++) {\n        if (i & (1 << j)) {\n          combination.push(list[j]);\n        }\n      }\n\n      allCombinations.push(combination);\n    }\n    return allCombinations;\n  }\n\n  makeWheel(event?: MouseWheelEvent): IWheelMetrics {\n    if (!event) {\n      return {\n        delta: [0, 0]\n      };\n    }\n\n    const wheel = normalizeWheel(event);\n\n    return {\n      delta: [wheel.pixelX, wheel.pixelY]\n    };\n  }\n\n  /**\n   * When the renderer is resized, we must reform our quad tree\n   */\n  resize = () => {\n    this._waitingForRender = true;\n  };\n\n  /**\n   * Sets the controllers to receive events from this manager.\n   */\n  setControllers(controllers: EventManager[]) {\n    this.controllers = controllers;\n\n    for (const controller of this.controllers) {\n      controller.setUserInputManager(this);\n    }\n  }\n\n  destroy() {\n    delete this.quadTree;\n\n    if (!isOffscreenCanvas(this.context)) {\n      this.context.onmousedown = null;\n      this.context.onmousemove = null;\n      this.context.onmouseleave = null;\n    }\n\n    const experimental = this.context as any;\n\n    if (experimental.onmousewheel) {\n      experimental.onmousewheel = null;\n    }\n\n    this.eventCleanup.forEach(event => {\n      this.context.removeEventListener(event[0], event[1]);\n    });\n  }\n}\n","import { Attribute } from \"./attribute\";\nimport { Geometry } from \"./geometry\";\nimport {\n  colorBufferFormat,\n  depthBufferFormat,\n  drawMode,\n  indexToColorAttachment,\n  inputImageFormat,\n  magFilter,\n  minFilter,\n  stencilBufferFormat,\n  texelFormat,\n  wrapMode\n} from \"./gl-decode\";\nimport { GLSettings } from \"./gl-settings\";\nimport { GLState } from \"./gl-state\";\nimport { Material } from \"./material\";\nimport { Model } from \"./model\";\nimport { RenderTarget } from \"./render-target\";\nimport { Texture } from \"./texture\";\nimport { GLContext, IExtensions } from \"./types\";\n\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * Type guard to see if a textire object's data is a buffer.\n */\nfunction isDataBuffer(\n  val: any\n): val is { width: number; height: number; buffer: ArrayBufferView | null } {\n  return (\n    (val &&\n      val.buffer &&\n      val.buffer.byteOffset !== undefined &&\n      val.buffer.byteLength) ||\n    val.buffer === null\n  );\n}\n\n/**\n * Tests if a value is a power of 2\n */\nfunction isPowerOf2(val: number) {\n  return (val & (val - 1)) === 0;\n}\n\n/**\n * This determines if a texture object is ready for use meaning\n * it's compiled and has a current active texture unit.\n */\nfunction isTextureReady(\n  texture: Texture\n): texture is Texture & {\n  gl: { textureId: WebGLTexture; textureUnit: number };\n} {\n  return Boolean(\n    texture.gl && texture.gl.textureId && texture.gl.textureUnit > -1\n  );\n}\n\n/**\n * This is where all objects go to be processed and updated with webgl calls. Such as textures, geometries, etc\n */\nexport class GLProxy {\n  /** Message to include with debugging statements, warnings and errors */\n  debugContext: string = \"\";\n  /** This is the gl context we're manipulating. */\n  gl: GLContext;\n  /** This is the state tracker of the GL context */\n  state: GLState;\n  /** These are the extensions established for the context */\n  extensions: IExtensions;\n\n  /**\n   * Store all of the compiled shaders based on the string text of the\n   * shader so we never duplicate a shader program.\n   */\n  private fragmentShaders = new Map<string, WebGLShader>();\n  /**\n   * Store all of the compiled shaders based on the string text of the\n   * shader so we never duplicate a shader program.\n   */\n  private vertexShaders = new Map<string, WebGLShader>();\n  /**\n   * Make a look up for existing programs based on shader objects.\n   */\n  private programs = new Map<\n    WebGLShader,\n    Map<WebGLShader, { useCount: number; program: WebGLProgram }>\n  >();\n\n  constructor(gl: GLContext, state: GLState, extensions: IExtensions) {\n    this.gl = gl;\n    this.state = state;\n    this.extensions = extensions;\n  }\n\n  /**\n   * This enables the desired and supported extensions this framework utilizes.\n   */\n  static addExtensions(gl: GLContext): IExtensions {\n    const instancing = gl.getExtension(\"ANGLE_instanced_arrays\");\n    const drawBuffers = gl.getExtension(\"WEBGL_draw_buffers\");\n    const anisotropicFiltering = gl.getExtension(\n      \"EXT_texture_filter_anisotropic\"\n    );\n\n    const anisotropicStats = {\n      maxAnistropicFilter: 0\n    };\n\n    // This exists as an extension or as a webgl2 context\n    if (!instancing && !(gl instanceof WebGL2RenderingContext)) {\n      debug(\n        \"This device does not have hardware instancing. All buffering strategies will be utilizing compatibility modes.\"\n      );\n    }\n\n    // This exists as an extension or as a webgl2 context\n    if (!drawBuffers && !(gl instanceof WebGL2RenderingContext)) {\n      debug(\n        \"This device does not have hardware multi-render target capabilities. The system will have to fallback to multiple render passes to multiple FBOs to achieve the same result.\"\n      );\n    }\n\n    // This only exists as an extension\n    if (!anisotropicFiltering) {\n      debug(\n        \"This device does not have hardware anisotropic filtering for textures. This property will be ignored when setting texture settings.\"\n      );\n    } else {\n      anisotropicStats.maxAnistropicFilter = gl.getParameter(\n        anisotropicFiltering.MAX_TEXTURE_MAX_ANISOTROPY_EXT\n      );\n    }\n\n    return {\n      instancing:\n        (gl instanceof WebGL2RenderingContext ? gl : instancing) || undefined,\n      drawBuffers:\n        (gl instanceof WebGL2RenderingContext ? gl : drawBuffers) || undefined,\n      anisotropicFiltering: anisotropicFiltering\n        ? {\n            ext: anisotropicFiltering,\n            stat: anisotropicStats\n          }\n        : undefined\n    };\n  }\n\n  /**\n   * Clears the specified buffers\n   */\n  clear(color?: boolean, depth?: boolean, stencil?: boolean) {\n    let mask = 0;\n\n    if (color) mask = mask | this.gl.COLOR_BUFFER_BIT;\n    if (depth) mask = mask | this.gl.DEPTH_BUFFER_BIT;\n    if (stencil) mask = mask | this.gl.STENCIL_BUFFER_BIT;\n\n    this.gl.clear(mask);\n  }\n\n  /**\n   * Takes an Attribute object and ensures it's buffer is created and initialized.\n   */\n  compileAttribute(attribute: Attribute) {\n    if (attribute.gl) return;\n\n    const gl = this.gl;\n    const buffer = gl.createBuffer();\n\n    if (!buffer) {\n      console.warn(\n        this.debugContext,\n        \"Could bot create WebGLBuffer. Printing any existing gl errors:\"\n      );\n      this.printError();\n\n      return;\n    }\n\n    // State change\n    this.state.bindVBO(buffer);\n\n    // Upload the data to the GPU\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      attribute.data,\n      attribute.isDynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW\n    );\n\n    attribute.gl = {\n      bufferId: buffer,\n      type: gl.ARRAY_BUFFER\n    };\n\n    // Indicate the attribute is updated to it's latest needs and concerns\n    attribute.resolve();\n\n    return true;\n  }\n\n  /**\n   * Takes a geometry object and ensures all of it's buffers are generated\n   */\n  compileGeometry(geometry: Geometry) {\n    let success = true;\n\n    // Loop through each attribute of the geometry\n    geometry.attributes.forEach(attribute => {\n      success = Boolean(this.compileAttribute(attribute) && success);\n    });\n\n    return success;\n  }\n\n  /**\n   * This creates the shaders and programs needed to create a material.\n   */\n  compileMaterial(material: Material) {\n    // If the gl object exists, then this is considered finished\n    if (material.gl) return;\n\n    // Check for existing shader programs for the fragment shader\n    let fs = this.fragmentShaders.get(material.fragmentShader) || null;\n\n    // If none exists, then we create and compile the fragments shader\n    if (!fs) {\n      fs = this.gl.createShader(this.gl.FRAGMENT_SHADER);\n\n      if (!fs) {\n        console.warn(\n          this.debugContext,\n          \"Could not create a Fragment WebGLShader. Printing GL Errors:\"\n        );\n        this.printError();\n        return;\n      }\n\n      this.gl.shaderSource(fs, material.fragmentShader);\n      this.gl.compileShader(fs);\n\n      if (this.gl.isContextLost()) {\n        console.warn(\"Context was lost during compilation\");\n      }\n\n      if (!this.gl.getShaderParameter(fs, this.gl.COMPILE_STATUS)) {\n        console.error(\n          this.debugContext,\n          \"FRAGMENT SHADER COMPILER ERROR:\",\n          material.name\n        );\n        console.warn(\n          \"Could not compile provided shader. Printing logs and errors:\"\n        );\n        console.warn(this.lineFormatShader(material.fragmentShader));\n        console.warn(\"LOGS:\");\n        console.warn(this.gl.getShaderInfoLog(fs));\n        this.printError();\n        this.gl.deleteShader(fs);\n\n        return;\n      }\n    }\n\n    // Check for existing vertex shader object\n    let vs = this.vertexShaders.get(material.vertexShader) || null;\n\n    // If none exists, then compile\n    if (!vs) {\n      vs = this.gl.createShader(this.gl.VERTEX_SHADER);\n\n      if (!vs) {\n        console.warn(\n          this.debugContext,\n          \"Could not create a Vertex WebGLShader. Printing GL Errors:\"\n        );\n        this.printError();\n        return;\n      }\n\n      this.gl.shaderSource(vs, material.vertexShader);\n      this.gl.compileShader(vs);\n\n      if (this.gl.isContextLost()) {\n        console.warn(\"Context was lost during compilation\");\n      }\n\n      if (!this.gl.getShaderParameter(vs, this.gl.COMPILE_STATUS)) {\n        console.error(\n          this.debugContext,\n          \"VERTEX SHADER COMPILER ERROR\",\n          material.name\n        );\n        console.warn(\n          \"Could not compile provided shader. Printing logs and errors:\"\n        );\n        console.warn(this.lineFormatShader(material.vertexShader));\n        console.warn(\"LOGS:\");\n        console.warn(this.gl.getShaderInfoLog(vs));\n        this.printError();\n        this.gl.deleteShader(vs);\n\n        return;\n      }\n    }\n\n    let vertexPrograms = this.programs.get(vs);\n\n    if (!vertexPrograms) {\n      vertexPrograms = new Map();\n      this.programs.set(vs, vertexPrograms);\n    }\n\n    let useMetrics = vertexPrograms.get(fs) || null;\n\n    if (!useMetrics) {\n      const program = this.gl.createProgram();\n\n      if (!program) {\n        console.warn(\n          this.debugContext,\n          \"Could not create a WebGLProgram. Printing GL Errors:\"\n        );\n        this.printError();\n\n        return;\n      }\n\n      useMetrics = {\n        useCount: 1,\n        program\n      };\n\n      this.gl.attachShader(program, vs);\n      this.gl.attachShader(program, fs);\n\n      // Make the shaders operate together\n      this.gl.linkProgram(program);\n      this.gl.validateProgram(program);\n\n      if (\n        !this.gl.getProgramParameter(program, this.gl.LINK_STATUS) ||\n        !this.gl.getProgramParameter(program, this.gl.VALIDATE_STATUS)\n      ) {\n        const info = this.gl.getProgramInfoLog(program);\n        console.warn(\n          this.debugContext,\n          \"Could not compile WebGL program. \\n\\n\",\n          info\n        );\n        this.gl.deleteProgram(program);\n\n        return;\n      }\n\n      vertexPrograms.set(fs, useMetrics);\n    } else {\n      // Up the use count of the program for like programs that are found\n      useMetrics.useCount++;\n    }\n\n    // Establish the gl context info that makes this material tick.\n    material.gl = {\n      fsId: fs,\n      vsId: vs,\n      programId: useMetrics.program,\n      proxy: this\n    };\n\n    // Let's get a list of all uniforms the shaders are demanding and make sure the material is\n    // supplying them. If not, then the shader will not have all of the information it may need\n    // and thus would be considered invalid rendering.\n\n    // Switch to the program and clean up any uniform mismatches\n    this.state.useProgram(useMetrics.program);\n    // Get the current program applied to our state\n    const program = this.state.currentProgram;\n    if (!program) return false;\n\n    // Get the total uniforms requested by the program so we can loop through them\n    const totalProgramUniforms = this.gl.getProgramParameter(\n      program,\n      this.gl.ACTIVE_UNIFORMS\n    );\n    const usedUniforms = new Set<string>();\n\n    for (let i = 0; i < totalProgramUniforms; i++) {\n      const uniformInfo = this.gl.getActiveUniform(program, i);\n\n      if (uniformInfo) {\n        usedUniforms.add(uniformInfo.name);\n      }\n    }\n\n    // We now delete any uniforms that are not matched between material and program as they are not needed\n    // and will just be lingering unused clutter.\n    const uniformToRemove = new Set<string>();\n\n    Object.keys(material.uniforms).forEach(name => {\n      if (!usedUniforms.has(name)) {\n        uniformToRemove.add(name);\n      }\n    });\n\n    uniformToRemove.forEach(name => {\n      delete material.uniforms[name];\n    });\n\n    // Now we validate we have all of the uniforms the program requested\n    if (Object.keys(material.uniforms).length !== usedUniforms.size) {\n      console.warn(\n        this.debugContext,\n        \"A program is requesting a set of uniforms:\",\n        Array.from(usedUniforms.values()),\n        \"but our material only provides\",\n        Object.keys(material.uniforms),\n        \"thus the expected rendering will be considered invalid.\"\n      );\n\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * This does what is needed to generate a GPU FBO that we can utilize as a render target\n   * for subsequent draw calls.\n   *\n   * TODO: For MRT (using extensions or webgl 2) Our current set up is ok. However, we need\n   * to change this to compile out split buffers for compatibility MRT.\n   */\n  compileRenderTarget(target: RenderTarget) {\n    // If the gl target exists, then this is considered to be compiled already\n    if (target.gl) return;\n\n    // We will now create the frame buffer and render buffers and targets necessary\n    // to make this render target work.\n    const gl = this.gl;\n    const fbo = gl.createFramebuffer();\n\n    if (!fbo) {\n      console.warn(\n        this.debugContext,\n        \"Could not generate a frame buffer object. Printing GL errors:\"\n      );\n      this.printError();\n      return false;\n    }\n\n    // Change state\n    this.state.bindFBO(fbo);\n\n    // Generate the context to be attached to the render target\n    const glContext: RenderTarget[\"gl\"] = {\n      fboId: fbo,\n      proxy: this\n    };\n\n    // Color buffer\n    if (Array.isArray(target.buffers.color)) {\n      const buffers: (WebGLRenderbuffer | Texture)[] = [];\n      let isReady = true;\n      glContext.colorBufferId = buffers;\n\n      target.buffers.color.forEach((buffer, i) => {\n        if (!isReady) return;\n        if (buffer instanceof Texture) {\n          buffers.push(buffer);\n\n          if (isTextureReady(buffer)) {\n            gl.framebufferTexture2D(\n              gl.FRAMEBUFFER,\n              indexToColorAttachment(gl, this.extensions, i, true),\n              gl.TEXTURE_2D,\n              buffer.gl.textureId,\n              0\n            );\n          } else {\n            console.warn(\n              this.debugContext,\n              \"Attempted to compile render target whose target texture was not ready for use.\"\n            );\n            isReady = false;\n          }\n        } else {\n          const rboId = this.compileColorBuffer(\n            buffer,\n            target.width,\n            target.height\n          );\n\n          if (rboId) {\n            buffers.push(rboId);\n            gl.framebufferRenderbuffer(\n              gl.FRAMEBUFFER,\n              indexToColorAttachment(gl, this.extensions, i, true),\n              gl.RENDERBUFFER,\n              rboId\n            );\n          }\n        }\n      });\n\n      if (!isReady) {\n        return false;\n      }\n    } else if (target.buffers.color !== undefined) {\n      const buffer = target.buffers.color;\n\n      if (buffer instanceof Texture) {\n        glContext.colorBufferId = buffer;\n\n        if (isTextureReady(buffer)) {\n          gl.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            indexToColorAttachment(gl, this.extensions, 0, true),\n            gl.TEXTURE_2D,\n            buffer.gl.textureId,\n            0\n          );\n        } else {\n          console.warn(\n            this.debugContext,\n            \"Attempted to compile render target whose target texture was not ready for use.\"\n          );\n          return false;\n        }\n      } else {\n        const rboId = this.compileColorBuffer(\n          buffer,\n          target.width,\n          target.height\n        );\n\n        if (rboId) {\n          glContext.colorBufferId = rboId;\n          gl.framebufferRenderbuffer(\n            gl.FRAMEBUFFER,\n            indexToColorAttachment(gl, this.extensions, 0, true),\n            gl.RENDERBUFFER,\n            rboId\n          );\n        }\n      }\n    }\n\n    // Depth buffer\n    if (target.buffers.depth !== undefined) {\n      const buffer = target.buffers.depth;\n\n      if (buffer instanceof Texture) {\n        glContext.depthBufferId = buffer;\n\n        if (isTextureReady(buffer)) {\n          gl.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            gl.DEPTH_ATTACHMENT,\n            gl.TEXTURE_2D,\n            buffer.gl.textureId,\n            0\n          );\n        }\n      } else {\n        const rboId = this.compileDepthBuffer(\n          buffer,\n          target.width,\n          target.height\n        );\n\n        if (rboId) {\n          glContext.depthBufferId = rboId;\n          gl.framebufferRenderbuffer(\n            gl.FRAMEBUFFER,\n            gl.DEPTH_ATTACHMENT,\n            gl.RENDERBUFFER,\n            rboId\n          );\n        }\n      }\n    }\n\n    // Stencil buffer\n    if (target.buffers.stencil !== undefined) {\n      const buffer = target.buffers.stencil;\n\n      if (buffer instanceof Texture) {\n        glContext.stencilBufferId = buffer;\n\n        if (isTextureReady(buffer)) {\n          gl.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            gl.STENCIL_ATTACHMENT,\n            gl.TEXTURE_2D,\n            buffer.gl.textureId,\n            0\n          );\n        }\n      } else {\n        const rboId = this.compileStencilBuffer(\n          buffer,\n          target.width,\n          target.height\n        );\n\n        if (rboId) {\n          glContext.stencilBufferId = rboId;\n          gl.framebufferRenderbuffer(\n            gl.FRAMEBUFFER,\n            gl.STENCIL_ATTACHMENT,\n            gl.RENDERBUFFER,\n            rboId\n          );\n        }\n      }\n    }\n\n    // Store the generated information in the target\n    target.gl = glContext;\n\n    // Check framebuffer for success\n    const frameBufferCheckResult = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    let unidentifiedResult = false;\n    let stillUnidentifiedResult = false;\n    let message = \"\";\n\n    switch (frameBufferCheckResult) {\n      case gl.FRAMEBUFFER_COMPLETE:\n        target.setAsValid();\n        break;\n\n      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n        message = \"FRAMEBUFFER_INCOMPLETE_ATTACHMENT\";\n        break;\n\n      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n        message = \"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\";\n        break;\n\n      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n        message = \"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\";\n        break;\n\n      case gl.FRAMEBUFFER_UNSUPPORTED:\n        message = \"FRAMEBUFFER_UNSUPPORTED\";\n        break;\n\n      default:\n        unidentifiedResult = true;\n        break;\n    }\n\n    // WebGL 2 specific checks\n    if (gl instanceof WebGL2RenderingContext) {\n      switch (frameBufferCheckResult) {\n        case gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:\n          message = \"FRAMEBUFFER_INCOMPLETE_MULTISAMPLE\";\n          break;\n\n        case gl.RENDERBUFFER_SAMPLES:\n          message = \"RENDERBUFFER_SAMPLES\";\n          break;\n\n        default:\n          stillUnidentifiedResult = true;\n          break;\n      }\n    }\n\n    if (unidentifiedResult && stillUnidentifiedResult) {\n      console.warn(\n        this.debugContext,\n        \"A framebuffer check failed to return a known result. This FBO for render target will be assumed failed\"\n      );\n      console.warn(\"Result:\", frameBufferCheckResult, \"Render Target:\", target);\n      message = \"UNKNOWN\";\n    }\n\n    if (message) {\n      console.warn(\n        this.debugContext,\n        \"When creating a new FrameBuffer Object, the check on the framebuffer failed. Printing Errors:\"\n      );\n      console.warn(message);\n      console.warn(\"FAILED RENDER TARGET:\", target);\n      delete target.gl;\n\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Produces a render buffer object intended for a render target for the depth buffer attachment\n   */\n  private compileDepthBuffer(\n    buffer: GLSettings.RenderTarget.DepthBufferFormat,\n    width: number,\n    height: number\n  ) {\n    const gl = this.gl;\n    const rbo = gl.createRenderbuffer();\n\n    if (!rbo) {\n      console.warn(\n        this.debugContext,\n        \"Could not generate a WebGLRenderBuffer. Printing GL Errors:\"\n      );\n      this.printError();\n      return;\n    }\n\n    // State change\n    this.state.bindRBO(rbo);\n    // Set the storage format of the RBO\n    gl.renderbufferStorage(\n      gl.RENDERBUFFER,\n      depthBufferFormat(gl, buffer),\n      width,\n      height\n    );\n\n    return rbo;\n  }\n\n  /**\n   * Produces a render buffer object intended for a render target for the stencil buffer attachment\n   */\n  private compileStencilBuffer(\n    buffer: GLSettings.RenderTarget.StencilBufferFormat,\n    width: number,\n    height: number\n  ) {\n    const gl = this.gl;\n    const rbo = gl.createRenderbuffer();\n\n    if (!rbo) {\n      console.warn(\n        this.debugContext,\n        \"Could not generate a WebGLRenderBuffer. Printing GL Errors:\"\n      );\n      this.printError();\n      return;\n    }\n\n    // State change\n    this.state.bindRBO(rbo);\n    // Set the storage format of the RBO\n    gl.renderbufferStorage(\n      gl.RENDERBUFFER,\n      stencilBufferFormat(gl, buffer),\n      width,\n      height\n    );\n\n    return rbo;\n  }\n\n  /**\n   * Produces a render buffer object intended for a render target for the color buffer attachment\n   */\n  private compileColorBuffer(\n    buffer: GLSettings.RenderTarget.ColorBufferFormat,\n    width: number,\n    height: number\n  ) {\n    const gl = this.gl;\n    const rbo = gl.createRenderbuffer();\n\n    if (!rbo) {\n      console.warn(\n        this.debugContext,\n        \"Could not generate a WebGLRenderBuffer. Printing GL Errors:\"\n      );\n      this.printError();\n      return;\n    }\n\n    // State change\n    this.state.bindRBO(rbo);\n    // Set the storage format of the RBO\n    gl.renderbufferStorage(\n      gl.RENDERBUFFER,\n      colorBufferFormat(gl, buffer),\n      width,\n      height\n    );\n\n    return rbo;\n  }\n\n  /**\n   * This does what is needed to generate a GPU texture object and format it to the\n   * Texture object specifications.\n   */\n  compileTexture(texture: Texture) {\n    if (!texture.gl) return;\n    // If the id is already established, this does not need a compile but an update\n    if (texture.gl.textureId) return;\n\n    // The texture must have a unit established in order to be compiled\n    if (texture.gl.textureUnit < 0) {\n      console.warn(\n        this.debugContext,\n        \"A Texture object attempted to be compiled without an established Texture Unit.\",\n        texture\n      );\n      return;\n    }\n\n    // Set our unit to the unit allotted to the texture for this operation\n    this.state.setActiveTextureUnit(texture.gl.textureUnit);\n\n    const gl = this.gl;\n    const textureId = gl.createTexture();\n\n    if (!textureId) {\n      console.warn(\n        this.debugContext,\n        \"Could not generate a texture object on the GPU. Printing any gl errors:\"\n      );\n      this.printError();\n      return;\n    }\n\n    // Establish the texture's generated gl context\n    texture.gl.textureId = textureId;\n    // No matter what, when compiled both data and settings should be updated immediately\n    texture.needsDataUpload = true;\n    texture.needsSettingsUpdate = true;\n\n    // Upload the texture's data to the object\n    this.updateTextureData(texture);\n    // Make sure the settings for the texture are set correctly to match the texture object\n    this.updateTextureSettings(texture);\n\n    return true;\n  }\n\n  /**\n   * Executes the draw operation for a given model\n   */\n  draw(model: Model) {\n    let instancing;\n    let drawRange = [0, 0];\n\n    // Get the appropriate draw range from the model\n    if (\n      model.vertexDrawRange &&\n      model.vertexDrawRange[0] >= 0 &&\n      model.vertexDrawRange[1] >= 0\n    ) {\n      drawRange = [\n        model.vertexDrawRange[0],\n        model.vertexDrawRange[1] - model.vertexDrawRange[0]\n      ];\n    } else {\n      drawRange = [0, model.vertexCount];\n    }\n\n    // Only if this geometry has instances requested will it attempt to render instances\n    if (model.drawInstances >= 0 && model.geometry.isInstanced) {\n      instancing = this.extensions.instancing;\n    }\n\n    if (instancing && instancing instanceof WebGL2RenderingContext) {\n      instancing.drawArraysInstanced(\n        drawMode(this.gl, model.drawMode),\n        drawRange[0],\n        drawRange[1],\n        model.drawInstances\n      );\n    } else if (instancing) {\n      instancing.drawArraysInstancedANGLE(\n        drawMode(this.gl, model.drawMode),\n        drawRange[0],\n        drawRange[1],\n        model.drawInstances\n      );\n    } else {\n      this.gl.drawArrays(\n        drawMode(this.gl, model.drawMode),\n        drawRange[0],\n        drawRange[1]\n      );\n    }\n  }\n\n  /**\n   * Destroys a material's resources from the GL Context.\n   */\n  disposeMaterial(material: Material) {\n    if (material.gl) {\n      const { vsId, fsId, programId } = material.gl;\n      let fsLookup = this.programs.get(vsId);\n\n      // If nothing is found we have something with odd state. Just delete the vertex\n      // and fake the object to continue the program normally\n      if (!fsLookup) {\n        fsLookup = new Map();\n        this.gl.deleteShader(vsId);\n      }\n\n      let useMetrics = fsLookup.get(fsId);\n\n      // No use metrics means odd state, make a fake object to continue the process normally\n      if (!useMetrics) {\n        useMetrics = {\n          useCount: 0,\n          program: programId\n        };\n      }\n\n      // We're removing a material from utilizing this program, thus reduce it's useage\n      useMetrics.useCount--;\n\n      // If the useage is at or drops below zero, the program is no longer valid and not in use\n      if (useMetrics.useCount < 1) {\n        this.gl.deleteProgram(useMetrics.program);\n        fsLookup.delete(fsId);\n\n        // If removing this fragment shader reference reduces the lookups to zero, then the\n        // vertex shader is not paired with anything and has no programs. It is ready for\n        // removal as well\n        if (fsLookup.size <= 0) {\n          this.gl.deleteShader(vsId);\n        }\n      }\n\n      // The fragment shader is a bit trickier, we must go through all vertex shader lookups and see\n      // if the fragment shader exists in any of them. If not: the fragment shader is ready for removal\n      let found = false;\n      this.programs.forEach(fsLookup => {\n        if (fsLookup.has(fsId)) found = true;\n      });\n\n      // If no fragment shader references remain: delete it.\n      if (!found) {\n        this.gl.deleteShader(fsId);\n      }\n    }\n\n    delete material.gl;\n  }\n\n  /**\n   * Destroy a render buffer (RBO)\n   */\n  disposeRenderBuffer(buffer: WebGLRenderbuffer) {\n    this.gl.deleteRenderbuffer(buffer);\n  }\n\n  /**\n   * Destroys a render target's resources from the GL context\n   */\n  disposeRenderTarget(target: RenderTarget) {\n    if (target.gl) {\n      // List of color buffers for MRT\n      if (Array.isArray(target.gl.colorBufferId)) {\n        target.gl.colorBufferId.forEach(buffer => {\n          if (buffer instanceof Texture && !target.retainTextureTargets) {\n            this.disposeTexture(buffer);\n          } else {\n            this.disposeRenderBuffer(buffer);\n          }\n        });\n      } else if (\n        target.gl.colorBufferId instanceof Texture &&\n        !target.retainTextureTargets\n      ) {\n        this.disposeTexture(target.gl.colorBufferId);\n      } else if (target.gl.colorBufferId instanceof WebGLRenderbuffer) {\n        this.disposeRenderBuffer(target.gl.colorBufferId);\n      }\n\n      // Dispose of depth buffer\n      if (\n        target.gl.depthBufferId instanceof Texture &&\n        !target.retainTextureTargets\n      ) {\n        this.disposeTexture(target.gl.depthBufferId);\n      } else if (target.gl.depthBufferId instanceof WebGLRenderbuffer) {\n        this.disposeRenderBuffer(target.gl.depthBufferId);\n      }\n\n      // Dispose of stencil buffer\n      if (\n        target.gl.stencilBufferId instanceof Texture &&\n        !target.retainTextureTargets\n      ) {\n        this.disposeTexture(target.gl.stencilBufferId);\n      } else if (target.gl.stencilBufferId instanceof WebGLRenderbuffer) {\n        this.disposeRenderBuffer(target.gl.stencilBufferId);\n      }\n\n      // Clean up the context generated for the render target\n      delete target.gl;\n    }\n  }\n\n  /**\n   * Destroys a texture's resources from the GL context\n   */\n  disposeTexture(texture: Texture) {\n    if (texture.gl) {\n      this.gl.deleteTexture(texture.gl.textureId);\n      this.state.freeTextureUnit(texture);\n    }\n\n    delete texture.gl;\n  }\n\n  /**\n   * Retrieves the gl context from the canvas\n   */\n  static getContext(canvas: HTMLCanvasElement, options: {}) {\n    // TODO: Let's make sure webgl works before we attempt any webgl 2 shenanigans\n    const names = [/** \"webgl2\", */ \"webgl\", \"experimental-webgl\"];\n    let context: GLContext | null = null;\n    let extensions: IExtensions = {};\n\n    for (let i = 0; i < names.length; ++i) {\n      const name = names[i];\n      const ctx = canvas.getContext(name, options);\n\n      if (\n        ctx &&\n        (ctx instanceof WebGLRenderingContext ||\n          ctx instanceof WebGL2RenderingContext)\n      ) {\n        debug(\n          \"Generated GL Context of version with attributes:\",\n          name,\n          options\n        );\n        context = ctx;\n        extensions = GLProxy.addExtensions(context);\n        break;\n      }\n    }\n\n    return {\n      context,\n      extensions\n    };\n  }\n\n  /**\n   * This decodes and prints any webgl context error in a  human readable manner.\n   */\n  printError() {\n    const glError = this.gl.getError();\n\n    switch (glError) {\n      case this.gl.NO_ERROR:\n        console.warn(\"GL Error: No Error\");\n        break;\n\n      case this.gl.INVALID_ENUM:\n        console.warn(\"GL Error: INVALID ENUM\");\n        break;\n\n      case this.gl.INVALID_VALUE:\n        console.warn(\"GL Error: INVALID_VALUE\");\n        break;\n\n      case this.gl.INVALID_OPERATION:\n        console.warn(\"GL Error: INVALID OPERATION\");\n        break;\n\n      case this.gl.INVALID_FRAMEBUFFER_OPERATION:\n        console.warn(\"GL Error: INVALID FRAMEBUFFER OPERATION\");\n        break;\n\n      case this.gl.OUT_OF_MEMORY:\n        console.warn(\"GL Error: OUT OF MEMORY\");\n        break;\n\n      case this.gl.CONTEXT_LOST_WEBGL:\n        console.warn(\"GL Error: CONTEXT LOST WEBGL\");\n        break;\n\n      default:\n        console.warn(\n          \"GL Error: GL Context output an unrecognized error value:\",\n          glError\n        );\n        break;\n    }\n  }\n\n  /**\n   * Prints a shader broken down by lines\n   */\n  lineFormatShader(shader: string) {\n    const lines = shader.split(\"\\n\");\n    const lineChars = String(lines.length).length + 1;\n\n    return `\\n${lines\n      .map(\n        (l, i) =>\n          `${Array(lineChars - String(i + 1).length).join(\" \")}${i + 1}: ${l}`\n      )\n      .join(\"\\n\")}`;\n  }\n\n  /**\n   * Ensures a texture object is compiled and/or updated.\n   */\n  updateTexture(texture: Texture) {\n    if (!texture.gl || texture.gl.textureUnit < 0) {\n      console.warn(\n        this.debugContext,\n        \"Can not update or compile a texture that does not have an established texture unit.\",\n        texture\n      );\n      return;\n    }\n\n    // Perform any necessary compilation or settings changes requested of the texture\n    this.compileTexture(texture);\n    this.updateTextureData(texture);\n    this.updateTexturePartialData(texture);\n    this.updateTextureSettings(texture);\n\n    // Indicate all updates required of the texture have been performed\n    texture.resolve();\n  }\n\n  /**\n   * Ensures the texture object has it's data uploaded to the GPU\n   */\n  private updateTextureData(texture: Texture) {\n    // Check for upload flag\n    if (!texture.needsDataUpload) return;\n    // Check for gl context established\n    if (!texture.gl) return;\n    // This texture must have an establish texture id\n    if (!texture.gl.textureId) return;\n\n    // The texture must have a unit established in order to have it's data updated\n    if (texture.gl.textureUnit < 0) {\n      console.warn(\n        this.debugContext,\n        \"A Texture object attempted to update it's data without an established Texture Unit.\",\n        texture\n      );\n      return;\n    }\n\n    const gl = this.gl;\n\n    // Ensure we are operating on the correct active unit\n    this.state.setActiveTextureUnit(texture.gl.textureUnit);\n    // Ensure our texture is bound as the active texture unit\n    this.state.bindTexture(\n      texture,\n      GLSettings.Texture.TextureBindingTarget.TEXTURE_2D\n    );\n\n    // Make sure the settings are properly set for the texture before performing the data upload\n    texture.needsSettingsUpdate = true;\n    this.updateTextureSettings(texture);\n\n    // First set the data in the texture\n    if (gl instanceof WebGLRenderingContext) {\n      if (isDataBuffer(texture.data)) {\n        if (\n          !isPowerOf2(texture.data.width) ||\n          !isPowerOf2(texture.data.height)\n        ) {\n          debug(\"Created a texture that is not using power of 2 dimensions.\");\n        }\n\n        gl.texImage2D(\n          gl.TEXTURE_2D,\n          0,\n          texelFormat(gl, texture.format),\n          texture.data.width,\n          texture.data.height,\n          0,\n          texelFormat(gl, texture.format),\n          inputImageFormat(gl, texture.type),\n          texture.data.buffer\n        );\n      } else if (texture.data) {\n        if (\n          !isPowerOf2(texture.data.width) ||\n          !isPowerOf2(texture.data.height)\n        ) {\n          debug(\n            \"Created a texture that is not using power of 2 dimensions. %o\",\n            texture\n          );\n        }\n\n        gl.texImage2D(\n          gl.TEXTURE_2D,\n          0,\n          texelFormat(gl, texture.format),\n          texelFormat(gl, texture.format),\n          inputImageFormat(gl, texture.type),\n          // @ts-ignore Typescript is not able to pick the correct overload for the type check for this for some reason\n          texture.data\n        );\n      }\n\n      if (texture.generateMipMaps) {\n        gl.generateMipmap(gl.TEXTURE_2D);\n      }\n    }\n\n    // Let's not hang onto large data buffers that are being uploaded to the gpu. Let's\n    // delete the buffer but keep some simple metrics about it.\n    if (texture.data) {\n      texture.data = {\n        width: texture.data.width,\n        height: texture.data.height,\n        buffer: null\n      };\n    }\n\n    // Clear the flag for updates\n    texture.needsDataUpload = false;\n  }\n\n  /**\n   * This consumes all of the partial texture updates applied to the texture.\n   */\n  private updateTexturePartialData(texture: Texture) {\n    // Check for partial update flag\n    if (!texture.needsPartialDataUpload) return;\n    // Check for gl context established\n    if (!texture.gl) return;\n    // This texture must have an establish texture id\n    if (!texture.gl.textureId) return;\n\n    // The texture must have a unit established in order to have it's data updated\n    if (texture.gl.textureUnit < 0) {\n      console.warn(\n        this.debugContext,\n        \"A Texture object attempted to update it's data without an established Texture Unit.\",\n        texture\n      );\n      return;\n    }\n\n    // Get gl context to work with\n    const gl = this.gl;\n    // Ensure we are operating on the correct active unit\n    this.state.setActiveTextureUnit(texture.gl.textureUnit);\n    // Ensure our texture is bound as the active texture unit\n    this.state.bindTexture(\n      texture,\n      GLSettings.Texture.TextureBindingTarget.TEXTURE_2D\n    );\n\n    // Loop through all the necessary update regions and apply the changes\n    texture.updateRegions.forEach(region => {\n      const buffer = region[0];\n      const bounds = region[1];\n\n      // First set the data in the texture\n      if (gl instanceof WebGLRenderingContext) {\n        if (isDataBuffer(buffer)) {\n          gl.texSubImage2D(\n            gl.TEXTURE_2D,\n            0,\n            bounds.x,\n            bounds.y,\n            buffer.width,\n            buffer.height,\n            texelFormat(gl, texture.format),\n            inputImageFormat(gl, texture.type),\n            buffer.buffer\n          );\n        } else if (buffer) {\n          gl.texSubImage2D(\n            gl.TEXTURE_2D,\n            0,\n            bounds.x,\n            bounds.y,\n            texelFormat(gl, texture.format),\n            inputImageFormat(gl, texture.type),\n            // @ts-ignore Typescript is not able to pick the correct overload for the type check for this for some reason\n            buffer\n          );\n        }\n\n        if (texture.generateMipMaps) {\n          gl.generateMipmap(gl.TEXTURE_2D);\n        }\n      }\n    });\n\n    // Flag the deed as done\n    texture.needsPartialDataUpload = false;\n  }\n\n  /**\n   * Modifies all settings needing modified on the provided texture object.\n   */\n  private updateTextureSettings(texture: Texture) {\n    // Check update flag\n    if (!texture.needsSettingsUpdate) return;\n    // Check for gl context\n    if (!texture.gl || !texture.data) return;\n    // This texture must have an establish texture id\n    if (!texture.gl.textureId) return;\n\n    // The texture must have a unit established in order to be compiled\n    if (texture.gl.textureUnit < 0) {\n      console.warn(\n        this.debugContext,\n        \"A Texture object attempted to update it's settings without an established Texture Unit.\",\n        texture\n      );\n      return;\n    }\n\n    const isPower2 =\n      isPowerOf2(texture.data.width) && isPowerOf2(texture.data.height);\n    const gl = this.gl;\n    this.state.setActiveTextureUnit(texture.gl.textureUnit);\n    this.state.bindTexture(\n      texture,\n      GLSettings.Texture.TextureBindingTarget.TEXTURE_2D\n    );\n\n    // Set filtering and other properties to the texture\n    gl.texParameteri(\n      gl.TEXTURE_2D,\n      gl.TEXTURE_MAG_FILTER,\n      magFilter(gl, texture.magFilter, isPower2)\n    );\n    gl.texParameteri(\n      gl.TEXTURE_2D,\n      gl.TEXTURE_MIN_FILTER,\n      minFilter(gl, texture.minFilter, isPower2, texture.generateMipMaps)\n    );\n    gl.texParameteri(\n      gl.TEXTURE_2D,\n      gl.TEXTURE_WRAP_S,\n      wrapMode(gl, texture.wrapHorizontal)\n    );\n    gl.texParameteri(\n      gl.TEXTURE_2D,\n      gl.TEXTURE_WRAP_T,\n      wrapMode(gl, texture.wrapVertical)\n    );\n\n    // NOTE: All pixelStorei with boolean settings:\n    // The typescript definitions are wrong right now thus requiring some weird casting\n    // voodoo. The correct value according to the webgl specs IS true right here and not a number\n    // for this particular enum.\n\n    gl.pixelStorei(\n      gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,\n      (texture.premultiplyAlpha as unknown) as number\n    );\n\n    gl.pixelStorei(\n      gl.UNPACK_FLIP_Y_WEBGL,\n      (texture.flipY as unknown) as number\n    );\n\n    // Apply the anistropic extension (if available)\n    if (this.extensions.anisotropicFiltering) {\n      const { ext, stat } = this.extensions.anisotropicFiltering;\n      gl.texParameterf(\n        gl.TEXTURE_2D,\n        ext.TEXTURE_MAX_ANISOTROPY_EXT,\n        Math.min(stat.maxAnistropicFilter, Math.floor(texture.anisotropy))\n      );\n    }\n\n    // Clear the flag for updates\n    texture.needsSettingsUpdate = false;\n  }\n\n  /**\n   * This updates an attribute's buffer data\n   */\n  updateAttribute(attribute: Attribute) {\n    if (!attribute.gl) return this.compileAttribute(attribute);\n\n    // Make sure an update is even needed\n    if (!attribute.fullUpdate && !attribute.needsUpdate) {\n      return true;\n    }\n\n    const gl = this.gl;\n\n    // Check to see if this should be a complete buffer update\n    if (\n      attribute.fullUpdate ||\n      attribute.updateRange.count < 0 ||\n      attribute.updateRange.offset < 0\n    ) {\n      // State change\n      this.state.bindVBO(attribute.gl.bufferId);\n      // Upload data\n      gl.bufferData(\n        gl.ARRAY_BUFFER,\n        attribute.data,\n        attribute.isDynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW\n      );\n    }\n\n    // Otherwise, we work to upload only a partial update to the buffer\n    else if (attribute.updateRange.count > 0) {\n      // State change\n      this.state.bindVBO(attribute.gl.bufferId);\n      // Upload data\n      const start = attribute.updateRange.offset;\n      gl.bufferSubData(\n        gl.ARRAY_BUFFER,\n        start * 4,\n        attribute.data.subarray(start, start + attribute.updateRange.count)\n      );\n    }\n\n    // Flag the attribute as updated to all of it's necessities\n    attribute.resolve();\n\n    return true;\n  }\n\n  /**\n   * This performs all necessary functions to use the attribute utilizing\n   * the current program in use.\n   */\n  useAttribute(name: string, attribute: Attribute, geometry: Geometry) {\n    // We need a valid program in use.\n    if (!this.state.currentProgram) return false;\n    // Must have it's gl context established\n    if (!attribute.gl) return false;\n\n    // Ensure the attribute has established location information for this program\n    attribute.gl.locations = attribute.gl.locations || new Map();\n    // Find existing attribute location for the current program\n    let location = attribute.gl.locations.get(this.state.currentProgram);\n\n    // If no location is found for this attribute for this program we must query for it\n    if (location === undefined) {\n      location = this.gl.getAttribLocation(this.state.currentProgram, name);\n\n      if (location === -1) {\n        debug(\n          \"WARN: An attribute is not being used with the current material: %o\",\n          name,\n          attribute\n        );\n      }\n\n      attribute.gl.locations.set(this.state.currentProgram, location);\n    }\n\n    // Exit if our location is invalid for this attribute. It won't be used in next draw call.\n    if (location === -1) return;\n\n    // At this point we're ready to establish the attribute's state and stride\n    this.state.bindVBO(attribute.gl.bufferId);\n\n    switch (attribute.size) {\n      // For sizes that fit within a single vertex block, this is the simplest way to establish the pointer\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        // Enable the use of the vertex location\n        this.state.willUseVertexAttributeArray(location);\n        // Now we establish the metrics of the buffer\n        this.gl.vertexAttribPointer(\n          location,\n          attribute.size, // How many floats used for the attribute\n          this.gl.FLOAT, // We are only sending over float data right now\n          attribute.normalize,\n          0,\n          0\n        );\n        if (\n          geometry.isInstanced &&\n          attribute.isInstanced &&\n          this.extensions.instancing\n        ) {\n          this.state.setVertexAttributeArrayDivisor(location, 1);\n        } else {\n          this.state.setVertexAttributeArrayDivisor(location, 0);\n        }\n        break;\n\n      // For sizes that exceed a single 'block' for a vertex attribute, one must break up the attribute pointers as the\n      // max allowed size is 4 at a time.\n      default:\n        const totalBlocks = Math.ceil(attribute.size / 4);\n\n        // ENable array for every location\n        for (let i = 0; i < totalBlocks; ++i) {\n          // Enable the use of the vertex location\n          this.state.willUseVertexAttributeArray(location + i);\n        }\n\n        // Now we establish the metrics of the buffer\n        for (let i = 0; i < totalBlocks; ++i) {\n          this.gl.vertexAttribPointer(\n            location + i,\n            4,\n            this.gl.FLOAT,\n            attribute.normalize,\n            totalBlocks * 4 * 4,\n            i * 16\n          );\n        }\n\n        for (let i = 0; i < totalBlocks; ++i) {\n          if (\n            geometry.isInstanced &&\n            attribute.isInstanced &&\n            this.extensions.instancing\n          ) {\n            this.state.setVertexAttributeArrayDivisor(location + i, 1);\n          } else {\n            this.state.setVertexAttributeArrayDivisor(location + i, 0);\n          }\n        }\n\n        break;\n    }\n\n    return true;\n  }\n}\n","import { EulerOrder, EulerRotation } from \"../types\";\nimport {\n  identity4,\n  M400,\n  M401,\n  M402,\n  M403,\n  M410,\n  M411,\n  M412,\n  M413,\n  M420,\n  M421,\n  M422,\n  M423,\n  M430,\n  M431,\n  M432,\n  M433,\n  Mat3x3,\n  Mat4x4\n} from \"./matrix\";\nimport { cross3, dot4, normalize3, Vec3, Vec3Compat, Vec4 } from \"./vector\";\n\nconst { cos, sin, sqrt, exp, acos, atan2, PI } = Math;\n\n/** Expresses a quaternion [scalar, i, j, k] */\nexport type Quaternion = Vec4;\n\nexport function clamp(x: number, min: number, max: number) {\n  if (x > max) return max;\n  if (x < min) return min;\n  return x;\n}\n\n/**\n * Generates a new zero quaternion\n */\nexport function zeroQuat(out?: Quaternion): Quaternion {\n  if (out) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n\n    return out;\n  }\n\n  return [0, 0, 0, 0];\n}\n\n/**\n * Adds two quaternions.\n */\nexport function addQuat(\n  q1: Quaternion,\n  q2: Quaternion,\n  out?: Quaternion\n): Quaternion {\n  out = out || zeroQuat();\n  out[0] = q1[0] + q2[0];\n  out[1] = q1[1] + q2[1];\n  out[2] = q1[2] + q2[2];\n  out[3] = q1[3] + q2[3];\n\n  return out;\n}\n\n/**\n * Multiplies two quaternions.\n * Note: Quaternion multiplication is noncommutative.\n */\nexport function multiplyQuat(\n  q1: Quaternion,\n  q2: Quaternion,\n  out?: Quaternion\n): Quaternion {\n  out = out || zeroQuat();\n\n  const a1 = q1[0],\n    a2 = q2[0],\n    b1 = q1[1],\n    b2 = q2[1],\n    c1 = q1[2],\n    c2 = q2[2],\n    d1 = q1[3],\n    d2 = q2[3];\n\n  out[0] = a1 * a2 - b1 * b2 - c1 * c2 - d1 * d2;\n  out[1] = a1 * b2 + b1 * a2 + c1 * d2 - d1 * c2;\n  out[2] = a1 * c2 - b1 * d2 + c1 * a2 + d1 * b2;\n  out[3] = a1 * d2 + b1 * c2 - c1 * b2 + d1 * a2;\n\n  return out;\n}\n\n/**\n * Performs quaternion division:\n * q1 / q2 = q1 * q2^-1\n */\nexport function divideQuat(\n  q1: Quaternion,\n  q2: Quaternion,\n  out?: Quaternion\n): Quaternion {\n  out = out || zeroQuat();\n\n  const a1 = q1[0],\n    b1 = q1[1],\n    c1 = q1[2],\n    d1 = q1[3];\n\n  const a2 = q2[0],\n    b2 = q2[1],\n    c2 = q2[2],\n    d2 = q2[3];\n\n  const norm = a2 * a2 + b2 * b2 + c2 * c2 + d2 * d2;\n\n  if (norm === 0) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  } else {\n    const r = 1 / norm;\n\n    out[0] = (a1 * a2 + b1 * b2 + c1 * c2 + d1 * d2) * r;\n    out[1] = (b1 * a2 - a1 * b2 - c1 * d2 + d1 * c2) * r;\n    out[2] = (c1 * a2 - a1 * c2 - d1 * b2 + b1 * d2) * r;\n    out[3] = (d1 * a2 - a1 * d2 - b1 * c2 + c1 * b2) * r;\n  }\n\n  return out;\n}\n\n/**\n * Calculates the exponentiation of a quaternion\n */\nexport function exponentQuat(q: Quaternion, out?: Quaternion): Quaternion {\n  out = out || zeroQuat();\n\n  const a = q[0],\n    b = q[1],\n    c = q[2],\n    d = q[3];\n\n  const norm = sqrt(b * b + c * c + d * d);\n  const wExp = exp(a);\n  const scale = (wExp / norm) * sin(norm);\n\n  if (norm === 0) {\n    out[0] = exp(a);\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  } else {\n    out[0] = wExp * cos(norm);\n    out[1] = b * scale;\n    out[2] = c * scale;\n    out[3] = d * scale;\n  }\n\n  return out;\n}\n\n/**\n * Multiplies a quaternion by a scalar.\n */\nexport function scaleQuat(\n  q: Quaternion,\n  scale: number,\n  out?: Quaternion\n): Quaternion {\n  out = out || zeroQuat();\n\n  out[0] = q[0] * scale;\n  out[1] = q[1] * scale;\n  out[2] = q[2] * scale;\n  out[3] = q[3] * scale;\n\n  return out;\n}\n\n/**\n * Computes the conjugate of a quaternion.\n */\nexport function conjugateQuat(q: Quaternion, out?: Quaternion): Quaternion {\n  out = out || zeroQuat();\n\n  out[0] = q[0];\n  out[1] = -q[1];\n  out[2] = -q[2];\n  out[3] = -q[3];\n\n  return out;\n}\n\n/**\n * Computes the inverse, or reciprocal, of a quaternion.\n */\nexport function inverseQuat(q: Quaternion, out?: Quaternion): Quaternion {\n  out = out || zeroQuat();\n\n  const a = q[0],\n    b = q[1],\n    c = q[2],\n    d = q[3];\n\n  const norm = a * a + b * b + c * c + d * d;\n\n  if (norm === 0) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  } else {\n    const r = 1 / norm;\n\n    out[0] = a * r;\n    out[1] = -b * r;\n    out[2] = -c * r;\n    out[3] = -d * r;\n  }\n\n  return out;\n}\n\n/**\n * Computes the length of a quaternion: that is, the square root of\n * the product of the quaternion with its conjugate.  Also known as\n * the \"norm\".\n */\nexport function lengthQuat(q: Quaternion): number {\n  const a = q[0],\n    b = q[1],\n    c = q[2],\n    d = q[3];\n\n  return sqrt(a * a + b * b + c * c + d * d);\n}\n\n/**\n * Normalizes a quaternion so its length is equal to 1.  The result of\n * normalizing a zero quaternion is undefined.\n */\nexport function normalizeQuat(q: Quaternion, out?: Quaternion): Quaternion {\n  out = out || zeroQuat();\n  const len = lengthQuat(q);\n  if (len === 0) return [0, 0, 0, 0];\n  const rlen = 1 / lengthQuat(q);\n\n  return scaleQuat(q, rlen, out);\n}\n\n/**\n * Provides the real part of the quaternion.\n */\nexport function realQuat(q: Quaternion): number {\n  return q[0];\n}\n\n/**\n * Provides the vector part of the quaternion.\n */\nexport function imaginaryQuat(q: Quaternion): Vec3 {\n  return [q[1], q[2], q[3]];\n}\n\n/**\n * Dot product of two quaternions\n */\nexport function dotQuat(q1: Quaternion, q2: Quaternion): number {\n  return dot4(q1, q2);\n}\n\n/**\n * Constructs a rotation quaternion from an axis (a normalized\n * Vec3) and an angle (in radians).\n */\nexport function fromEulerAxisAngleToQuat(\n  axis: Vec3,\n  angle: number,\n  out?: Quaternion\n): Quaternion {\n  out = out || zeroQuat();\n  const x = axis[0],\n    y = axis[1],\n    z = axis[2];\n  const r = 1 / sqrt(x * x + y * y + z * z);\n  const s = sin(angle / 2);\n  out[0] = cos(angle / 2);\n  out[1] = s * x * r;\n  out[2] = s * y * r;\n  out[3] = s * z * r;\n\n  return out;\n}\n\n/**\n * This converts a general euler angle of any rotation order into a quaternion\n */\nexport function fromOrderedEulerToQuat(\n  angles: Vec3,\n  order: EulerOrder,\n  out?: Quaternion\n): Quaternion {\n  out = out || zeroQuat();\n  const x = angles[0],\n    y = angles[1],\n    z = angles[2];\n\n  const cos = Math.cos;\n  const sin = Math.sin;\n\n  const c1 = cos(x / 2);\n  const c2 = cos(y / 2);\n  const c3 = cos(z / 2);\n\n  const s1 = sin(x / 2);\n  const s2 = sin(y / 2);\n  const s3 = sin(z / 2);\n\n  switch (order) {\n    case EulerOrder.xyz:\n      out[1] = s1 * c2 * c3 + c1 * s2 * s3;\n      out[2] = c1 * s2 * c3 - s1 * c2 * s3;\n      out[3] = c1 * c2 * s3 + s1 * s2 * c3;\n      out[0] = c1 * c2 * c3 - s1 * s2 * s3;\n      /*out[0] = c1 * c2 * c3 + s1 * s2 * s3;\n      out[1] = s1 * c2 * c3 - c1 * s2 * s3;\n      out[2] = c1 * s2 * c3 + s1 * c2 * s3;\n      out[3] = c1 * c2 * s3 - s1 * s2 * c3;*/\n      break;\n\n    case EulerOrder.yxz:\n      out[0] = c1 * c2 * c3 + s1 * s2 * s3;\n      out[1] = s1 * c2 * c3 + c1 * s2 * s3;\n      out[2] = c1 * s2 * c3 - s1 * c2 * s3;\n      out[3] = c1 * c2 * s3 - s1 * s2 * c3;\n      /*out[0] = c1 * c2 * c3 - s1 * s2 * s3;\n      out[1] = c1 * s2 * c3 - s1 * c2 * s3;\n      out[2] = c1 * s2 * s3 + s1 * c2 * c3 ;\n      out[3] = c1 * c2 * s3 + s1 * s2 * c3;*/\n      break;\n\n    case EulerOrder.zxy:\n      out[0] = c1 * c2 * c3 - s1 * s2 * s3;\n      out[1] = s1 * c2 * c3 - c1 * s2 * s3;\n      out[2] = c1 * s2 * c3 + s1 * c2 * s3;\n      out[3] = c1 * c2 * s3 + s1 * s2 * c3;\n      break;\n\n    case EulerOrder.zyx:\n      out[0] = c1 * c2 * c3 + s1 * s2 * s3;\n      out[1] = s1 * c2 * c3 - c1 * s2 * s3;\n      out[2] = c1 * s2 * c3 + s1 * c2 * s3;\n      out[3] = c1 * c2 * s3 - s1 * s2 * c3;\n\n      break;\n\n    case EulerOrder.yzx:\n      out[0] = c1 * c2 * c3 - s1 * s2 * s3;\n      out[1] = s1 * c2 * c3 + c1 * s2 * s3;\n      out[2] = c1 * s2 * c3 + s1 * c2 * s3;\n      out[3] = c1 * c2 * s3 - s1 * s2 * c3;\n\n      break;\n\n    case EulerOrder.xzy:\n      out[0] = c1 * c2 * c3 + s1 * s2 * s3;\n      out[1] = s1 * c2 * c3 - c1 * s2 * s3;\n      out[2] = c1 * s2 * c3 - s1 * c2 * s3;\n      out[3] = c1 * c2 * s3 + s1 * s2 * c3;\n\n      break;\n  }\n\n  return out;\n}\n\n/**\n * This converts a euler angle of any ordering and turns it into an euler of XYZ orientation which is the expected\n * rotation of most elements in this framework.\n */\nexport function toEulerXYZfromOrderedEuler(\n  euler: Vec3,\n  order: EulerOrder,\n  out?: EulerRotation\n): EulerRotation {\n  out = out || [0, 0, 0];\n  const q = fromOrderedEulerToQuat(euler, order);\n  toOrderedEulerFromQuat(q, EulerOrder.xyz, out);\n  // toOrderedEulerFromQuat(q, EulerOrder.zyx, out);\n  return out;\n}\n\n/**\n * Helper method for toEulerQuat\n */\nfunction twoAxisRotation(\n  r11: number,\n  r12: number,\n  r2: number,\n  r31: number,\n  r32: number,\n  out: number[]\n) {\n  out[0] = atan2(r11, r12);\n  out[1] = acos(r2);\n  out[2] = atan2(r31, r32);\n}\n\n/**\n * Helper method for toEulerQuat\n * TODO: May not need this method anymore?\n */\n// function threeAxisRotation(\n//   r11: number,\n//   r12: number,\n//   r2: number,\n//   r31: number,\n//   r32: number,\n//   out: number[]\n// ) {\n//   // out[0] = atan2(r31, r32);\n//   out[0] = atan2(r11, r12);\n//   out[1] = asin(r2);\n//   // out[2] = atan2(r11, r12);\n//   out[2] = atan2(r31, r32);\n// }\n\n/**\n * Produces a XYZ Euler angle from the provided Quaternion.\n */\nexport function toEulerFromQuat(q: Quaternion, out?: EulerRotation) {\n  return toOrderedEulerFromQuat(q, EulerOrder.zyx, out);\n}\n\n/**\n * Converts a quaternion to an ordered Euler angle.\n *\n * NOTE: It is best to convert to XYZ ordering if using with this framework's 3D system, or simply use toEulerFromQuat\n * if this is desired. Only use this if you specifically need an Euler angle for a known purpose.\n */\nexport function toOrderedEulerFromQuat(\n  q: Quaternion,\n  order: EulerOrder,\n  out?: Vec3\n): EulerRotation {\n  out = out || [0, 0, 0];\n\n  const q0 = q[0],\n    q1 = q[1],\n    q2 = q[2],\n    q3 = q[3];\n\n  const m = matrix4x4FromUnitQuatView(q);\n  const m11 = m[0],\n    m12 = m[4],\n    m13 = m[8];\n  const m21 = m[1],\n    m22 = m[5],\n    m23 = m[9];\n  const m31 = m[2],\n    m32 = m[6],\n    m33 = m[10];\n\n  switch (order) {\n    case EulerOrder.zyx:\n      /*threeAxisRotation(\n        2 * (q[1] * q[2] + q[0] * q[3]),\n        q[0] * q[0] + q[1] * q[1] - q[2] * q[2] - q[3] * q[3],\n        -2 * (q[1] * q[3] - q[0] * q[2]),\n        2 * (q[2] * q[3] + q[0] * q[1]),\n        q[0] * q[0] - q[1] * q[1] - q[2] * q[2] + q[3] * q[3],\n        out\n      );\n      threeAxisRotation(\n        2 * q0 * q3 - 2 * q1 * q2,\n        q1 * q1 + q0 * q0 - q3 * q3 - q2 * q2,\n        2 * q1 * q3 + 2 * q0 * q2,\n        2 * q0 * q1 - 2 * q2 * q3,\n        q3 * q3 - q2 * q2 - q1 * q1 + q0 * q0,\n        out\n      )*/\n\n      out[1] = Math.asin(-clamp(m31, -1, 1));\n\n      if (Math.abs(m31) < 0.99999) {\n        out[0] = Math.atan2(m32, m33);\n        out[2] = Math.atan2(m21, m11);\n      } else {\n        out[0] = 0;\n        out[2] = Math.atan2(-m12, m22);\n      }\n      break;\n\n    case EulerOrder.zyz:\n      /*twoAxisRotation(\n        2 * (q[2] * q[3] - q[0] * q[1]),\n        2 * (q[1] * q[3] + q[0] * q[2]),\n        q[0] * q[0] - q[1] * q[1] - q[2] * q[2] + q[3] * q[3],\n        2 * (q[2] * q[3] + q[0] * q[1]),\n        -2 * (q[1] * q[3] - q[0] * q[2]),\n        out\n      );*/\n      twoAxisRotation(\n        2 * q2 * q3 + 2 * q0 * q1,\n        2 * q0 * q2 - 2 * q1 * q3,\n        q3 * q3 - q2 * q2 - q1 * q1 + q0 * q0,\n        2 * q2 * q3 - 2 * q0 * q1,\n        2 * q1 * q3 + 2 * q0 * q2,\n        out\n      );\n      break;\n\n    case EulerOrder.zxy:\n      /*threeAxisRotation(\n        -2 * (q[1] * q[2] - q[0] * q[3]),\n        q[0] * q[0] - q[1] * q[1] + q[2] * q[2] - q[3] * q[3],\n        2 * (q[2] * q[3] + q[0] * q[1]),\n        -2 * (q[1] * q[3] - q[0] * q[2]),\n        q[0] * q[0] - q[1] * q[1] - q[2] * q[2] + q[3] * q[3],\n        out\n      );\n      threeAxisRotation(\n        2 * q1 * q2 + 2 * q0 * q3,\n        q2 * q2 - q3 * q3 + q0 * q0 - q1 * q1,\n        2 * q0 * q1 - 2 * q2 * q3,\n        2 * q1 * q3 + 2 * q0 * q2,\n        q3 * q3 - q2 * q2 - q1 * q1 + q0 * q0,\n        out\n      )*/\n      out[0] = Math.asin(clamp(m32, -1, 1));\n\n      if (Math.abs(m32) < 0.99999) {\n        out[1] = Math.atan2(-m31, m33);\n        out[2] = Math.atan2(-m12, m22);\n      } else {\n        out[1] = 0;\n        out[2] = Math.atan2(m21, m11);\n      }\n\n      break;\n\n    case EulerOrder.zxz:\n      /*twoAxisRotation(\n        2 * (q[1] * q[3] + q[0] * q[2]),\n        -2 * (q[2] * q[3] - q[0] * q[1]),\n        q[0] * q[0] - q[1] * q[1] - q[2] * q[2] + q[3] * q[3],\n        2 * (q[1] * q[3] - q[0] * q[2]),\n        2 * (q[2] * q[3] + q[0] * q[1]),\n        out\n      );*/\n      twoAxisRotation(\n        2 * q1 * q3 - 2 * q0 * q2,\n        2 * q2 * q3 + 2 * q0 * q1,\n        q3 * q3 - q2 * q2 - q1 * q1 + q0 * q0,\n        2 * q1 * q3 + 2 * q0 * q2,\n        2 * q0 * q1 - 2 * q2 * q3,\n        out\n      );\n      break;\n\n    case EulerOrder.yxz:\n      /*threeAxisRotation(\n        2 * (q[1] * q[3] + q[0] * q[2]),\n        q[0] * q[0] - q[1] * q[1] - q[2] * q[2] + q[3] * q[3],\n        -2 * (q[2] * q[3] - q[0] * q[1]),\n        2 * (q[1] * q[2] + q[0] * q[3]),\n        q[0] * q[0] - q[1] * q[1] + q[2] * q[2] - q[3] * q[3],\n        out\n      );\n      threeAxisRotation(\n        2 * q0 * q2 - 2 * q1 * q3,\n        q3 * q3 - q2 * q2 - q1 * q1 + q0 * q0,\n        2 * q2 * q3 + 2 * q0 * q1,\n        2 * q0 * q3 - 2 * q1 * q2,\n        q2 * q2 - q3 * q3 + q0 * q0 - q1 * q1,\n        out\n      )*/\n\n      out[0] = Math.asin(-clamp(m23, -1, 1));\n\n      if (Math.abs(m23) < 0.9999) {\n        out[1] = Math.atan2(m13, m33);\n        out[2] = Math.atan2(m21, m22);\n      } else {\n        out[1] = Math.atan2(-m31, m11);\n        out[2] = 0;\n      }\n      break;\n\n    case EulerOrder.yxy:\n      /*twoAxisRotation(\n        2 * (q[1] * q[2] - q[0] * q[3]),\n        2 * (q[2] * q[3] + q[0] * q[1]),\n        q[0] * q[0] - q[1] * q[1] + q[2] * q[2] - q[3] * q[3],\n        2 * (q[1] * q[2] + q[0] * q[3]),\n        -2 * (q[2] * q[3] - q[0] * q[1]),\n        out\n      );*/\n      twoAxisRotation(\n        2 * q1 * q2 + 2 * q0 * q3,\n        2 * q0 * q1 - 2 * q2 * q3,\n        q2 * q2 - q3 * q3 + q0 * q0 - q1 * q1,\n        2 * q1 * q2 - 2 * q0 * q3,\n        2 * q2 * q3 + 2 * q0 * q1,\n        out\n      );\n      break;\n\n    case EulerOrder.yzx:\n      /*threeAxisRotation(\n        -2 * (q[1] * q[3] - q[0] * q[2]),\n        q[0] * q[0] + q[1] * q[1] - q[2] * q[2] - q[3] * q[3],\n        2 * (q[1] * q[2] + q[0] * q[3]),\n        -2 * (q[2] * q[3] - q[0] * q[1]),\n        q[0] * q[0] - q[1] * q[1] + q[2] * q[2] - q[3] * q[3],\n        out\n      );\n      threeAxisRotation(\n        2 * q1 * q3 + 2 * q0 * q2,\n        q1 * q1 + q0 * q0 - q3 * q3 - q2 * q2,\n        2 * q0 * q3 - 2 * q1 * q2,\n        2 * q2 * q3 + 2 * q0 * q1,\n        q2 * q2 - q3 * q3 + q0 * q0 - q1 * q1,\n        out\n      )*/\n\n      out[2] = Math.asin(clamp(m21, -1, 1));\n\n      if (Math.abs(m21) < 0.99999) {\n        out[0] = Math.atan2(-m23, m22);\n        out[1] = Math.atan2(-m31, m11);\n      } else {\n        out[0] = 0;\n        out[1] = Math.atan2(m13, m33);\n      }\n      break;\n\n    case EulerOrder.yzy:\n      /*twoAxisRotation(\n        2 * (q[2] * q[3] + q[0] * q[1]),\n        -2 * (q[1] * q[2] - q[0] * q[3]),\n        q[0] * q[0] - q[1] * q[1] + q[2] * q[2] - q[3] * q[3],\n        2 * (q[2] * q[3] - q[0] * q[1]),\n        2 * (q[1] * q[2] + q[0] * q[3]),\n        out\n      );*/\n      twoAxisRotation(\n        2 * q2 * q3 - 2 * q0 * q1,\n        2 * q1 * q2 + 2 * q0 * q3,\n        q2 * q2 - q3 * q3 + q0 * q0 - q1 * q1,\n        2 * q2 * q3 + 2 * q0 * q1,\n        2 * q0 * q3 - 2 * q1 * q2,\n        out\n      );\n      break;\n\n    case EulerOrder.xyz:\n      /*threeAxisRotation(\n        -2 * (q[2] * q[3] - q[0] * q[1]),\n        q[0] * q[0] - q[1] * q[1] - q[2] * q[2] + q[3] * q[3],\n        2 * (q[1] * q[3] + q[0] * q[2]),\n        -2 * (q[1] * q[2] - q[0] * q[3]),\n        q[0] * q[0] + q[1] * q[1] - q[2] * q[2] - q[3] * q[3],\n        out\n      );\n      threeAxisRotation(\n        2 * q2 * q3 + 2 * q0 * q1,\n        q3 * q3 - q2 * q2 - q1 * q1 + q0 * q0,\n        2 * q0 *q2 - 2 * q1 * q3,\n        2 * q1 * q2 + 2 * q0 * q3,\n        q1 * q1 + q0 * q0 - q3 * q3 - q2 * q2,\n        out\n      );*/\n\n      out[1] = Math.asin(clamp(m13, -1, 1));\n\n      if (Math.abs(m13) < 0.99999) {\n        out[0] = Math.atan2(-m23, m33);\n        out[2] = Math.atan2(-m12, m11);\n      } else {\n        out[0] = Math.atan2(m32, m22);\n        out[2] = 0;\n      }\n      break;\n\n    case EulerOrder.xyx:\n      /*twoAxisRotation(\n        2 * (q[1] * q[2] + q[0] * q[3]),\n        -2 * (q[1] * q[3] - q[0] * q[2]),\n        q[0] * q[0] + q[1] * q[1] - q[2] * q[2] - q[3] * q[3],\n        2 * (q[1] * q[2] - q[0] * q[3]),\n        2 * (q[1] * q[3] + q[0] * q[2]),\n        out\n      );*/\n      twoAxisRotation(\n        2 * q1 * q2 - 2 * q0 * q3,\n        2 * q1 * q3 + 2 * q0 * q2,\n        q1 * q1 + q0 * q0 - q3 * q3 - q2 * q2,\n        2 * q1 * q2 + 2 * q0 * q3,\n        2 * q0 * q2 - 2 * q1 * q3,\n        out\n      );\n      break;\n\n    case EulerOrder.xzy:\n      /*threeAxisRotation(\n        2 * (q[2] * q[3] + q[0] * q[1]),\n        q[0] * q[0] - q[1] * q[1] + q[2] * q[2] - q[3] * q[3],\n        -2 * (q[1] * q[2] - q[0] * q[3]),\n        2 * (q[1] * q[3] + q[0] * q[2]),\n        q[0] * q[0] + q[1] * q[1] - q[2] * q[2] - q[3] * q[3],\n        out\n      );\n      threeAxisRotation(\n        2 * q0 * q1 - 2 * q2 * q3,\n        q2 * q2 - q3 * q3 + q0 * q0 - q1 * q1,\n        2 * q1 * q2 + 2 * q0 * q3,\n        2 * q0 * q2 - 2 * q1 * q3,\n        q1 * q1 + q0 * q0 - q3 * q3 - q2 * q2,\n        out\n      )*/\n\n      out[2] = Math.asin(-clamp(m12, -1, 1));\n\n      if (Math.abs(m12) < 0.99999) {\n        out[0] = Math.atan2(m32, m22);\n        out[1] = Math.atan2(m13, m11);\n      } else {\n        out[0] = Math.atan2(-m23, m33);\n        out[1] = 0;\n      }\n\n      break;\n\n    case EulerOrder.xzx:\n      /*twoAxisRotation(\n        2 * (q[1] * q[3] - q[0] * q[2]),\n        2 * (q[1] * q[2] + q[0] * q[3]),\n        q[0] * q[0] + q[1] * q[1] - q[2] * q[2] - q[3] * q[3],\n        2 * (q[1] * q[3] + q[0] * q[2]),\n        -2 * (q[1] * q[2] - q[0] * q[3]),\n        out\n      );*/\n\n      twoAxisRotation(\n        2 * q1 * q3 + 2 * q0 * q2,\n        2 * q0 * q3 - 2 * q1 * q2,\n        q1 * q1 + q0 * q0 - q3 * q3 - q2 * q2,\n        2 * q1 * q3 - 2 * q0 * q2,\n        2 * q1 * q2 + 2 * q0 * q3,\n        out\n      );\n      break;\n\n    default:\n      console.warn(\"Invalid Euler rotation order.\");\n      break;\n  }\n\n  return out;\n}\n\nexport function toOrderedEulerFromQuat2(\n  quat: Quaternion,\n  order: EulerOrder,\n  out?: Vec3\n) {\n  out = out || [0, 0, 0];\n\n  const m = matrix4x4FromUnitQuatView(quat);\n  const m11 = m[0],\n    m12 = m[4],\n    m13 = m[8];\n  const m21 = m[1],\n    m22 = m[5],\n    m23 = m[9];\n  const m31 = m[2],\n    m32 = m[6],\n    m33 = m[10];\n\n  switch (order) {\n    case EulerOrder.xyz:\n      out[1] = Math.asin(clamp(m13, -1, 1));\n\n      if (Math.abs(m13) < 0.99999) {\n        out[0] = Math.atan2(-m23, m33);\n        out[2] = Math.atan2(-m12, m11);\n      } else {\n        out[0] = Math.atan2(m32, m22);\n        out[2] = 0;\n      }\n\n      break;\n    case EulerOrder.yxz:\n      out[0] = Math.asin(-clamp(m23, -1, 1));\n\n      if (Math.abs(m23) < 0.9999) {\n        out[1] = Math.atan2(m13, m33);\n        out[2] = Math.atan2(m21, m22);\n      } else {\n        out[1] = Math.atan2(-m31, m11);\n        out[2] = 0;\n      }\n\n      break;\n    case EulerOrder.zxy:\n      out[0] = Math.asin(clamp(m32, -1, 1));\n\n      if (Math.abs(m32) < 0.99999) {\n        out[1] = Math.atan2(-m31, m33);\n        out[2] = Math.atan2(-m12, m22);\n      } else {\n        out[1] = 0;\n        out[2] = Math.atan2(m21, m11);\n      }\n\n      break;\n    case EulerOrder.zyx:\n      out[1] = Math.asin(-clamp(m31, -1, 1));\n\n      if (Math.abs(m31) < 0.99999) {\n        out[0] = Math.atan2(m32, m33);\n        out[2] = Math.atan2(m21, m11);\n      } else {\n        out[0] = 0;\n        out[2] = Math.atan2(-m12, m22);\n      }\n\n      break;\n    case EulerOrder.yzx:\n      out[2] = Math.asin(clamp(m21, -1, 1));\n\n      if (Math.abs(m21) < 0.99999) {\n        out[0] = Math.atan2(-m23, m22);\n        out[1] = Math.atan2(-m31, m11);\n      } else {\n        out[0] = 0;\n        out[1] = Math.atan2(m13, m33);\n      }\n\n      break;\n    case EulerOrder.xzy:\n      out[2] = Math.asin(-clamp(m12, -1, 1));\n\n      if (Math.abs(m12) < 0.99999) {\n        out[0] = Math.atan2(m32, m22);\n        out[1] = Math.atan2(m13, m11);\n      } else {\n        out[0] = Math.atan2(-m23, m33);\n        out[1] = 0;\n      }\n\n      break;\n  }\n}\n\n/**\n * Extracts the angle part, in radians, of a rotation quaternion.\n */\nexport function angleQuat(quat: Quaternion): number {\n  const a = quat[0];\n\n  if (a < -1.0 || a > 1.0) {\n    return 0.0;\n  }\n\n  const angle = 2 * acos(a);\n\n  if (angle > PI) {\n    return angle - 2 * PI;\n  }\n\n  return angle;\n}\n\n/**\n * Extracts the axis part, as a Vec3, of a rotation quaternion.\n */\nexport function axisQuat(quat: Quaternion): Vec3 {\n  const x = quat[1],\n    y = quat[2],\n    z = quat[3];\n\n  const length = sqrt(x * x + y * y + z * z);\n\n  if (length === 0) return [0, 0, 0];\n\n  const r = 1 / sqrt(x * x + y * y + z * z);\n\n  return [x * r, y * r, z * r];\n}\n\n/**\n * Produces a transform matrix from a returned unit quaternion. This is a matrix that is from a 'models' perspective\n * where the model orients itself to match the orientation.\n */\nexport function matrix4x4FromUnitQuatModel(q: Quaternion, m?: Mat4x4): Mat4x4 {\n  let wx, wy, wz, xx, yy, yz, xy, xz, zz, x2, y2, z2;\n  m = m || identity4();\n\n  // calculate coefficients\n  x2 = q[1] + q[1];\n  y2 = q[2] + q[2];\n  z2 = q[3] + q[3];\n  xx = q[1] * x2;\n  xy = q[1] * y2;\n  xz = q[1] * z2;\n  yy = q[2] * y2;\n  yz = q[2] * z2;\n  zz = q[3] * z2;\n  wx = q[0] * x2;\n  wy = q[0] * y2;\n  wz = q[0] * z2;\n\n  m[M400] = 1.0 - (yy + zz);\n  m[M401] = xy - wz;\n  m[M402] = xz + wy;\n  m[M403] = 0.0;\n\n  m[M410] = xy + wz;\n  m[M411] = 1.0 - (xx + zz);\n  m[M412] = yz - wx;\n  m[M413] = 0.0;\n\n  m[M420] = xz - wy;\n  m[M421] = yz + wx;\n  m[M422] = 1.0 - (xx + yy);\n  m[M423] = 0.0;\n\n  m[M430] = 0;\n  m[M431] = 0;\n  m[M432] = 0;\n  m[M433] = 1;\n\n  return m;\n}\n\n/**\n * Produces a transform matrix from a returned unit quaternion. This is a matrix that is from a 'views' perspective\n * where the world orients to match the view.\n */\nexport function matrix4x4FromUnitQuatView(q: Quaternion, m?: Mat4x4): Mat4x4 {\n  let wx, wy, wz, xx, yy, yz, xy, xz, zz, x2, y2, z2;\n  m = m || identity4();\n\n  // calculate coefficients\n  x2 = q[1] + q[1];\n  y2 = q[2] + q[2];\n  z2 = q[3] + q[3];\n  xx = q[1] * x2;\n  xy = q[1] * y2;\n  xz = q[1] * z2;\n  yy = q[2] * y2;\n  yz = q[2] * z2;\n  zz = q[3] * z2;\n  wx = q[0] * x2;\n  wy = q[0] * y2;\n  wz = q[0] * z2;\n\n  m[M400] = 1.0 - (yy + zz);\n  m[M410] = xy - wz;\n  m[M420] = xz + wy;\n  m[M430] = 0.0;\n\n  m[M401] = xy + wz;\n  m[M411] = 1.0 - (xx + zz);\n  m[M421] = yz - wx;\n  m[M431] = 0.0;\n\n  m[M402] = xz - wy;\n  m[M412] = yz + wx;\n  m[M422] = 1.0 - (xx + yy);\n  m[M432] = 0.0;\n\n  m[M403] = 0;\n  m[M413] = 0;\n  m[M423] = 0;\n  m[M433] = 1;\n\n  return m;\n}\n\n/**\n * Converts Euler angles [roll(X), pitch(Y), yaw(Z)]\n */\nexport function eulerToQuat(\n  angles: EulerRotation,\n  out?: Quaternion\n): Quaternion {\n  out = out || zeroQuat();\n  let cr, cp, cy, sr, sp, sy, cpcy, spsy;\n  const [roll, pitch, yaw] = angles;\n\n  // calculate trig identities\n  cr = cos(roll / 2);\n  cp = cos(pitch / 2);\n  cy = cos(yaw / 2);\n  sr = sin(roll / 2);\n  sp = sin(pitch / 2);\n  sy = sin(yaw / 2);\n  cpcy = cp * cy;\n  spsy = sp * sy;\n  out[0] = cr * cpcy + sr * spsy;\n  out[1] = sr * cpcy - cr * spsy;\n  out[2] = cr * sp * cy + sr * cp * sy;\n  out[3] = cr * cp * sy - sr * sp * cy;\n\n  return out;\n}\n\n/**\n * This produces a quaternion that creates an orientation that will look in the direction specified.\n */\nexport function lookAtQuat(\n  forward: Vec3Compat,\n  up: Vec3Compat,\n  q?: Quaternion\n): Quaternion {\n  q = q || zeroQuat();\n  forward = normalize3(forward);\n\n  const f: Vec3 = [-forward[0], -forward[1], -forward[2]];\n  const l = normalize3(cross3(up, f));\n  const u = normalize3(cross3(f, l));\n\n  const m00 = l[0];\n  const m01 = l[1];\n  const m02 = l[2];\n  const m10 = u[0];\n  const m11 = u[1];\n  const m12 = u[2];\n  const m20 = f[0];\n  const m21 = f[1];\n  const m22 = f[2];\n\n  const tr = m00 + m11 + m22;\n\n  if (tr > 0.0) {\n    const s = sqrt(tr + 1.0) * 2;\n    q[0] = 0.25 * s;\n    q[1] = (m21 - m12) / s;\n    q[2] = (m02 - m20) / s;\n    q[3] = (m10 - m01) / s;\n\n    return q;\n  }\n\n  if (m00 > m11 && m00 > m22) {\n    const s = sqrt(1.0 + m00 - m11 - m22) * 2;\n    q[0] = (m21 - m12) / s;\n    q[1] = 0.25 * s;\n    q[2] = (m01 + m10) / s;\n    q[3] = (m02 + m20) / s;\n\n    return q;\n  }\n\n  if (m11 > m22) {\n    const s = sqrt(1.0 + m11 - m00 - m22) * 2;\n\n    q[0] = (m02 - m20) / s;\n    q[1] = (m10 + m01) / s;\n    q[2] = 0.25 * s;\n    q[3] = (m21 + m12) / s;\n\n    return q;\n  }\n\n  const s = sqrt(1.0 + m22 - m00 - m11) * 2;\n  q[0] = (m10 - m01) / s;\n  q[1] = (m20 + m02) / s;\n  q[2] = (m21 + m12) / s;\n  q[3] = 0.25 * s;\n\n  return q;\n}\n\nexport function matrix3x3ToQuaternion(mat: Mat3x3, q?: Quaternion): Quaternion {\n  q = q || zeroQuat();\n\n  const m00 = mat[0];\n  const m01 = mat[3];\n  const m02 = mat[6];\n  const m10 = mat[1];\n  const m11 = mat[4];\n  const m12 = mat[7];\n  const m20 = mat[2];\n  const m21 = mat[5];\n  const m22 = mat[8];\n\n  const tr = m00 + m11 + m22;\n\n  if (tr > 0.0) {\n    const s = sqrt(tr + 1.0) * 2;\n    q[0] = 0.25 * s;\n    q[1] = (m21 - m12) / s;\n    q[2] = (m02 - m20) / s;\n    q[3] = (m10 - m01) / s;\n\n    return q;\n  }\n\n  if (m00 > m11 && m00 > m22) {\n    const s = sqrt(1.0 + m00 - m11 - m22) * 2;\n    q[0] = (m21 - m12) / s;\n    q[1] = 0.25 * s;\n    q[2] = (m01 + m10) / s;\n    q[3] = (m02 + m20) / s;\n\n    return q;\n  }\n\n  if (m11 > m22) {\n    const s = sqrt(1.0 + m11 - m00 - m22) * 2;\n\n    q[0] = (m02 - m20) / s;\n    q[1] = (m10 + m01) / s;\n    q[2] = 0.25 * s;\n    q[3] = (m21 + m12) / s;\n\n    return q;\n  }\n\n  const s = sqrt(1.0 + m22 - m00 - m11) * 2;\n  q[0] = (m10 - m01) / s;\n  q[1] = (m20 + m02) / s;\n  q[2] = (m21 + m12) / s;\n  q[3] = 0.25 * s;\n\n  return q;\n}\n\nexport function matrix4x4ToQuaternion(mat: Mat4x4, q?: Quaternion): Quaternion {\n  q = q || zeroQuat();\n\n  const m00 = mat[0];\n  const m01 = mat[4];\n  const m02 = mat[8];\n  const m10 = mat[1];\n  const m11 = mat[5];\n  const m12 = mat[9];\n  const m20 = mat[2];\n  const m21 = mat[6];\n  const m22 = mat[10];\n\n  const tr = m00 + m11 + m22;\n\n  if (tr > 0.0) {\n    const s = sqrt(tr + 1.0) * 2;\n    q[0] = 0.25 * s;\n    // num = 0.5 / num;\n    q[1] = (m21 - m12) / s;\n    q[2] = (m02 - m20) / s;\n    q[3] = (m10 - m01) / s;\n\n    return q;\n  }\n\n  if (m00 > m11 && m00 > m22) {\n    // const num7 = sqrt(1.0 + m00 - m11 - m22);\n    // const num4 = 0.5 / num7;\n    const s = sqrt(1.0 + m00 - m11 - m22) * 2;\n    q[0] = (m21 - m12) / s;\n    q[1] = 0.25 * s;\n    q[2] = (m01 + m10) / s;\n    q[3] = (m02 + m20) / s;\n\n    return q;\n  }\n\n  if (m11 > m22) {\n    // const num6 = sqrt(1.0 + m11 - m00 - m22);\n    // const num3 = 0.5 / num6;\n    const s = sqrt(1.0 + m11 - m00 - m22) * 2;\n\n    q[0] = (m02 - m20) / s;\n    q[1] = (m10 + m01) / s;\n    q[2] = 0.25 * s;\n    q[3] = (m21 + m12) / s;\n\n    return q;\n  }\n\n  // const num5 = sqrt(1.0 + m22 - m00 - m11);\n  // const num2 = 0.5 / num5;\n  const s = sqrt(1.0 + m22 - m00 - m11) * 2;\n  q[0] = (m10 - m01) / s;\n  q[1] = (m20 + m02) / s;\n  q[2] = (m21 + m12) / s;\n  q[3] = 0.25 * s;\n\n  return q;\n}\n\nexport function lookAtMatrix(\n  forward: Vec3Compat,\n  up: Vec3Compat,\n  m?: Mat4x4\n): Mat4x4 {\n  m = m || identity4();\n\n  forward = normalize3(forward);\n\n  const f: Vec3 = [-forward[0], -forward[1], -forward[2]];\n  const l = normalize3(cross3(up, f));\n  const u = normalize3(cross3(f, l));\n\n  m[0] = l[0];\n  m[1] = u[0];\n  m[2] = f[0];\n  m[3] = 0.0;\n  m[4] = l[1];\n  m[5] = u[1];\n  m[6] = f[1];\n  m[7] = 0.0;\n  m[8] = l[2];\n  m[9] = u[2];\n  m[10] = f[2];\n  m[11] = 0.0;\n  m[12] = 0.0;\n  m[13] = 0.0;\n  m[14] = 0.0;\n  m[15] = 1.0;\n\n  return m;\n}\n\n/**\n * SLERP interpolation between two quaternion orientations. The Quaternions MUST be unit quats for this to be valid.\n * If the quat has gotten out of normalization from precision errors, consider renormalizing the quaternion.\n */\nexport function slerpUnitQuat(\n  from: Quaternion,\n  to: Quaternion,\n  t: number,\n  out?: Quaternion\n): Quaternion {\n  out = out || zeroQuat();\n  const to1: Vec4 = [0, 0, 0, 0];\n  let omega, cosom, sinom, scale0, scale1;\n  cosom = from[1] * to[1] + from[2] * to[2] + from[3] * to[3] + from[0] * to[0];\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    to1[0] = -to[1];\n    to1[1] = -to[2];\n    to1[2] = -to[3];\n    to1[3] = -to[0];\n  } else {\n    to1[0] = to[1];\n    to1[1] = to[2];\n    to1[2] = to[3];\n    to1[3] = to[0];\n  }\n\n  // Calculate coefficients for final values. We use SLERP if the difference between the two angles isn't too big.\n  if (1.0 - cosom > 0.0000001) {\n    omega = acos(cosom);\n    sinom = sin(omega);\n    scale0 = sin((1.0 - t) * omega) / sinom;\n    scale1 = sin(t * omega) / sinom;\n  }\n\n  // We linear interpolate for quaternions that are very close together in angle.\n  else {\n    scale0 = 1.0 - t;\n    scale1 = t;\n  }\n\n  // calculate final values\n  out[1] = scale0 * from[1] + scale1 * to1[0];\n  out[2] = scale0 * from[2] + scale1 * to1[1];\n  out[3] = scale0 * from[3] + scale1 * to1[2];\n  out[0] = scale0 * from[0] + scale1 * to1[3];\n\n  return out;\n}\n\n/**\n * One basis quaternion\n */\nexport function oneQuat(): Quaternion {\n  return [1, 0, 0, 0];\n}\n\n/**\n * i basis quaternion\n */\nexport function iQuat(): Quaternion {\n  return [0, 1, 0, 0];\n}\n\n/**\n * j basis quaternion\n */\nexport function jQuat(): Quaternion {\n  return [0, 0, 1, 0];\n}\n\n/**\n * i basis quaternion\n */\nexport function kQuat(): Quaternion {\n  return [0, 0, 0, 1];\n}\n","import { Bounds } from \"./bounds\";\n\n/**\n * Anytime this is used to express bounds of an object, it is expected\n * to behave like CSS styling with absolute positioning.\n *\n * Setting a left and a right will auto calculate width (setting width takes precedence)\n *\n * You can set numbers to a %. If no % is present all other characters will be ignored\n * (px, em, and other dimensions will not be supported...just px by default unless %)\n */\nexport type AbsolutePosition = {\n  bottom?: number | string;\n  height?: number | string;\n  left?: number | string;\n  right?: number | string;\n  top?: number | string;\n  width?: number | string;\n};\n\nfunction value(val: number | string, ref: number, scaleRatio: number) {\n  const parse = `${val}`;\n  const num = parseFloat(parse);\n\n  if (isNaN(num)) {\n    return 0;\n  }\n\n  // If this is a percentage use the reference as the num to multiply against\n  if (parse.indexOf(\"%\") > -1) {\n    return (num / 100.0) * ref;\n  }\n\n  return num * scaleRatio;\n}\n\n/**\n * This evaluates an absolute position with a reference to produce meaningful bounds.\n *\n * The scaleRatio provided should be available in or for percents to have the same weighting\n * as whole number values.\n */\nexport function getAbsolutePositionBounds<T>(\n  item: AbsolutePosition,\n  reference: Bounds<any>,\n  scaleRatio: number\n): Bounds<T> {\n  if (reference.width === 0 || reference.height === 0) {\n    console.warn(\n      \"An AbsolutePosition evaluated to invalid dimensions.\",\n      \"Please ensure that the object provided and the reference has valid dimensions\",\n      \"to produce dimensions with width and height that are non-zero.\",\n      \"item:\",\n      item,\n      \"reference:\",\n      reference.toString()\n    );\n  }\n\n  const bounds = Bounds.emptyBounds<T>();\n  let width;\n  let height;\n\n  // Calculate the horizontal values\n  if (item.width) {\n    bounds.width = value(item.width, reference.width, scaleRatio);\n\n    if (item.left !== undefined) {\n      bounds.x = value(item.left, reference.width, scaleRatio);\n    } else if (item.right !== undefined) {\n      bounds.x =\n        reference.width -\n        value(item.right, reference.width, scaleRatio) -\n        bounds.width;\n    }\n  } else {\n    const left = value(item.left || 0, reference.width, scaleRatio);\n    const right =\n      reference.width - value(item.right || 0, reference.width, scaleRatio);\n    width = right - left;\n\n    if (width < 0) {\n      console.warn(\n        \"An AbsolutePosition evaluated to invalid dimensions.\",\n        \"Please ensure that the object provided and the reference has valid dimensions\",\n        \"to produce dimensions with width and height that are greater than zero.\",\n        \"item:\",\n        item,\n        \"reference:\",\n        reference.toString()\n      );\n    }\n\n    bounds.x = left;\n    bounds.width = width;\n  }\n\n  // Calculate the vertical values\n  if (item.height) {\n    bounds.height = value(item.height, reference.height, scaleRatio);\n\n    if (item.top !== undefined) {\n      bounds.y = value(item.top, reference.height, scaleRatio);\n    } else if (item.bottom !== undefined) {\n      bounds.y =\n        reference.height -\n        value(item.bottom, reference.height, scaleRatio) -\n        bounds.height;\n    }\n  } else {\n    const top = value(item.top || 0, reference.height, scaleRatio);\n    const bottom =\n      reference.height - value(item.bottom || 0, reference.height, scaleRatio);\n    height = bottom - top;\n\n    if (height === undefined || height < 0) {\n      console.warn(\n        \"An AbsolutePosition evaluated to invalid dimensions.\",\n        \"Please ensure that the object provided and the reference has valid dimensions\",\n        \"to produce dimensions with width and height that are greater than zero.\",\n        \"item:\",\n        item,\n        \"reference:\",\n        reference.toString()\n      );\n    }\n\n    bounds.y = top;\n    bounds.height = height;\n  }\n\n  if (\n    bounds.width === 0 ||\n    bounds.height === 0 ||\n    isNaN(bounds.x + bounds.y + bounds.width + bounds.height)\n  ) {\n    bounds.x = 0;\n    bounds.y = 0;\n    bounds.width = reference.width;\n    bounds.height = reference.height;\n  }\n\n  return bounds;\n}\n","/**\n * Shallow comparison of two objects\n */\nexport function shallowCompare(objA: any, objB: any) {\n  if (!objA || !objB) {\n    return objA === objB;\n  }\n\n  return !Boolean(\n    Object.keys(Object.assign({}, objA, objB)).find(\n      key => objA[key] !== objB[key]\n    )\n  );\n}\n","import { ISingleTouchInteraction } from \"../event-management/types\";\n\n/**\n * This file contains common methods for filtering data within the framework.\n */\n\n/**\n * When applied to a filter (eg - .filter(isDefined)), this will make the resulting array not have any FALSEY values.\n * This will also ensure the resulting TYPE of the array is not undefined or null. Thus:\n *\n * const test: (Type1 | Type2 | ... | undefined | null)[] = []\n * const notNull = test.filter(isDefined);\n *\n * notNull will now have a type that excludes undefined and null values.\n *\n * NOTE: The type correction seems to only work when you use this method DIRECTLY as a filter parameter\n * .filter(isDefined) Works!\n * .filter(val => isDefined(val)) Does NOT adjust typings!\n *\n * WARNING: This WILL filter out FALSEY values. So if values like 0 or '' is VALID, then beware.\n */\nexport function isDefined<T>(val: T | null | undefined): val is T {\n  return Boolean(val);\n}\n\n/**\n * This is a filter for touch events. This will filter down a list of ISingleTouchInteractions to a list that has\n * interactions who only have a specified start view.\n */\nexport function touchesHasStartView(view: string | string[]) {\n  if (Array.isArray(view)) {\n    return (touch: ISingleTouchInteraction) =>\n      view.indexOf(touch.start.view.id) >= 0;\n  }\n\n  return (touch: ISingleTouchInteraction) => touch.start.view.id === view;\n}\n\n/**\n * This is a filter for touch events. This will filter down a list of ISingleTouchInteractions to a list that has\n * interactions who only have a view that was under the start position of the touch.\n */\nexport function touchesContainsStartView(view: string | string[]) {\n  if (Array.isArray(view)) {\n    return (touch: ISingleTouchInteraction) =>\n      touch.start.views.find(v => view.indexOf(v.view.id) >= 0);\n  }\n\n  return (touch: ISingleTouchInteraction) =>\n    touch.start.views.find(v => v.view.id === view);\n}\n","import { Vec2 } from \"../math/vector\";\nimport { normalizeWheel } from \"./normalize-wheel\";\n\n/**\n * Analyzes a MouseEvent and calculates the mouse coordinates (relative to the element).\n */\nfunction eventElementPosition(e: any, relative?: HTMLElement): Vec2 {\n  let mouseX: number = 0,\n    mouseY: number = 0,\n    eventX: number = 0,\n    eventY: number = 0,\n    object: any =\n      relative || (e.nativeEvent && e.nativeEvent.target) || e.target;\n\n  // Get mouse position on document crossbrowser\n  if (!e) {\n    e = window.event;\n  }\n\n  if (e.pageX || e.pageY) {\n    mouseX = e.pageX;\n    mouseY = e.pageY;\n  } else if (e.clientX || e.clientY) {\n    let scrollLeft = 0;\n    let scrollTop = 0;\n\n    if (document.documentElement) {\n      scrollLeft = document.documentElement.scrollLeft;\n      scrollTop = document.documentElement.scrollTop;\n    }\n\n    mouseX = e.clientX + document.body.scrollLeft + scrollLeft;\n    mouseY = e.clientY + document.body.scrollTop + scrollTop;\n  }\n\n  // Get parent element position in document\n  if (object.offsetParent) {\n    do {\n      eventX += object.offsetLeft;\n      eventY += object.offsetTop;\n      object = object.offsetParent;\n    } while (object);\n  }\n\n  // Mouse position minus elm position is mouseposition relative to element:\n  return [mouseX - eventX, mouseY - eventY];\n}\n\nexport { eventElementPosition, normalizeWheel };\n","import { Bounds } from \"../math/primitives/bounds\";\nimport { isVec2, Vec2 } from \"../math/vector\";\n\n// A configuration that controls how readily a quadtree will split to another level\n// Adjusting this number can improve or degrade your performance significantly and\n// Must be tested for specific use cases\nconst maxPopulation: number = 5;\nconst maxDepth: number = 10;\n\nexport type IQuadTreeItem = Bounds<any>;\n\n/**\n * This filters a quad tree query by type\n *\n * @export\n * @template T\n */\nexport function filterQuery<T extends IQuadTreeItem>(\n  type: Function[],\n  queryValues: IQuadTreeItem[]\n): T[] {\n  const filtered: T[] = [];\n\n  queryValues.forEach((obj: IQuadTreeItem) => {\n    if (type.find(t => obj instanceof t)) {\n      filtered.push(obj as T);\n    }\n  });\n\n  return filtered;\n}\n\n/**\n * Allows typing of a callback argument\n */\nexport interface IQuadTreeVisitFunction<T extends IQuadTreeItem> {\n  /**\n   * A callback to use during add or query\n   *\n   * Called do provide aggregation or filtering like Array.reduce or\n   * Array.filter, but in a QuadTree instead.\n   *\n   * @param node  The node to effect the function upon\n   * @param child The child to add to the node\n   */\n  (node: QuadTreeNode<T>, child?: IQuadTreeItem): void;\n}\n\n/**\n * This is a class used specifically by the quad tree nodes to indicate split space\n * within the quad tree.\n *\n * @class Quadrants\n */\nexport class QuadTreeQuadrants<T extends IQuadTreeItem> {\n  TL: QuadTreeNode<T>;\n  TR: QuadTreeNode<T>;\n  BL: QuadTreeNode<T>;\n  BR: QuadTreeNode<T>;\n\n  /**\n   * Ensures all memory is released for all nodes and all references are removed\n   * to potentially high memory consumption items\n   *\n   * @memberOf Quadrants\n   */\n  destroy() {\n    this.TL.destroy();\n    this.TR.destroy();\n    this.BL.destroy();\n    this.BR.destroy();\n    delete this.TL;\n    delete this.TR;\n    delete this.BL;\n    delete this.BR;\n  }\n\n  /**\n   * Creates an instance of Quadrants.\n   *\n   * @param bounds The bounds this will create quandrants for\n   * @param depth  The child depth of this element\n   *\n   * @memberOf Quadrants\n   */\n  constructor(bounds: IQuadTreeItem, depth: number) {\n    const mid = bounds.mid;\n    this.TL = new QuadTreeNode<T>(bounds.x, mid[0], bounds.y, mid[1], depth);\n    this.TR = new QuadTreeNode<T>(\n      mid[0],\n      bounds.right,\n      bounds.y,\n      mid[1],\n      depth\n    );\n    this.BL = new QuadTreeNode<T>(\n      bounds.x,\n      mid[0],\n      mid[1],\n      bounds.bottom,\n      depth\n    );\n    this.BR = new QuadTreeNode<T>(\n      mid[0],\n      bounds.right,\n      mid[1],\n      bounds.bottom,\n      depth\n    );\n  }\n}\n\n/**\n * The quad tree node. This Node will take in a certain population before dividing itself into\n * 4 quadrants which it will attempt to inject it's population into. If a member of the population\n * does not completely get injected into one of the quadrants it remains as a member of this node.\n *\n * @export\n * @class Node\n */\nexport class QuadTreeNode<T extends IQuadTreeItem> {\n  bounds: Bounds<never>;\n  children: T[] = [];\n  depth: number = 0;\n  nodes: QuadTreeQuadrants<T>;\n\n  /**\n   * Destroys this node and ensures all child nodes are destroyed as well.\n   *\n   * @memberOf Node\n   */\n  destroy() {\n    delete this.children;\n    delete this.bounds;\n\n    if (this.nodes) {\n      this.nodes.destroy();\n      delete this.nodes;\n    }\n  }\n\n  /**\n   * Creates an instance of Node.\n   *\n   * @param l     The bounding left wall of the space this node covers\n   * @param r     The bounding right wall of the space this node covers\n   * @param t     The bounding top wall of the space this node covers\n   * @param b     The bounding bottom wall of the space this node covers\n   * @param depth The depth within the quad tree this node resides\n   *\n   * @memberOf Node\n   */\n  constructor(\n    left: number,\n    right: number,\n    top: number,\n    bottom: number,\n    depth?: number\n  ) {\n    // If params insertted\n    if (arguments.length >= 4) {\n      this.bounds = new Bounds({ left, right, top, bottom });\n    } else {\n      // Otherwise, make tiny start area\n      this.bounds = new Bounds({ left: 0, right: 1, top: 0, bottom: 1 });\n    }\n\n    // Ensure the depth is set\n    this.depth = depth || 0;\n  }\n\n  /**\n   * Adds an object that extends Bounds (or is Bounds) and properly injects it into this node\n   * or into a sub quadrant if this node is split already. If the child is outside the boundaries\n   * this quad tree spans (and this is the root node), the quad tree will expand to include\n   * the new child.\n   *\n   * @param child The Bounds type object to inject\n   * @param props Properties that can be retrieved with the child object if applicable\n   *\n   * @returns True if the insertion was successful\n   *\n   * @memberOf Node\n   */\n  add(child: T, props: any): boolean {\n    // This is the entry function for adding children, so we must first expand our top node\n    // To cover the area that the child is located.\n    // If we're in bounds, then let's just add the child\n    if (child.isInside(this.bounds)) {\n      return this.doAdd(child);\n    } else {\n      // Otherwise, we need to expand first\n      this.cover(child);\n      return this.add(child, props);\n    }\n  }\n\n  /**\n   * Adds a list of new children to this quad tree. It performs the same operations as\n   * addChild for each child in the list, however, it more efficiently recalculates the\n   * bounds necessary to cover the area the children cover.\n   *\n   * @param children      List of Bounds objects to inject\n   */\n  addAll(children: T[]) {\n    // Make sure we cover the entire area of all the children.\n    // We can speed this up a lot if we first calculate the total bounds the new children covers\n    let minX = Number.MAX_SAFE_INTEGER,\n      minY = Number.MAX_SAFE_INTEGER,\n      maxX = Number.MIN_SAFE_INTEGER,\n      maxY = Number.MIN_SAFE_INTEGER;\n\n    const { min, max } = Math;\n\n    // Get the dimensions of the new bounds\n    for (let i = 0, iMax = children.length; i < iMax; ++i) {\n      const child = children[i];\n\n      minX = min(minX, child.x);\n      maxX = max(child.right, maxX);\n      minY = min(minY, child.y);\n      maxY = max(maxY, child.bottom);\n    }\n\n    // Make sure our bounds includes the specified bounds\n    this.cover(\n      new Bounds({ left: minX, right: maxX, top: minY, bottom: maxY })\n    );\n    // Add all of the children into the tree\n    children.forEach(child => this.doAdd(child));\n  }\n\n  /**\n   * Ensures this quad tree includes the bounds specified in it's spatial coverage.\n   * This will cause all children to be re-injected into the tree.\n   *\n   * @param bounds The bounds to include in the tree's coverage\n   */\n  cover(bounds: IQuadTreeItem) {\n    // If we are already covering the area: abort\n    if (bounds.isInside(this.bounds)) {\n      return;\n    }\n\n    // Make our bounds cover the new area\n    this.bounds.encapsulate(bounds);\n    this.bounds.x -= 1;\n    this.bounds.y -= 1;\n    this.bounds.width += 2;\n    this.bounds.height += 2;\n    // Get all of the children underneath this node\n    const allChildren = this.gatherChildren([]);\n\n    // Destroy the split nodes\n    if (this.nodes) {\n      // completely...destroy...\n      this.nodes.destroy();\n      delete this.nodes;\n    }\n\n    // Reinsert all children with the new dimensions in place\n    allChildren.forEach(child => this.doAdd(child));\n  }\n\n  /**\n   * When adding children, this performs the actual action of injecting the child into the tree\n   * without the process of seeing if the tree needs a spatial adjustment to account for the child.\n   *\n   * @param child The Bounds item to inject into the tree\n   *\n   * @returns True if the injection was successful\n   */\n  doAdd(child: T): boolean {\n    // If nodes are present, then we have already exceeded the population of this node\n    if (this.nodes) {\n      if (child.isInside(this.nodes.TL.bounds)) {\n        return this.nodes.TL.doAdd(child);\n      }\n\n      if (child.isInside(this.nodes.TR.bounds)) {\n        return this.nodes.TR.doAdd(child);\n      }\n\n      if (child.isInside(this.nodes.BL.bounds)) {\n        return this.nodes.BL.doAdd(child);\n      }\n\n      if (child.isInside(this.nodes.BR.bounds)) {\n        return this.nodes.BR.doAdd(child);\n      }\n\n      // Otherwise, this is a child overlapping this border\n      this.children.push(child);\n\n      return true;\n    } else if (child.isInside(this.bounds)) {\n      // Otherwise, we have not had a split due to population limits being exceeded\n      this.children.push(child);\n\n      // If we exceeded our population for this quadrant, it is time to split up\n      if (this.children.length > maxPopulation && this.depth < maxDepth) {\n        this.split();\n      }\n\n      return true;\n    }\n\n    // This is when there is something wrong with the insertted child. The bounds\n    // For the quad should have grown without issue, but in this case the bounds\n    // Could not grow to accomodate the child.\n    if (isNaN(child.width + child.height + child.x + child.y)) {\n      console.error(\n        \"Child did not fit into bounds because a dimension is NaN\",\n        child\n      );\n    } else if (child.area === 0) {\n      console.error(\n        \"Child did not fit into bounds because the area is zero\",\n        child\n      );\n    }\n\n    // Don't insert the child and continue\n    return true;\n  }\n\n  /**\n   * Collects all children of all the current and sub nodes into a single list.\n   *\n   * @param list The list we must aggregate children into\n   *\n   * @return The list specified as the list parameter\n   */\n  gatherChildren(list: T[], visit?: IQuadTreeVisitFunction<T>): T[] {\n    if (visit) visit(this);\n\n    for (let i = 0, iMax = this.children.length; i < iMax; ++i) {\n      list.push(this.children[i]);\n    }\n\n    if (this.nodes) {\n      this.nodes.TL.gatherChildren(list, visit);\n      this.nodes.TR.gatherChildren(list, visit);\n      this.nodes.BL.gatherChildren(list, visit);\n      this.nodes.BR.gatherChildren(list, visit);\n    }\n\n    return list;\n  }\n\n  /**\n   * Entry query for determining query type based on input object\n   *\n   * @param bounds Can be a Bounds or a Point object\n   * @param visit  A callback function that will receive the Node as it is analyzed. This gives\n   *               information on a spatial scale, how a query reaches it's target intersections.\n   *\n   * @return An array of children that intersects with the query\n   */\n  query(bounds: IQuadTreeItem | Vec2, visit?: IQuadTreeVisitFunction<T>): T[] {\n    // Query a rectangle\n    if (bounds instanceof Bounds) {\n      if (bounds.hitBounds(this.bounds)) {\n        return this.queryBounds(bounds, [], visit);\n      }\n\n      // Return an empty array when nothing is collided with\n      return [];\n    } else if (isVec2(bounds)) {\n      // Query a point\n      if (this.bounds.containsPoint(bounds)) {\n        return this.queryPoint(bounds, [], visit);\n      }\n    }\n\n    // Return an empty array when nothing is collided with\n    return [];\n  }\n\n  /**\n   * Queries children for intersection with a bounds object\n   *\n   * @param b     The Bounds to test children against\n   * @param list  The list of children to aggregate into the query\n   * @param visit A callback function that will receive the Node as it is analyzed. This gives\n   *              information on a spatial scale, how a query reaches it's target intersections.\n   *\n   * @return     Returns the exact same list that was input as the list param\n   */\n  queryBounds(\n    b: IQuadTreeItem,\n    list: T[],\n    visit?: IQuadTreeVisitFunction<T>\n  ): T[] {\n    // As an optimization for querying by bounds, if the bounds engulfs these bounds,\n    // we can assume all of the contents of this node and child nodes are hit by the bounds\n    // So simply gather the child items and don't do extra tests\n    if (this.bounds.isInside(b)) {\n      this.gatherChildren(list, visit);\n      return list;\n    }\n\n    // Gather the children as hit at this point\n    this.children.forEach(c => {\n      if (c.hitBounds(b)) {\n        list.push(c);\n      }\n    });\n\n    if (visit) {\n      visit(this);\n    }\n\n    if (this.nodes) {\n      if (b.hitBounds(this.nodes.TL.bounds)) {\n        this.nodes.TL.queryBounds(b, list, visit);\n      }\n\n      if (b.hitBounds(this.nodes.TR.bounds)) {\n        this.nodes.TR.queryBounds(b, list, visit);\n      }\n\n      if (b.hitBounds(this.nodes.BL.bounds)) {\n        this.nodes.BL.queryBounds(b, list, visit);\n      }\n\n      if (b.hitBounds(this.nodes.BR.bounds)) {\n        this.nodes.BR.queryBounds(b, list, visit);\n      }\n    }\n\n    return list;\n  }\n\n  /**\n   * Queries children for intersection with a point\n   *\n   * @param p     The Point to test children against\n   * @param list  The list of children to aggregate into the query\n   * @param visit A callback function that will receive the Node as it is analyzed. This gives\n   *              information on a spatial scale, how a query reaches it's target intersections.\n   *\n   * @return      Returns the exact same list that was input as the list param\n   */\n  queryPoint(p: any, list: T[], visit?: IQuadTreeVisitFunction<T>): T[] {\n    this.children.forEach(c => {\n      if (c.containsPoint(p)) {\n        list.push(c);\n      }\n    });\n\n    if (visit) {\n      visit(this);\n    }\n\n    if (this.nodes) {\n      if (this.nodes.TL.bounds.containsPoint(p)) {\n        this.nodes.TL.queryPoint(p, list, visit);\n      }\n\n      if (this.nodes.TR.bounds.containsPoint(p)) {\n        this.nodes.TR.queryPoint(p, list, visit);\n      }\n\n      if (this.nodes.BL.bounds.containsPoint(p)) {\n        this.nodes.BL.queryPoint(p, list, visit);\n      }\n\n      if (this.nodes.BR.bounds.containsPoint(p)) {\n        this.nodes.BR.queryPoint(p, list, visit);\n      }\n    }\n\n    return list;\n  }\n\n  /**\n   * Creates four sub quadrants for this node.\n   */\n  split() {\n    // Gather all items to be handed down\n    const allChildren: T[] = [];\n    this.gatherChildren(allChildren);\n    // Gather all props for the children to be handed down as well\n    this.nodes = new QuadTreeQuadrants<T>(this.bounds, this.depth + 1);\n    // Clear the children from our node to be reinjected to re-assess where they belong\n    // within the split nodes\n    this.children = [];\n\n    for (let i = 0, iMax = allChildren.length; i < iMax; ++i) {\n      const child = allChildren[i];\n      if (child) this.doAdd(child);\n    }\n  }\n\n  /**\n   * Traverses the quad tree returning every quadrant encountered\n   *\n   * @param cb A callback that has the parameter (node) which is a quadrant in the tree\n   */\n  visit(cb: IQuadTreeVisitFunction<T>): void {\n    const finished = Boolean(cb(this));\n\n    if (this.nodes && !finished) {\n      this.nodes.TL.visit(cb);\n      this.nodes.TR.visit(cb);\n      this.nodes.BL.visit(cb);\n      this.nodes.BR.visit(cb);\n    }\n  }\n}\n\nexport class QuadTree<T extends IQuadTreeItem> extends QuadTreeNode<T> {}\n","import { nextFrame } from \"./frame\";\nimport { PromiseResolver } from \"./promise-resolver\";\n\n/**\n * This produces a method that is a gate for methods that may be entered multiple times before a valid dimension occurs.\n * This allows you to reduce the number of times the method is allowed to actually execute (reduced to a single\n * execution) once the dimensions are valid.\n *\n * For example, if we have an init() method that keeps getting called until object is properly initialized, but the\n * object is waiting for valid dimensions from it's container then you can get this pattern to happen:\n *\n * obj.init(); // no valid dimensions\n * obj.init(); // no valid dimensions\n * // dimensions are now valid!\n * obj.init(); // Initializes properly!\n *\n * You will notice an inherent problem or challenge. obj.init() probably contains code that shouldn't execute unless\n * the dimensions are available. Additionally you may see this happen:\n *\n * obj.init(); // no valid dimensions\n * // Nothing else happens\n * // Dimensions are now valid!\n * // obj.init isn't ever going to get called again\n *\n * So you are stuck with needing a robust initializer that can handle being called multiple times, only execute once,\n * and can wait for the dimensions to occur. It's also assumed the most recent init() call should be the one true\n * method call.\n *\n * So we have this method which allows you to make such a robust method:\n *\n * class Obj {\n *   waitToInit = waitForValidDimensions(container);\n *\n *   async init() {\n *     const result = this.waitToInit();\n *     if (!result) return;\n *     // Do your init\n *   }\n * }\n *\n * Now init methods will stack up waiting for the valid dimensions, but upon valid dimensions being available, all the\n * methods will resolve but only the latest init will actually execute as it will be the only one provided a 'true'\n * result.\n */\nexport function waitForValidDimensions(container?: HTMLElement) {\n  // This is the context flag for the operation. This let's us know which resolution is the most recent and is validly\n  // waiting for the container to finish\n  let waitForSizeContext = 0;\n  // We queue up all the resolvers for this context, this way we can resolve all existing gates if the container\n  // should change. If we're waiting for a new container with the same context, then we should assume the others that\n  // are waiting are no longer valid as only the most recent will resolve as a valid result (which, again, will be\n  // against a new container)\n  let resolvers: PromiseResolver<boolean>[] = [];\n\n  // This is the gate method that is used to await upon to receive a result from waiting for the dimensions.\n  const gate: Function & { cancel: Function } = Object.assign(\n    async (otherContainer?: HTMLElement): Promise<boolean> => {\n      // Check the input container, if we're suddenly waiting for a new container, the previous contexts should be\n      // invalid\n      if (otherContainer !== void 0 && otherContainer !== container) {\n        resolvers.forEach(r => r.resolve(false));\n        container = otherContainer;\n      }\n\n      // If a valid container is not specified, there is no way for this to ever resolve, so we immediately resolve to\n      // false.\n      if (!container) return false;\n\n      const waitForSizeId = ++waitForSizeContext;\n      const resolver = new PromiseResolver<boolean>();\n      let box = container.getBoundingClientRect();\n      let observer: MutationObserver | undefined;\n      resolvers.push(resolver);\n\n      // Check to ensure the box width and height is valid\n      if (box.width === 0 || box.height === 0) {\n        let observing = true;\n        const toWatch = {\n          attributes: true\n        };\n\n        // Try to use a DOM concept for waiting for changes to the container\n        observer = new MutationObserver(mutationsList => {\n          if (!observing) return;\n\n          for (const mutation of mutationsList) {\n            if (mutation.type === \"attributes\") {\n              // Make sure our container context stayed valid\n              if (!container) return;\n              box = container.getBoundingClientRect();\n\n              if (box.width !== 0 && box.height !== 0) {\n                if (observer) {\n                  observer.disconnect();\n                  observer = void 0;\n                }\n\n                observing = false;\n                resolver.resolve(waitForSizeId === waitForSizeContext);\n              }\n            }\n          }\n        });\n\n        observer.observe(container, toWatch);\n\n        // Give the system an additional way to check for a valid sizing if the observer fails\n        await nextFrame();\n        box = container.getBoundingClientRect();\n\n        if (observing && box.width !== 0 && box.height !== 0) {\n          observer.disconnect();\n          observing = false;\n          resolver.resolve(waitForSizeId === waitForSizeContext);\n        }\n      } else {\n        // Both calls awaiting a size must be async in order for this method to work\n        await nextFrame();\n        resolver.resolve(waitForSizeId === waitForSizeContext);\n      }\n\n      const result = await resolver.promise;\n\n      // Absolutely make sure the observer is disconnected as the promise can be resolved externally from other processes\n      // completing.\n      if (observer) {\n        observer.disconnect();\n        observer = void 0;\n      }\n\n      if (result) {\n        resolvers.forEach(r => r.resolve(false));\n        resolvers = [];\n      }\n\n      return result;\n    },\n\n    // We apply a cancel method to allow for a manual forced cancellation of all contexts waiting for the valid\n    // dimensions to occur. This allows for proper memory cleansing\n    {\n      cancel: () => {\n        resolvers.forEach(r => r.resolve(false));\n        resolvers = [];\n      }\n    }\n  );\n\n  return gate;\n}\n","import { compare4, copy4, flatten4, Vec4 } from \"../math/vector\";\nimport { TypeVec } from \"../types\";\nimport { indexToTextureUnit, textureUnitToIndex } from \"./gl-decode\";\nimport { GLProxy } from \"./gl-proxy\";\nimport { GLSettings } from \"./gl-settings\";\nimport { Material } from \"./material\";\nimport { RenderTarget } from \"./render-target\";\nimport { Texture } from \"./texture\";\nimport {\n  IExtensions,\n  IMaterialUniform,\n  MaterialUniformType,\n  MaterialUniformValue\n} from \"./types\";\n\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * This class represents all of the current state and settings that the gl context is in currently. This\n * helps to decide when to make gl calls to alter the state and not do so unecessarily.\n *\n * This state focuses on global state settings like bound objects and gl settings. Other state\n * for the GL context is stored within objects that are generated, such as Texture and Attribute.\n */\nexport class GLState {\n  /** Message to include with debug, warns, and errors */\n  debugContext: string = \"\";\n  /** The extensions enabled for the context */\n  private extensions: IExtensions;\n  /** Stores the gl context this is watching the state over */\n  private gl: WebGLRenderingContext;\n  /** This is a proxy to execute commands that do not change global gl state */\n  private glProxy: GLProxy;\n  /** Lookup a texture unit to it's current assigned texture. */\n  private _textureUnitToTexture = new Map<number, Texture | null>();\n  /** This holds which texture units are free for use and have no Texture assigned to them */\n  private _freeUnits: number[] = [];\n\n  /** Indicates if blending is enabled */\n  get blendingEnabled() {\n    return this._blendingEnabled;\n  }\n  private _blendingEnabled = true;\n\n  /** The current destination factor used in the blending equation */\n  get blendDstFactor() {\n    return this._blendDstFactor;\n  }\n  private _blendDstFactor = GLSettings.Material.BlendingDstFactor.One;\n\n  /** The current destination factor used in the blending equation */\n  get blendSrcFactor() {\n    return this._blendSrcFactor;\n  }\n  private _blendSrcFactor:\n    | GLSettings.Material.BlendingSrcFactor\n    | GLSettings.Material.BlendingDstFactor =\n    GLSettings.Material.BlendingDstFactor.One;\n\n  /** The current equation used in the blend mode */\n  get blendEquation() {\n    return this._blendEquation;\n  }\n  private _blendEquation = GLSettings.Material.BlendingEquations.Add;\n\n  /** Indicates which faces will be culled */\n  get cullFace() {\n    return this._cullFace;\n  }\n  private _cullFace: GLSettings.Material.CullSide =\n    GLSettings.Material.CullSide.NONE;\n\n  /** The channels in the color buffer a fragment is allowed to write to */\n  get colorMask() {\n    return this._colorMask;\n  }\n  private _colorMask: TypeVec<boolean> = [true, true, true, true];\n\n  /** The current color the context will clear when clear with the color buffer bit is called */\n  get clearColor() {\n    return this._clearColor;\n  }\n  private _clearColor: Vec4 = [0.0, 0.0, 0.0, 1.0];\n\n  /** Comparator used when testing a fragment against the depth buffer */\n  get depthFunc() {\n    return this._depthFunc;\n  }\n  private _depthFunc = GLSettings.Material.DepthFunctions.ALWAYS;\n\n  /** Indicates if fragments are tested against the depth buffer or not */\n  get depthTestEnabled() {\n    return this._depthTestEnabled;\n  }\n  private _depthTestEnabled = true;\n\n  /** Indicates if the fragment will write to the depth buffer or not */\n  get depthMask() {\n    return this._depthMask;\n  }\n  private _depthMask = true;\n\n  /** Indicates if dithering is enabled */\n  get ditheringEnabled() {\n    return this._ditheringEnabled;\n  }\n  private _ditheringEnabled = true;\n\n  /** The currently bound frame buffer object. null if nothing bound. */\n  get boundFBO() {\n    return this._boundFBO;\n  }\n  private _boundFBO: WebGLFramebuffer | null = null;\n\n  /** The currently bound render buffer object. null if nothing bound. */\n  get boundRBO() {\n    return this._boundRBO;\n  }\n  private _boundRBO: WebGLRenderbuffer | null = null;\n\n  /** The current id of the current bound vbo. If null, nothing is bound */\n  get boundVBO() {\n    return this._boundVBO;\n  }\n  private _boundVBO: WebGLBuffer | null = null;\n\n  /**\n   * The current texture object bound. If null, nothing is bound. This also tracks\n   * the texture unit to which it was bound. The unit and the texture object must match for\n   * a binding call to be skipped.\n   */\n  get boundTexture() {\n    return this._boundTexture;\n  }\n  private _boundTexture: { id: WebGLTexture | null; unit: number } = {\n    id: null,\n    unit: -1\n  };\n\n  /** The current program in use */\n  get currentProgram() {\n    return this._currentProgram;\n  }\n  private _currentProgram: WebGLProgram | null = null;\n\n  /** Indicates if the scissor test is enabled in the context */\n  get scissorTestEnabled() {\n    return this._scissorTestEnabled;\n  }\n  private _scissorTestEnabled: boolean = false;\n\n  /** The current bounds of the scissor test */\n  get scissorBounds() {\n    return this._scissorBounds;\n  }\n  private _scissorBounds = { x: 0, y: 0, width: 1, height: 1 };\n\n  /** These are the current uniforms uploaded to the GPU */\n  get currentUniforms() {\n    return this._currentUniforms;\n  }\n  private _currentUniforms: {\n    [name: string]: IMaterialUniform<MaterialUniformType>;\n  };\n\n  /** This is the texture unit currently active */\n  get activeTextureUnit() {\n    return this._activeTextureUnit;\n  }\n  private _activeTextureUnit: number = -1;\n\n  /**\n   * This contains all of the textures that are are needing to be utilized for next draw.\n   * Textures are used by either uniforms or by RenderTargets in a single draw call. Thus\n   * we track the uniforms or the render targets awaiting use of the texture.\n   */\n  get textureWillBeUsed() {\n    return this._textureWillBeUsed;\n  }\n  private _textureWillBeUsed = new Map<\n    Texture,\n    Set<WebGLUniformLocation> | RenderTarget\n  >();\n\n  /** The current viewport gl is using */\n  get viewport() {\n    return this._viewport;\n  }\n  private _viewport = { x: 0, y: 0, width: 100, height: 100 };\n\n  /** This contains all of the currently enabled vertex attribute pointers */\n  get enabledVertexAttributeArray() {\n    return this._enabledVertexAttributeArray\n      .slice(0)\n      .filter(n => n !== undefined);\n  }\n  private _enabledVertexAttributeArray: number[] = [];\n  private _willUseVertexAttributeArray: number[] = [];\n\n  /** Tracks the current divisor set to a given vertex array location. */\n  private _vertexAttributeArrayDivisor = new Map<number, number>();\n\n  /**\n   * Generate a new state manager and establish some initial state settings by querying the context.\n   */\n  constructor(gl: WebGLRenderingContext, extensions: IExtensions) {\n    this.gl = gl;\n    this.extensions = extensions;\n    // Retrieve how many units are allowed at the same time to be assiged so we can initialize our free units array\n    const totalUnits = this.gl.getParameter(\n      gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS\n    );\n\n    for (let i = 0; i < totalUnits; ++i) {\n      this._freeUnits.push(indexToTextureUnit(gl, i));\n    }\n\n    // Initialize state to valid value\n    this._activeTextureUnit = gl.TEXTURE0;\n  }\n\n  /**\n   * Sets the provided buffer identifier as the current bound item.\n   */\n  bindVBO(id: WebGLBuffer | null) {\n    if (this._boundVBO !== id) {\n      this._boundVBO = id;\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, id);\n    }\n  }\n\n  /**\n   * Sets the provided buffer identifier as the current bound item\n   */\n  bindRBO(id: WebGLRenderbuffer) {\n    if (this._boundRBO !== id) {\n      this._boundRBO = id;\n      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, id);\n    }\n  }\n\n  /**\n   * Sets the provided buffer identifier as the current bound item\n   */\n  bindFBO(id: WebGLFramebuffer | null) {\n    if (this._boundFBO !== id) {\n      this._boundFBO = id;\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, id);\n    }\n  }\n\n  /**\n   * Sets the provided buffer identifier as the current bound item. This automatically\n   * updates all stateful information to track that a texture is now utilizing a texture unit.\n   */\n  bindTexture(\n    texture: Texture,\n    target: GLSettings.Texture.TextureBindingTarget\n  ) {\n    if (!texture.gl || !texture.gl.textureId) return;\n\n    if (\n      !texture ||\n      this._boundTexture.id !== texture.gl.textureId ||\n      this._boundTexture.unit !== this._activeTextureUnit\n    ) {\n      this._boundTexture = {\n        id: texture.gl.textureId,\n        unit: this._activeTextureUnit\n      };\n\n      switch (target) {\n        case GLSettings.Texture.TextureBindingTarget.TEXTURE_2D:\n          this.gl.bindTexture(this.gl.TEXTURE_2D, texture.gl.textureId);\n          break;\n\n        case GLSettings.Texture.TextureBindingTarget.TEXTURE_2D:\n          this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, texture.gl.textureId);\n          break;\n      }\n\n      // Since the binding happened, we HAVE to track that this texture is now the texture\n      // for the current active unit. We must also remove the unit from any texture previously\n      // utilizing the unit\n      const previous = this._textureUnitToTexture.get(this._activeTextureUnit);\n\n      if (previous) {\n        if (previous.gl) previous.gl.textureUnit = -1;\n      }\n\n      this._textureUnitToTexture.set(this._activeTextureUnit, texture);\n      texture.gl.textureUnit = this._activeTextureUnit;\n    }\n  }\n\n  /**\n   * Flags an attribute array as going to be used. Any attribute array location\n   * no longer in use will be disabled when applyVertexAttributeArrays is called.\n   */\n  willUseVertexAttributeArray(index: number) {\n    // Flag the index as will be used\n    this._willUseVertexAttributeArray[index] = index;\n    // If already enabled we're done\n    if (this._enabledVertexAttributeArray[index] !== undefined) return;\n    // Flag the index as enabled\n    this._enabledVertexAttributeArray[index] = index;\n    // Otherwise, get this location enabled right away\n    this.gl.enableVertexAttribArray(index);\n  }\n\n  /**\n   * This enables the necessary vertex attribute arrays.\n   */\n  applyVertexAttributeArrays() {\n    // All locations that should be enabled are now enabled\n    // Disable any locations that will not be used\n    for (\n      let i = 0, iMax = this._enabledVertexAttributeArray.length;\n      i < iMax;\n      ++i\n    ) {\n      const index = this._enabledVertexAttributeArray[i];\n\n      if (index !== undefined) {\n        if (this._willUseVertexAttributeArray[index] !== undefined) return;\n        this.gl.disableVertexAttribArray(index);\n        delete this._enabledVertexAttributeArray[index];\n      }\n    }\n\n    // Reset the use array for next draw\n    this._willUseVertexAttributeArray = [];\n  }\n\n  /**\n   * Applies (if necessary) the divisor for a given array. This only works if the array location\n   * is enabled.\n   */\n  setVertexAttributeArrayDivisor(index: number, divisor: number) {\n    if (!this.extensions.instancing) return;\n\n    if (this._enabledVertexAttributeArray[index] !== undefined) {\n      if (this._vertexAttributeArrayDivisor.get(index) !== divisor) {\n        if (this.extensions.instancing instanceof WebGL2RenderingContext) {\n          this.extensions.instancing.vertexAttribDivisor(index, divisor);\n        } else {\n          this.extensions.instancing.vertexAttribDivisorANGLE(index, divisor);\n        }\n\n        this._vertexAttributeArrayDivisor.set(index, divisor);\n      }\n    }\n  }\n\n  /**\n   * This takes a texture and flags it's texture unit as freed if the texture has a used unit\n   */\n  freeTextureUnit(texture: Texture) {\n    if (texture.gl) {\n      if (texture.gl.textureUnit > -1) {\n        this._freeUnits.unshift(texture.gl.textureUnit);\n        texture.gl.textureUnit = -1;\n      }\n    }\n  }\n\n  /**\n   * Changes the active texture unit to the provided unit.\n   */\n  setActiveTextureUnit(unit: number) {\n    if (this._activeTextureUnit !== unit) {\n      this._activeTextureUnit = unit;\n      this.gl.activeTexture(unit);\n    }\n  }\n\n  /**\n   * Changes the gl clear color state\n   */\n  setClearColor(color: Vec4) {\n    if (!compare4(color, this._clearColor)) {\n      this._clearColor = copy4(color);\n      this.applyClearColor();\n    }\n  }\n\n  /**\n   * Sets the GPU proxy to be used to handle commands that call to the GPU but don't alter\n   * global GL state.\n   */\n  setProxy(proxy: GLProxy) {\n    this.glProxy = proxy;\n  }\n\n  /**\n   * Enables or disables the scissor test\n   */\n  setScissor(\n    bounds: { x: number; y: number; width: number; height: number } | null\n  ) {\n    if (bounds) {\n      if (!this._scissorTestEnabled) {\n        this._scissorTestEnabled = true;\n        this.gl.enable(this.gl.SCISSOR_TEST);\n      }\n\n      if (\n        bounds.x !== this._scissorBounds.x ||\n        bounds.y !== this._scissorBounds.y ||\n        bounds.width !== this._scissorBounds.width ||\n        bounds.height !== this._scissorBounds.height\n      ) {\n        this._scissorBounds = bounds;\n        this.applyScissorBounds();\n      }\n    } else {\n      if (this._scissorTestEnabled) {\n        this._scissorTestEnabled = false;\n        this.gl.disable(this.gl.SCISSOR_TEST);\n      }\n    }\n  }\n\n  /**\n   * Applies a viewport to the given state\n   */\n  setViewport(x: number, y: number, width: number, height: number) {\n    if (\n      x !== this._viewport.x ||\n      y !== this._viewport.y ||\n      width !== this._viewport.width ||\n      height !== this._viewport.height\n    ) {\n      this._viewport = { x, y, width, height };\n      this.applyViewport();\n    }\n  }\n\n  /**\n   * Uses the program indicated\n   */\n  useProgram(program: WebGLProgram) {\n    if (this._currentProgram !== program) {\n      this._currentProgram = program;\n      this.gl.useProgram(this._currentProgram);\n    }\n  }\n\n  /**\n   * Sets all current gl state to match the materials settings.\n   */\n  useMaterial(material: Material) {\n    // Make sure the material is compiled\n    if (!material.gl) {\n      if (!this.glProxy.compileMaterial(material)) {\n        return false;\n      }\n\n      if (!material.gl) {\n        return false;\n      }\n    }\n\n    if (!material.gl.programId) {\n      return false;\n    }\n\n    // Use the material's program\n    this.useProgram(material.gl.programId);\n    // Synchronize the material's settings to the gl state\n    this.syncMaterial(material);\n\n    return true;\n  }\n\n  /**\n   * Sets all current gl state to match the render target specified\n   */\n  useRenderTarget(target: RenderTarget | null) {\n    if (!target) {\n      this.bindFBO(null);\n      return true;\n    }\n\n    // The gl context must be specified for the target in order to use it\n    if (!target.gl) return false;\n    // Bind the FBO of the target as the current item we are rendering into\n    this.bindFBO(target.gl.fboId);\n\n    return true;\n  }\n\n  /**\n   * This syncs the state of the GL context with the requested state of a material\n   */\n  syncMaterial(material: Material) {\n    const gl = this.gl;\n    const depthWrite = Boolean(material.depthWrite);\n\n    // Depth mode changes\n    if (this._depthMask !== depthWrite) {\n      this._depthMask = depthWrite;\n      gl.depthMask(this._depthMask);\n    }\n\n    if (this._depthTestEnabled !== material.depthTest) {\n      this._depthTestEnabled = material.depthTest;\n      this._depthTestEnabled\n        ? gl.enable(gl.DEPTH_TEST)\n        : gl.disable(gl.DEPTH_TEST);\n    }\n\n    if (this._depthFunc !== material.depthFunc) {\n      this._depthFunc = material.depthFunc;\n      this.applyDepthFunc();\n    }\n\n    // Blending changes\n    if (material.blending) {\n      if (!this._blendingEnabled) {\n        gl.enable(gl.BLEND);\n      }\n\n      if (\n        this._blendDstFactor !== material.blending.blendDst ||\n        this._blendSrcFactor !== material.blending.blendSrc ||\n        this._blendEquation !== material.blending.blendEquation\n      ) {\n        this._blendDstFactor =\n          material.blending.blendDst || this._blendDstFactor;\n        this._blendSrcFactor =\n          material.blending.blendSrc || this._blendSrcFactor;\n        this._blendEquation =\n          material.blending.blendEquation || this._blendEquation;\n        this.applyBlendFactors();\n      }\n    } else {\n      if (this._blendingEnabled) {\n        gl.disable(gl.BLEND);\n      }\n    }\n\n    // Cull mode\n    if (this._cullFace !== material.culling) {\n      this._cullFace = material.culling;\n      this.applyCullFace();\n    }\n\n    // Color mode\n    if (\n      this._colorMask[0] !== material.colorWrite[0] ||\n      this._colorMask[1] !== material.colorWrite[1] ||\n      this._colorMask[2] !== material.colorWrite[2] ||\n      this._colorMask[3] !== material.colorWrite[3]\n    ) {\n      this._colorMask = material.colorWrite;\n      this.applyColorMask();\n    }\n\n    // Dithering\n    if (this._ditheringEnabled !== material.dithering) {\n      this._ditheringEnabled = material.dithering;\n      this._ditheringEnabled ? gl.enable(gl.DITHER) : gl.disable(gl.DITHER);\n    }\n\n    // Uniforms\n    this._currentUniforms = material.uniforms;\n    let success = true;\n\n    if (!this._currentProgram) {\n      return false;\n    }\n\n    // Now we can update and retrieve the locations for each uniform in the program\n    Object.entries(material.uniforms).forEach(([name, uniform]) => {\n      if (!this._currentProgram) return;\n      if (!uniform.gl) uniform.gl = new Map();\n      let glSettings = uniform.gl.get(this._currentProgram);\n\n      // If no settings for the given program are present, then we must\n      // query the program for the uniform's locations and what not.\n      if (!glSettings) {\n        const location = this.gl.getUniformLocation(this._currentProgram, name);\n\n        if (!location) {\n          console.warn(\n            this.debugContext,\n            `A Material specified a uniform ${name}, but none was found in the current program.`\n          );\n          success = false;\n          return;\n        }\n\n        glSettings = {\n          location\n        };\n\n        // Store the found location for the uniform\n        uniform.gl.set(this._currentProgram, glSettings);\n      }\n\n      // After locations for the uniforms are established, we must now copy the uniform\n      // info into the GPU\n      this.uploadUniform(glSettings.location, uniform);\n    });\n\n    if (!success) {\n      console.warn(material.vertexShader);\n      console.warn(material.fragmentShader);\n      return false;\n    }\n\n    // Textures\n    if (this._textureWillBeUsed.size > 0) {\n      if (!this.applyUsedTextures()) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Performs the upload operation of a uniform to the GL context\n   */\n  private uploadUniform(\n    location: WebGLUniformLocation,\n    uniform: IMaterialUniform<MaterialUniformType>\n  ) {\n    let v;\n\n    switch (uniform.type) {\n      case MaterialUniformType.FLOAT:\n        v = uniform.value as MaterialUniformValue<MaterialUniformType.FLOAT>;\n        this.gl.uniform1f(location, v);\n        break;\n\n      case MaterialUniformType.VEC2:\n        v = uniform.value as MaterialUniformValue<MaterialUniformType.VEC2>;\n        this.gl.uniform2f(location, v[0], v[1]);\n        break;\n\n      case MaterialUniformType.VEC3:\n        v = uniform.value as MaterialUniformValue<MaterialUniformType.VEC3>;\n        this.gl.uniform3f(location, v[0], v[1], v[2]);\n        break;\n\n      case MaterialUniformType.VEC4:\n        v = uniform.value as MaterialUniformValue<MaterialUniformType.VEC4>;\n        this.gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n        break;\n\n      case MaterialUniformType.VEC4_ARRAY:\n        v = uniform.value as MaterialUniformValue<\n          MaterialUniformType.VEC4_ARRAY\n        >;\n        this.gl.uniform4fv(location, flatten4(v));\n        break;\n\n      case MaterialUniformType.MATRIX3x3:\n        v = uniform.value as MaterialUniformValue<\n          MaterialUniformType.MATRIX3x3\n        >;\n        this.gl.uniformMatrix3fv(location, false, v);\n        break;\n\n      case MaterialUniformType.MATRIX4x4:\n        v = uniform.value as MaterialUniformValue<\n          MaterialUniformType.MATRIX4x4\n        >;\n        this.gl.uniformMatrix4fv(location, false, v);\n        break;\n\n      case MaterialUniformType.TEXTURE:\n        v = uniform.value as MaterialUniformValue<MaterialUniformType.TEXTURE>;\n        this.willUseTextureUnit(v, location);\n        break;\n\n      default:\n        console.warn(\n          this.debugContext,\n          \"A uniform specified an unrecognized type. It will not sync with the GPU:\",\n          uniform\n        );\n    }\n  }\n\n  /**\n   * This will consume the values aggregated within willUseTextureUnit. All Texture objects\n   * consumed will be assigned an active texture unit (if one was not already applied), then\n   * the Texture will be compiled / updated as necessary and applied to all uniforms requiring\n   * a Sampler unit.\n   */\n  applyUsedTextures() {\n    // Assign texture units to the textures that will be used\n    const failedTextures = this.assignTextureUnits(\n      Array.from(this._textureWillBeUsed.keys())\n    );\n\n    // We apply the default unit to each texture that failed. Output will be made from the\n    // previous method, so at this point, let's just try to make lemonade out of lemons (set\n    // sane defaults)\n    failedTextures.forEach(texture => {\n      if (texture.gl) {\n        texture.gl.textureUnit = this.gl.TEXTURE0;\n      } else {\n        texture.gl = {\n          textureId: null,\n          textureUnit: this.gl.TEXTURE0,\n          proxy: this.glProxy\n        };\n      }\n    });\n\n    // Let's sort out which textures are affiliated with a RenderTarget or with a uniform set.\n    const textureToUniforms = new Map<Texture, Set<WebGLUniformLocation>>();\n    const renderTargets = new Set<RenderTarget>();\n\n    this._textureWillBeUsed.forEach((targets, texture) => {\n      if (targets instanceof RenderTarget) {\n        renderTargets.add(targets);\n      } else {\n        textureToUniforms.set(texture, targets);\n      }\n    });\n\n    // Now our list of render targets is guaranteed to have their textures set with an active texture unit,\n    // so we can now officially ensure the render target is compiled.\n    renderTargets.forEach(target => {\n      const textures = target.getTextures();\n      const failed = textures.some(texture => {\n        // Only compile and process successful texture units\n        if (failedTextures.indexOf(texture) < 0) {\n          this.glProxy.updateTexture(texture);\n        } else return true;\n\n        return false;\n      });\n\n      if (!failed) {\n        this.glProxy.compileRenderTarget(target);\n      } else {\n        console.warn(\n          this.debugContext,\n          \"A RenderTarget can not be used because all of it's textures could not be compiled.\"\n        );\n      }\n    });\n\n    // Now that all of our textures have units, we loop through each texture and have them\n    // compiled and/or updated then upload the unit to the appropriate uniforms indicated.\n    textureToUniforms.forEach((uniforms, texture) => {\n      // Only compile and process successful texture units\n      if (failedTextures.indexOf(texture) < 0) {\n        this.glProxy.updateTexture(texture);\n\n        uniforms.forEach(uniform => {\n          this.uploadTextureToUniform(uniform, texture);\n        });\n      }\n\n      // Failed textures get their uniforms filled with the default 0 texture unit\n      else {\n        uniforms.forEach(uniform => {\n          this.gl.uniform1i(uniform, textureUnitToIndex(this.gl, 0));\n        });\n      }\n    });\n\n    // We used the textures! This is no longer needed\n    this._textureWillBeUsed.clear();\n\n    return true;\n  }\n\n  /**\n   * Attempts to assign free or freed texture units to the provided texture objects.\n   * This will return a list of textures\n   */\n  private assignTextureUnits(textures: Texture[]) {\n    const needsUnit: Texture[] = [];\n    const hasUnit: Texture[] = [];\n\n    // First establish all textures that need a unit\n    textures.forEach(texture => {\n      if (!texture.gl || texture.gl.textureUnit < 0) {\n        needsUnit.push(texture);\n      } else {\n        hasUnit.push(texture);\n      }\n    });\n\n    // We now first see if we have free units to statisfy the needs\n    while (this._freeUnits.length > 0 && needsUnit.length > 0) {\n      const texture = needsUnit.shift();\n      if (!texture) continue;\n\n      const freeUnit = this._freeUnits.shift();\n\n      if (freeUnit === undefined) {\n        needsUnit.unshift(texture);\n        continue;\n      }\n\n      if (!texture.gl) {\n        texture.gl = {\n          textureId: null,\n          textureUnit: freeUnit,\n          proxy: this.glProxy\n        };\n      } else {\n        texture.gl.textureUnit = freeUnit;\n      }\n\n      hasUnit.push(texture);\n    }\n\n    // If nothing needs a unit still, then we can just exit now\n    if (needsUnit.length <= 0) {\n      return needsUnit;\n    }\n\n    // We now get any remaining texture that still needs a unit. We will claim the unit\n    // of a texture using a unit but is NOT going to be used for the next call.\n    // If there are no units available in this manner, then we are officially using too many\n    // textures for the next draw call.\n    debug(\n      \"WARNING: Too many textures in use are causing texture units to be swapped. Doing this occasionally is fine, but handling this on a frame loop can have serious performance concerns.\"\n    );\n\n    // Get a list of texture units in use but are not required for next draw call\n    const inUse = new Map<Texture, boolean>();\n\n    this._textureUnitToTexture.forEach(texture => {\n      if (texture) {\n        inUse.set(texture, false);\n      }\n    });\n\n    hasUnit.forEach(texture => {\n      inUse.set(texture, true);\n    });\n\n    const canGiveUpUnit: Texture[] = [];\n\n    inUse.forEach((isUsed, texture) => {\n      if (!isUsed) canGiveUpUnit.push(texture);\n    });\n\n    // We should now have all textures able to give up their unit for the next draw call\n    if (canGiveUpUnit.length === 0) {\n      console.warn(\n        this.debugContext,\n        \"There are too many textures being used for a single draw call. These textures will not be utilized on the GPU\",\n        needsUnit\n      );\n      return needsUnit;\n    }\n\n    while (canGiveUpUnit.length > 0 && needsUnit.length > 0) {\n      const texture = needsUnit.shift();\n      if (!texture) continue;\n\n      const freeUnit = canGiveUpUnit.shift();\n\n      if (\n        freeUnit === undefined ||\n        !freeUnit.gl ||\n        freeUnit.gl.textureUnit < 0\n      ) {\n        needsUnit.unshift(texture);\n        continue;\n      }\n\n      if (!texture.gl) {\n        texture.gl = {\n          textureId: null,\n          textureUnit: freeUnit.gl.textureUnit,\n          proxy: this.glProxy\n        };\n      } else {\n        texture.gl.textureUnit = freeUnit.gl.textureUnit;\n      }\n\n      hasUnit.push(texture);\n    }\n\n    // If by some voodoo we still have not provided a unit for a texture needing it, then we have a problem\n    if (needsUnit.length > 0) {\n      console.warn(\n        this.debugContext,\n        \"There are too many textures being used for a single draw call. These textures will not be utilized on the GPU\",\n        needsUnit\n      );\n    }\n\n    return needsUnit;\n  }\n\n  /**\n   * Applies the necessary value for a texture to be applied to a sampler uniform.\n   */\n  private uploadTextureToUniform(\n    location: WebGLUniformLocation,\n    texture: Texture\n  ) {\n    if (texture.gl && texture.gl.textureUnit >= 0) {\n      this.gl.uniform1i(\n        location,\n        textureUnitToIndex(this.gl, texture.gl.textureUnit)\n      );\n    } else {\n      console.warn(\n        this.debugContext,\n        \"Attempted to set a Texture Object to a uniform, but the Texture object did not have a valid texture unit.\",\n        texture\n      );\n    }\n  }\n\n  /**\n   * This flags a texture as going to be used within the next upcoming draw call\n   */\n  willUseTextureUnit(\n    texture: Texture,\n    target: WebGLUniformLocation | RenderTarget\n  ) {\n    const uniforms = this._textureWillBeUsed.get(texture);\n\n    if (target instanceof RenderTarget) {\n      if (!uniforms) {\n        this._textureWillBeUsed.set(texture, target);\n      } else if (uniforms instanceof RenderTarget) {\n        if (uniforms !== target) {\n          console.warn(\n            this.debugContext,\n            \"A Texture is attempting to be used by two different render targets in a single draw.\"\n          );\n        }\n      }\n    } else {\n      if (!uniforms) {\n        this._textureWillBeUsed.set(texture, new Set([target]));\n      } else {\n        if (uniforms instanceof RenderTarget) {\n          console.warn(\n            this.debugContext,\n            \"A texture in a single draw is attempting to attach to a uniform AND a render target which is invalid.\"\n          );\n        } else {\n          uniforms.add(target);\n        }\n      }\n    }\n  }\n\n  /**\n   * This method applies ALL of the state elements monitored and force sets them with WebGL calls\n   * to make sure the GPU is in the same state as this state object.\n   */\n  syncState() {\n    const gl = this.gl;\n\n    this._blendingEnabled ? gl.enable(gl.BLEND) : gl.disable(gl.BLEND);\n    this._ditheringEnabled ? gl.enable(gl.DITHER) : gl.disable(gl.DITHER);\n    this._depthTestEnabled\n      ? gl.enable(gl.DEPTH_TEST)\n      : gl.disable(gl.DEPTH_TEST);\n    this._scissorTestEnabled\n      ? gl.enable(gl.SCISSOR_TEST)\n      : gl.disable(gl.SCISSOR_TEST);\n    this.setActiveTextureUnit(this._activeTextureUnit);\n    this.applyClearColor();\n    this.applyCullFace();\n    this.applyBlendFactors();\n    this.applyBlendEquation();\n    this.applyColorMask();\n    this.applyDepthFunc();\n    this.applyScissorBounds();\n    this.applyViewport();\n    gl.depthMask(this._depthMask);\n  }\n\n  /**\n   * Applies the current clearColor to the gl state\n   */\n  private applyClearColor() {\n    const gl = this.gl;\n\n    gl.clearColor(\n      this._clearColor[0],\n      this._clearColor[1],\n      this._clearColor[2],\n      this._clearColor[3]\n    );\n  }\n\n  /**\n   * Applies the current depth function to the gl state\n   */\n  private applyDepthFunc() {\n    const gl = this.gl;\n\n    switch (this._depthFunc) {\n      case GLSettings.Material.DepthFunctions.ALWAYS:\n        gl.depthFunc(gl.ALWAYS);\n        break;\n      case GLSettings.Material.DepthFunctions.EQUAL:\n        gl.depthFunc(gl.EQUAL);\n        break;\n      case GLSettings.Material.DepthFunctions.GREATER:\n        gl.depthFunc(gl.GREATER);\n        break;\n      case GLSettings.Material.DepthFunctions.GREATER_OR_EQUAL:\n        gl.depthFunc(gl.GEQUAL);\n        break;\n      case GLSettings.Material.DepthFunctions.LESS:\n        gl.depthFunc(gl.LESS);\n        break;\n      case GLSettings.Material.DepthFunctions.LESS_OR_EQUAL:\n        gl.depthFunc(gl.LEQUAL);\n        break;\n      case GLSettings.Material.DepthFunctions.NEVER:\n        gl.depthFunc(gl.NEVER);\n        break;\n      case GLSettings.Material.DepthFunctions.NOTEQUAL:\n        gl.depthFunc(gl.NOTEQUAL);\n        break;\n\n      default:\n        gl.depthFunc(gl.ALWAYS);\n        break;\n    }\n  }\n\n  /**\n   * Applies the current scissor bounds to the gl state\n   */\n  private applyScissorBounds() {\n    this.gl.scissor(\n      this._scissorBounds.x,\n      this._scissorBounds.y,\n      this._scissorBounds.width,\n      this._scissorBounds.height\n    );\n  }\n\n  /**\n   * Applies the writing mask to the color buffer to the gl state.\n   */\n  private applyColorMask() {\n    this.gl.colorMask(\n      this.colorMask[0] || false,\n      this.colorMask[1] || false,\n      this.colorMask[2] || false,\n      this.colorMask[3] || false\n    );\n  }\n\n  /**\n   * Applies the blending equations to the gl state\n   */\n  private applyBlendEquation() {\n    const gl = this.gl;\n\n    switch (this._blendEquation) {\n      case GLSettings.Material.BlendingEquations.Add:\n        gl.blendEquation(gl.FUNC_ADD);\n        break;\n      case GLSettings.Material.BlendingEquations.Subtract:\n        gl.blendEquation(gl.FUNC_SUBTRACT);\n        break;\n      case GLSettings.Material.BlendingEquations.ReverseSubtract:\n        gl.blendEquation(gl.FUNC_REVERSE_SUBTRACT);\n        break;\n      // case GLSettings.Material.BlendingEquations.Min: /** Requires extension for Webgl 1 */ break;\n      // case GLSettings.Material.BlendingEquations.Max: /** Requires extension for Webgl 1 */ break;\n    }\n  }\n\n  /**\n   * Applies the blending factors to the gl state\n   */\n  private applyBlendFactors() {\n    const gl = this.gl;\n    let dst, src;\n\n    switch (this._blendDstFactor) {\n      case GLSettings.Material.BlendingDstFactor.DstAlpha:\n        dst = gl.BLEND_DST_ALPHA;\n        break;\n      case GLSettings.Material.BlendingDstFactor.DstColor:\n        dst = gl.BLEND_DST_RGB;\n        break;\n      case GLSettings.Material.BlendingDstFactor.One:\n        dst = gl.ONE;\n        break;\n      case GLSettings.Material.BlendingDstFactor.OneMinusDstAlpha:\n        dst = gl.ONE_MINUS_DST_ALPHA;\n        break;\n      case GLSettings.Material.BlendingDstFactor.OneMinusDstColor:\n        dst = gl.ONE_MINUS_DST_COLOR;\n        break;\n      case GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha:\n        dst = gl.ONE_MINUS_SRC_ALPHA;\n        break;\n      case GLSettings.Material.BlendingDstFactor.OneMinusSrcColor:\n        dst = gl.ONE_MINUS_SRC_COLOR;\n        break;\n      case GLSettings.Material.BlendingDstFactor.SrcAlpha:\n        dst = gl.SRC_ALPHA;\n        break;\n      case GLSettings.Material.BlendingDstFactor.SrcColor:\n        dst = gl.SRC_COLOR;\n        break;\n      case GLSettings.Material.BlendingDstFactor.Zero:\n        dst = gl.ZERO;\n        break;\n\n      default:\n        dst = gl.ONE;\n        break;\n    }\n\n    switch (this._blendSrcFactor) {\n      case GLSettings.Material.BlendingDstFactor.DstAlpha:\n        src = gl.BLEND_DST_ALPHA;\n        break;\n      case GLSettings.Material.BlendingDstFactor.DstColor:\n        src = gl.BLEND_DST_RGB;\n        break;\n      case GLSettings.Material.BlendingDstFactor.One:\n        src = gl.ONE;\n        break;\n      case GLSettings.Material.BlendingDstFactor.OneMinusDstAlpha:\n        src = gl.ONE_MINUS_DST_ALPHA;\n        break;\n      case GLSettings.Material.BlendingDstFactor.OneMinusDstColor:\n        src = gl.ONE_MINUS_DST_COLOR;\n        break;\n      case GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha:\n        src = gl.ONE_MINUS_SRC_ALPHA;\n        break;\n      case GLSettings.Material.BlendingDstFactor.OneMinusSrcColor:\n        src = gl.ONE_MINUS_SRC_COLOR;\n        break;\n      case GLSettings.Material.BlendingDstFactor.SrcAlpha:\n        src = gl.SRC_ALPHA;\n        break;\n      case GLSettings.Material.BlendingDstFactor.SrcColor:\n        src = gl.SRC_COLOR;\n        break;\n      case GLSettings.Material.BlendingDstFactor.Zero:\n        src = gl.ZERO;\n        break;\n      case GLSettings.Material.BlendingSrcFactor.SrcAlphaSaturate:\n        src = gl.SRC_ALPHA_SATURATE;\n        break;\n\n      default:\n        src = gl.ONE;\n        break;\n    }\n\n    gl.blendFunc(src, dst);\n  }\n\n  /**\n   * Applies the cull face property to the gl state\n   */\n  private applyCullFace() {\n    const gl = this.gl;\n\n    if (this._cullFace !== GLSettings.Material.CullSide.NONE) {\n      gl.enable(gl.CULL_FACE);\n    }\n\n    switch (this._cullFace) {\n      case GLSettings.Material.CullSide.CW:\n        gl.frontFace(gl.CW);\n        gl.cullFace(gl.FRONT);\n        break;\n      case GLSettings.Material.CullSide.CCW:\n        gl.frontFace(gl.CCW);\n        gl.cullFace(gl.FRONT);\n        break;\n      case GLSettings.Material.CullSide.BOTH:\n        gl.frontFace(gl.CW);\n        gl.cullFace(gl.FRONT_AND_BACK);\n        break;\n\n      default:\n        gl.disable(gl.CULL_FACE);\n    }\n  }\n\n  /**\n   * This applies the current viewport property to the gl context\n   */\n  private applyViewport() {\n    this.gl.viewport(\n      this._viewport.x,\n      this._viewport.y,\n      this._viewport.width,\n      this._viewport.height\n    );\n  }\n}\n","import { uid } from \"../util/uid\";\nimport { GLProxy } from \"./gl-proxy\";\nimport { GLSettings } from \"./gl-settings\";\nimport { Texture } from \"./texture\";\n\n/**\n * These are the options available for creating a new RenderTarget.\n */\nexport interface IRenderTargetOptions {\n  /** Specifies the buffers the render target will render into when draw calls happen. */\n  buffers: {\n    /** The color buffer attachment. This allows multiple color buffers for MRT when available. */\n    color?:\n      | GLSettings.RenderTarget.ColorBufferFormat\n      | Texture\n      | (GLSettings.RenderTarget.ColorBufferFormat | Texture)[];\n    /** The depth buffer attachment. Exclusion automatically makes depth testing not work. */\n    depth?: GLSettings.RenderTarget.DepthBufferFormat | Texture;\n    /** The stencil buffer attachment. Exclusion automatically disables stencil testing. */\n    stencil?: GLSettings.RenderTarget.StencilBufferFormat | Texture;\n  };\n  /**\n   * The height of the render target. This is used when the textures are not dictating the width\n   * and the height. This is required if no Textures are specified as a buffer.\n   */\n  height?: number;\n  /**\n   * If set to true, then disposing this render target will NOT cause the targets that are textures to be disposed\n   * when this is disposed.\n   */\n  retainTextureTargets?: boolean;\n  /**\n   * The width of the render target. This is used when the textures are not dictating the width\n   * and the width. This is required if no Textures are specified as a buffer.\n   */\n  width?: number;\n}\n\n/**\n * This represents an FBO render target to be rendered into. This can manage several\n * targets at once for MRT (or within compatibility modes).\n *\n * DO NOT EDIT existing render targets after they are constructed. Just dispose of old targets\n * and create new ones.\n */\nexport class RenderTarget {\n  /** UID for the object */\n  get uid() {\n    return this._uid;\n  }\n  private _uid = uid();\n\n  /** The buffer settings utilized in rendering this target */\n  get buffers() {\n    return {\n      color: Array.isArray(this._buffers.color)\n        ? this._buffers.color.slice(0)\n        : this._buffers.color,\n      depth: this._buffers.depth,\n      stencil: this._buffers.stencil\n    };\n  }\n  private _buffers: IRenderTargetOptions[\"buffers\"];\n  /**\n   * The height of the render target. This is automatically set if any of the buffers are a Texture\n   * object. Otherwise, this reflects the value provided in the options.\n   */\n  get height() {\n    return this._height;\n  }\n  private _height: number;\n  /**\n   * The width of the render target. This is automatically set if any of the buffers are a Texture\n   * object. Otherwise, this reflects the value provided in the options.\n   */\n  get width() {\n    return this._width;\n  }\n  private _width: number;\n  /**\n   * This is a flag indicating if the render target passed it's frame buffer status check\n   */\n  get validFramebuffer() {\n    return this._validFramebuffer;\n  }\n  private _validFramebuffer: boolean = false;\n\n  /** Flag indicating whether or not to preserve render targets that are textures or not. */\n  retainTextureTargets: boolean = false;\n\n  /**\n   * Split buffers occur to handle compatibility problems with MRT (multi render targeting)\n   * If the system this is running on does not support MRT, then for every color buffer attachment\n   * requested, we need to create a split buffer that has a single color buffer for each color buffer\n   * provided.\n   *\n   * TODO: We have not implemented split render buffers yet.\n   */\n  get splitRenderBuffers() {\n    return this._splitRenderBuffers;\n  }\n  private _splitRenderBuffers: RenderTarget[] | null = null;\n\n  /**\n   * This contains gl state that is processed and identified for the render target.\n   * Modifying this outside of the framework is guaranteed to break something.\n   */\n  gl?: {\n    /** Identifier for the FBO object representing this target */\n    fboId: WebGLFramebuffer;\n    /** The color buffer(s) this target is rendering into */\n    colorBufferId?:\n      | WebGLRenderbuffer\n      | Texture\n      | (WebGLRenderbuffer | Texture)[];\n    /** The depth buffer this target is rendering into */\n    depthBufferId?: WebGLRenderbuffer | Texture;\n    /** The stencil buffer this target is rendering into */\n    stencilBufferId?: WebGLRenderbuffer | Texture;\n    /** The managing GL proxy of this target */\n    proxy: GLProxy;\n  };\n\n  constructor(options: IRenderTargetOptions) {\n    this._buffers = {\n      color: Array.isArray(options.buffers.color)\n        ? options.buffers.color.slice(0)\n        : options.buffers.color,\n      depth: options.buffers.depth,\n      stencil: options.buffers.stencil\n    };\n    this._width = options.width || 0;\n    this._height = options.height || 0;\n    this.retainTextureTargets = options.retainTextureTargets || false;\n    this.getDimensions();\n  }\n\n  /**\n   * Free all resources associated with this render target.\n   */\n  dispose() {\n    if (this.gl) {\n      this.gl.proxy.disposeRenderTarget(this);\n    }\n  }\n\n  /**\n   * This analyzes the buffers for Textures to infer the width and height. This\n   * also ensures all Texture objects are the same size to prevent errors.\n   */\n  private getDimensions() {\n    const textures: Texture[] = [];\n\n    if (this._buffers.color instanceof Texture) {\n      textures.push(this._buffers.color);\n    }\n\n    if (Array.isArray(this._buffers.color)) {\n      this._buffers.color.forEach(buffer => {\n        if (buffer instanceof Texture) {\n          textures.push(buffer);\n        }\n      });\n    }\n\n    if (this._buffers.depth instanceof Texture) {\n      textures.push(this._buffers.depth);\n    }\n\n    if (this._buffers.stencil instanceof Texture) {\n      textures.push(this._buffers.stencil);\n    }\n\n    if (textures.length > 0 && textures[0].data) {\n      const { width, height } = textures[0].data;\n\n      textures.forEach(texture => {\n        if (!texture.data) return;\n        const { width: checkWidth, height: checkHeight } = texture.data;\n\n        if (checkWidth !== width || checkHeight !== height) {\n          console.warn(\n            \"Texture applied to the render target is invalid as it does not match dimensions of all textures applied:\",\n            texture,\n            textures,\n            \"The texture will be removed as a target for the render target\"\n          );\n\n          this.removeTextureFromBuffer(texture);\n        }\n      });\n\n      this._width = width;\n      this._height = height;\n    } else if (!this._width || !this._height) {\n      console.warn(\n        \"A RenderTarget was not able to establish valid dimensions. This target had no texture buffers and did not specify valid width and height values.\",\n        this\n      );\n    }\n  }\n\n  /**\n   * Retrieves all of the textures associated with this render target\n   */\n  getTextures() {\n    const textures = [];\n\n    if (Array.isArray(this.buffers.color)) {\n      this.buffers.color.forEach(buffer => {\n        if (buffer instanceof Texture) {\n          textures.push(buffer);\n        }\n      });\n    } else {\n      if (this.buffers.color instanceof Texture) {\n        textures.push(this.buffers.color);\n      }\n    }\n\n    if (this.buffers.depth instanceof Texture) {\n      textures.push(this.buffers.depth);\n    }\n\n    if (this.buffers.stencil instanceof Texture) {\n      textures.push(this.buffers.stencil);\n    }\n\n    return textures;\n  }\n\n  /**\n   * Cleanses a texture from being used as a buffer\n   */\n  private removeTextureFromBuffer(texture: Texture) {\n    if (Array.isArray(this._buffers.color)) {\n      const index = this._buffers.color.indexOf(texture);\n      if (index > -1) this._buffers.color.splice(index, 1);\n    } else if (this._buffers.color === texture) {\n      delete this._buffers.color;\n    }\n\n    if (this._buffers.depth === texture) {\n      delete this._buffers.depth;\n    }\n\n    if (this._buffers.stencil === texture) {\n      delete this._buffers.stencil;\n    }\n  }\n\n  /**\n   * Changes the size of this render target. This is a VERY costly operation.\n   * It will delete all existing buffers associated with this target. Change the intended\n   * size of each buffer / texture, then cause the buffer / texture to get recreated with\n   * the new size settings.\n   *\n   * This operation clears any existing texture contents that may have existed.\n   */\n  setSize(width: number, height: number) {\n    // Delete all previous GL content\n    this.dispose();\n    // Set our new width and height desires\n    this._width = width;\n    this._height = height;\n    // Adjust all of the texture objects data to size properly\n    const textures = this.getTextures();\n\n    textures.forEach(texture => {\n      texture.data = {\n        buffer: null,\n        height,\n        width\n      };\n    });\n  }\n\n  /**\n   * Flags this render target as having a valid framebuffer for rendering.\n   */\n  setAsValid() {\n    this._validFramebuffer = true;\n  }\n}\n","import { Model } from \"./model\";\n\n/**\n * This is an object that contains a list of buffers and state for those buffers to\n * be rendered together.\n */\nexport class Scene {\n  /** The models this scene will render. They will be rendered in the order they were insertted */\n  models = new Set<Model>();\n\n  /**\n   * Add a model to be rendered within the scene\n   */\n  add(model: Model) {\n    this.models.add(model);\n  }\n\n  /**\n   * Remove a model from the scene\n   */\n  remove(model: Model) {\n    this.models.delete(model);\n  }\n}\n","import { Vec4 } from \"../math\";\nimport { Size } from \"../types\";\nimport { Attribute } from \"./attribute\";\nimport { Geometry } from \"./geometry\";\nimport { GLProxy } from \"./gl-proxy\";\nimport { GLState } from \"./gl-state\";\nimport { Model } from \"./model\";\nimport { RenderTarget } from \"./render-target\";\nimport { Scene } from \"./scene\";\nimport { WebGLStat } from \"./webgl-stat\";\n\n/**\n * Options used to create or update the renderer.\n */\nexport interface IWebGLRendererOptions {\n  /**\n   * Determines if the rendering context renders to a buffer with an alpha channel.\n   * Performs better if no alpha channel is used, but may be needed if any DOM elements or\n   * backgrounds needs to bleed through the canvas.\n   */\n  alpha?: boolean;\n  /**\n   * Set to true to use the system antialiasing set up. Performs much better when false, but definitely\n   * looks better when true.\n   */\n  antialias?: boolean;\n  /**\n   * This is the canvas that is required to retrieve the webgl context to make all webgl calls with.\n   */\n  canvas: HTMLCanvasElement;\n  /**\n   * This needs to be true in order to query the canvas current rendered output. Performs better when false,\n   * but some cases may need it to do such operations like snapshots etc.\n   */\n  preserveDrawingBuffer?: boolean;\n  /**\n   * Set to true to make the default context expect premultipled alpha for blending.\n   */\n  premultipliedAlpha?: boolean;\n\n  /**\n   * Callback indicating a context could not be generated.\n   */\n  onNoContext?(): void;\n}\n\n/**\n * Internal state of the renderer.\n */\nexport interface IWebGLRendererState {\n  /** Sets up a clear mask to ensure the clear operation only happens once per draw */\n  clearMask: [boolean, boolean, boolean];\n  /** Stores which render target is in focus for the current operations on the renderer */\n  currentRenderTarget: RenderTarget | null;\n  /** The current display size of the canvas */\n  displaySize: Size;\n  /** The current pixel ratio in use */\n  pixelRatio: number;\n  /** The current rendering size of the canvas */\n  renderSize: Size;\n}\n\n/**\n * This is the primary file where the rendering and compositing resources and managing\n * gl state happens. A context is provided for the renderer to work with, then it is the\n * renderer's job to ensure state changes as expected and provide as much convenience as necessary\n * to make working with the webgl pipeline as easy as possible.\n */\nexport class WebGLRenderer {\n  /** When this is set this creates */\n  set debugContext(val: string) {\n    if (this.glProxy) this.glProxy.debugContext = val;\n    if (this.glState) this.glState.debugContext = val;\n  }\n\n  /** The context the renderer is managing */\n  private _gl?: WebGLRenderingContext;\n  /** The readonly gl context the renderer determined for use */\n  get gl() {\n    return this._gl;\n  }\n  /** This is the compiler that performs all actions related to creating and updating buffers and objects on the GPU */\n  glProxy: GLProxy;\n  /** This handles anything related to state changes in the GL state */\n  glState: GLState;\n  /** The options that constructed or are currently applied to the renderer */\n  options: IWebGLRendererOptions;\n\n  /** Any current internal state the renderer has applied to it's target */\n  state: IWebGLRendererState = {\n    clearMask: [false, false, false],\n    currentRenderTarget: null,\n    displaySize: [1, 1],\n    pixelRatio: 1,\n    renderSize: [1, 1]\n  };\n\n  constructor(options: IWebGLRendererOptions) {\n    // Assign defaults to our options\n    this.options = Object.assign(\n      {\n        alpha: false,\n        antialias: false,\n        preserveDrawingBuffer: false\n      },\n      options\n    );\n\n    // Make sure we are provided a canvas to work with\n    if (!this.options.canvas) {\n      console.warn(\"WebGLRenderer ERROR: A canvas is REQUIRED as a parameter.\");\n    }\n\n    // Initialize context for the renderer\n    this.getContext();\n  }\n\n  /**\n   * Clears the specified buffers.\n   */\n  clear(color?: boolean, depth?: boolean, stencil?: boolean) {\n    const clear = this.state.clearMask;\n\n    this.state.clearMask = [\n      clear[0] || color || false,\n      clear[1] || depth || false,\n      clear[2] || stencil || false\n    ];\n  }\n\n  /**\n   * Clears the color either set with setClearColor, or clears the color specified.\n   */\n  clearColor(color?: Vec4) {\n    if (color) {\n      this.glState.setClearColor(color);\n    }\n  }\n\n  /**\n   * Free all resources this renderer utilized. Make sure textures and frame/render/geometry\n   * buffers are all deleted. We may even use aggressive buffer removal that force resizes the buffers\n   * so their resources are immediately reduced instead of waiting for the JS engine to free up resources.\n   */\n  dispose() {\n    // TODO\n  }\n\n  /**\n   * Retrieve and establish the context from the canvas.\n   */\n  getContext() {\n    if (this._gl) return this._gl;\n\n    const gl = GLProxy.getContext(this.options.canvas, {\n      alpha: this.options.alpha || false,\n      antialias: this.options.antialias || false,\n      premultipliedAlpha: this.options.premultipliedAlpha || false,\n      preserveDrawingBuffer: this.options.preserveDrawingBuffer || false\n    });\n\n    if (gl.context) {\n      this._gl = gl.context;\n      this.glState = new GLState(gl.context, gl.extensions);\n      this.glProxy = new GLProxy(gl.context, this.glState, gl.extensions);\n      this.glState.setProxy(this.glProxy);\n\n      // Make sure our GPU is synced with our default state\n      this.glState.syncState();\n    } else if (this.options.onNoContext) {\n      this.options.onNoContext();\n    } else {\n      console.warn(\n        \"No context was able to be produced, and the handler onNoContext was not implemented for such cases.\"\n      );\n    }\n\n    return this._gl;\n  }\n\n  /**\n   * Retrieves the size of the canvas ignoring pixel ratio.\n   */\n  getDisplaySize(): Size {\n    return this.state.displaySize;\n  }\n\n  /**\n   * Retrieves the current pixel ratio in use for the context.\n   */\n  getPixelRatio() {\n    return this.state.pixelRatio;\n  }\n\n  /**\n   * Retrieves the size of the rendering context. This is the pixel dimensions\n   * of what is being rendered into.\n   */\n  getRenderSize(): Size {\n    return this.state.renderSize;\n  }\n\n  /**\n   * Returns the full viewport for the current target.\n   *\n   * If a RenderTarget is not set, then this returns the viewport of the canvas ignoring\n   * the current pixel ratio.\n   */\n  getFullViewport() {\n    const target = this.state.currentRenderTarget;\n\n    if (target) {\n      return {\n        x: 0,\n        y: 0,\n        width: target.width,\n        height: target.height\n      };\n    } else {\n      const size = this.getRenderSize();\n\n      return {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      };\n    }\n  }\n\n  /**\n   * Prepares the specified attribute\n   */\n  prepareAttribute(geometry: Geometry, attribute: Attribute, name: string) {\n    // If we successfully update/compile the attribute, then we enable it's vertex array\n    if (this.glProxy.updateAttribute(attribute)) {\n      this.glProxy.useAttribute(name, attribute, geometry);\n    }\n\n    // Otherwise, we flag this as invalid geometry so we don't cause errors or undefined\n    // behavior while rendering\n    else {\n      console.warn(\"Could not update attribute\", attribute);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Renders the Scene specified\n   */\n  render(scene: Scene, target: RenderTarget | null = null) {\n    // Context must be established to render\n    if (!this.gl) return;\n\n    // Establish the rendering state we're in right now\n    this.setRenderTarget(target);\n\n    // Apply the last clear mask provided for the render\n    const clear = this.state.clearMask;\n    if (clear[0] || clear[1] || clear[2]) {\n      this.glProxy.clear(clear[0], clear[1], clear[2]);\n      this.state.clearMask = [false, false, false];\n    }\n\n    // If the fbo is not ready, we're not drawing\n    if (target && !target.gl) {\n      console.warn(\n        \"FBO is not ready for drawing. Skipping the rendering of the scene and target:\",\n        { scene, target }\n      );\n      return;\n    }\n\n    // We'll remove any models that have errored from the scene\n    const toRemove: Model[] = [];\n    // Loop through all of the models of the scene and process them for rendering\n    scene.models.forEach((model: Model) => {\n      this.renderModel(model, toRemove);\n    });\n\n    // Clear out any failed models from the scene\n    toRemove.forEach(model => {\n      scene.remove(model);\n    });\n  }\n\n  /**\n   * Renders the specified model\n   */\n  private renderModel(model: Model, toRemove: Model[]) {\n    const geometry = model.geometry;\n    const material = model.material;\n\n    // Let's put the material's program in use first so we can have the attribute information\n    // available to us.\n    if (this.glState.useMaterial(material)) {\n      let geometryIsValid = true;\n\n      // Faster to use defined functions rather than closures for loops\n      const attributeLoop = function(attribute: Attribute, name: string) {\n        geometryIsValid =\n          this.prepareAttribute(geometry, attribute, name) && geometryIsValid;\n      };\n\n      // First update/compile all aspects of the geometry\n      geometry.attributes.forEach(attributeLoop, this);\n      // Now all of our attributes are established, we must make sure our vertex arrays are cleaned up\n      this.glState.applyVertexAttributeArrays();\n\n      // If all of the attribute updates passed correctly, then we can use the established state\n      // to make our draw call\n      if (geometryIsValid) {\n        this.glProxy.draw(model);\n      } else {\n        console.warn(\n          \"Geometry was unable to update correctly, thus we are skipping the drawing of\",\n          model\n        );\n\n        toRemove.push(model);\n      }\n    } else {\n      console.warn(\n        \"Could not utilize material. Skipping draw call for:\",\n        material,\n        geometry\n      );\n\n      toRemove.push(model);\n    }\n  }\n\n  /**\n   * Reads the pixels from the current Render Target (or more specifically from the current framebuffer)\n   *\n   * By default the viewport is set based on the canvas being rendered into. Include a render target\n   * to make the viewport be applied with the target considered rather than needing pixel density considerations.\n   */\n  readPixels(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    out: ArrayBufferView\n  ) {\n    if (!this.gl) return;\n    const target = this.state.currentRenderTarget;\n    let canRead = true;\n    if (target) canRead = target.validFramebuffer;\n\n    if (!canRead) {\n      console.warn(\n        \"Framebuffer is incomplete. Can not read pixels at this time.\"\n      );\n      return;\n    }\n\n    x = Math.max(0, x);\n    y = Math.max(0, y);\n\n    if (target) {\n      if (x + width > target.width) width = target.width - x;\n      if (y + height > target.height) height = target.height - y;\n      const _height = target.height;\n\n      this.gl.readPixels(\n        x,\n        _height - y - height,\n        width,\n        height,\n        this.gl.RGBA,\n        this.gl.UNSIGNED_BYTE,\n        out\n      );\n    } else {\n      const size = this.getRenderSize();\n      const _height = size[1];\n\n      if (x + width > size[0]) width = size[0] - x;\n      if (y + height > size[1]) height = size[1] - y;\n\n      this.gl.readPixels(\n        x,\n        _height - y - height,\n        width,\n        height,\n        this.gl.RGBA,\n        this.gl.UNSIGNED_BYTE,\n        out\n      );\n    }\n  }\n\n  /**\n   * Sets the clear color to be used when the clear operation executes.\n   */\n  setClearColor(color: Vec4) {\n    this.glState.setClearColor(color);\n  }\n\n  /**\n   * Applies a given ratio for the provided canvas context.\n   */\n  setPixelRatio(ratio: number) {\n    const { canvas } = this.options;\n    const size = this.getDisplaySize();\n\n    canvas.width = size[0] * ratio;\n    canvas.height = size[1] * ratio;\n\n    this.state.pixelRatio = ratio;\n  }\n\n  /**\n   * Sets the region the scissor test will accept as visible. Anything outside the region\n   * will be clipped.\n   *\n   * By default the scissor region is set based on the canvas being rendered into. Include a render target\n   * to make the scissor region be applied with the target considered rather than needing pixel density considerations.\n   */\n  setScissor(\n    bounds?: { x: number; y: number; width: number; height: number },\n    target?: RenderTarget\n  ) {\n    target = target || this.state.currentRenderTarget || undefined;\n\n    if (target) {\n      const _height = target.height;\n\n      if (bounds) {\n        const { x, y, width, height } = bounds;\n        // Apply the viewport in a fashion that is more web dev friendly where top left is 0, 0\n        this.glState.setScissor({ x, y: _height - y - height, width, height });\n      } else {\n        this.glState.setScissor(null);\n      }\n    } else {\n      const { renderSize } = this.state;\n      const _height = renderSize[1];\n\n      if (bounds) {\n        const { x, y, width, height } = bounds;\n        this.glState.setScissor({\n          x: x,\n          y: _height - y - height,\n          width: width,\n          height: height\n        });\n      } else {\n        this.glState.setScissor(null);\n      }\n    }\n  }\n\n  /**\n   * Resizes the render area to the specified amount.\n   */\n  setSize(width: number, height: number) {\n    const { canvas } = this.options;\n    const { pixelRatio } = this.state;\n\n    // Set the rendering width and height of the canvas to the screen's resolution for maximum sharpness\n    // but it must be limited by the max texture size the hardware supports\n    canvas.width = Math.min(width * pixelRatio, WebGLStat.MAX_TEXTURE_SIZE);\n    canvas.height = Math.min(height * pixelRatio, WebGLStat.MAX_TEXTURE_SIZE);\n\n    // Scale the canvas to fit the desired width and height\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n\n    this.state.renderSize = [canvas.width, canvas.height];\n    this.state.displaySize = [width, height];\n  }\n\n  /**\n   * This sets the context to render into the indicated target\n   */\n  setRenderTarget(target: RenderTarget | null) {\n    // Don't need to do anything forsame render targets\n    if (this.state.currentRenderTarget === target) return;\n\n    if (!this.glState.useRenderTarget(target) && target) {\n      // If unable to use yet, this indicates the FBO needs to be compiled\n      // Probably due to uncompiled texture objects that the FBO needs.\n      // First flag all textures as needing a texture unit\n      target.getTextures().forEach(texture => {\n        this.glState.willUseTextureUnit(texture, target);\n      });\n\n      // Now apply those textures (compile them while utilizing the texture units requested)\n      // This will also trigger the compilation of the target since the textures used\n      // This will also ensure the FBO is in use for the next draw call\n      this.glState.applyUsedTextures();\n\n      // Compile the render target then use if successful\n      if (this.glProxy.compileRenderTarget(target)) {\n        this.glState.useRenderTarget(target);\n      }\n    }\n\n    // Set this as the current render target for the renderer\n    this.state.currentRenderTarget = target;\n  }\n\n  /**\n   * Sets the viewport we render into.\n   *\n   * By default the viewport is set based on the canvas being rendered into. Include a render target\n   * to make the viewport be applied with the target considered rather than needing pixel density considerations.\n   */\n  setViewport(bounds: { x: number; y: number; width: number; height: number }) {\n    const target = this.state.currentRenderTarget;\n    const { x, y, width, height } = bounds;\n\n    if (target) {\n      const _height = target.height;\n\n      // Apply the viewport in a fashion that is more web dev friendly where top left is 0, 0\n      this.glState.setViewport(x, _height - y - height, width, height);\n    } else {\n      const { renderSize } = this.state;\n      const _height = renderSize[1];\n\n      // Apply the viewport in a fashion that is more web dev friendly where top left is 0, 0\n      this.glState.setViewport(x, _height - y - height, width, height);\n    }\n  }\n}\n","import { AbsolutePosition } from \"../../math/primitives/absolute-position\";\nimport { Camera, CameraProjectionType } from \"../../util/camera\";\n\nexport interface IDefaultElements {\n  /** Default chartting camera */\n  camera: Camera;\n  /** The default viewport that encompasses the entire canvas */\n  viewport: AbsolutePosition;\n}\n\n/**\n * This generates all of the cameras/views/scenes necessary for default viewing of elements.\n *\n * These defaults are required to ensure the following:\n *\n * - Orthographic view\n * - top left corner of the canvas is 0,0\n * - y axis is +y downward\n * - entire canvas is the viewport.\n */\nexport function generateDefaultElements(\n  context: WebGLRenderingContext\n): IDefaultElements {\n  // Generate a default view camera that is\n  // - Orthographic\n  // - (0, 0) is the top left of the canvas\n  // - the y axis is +y going downward\n  const height = context.canvas.height;\n  const width = context.canvas.width;\n  const aspectRatio = width / height;\n\n  const viewport = {\n    aspectRatio: aspectRatio,\n    bottom: -height / 2,\n    far: 10000000,\n    left: -width / 2,\n    near: -100,\n    right: width / 2,\n    top: height / 2,\n    viewSize: height\n  };\n\n  const defaultCamera = new Camera({\n    type: CameraProjectionType.ORTHOGRAPHIC,\n    left: viewport.left,\n    right: viewport.right,\n    top: viewport.top,\n    bottom: viewport.bottom,\n    near: viewport.near,\n    far: viewport.far\n  });\n\n  defaultCamera.scale = [1.0, -1.0, 1.0];\n  defaultCamera.position = [0.0, 0.0, -300.0];\n  defaultCamera.update();\n\n  // This is a viewport that covers the entire context\n  const defaultViewport = {\n    bottom: 0,\n    left: 0,\n    right: 0,\n    top: 0\n  };\n\n  return {\n    camera: defaultCamera,\n    viewport: defaultViewport\n  };\n}\n","import { Attribute } from \"../../gl\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport { MetricsProcessing } from \"../../shaders/processing/metrics-processing\";\nimport { ILayerProps, Layer } from \"../../surface/layer\";\nimport {\n  IInstanceAttribute,\n  IInstancingUniform,\n  IUniform,\n  IVertexAttribute,\n  ShaderInjectionTarget\n} from \"../../types\";\n\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * The result of an injection into the header of a shader. Allows for injection content into the header\n * and provide extra Shader IO such as uniforms and attributes.\n */\nexport type ShaderIOHeaderInjectionResult = {\n  /** The content to inject into the shader */\n  injection: string;\n  /** Additional geometry changes possibly caused by the header injection */\n  geometry?: {\n    attributes: { [key: string]: Attribute };\n  };\n  /** Additional material changes possibly caused by the header injection changes */\n  material?: {\n    uniforms: IInstancingUniform[];\n  };\n};\n\nexport type ShaderDeclarationStatements = Map<string, string>;\n\n/**\n * This is the basis to allow the system to have additional shader injection capabilities.\n * This will cover an object or manager that wishes to inject elements into the header of the\n * shader and inject elements after attribute destructuring.\n */\nexport abstract class BaseShaderIOInjection {\n  /**\n   * This is a helper to apply declarations to the input declaration object. This will automatically use the\n   * performance debug output to provide useful information when overrides occur.\n   */\n  setDeclaration(\n    declarations: ShaderDeclarationStatements,\n    key: string,\n    value: string,\n    debugMessageCtx?: string\n  ) {\n    if (declarations.get(key)) {\n      debug(\n        \"%s: Overriding declaration %s\\nSetting new value: %s\",\n        debugMessageCtx || \"Expand IO Declarations\",\n        key,\n        value\n      );\n    }\n\n    declarations.set(key, value);\n  }\n\n  /**\n   * This allows for injection into the header of the shader.\n   *\n   * The order these controllers are injected\n   * into the system determines the order the contents are written to the header. So dependent injections\n   * must be sorted appropriately.\n   *\n   * @param target Specifies which shader type we should be writing the header for. Will be FS OR VS not ALL.\n   * @param declarations This is where the output should register declarations so the system can composite them together.\n   *                     This allows for IO Injections to override each other on declared names and help them set up expectations\n   *                     amongst each other for shader output.\n   * @param layer The layer that is currently being processed\n   * @param metrics Some metrics processed that are useful for making decisions about buffering strategies etc.\n   */\n  abstract processHeaderInjection(\n    target: ShaderInjectionTarget,\n    declarations: ShaderDeclarationStatements,\n    layer: Layer<Instance, ILayerProps<Instance>>,\n    metrics: MetricsProcessing,\n    vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<Instance>[],\n    uniforms: IUniform[]\n  ): ShaderIOHeaderInjectionResult;\n\n  /**\n   * This allows for injection into the shader AFTER attribute destructuring has taken place.\n   *\n   * The order these controllers are injected\n   * into the system determines the order the contents are written to the header. So dependent injections\n   * must be sorted appropriately.\n   *\n   * @param layer The layer that is currently being processed\n   * @param declarations This is where the output should register declarations so the system can composite them together.\n   *                     This allows for IO Injections to override each other on declared names and help them set up expectations\n   *                     amongst each other for shader output.\n   * @param metrics Some metrics processed that are useful for making decisions about buffering strategies etc.\n   */\n  abstract processAttributeDestructuring(\n    layer: Layer<Instance, ILayerProps<Instance>>,\n    declarations: ShaderDeclarationStatements,\n    metrics: MetricsProcessing,\n    vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<Instance>[],\n    uniforms: IUniform[]\n  ): string;\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport { ILayerProps, Layer } from \"../../surface/layer\";\nimport {\n  IInstanceAttribute,\n  IUniform,\n  IVertexAttribute,\n  Omit,\n  ShaderInjectionTarget\n} from \"../../types\";\n\n/** This is the message used when a module unit is attempted to be modified after it has been locked down */\nconst LOCKED_MODULE_UNIT_MESSAGE =\n  \"Once a ShaderModuleUnit has been registered, you CAN NOT modify it! Module ID:\";\n\n/** Options for the constructor for a new ShaderModuleUnit */\nexport type ShaderModuleUnitOptions = Omit<Partial<ShaderModuleUnit>, \"lock\">;\n\n/**\n * This is a module unit that can be registered as a ShaderModule which the system will use to resolve\n * imports within a shader.\n */\nexport class ShaderModuleUnit {\n  private _isLocked: boolean;\n  private _content: string;\n  private _compatibility: ShaderInjectionTarget;\n  private _moduleId: string;\n  private _dependents: string[] | null = null;\n\n  /**\n   * This is the content that replaces shader imports\n   */\n  get content(): string {\n    return this._content;\n  }\n  set content(val: string) {\n    if (this._isLocked) {\n      console.warn(LOCKED_MODULE_UNIT_MESSAGE, this._moduleId);\n      return;\n    }\n\n    this._content = val;\n  }\n\n  /**\n   * This defines which shader type the content is compatible with. You can only have one content assigned\n   * per each ShaderInjectionTarget type. Thus you can have a module such as 'picking' with two unique implementations\n   * one for Fragment and one for Vertex shaders. Or you can assign it to both.\n   */\n  get compatibility(): ShaderInjectionTarget {\n    return this._compatibility;\n  }\n  set compatibility(val: ShaderInjectionTarget) {\n    if (this._isLocked) {\n      console.warn(LOCKED_MODULE_UNIT_MESSAGE, this._moduleId);\n      return;\n    }\n\n    this._compatibility = val;\n  }\n\n  /**\n   * This is the list of module id dependents this unit will need. We store\n   * this here so the module can be analyzed once. Import statements will be stripped and the sub module contents will\n   * be added to the top of the contents of the shader. This only stores ids, as the ids will still need to be analyzed\n   * so duplication can be prevented.\n   */\n  get dependents(): string[] | null {\n    return this._dependents;\n  }\n  set dependents(val: string[] | null) {\n    // If this has been locked AND the dependents have been established then dependents can not be\n    // adjusted.\n    if (this._isLocked && this._dependents !== null) {\n      console.warn(LOCKED_MODULE_UNIT_MESSAGE, this._moduleId);\n      return;\n    }\n\n    this._dependents = val;\n  }\n\n  /**\n   * Method for the unit to provide instance attributes for the module\n   */\n  instanceAttributes?<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>\n  ): IInstanceAttribute<T>[];\n\n  /**\n   * Indicates this unit cannot be modified anymore.\n   */\n  isLocked() {\n    return this._isLocked;\n  }\n\n  /**\n   * Allows a module to prevent overrides by another module using the same moduleId.\n   * Attempted overrides will throw warnings.\n   */\n  isFinal?: boolean;\n  /** This is the string ID a shader must use to include the provided content. */\n  get moduleId(): string {\n    return this._moduleId;\n  }\n  set moduleId(val: string) {\n    if (this._isLocked) {\n      console.warn(LOCKED_MODULE_UNIT_MESSAGE, this._moduleId);\n      return;\n    }\n\n    this._moduleId = val;\n  }\n\n  /**\n   * Method so the unit can provide uniforms for the module.\n   */\n  uniforms?<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>\n  ): IUniform[];\n\n  /**\n   * Method so the unit can provide vertex attributes for the module.\n   */\n  vertexAttributes?<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>\n  ): IVertexAttribute[];\n\n  /**\n   * Default ctor for creating a new Shader Module Unit to be registered with the system.\n   */\n  constructor(options: ShaderModuleUnitOptions) {\n    Object.assign(this, options);\n  }\n\n  /**\n   * Applies the content after it's been processed for import statements. You can not set the content this way\n   * again after processing has happened.\n   */\n  applyAnalyzedContent(content: string) {\n    if (this._isLocked && this.dependents !== null) {\n      console.warn(LOCKED_MODULE_UNIT_MESSAGE, this._moduleId);\n      return;\n    }\n\n    this._content = content;\n  }\n\n  /**\n   * Makes this unit unable to be modified in anyway\n   */\n  lock() {\n    this._isLocked = true;\n  }\n}\n","import { ShaderInjectionTarget } from \"../../types\";\nimport { shaderTemplate } from \"../../util\";\nimport {\n  ShaderModuleUnit,\n  ShaderModuleUnitOptions\n} from \"./shader-module-unit\";\n\nconst debug = require(\"debug\")(\"performance\");\nconst debugModuleVS = require(\"debug\")(\"shader-module-vs\");\nconst debugModuleFS = require(\"debug\")(\"shader-module-fs\");\n\n/**\n * This is the results expected from a compile() operation from the ShaderModule.\n */\nexport interface IShaderCompileResults {\n  /** Error messages generated from analyzing the shaders */\n  errors: string[];\n  /** The generated shader from analyzing the module */\n  shader: string | null;\n  /** The shader module units discovered during the processing of the module */\n  shaderModuleUnits: Set<ShaderModuleUnit>;\n}\n\n/**\n * The partial token that must be matched to indicate an import statement.\n * (Must be the first non-whitespace word found in the token)\n */\nconst IMPORT_TOKEN = \"import\";\n/**\n * This is a delimiter between the import token and the identifying import id value\n * provided. This must be the next non-whitespace character found after the import token.\n *\n * We allow whitespace between the token and it's delimiter to allow for style preference\n *\n * import: id\n * import:id\n * import : id\n *\n * etc.\n */\nconst IMPORT_DELIMITER = \":\";\n\n/**\n * Tests to see if a ShaderModuleUnit is compatible with a provided Shader Target\n */\nfunction isUnitCompatible(\n  unit: ShaderModuleUnit,\n  target: ShaderInjectionTarget\n) {\n  return (\n    Boolean(unit) &&\n    (unit.compatibility === target ||\n      unit.compatibility === ShaderInjectionTarget.ALL)\n  );\n}\n\n/**\n * This file defines modules for shaders. Shader modules are global to the window context.\n */\nexport class ShaderModule {\n  /** These are all of the currently registered modules for the Shader Modules */\n  static modules = new Map<\n    string,\n    { fs?: ShaderModuleUnit; vs?: ShaderModuleUnit }\n  >();\n\n  /**\n   * This registers a new ShaderModuleUnit. It makes the module available by it's importId within shaders\n   * using this framework.\n   *\n   * If the module is registered with no returned output, the registration was a success. Any returned output\n   * indicates issues encountered while registering the module.\n   */\n  static register(\n    unit: ShaderModuleUnit | ShaderModuleUnitOptions | ShaderModuleUnitOptions[]\n  ): string | null {\n    // If the input is just Shader Module Unit options injected, then we simply handle wrapping\n    // the options into a ShaderModuleUnit and do a registration.\n    if (!(unit instanceof ShaderModuleUnit)) {\n      if (Array.isArray(unit)) {\n        let out = \"\";\n\n        unit.forEach(options => {\n          const output = ShaderModule.register(options);\n          if (output) out += `${output}\\n`;\n        });\n\n        // If there was no output at any time, let's be sure to return a simple null\n        if (!out) {\n          return null;\n        }\n\n        return out;\n      }\n\n      return ShaderModule.register(new ShaderModuleUnit(unit));\n    }\n\n    let current = ShaderModule.modules.get(unit.moduleId);\n\n    if (!current) {\n      current = {};\n      ShaderModule.modules.set(unit.moduleId, current);\n    }\n\n    const fs = current.fs;\n    const vs = current.vs;\n    const isFSCompatible = isUnitCompatible(\n      unit,\n      ShaderInjectionTarget.FRAGMENT\n    );\n    const isVSCompatible = isUnitCompatible(unit, ShaderInjectionTarget.VERTEX);\n\n    if (fs && isFSCompatible) {\n      if (fs.isFinal) {\n        return `Module ID: ${unit.moduleId} Can not override the module's existing Fragment registration as the exisitng module is marked as final`;\n      }\n\n      debug(\n        \"A Shader Module Unit has overridden an existing module for the Fragment Shader Module ID: %o\",\n        unit.moduleId\n      );\n    }\n\n    if (vs && isVSCompatible) {\n      if (vs.isFinal) {\n        return `Module ID: ${unit.moduleId} Can not override the module's existing Vertex registration as the exisitng module is marked as final`;\n      }\n\n      debug(\n        \"A Shader Module Unit has overridden an existing module for the Vertex Shader Module ID: %o\",\n        unit.moduleId\n      );\n    }\n\n    // Register the module as it passed all scrutiny by this point\n    if (isFSCompatible) {\n      current.fs = unit;\n    }\n\n    if (isVSCompatible) {\n      current.vs = unit;\n    }\n\n    // Lock the unit down indicating it can no longer be modified ever again.\n    unit.lock();\n\n    return null;\n  }\n\n  /**\n   * This gathers all of the dependents for the module as ids. This also causes the contents of the module to\n   * be stripped of it's import statements.\n   */\n  static analyzeDependents(unit: ShaderModuleUnit) {\n    // If the dependents are already established for this unit and it can not be modified further,\n    // then we do not bother to analyze the dependents again.\n    if (unit.dependents && unit.isLocked) {\n      return [];\n    }\n\n    // Gathers error messages found while processing the module\n    const errors: string[] = [];\n    // Stores the dependents in the order they are found in the module\n    const dependents: string[] = [];\n    // Stores all of the unique dependents found for this module\n    const dependentSet = new Set<string>();\n    // Get then compatibility target of the module unit so we can properly see what modules are available\n    // to the unit and what is not.\n    const target = unit.compatibility;\n    // This is the identifier of the module requesting it's dependents\n    const id = unit.moduleId;\n\n    // Here we process the module contents and look for additional import statements.\n    const templateResults = shaderTemplate({\n      // We do not want any direct replacement options, we will handle token analyzing\n      // via our onToken callback so we can find our special \"import:\" case\n      options: {},\n      // Provide the shader to our template processor\n      shader: unit.content,\n\n      // We do not want to remove any template macros that do not deal with extension\n      onToken: token => {\n        const trimmedToken = token.trim();\n\n        // See if the token is the first thing to appear\n        if (trimmedToken.indexOf(IMPORT_TOKEN) === 0) {\n          // Analyze the remainder of the token to find the necessary colon to be the NEXT\n          // Non-whitespace character\n          const afterToken = trimmedToken.substr(IMPORT_TOKEN.length).trim();\n\n          // Make sure the character IS a colon\n          if (afterToken[0] === IMPORT_DELIMITER) {\n            // Indicates if content was properly found for the requested ID\n            let moduleContentFound = false;\n            // At this point, ANYTHING after the colon is the module id being requested (with white space trimmed)\n            // We allow comma delimited module ids to be specified\n            const moduleIds = afterToken\n              .substr(IMPORT_DELIMITER.length)\n              .trim()\n              .split(\",\");\n\n            // Wealso  allow trailing comma\n            if (moduleIds[moduleIds.length - 1].trim().length === 0) {\n              moduleIds.pop();\n            }\n\n            // Loop through all discovered module ids after the import statement\n            moduleIds.forEach(moduleId => {\n              // Make sure whitespace is cleared\n              moduleId = moduleId.trim();\n              // Get the requested module\n              const mod = ShaderModule.modules.get(moduleId);\n\n              // If we found the module, great! We can store the identifier as a module associated with this shader\n              // string thus reducing processing time needed for next processing.\n              if (mod) {\n                if (\n                  target === ShaderInjectionTarget.FRAGMENT ||\n                  target === ShaderInjectionTarget.ALL\n                ) {\n                  if (mod.fs) {\n                    moduleContentFound = true;\n\n                    if (!dependentSet.has(moduleId)) {\n                      dependents.push(moduleId);\n                    }\n                  } else {\n                    errors.push(\n                      `Could not find requested target fragment module for Module ID: ${moduleId} requested by module: ${id}`\n                    );\n                  }\n                }\n\n                if (\n                  target === ShaderInjectionTarget.VERTEX ||\n                  target === ShaderInjectionTarget.ALL\n                ) {\n                  if (mod.vs) {\n                    moduleContentFound = true;\n\n                    if (!dependentSet.has(moduleId)) {\n                      dependents.push(moduleId);\n                    }\n                  } else {\n                    errors.push(\n                      `Could not find requested target vertex module for Module ID: ${moduleId} requested by module: ${id}`\n                    );\n                  }\n                }\n\n                if (!mod.vs && !mod.fs) {\n                  errors.push(\n                    \"Could not find a vertex or fragment shader within exisitng module\"\n                  );\n                }\n\n                if (!moduleContentFound) {\n                  errors.push(\n                    `Error Processing module Module ID: ${moduleId} requested by module: ${id}`\n                  );\n                }\n              } else {\n                errors.push(\n                  `Could not find requested module: ${moduleId} requested by module: ${id}`\n                );\n              }\n            });\n\n            // Clear the import token from the body of the shader\n            return \"\";\n          }\n        }\n\n        // Leave any token not processed alone\n        return `$\\{${token}}`;\n      }\n    });\n\n    // Update the content to be stripped of it's import statements\n    unit.applyAnalyzedContent(templateResults.shader);\n    // Update the dependents to include the modules found that this module requested\n    unit.dependents = dependents;\n\n    return errors;\n  }\n\n  /**\n   * This examines a shader string and replaces all import statements with any existing registered modules.\n   * This will also output any issues such as requested modules that don't exist and detect circular dependencies\n   * and such ilk.\n   *\n   * @param shader The content of the shader to analyze for import statements\n   * @param target The shader target type to consider\n   * @param additionalModules Additional modules to include in the shader regardless if the shader requested it or not\n   */\n  static process(\n    id: string,\n    shader: string,\n    target: ShaderInjectionTarget,\n    additionalModules?: string[]\n  ): IShaderCompileResults {\n    // The discovered shader module units during processing\n    const shaderModuleUnits = new Set<ShaderModuleUnit>();\n    // This stores the module id's that have already been included in the shader\n    const included = new Set<string>();\n    // This stores the import stack that is currently being processed\n    const processing: (string | null)[] = [];\n    // This is all of the processed errors discovered while resolving imports\n    const errors: string[] = [];\n    // Pick a debugging target based on shader target\n    const debugTarget =\n      target === ShaderInjectionTarget.VERTEX ? debugModuleVS : debugModuleFS;\n    debugTarget(\"Processing Shader for id %o:\", id);\n\n    // Internal checking method of the state of the process to find circular dependencies\n    function checkCircularDependency(unit: ShaderModuleUnit) {\n      // Get the id of the module being processed for quick reference\n      const id = unit.moduleId;\n      // Debugging for the import id's found along with the current stack\n      debugTarget(\n        \"%o: %o\",\n        id,\n        processing\n          .slice(0)\n          .reverse()\n          .join(\" -> \")\n      );\n\n      // First look to see if the identifier is already in the processing queue. If it is, we\n      // have a heinous circular dependency.\n      const queueIndex = processing.indexOf(id);\n      // Queue up this id as being processed\n      processing.unshift(id);\n\n      // See if the circular dependency is found.\n      if (queueIndex > -1) {\n        // Since we have a queue of our processing path, we can show the circular dependency path\n        const circularPath = processing.slice(0, queueIndex + 2).reverse();\n        // Spew the blood\n        errors.push(\n          `A Shader has detected a Circular dependency in import requests: ${circularPath.join(\n            \" -> \"\n          )}`\n        );\n        // Remove the id from the queue\n        processing.shift();\n\n        // Return a null flag indicating the process failed.\n        return false;\n      }\n\n      return true;\n    }\n\n    // We place this method as an internal recursive strategy to solving this issue due to the complexities of\n    // the problem at hand. We have shaders that have tokens analyzed that MUST be immediately resolved\n    // to a correct value. Thus we can not use a process queue to remove the need for the recursion. Also, as\n    // this is a static method, this provides some needed properties within the context of the function that we\n    // do not want exposed at all, which is impossible to hide within a static context (private static is not supported).\n    function process(unit: ShaderModuleUnit): string | null {\n      // This is the id of the module unit  currently being processed\n      const id = unit.moduleId;\n\n      // Do the circular dependency check for the module\n      if (!checkCircularDependency(unit)) {\n        return null;\n      }\n\n      // At this point we need to determine if the id has already been included in the module imports\n      // Each import should only be included once so we prevent duplicate items from showing up\n      if (id && included.has(id)) {\n        // Remove the id from the queue\n        processing.shift();\n\n        // Return empty, but not errored\n        return \"\";\n      }\n\n      // This will store all of the module content that should be injected as the header\n      let includedModuleContent = \"\";\n      // Make sure the dependents for the module are properly analyzed\n      const dependentsErrors = ShaderModule.analyzeDependents(unit);\n      // Add in any errors discovered during module analysis\n      dependentsErrors.forEach(error => errors.push(error));\n      // Get the dependents for the module for processing\n      const dependents = unit.dependents;\n\n      if (dependents && dependents.length > 0) {\n        for (let i = 0, iMax = dependents.length; i < iMax; ++i) {\n          // The dependent is the id of the module id dependency\n          const moduleId = dependents[i];\n          // Get the requested module\n          const mod = ShaderModule.modules.get(moduleId);\n\n          // If we found the module, great! We can see if the found module has a compatible target for this module.\n          if (mod) {\n            let moduleContent;\n\n            if (\n              target === ShaderInjectionTarget.FRAGMENT ||\n              target === ShaderInjectionTarget.ALL\n            ) {\n              if (mod.fs) {\n                shaderModuleUnits.add(mod.fs);\n                moduleContent = process(mod.fs);\n              } else {\n                errors.push(\n                  `Could not find requested target fragment module for Module ID: ${moduleId} requested by module: ${id}`\n                );\n              }\n            }\n\n            if (\n              target === ShaderInjectionTarget.VERTEX ||\n              target === ShaderInjectionTarget.ALL\n            ) {\n              if (mod.vs) {\n                shaderModuleUnits.add(mod.vs);\n                moduleContent = process(mod.vs);\n              } else {\n                errors.push(\n                  `Could not find requested target vertex module for Module ID: ${moduleId} requested by module: ${id}`\n                );\n              }\n            }\n\n            if (!mod.vs && !mod.fs) {\n              errors.push(\n                \"Could not find a vertex or fragment shader within exisitng module\"\n              );\n            }\n\n            if (moduleContent === null) {\n              errors.push(\n                `Error Processing module Module ID: ${moduleId} requested by module: ${id}`\n              );\n            }\n\n            // Include the discovered content in the module content output\n            includedModuleContent += moduleContent || \"\";\n          } else {\n            errors.push(\n              `Could not find requested module: ${moduleId} requested by module: ${id}`\n            );\n          }\n        }\n      }\n\n      // Remove the id being processed currently\n      processing.shift();\n      // Add the id to the list of items that have been included\n      included.add(id || \"\");\n\n      // Place the included module content at the top of the shader and return this module with it's necessary\n      // inclusions\n      return `${includedModuleContent.trim()}\\n\\n${unit.content.trim()}`;\n    }\n\n    // We throw in the additional imports  at the top of the shader being analyzed\n    let modifedShader = shader;\n\n    if (additionalModules) {\n      let imports = \"\";\n\n      additionalModules.forEach(\n        moduleId => (imports += `$\\{import: ${moduleId}}\\n`)\n      );\n\n      modifedShader = imports + shader;\n    }\n\n    // Make our shader a temp module unit to make it compatible with the rest of the shader module processing\n    const tempShaderModuleUnit = new ShaderModuleUnit({\n      content: modifedShader,\n      compatibility: target,\n      moduleId: `Layer \"${id}\" ${\n        target === ShaderInjectionTarget.ALL\n          ? \"fs vs\"\n          : target === ShaderInjectionTarget.VERTEX\n          ? \"vs\"\n          : \"fs\"\n      }`\n    });\n\n    // Generate the results needed\n    const results = {\n      errors,\n      shader: process(tempShaderModuleUnit),\n      shaderModuleUnits\n    };\n\n    return results;\n  }\n}\n","import { Bounds } from \"../../math/primitives\";\nimport { PackNode } from \"../../resources/texture/pack-node\";\nimport { Omit, ResourceType, Size } from \"../../types\";\nimport { BaseResourceOptions } from \"../base-resource-manager\";\nimport { SubTexture } from \"../texture/sub-texture\";\nimport { FontMap, FontMapGlyphType } from \"./font-map\";\nimport { FontRenderer } from \"./font-renderer\";\nimport { fontRequest, IFontResourceRequest } from \"./font-resource-request\";\n\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * Valid glyph rendering sizes that the system will use when rendering the glyphs to the font map's texture.\n */\nexport enum FontGlyphRenderSize {\n  /** NOT RECOMMENDED: You lose a lot of quality with this size. Use only if you do not need your text larger than 16 ever. */\n  _16 = 16,\n  /** Ideal size for simple SDF technique that trades used memory for quality */\n  _32 = 32,\n  /** Better quality glyphs for rendering, but suffers from resource useasge */\n  _64 = 64,\n  /** NOT RECOMMENDED: This is very large and will not allow for many glyphs on a single texture */\n  _128 = 128\n}\n\n/**\n * Metrics for a font map source specification.\n */\nexport interface IFontMapMetrics {\n  /**\n   * EXPERIMENTAL: When enabled, this allows the framework to cache the kerning pair calculations in the local storage.\n   * This can greatly speed up reload times of this chart, but may come with consequences as well.\n   */\n  localKerningCache?: boolean;\n  /** A type indicator to help identify which type of font resource is provided */\n  type?: FontMapGlyphType;\n  /** Size the font is rendered to the font map */\n  size: number;\n  /** Family of the font to be rendered to the font map */\n  family: string;\n  /** Font weight of the font to be rendered to the font map */\n  weight: string | number;\n  /** Applies pre-computed strings to warm up kerning pairs and glyph renderings before any label is generated. */\n  preload?: string;\n}\n\nexport interface ISimpleFontMapMetrics extends IFontMapMetrics {\n  type: undefined;\n}\n\n/**\n * Indicates a bitmap font source.\n */\nexport interface IBitmapFontSource extends IFontMapMetrics {\n  /** This indicates a bitmap style of font rendering is required of the font. */\n  type: FontMapGlyphType.BITMAP;\n}\n\n/**\n * The available properties of a prerendered font source\n */\nexport interface IPrerenderedFontSource extends IFontMapMetrics {\n  /** This is the glyph renderings in Base64 encoding */\n  glyphs: { [key: string]: string };\n  /** This is the glyph used when no glyph is available */\n  errorGlyph: string;\n}\n\n/**\n * This is a provided pre-rendered SDF resource object format.\n */\nexport interface IPrerenderedSDFFontSource extends IPrerenderedFontSource {\n  /** This is the indicator that this prerendered resource is SDF */\n  type: FontMapGlyphType.SDF;\n}\n\n/**\n * This is a provided pre-rendered MSDF resource object format.\n */\nexport interface IPrerenderedMSDFFontSource extends IPrerenderedFontSource {\n  /** This is the indicator that this prerendered resource is MlSDF */\n  type: FontMapGlyphType.MSDF;\n}\n\n/**\n * These are the valid sources of a font from which the system will derive the glyphs and font metrics necessary\n * to render text to the screen.\n */\nexport type FontMapSource =\n  | IFontMapMetrics\n  | IBitmapFontSource\n  | IPrerenderedSDFFontSource\n  | IPrerenderedMSDFFontSource;\n\n/**\n * Options for creating a new Font Resource.\n */\nexport interface IFontResourceOptions extends BaseResourceOptions {\n  /**\n   * When this is provided ONLY these characters will be supplied by this resource.\n   * This is simply a string with every character to allow. Filtering glyphs can greatly\n   * speed up performance. When not provided, the system will analyze strings as they stream in\n   * and will update the atlas with the needed glyphs to render the text.\n   */\n  characterFilter?: string;\n  /**\n   * When this is set, the system will add glyphs to the font map from the font source provided as the glyphs\n   * are needed. This performs not as well as preset fonts. You can combine dynamic with characterFilter to have\n   * initial glyphs be preloaded and work faster from the start. Or you can use the character filter but NOT be dynamic\n   * and enforce strict character allowances.\n   */\n  dynamic?: boolean;\n  /** If the system has generated the font map for this resource, this will be populated */\n  fontMap?: FontMap;\n  /**\n   * This is the source the font information is derived from.\n   *\n   * A string will cause the system to use canvas rendering to attempt to best calculate the font glyphs and metrics as best\n   * as possible. This is the slowest possible method to render text.\n   *\n   * It is much better to used the pre-rendered formats.\n   */\n  fontSource: FontMapSource;\n  /** Enforce the resource to be a FONT type */\n  type: ResourceType.FONT;\n  /** If provided will constrain the texture to the provided size */\n  fontMapSize?: Size;\n}\n\n/**\n * Type guard for font resource options type\n */\nexport function isFontResource(\n  val: BaseResourceOptions\n): val is IFontResourceOptions {\n  return val && val.type === ResourceType.FONT;\n}\n\n/**\n * This is the string font source type guard.\n */\nfunction isSimpleFontMetrics(val: any): val is ISimpleFontMapMetrics {\n  return val && val.type === undefined;\n}\n\n/**\n * Method for making typings and API feedback easier. Just a wrapper for building\n * an IFontResourceOptions object. Excludes the need to specify the type.\n */\nexport function createFont(\n  options: Omit<IFontResourceOptions, \"type\" | \"key\"> &\n    Partial<Pick<IFontResourceOptions, \"key\">>\n): IFontResourceOptions {\n  return {\n    key: \"\",\n    type: ResourceType.FONT,\n    ...options\n  };\n}\n\n/**\n * This manager is responsible for handling the actual generation and updating of Font textures.\n *\n * This manager handles consuming resource options and producing an appropriate resource based on\n * either generating the SDF at run time or loading up a provided pre-rendered font resource.\n */\nexport class FontManager {\n  /** The lookup for the font map resources by their key */\n  fontMaps = new Map<string, FontMap>();\n  /**\n   * Contains the methods needed to render glyphs and calculate kerning\n   * when no precomputed resources are available.\n   */\n  fontRenderer = new FontRenderer();\n\n  /**\n   * This takes all requests that want layout information included for a group of text\n   * and populates the request with the appropriate information.\n   */\n  async calculateMetrics(\n    resourceKey: string,\n    requests: IFontResourceRequest[]\n  ) {\n    debug(\"Calculating metrics for requests\");\n    const fontMap = this.fontMaps.get(resourceKey);\n    if (!fontMap) return;\n\n    for (let i = 0, iMax = requests.length; i < iMax; ++i) {\n      const request = requests[i];\n      const metrics = request.metrics;\n\n      // Only some requests will have metrics to be calculated\n      if (metrics) {\n        // Get the layout of the request\n        metrics.layout = fontMap.getStringLayout(\n          metrics.text,\n          metrics.fontSize,\n          metrics.letterSpacing\n        );\n\n        // If a max width is present, we need to calculate the truncation of the label\n        if (metrics.maxWidth) {\n          debug(\"Calculating truncation for\", metrics.text, metrics.maxWidth);\n\n          metrics.layout = await fontMap.getTruncatedLayout(\n            metrics.layout,\n            metrics.truncation || \"\",\n            metrics.maxWidth,\n            metrics.fontSize,\n            metrics.letterSpacing,\n            this.fontRenderer\n          );\n\n          // Show what the truncated text is\n          metrics.truncatedText = metrics.layout.text;\n        }\n      }\n    }\n  }\n\n  /**\n   * Converts a character filter to a deduped list of single characters\n   */\n  private characterFilterToCharacters(filter: string): string {\n    const characters = new Set<string>();\n    let all = \"\";\n\n    for (let i = 0, iMax = filter.length; i < iMax; ++i) {\n      const char = filter[i];\n\n      if (!characters.has(char)) {\n        characters.add(char);\n        all += char;\n      }\n    }\n\n    return all;\n  }\n\n  /**\n   * This generates a new font map object to work with. It will either be pre-rendered or dynamically\n   * populated as requests are made.\n   */\n  async createFontMap(resourceOptions: IFontResourceOptions) {\n    // This will contain all of the characters that the map initially starts with\n    const characters: string = this.characterFilterToCharacters(\n      resourceOptions.characterFilter || \"\"\n    );\n    // This is the generated font map specified by the resource options\n    let fontMap: FontMap | undefined;\n    // This is the source information of the font which the system will utilize to produce the map\n    const fontSource = resourceOptions.fontSource;\n    // This is the determined glyph type of the resource\n    let glyphType: FontMapGlyphType = FontMapGlyphType.SDF;\n\n    // We now determine what type of font source the options provide and set our font map\n    // up properly for it.\n    if (fontSource) {\n      if (isSimpleFontMetrics(fontSource)) {\n        glyphType = FontMapGlyphType.BITMAP;\n      } else {\n        glyphType = fontSource.type || glyphType;\n      }\n    }\n\n    // Create our new font map resource\n    fontMap = new FontMap({\n      ...resourceOptions,\n      glyphType\n    });\n\n    // Apply initial characters to the fontMap\n    await this.updateFontMapCharacters(characters, fontMap);\n    // Keep the generated font map as our resource\n    this.fontMaps.set(resourceOptions.key, fontMap);\n\n    // Check if the font source has some preload characters needed to update the fontmap with to improve initial render\n    // times of resources making requests\n    if (resourceOptions.fontSource.preload) {\n      this.updateFontMap(resourceOptions.key, [\n        fontRequest({\n          key: resourceOptions.key,\n          character: \"\",\n          kerningPairs: [resourceOptions.fontSource.preload],\n          metrics: {\n            fontSize: 12,\n            text: resourceOptions.fontSource.preload,\n            letterSpacing: 0\n          }\n        })\n      ]);\n    }\n\n    return fontMap;\n  }\n\n  /**\n   * Free all generated resources here.\n   */\n  destroy() {\n    // Clears up resources\n    this.fontMaps.forEach(font => font.destroy());\n  }\n\n  /**\n   * Destroy a single font map\n   */\n  destroyFontMap(key: string) {\n    const fontMap = this.fontMaps.get(key);\n    if (!fontMap) return;\n    fontMap.destroy();\n  }\n\n  /**\n   * This updates a font map with requests made. After the font map is updated, the\n   * requests should be populated with the appropriate sub texture information.\n   */\n  async updateFontMap(resourceKey: string, requests: IFontResourceRequest[]) {\n    const fontMap = this.fontMaps.get(resourceKey);\n    if (!fontMap) return;\n\n    let allPairs: string[] = [];\n    const allCharacters = new Set<string>();\n\n    // Aggregate all kerning and character requests and needs\n    for (let i = 0, iMax = requests.length; i < iMax; ++i) {\n      const req = requests[i];\n      if (req.character) allCharacters.add(req.character);\n      if (req.kerningPairs) allPairs = allPairs.concat(req.kerningPairs);\n\n      // We add in truncation characters as well if provided\n      if (req.metrics) {\n        if (req.metrics.truncation) {\n          const truncation = req.metrics.truncation.replace(/\\s/g, \"\");\n          allPairs.push(truncation);\n\n          for (let i = 0, iMax = req.metrics.truncation.length; i < iMax; ++i) {\n            allCharacters.add(truncation);\n          }\n        }\n      }\n    }\n\n    // Kerning pairs are also candidates for being rendered to the font map\n    for (let i = 0, iMax = allPairs.length; i < iMax; ++i) {\n      allCharacters.add(allPairs[i]);\n    }\n\n    // Convert the characters to be rendered to a sinple string\n    let uniqueCharacters: string = \"\";\n    allCharacters.forEach(char => (uniqueCharacters += char));\n\n    // Perform the updates to the font map\n    await this.updateFontMapCharacters(uniqueCharacters, fontMap);\n    // Perform the updates to the kerning pairs\n    await this.updateKerningPairs(allPairs, fontMap);\n\n    // After all this is done, all the requests can be populated with the font map\n    // signaling the request now has the resources to accomplish what it needs\n    for (let i = 0, iMax = requests.length; i < iMax; ++i) {\n      requests[i].fontMap = fontMap;\n    }\n  }\n\n  /**\n   * This updates the calculated kerning pairs for a given font map.\n   */\n  private async updateKerningPairs(pairs: string[], fontMap?: FontMap) {\n    if (!fontMap) return;\n\n    // Calculate the new kerning pair information\n    const kerning = await this.fontRenderer.estimateKerning(\n      pairs,\n      fontMap.fontString,\n      fontMap.fontSource.size,\n      fontMap.kerning,\n      !fontMap.spaceWidth\n    );\n\n    // Add the pairs to the font map\n    fontMap.addKerning(kerning.pairs);\n    // Set the calculated width of a space\n    fontMap.spaceWidth = fontMap.spaceWidth || kerning.spaceWidth;\n  }\n\n  /**\n   * This updates a specified font map with a list of characters expected within it.\n   */\n  private async updateFontMapCharacters(characters: string, fontMap?: FontMap) {\n    if (!fontMap) return;\n    const texture = fontMap.texture;\n\n    // We must determine which characters are not supported by the font map first\n    const toAdd = fontMap.findMissingCharacters(characters);\n    // Nothing to add, then nothig to do!\n    if (toAdd.length <= 0) return;\n\n    // Get all the glyph data we need to update to the Font Map's texture\n    const glyphs = this.fontRenderer.makeBitmapGlyphs(\n      toAdd,\n      fontMap.fontString,\n      fontMap.fontSource.size\n    );\n\n    // Apply each newly rendered glyph into the font map\n    for (const char in glyphs) {\n      const metrics = glyphs[char];\n\n      if (texture.data) {\n        const packBounds = new Bounds({\n          x: 0,\n          y: 0,\n          width: metrics.glyph.width,\n          height: metrics.glyph.height\n        });\n\n        // Make the sub texture object our packing is going to associate with\n        const subTexture = new SubTexture();\n\n        // Pack the glyph information into the font map texture\n        const packing = fontMap.packing.insert({\n          data: subTexture,\n          bounds: packBounds\n        });\n\n        if (!packing) {\n          console.warn(\n            \"Font map is full and could not pack in any more glyphs\"\n          );\n          return;\n        }\n\n        // Now use the packing information to update our texture\n        PackNode.applyToSubTexture(\n          fontMap.packing,\n          packing,\n          subTexture,\n          undefined,\n          true\n        );\n\n        // Apply the image to the texture\n        texture.update(metrics.glyph, {\n          ...packing.bounds,\n          y:\n            fontMap.packing.bounds.height -\n            packing.bounds.y -\n            packing.bounds.height\n        });\n\n        // Register the glyph with the font map\n        if (subTexture) fontMap.registerGlyph(char, subTexture);\n        else {\n          console.warn(\n            \"Could not generate a subtexture for the font map registration.\"\n          );\n        }\n      } else {\n        console.warn(\n          \"Can not update font map as the maps texture data is not defined.\"\n        );\n      }\n    }\n  }\n\n  /**\n   * TODO:\n   * We do not use this method yet as we do not have a format set for prerendered fonts.\n   * Currently the system only uses the bitmap font dynamic pattern.\n   *\n   * This renders the specified characters from a pre-rendered font source in ImageData that can be used to composite\n   * a texture.\n   */\n  async getPrerenderedImageData(\n    source: IPrerenderedFontSource,\n    glyphSize: FontGlyphRenderSize,\n    characters: string[]\n  ) {\n    const promises: Promise<void>[] = [];\n\n    // Loop through all of the characters to be loaded from the source\n    characters.forEach(char => {\n      let glyphData = source.glyphs[char];\n\n      // Make sure the character exists, if not, use the error glyph provided by the source\n      if (!glyphData) {\n        glyphData = source.errorGlyph;\n      }\n\n      // A valid error glyph MUST be present\n      if (!source.errorGlyph) {\n        console.warn(\n          \"The prerendered source provided did NOT provide a proper glyph for rendering when a glyph could not be located.\"\n        );\n        return [];\n      }\n\n      // Set up the waiting mechanisms and the resources to render our glyphs from Base64\n      const image = new Image();\n      let resolve: Function;\n      const promise = new Promise<void>(resolver => (resolve = resolver));\n\n      // Wait for the image to finish loading\n      image.onload = function() {\n        // Make our canvas context to render the glyph data to.\n        const canvas: HTMLCanvasElement = document.createElement(\"canvas\");\n        const context = canvas.getContext(\"2d\");\n        if (!context) return;\n        // Our canvas to render to will be the specified glyphSize block\n        canvas.width = glyphSize;\n        canvas.height = glyphSize;\n        // We want to draw the glyph the size of the desired glyph rendering\n        context.drawImage(image, 0, 0, glyphSize, glyphSize);\n        // Retreieve the data rendered to the canvas as our glyph data\n        const glyphData = context.getImageData(0, 0, glyphSize, glyphSize);\n        // Resolve with the rendered portion\n        resolve(glyphData);\n      };\n\n      // If an error occurrs\n      image.onerror = function() {\n        console.warn(\n          \"There was an issue with loading the glyph data for character:\",\n          char\n        );\n        resolve(null);\n      };\n\n      // Begin loading the glyph data into the image\n      image.src = source.glyphs[char];\n      promises.push(promise);\n\n      return [];\n    });\n\n    // This will contain all of the glyph render information\n    return await Promise.all(promises);\n  }\n}\n","import { GLSettings, Texture, TextureOptions } from \"../../gl\";\nimport { add2, scale2, Vec2 } from \"../../math/vector\";\nimport { isWhiteSpace, ResourceType, Size, TextureSize } from \"../../types\";\nimport { IdentifyByKey } from \"../../util/identify-by-key\";\nimport { PackNode } from \"../texture/pack-node\";\nimport { SubTexture } from \"../texture/sub-texture\";\nimport {\n  FontManager,\n  FontMapSource,\n  IFontResourceOptions\n} from \"./font-manager\";\nimport { FontRenderer, KerningPairs } from \"./font-renderer\";\n\nconst debug = require(\"debug\")(\"performance\");\n\nexport enum FontMapGlyphType {\n  /** Straight images for each glyph */\n  BITMAP,\n  /** Signed distance field glyphs */\n  SDF,\n  /** Multichannel signed distance fields */\n  MSDF\n}\n\nexport interface IFontMapOptions extends IFontResourceOptions {\n  /**\n   * This is the initial characters registered with this font map. If this is not Dynamic,\n   * these are the only characters this map can provide.\n   */\n  characters?: [string, SubTexture][];\n  /**\n   * This is the glyph type for the font.\n   */\n  glyphType: FontMapGlyphType;\n}\n\n/**\n * This describes a string's individual letter offsets when properly kerned relative to each other.\n */\nexport type KernedLayout = {\n  /** The scaling of the font relative to the desired font size vs the rendered size of the font on the font map */\n  fontScale: number;\n  /** This is the glyphs given positions. This is essentially the text minus the whitespace. */\n  glyphs: string;\n  /**\n   * This provides the kerning of each letter. The order of the positions provided is in\n   * the order the letters appear in the text measured. This is all relative to placing the\n   * top left of the rendering at [0, 0]\n   */\n  positions: Vec2[];\n  /** The width and height of the entire rendered string */\n  size: Size;\n  /** The text used in calculating this layout */\n  text: string;\n};\n\n/**\n * This represents the actual font map resource. It contains the raw texture object for manipulating.\n */\nexport class FontMap extends IdentifyByKey implements IFontResourceOptions {\n  /** Makes a CSS font string from the font properties in the map */\n  get fontString() {\n    return `${this.fontSource.size}px ${this.fontSource.family}`;\n  }\n  /**\n   * A dynamic font map renders single glyphs at a time into the resource rather than preloads.\n   */\n  dynamic: boolean = false;\n  /** The metrics of the font rendered to this font map */\n  fontSource: FontMapSource;\n  /**\n   * The number of glyphs successfully registered with this font map. This is used to determine the\n   * position of the next glyph for the font map.\n   */\n  glyphCount: number;\n  /**\n   * This maps all of the glyphs this resource provides for to the SubTexture where the glyph is rendered\n   * on the resource.\n   */\n  glyphMap: { [char: string]: SubTexture } = {};\n  /**\n   * These  are the calculated kerning pairs available for this font map. If a pair does not\n   * exist here, then the map may not have the character or the pair may not have been calculated\n   * for the font map yet.\n   */\n  kerning: KerningPairs = {};\n  /** This is the manager storing the Font Map */\n  manager: FontManager;\n  /** Tracks how the glyphs are packed into the map */\n  packing: PackNode<SubTexture>;\n  /** This is the calculated width of a space for the font map */\n  spaceWidth: number = 0;\n  /** The base texture where the font map is stored */\n  texture: Texture;\n  /**\n   * The settings applied to the texture object itself. This is managed by the type of glyph in use.\n   */\n  private textureSettings: TextureOptions;\n  /**\n   * This finishes establishing this font map as a resource that is a IFontMapResourceOptions\n   */\n  type: ResourceType.FONT = ResourceType.FONT;\n\n  constructor(options: IFontMapOptions) {\n    super(options);\n\n    this.dynamic = options.dynamic || false;\n    this.fontSource = options.fontSource;\n\n    if (options.characters) {\n      options.characters.forEach(pair => {\n        this.doRegisterGlyph(pair[0], pair[1]);\n      });\n    }\n\n    const fontMapSize: Size = options.fontMapSize\n      ? options.fontMapSize\n      : [TextureSize._1024, TextureSize._1024];\n\n    this.makeGlyphTypeTextureSettings(options.glyphType);\n    this.createTexture(fontMapSize);\n\n    // Initialize the packing layout for the texture\n    this.packing = new PackNode(0, 0, fontMapSize[0], fontMapSize[1]);\n    // If allowed, load the cached kerning from the system\n    this.addCachedKerning();\n  }\n\n  private getKerningCacheName() {\n    return `__deltav_kerning_cache_${this.fontSource.family}__`;\n  }\n\n  /**\n   * Loads the stored cached kerning if it's available.\n   */\n  private addCachedKerning() {\n    if (this.fontSource.localKerningCache) {\n      const cachedKerningStr = localStorage.getItem(this.getKerningCacheName());\n\n      if (cachedKerningStr) {\n        debug(\"Loading cached kerning items:\", this.getKerningCacheName());\n\n        try {\n          const cachedKerning = JSON.parse(cachedKerningStr);\n          let totalKernsLoaded = 0;\n\n          for (const left in cachedKerning) {\n            let isValid: boolean =\n              typeof left === \"string\" && left.length === 1;\n            if (!isValid) continue;\n\n            const rights = cachedKerning[left];\n            const rightKerning = this.kerning[left] || {};\n            this.kerning[left] = rightKerning;\n\n            for (const right in rights) {\n              isValid = typeof left === \"string\" && left.length === 1;\n              if (!isValid) continue;\n              rightKerning[right] = rights[right];\n              totalKernsLoaded++;\n            }\n          }\n\n          debug(\n            \"Found kerning items in the cache!\",\n            \"Count:\",\n            totalKernsLoaded\n          );\n        } catch (err) {\n          /** do nothing as the kerning info is not valid */\n        }\n      }\n    }\n  }\n\n  /**\n   * Applies additional kerning pair information to the map.\n   */\n  addKerning(kerning: KerningPairs) {\n    let hasNew = false;\n\n    for (const left in kerning) {\n      const rights = kerning[left];\n      const rightKerning = this.kerning[left] || {};\n      if (!this.kerning[left]) hasNew = true;\n      this.kerning[left] = rightKerning;\n\n      for (const right in rights) {\n        if (!rightKerning[right]) hasNew = true;\n        rightKerning[right] = rights[right];\n      }\n    }\n\n    // If new kerning pairs applied, then we should update the cache\n    if (hasNew && this.fontSource.localKerningCache) {\n      try {\n        debug(\"Storing kerning info in cache...\");\n        const kerningCache = JSON.stringify(this.kerning);\n        localStorage.setItem(this.getKerningCacheName(), kerningCache);\n      } catch (err) {\n        // Failures just silently fail\n        debug(\"Could not cache kerning info\");\n      }\n    }\n  }\n\n  /**\n   * Generates the texture for the font map which makes it ready for utilization and ready\n   * for updates.\n   */\n  private createTexture(size: Size) {\n    if (this.texture) return;\n\n    // Establish the settings to be applied to the Texture\n    let textureSettings;\n\n    if (this.textureSettings) {\n      textureSettings = {\n        generateMipMaps: true,\n        premultiplyAlpha: true,\n        ...this.textureSettings\n      };\n    } else {\n      textureSettings = {\n        generateMipMaps: true,\n        premultiplyAlpha: true\n      };\n    }\n\n    // Generate the texture\n    this.texture = new Texture({\n      data: {\n        width: size[0],\n        height: size[1],\n        buffer: null\n      },\n      ...textureSettings\n    });\n  }\n\n  /**\n   * Free resources for this manager\n   */\n  destroy() {\n    this.texture.dispose();\n  }\n\n  /**\n   * Performs the internal glyph registration.\n   */\n  private doRegisterGlyph(char: string, tex: SubTexture) {\n    const oneChar = char[0];\n\n    if (!this.glyphMap[oneChar]) {\n      this.glyphMap[oneChar] = tex;\n    } else {\n      console.warn(\"A Glyph is already registered with a rendering\");\n    }\n  }\n\n  /**\n   * This returns which characters are not included in this font map.\n   */\n  findMissingCharacters(newCharacters: string) {\n    const missing = new Set<string>();\n    let allMissing: string = \"\";\n\n    for (let i = 0, iMax = newCharacters.length; i < iMax; ++i) {\n      const char = newCharacters[i];\n\n      if (!this.glyphMap[char] && !missing.has(char)) {\n        missing.add(char);\n        allMissing += char;\n      }\n    }\n\n    return allMissing;\n  }\n\n  /**\n   * This retrieves the glyph texture information from the FontMap.\n   */\n  getGlyphTexture(char: string): SubTexture | null {\n    return this.glyphMap[char[0]] || null;\n  }\n\n  /**\n   * This provides the expected vector from the top left corner of the left vector\n   * to the top left corner of the right vector.\n   */\n  getGlyphKerning(leftChar: string, rightChar: string): Vec2 {\n    const right = this.kerning[leftChar];\n    // If not pairs for the provided left character, just provide 0\n    if (!right) return [0, 0];\n\n    // Produce the kerning value or zero if none exists\n    return right[rightChar] || [0, 0];\n  }\n\n  /**\n   * This looks at the glyphs directly from a layout and provides the width of the glyphs.\n   *\n   * This differs from getStringWidth as the indices reference GLYPHS (not white space) while\n   * the parameters on the other reference the text.\n   *\n   * This method is a little less intuitive but can perform faster.\n   */\n  getGlyphWidth(stringLayout: KernedLayout, start: number, end: number) {\n    const startOffset = stringLayout.positions[start];\n    const endOffset = stringLayout.positions[end];\n    // The indices must be valid to work\n    if (!start || !end) return 0;\n    // Get the width of the final glyph\n    const image = this.glyphMap[stringLayout.glyphs[end]];\n    if (!image) return 0;\n\n    // Now we can output the rendered width\n    return endOffset[0] + image.pixelWidth - startOffset[0];\n  }\n\n  /**\n   * This looks at a string layout and provides a layout that reflects the layout bounded\n   * by a max width. This accounts for including\n   */\n  async getTruncatedLayout(\n    layout: KernedLayout,\n    truncation: string,\n    maxWidth: number,\n    fontSize: number,\n    letterSpacing: number,\n    fontRenderer: FontRenderer\n  ) {\n    // If the label exceeds the specified maxWidth then truncation must take places\n    if (layout.size[0] > maxWidth) {\n      let truncatedText = \"\";\n      let truncationWidth = 0;\n\n      // We'll get a rough and dirty truncation character width estimate by simply adding the width of\n      // all the glyphs\n      for (let i = 0, iMax = truncation.length; i < iMax; ++i) {\n        truncationWidth += this.glyphMap[truncation[i]].pixelWidth;\n      }\n\n      // Now find a width of glyphs + the width of the truncation that will fit within the maxWidth\n      // If the truncation width is wider than the max width, then we truncate to no text at all.\n      if (truncationWidth > maxWidth) {\n        return {\n          fontScale: 1,\n          glyphs: \"\",\n          positions: [],\n          size: [0, 0],\n          text: \"\"\n        } as KernedLayout;\n      }\n\n      // Otherwise, let's do the search for the correct glyphs to show that will fit properly.\n      // We will use a simple binary search to find the appropriate length to use.\n      let left = 0;\n      let right = layout.positions.length;\n      let cursor = 0;\n      let check = 0;\n      let char = \"\";\n\n      while (left !== right) {\n        cursor = Math.floor((right - left) / 2) + left;\n        char = layout.glyphs[cursor];\n        check =\n          layout.positions[cursor][0] +\n          this.glyphMap[char].pixelWidth +\n          truncationWidth;\n\n        if (check > maxWidth) right = cursor;\n        else if (check < maxWidth) left = cursor;\n        else break;\n\n        if (Math.abs(left - right) <= 1) {\n          if (check < maxWidth) break;\n\n          while (check > maxWidth && cursor >= 0) {\n            cursor--;\n            check =\n              layout.positions[cursor][0] +\n              this.glyphMap[char].pixelWidth +\n              truncationWidth;\n          }\n\n          break;\n        }\n      }\n\n      // Our cursor should now be pointing to the letter that will be our truncation point\n      // We must make sure with the characters specified it does fit, if not, we only render\n      // the truncation glyphs\n      check =\n        layout.positions[cursor][0] +\n        this.glyphMap[char].pixelWidth +\n        truncationWidth;\n\n      if (check < maxWidth) {\n        // Loop through the text and find the glyph matching to the actual text with glyphs\n        let glyphIndex = 0;\n        let charIndex = 0;\n\n        for (\n          let i = 0, iMax = layout.text.length;\n          i < iMax && glyphIndex <= cursor;\n          ++i\n        ) {\n          const char = layout.text[i];\n\n          charIndex++;\n          if (!isWhiteSpace(char)) glyphIndex++;\n        }\n\n        // Make sure the last character attached to the first truncated letter has kerning info\n        const lastChar = layout.text[charIndex - 1];\n        let firstTruncChar;\n\n        for (let i = 0, iMax = truncation.length; i < iMax; ++i) {\n          if (!isWhiteSpace(truncation[i])) {\n            firstTruncChar = truncation[i];\n            break;\n          }\n        }\n\n        if (\n          lastChar &&\n          firstTruncChar &&\n          !this.kerning[lastChar][firstTruncChar]\n        ) {\n          const kerning = await fontRenderer.estimateKerning(\n            [lastChar + firstTruncChar],\n            this.fontString,\n            this.fontSource.size,\n            this.kerning,\n            false\n          );\n\n          this.addKerning(kerning.pairs);\n        }\n\n        truncatedText = `${layout.text.substr(0, charIndex)}${truncation}`;\n      } else {\n        truncatedText = truncation;\n      }\n\n      // Caculate the layout of the truncated text\n      return this.getStringLayout(truncatedText, fontSize, letterSpacing);\n    }\n\n    return layout;\n  }\n\n  /**\n   * Get the width of a set of characters within a string layout.\n   *\n   * To use this, first use the getStringLayout() method to get the KernedLayout then insert\n   * the the range of characters the width should be calculated for.\n   *\n   * [start, end)\n   */\n  getStringWidth(\n    stringLayout: KernedLayout,\n    start: number,\n    end: number\n  ): number;\n  /**\n   * Get the width of a substring from a string layout.\n   *\n   * To use this, first use the getStringLayout() method to get the KernedLayout then insert\n   * the substring of text desired for calculating the width.\n   */\n  getStringWidth(stringLayout: KernedLayout, substr: string): number;\n  /**\n   * Calculates the width of a chunk of characters within a calculated KernedLayout.\n   * To use this, first use the getStringLayout() method to get the KernedLayout then insert\n   * the substring of text desired for calculating the width.\n   */\n  getStringWidth(\n    stringLayout: KernedLayout,\n    param1: string | number,\n    param2?: number\n  ): number {\n    const text = stringLayout.text;\n    let firstChar = 0;\n    let lastChar = text.length;\n\n    // String param means we look for a substring\n    if (typeof param1 === \"string\") {\n      const index = text.indexOf(param1);\n      // No found sub string means the examined text does not exist\n      if (index < 0) return 0;\n      // Now we have the letter within the text we begin with.\n      firstChar = index;\n      // Last character is the first + length of sub string\n      lastChar = firstChar + param1.length;\n    } else {\n      firstChar = param1;\n    }\n\n    // Set the explicit last character to use\n    if (param2 !== undefined) {\n      lastChar = param2;\n    }\n\n    // We now trim out white space from our indices to get the actual glyph indices that match our search\n    let i = 0;\n    const endOfFirst = Math.min(text.length, firstChar);\n    const endOfLast = Math.min(text.length, lastChar);\n\n    for (; i < endOfFirst; ++i) {\n      if (isWhiteSpace(text[i])) {\n        firstChar--;\n        lastChar--;\n      }\n    }\n\n    for (; i < endOfLast; ++i) {\n      if (isWhiteSpace(text[i])) lastChar--;\n    }\n\n    // We now have the indices of the first and last glyph's position information in our text.\n    // We can use these two to determine the width of the text.\n    const lastGlyph = this.glyphMap[stringLayout.text[lastChar] || \"\"];\n    if (!lastGlyph) return 0;\n\n    return (\n      (stringLayout.positions[lastChar] || [0, 0])[0] -\n      (stringLayout.positions[firstChar] || [0, 0])[0] +\n      lastGlyph.pixelWidth\n    );\n  }\n\n  /**\n   * This processes a string and lays it out by the kerning rules available to this font map.\n   *\n   * NOTE: This ONLY processes a SINGLE LINE!! ALL whitespace characters will be considered a single\n   * space.\n   */\n  getStringLayout(\n    text: string,\n    fontSize: number,\n    letterSpacing: number\n  ): KernedLayout {\n    // The output positions for each letter in the text\n    const positions: Vec2[] = [];\n    // The output of each character found that is provided a position (the string without the whitespace)\n    let glyphs: string = \"\";\n    // Calculate the scaling of the font which would be the font map's rendered glyph size\n    // as a ratio to the label's desired font size.\n    const fontScale = fontSize / this.fontSource.size;\n\n    // Start with the initial glyph dimensions as the min and max y the label will have\n    let minY = Number.MAX_SAFE_INTEGER;\n    let maxY = 0;\n    let currentWidth = 0;\n    // The current offset for the current letter to be rendered properly\n    let offset: Vec2 = [0, 0];\n    // The amount each white space moves the text forward\n    const whiteSpacing = this.spaceWidth;\n    // Number of found whitespace characters since last character\n    let whiteSpaceCount = 0;\n    // The current character found to the left of the current one being processed\n    let leftChar = \"\";\n    // Holder for the found kerning of the character pair\n    let kern: Vec2;\n    // The image of the glyph that was rendered\n    let image: SubTexture;\n\n    // Loop through the text and calculate the offsets of each non-whitespace character\n    for (let i = 0, iMax = text.length; i < iMax; ++i) {\n      const char = text[i];\n\n      // White space merely moves the offset forward by the amount of a space\n      if (isWhiteSpace(char)) {\n        whiteSpaceCount++;\n        continue;\n      }\n\n      kern = [0, 0];\n\n      if (leftChar) {\n        kern = this.kerning[leftChar][char] || [0, 0];\n      }\n\n      offset = add2(add2(offset, scale2(kern, fontScale)), [\n        whiteSpaceCount * whiteSpacing * fontScale +\n          (i === 0 ? 0 : letterSpacing),\n        0\n      ]);\n\n      // Copy the offset to our output positions for the character\n      positions.push([offset[0], offset[1]]);\n      glyphs += char;\n\n      // Get the glyph rendering from the font map\n      image = this.glyphMap[char];\n      // Use the offset and the rendering height to determine the top and bottom of the glyph\n      minY = Math.min(offset[1], minY);\n      maxY = Math.max(offset[1] + image.pixelHeight * fontScale, maxY);\n      // Make this processed glyph the next glyph that is 'to the left' for the next glyph\n      leftChar = char;\n      // Calculate the width of the label as we lay out\n      currentWidth = offset[0] + image.pixelWidth * fontScale;\n      // Reset the whitespace count so we can see whitespaces to next character\n      whiteSpaceCount = 0;\n    }\n\n    // Now we have positioned all of our glyphs with relative kerning.\n    // We can now get a width and height of the total label\n    const height = maxY - minY;\n    // Update the instance with the calculated width of the label\n    const size: Size = [currentWidth, height];\n\n    // Move all of the glyphs by -minY. This will effectively frame the label where the\n    // top left is 0,0 relative to all of the contents of the label.\n    // We also apply the calculated anchor at this time for the label\n    for (let i = 0, iMax = positions.length; i < iMax; ++i) {\n      offset = positions[i];\n      offset[1] -= minY;\n    }\n\n    return {\n      fontScale,\n      glyphs,\n      positions,\n      size,\n      text\n    };\n  }\n\n  /**\n   * This generates the necessary texture settings for the font map based on it's glyph type.\n   */\n  private makeGlyphTypeTextureSettings(type: FontMapGlyphType) {\n    switch (type) {\n      // Simple bitmap glyphs. Just need luminance and alpha value for the glyph\n      case FontMapGlyphType.BITMAP:\n        this.textureSettings = {\n          magFilter: GLSettings.Texture.TextureMagFilter.Linear,\n          minFilter: GLSettings.Texture.TextureMinFilter.LinearMipMapLinear,\n          format: GLSettings.Texture.TexelDataType.LuminanceAlpha\n        };\n        break;\n\n      // Only a single channel is needed for SDF\n      case FontMapGlyphType.SDF:\n        this.textureSettings = {\n          magFilter: GLSettings.Texture.TextureMagFilter.Linear,\n          minFilter: GLSettings.Texture.TextureMinFilter.Linear,\n          format: GLSettings.Texture.TexelDataType.Luminance\n        };\n        break;\n\n      // The MSDF strategy uses all RGB channels for the algorithm. Heavier data use\n      // better quality results.\n      case FontMapGlyphType.MSDF:\n        this.textureSettings = {\n          magFilter: GLSettings.Texture.TextureMagFilter.Linear,\n          minFilter: GLSettings.Texture.TextureMinFilter.Linear,\n          format: GLSettings.Texture.TexelDataType.RGB\n        };\n        break;\n    }\n  }\n\n  /**\n   * Registers a glyph with it's location on the map.\n   */\n  registerGlyph(char: string, tex: SubTexture) {\n    if (this.dynamic) {\n      this.doRegisterGlyph(char, tex);\n    } else {\n      console.warn(\n        \"Attempted to register a new glyph with a non-dynamic FontMap\"\n      );\n    }\n  }\n\n  /**\n   * Validates if all the kerning specified is ready for the text\n   */\n  supportsKerning(text: string) {\n    // Loop through the characters in the text and see if all pairs of glyphs\n    // have their kerning determined and calculated.\n    for (let i = 1, iMax = text.length; i < iMax; ++i) {\n      const char = text[i];\n      const leftChar = text[i - 1];\n\n      // If the left or the right character is not found properly, then this text is not supported\n      // by the font map kerning yet.\n      if (this.kerning[leftChar]) {\n        if (!this.kerning[leftChar][char]) {\n          return false;\n        }\n      } else return false;\n    }\n\n    return true;\n  }\n}\n","/**\n * The purpose of this file is to provide a means to render glyphs to a grid and to provide\n * an approach to estimating kerning values for characters utilizing any custom embedded font\n * in a web page.\n */\nimport { WebGLStat } from \"../../gl/webgl-stat\";\nimport { scale2, Vec2 } from \"../../math\";\nimport { IResourceType, ResourceType } from \"../../types\";\nimport { IdentifyByKey } from \"../../util/identify-by-key\";\nimport { renderGlyph } from \"./glyph-renderer\";\nimport { svgToData } from \"./svg-to-data\";\n\nconst debug = require(\"debug\")(\"performance\");\nconst { floor } = Math;\n\ntype IGlyphRenderMetrics = {\n  [key: string]: { glyph: ImageData; glyphIndex: number };\n};\n\nexport type KerningPairs = {\n  [leftLetter: string]: { [rightLtter: string]: Vec2 };\n};\n\nexport type KerningInfo = {\n  all: string[];\n  pairs: KerningPairs;\n  spaceWidth: number;\n};\n\n/**\n * This function is calculate the offset of adjacent letters\n */\nasync function renderEachPair(\n  fontString: string,\n  fontSize: number,\n  pairs: KerningInfo,\n  calculateSpace: boolean\n) {\n  // Make the svg namespace to dynamically construct an svg\n  const svgNS = \"http://www.w3.org/2000/svg\";\n  // Calculate the max width the system can reliably handle. It can be considered that the WebGL texture limit would\n  // be the limit a canvas context could handle. It would make little sense for a browser to behave otherwise.\n  const contextWidth = WebGLStat.MAX_TEXTURE_SIZE / window.devicePixelRatio;\n  // Create the table\n  const cellWidth = fontSize * 2;\n  const cellHeight = fontSize * 1.3;\n  const maxColumns = floor(contextWidth / cellWidth);\n  // Generate the svg wrapper that will hold all of our elements\n  const table = document.createElementNS(svgNS, \"svg\");\n  table.setAttribute(\"width\", `${contextWidth}px`);\n  table.style.font = fontString;\n  table.style.position = \"relative\";\n  table.style.left = \"0px\";\n  table.style.top = `0px`;\n  // We will store the rows discovered so we can render them in batches to accommodate systems with smaller canvas limits\n  const rows = [];\n  const rowsPerBatch = Math.floor(contextWidth / cellHeight);\n  let currentBatch = 0;\n\n  let currentPair = 0;\n  let columnIndex = 0;\n  let currentRow;\n  let rowSpacer;\n  let remainingSpace = 0;\n\n  // Render each pair to cell of the table\n  while (currentPair < pairs.all.length) {\n    const tr = document.createElementNS(svgNS, \"g\");\n    currentRow = tr;\n    currentBatch = Math.floor(rows.length / rowsPerBatch);\n    tr.setAttribute(\n      \"transform\",\n      `translate(0, ${(rows.length - currentBatch * rowsPerBatch) *\n        cellHeight})`\n    );\n    rows.push(tr);\n\n    // We track how much room is remaining so we can inject an empty cell at the end to ensure\n    // the table doesn't stretch to fill\n    let remaining = contextWidth;\n\n    // Render each tr with col number of td\n    for (\n      columnIndex = 0;\n      columnIndex < maxColumns && currentPair < pairs.all.length;\n      columnIndex++\n    ) {\n      const td = document.createElementNS(svgNS, \"text\");\n      td.setAttribute(\"x\", `${columnIndex * cellWidth}`);\n      td.setAttribute(\"dy\", \"1em\");\n\n      const pair = pairs.all[currentPair];\n      currentPair++;\n      const leftStr = pair[0];\n      const rightStr = pair[1];\n\n      // Each td has two spans\n      const leftSpan = document.createElementNS(svgNS, \"tspan\");\n      const rightSpan = document.createElementNS(svgNS, \"tspan\");\n      leftSpan.setAttribute(\"fill\", \"#ff0000\");\n      rightSpan.setAttribute(\"fill\", \"#0000ff\");\n\n      leftSpan.textContent = leftStr;\n      rightSpan.textContent = rightStr;\n\n      td.appendChild(leftSpan);\n      td.appendChild(rightSpan);\n      tr.appendChild(td);\n\n      remaining -= cellWidth;\n    }\n\n    if (remaining >= 0) {\n      const td = document.createElementNS(svgNS, \"text\");\n      td.setAttribute(\"width\", `${remaining}px`);\n      tr.appendChild(td);\n      rowSpacer = td;\n    } else {\n      rowSpacer = null;\n    }\n\n    remainingSpace = remaining;\n  }\n\n  // Init the array for left-top corners for each letter in a pair\n  // [leftLetter->left, leftLetter->top, rightLetter->left, rightLetter->top]\n  const mins: [number, number, number, number][] = [];\n  for (let i = 0; i < pairs.all.length; i++) {\n    mins.push([\n      Number.MAX_SAFE_INTEGER,\n      Number.MAX_SAFE_INTEGER,\n      Number.MAX_SAFE_INTEGER,\n      Number.MAX_SAFE_INTEGER\n    ]);\n  }\n\n  // This stores how large the test character's rendering is that will be used for analyzing\n  // how large a space between characters is.\n  let testSpaceCharacterWidth = 0;\n  let doSpaceCheck = false;\n\n  // If the distance of a space is required, then we add in one more additional cell\n  if (calculateSpace) {\n    const testChar = \"M\";\n    const td = document.createElementNS(svgNS, \"text\");\n    td.setAttribute(\"dy\", \"1em\");\n    // td.style.display = \"table-cell\";\n    td.style.width = `${cellWidth}`;\n    td.style.height = `${cellHeight}`;\n    td.setAttribute(\"x\", `${cellWidth * columnIndex}`);\n    // td.style.overflow = \"hidden\";\n    td.style.font = fontString;\n\n    // The test character for the spacing will be the first character in the pairs we\n    // wanted to render.\n    const render = await renderGlyph(testChar, 128, 128, fontString);\n\n    if (render) {\n      // Keep how wide the test character is for after the kerning calculation so we can accurately\n      // determine how large a space is by subtracting the width of the character from the kerning distance.\n      testSpaceCharacterWidth = render.size[0];\n      // We create two of the test characters and place a space between them.\n      const leftSpan = document.createElementNS(svgNS, \"tspan\");\n      const spaceSpan = document.createElementNS(svgNS, \"tspan\");\n      const rightSpan = document.createElementNS(svgNS, \"tspan\");\n      leftSpan.setAttribute(\"fill\", \"#ff0000\");\n      rightSpan.setAttribute(\"fill\", \"#0000ff\");\n      leftSpan.textContent = testChar;\n      rightSpan.textContent = testChar;\n      spaceSpan.textContent = \" \";\n      td.appendChild(leftSpan);\n      td.appendChild(spaceSpan);\n      td.appendChild(rightSpan);\n\n      // If the last row has room for the rendering, then we just add to it\n      if (columnIndex < maxColumns && currentRow) {\n        currentRow.appendChild(td);\n        remainingSpace -= cellWidth;\n\n        // If a spacer at the end of the row is present, it should be adjusted to the size needed\n        // It should also be moved to the end of the child list\n        if (rowSpacer) {\n          rowSpacer.remove();\n\n          if (remainingSpace > 0) {\n            currentRow.style.width = `${remainingSpace}px`;\n            currentRow.appendChild(rowSpacer);\n          }\n        }\n      }\n\n      // Otherwise, we make a new row to inject into\n      else {\n        const tr = document.createElement(\"g\");\n        currentBatch = Math.floor(rows.length / rowsPerBatch);\n        tr.setAttribute(\n          \"transform\",\n          `translate(0, ${(rows.length - currentBatch * rowsPerBatch) *\n            cellHeight})`\n        );\n        currentRow = tr;\n        currentRow.appendChild(td);\n        rows.push(tr);\n\n        // Inject a spacer to fill the remaining space\n        rowSpacer = document.createElementNS(svgNS, \"text\");\n        tr.appendChild(rowSpacer);\n      }\n\n      // Add an additional min tracker for the check\n      mins.push([\n        Number.MAX_SAFE_INTEGER,\n        Number.MAX_SAFE_INTEGER,\n        Number.MAX_SAFE_INTEGER,\n        Number.MAX_SAFE_INTEGER\n      ]);\n\n      // Indicate the space check is indeed happening\n      doSpaceCheck = true;\n    }\n  }\n\n  // We now have all of the rows calculated and prepared. We now batch the rows together to fit within the max allowed\n  // canvas size and stitch the results together at the end.\n  const totalHeight = rows.length * cellHeight;\n  const totalCanvasBatches = Math.ceil(totalHeight / contextWidth);\n  let result: ImageData | null = null;\n\n  debug(\n    \"Rendering table canvas batches for font kerning analysis\",\n    pairs,\n    rows\n  );\n\n  for (let i = 0; i < totalCanvasBatches; ++i) {\n    // Gather the next batch to render\n    const rowBatch = rows.splice(0, rowsPerBatch);\n    const batchHeight = rowBatch.length * cellHeight;\n    // Adjust the height of the svg to cover allrows added\n    table.setAttribute(\"height\", `${batchHeight}px`);\n\n    // Clear out the table children\n    while (table.lastElementChild) table.lastElementChild.remove();\n\n    // Add the next row batch to the table\n    for (let k = 0, kMax = rowBatch.length; k < kMax; ++k) {\n      const row = rowBatch[k];\n      table.appendChild(row);\n    }\n\n    // Start the results with the first found result\n    if (!result) {\n      result = await svgToData(table);\n    }\n\n    // Additional results will need their results stitched into the initial result\n    else {\n      const stitchResult = await svgToData(table);\n\n      if (!stitchResult) {\n        console.warn(\n          \"Font Renderer: Could not generate image data for analyzing font kerning\"\n        );\n        continue;\n      }\n\n      const newBuffer: Uint8ClampedArray = new Uint8ClampedArray(\n        result.data.length + stitchResult.data.length\n      );\n\n      newBuffer.set(result.data);\n      newBuffer.set(stitchResult.data, result.data.length);\n      result = new ImageData(\n        newBuffer,\n        contextWidth * window.devicePixelRatio,\n        result.height + stitchResult.height\n      );\n    }\n  }\n\n  debug(\"Analyzing rendered data\", result);\n\n  // Width and height of each cell\n  const w = cellWidth * window.devicePixelRatio;\n  const h = cellHeight * window.devicePixelRatio;\n\n  if (result) {\n    // const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n    const data = result.data;\n    let pixel, r, g, b, min, index;\n\n    for (let y = 0, canvasHeight = result.height; y < canvasHeight; y++) {\n      for (let x = 0, canvasWidth = result.width; x < canvasWidth; x++) {\n        pixel = (canvasWidth * y + x) * 4;\n        r = data[pixel + 0];\n        g = data[pixel + 1];\n        b = data[pixel + 2];\n\n        // Get the index of the pair by the position of pixel\n        index = floor(y / h) * maxColumns + floor(x / w);\n\n        if (index < mins.length) {\n          min = mins[index];\n\n          // Red pixel is for left letter\n          if (r > 0 && g === 0 && b === 0) {\n            if (x < min[0]) min[0] = x;\n            if (y < min[1]) min[1] = y;\n          }\n\n          // Blue pixel is for right letter\n          if (r === 0 && g === 0 && b > 0) {\n            if (x < min[2]) min[2] = x;\n            if (y < min[3]) min[3] = y;\n          }\n        }\n      }\n    }\n\n    // Before letter processing, remove and analyze processing for the 'space' character\n    if (doSpaceCheck) {\n      const min = mins.pop();\n      if (min) {\n        const vec: Vec2 = [min[2] - min[0], 0];\n        const exact = scale2(vec, 1 / window.devicePixelRatio);\n        pairs.spaceWidth = Math.ceil(exact[0]) - testSpaceCharacterWidth;\n      }\n    }\n\n    // Set pairs map based on mins array\n    for (let i = 0, iMax = mins.length; i < iMax; i++) {\n      const pair = pairs.all[i];\n      const left = pair[0];\n      const right = pair[1];\n      const min = mins[i];\n      const vec: Vec2 = [min[2] - min[0], min[3] - min[1]];\n      const rightLetters = pairs.pairs[left];\n\n      if (rightLetters) {\n        // The calculations done on the space are in a devices pixel ratio. So we must\n        // adjust by that ratio to make it normal world space coordinates.\n        const exact = scale2(vec, 1 / window.devicePixelRatio);\n        rightLetters[right] = [Math.ceil(exact[0]), exact[1]];\n      }\n    }\n  } else {\n    console.warn(\n      \"html2canvas did not produce a valid canvas context to analyze\"\n    );\n  }\n\n  // table.remove();\n  debug(\"Kerning rendering analysis complete\", pairs.pairs);\n}\n\n/**\n * This function takes a string to return a map with next letters of each letter\n */\nfunction stringToPairs(\n  str: string,\n  existing: KerningPairs,\n  out?: KerningInfo\n): KerningInfo {\n  // Remove all the whitespace\n  str = str.replace(/\\s/g, \"\");\n  const all: string[] = (out && out.all) || [];\n  const pairs: KerningPairs = (out && out.pairs) || {};\n\n  for (let i = 0; i < str.length - 1; i++) {\n    const left = str[i];\n    const right = str[i + 1];\n    let neighbors = pairs[left];\n\n    if (!neighbors) {\n      neighbors = pairs[left] = {};\n    }\n\n    // Don't remake a pair for already existing pairs\n    if ((!existing[left] || !existing[left][right]) && !neighbors[right]) {\n      neighbors[right] = [0, 0];\n      all.push(`${left}${right}`);\n    }\n  }\n\n  return {\n    all,\n    pairs,\n    spaceWidth: 0\n  };\n}\n\nexport interface IFontOptions extends IdentifyByKey, IResourceType {\n  /** This resource must have it's type explcitly be set to a Font */\n  type: ResourceType.FONT;\n}\n\nexport class FontRenderer {\n  /**\n   * This function takes a sentence and grid info\n   * Returns a canvas with a list of glyphs where each glyph fits cnetered within each grid cell\n   */\n  makeBitmapGlyphs(\n    glyphs: string,\n    fontString: string,\n    fontSize: number\n  ): IGlyphRenderMetrics {\n    // It is used to store the metrics of each glyph\n    const map: IGlyphRenderMetrics = {};\n    // Get all unique glyphs provided\n    const uniqueGlyphs = new Set<string>();\n\n    for (let i = 0, iMax = glyphs.length; i < iMax; ++i) {\n      uniqueGlyphs.add(glyphs[i]);\n    }\n\n    // Get the characters to be rendered\n    const chars = Array.from(uniqueGlyphs.values());\n\n    for (let i = 0, iMax = chars.length; i < iMax; ++i) {\n      const char = chars[i];\n      const glyph = renderGlyph(char, fontSize * 2, fontSize * 2, fontString);\n\n      if (glyph) {\n        map[char] = {\n          glyph: glyph.data,\n          glyphIndex: i\n        };\n      } else {\n        console.warn(\n          \"Unable to render character\",\n          char,\n          \"to font map for rendering.\"\n        );\n      }\n    }\n\n    return map;\n  }\n\n  /**\n   * This performs a special rendering to guess kerning of letters of embedded fonts (fonts we don't\n   * have access to their raw font files). This will provide kerning information of a letter by providing\n   * the distance from a 'left' letter's top left  corner to the 'right' letter's topleft corner.\n   */\n  async estimateKerning(\n    str: string[],\n    fontString: string,\n    fontSize: number,\n    existing: KerningPairs,\n    includeSpace: boolean\n  ) {\n    // Get all of the new pairs of letters that need kerning infoz\n    const pairInfo: KerningInfo = {\n      all: [],\n      pairs: {},\n      spaceWidth: 0\n    };\n\n    debug(\"Estimating Kerning for\", str);\n\n    for (let i = 0, iMax = str.length; i < iMax; ++i) {\n      const s = str[i];\n      stringToPairs(s, existing, pairInfo);\n    }\n\n    // Only if there are new kerning needs do we actually need to run this method\n    if (pairInfo.all.length > 0 || includeSpace) {\n      await renderEachPair(fontString, fontSize, pairInfo, includeSpace);\n    }\n\n    return pairInfo;\n  }\n}\n","/**\n * This provides the methods needed to render single glyphs and receive the image data\n * for the rendering. The glyphs will be rendered within a given dimension range and centered.\n */\n\nconst { min, max } = Math;\nconst canvas = document.createElement(\"canvas\");\nlet ctx: CanvasRenderingContext2D;\n\n/**\n * Measures the contents of a canvas based on the canvas havinga pure black\n * background with rendered elements as white.\n */\nfunction measureBlackWhiteCanvasContents(canvas: CanvasRenderingContext2D) {\n  const { width, height } = canvas.canvas;\n  const imageData = canvas.getImageData(0, 0, width, height).data;\n  let r;\n\n  let found = false;\n  let minY = Number.MAX_SAFE_INTEGER;\n  let minX = Number.MAX_SAFE_INTEGER;\n  let maxX = Number.MIN_SAFE_INTEGER;\n  let maxY = Number.MIN_SAFE_INTEGER;\n\n  for (let i = 0; i < width; ++i) {\n    for (let k = 0; k < height; ++k) {\n      const redIndex = k * (width * 4) + i * 4;\n      r = imageData[redIndex];\n\n      if (r > 0.0) {\n        found = true;\n        minY = min(minY, k);\n        minX = min(minX, i);\n        maxX = max(maxX, i);\n        maxY = max(maxY, k);\n      }\n    }\n  }\n\n  if (!found) {\n    return null;\n  }\n\n  // The identified pixel needs to be encased and not a direct target\n  minY -= 1;\n  maxY += 2;\n  maxX += 2;\n  minX -= 1;\n\n  minY = max(minY, 0);\n  minX = max(minX, 0);\n\n  return { minX, minY, maxX, maxY };\n}\n\n/**\n * Renders a glyph centered within the provided rectangle size. This also provides the size of the\n * rendered glyph along with a vector pointing to the topleft of the glyph within then rectangle.\n * This vector can be used to find any corner of the glyph as the glyph is centered within the\n * rectangle's space.\n */\nexport function renderGlyph(\n  glyph: string,\n  width: number,\n  height: number,\n  font: string\n) {\n  // Ensure we're rendering a single characters\n  glyph = glyph[0];\n\n  if (canvas.width < width || canvas.height < height) {\n    canvas.width = width;\n    canvas.height = height;\n  }\n\n  if (!ctx) {\n    const context = canvas.getContext(\"2d\");\n    if (context) ctx = context;\n    else return null;\n  }\n\n  // Draw the glyph\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.font = font;\n  ctx.fillStyle = \"white\";\n  ctx.fillText(glyph, width / 2, height / 2);\n\n  // Get the metrics of the glyph within the rendering\n  const dimensions = measureBlackWhiteCanvasContents(ctx);\n\n  if (!dimensions) {\n    const data = ctx.getImageData(0, 0, 1, 1);\n\n    return {\n      data,\n      size: [0, 0]\n    };\n  }\n\n  // Copy the data from the rendering\n  const glyphWidth = dimensions.maxX - dimensions.minX;\n  const glyphHeight = dimensions.maxY - dimensions.minY;\n\n  const data = ctx.getImageData(\n    dimensions.minX,\n    dimensions.minY,\n    glyphWidth,\n    glyphHeight\n  );\n\n  return {\n    data,\n    size: [glyphWidth, glyphHeight]\n  };\n}\n","import {\n  Attribute,\n  Geometry,\n  GLSettings,\n  Material,\n  MaterialUniformType,\n  Model,\n  RenderTarget,\n  Scene,\n  Texture,\n  WebGLRenderer\n} from \"../../gl\";\nimport { Bounds } from \"../../math/primitives/bounds\";\nimport { ImageRasterizer } from \"../../resources/texture/image-rasterizer\";\nimport { VideoTextureMonitor } from \"../../resources/texture/video-texture-monitor\";\nimport { Atlas, IAtlasResource } from \"./atlas\";\nimport { IAtlasResourceRequest } from \"./atlas-resource-request\";\nimport { IPackNodeDimensions, PackNode } from \"./pack-node\";\nimport { SubTexture } from \"./sub-texture\";\n\nconst debug = require(\"debug\")(\"performance\");\n\nconst ZERO_IMAGE: SubTexture = new SubTexture({\n  aspectRatio: 0,\n  atlasBL: [0, 0],\n  atlasBR: [0, 0],\n  texture: null,\n  atlasTL: [0, 0],\n  atlasTR: [0, 0],\n  heightOnAtlas: 0,\n  isValid: false,\n  pixelHeight: 0,\n  pixelWidth: 0,\n  widthOnAtlas: 0\n});\n\n/**\n * Determines if a SubTexture is a valid SubTexture for rendering\n */\nfunction isValidImage(image?: SubTexture): image is SubTexture {\n  if (image && image.isValid) {\n    if (image.pixelWidth && image.pixelHeight) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Defines a manager of atlas', which includes generating the atlas and producing\n * textures defining those pieces of atlas.\n */\nexport class AtlasManager {\n  /** Stores all of the generated atlas' in a lookup by name */\n  allAtlas = new Map<string, Atlas>();\n  /**\n   * This will be the renderer this manager is acting on behalf. This is used internally to perform some GL actions\n   * without messing up the sync state of the gl context with the renderer.\n   */\n  renderer?: WebGLRenderer;\n\n  /**\n   * Creates a new atlas that resources can be loaded into.\n   *\n   * @param resources The images with their image path set to be loaded into the atlas.\n   *               Images that keep an atlas ID of null indicates the image did not load\n   *               correctly\n   *\n   * @return {Texture} The texture that is created as our atlas. The images injected\n   *                   into the texture will be populated with the atlas'\n   */\n  async createAtlas(options: IAtlasResource) {\n    // Create the new Atlas object that tracks all of our atlas' metrics\n    const atlas = new Atlas(options);\n    // Make the atlas identifiable by it's name\n    this.allAtlas.set(atlas.id, atlas);\n\n    debug(\"Atlas Created-> %o\", atlas);\n\n    return atlas;\n  }\n\n  /**\n   * Free ALL resources under this manager\n   */\n  destroy() {\n    this.allAtlas.forEach(value => value.destroy());\n  }\n\n  /**\n   * Disposes of the resources the atlas held and makes the atlas invalid for use\n   *\n   * @param atlasName\n   */\n  destroyAtlas(atlasName: string) {\n    const atlas = this.allAtlas.get(atlasName);\n\n    if (atlas) {\n      atlas.destroy();\n    }\n  }\n\n  private setDefaultImage(image: SubTexture, atlasName: string) {\n    image = Object.assign(image, ZERO_IMAGE, { atlasReferenceID: atlasName });\n    return image;\n  }\n\n  /**\n   * This loads, packs, and draws the indicated image into the specified canvas\n   * using the metrics that exists for the specified atlas.\n   *\n   * @param request The image who should have it's image path loaded\n   * @param atlasName The name of the atlas to make the packing work\n   * @param canvas The canvas we will be drawing into to generate the complete image\n   *\n   * @return {Promise<boolean>} Promise that resolves to if the image successfully was drawn or not\n   */\n  private async draw(\n    atlas: Atlas,\n    request: IAtlasResourceRequest\n  ): Promise<boolean> {\n    const atlasName = atlas.id;\n\n    // We don't draw or process requests to resources being disposed.\n    if (request.disposeResource) {\n      return true;\n    }\n\n    // First ensure the atlas does not have this resource referenced yet\n    const existing = atlas.resourceReferences.get(request.source);\n\n    // If the resource still has it's reference, we exit immediately to prevent drawing the resource into the atlas twice\n    if (existing) {\n      return true;\n    }\n\n    // Immediately register the resource with a subtexture to prevent duplicate\n    // processing.\n    request.texture = request.texture || new SubTexture();\n    request.texture.isValid = true;\n    atlas.resourceReferences.set(request.source, {\n      subtexture: request.texture,\n      count: 0\n    });\n\n    // First we must load the image\n    // Make a buffer to hold our new image\n    // Load the image into memory, default to keeping the alpha channel\n    const loadedImage: TexImageSource | null = await this.loadImage(request);\n    // Get the sub texture that is going to be applied to the atlas\n    const texture = request.texture;\n\n    // Only a non-null image means the image loaded correctly\n    if (loadedImage && isValidImage(texture)) {\n      // Now we create a Rectangle to store the image dimensions\n      const rect: Bounds<never> = new Bounds({\n        bottom: texture.pixelHeight,\n        left: 0,\n        right: texture.pixelWidth,\n        top: 0\n      });\n\n      // Create ImageDimension to insert into our atlas mapper\n      const dimensions: IPackNodeDimensions<SubTexture> = {\n        data: texture,\n        bounds: rect\n      };\n\n      // Auto add a buffer in\n      dimensions.bounds.width += 1;\n      dimensions.bounds.height += 1;\n      // Get the atlas map node\n      let packing: PackNode<SubTexture> = atlas.packing;\n      // Store the node resulting from the insert operation\n      let insertedNode: PackNode<SubTexture> | null = packing.insert(\n        dimensions\n      );\n\n      // If we failed to insert the image, let's repack the atlas and attempt a second round\n      // of packing. We can only repack if the system has provided the manager a renderer to work with.\n      if (!insertedNode) {\n        // Repack the atlas\n        const success = this.repackResources(atlas);\n\n        if (!success) {\n          console.error(\n            \"Repacking the atlas failed. Some resources may be in an undefined state. Consider making another atlas.\"\n          );\n          return false;\n        }\n\n        // Attempt to insert the item again\n        packing = atlas.packing;\n        insertedNode = packing.insert(dimensions);\n      }\n\n      // If the result was NULL we did not successfully insert the image into any atlas\n      if (insertedNode) {\n        // Apply the image to the node\n        insertedNode.data = texture;\n\n        // Set our image's atlas properties\n        PackNode.applyToSubTexture(packing, insertedNode, texture, {\n          top: 0,\n          left: 0,\n          right: 1,\n          bottom: 1\n        });\n\n        // Track the subtexture with the source that created it.\n        texture.texture = atlas.texture;\n        texture.source = loadedImage;\n        texture.atlasRegion = {\n          ...insertedNode.bounds,\n          y: atlas.height - insertedNode.bounds.y - insertedNode.bounds.height\n        };\n\n        // Now specify the update region to be applied to the texture\n        atlas.texture.update(loadedImage, texture.atlasRegion);\n\n        // If this is a video element, we must make a monitor for it to keep the texture in sync with the videos time\n        // location\n        if (loadedImage instanceof HTMLVideoElement) {\n          texture.video = {\n            monitor: new VideoTextureMonitor(loadedImage, texture)\n          };\n        }\n\n        // We have finished inserting\n        return true;\n      } else {\n        // Log an error\n        console.error(`Could not fit resource into atlas`, request);\n        request.texture = this.setDefaultImage(texture, atlasName);\n        return false;\n      }\n    }\n\n    // Since the image did not fit, we now get the atlas to consolidate all of it's existing resources\n    // by removing unused images that were placed in the atlas but were flagged as no longer used.\n    else {\n      if (texture && !texture.isValid) {\n        debug(\"Resource was invalidated during load:\", request);\n      } else {\n        // Log an error and load a default sub texture\n        console.error(`Could not load resource:`, request);\n      }\n\n      if (request.texture) {\n        request.texture = this.setDefaultImage(request.texture, atlasName);\n      }\n\n      return false;\n    }\n  }\n\n  /**\n   * Retrieves the actual Atlas object for a given resource id\n   */\n  getAtlasTexture(resourceId: string): Atlas | undefined {\n    return this.allAtlas.get(resourceId);\n  }\n\n  /**\n   * This takes in any atlas resource and ensures the image is available and ready to\n   * render.\n   */\n  private async loadImage(\n    resource: IAtlasResourceRequest\n  ): Promise<TexImageSource | null> {\n    const subTexture = resource.texture || new SubTexture();\n    const source = resource.source;\n    resource.texture = subTexture;\n    if (resource.texture.isValid === false) return null;\n\n    if (source instanceof HTMLImageElement) {\n      let image = await new Promise<TexImageSource | null>(resolve => {\n        if (!(source instanceof HTMLImageElement)) return;\n        const image: HTMLImageElement | undefined = source;\n\n        if (image.width && image.height) {\n          ImageRasterizer.calculateImageSize(image);\n          subTexture.pixelWidth = image.width;\n          subTexture.pixelHeight = image.height;\n          subTexture.aspectRatio = image.width / image.height;\n          resolve(image);\n          return;\n        }\n\n        if (image) {\n          image.onload = function() {\n            subTexture.pixelWidth = image.width;\n            subTexture.pixelHeight = image.height;\n            subTexture.aspectRatio = image.width / image.height;\n            image.onload = null;\n            resolve(image);\n          };\n\n          image.onerror = function() {\n            image.onload = null;\n            resolve(null);\n          };\n        } else {\n          resolve(null);\n        }\n      });\n\n      if (\n        image &&\n        resource.rasterizationScale !== undefined &&\n        resource.rasterizationScale !== 1\n      ) {\n        image = await ImageRasterizer.resizeImage(\n          image,\n          resource.rasterizationScale || 1\n        );\n      }\n\n      return image;\n    } else if (source instanceof HTMLVideoElement) {\n      if (source.videoHeight === 0 || source.videoWidth === 0) {\n        console.warn(\n          \"Video requests to the atlas manager MUST have the video completely loaded and ready for loading\",\n          \"There are too many caveats to automate video loading at this low of a level to have it prepped properly for\",\n          \"use in the texture for all browsers. Consider handling video resources at the layer level to have them\",\n          \"prepped for use.\"\n        );\n        return null;\n      }\n\n      // At this point, the video width and height should definitely be established and can be applied to the texture\n      subTexture.pixelWidth = source.videoWidth;\n      subTexture.pixelHeight = source.videoHeight;\n      subTexture.aspectRatio = source.videoWidth / source.videoHeight;\n\n      // Return the video here to indicate a successful load\n      return source;\n    } else if (typeof source === \"string\") {\n      const dataURL = source;\n\n      let image = await new Promise<TexImageSource | null>(resolve => {\n        const image = new Image();\n\n        image.onload = function() {\n          subTexture.pixelWidth = image.width;\n          subTexture.pixelHeight = image.height;\n          subTexture.aspectRatio = image.width / image.height;\n          image.onload = null;\n          resolve(image);\n        };\n\n        image.onerror = function() {\n          resolve(null);\n        };\n\n        image.src = dataURL;\n      });\n\n      if (\n        image &&\n        resource.rasterizationScale !== undefined &&\n        resource.rasterizationScale !== 1\n      ) {\n        image = await ImageRasterizer.resizeImage(\n          image,\n          resource.rasterizationScale || 1\n        );\n      }\n    } else {\n      let image: TexImageSource = source;\n\n      if (\n        image &&\n        resource.rasterizationScale !== undefined &&\n        resource.rasterizationScale !== 1\n      ) {\n        image = await ImageRasterizer.resizeImage(\n          image,\n          resource.rasterizationScale || 1\n        );\n      }\n\n      return image;\n    }\n\n    return null;\n  }\n\n  /**\n   * When this is triggered, the atlas will examine all of it's packing and repack it's resources\n   * on the texture for the atlas thus eliminating any dead space from resources that have been disposed.\n   *\n   * This process will cause the atlas to generate a new Texture to utilize and dispose of the old texture\n   * to allow for the atlas to redraw it's texture using GPU operations which is much faster than a CPU operation\n   * of generating the texture.\n   */\n  private repackResources(atlas: Atlas) {\n    if (!this.renderer) {\n      console.warn(\n        \"Attempted to repack resources for an atlas, but no renderer has been specified for this manager yet.\"\n      );\n      return false;\n    }\n\n    // Flatten the nodes into a list to make them easier to work with\n    const toProcess = [atlas.packing];\n    const allNodes = [];\n    let index = 0;\n    // Track the old bounds position information. Will be able to look up via the node's bounds object as it will get\n    // reused for the remapping.\n    const oldBounds = new Map<Bounds<any>, Bounds<any>>();\n\n    // We process all of the nodes in the current atlas and flatten out the tree to merely the bounds of each node\n    while (index < toProcess.length) {\n      const next = toProcess[index];\n      index++;\n\n      // Only gather nodes that have not been invalidated.\n      if (next.data && next.data.texture) {\n        allNodes.push(next);\n        oldBounds.set(next.bounds, new Bounds<any>(next.bounds));\n      }\n\n      if (next.child[0]) toProcess.push(next.child[0]);\n      if (next.child[1]) toProcess.push(next.child[1]);\n    }\n\n    // Place the nodes with the largest features first\n    allNodes.sort(\n      (a, b) =>\n        Math.max(b.bounds.width, b.bounds.height) -\n        Math.max(a.bounds.width, a.bounds.height)\n    );\n\n    // If there are no valid nodes left, then we simply clear out the root pack node and let the texture repack anew.\n    if (allNodes.length <= 0) {\n      atlas.packing = new PackNode<SubTexture>(0, 0, atlas.width, atlas.height);\n      return true;\n    }\n\n    // We now know at this point a new texture will be needed to render the newly packed layout\n    // Simply copy all of the settings of the existing texture\n    const newAtlasTexture = new Texture(atlas.texture);\n    // Initialize the texture with blank information\n    newAtlasTexture.data = {\n      buffer: new Uint8Array(atlas.width * atlas.height * 4),\n      width: atlas.width,\n      height: atlas.height\n    };\n\n    // We now have all of the valid nodes and their respective original bounds. We will now repack these nodes to\n    // get the new locations of them all.\n    const rootNode = new PackNode<SubTexture>(0, 0, atlas.width, atlas.height);\n    let failedRepack = false;\n\n    for (let i = 0, iMax = allNodes.length; i < iMax; ++i) {\n      const node = allNodes[i];\n\n      if (!node.data) {\n        console.warn(\"Attempted to repack a node with no valid data.\");\n        continue;\n      }\n\n      node.bounds.x = 0;\n      node.bounds.y = 0;\n\n      const newNode = rootNode.insert({\n        bounds: node.bounds,\n        data: node.data\n      });\n\n      if (!newNode) {\n        console.warn(\n          \"When repacking the atlas, an existing node was unable to be repacked\",\n          node\n        );\n        failedRepack = true;\n        continue;\n      }\n\n      // Apply the node to the subtexture to let the subtexture know it's new coordinates in the render space. This\n      // sub texture should be the same subtexture object the node originally was associated with. This way all\n      // references using this subtexture object will immediately have the new subtexture information.\n      PackNode.applyToSubTexture(rootNode, newNode, node.data);\n    }\n\n    if (failedRepack) {\n      return false;\n    }\n\n    // Now we can map all of the nodes to quads\n    // Positions = Total nodes * Vec2 for xy coords * 6 vertices per quad\n    const positions = new Float32Array(allNodes.length * 2 * 6);\n    // Texture coordinates = Total nodes * Vec2 for xy coord positions * 6 vertices per quad\n    const texCoords = new Float32Array(allNodes.length * 2 * 6);\n    // We now produce the geometry that will render the old texture atlas elements to the new texture atlas. The texture\n    // coordinates will be the coordinates located on the old texture. The position of the vertices will be the new pack\n    // location to be rendered on the new texture.\n    const tempTexture = new SubTexture();\n\n    for (let i = 0, iMax = allNodes.length; i < iMax; ++i) {\n      const node = allNodes[i];\n      const previousBounds = oldBounds.get(node.bounds);\n      const nextTexture = node.data;\n\n      if (!previousBounds || !nextTexture) {\n        console.warn(\n          \"While repacking there was an issue finding the previous bounds and the next texture to use\",\n          previousBounds,\n          nextTexture\n        );\n        continue;\n      }\n\n      // We need the atlas coordinates of the previous bounds so we can make sure we keep the coordinate system\n      // consistent with the new packing\n      PackNode.applyToSubTexture(rootNode, previousBounds, tempTexture);\n      // Get the index of data for the first vertex for the quad for the node we want to render\n      const startIndex = i * 2 * 6;\n\n      // The position is the location within clip space the new packing will occur. We must convert the coords to clip\n      // space simply by x * 2 - 1 as clip space is [-1, 1] so it's '2' wide while tex coords are 0 - 1.\n      // Set the xy coordinate within the new texture\n      positions[startIndex] = nextTexture.atlasTL[0] * 2 - 1;\n      positions[startIndex + 1] = nextTexture.atlasTL[1] * 2 - 1;\n      positions[startIndex + 2] = nextTexture.atlasTR[0] * 2 - 1;\n      positions[startIndex + 3] = nextTexture.atlasTR[1] * 2 - 1;\n      positions[startIndex + 4] = nextTexture.atlasBL[0] * 2 - 1;\n      positions[startIndex + 5] = nextTexture.atlasBL[1] * 2 - 1;\n\n      // Bottom triangle\n      positions[startIndex + 6] = nextTexture.atlasTR[0] * 2 - 1;\n      positions[startIndex + 7] = nextTexture.atlasTR[1] * 2 - 1;\n      positions[startIndex + 8] = nextTexture.atlasBR[0] * 2 - 1;\n      positions[startIndex + 9] = nextTexture.atlasBR[1] * 2 - 1;\n      positions[startIndex + 10] = nextTexture.atlasBL[0] * 2 - 1;\n      positions[startIndex + 11] = nextTexture.atlasBL[1] * 2 - 1;\n\n      // The Tex coordinate is the tex coords within the previous position\n      // Top triangle\n      texCoords[startIndex] = tempTexture.atlasTL[0];\n      texCoords[startIndex + 1] = tempTexture.atlasTL[1];\n      texCoords[startIndex + 2] = tempTexture.atlasTR[0];\n      texCoords[startIndex + 3] = tempTexture.atlasTR[1];\n      texCoords[startIndex + 4] = tempTexture.atlasBL[0];\n      texCoords[startIndex + 5] = tempTexture.atlasBL[1];\n\n      // Bottom triangle\n      texCoords[startIndex + 6] = tempTexture.atlasTR[0];\n      texCoords[startIndex + 7] = tempTexture.atlasTR[1];\n      texCoords[startIndex + 8] = tempTexture.atlasBR[0];\n      texCoords[startIndex + 9] = tempTexture.atlasBR[1];\n      texCoords[startIndex + 10] = tempTexture.atlasBL[0];\n      texCoords[startIndex + 11] = tempTexture.atlasBL[1];\n\n      // Set the subtexture's texture to the new texture\n      nextTexture.texture = newAtlasTexture;\n    }\n\n    // Create a model to render our newly specified geometry. Our vertices will already be in clip\n    // space so no camera transforms will be needed.\n    const geometry = new Geometry();\n    const positionAttr = new Attribute(positions, 2);\n    const texAttr = new Attribute(texCoords, 2);\n    geometry.addAttribute(\"position\", positionAttr);\n    geometry.addAttribute(\"texCoord\", texAttr);\n\n    // Make a simple material that will handle the\n    const material = new Material({\n      culling: GLSettings.Material.CullSide.NONE,\n      uniforms: {\n        texture: { type: MaterialUniformType.TEXTURE, value: atlas.texture }\n      },\n      fragmentShader: `\n        precision highp float;\n\n        uniform sampler2D texture;\n        varying vec2 _texCoord;\n\n        void main() {\n          gl_FragColor = texture2D(texture, _texCoord);\n        }\n      `,\n      vertexShader: `\n        precision highp float;\n\n        attribute vec2 position;\n        attribute vec2 texCoord;\n        varying vec2 _texCoord;\n\n        void main() {\n          _texCoord = texCoord;\n          gl_Position = vec4(position, 0.0, 1.0);\n        }\n      `\n    });\n\n    const model = new Model(geometry, material);\n    model.vertexCount = allNodes.length * 6;\n    model.drawMode = GLSettings.Model.DrawMode.TRIANGLES;\n\n    // Now we create a render target that will render to our new texture\n    const renderTarget = new RenderTarget({\n      buffers: {\n        color: newAtlasTexture\n      },\n      retainTextureTargets: true\n    });\n\n    // Make a dummy scene to cram our model into\n    const scene = new Scene();\n    scene.add(model);\n    // Now perform the rendering to our new texture. This should effectively make our new texture the newly packed\n    // version of the previous atlas texture.\n    this.renderer.setRenderTarget(renderTarget);\n    this.renderer.setViewport(this.renderer.getFullViewport());\n    this.renderer.setScissor(this.renderer.getFullViewport());\n    this.renderer.render(scene, renderTarget);\n    // Clean up anything that will try to retain GPU resources\n    material.dispose();\n    geometry.dispose();\n    renderTarget.dispose();\n    // The old texture is no longer needed now!\n    atlas.texture.dispose();\n    // Apply the new texture to our atlas. The texture should already be applied to all of the valid\n    // subtextures already.\n    atlas.texture = newAtlasTexture;\n    // Set the new packing node as the packing scheme for the texture since it was recalculated. This will allow\n    // new nodes to use the new pack layout.\n    atlas.packing = rootNode;\n\n    return true;\n  }\n\n  /**\n   * This targets an existing atlas and attempts to update it with the provided atlas resources.\n   */\n  async updateAtlas(atlasName: string, requests: IAtlasResourceRequest[]) {\n    const atlas = this.allAtlas.get(atlasName);\n\n    if (atlas) {\n      const promises = [];\n\n      for (let i = 0, iMax = requests.length; i < iMax; ++i) {\n        const request = requests[i];\n\n        if (!request.disposeResource) {\n          promises.push(this.draw(atlas, request));\n        }\n      }\n\n      await Promise.all(promises);\n\n      // Now that all of the requests have been processed, we can now update reference counting for the\n      // underlying resources.\n      for (let i = 0, iMax = requests.length; i < iMax; ++i) {\n        const request = requests[i];\n\n        if (request.disposeResource) atlas.stopUsingResource(request);\n        else atlas.useResource(request);\n      }\n\n      // Now resolve the reference counting with the atlas so the atlas can invalidate textures and flag\n      // space on the atlas as available for rendering again.\n      atlas.resolveResources();\n    } else {\n      console.warn(\n        \"Can not update non-existing atlas:\",\n        atlasName,\n        \"These resources will not be loaded:\",\n        requests\n      );\n    }\n\n    return atlas;\n  }\n}\n","let canvas: CanvasRenderingContext2D | null;\n\nexport interface IImageRasterizedMetrics {\n  canvas: HTMLCanvasElement;\n  height: number;\n  width: number;\n}\n\nexport class ImageRasterizer {\n  /**\n   * This loops until our canvas context is available\n   */\n  static async awaitContext() {\n    // Iterate till the browser provides a valid canvas to render elements into\n    while (!canvas) {\n      this.getContext();\n      await new Promise(resolve => setTimeout(resolve, 10));\n    }\n  }\n\n  /**\n   * Attempts to populate the 'canvas' context for rendering images offscreen.\n   */\n  static getContext() {\n    if (!canvas) {\n      canvas = document.createElement(\"canvas\").getContext(\"2d\");\n    }\n  }\n\n  /**\n   * This ensures an image is renderable at the current moment. This draws the image to a canvas partially\n   * to help the image 'warm up' within some browser contexts to ensure the image can be used as a drawable item.\n   */\n  static async calculateImageSize(image: HTMLImageElement) {\n    await this.awaitContext();\n\n    if (!canvas) {\n      console.warn(\n        \"The Image rasterizer was unable to establish a valid canvas context. Please ensure the system supports contexts and ensure the document is ready first.\"\n      );\n      return;\n    }\n\n    if (image.width === 0 || image.height === 0) {\n      console.warn(\n        \"Images provided shoud have valid dimensions! Please ensure the image is loaded first.\"\n      );\n      return;\n    }\n\n    // Just make sure th canvas is available\n    canvas.canvas.width = 100;\n    canvas.canvas.height = 100;\n    // Render the image into our canvas merely to ensure the image can be rendered\n    // This action often 'warms up' images such as images that have a data URL instead of a path\n    canvas.drawImage(image, 0, 0, 1, 1);\n\n    return [image.width, image.height];\n  }\n\n  /**\n   * This resizes the input image by the provided scale.\n   */\n  static async resizeImage(image: TexImageSource, scale: number) {\n    await this.awaitContext();\n\n    if (!canvas) {\n      console.warn(\n        \"The Image rasterizer was unable to establish a valid canvas context. Please ensure the system supports contexts and ensure the document is ready first.\"\n      );\n\n      return image;\n    }\n\n    if (image.width === 0 || image.height === 0) {\n      console.warn(\n        \"Images provided shoud have valid dimensions! Please ensure the image is loaded first.\"\n      );\n\n      return image;\n    }\n\n    // Make the canvas the proper size to render the resized image\n    canvas.canvas.width = Math.floor(image.width * scale);\n    canvas.canvas.height = Math.floor(image.height * scale);\n\n    // Render the image into our canvas with the resizing taking place\n    if (image instanceof ImageData) {\n      canvas.putImageData(\n        image,\n        0,\n        0,\n        0,\n        0,\n        canvas.canvas.width,\n        canvas.canvas.height\n      );\n    } else {\n      canvas.drawImage(image, 0, 0, canvas.canvas.width, canvas.canvas.height);\n    }\n\n    // Make our canvas a data url for another image to become\n    const out = new Image();\n    out.src = canvas.canvas.toDataURL(\"image/png\");\n    // Ensure the image is renderable at this moment\n    await ImageRasterizer.calculateImageSize(out);\n\n    return out;\n  }\n}\n","import { WebGLRenderer } from \"../../gl\";\nimport { Texture } from \"../../gl/texture\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport { ILayerProps, Layer } from \"../../surface\";\nimport { BaseIOExpansion } from \"../../surface/layer-processing/base-io-expansion\";\nimport { InstanceIOValue, IResourceContext, ResourceType } from \"../../types\";\nimport { nextFrame } from \"../../util\";\nimport {\n  BaseResourceManager,\n  BaseResourceOptions\n} from \"../base-resource-manager\";\nimport { Atlas, IAtlasResource, isAtlasResource } from \"./atlas\";\nimport { AtlasManager } from \"./atlas-manager\";\nimport { IAtlasResourceRequest } from \"./atlas-resource-request\";\nimport { subTextureIOValue } from \"./sub-texture\";\nimport { TextureIOExpansion } from \"./texture-io-expansion\";\n\nexport interface IAtlasResourceManagerOptions {\n  /** This is the atlas manager that handles operations with our atlas' */\n  atlasManager?: AtlasManager;\n}\n\n/**\n * This class is responsible for tracking resources requested to be placed on an Atlas.\n * This makes sure the resource is uploaded and then properly cached so similar requests\n * return already existing resources. This also manages instances waiting for the resource\n * to be made available.\n */\nexport class AtlasResourceManager extends BaseResourceManager<\n  IAtlasResource,\n  IAtlasResourceRequest\n> {\n  /** This is the resources generated by this manager */\n  resources = new Map<string, Atlas>();\n  /** This is the atlas manager that handles operations with our atlas' */\n  atlasManager: AtlasManager;\n  /** This stores all of the requests awaiting dequeueing */\n  private requestQueue = new Map<string, IAtlasResourceRequest[]>();\n  /**\n   * This tracks if a resource is already in the request queue. This also stores ALL instances awaiting the resource.\n   */\n  private requestLookup = new Map<\n    string,\n    Map<IAtlasResourceRequest, [Layer<any, any>, Instance][]>\n  >();\n\n  /** Override the get and set of the webgl renderer so we can also apply it to the atlas manager object */\n  get webGLRenderer() {\n    return this._webGLRenderer;\n  }\n  set webGLRenderer(val: WebGLRenderer | undefined) {\n    this._webGLRenderer = val;\n    this.atlasManager.renderer = val;\n  }\n  private _webGLRenderer?: WebGLRenderer;\n\n  constructor(options?: IAtlasResourceManagerOptions) {\n    super();\n    this.atlasManager = (options && options.atlasManager) || new AtlasManager();\n  }\n\n  /**\n   * This dequeues all instance requests for a resource and processes the request which will\n   * inevitably make the instance active\n   */\n  async dequeueRequests() {\n    // This flag will be modified to reflect if a dequeue operation has occurred\n    let didDequeue = false;\n\n    const resourceRequestsWithKey: [string, IAtlasResourceRequest[]][] = [];\n\n    this.requestQueue.forEach((requests, resourceKey) => {\n      resourceRequestsWithKey.push([resourceKey, requests]);\n    });\n\n    this.requestQueue.clear();\n\n    for (const [targetAtlas, requests] of resourceRequestsWithKey) {\n      if (requests.length > 0) {\n        // We did dequeue\n        didDequeue = true;\n        // Pull out all of the requests into a new array and empty the existing queue to allow the queue to register\n        // New requests while this dequeue is being processed\n        const allRequests = requests.slice(0);\n        // Empty the queue to begin taking in new requests as needed\n        requests.length = 0;\n        // Tell the atlas manager to update with all of the requested resources\n        await this.atlasManager.updateAtlas(targetAtlas, allRequests);\n        // Get the requests for the given atlas\n        const atlasRequests = this.requestLookup.get(targetAtlas);\n\n        if (atlasRequests) {\n          // Once the manager has been updated, we can now flag all of the instances waiting for the resources\n          // As active, which should thus trigger an update to the layers to perform a diff for each instance\n          allRequests.forEach(request => {\n            const requesters = atlasRequests.get(request);\n            atlasRequests.delete(request);\n\n            if (requesters && !request.disposeResource) {\n              for (let i = 0, iMax = requesters.length; i < iMax; ++i) {\n                const [layer, instance] = requesters[i];\n                // If the instance is still associated with buffer locations, then the instance can be activated. Having\n                // A buffer location is indicative the instance has not been deleted.\n                if (layer.managesInstance(instance)) {\n                  // Make sure the instance is active\n                  instance.active = true;\n                }\n              }\n\n              // Do a delay to next frame before we do our resource trigger so we can see any lingering updates get\n              // applied to the instance's rendering\n              nextFrame(() => {\n                const triggered = new Set();\n\n                for (let i = 0, iMax = requesters.length; i < iMax; ++i) {\n                  const instance = requesters[i][1];\n\n                  if (!triggered.has(instance)) {\n                    triggered.add(instance);\n                    instance.active = true;\n                    instance.resourceTrigger();\n                  }\n                }\n              });\n            }\n          });\n        }\n      }\n    }\n\n    return didDequeue;\n  }\n\n  /**\n   * Free ALL resources managed under this resource manager\n   */\n  destroy() {\n    this.atlasManager.destroy();\n  }\n\n  /**\n   * System requests a resource get's destroyed here\n   */\n  destroyResource(init: BaseResourceOptions) {\n    const resource = this.resources.get(init.key);\n    if (!resource) return;\n    this.atlasManager.destroyAtlas(init.key);\n    this.resources.delete(init.key);\n  }\n\n  /**\n   * This retrieves the actual atlas texture that should be applied to a uniform's\n   * value.\n   */\n  getAtlasTexture(key: string): Texture | null {\n    const atlas = this.atlasManager.getAtlasTexture(key);\n\n    if (atlas) {\n      return atlas.texture;\n    }\n\n    return null;\n  }\n\n  /**\n   * Get generated resources from this manager\n   */\n  getResource(resourceKey: string) {\n    return this.resources.get(resourceKey) || null;\n  }\n\n  /**\n   * Return the IO Expander necessary to handle the resurce type this manager is attempting to provide for layers.\n   */\n  getIOExpansion(): BaseIOExpansion[] {\n    return [new TextureIOExpansion(ResourceType.ATLAS, this)];\n  }\n\n  /**\n   * Initialize the atlas resources requested for construction\n   */\n  async initResource(resource: BaseResourceOptions) {\n    if (isAtlasResource(resource)) {\n      const atlas = await this.atlasManager.createAtlas(resource);\n      this.resources.set(resource.key, atlas);\n    }\n  }\n\n  /**\n   * This is a request for atlas texture resources. It will produce either the coordinates needed to\n   * make valid texture lookups, or it will trigger a loading of resources to an atlas and cause an\n   * automated deactivation and reactivation of the instance.\n   */\n  request<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>,\n    instance: Instance,\n    request: IAtlasResourceRequest,\n    _context?: IResourceContext\n  ): InstanceIOValue {\n    const resourceContext = request.key || \"\";\n    const texture = request.texture;\n\n    // If the texture is ready and available, then we simply return the IO values\n    if (texture) {\n      return subTextureIOValue(texture);\n    }\n\n    // If a request is already made, then we must save the instance making the request for deactivation and\n    // Reactivation but without any additional atlas loading\n    let atlasRequests = this.requestLookup.get(resourceContext);\n\n    if (atlasRequests) {\n      const existingRequests = atlasRequests.get(request);\n\n      if (existingRequests) {\n        existingRequests.push([layer, instance]);\n        instance.active = false;\n\n        return subTextureIOValue(texture);\n      }\n    } else {\n      atlasRequests = new Map();\n      this.requestLookup.set(resourceContext, atlasRequests);\n    }\n\n    // If the texture is not available, then we must load the resource, deactivate the instance\n    // And wait for the resource to become available. Once the resource is available, the system\n    // Must activate the instance to render the resource.\n    if (!request.disposeResource) {\n      instance.active = false;\n    }\n\n    let requests = this.requestQueue.get(resourceContext);\n\n    if (!requests) {\n      requests = [];\n      this.requestQueue.set(resourceContext, requests);\n    }\n\n    requests.push(request);\n    atlasRequests.set(request, [[layer, instance]]);\n\n    // This returns essentially returns blank values for the resource lookup\n    return subTextureIOValue(texture);\n  }\n\n  /**\n   * System is requesting properties for a resource should be updated.\n   */\n  updateResource(options: BaseResourceOptions) {\n    if (!isAtlasResource(options)) return;\n  }\n}\n","import { Vec } from \"../math/vector\";\nimport { IEasingProps } from \"../types\";\n\n/**\n * This object represents the data associated with easing. It provides the\n * information needed to make an easing equation execute to completion. It also\n * contains a few methods to aid in properly adjusting the easing values.\n */\nexport class EasingProps implements IEasingProps {\n  delay: number = 0;\n  duration: number;\n  end: Vec;\n  isManualStart = false;\n  isTimeSet = false;\n  start: Vec;\n  startTime: number;\n\n  constructor(options: IEasingProps) {\n    Object.assign(this, options);\n  }\n\n  /**\n   * If you manually set values for the easing properties, then you use this to return\n   * the easing object back to an automated state which is where the start value is\n   * the calculated current position of the output and the delay and duration is determined\n   * by the easing set to the layer's IAutomatedEasingMethod value set to the layer.\n   */\n  setAutomatic() {\n    this.isManualStart = false;\n    this.isTimeSet = false;\n  }\n\n  /**\n   * This controls the start value of the easing. This should be used to force a starting\n   * value of the animation.\n   *\n   * Use setAutomatic() to return to default easing behavior.\n   */\n  setStart(start?: Vec) {\n    if (start) {\n      if (this.start.length !== start.length) {\n        console.warn(\n          \"A manual easing adjustment provided an incompatible value for the easing type.\"\n        );\n      } else {\n        this.start = start;\n        this.isManualStart = true;\n      }\n    }\n  }\n\n  /**\n   * This controls of the timing of the easing equation. This should be used to adjust\n   * when a value is to be adjusted\n   *\n   * Use setAutomatic() to return to default easing behavior.\n   */\n  setTiming(delay?: number, duration?: number) {\n    this.delay = delay === undefined ? this.delay : delay;\n    this.duration = duration === undefined ? this.duration : duration;\n    this.isTimeSet = true;\n  }\n}\n","import { Attribute, Geometry } from \"../../gl\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport {\n  IVertexAttribute,\n  IVertexAttributeInternal,\n  LayerBufferType,\n  ShaderIOValue\n} from \"../../types\";\nimport { Layer } from \"../layer\";\n\nfunction isNumberCluster(\n  val: ShaderIOValue\n): val is\n  | [number]\n  | [number, number]\n  | [number, number, number]\n  | [number, number, number, number] {\n  return !Array.isArray(val[0]);\n}\n\nexport function generateLayerGeometry<T extends Instance>(\n  layer: Layer<T, any>,\n  maxInstancesPerBuffer: number,\n  vertexAttributes: IVertexAttributeInternal[],\n  vertexCount: number\n): Geometry {\n  // Make the new buffers to be updated\n  const vertexBuffers = [];\n\n  // Certain buffer strategies only need one instance buffered in\n  if (\n    layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE ||\n    layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE_PACKING\n  ) {\n    maxInstancesPerBuffer = 1;\n  }\n\n  for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n    const attribute = vertexAttributes[i];\n    vertexBuffers.push(\n      new Float32Array(attribute.size * vertexCount * maxInstancesPerBuffer)\n    );\n  }\n\n  // Let's now fill in the baseline geometry with the instances we will be generating\n  // First we ask the layer for a single instance's buffer setup\n  const endk = vertexAttributes.length;\n  let buffer: Float32Array;\n  let attribute: IVertexAttribute;\n  let value: ShaderIOValue;\n  let formatError: boolean = false;\n\n  for (let i = 0, end = vertexCount; i < end; ++i) {\n    for (let k = 0; k < endk; ++k) {\n      attribute = vertexAttributes[k];\n      buffer = vertexBuffers[k];\n      value = attribute.update(i);\n\n      if (isNumberCluster(value)) {\n        for (\n          let j = i * attribute.size, endj = j + attribute.size, index = 0;\n          j < endj;\n          ++j, ++index\n        ) {\n          buffer[j] = value[index];\n        }\n      } else {\n        formatError = true;\n      }\n    }\n  }\n\n  if (formatError) {\n    console.warn(\n      \"A vertex buffer updating method should not use arrays of arrays of numbers.\"\n    );\n  }\n\n  // After getting the geometry for a single instance, we can now copy paste\n  // For subsequent instances using very fast FLoat32 methods\n  // NOTE: This is ONLY for certain buffering strategies. This is essentially a noop when the\n  // maxInstances is set to one.\n  for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n    const attribute = vertexAttributes[i];\n    const instanceSize = attribute.size * vertexCount;\n\n    // Copy the first buffer set into the rest of the buffer\n    for (let k = 1, endk = maxInstancesPerBuffer; k < endk; ++k) {\n      vertexBuffers[i].copyWithin(instanceSize * k, 0, instanceSize);\n    }\n  }\n\n  // Lastly, we make the instance attribute reflect correctly so each instance\n  // Can have varied information. This is only appropriate for the uniform buffer strategy\n  if (layer.bufferType === LayerBufferType.UNIFORM) {\n    const instancingBuffer = vertexBuffers[0];\n\n    for (let i = 0, end = maxInstancesPerBuffer; i < end; ++i) {\n      const instanceStartIndex = i * vertexCount;\n\n      for (let k = 0; k < vertexCount; ++k) {\n        instancingBuffer[k + instanceStartIndex] = i;\n      }\n    }\n  }\n\n  // Now we can generate the attributes and apply them to a geometry object\n  const geometry = new Geometry();\n\n  // Generate the attributes, they are all Vertex attributes, thus instancing does not get flagged on them.\n  for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n    const attribute = vertexAttributes[i];\n    const materialAttribute = new Attribute(vertexBuffers[i], attribute.size);\n    attribute.materialAttribute = materialAttribute;\n    geometry.addAttribute(attribute.name, materialAttribute);\n  }\n\n  return geometry;\n}\n","import { Material, MaterialOptions, MaterialUniformType } from \"../../gl\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport { IInstancingUniform, IUniform, UniformSize } from \"../../types\";\nimport { ILayerProps, Layer } from \"../layer\";\n\nconst UNIFORM_SIZE_TO_MATERIAL_TYPE: { [key: number]: MaterialUniformType } = {\n  [UniformSize.ONE]: MaterialUniformType.FLOAT,\n  [UniformSize.TWO]: MaterialUniformType.VEC2,\n  [UniformSize.THREE]: MaterialUniformType.VEC3,\n  [UniformSize.FOUR]: MaterialUniformType.VEC4,\n  [UniformSize.MATRIX3]: MaterialUniformType.MATRIX3x3,\n  [UniformSize.MATRIX4]: MaterialUniformType.MATRIX4x4,\n  [UniformSize.ATLAS]: MaterialUniformType.TEXTURE\n};\n\nconst DEFAULT_UNIFORM_VALUE: { [key: number]: number[] } = {\n  [UniformSize.ONE]: [0],\n  [UniformSize.TWO]: [0, 0],\n  [UniformSize.THREE]: [0, 0, 0],\n  [UniformSize.FOUR]: [0, 0, 0, 0],\n  [UniformSize.MATRIX3]: [0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [UniformSize.MATRIX4]: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n};\n\nfunction toMaterialUniform(uniform: IUniform) {\n  return {\n    type: UNIFORM_SIZE_TO_MATERIAL_TYPE[uniform.size],\n    value: DEFAULT_UNIFORM_VALUE[uniform.size]\n  };\n}\n\nexport function generateLayerMaterial<\n  T extends Instance,\n  U extends ILayerProps<T>\n>(\n  layer: Layer<T, U>,\n  vs: string,\n  fs: string,\n  layerUniforms: IUniform[],\n  instancingUniforms: IInstancingUniform[]\n): Material {\n  // We now need to establish the material for the layer\n  const materialParams: MaterialOptions = layer.getMaterialOptions();\n\n  // The props applied to the layer has a material option declaration as well\n  // these settings take priority over all settings\n  Object.assign(materialParams, layer.props.materialOptions || {});\n\n  materialParams.vertexShader = vs;\n  materialParams.fragmentShader = fs;\n  materialParams.name = layer.id;\n\n  // We must convert all of the uniforms to actual GL material initialization uniforms\n  materialParams.uniforms = {};\n\n  // Convert our non-instancing uniforms to our material uniforms\n  for (let i = 0, end = layerUniforms.length; i < end; ++i) {\n    const uniform = layerUniforms[i];\n    const materialUniform = toMaterialUniform(uniform);\n    materialParams.uniforms[uniform.name] = materialUniform;\n  }\n\n  // Add in the generated instancing uniforms\n  for (let i = 0, end = instancingUniforms.length; i < end; ++i) {\n    const generatedUniform = instancingUniforms[i];\n    materialParams.uniforms[generatedUniform.name] = {\n      type: generatedUniform.type,\n      value: generatedUniform.value\n    };\n  }\n\n  return new Material(materialParams);\n}\n","/**\n * This file is dedicted to the all important step of processing desired inputs from the layer\n * and coming up with automated generated uniforms and attributes that the shader's will need\n * in order to operate with the conveniences the library offers. This includes things such as\n * injecting camera projection uniforms, resource uniforms, animation adjustments etc etc.\n */\nimport { Instance } from \"../../instance-provider/instance\";\nimport { ProcessShaderImportResults } from \"../../shaders/processing/shader-processor\";\nimport {\n  IInstanceAttribute,\n  IShaderInitialization,\n  IUniform,\n  IUniformInternal,\n  IVertexAttribute,\n  IVertexAttributeInternal\n} from \"../../types\";\nimport { BaseIOSorting } from \"../base-io-sorting\";\nimport { ILayerProps, Layer } from \"../layer\";\nimport { BaseIOExpansion } from \"./base-io-expansion\";\nimport { packAttributes } from \"./pack-attributes\";\n\n/**\n * Instance attribute typeguard\n */\nfunction isInstanceAttribute<T extends Instance>(\n  attr: any\n): attr is IInstanceAttribute<T> {\n  return Boolean(attr);\n}\n\n/**\n * Vertex attribute typeguard\n */\nfunction isVertexAttribute(attr: any): attr is IVertexAttribute {\n  return Boolean(attr);\n}\n\n/**\n * Uniform typeguard\n */\nfunction isUniform(attr: any): attr is IUniform {\n  return Boolean(attr);\n}\n\n/**\n * Converts a layer's vertex to the internal vertex structure used by the framework.\n */\nfunction toVertexAttributeInternal(\n  attribute: IVertexAttribute\n): IVertexAttributeInternal {\n  return Object.assign({}, attribute, { materialAttribute: null });\n}\n\n/**\n * Converts a layer's uniform to the internal uniform structure used by the framework.\n */\nfunction toUniformInternal(uniform: IUniform): IUniformInternal {\n  return Object.assign({}, uniform, { materialUniforms: [] });\n}\n\n/**\n * This processes instance attributes and performs some basic validation on them to ensure their\n * properties are sane and expected for rendering.\n */\nfunction validateInstanceAttributes<T extends Instance>(\n  layer: Layer<T, any>,\n  instanceAttributes: IInstanceAttribute<T>[],\n  vertexAttributes: IVertexAttribute[],\n  _uniforms: IUniform[]\n) {\n  instanceAttributes.forEach(attribute => {\n    if (attribute.name === undefined) {\n      console.warn(\n        \"All instance attributes MUST have a name on Layer:\",\n        layer.id\n      );\n    }\n\n    if (\n      instanceAttributes.find(\n        attr => attr !== attribute && attr.name === attribute.name\n      )\n    ) {\n      console.warn(\n        \"An instance attribute can not have the same name used more than once:\",\n        attribute.name\n      );\n    }\n\n    if (vertexAttributes.find(attr => attr.name === attribute.name)) {\n      console.warn(\n        \"An instance attribute and a vertex attribute in a layer can not share the same name:\",\n        attribute.name\n      );\n    }\n\n    if (!attribute.resource) {\n      if (attribute.size === undefined) {\n        console.warn(\"An instance attribute requires the size to be defined.\");\n        console.warn(attribute);\n      }\n    }\n  });\n}\n\n/**\n * This processes the results of shaders importing modules by gathering the attributes\n * and uniforms that arose from them.\n */\nfunction gatherIOFromShaderModules<\n  T extends Instance,\n  U extends ILayerProps<T>\n>(\n  layer: Layer<T, U>,\n  shaderIO: IShaderInitialization<T>,\n  importResults: ProcessShaderImportResults\n) {\n  if (!importResults) return;\n\n  // Get the existing items from the IO\n  let moduleInstanceAttributes = shaderIO.instanceAttributes || [];\n  let moduleUniforms = shaderIO.uniforms || [];\n  let moduleVertexAttributes = shaderIO.vertexAttributes || [];\n\n  // Add in the module requested items\n  importResults.shaderModuleUnits.forEach(unit => {\n    if (unit.instanceAttributes) {\n      moduleInstanceAttributes = moduleInstanceAttributes.concat(\n        unit.instanceAttributes(layer)\n      );\n    }\n\n    if (unit.uniforms) {\n      moduleUniforms = moduleUniforms.concat(unit.uniforms(layer));\n    }\n\n    if (unit.vertexAttributes) {\n      moduleVertexAttributes = moduleVertexAttributes.concat(\n        unit.vertexAttributes(layer)\n      );\n    }\n  });\n\n  // Dedup any element by name and show warnings when any item is overridden\n  const uniformNames = new Set<string>();\n  const instanceAttributeNames = new Set<string>();\n  const vertexAttributeNames = new Set<string>();\n\n  moduleUniforms.filter(uniform => {\n    if (uniform) {\n      if (uniformNames.has(uniform.name)) {\n        console.warn(\n          \"Included shader modules has introduced duplicate uniform names:\",\n          uniform.name,\n          \"One will be overridden thus causing a potential crash of the shader.\"\n        );\n        return false;\n      }\n\n      uniformNames.add(uniform.name);\n\n      return true;\n    }\n\n    return false;\n  });\n\n  moduleInstanceAttributes.filter(attribute => {\n    if (attribute) {\n      if (instanceAttributeNames.has(attribute.name)) {\n        console.warn(\n          \"Included shader modules has introduced duplicate Instance Attribute names:\",\n          attribute.name,\n          \"One will be overridden thus causing a potential crash of the shader.\"\n        );\n        return false;\n      }\n\n      instanceAttributeNames.add(attribute.name);\n\n      return true;\n    }\n\n    return false;\n  });\n\n  moduleVertexAttributes.filter(attribute => {\n    if (attribute) {\n      if (vertexAttributeNames.has(attribute.name)) {\n        console.warn(\n          \"Included shader modules has introduced duplicate Vertex Attribute names:\",\n          attribute.name,\n          \"One will be overridden thus causing a potential crash of the shader.\"\n        );\n        return false;\n      }\n\n      vertexAttributeNames.add(attribute.name);\n\n      return true;\n    }\n\n    return false;\n  });\n\n  // Apply any changes to the IO object\n  shaderIO.instanceAttributes = moduleInstanceAttributes;\n  shaderIO.uniforms = moduleUniforms;\n  shaderIO.vertexAttributes = moduleVertexAttributes;\n}\n\n/**\n * This is the primary method that analyzes all shader IO and determines which elements needs to be automatically injected\n * into the shader.\n *\n * @param gl The WebGL context this is being utilized on behalf of.\n * @param layer The layer who's ShaderIO we're analyzing and developing.\n * @param shaderIO The initial ShaderIO the layer has provided.\n * @param ioExpansion The list of BaseIOExpansion objects we will use to expand and process the layer's initial Shader IO\n * @param sortIO  The methods to sort the IO configurations\n * @param importResults The Shader IO object provided by the layer after it's had it's imports analyzed from the provided shader.\n */\nexport function injectShaderIO<T extends Instance, U extends ILayerProps<T>>(\n  gl: WebGLRenderingContext,\n  layer: Layer<T, U>,\n  shaderIO: IShaderInitialization<T>,\n  ioExpansion: BaseIOExpansion[],\n  sortIO: BaseIOSorting,\n  importResults: ProcessShaderImportResults\n) {\n  // After processing imports, we can now include any uniforms, or attributes the shader modules requested to be included in the\n  // layer so that the modules can operate properly. This mostly includes items such as times, projection matrices etc\n  // that the system should be providing rather than the layer\n  gatherIOFromShaderModules(layer, shaderIO, importResults);\n\n  // All of the instance attributes with nulls filtered out\n  const instanceAttributes = (shaderIO.instanceAttributes || []).filter(\n    isInstanceAttribute\n  );\n  // All of the vertex attributes with nulls filtered out\n  const vertexAttributes = (shaderIO.vertexAttributes || []).filter(\n    isVertexAttribute\n  );\n  // All of the uniforms with nulls filtered out\n  const uniforms = (shaderIO.uniforms || []).filter(isUniform);\n\n  // Now we process all of the custom attribute expansion specified by the surface\n  // to process the layer's IO to make special features with the attributes operate correctly.\n  for (let i = 0, iMax = ioExpansion.length; i < iMax; ++i) {\n    const expansion = ioExpansion[i];\n\n    // Do special expansion validation for attributes that may meet the criteria of the expander.\n    // If the validation fails, then we skip performing the expansion as it would result in\n    // invalid or undefined behavior. This validation method should provide all of the logged\n    // output necessary to determine why the configuration was wrong.\n    if (\n      expansion.validate(layer, instanceAttributes, vertexAttributes, uniforms)\n    ) {\n      // Perform the expansion\n      const extraIO = expansion.expand(\n        layer,\n        instanceAttributes,\n        vertexAttributes,\n        uniforms\n      );\n      // Now we add in the extra IO discovered\n      extraIO.instanceAttributes\n        .filter(isInstanceAttribute)\n        .forEach(attr => instanceAttributes.push(attr));\n      extraIO.vertexAttributes\n        .filter(isVertexAttribute)\n        .forEach(attr => vertexAttributes.push(attr));\n      extraIO.uniforms.filter(isUniform).forEach(attr => uniforms.push(attr));\n    }\n  }\n\n  // Do a final validation pass of the attributes injected so we can provide feedback as to why things behave odd\n  validateInstanceAttributes(\n    layer,\n    instanceAttributes,\n    vertexAttributes,\n    uniforms\n  );\n\n  // Gather instance attributes in such a way to not be mutated\n  const allInstanceAttributes = instanceAttributes.slice(0);\n  // Make sure the vertex attributes are internal attributes at this point\n  const allVertexAttributes = (vertexAttributes || []).map(\n    toVertexAttributeInternal\n  );\n  // Convert our uniforms to the internal structure they need to be\n  const allUniforms = uniforms.map(toUniformInternal);\n\n  // Apply the sorting\n  allInstanceAttributes.sort(sortIO.sortInstanceAttributes);\n  allUniforms.sort(sortIO.sortUniforms);\n  allVertexAttributes.sort(sortIO.sortVertexAttributes);\n\n  // Let's pack in our attributes automagically so we can determine block and block indices.\n  packAttributes(allInstanceAttributes);\n  // Before we make the vertex attributes, we must determine the buffering strategy our layer will utilize\n  layer.getLayerBufferType(gl, vertexAttributes, allInstanceAttributes);\n\n  return {\n    instanceAttributes: allInstanceAttributes,\n    uniforms: allUniforms,\n    vertexAttributes: allVertexAttributes\n  };\n}\n","import { Geometry } from \"../gl/geometry\";\nimport { Material } from \"../gl/material\";\nimport { Model } from \"../gl/model\";\nimport { WebGLStat } from \"../gl/webgl-stat\";\nimport { Instance } from \"../instance-provider/instance\";\nimport { ObservableMonitoring } from \"../instance-provider/observable\";\nimport { ResourceRouter } from \"../resources\";\nimport { ShaderProcessor } from \"../shaders/processing/shader-processor\";\nimport {\n  IInstanceAttribute,\n  IInstanceProvider,\n  ILayerEasingManager,\n  ILayerMaterialOptions,\n  ILayerRef,\n  INonePickingMetrics,\n  InstanceAttributeSize,\n  instanceAttributeSizeFloatCount,\n  IPickInfo,\n  IShaderInitialization,\n  ISinglePickingMetrics,\n  IUniformInternal,\n  IVertexAttribute,\n  IVertexAttributeInternal,\n  LayerBufferType,\n  PickType,\n  StreamChangeStrategy,\n  UniformIOValue\n} from \"../types\";\nimport { onFrame, PromiseResolver, uid } from \"../util\";\nimport { createAttribute } from \"../util/create-util\";\nimport { IdentifyByKey, IdentifyByKeyOptions } from \"../util/identify-by-key\";\nimport {\n  InstanceAttributeBufferManager,\n  InstanceAttributePackingBufferManager,\n  UniformBufferManager\n} from \"./buffer-management\";\nimport {\n  BufferManagerBase,\n  IBufferLocation\n} from \"./buffer-management/buffer-manager-base\";\nimport { InstanceDiffManager } from \"./buffer-management/instance-diff-manager\";\nimport { LayerInteractionHandler } from \"./layer-interaction-handler\";\nimport { generateLayerGeometry } from \"./layer-processing/generate-layer-geometry\";\nimport { generateLayerMaterial } from \"./layer-processing/generate-layer-material\";\nimport { generateLayerModel } from \"./layer-processing/generate-layer-model\";\nimport { LayerScene } from \"./layer-scene\";\nimport { Surface } from \"./surface\";\nimport { IViewProps, View } from \"./view\";\n\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * A type to describe the constructor of a Layer class.\n */\nexport interface ILayerConstructable<T extends Instance> {\n  new (surface: Surface, scene: LayerScene, props: ILayerProps<T>): Layer<\n    any,\n    any\n  >;\n}\n\n/**\n * This specifies a class type that can be used in creating a layer with createLayer\n */\nexport type ILayerConstructionClass<\n  T extends Instance,\n  U extends ILayerProps<T>\n> = ILayerConstructable<T> & { defaultProps: U };\n\n/**\n * This is a pair of a Class Type and the props to be applied to that class type.\n */\nexport type LayerInitializer = {\n  key: string;\n  init: [\n    ILayerConstructionClass<Instance, ILayerProps<Instance>>,\n    ILayerProps<Instance>\n  ];\n};\n\n/**\n * The internal system layer initializer that hides additional properties the front\n * facing API should not be concerned with.\n */\nexport type LayerInitializerInternal = {\n  key: string;\n  init: [\n    ILayerConstructionClass<Instance, ILayerPropsInternal<Instance>>,\n    ILayerPropsInternal<Instance>\n  ];\n};\n\n/**\n * Constructor options when generating a layer.\n */\nexport interface ILayerProps<T extends Instance> extends IdentifyByKeyOptions {\n  /**\n   * This allows for external overriding of the base shader modules for a layer. This can cause a layer to break if the\n   * overrides do not provide what the layer is expecting at the least.\n   */\n  baseShaderModules?(\n    shaderIO: IShaderInitialization<T>,\n    layerModules: { fs: string[]; vs: string[] }\n  ): { fs: string[]; vs: string[] };\n  /** This is the data provider where the instancing data is injected and modified. */\n  data: IInstanceProvider<T>;\n  /**\n   * This allows an easing ref to be applied to the layer. This ref can be used for detailed information regarding\n   * easing values, which allows for easier management of timings and feedback for animations being piped to the GPU.\n   */\n  ref?: ILayerRef;\n  /**\n   * Any pipeline declaring a layer cn manipulate a layer's default material settings as every pipeline\n   * can have some specific and significant needs the layer does not provide as a default.\n   */\n  materialOptions?: ILayerMaterialOptions;\n  /**\n   * This sets how instances can be picked via the mouse. This activates the mouse events for the layer IFF\n   * the value is not NONE.\n   */\n  picking?: PickType;\n  /**\n   * Used for debugging. Logs the generated shader for the layer in the console.\n   */\n  printShader?: boolean;\n  /**\n   * This is a property that allows for changes to stream in batches instead of commit in one giant push. This helps if\n   * you have 100's of 1000's of instances you need to update. Updating all the instances can put extreme pressure on\n   * your RAM and can cause massive frame lag. Picking a streaming strategy and amount to commit per frame can greatly\n   * improve user experience and can even help to prevent crashes from RAM over use.\n   *\n   * WARNING: Once changes start committing for a batch of changes, future changes will NOT be rendered or able to\n   * affect the GPU state UNTIL the streaming completes. Once the stream is completed, all edits that happen\n   * subsequently will begin streaming in as the next batch of changes.\n   *\n   * You are allowed to change the instance's properties while waiting for a set of changes to finish streaming.\n   */\n  streamChanges?: {\n    /**\n     * This is the amount of instance updates that can stream through per frame. This defaults to 10000 if not provided\n     */\n    count?: number;\n    /** This is the strategy for pulling the next set of instances to update to the GPU. Defaults to LINEAR */\n    strategy?: StreamChangeStrategy;\n  };\n\n  // ---- EVENTS ----\n  /** Executes when the mouse is down on instances (Picking type must be set) */\n  onMouseDown?(info: IPickInfo<T>): void;\n  /** Executes when the mouse moves on instances (Picking type must be set) */\n  onMouseMove?(info: IPickInfo<T>): void;\n  /** Executes when the mouse no longer over instances (Picking type must be set) */\n  onMouseOut?(info: IPickInfo<T>): void;\n  /** Executes when the mouse is newly over instances (Picking type must be set) */\n  onMouseOver?(info: IPickInfo<T>): void;\n  /** Executes when the mouse button is released when over instances (Picking type must be set) */\n  onMouseUp?(info: IPickInfo<T>): void;\n  /** Executes when the mouse was down on an instance but is released up outside of that instance (Picking type must be set) */\n  onMouseUpOutside?(info: IPickInfo<T>): void;\n  /** Executes when the mouse click gesture is executed over instances (Picking type must be set) */\n  onMouseClick?(info: IPickInfo<T>): void;\n\n  /**\n   * Executes when there are no longer any touches that are down for the layer (Picking type must be set).\n   *\n   * NOTE: This executes for touches being released inside and outside their respective instance.\n   */\n  onTouchAllEnd?(info: IPickInfo<T>): void;\n  /** Executes when a touch is down on instances. Each touch will produce it's own event (Picking type must be set) */\n  onTouchDown?(info: IPickInfo<T>): void;\n  /** Executes when a touch is up when over on instances. Each touch will produce it's own event (Picking type must be set) */\n  onTouchUp?(info: IPickInfo<T>): void;\n  /** Executes when a touch was down on an instance but is released up outside of that instance (Picking type must be set) */\n  onTouchUpOutside?(info: IPickInfo<T>): void;\n  /** Executes when a touch is moving atop of instances. Each touch will produce it's own event (Picking type must be set) */\n  onTouchMove?(info: IPickInfo<T>): void;\n  /** Executes when a touch is moves off of an instance. Each touch will produce it's own event (Picking type must be set) */\n  onTouchOut?(info: IPickInfo<T>): void;\n  /** Executes when a touch moves over instances while the touch is dragged around the screen. (Picking type must be set) */\n  onTouchOver?(info: IPickInfo<T>): void;\n  /** Executes when a touch moves off of an instance and there is no longer ANY touches over the instance (Picking type must be set) */\n  onTouchAllOut?(info: IPickInfo<T>): void;\n  /** Executes when a touch taps on instances. (Picking type must be set) */\n  onTap?(info: IPickInfo<T>): void;\n}\n\n/**\n * Layer properties that contains internal system values\n */\nexport interface ILayerPropsInternal<T extends Instance>\n  extends ILayerProps<T> {\n  /** The system provides this for the layer when the layer is being produced as a child of another layer */\n  parent?: Layer<Instance, ILayerProps<Instance>>;\n}\n\n/**\n * This is the information a layer stores regarding its shader configuration information\n */\nexport interface ILayerShaderIOInfo<T extends Instance> {\n  /** This is the attribute that specifies the _active flag for an instance */\n  activeAttribute: IInstanceAttribute<T>;\n  /** This is the GL geometry filled with the vertex information */\n  geometry: Geometry;\n  /** This is all of the instance attributes generated for the layer */\n  instanceAttributes: IInstanceAttribute<T>[];\n  /** Provides the number of vertices a single instance spans */\n  instanceVertexCount: number;\n  /** The official shader material generated for the layer */\n  material: Material;\n  /** INTERNAL: For the given shader IO provided this is how many instances can be present per buffer. */\n  maxInstancesPerBuffer: number;\n  /** Default model configuration for rendering in the gl layer */\n  model: Model;\n  /** This is all of the uniforms generated for the layer */\n  uniforms: IUniformInternal[];\n  /** This is all of the vertex attributes generated for the layer */\n  vertexAttributes: IVertexAttributeInternal[];\n}\n\ninterface ILayerEasingManagerInternal extends ILayerEasingManager {\n  easingComplete: PromiseResolver<void>;\n}\n\n/**\n * A base class for generating drawable content\n */\nexport class Layer<\n  T extends Instance,\n  U extends ILayerProps<T>\n> extends IdentifyByKey {\n  /** This MUST be implemented by sublayers in order for proper code hinting to happen */\n  static defaultProps: any = {};\n\n  /**\n   * Calculated end time of all animations that will take place. This will cause the system to keep rendering\n   * and not go into an idle state until the time of the last rendered frame has exceeded the time flagged\n   * here.\n   */\n  animationEndTime: number = 0;\n  /** This is a flag that allows a system to indicate this layer should always re-render */\n  isAnimationContinuous: boolean = false;\n  /** Buffer manager is read only. Must use setBufferManager */\n  private _bufferManager: BufferManagerBase<T, IBufferLocation>;\n  /**\n   * This matches an instance to the data buffers and positions to stream to the GPU for direct updates. Use\n   * setBufferManager to change this element.\n   */\n  get bufferManager() {\n    return this._bufferManager;\n  }\n  /** Buffer type is private and should not be directly modified */\n  private _bufferType: LayerBufferType;\n  /** This is the determined buffering strategy of the layer */\n  get bufferType() {\n    return this._bufferType;\n  }\n  /** When a layer creates children, this is populated with those children */\n  children?: Layer<Instance, ILayerProps<Instance>>[];\n  /** This determines the drawing order of the layer within it's scene */\n  depth: number = 0;\n  /** This contains the methods and controls for handling diffs for the layer */\n  diffManager: InstanceDiffManager<T>;\n  /**\n   * This gets populated when there are attributes that have easing applied to them. This\n   * subsequently gets applied to instances when they get added to the layer.\n   */\n  easingId: { [key: string]: number };\n  /** This is a manager used to monitor and handle the easing operations of the layer */\n  private _easingManager: ILayerEasingManagerInternal = {\n    easingComplete: new PromiseResolver(),\n    complete: () => this._easingManager.easingComplete.promise\n  };\n\n  get easingManager(): ILayerEasingManager {\n    return this._easingManager;\n  }\n\n  /** This is the initializer used when making this layer. */\n  initializer: LayerInitializer;\n  /** This is the handler that manages interactions for the layer */\n  interactions: LayerInteractionHandler<T, U>;\n  /** The last time stamp this layer had its contents rendered */\n  lastFrameTime: number = 0;\n  /** This indicates whether this layer needs to draw */\n  needsViewDrawn: boolean = false;\n  /** Helps assert rendering order. Lower numbers render first. */\n  order?: number;\n  /** If this is populated, then this layer is the product of a parent producing this layer. */\n  parent?: Layer<Instance, ILayerProps<Instance>>;\n  /** This is all of the picking metrics kept for handling picking scenarios */\n  picking: ISinglePickingMetrics<T> | INonePickingMetrics;\n  /** Properties handed to the Layer during a Surface render */\n  props: U;\n  /** This is the system provided resource manager that lets a layer request resources */\n  resource: ResourceRouter;\n  /** This is the layer scene this layer feeds into */\n  scene: LayerScene;\n  /** This contains the shader IO information generated when the layer was created */\n  shaderIOInfo: ILayerShaderIOInfo<T> = {} as ILayerShaderIOInfo<T>;\n  /**\n   * This is populated with the current streaming state for committing changes to the GPU. See ILayerProps for how the\n   * configuration happens for this object.\n   */\n  streamChanges: {\n    /** When locked this layer will NOT stream in new changes as it has a current stream it is completing first. */\n    locked: boolean;\n    /** When defined, this is the list of items currently being streamed to the GPU. */\n    stream?: U[\"data\"][\"changeList\"];\n    /** The index our stream has iterated through for the current stream */\n    streamIndex: number;\n  } = {\n    locked: false,\n    streamIndex: 0\n  };\n  /** This is the surface this layer is generated under */\n  surface: Surface;\n\n  /** A uid provided to the layer to give it some uniqueness as an object */\n  get uid() {\n    return this._uid;\n  }\n  private _uid: number = uid();\n  /**\n   * This maps a uid to the instance. This is only populated if it's needed for the processes the layer uses\n   * (such as color picking).\n   */\n  uidToInstance = new Map<number, T>();\n  /** This is the view the layer is applied to. The system sets this, modifying will only cause sorrow. */\n  view: View<IViewProps>;\n  /** This flag indicates if the layer will be reconstructed from scratch next layer rendering cycle */\n  willRebuildLayer: boolean = false;\n\n  /**\n   * This is a hook for the layer to respond to an instance being added via the diff manager. This is a simple\n   * opportunity to set some expectations of the instance and tie it directly to the layer it is processing under.\n   *\n   * By default for best performance, this method is undefined for the layer. One must be applied for the hook to take\n   * effect.\n   *\n   * For example: the primary case this arose was from instances needing the easing id mapping to allow for retrieval\n   * of the instance's easing information for a given layer association.\n   *\n   * WARNING: This is tied into a MAJOR performance sensitive portion of the framework. This should involve VERY simple\n   * assignments at best. Do NOT perform any logic in this callback or your application WILL suffer.\n   */\n  onDiffAdd?(instance: T): void;\n\n  /**\n   * This is an opportunity to clean up any instance's association with the layer it was originally a part of.\n   *\n   * WARNING: This is tied into a MAJOR performance sensitive portion of the framework. This should involve VERY simple\n   * assignments at best. Do NOT perform any logic in this callback or your application WILL suffer.\n   *\n   * EXTRA WARNING: You better make sure you instantiate this if you instantiated onDiffManagerAdd so you can clean out\n   * any bad memory allocation choices you made.\n   */\n  onDiffRemove?(instance: T): void;\n\n  /**\n   * Generates a reference object that can be used to retrieve layer specific metrics associated with the layer.\n   */\n  static createRef<T extends ILayerRef>(): T {\n    return {\n      easing: null\n    } as T;\n  }\n\n  constructor(surface: Surface, scene: LayerScene, props: ILayerProps<T>) {\n    // We do not establish bounds in the layer. The surface manager will take care of that for us\n    // After associating the layer with the view it is a part of.\n    super(props);\n    // Keep track of the surface this layer resides beneath\n    this.surface = surface;\n    // Track the parent Layer Scene this layer is under\n    this.scene = scene;\n    // Keep our props within the layer\n    this.props = Object.assign({}, Layer.defaultProps || {}, props as U);\n  }\n\n  /**\n   * This does special initialization by gathering the layers shader IO, generates a material\n   * and injects special automated uniforms and attributes to make instancing work for the\n   * shader.\n   */\n  init() {\n    // Set up the pick type for the layer\n    const { picking = PickType.NONE } = this.props;\n\n    if (picking === PickType.SINGLE) {\n      this.picking = {\n        currentPickMode: PickType.NONE,\n        type: PickType.SINGLE,\n        uidToInstance: new Map<number, T>()\n      };\n    } else {\n      this.picking = {\n        currentPickMode: PickType.NONE,\n        type: PickType.NONE\n      };\n    }\n\n    // Set the resource manager this surface utilizes to the layer\n    this.resource = this.surface.resourceManager;\n    // Get the shader metrics the layer desires\n    const shaderIO = this.initShader();\n    // Ensure the layer has interaction handling applied to it\n    this.interactions = new LayerInteractionHandler(this);\n\n    // If no metrics are provided, this layer is merely a shell layer and will not\n    // receive any GPU handling objects.\n    if (!shaderIO) {\n      this.picking.type = PickType.NONE;\n      debug(\n        \"Shell layer initialized. Nothing will be rendered for this layer\",\n        this.id\n      );\n      return true;\n    }\n\n    if (!shaderIO.fs || !shaderIO.vs) {\n      console.warn(\n        \"Layer needs to specify the fragment and vertex shaders:\",\n        this.id\n      );\n      return false;\n    }\n\n    // Clean out nulls provided as a convenience to the layer\n    shaderIO.instanceAttributes = (shaderIO.instanceAttributes || []).filter(\n      Boolean\n    );\n    shaderIO.vertexAttributes = (shaderIO.vertexAttributes || []).filter(\n      Boolean\n    );\n    shaderIO.uniforms = (shaderIO.uniforms || []).filter(Boolean);\n\n    // Generate the actual shaders to be used by injecting all of the necessary fragments and injecting\n    // Instancing fragments\n    const shaderMetrics = new ShaderProcessor().process(\n      this,\n      shaderIO,\n      this.surface.getIOExpanders(),\n      this.surface.getIOSorting()\n    );\n\n    // Check to see if the Shader Processing failed. If so, return null as a failure flag.\n    if (!shaderMetrics) {\n      console.warn(\n        \"The shader processor did not produce metrics for the layer.\"\n      );\n      return false;\n    }\n\n    // Retrieve all of the attributes created as a result of layer input and module processing.\n    const { vertexAttributes, instanceAttributes, uniforms } = shaderMetrics;\n\n    // Generate the geometry this layer will be utilizing\n    const geometry = generateLayerGeometry(\n      this,\n      shaderMetrics.maxInstancesPerBuffer,\n      vertexAttributes,\n      shaderIO.vertexCount\n    );\n\n    // This is the material that is generated for the layer that utilizes all of the generated and\n    // Injected shader IO and shader fragments\n    const material = generateLayerMaterial(\n      this,\n      shaderMetrics.vs,\n      shaderMetrics.fs,\n      uniforms,\n      shaderMetrics.materialUniforms\n    );\n\n    // And now we can now generate the mesh that will be added to the scene\n    const model = generateLayerModel(geometry, material, shaderIO.drawMode);\n\n    // Now that all of the elements of the layer are complete, let us apply them to the layer\n    this.shaderIOInfo = Object.assign<\n      ILayerShaderIOInfo<T>,\n      ILayerShaderIOInfo<T>\n    >(\n      {\n        activeAttribute: createAttribute({\n          name: \"active\",\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.active ? 1 : 0]\n        }),\n        geometry,\n        instanceAttributes,\n        instanceVertexCount: shaderIO.vertexCount,\n        material,\n        maxInstancesPerBuffer: shaderMetrics.maxInstancesPerBuffer,\n        model,\n        uniforms,\n        vertexAttributes\n      },\n      this.shaderIOInfo\n    );\n\n    // Generate the correct buffering strategy for the layer\n    this.makeLayerBufferManager(this.surface.gl, this.scene);\n\n    if (this.props.printShader) {\n      console.warn(\n        \"A Layer requested its shader be debugged. Do not leave this active for production:\",\n        \"Layer:\",\n        this.props.key,\n        \"Shader Metrics\",\n        shaderMetrics\n      );\n      console.warn(\"\\n\\nVERTEX SHADER\\n--------------\\n\\n\", shaderMetrics.vs);\n      console.warn(\"\\n\\nFRAGMENT SHADER\\n--------------\\n\\n\", shaderMetrics.fs);\n    }\n\n    // Establish diff handlers based on the settings of the layer\n    this.updateDiffHandlers();\n\n    // Establish initial ref needs\n    if (this.props.ref) {\n      this.props.ref.easing = this.easingManager;\n    }\n\n    return true;\n  }\n\n  /**\n   * This establishes basic modules required by the layer for the shaders. At it's core functionality, it will\n   * support the basic properties a layer has to provide, such as Picking modes\n   */\n  baseShaderModules(\n    shaderIO: IShaderInitialization<T>\n  ): { fs: string[]; vs: string[] } {\n    const additionalImportsVS = [];\n    const additionalImportsFS = [];\n\n    // All layers need the basic instancing functionality\n    additionalImportsVS.push(\"instancing\");\n\n    // See if the layer needs picking modules\n    if (this.picking.type === PickType.SINGLE) {\n      additionalImportsVS.push(\"picking\");\n      additionalImportsFS.push(\"picking\");\n    } else {\n      additionalImportsVS.push(\"no-picking\");\n      additionalImportsFS.push(\"no-picking\");\n    }\n\n    // See if there are any attributes that have  auto easing involved\n    const easing = (shaderIO.instanceAttributes || []).find(check =>\n      Boolean(check && check.easing)\n    );\n\n    // If easing is involved then we need to make sure that frame metrics are imported for our animations\n    if (easing) {\n      additionalImportsVS.push(\"frame\");\n    }\n\n    return {\n      fs: additionalImportsFS,\n      vs: additionalImportsVS\n    };\n  }\n\n  /**\n   * This provides a means for a layer to have child layers that are injected immediately after this layer.\n   *\n   * This essentially lets composite layer management occur allowing the compositer to behave as a layer does\n   * but have layers managed by it. This has the advantage of allowing a composition layer able to handle a\n   * data provider but split it's processing across it's own internal data providers which is thus picked up\n   * by it's child layers and output by the layers.\n   */\n  childLayers(): LayerInitializer[] {\n    return [];\n  }\n\n  /**\n   * Invalidate and free all resources assocated with this layer.\n   */\n  destroy() {\n    if (this.bufferManager) {\n      if (this.bufferManager.scene) this.bufferManager.scene.removeLayer(this);\n      this.bufferManager.removeFromScene();\n      this.bufferManager.destroy();\n    }\n  }\n\n  /**\n   * Lifecycle method for layers to inherit that executes after the props for the layer have been updated\n   */\n  didUpdateProps() {\n    /** LIFECYCLE */\n  }\n\n  /**\n   * This is where global uniforms should update their values. Executes every frame.\n   */\n  draw() {\n    // Make sure the stream lock is up to date before processing the next set of changes\n    this.updateStreamLock();\n    // Consume the diffs for the instances to update each element\n    const changeList = this.getChangeList();\n\n    // Set needsViewDrawn to be true if there is any change\n    if (changeList.length > 0) this.needsViewDrawn = true;\n    // Make some holder variables to prevent declaration within the loop\n    let change, instance, bufferLocations;\n    // Fast ref to the processor and manager\n    const diffManager = this.diffManager;\n    const processing = diffManager.processing;\n    const processor = diffManager.processor;\n\n    // Forewarn the processor how many instances are flagged for a change.\n    processor.incomingChangeList(changeList);\n    // Forewarn the buffer manager of changes so it can optimize it's handling of changes as well\n    this.bufferManager.incomingChangeList(changeList);\n\n    for (let i = 0, end = changeList.length; i < end; ++i) {\n      change = changeList[i];\n      instance = change[0];\n      bufferLocations = this.bufferManager.getBufferLocations(instance);\n      // The diff type is change[1] which we use to find the diff processing method to use\n      processing[change[1]](\n        processor,\n        instance,\n        Object.values(change[2]),\n        bufferLocations\n      );\n      // Clear the changes for the instance\n      instance.changes = {};\n    }\n\n    // Tell the diff processor that it has completed it's task set\n    processor.commit();\n    // Tell the manager changes are processed to allow it to free up resources\n    this.bufferManager.changesProcessed();\n    // Update our easing management\n    this.updateEasingManager();\n    // Trigger uniform updates\n    this.updateUniforms();\n  }\n\n  /**\n   * This handles updating our easingManager so references can properly react to easing completion times.\n   */\n  private updateEasingManager() {\n    // If we're streaming changes, then we have to wait for the stream to be finished before we can use the animation\n    // end time of the layer to establish the true end of all animations piped to the GPU.\n    if (this.props.streamChanges) {\n      // Wait for the stream to be emptied so we can\n      if (!this.streamChanges.stream || this.streamChanges.stream.length <= 0) {\n        // Get the existing resolver that is waiting for the animations to complete\n        const resolver = this._easingManager.easingComplete;\n        // Make a new resolver for next processes waiting for a current change set to complete\n        this._easingManager.easingComplete = new PromiseResolver<void>();\n\n        // Set a timer to complete when the layer has finished it's animation cycle\n        onFrame(() => {\n          resolver.resolve();\n        }, this.animationEndTime - this.surface.frameMetrics.currentTime);\n      }\n    }\n\n    // If this is a non-streamed change, then we simply wait until the layer's animation timer is resolved\n    else {\n      // Get the existing resolver that is waiting for the animations to complete\n      const resolver = this._easingManager.easingComplete;\n      // Make a new resolver for next processes waiting for a current change set to complete\n      this._easingManager.easingComplete = new PromiseResolver<void>();\n\n      // Set a timer to complete when the layer has finished it's animation cycle\n      onFrame(() => {\n        resolver.resolve();\n      }, this.animationEndTime - this.surface.frameMetrics.currentTime);\n    }\n  }\n\n  /**\n   * This gets the next changes that should be retrieved from a change stream. A stream is when changes are streamed\n   * in batches instead of committing all changes in a single update.\n   */\n  private getNextStreamChanges() {\n    let out: U[\"data\"][\"changeList\"];\n\n    // Get the stream changes settings from our props\n    const {\n      streamChanges = {\n        count: 10000,\n        strategy: StreamChangeStrategy.LINEAR\n      }\n    } = this.props;\n    // Get the stream that is currently in progress\n    const { stream = [], streamIndex } = this.streamChanges;\n\n    // Ensure we have a count set for the number of items to stream down\n    if (streamChanges.count === void 0) {\n      streamChanges.count = 10000;\n    }\n\n    // Validate the number of items to stream. Any number at 0 or less indicates a desire to stream all remaining\n    // changes.\n    if (streamChanges.count <= 0) {\n      streamChanges.count = Number.MAX_SAFE_INTEGER;\n    }\n\n    // Pick the strategy for pulling the next changes from the stream\n    switch (streamChanges.strategy) {\n      // Linear just pulls out changes as they came in\n      case StreamChangeStrategy.LINEAR:\n      default: {\n        out = stream.slice(streamIndex, streamIndex + streamChanges.count);\n        this.streamChanges.streamIndex += streamChanges.count;\n        break;\n      }\n    }\n\n    // If we hit the end of the stream, we need to dump the stream from memory.\n    if (\n      this.streamChanges.stream &&\n      this.streamChanges.streamIndex >= this.streamChanges.stream.length\n    ) {\n      delete this.streamChanges.stream;\n    }\n\n    return out;\n  }\n\n  /**\n   * This checks the status of the stream and determines if this layer is locked into a stream or is done processing\n   * the stream.\n   */\n  private updateStreamLock() {\n    this.streamChanges.locked = Boolean(\n      this.streamChanges.stream &&\n        this.streamChanges.streamIndex < this.streamChanges.stream.length\n    );\n  }\n\n  /**\n   * This gets the next instance changes to push to the GPU.\n   */\n  private getChangeList() {\n    let changeList: U[\"data\"][\"changeList\"];\n\n    // If we are streaming changes we do not accept new changes coming down but instead work on resolving the\n    // current stream\n    if (this.streamChanges.locked) {\n      changeList = this.getNextStreamChanges();\n    } else {\n      // If streaming changes is declared for the properties of the layer, then we need to gather the current change\n      // list into a stream and pull a set of the changes.\n      if (this.props.streamChanges) {\n        // We start a new stream so we have to begin at it's start index\n        this.streamChanges.streamIndex = 0;\n        // We lock the layer for the streaming changes so the stream will complete before new changes are applied\n        this.streamChanges.locked = true;\n        // Create the new stream from the existing changes.\n        this.streamChanges.stream = this.props.data.changeList;\n        // We provide no changes the first frame. There is some set up that can cause a spike in utilization, so we\n        // don't want the first changes to be too far ahead of the changes of others.\n        changeList = [];\n        // Since we retrieved all the current changes and applied it to our stream, we resolve the changes from the provider\n        // so new changes can be gathered whilst the stream resolves.\n        this.props.data.resolve(this.id);\n      } else {\n        // This is simply full copying all current changes as the next set of changes to be applied\n        changeList = this.props.data.changeList;\n        // Flag the changes as resolved since we gathered all changes and the changes will be immediately applied\n        this.props.data.resolve(this.id);\n      }\n    }\n\n    this.updateStreamLock();\n\n    return changeList;\n  }\n\n  /**\n   * This retrieves the observable IDs for instance observable properties. This triggers a\n   * getter of the indicated property.\n   *\n   * Do NOT use this in intensive loops, try to cache these results where possible.\n   */\n  getInstanceObservableIds<K extends keyof T>(\n    instance: T,\n    properties: Extract<K, string>[]\n  ): { [key: string]: number } {\n    const out: { [key: string]: number } = {};\n\n    // Loop through all of the requested properties to see if they are observable and have\n    // an id associated with them.\n    for (let i = 0, iMax = properties.length; i < iMax; ++i) {\n      // Activate monitoring of ids, this also resets the monitor's list\n      ObservableMonitoring.setObservableMonitor(true);\n      // Trigger the getter of the property\n      instance[properties[i]];\n      // We now can see if the property triggered an identifier thus indicating it's observable\n      // and has an ID\n      const propertyIds = ObservableMonitoring.getObservableMonitorIds(true);\n\n      // If an id is found, then the property was observable.\n      if (propertyIds[0] !== undefined) {\n        out[properties[i]] = propertyIds[0];\n      }\n    }\n\n    // SUPER IMPORTANT to deactivate this here. Leaving this turned on causes memory to be chewed up\n    // for every property getter.\n    ObservableMonitoring.setObservableMonitor(false);\n\n    return out;\n  }\n\n  /**\n   * The options for a GL Material without uniforms.\n   */\n  getMaterialOptions(): ILayerMaterialOptions {\n    return {};\n  }\n\n  /**\n   * This sets up all of the data bindings that will transport data from the CPU\n   * to the Shader on the GPU.\n   *\n   * Instance Attributes: These are very frequently changing attributes\n   * Vertex Attributes: These are attributes that should be static on a vertex. Conisder it very costly to update.\n   *                    The only time making these modifieable is in the event of GL_POINTS.\n   * Uniforms: These set up the uniforms for the layer, thus having all normal implications of a uniform. Global\n   *           across the fragment and vertex shaders and can be modified with little consequence.\n   *\n   * NOTE: Return null to indicate this layer is not going to render anything. This is typical for parent\n   * layers that manage child layers who themselves do not cause rendering of any sort.\n   */\n  initShader(): IShaderInitialization<T> | null {\n    return {\n      fs: \"${import: no-op}\",\n      instanceAttributes: [],\n      uniforms: [],\n      vertexAttributes: [],\n      vertexCount: 0,\n      vs: \"${import: no-op}\"\n    };\n  }\n\n  /**\n   * Indicates if this layer is managing an instance or not. This is normally done by determining\n   * if this layer's buffer manager has assigned buffer space to the instance. In special layer cases\n   * this may be overridden here to make the assertion in some other way.\n   */\n  managesInstance(instance: T): boolean {\n    return this.bufferManager && this.bufferManager.managesInstance(instance);\n  }\n\n  /**\n   * This method determines the buffering strategy that the layer should be utilizing based on provided vertex and\n   * instance attributes.\n   */\n  getLayerBufferType<T extends Instance>(\n    _gl: WebGLRenderingContext,\n    vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<T>[]\n  ) {\n    let type = LayerBufferType.UNIFORM;\n    let attributesUsed = 0;\n\n    // The layer only gets it's buffer type calculated once\n    if (this.bufferType !== undefined) {\n      return this.bufferType;\n    }\n\n    // Uncomment this to force the uniform buffer strategy\n    // this.setBufferType(LayerBufferType.UNIFORM);\n    // return LayerBufferType.UNIFORM;\n\n    if (WebGLStat.HARDWARE_INSTANCING) {\n      for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n        const attribute = vertexAttributes[i];\n        attributesUsed += Math.ceil(attribute.size / 4);\n      }\n\n      for (let i = 0, end = instanceAttributes.length; i < end; ++i) {\n        const attribute = instanceAttributes[i];\n        attributesUsed += Math.ceil(\n          instanceAttributeSizeFloatCount[attribute.size || 1] / 4\n        );\n      }\n\n      // Too many attempted single attributes. We will next attempt to see if we can pack the vertex\n      // attributes down into blocks.\n      if (attributesUsed > WebGLStat.MAX_VERTEX_ATTRIBUTES) {\n        attributesUsed = 0;\n\n        for (let i = 0, end = instanceAttributes.length; i < end; ++i) {\n          const attribute = instanceAttributes[i];\n          attributesUsed = Math.max(attributesUsed, attribute.block || 0);\n        }\n\n        for (let i = 0, end = vertexAttributes.length; i < end; ++i) {\n          const attribute = vertexAttributes[i];\n          attributesUsed += Math.ceil(attribute.size / 4);\n        }\n\n        // If we can fit now, then we are good to go with using attribute packing\n        if (attributesUsed < WebGLStat.MAX_VERTEX_ATTRIBUTES) {\n          type = LayerBufferType.INSTANCE_ATTRIBUTE_PACKING;\n\n          debug(\n            `Performance Issue (Moderate):\n            Layer %o is utilizing too many vertex attributes and is now using vertex packing.\n            Max Vertex units %o\n            Used Vertex units %o\n            Instance Attributes %o\n            Vertex Attributes %o`,\n            this.id,\n            WebGLStat.MAX_VERTEX_ATTRIBUTES,\n            attributesUsed,\n            instanceAttributes,\n            vertexAttributes\n          );\n        }\n      } else {\n        // If we make it here, we are good to go using hardware instancing! Hooray performance!\n        type = LayerBufferType.INSTANCE_ATTRIBUTE;\n      }\n    }\n\n    // No other faster mode supported: use uniform instancing\n    if (type === LayerBufferType.UNIFORM) {\n      debug(\n        `Performance Issue (High):\n        Layer %o is utilizing too many vertex attributes and is now using a uniform buffer.\n        Max Vertex units %o\n        Used Vertex units %o\n        Instance Attributes %o\n        Vertex Attributes %o`,\n        this.id,\n        WebGLStat.MAX_VERTEX_ATTRIBUTES,\n        attributesUsed,\n        instanceAttributes,\n        vertexAttributes\n      );\n      type = LayerBufferType.UNIFORM;\n    }\n\n    // Apply the type to the layer\n    this.setBufferType(type);\n\n    return type;\n  }\n\n  /**\n   * This generates the buffer manager to be used to manage instances getting applied to attribute locations.\n   */\n  makeLayerBufferManager(gl: WebGLRenderingContext, scene: LayerScene) {\n    // Esnure the buffering type has been calculated for the layer\n    const type = this.getLayerBufferType(\n      gl,\n      this.shaderIOInfo.vertexAttributes,\n      this.shaderIOInfo.instanceAttributes\n    );\n\n    switch (type) {\n      // This is the Instance Attribute buffering strategy, which means the system\n      case LayerBufferType.INSTANCE_ATTRIBUTE: {\n        this.setBufferManager(new InstanceAttributeBufferManager(this, scene));\n        break;\n      }\n\n      // This is the Instance Attribute buffering strategy, which means the system\n      case LayerBufferType.INSTANCE_ATTRIBUTE_PACKING: {\n        this.setBufferManager(\n          new InstanceAttributePackingBufferManager(this, scene)\n        );\n        break;\n      }\n\n      // Anything not utiliziing a specialized buffering strategy will use the uniform compatibility mode\n      default: {\n        this.setBufferManager(new UniformBufferManager(this, scene));\n        break;\n      }\n    }\n  }\n\n  /**\n   * This checks the state of the layer and determines how it should handle it's diff event handlers\n   */\n  updateDiffHandlers() {\n    // See if there are any attributes that have  auto easing involved\n    const easing = (this.shaderIOInfo.instanceAttributes || []).find(check =>\n      Boolean(check && check.easing)\n    );\n\n    // Establish the diff processing this layer needs to do based on the Easing IO present\n    // This will ensure there is not already some diff manager handling already established as a base layer's\n    // implementation.\n    if (easing) {\n      if (this.picking.type === PickType.SINGLE) {\n        this.onDiffAdd = this.handleDiffAddWithPickingAndEasing;\n        this.onDiffRemove = this.handleDiffRemoveWithPickingAndEasing;\n      } else {\n        this.onDiffAdd = this.handleDiffAddWithEasing;\n        this.onDiffRemove = this.handleDiffRemoveWithEasing;\n      }\n    } else {\n      if (this.picking.type === PickType.SINGLE) {\n        this.onDiffAdd = this.handleDiffAddWithPicking;\n        this.onDiffRemove = this.handleDiffRemoveWithPicking;\n      }\n    }\n  }\n\n  /**\n   * This is the default implementation for onDiffManagerAdd that gets applied if easing is present in the layer's IO.\n   */\n  private handleDiffAddWithEasing(instance: T) {\n    instance.easingId = this.easingId;\n  }\n\n  /**\n   * Handles diff manager add operations when the layer has picking enabled\n   */\n  private handleDiffAddWithPicking(instance: T) {\n    // Make sure the instance is mapped to it's UID\n    this.uidToInstance.set(instance.uid, instance);\n  }\n\n  /**\n   * Handles diff manager add operations when the layer has picking AND easing enabled\n   */\n  private handleDiffAddWithPickingAndEasing(instance: T) {\n    // Make sure the instance is mapped to it's UID\n    this.uidToInstance.set(instance.uid, instance);\n    // Make sure the instance has it's easing identifiers available for it's use within this layer\n    instance.easingId = this.easingId;\n  }\n\n  /**\n   * This is the default implementation for onDiffManagerRemove that gets applied if easing is present in the layer's\n   * IO\n   */\n  private handleDiffRemoveWithEasing(instance: T) {\n    if (instance.easing) delete instance.easing;\n    delete instance.easingId;\n  }\n\n  /**\n   * Handles diff manager remove operations when the layer has picking enabled\n   */\n  private handleDiffRemoveWithPicking(instance: T) {\n    // Remove the instance from our identifier list to prevent memory zombies\n    this.uidToInstance.delete(instance.uid);\n  }\n\n  /**\n   * Handles diff manager remove operations when the layer has picking AND easing enabled\n   */\n  private handleDiffRemoveWithPickingAndEasing(instance: T) {\n    // Remove the instance from our identifier list to prevent memory zombies\n    this.uidToInstance.delete(instance.uid);\n    // Remove the reference to the easing identifiers to prevent memory zombies\n    if (instance.easing) delete instance.easing;\n    delete instance.easingId;\n  }\n\n  /**\n   * This tells the framework to rebuild the layer from scratch, thus reconstructing the shaders and geometries\n   * of the layer.\n   */\n  rebuildLayer() {\n    this.willRebuildLayer = true;\n\n    // Children will be rebuilt as well\n    if (this.children) {\n      for (let i = 0, iMax = this.children.length; i < iMax; ++i) {\n        const child = this.children[i];\n        child.rebuildLayer();\n      }\n    }\n  }\n\n  /**\n   * Retrieves the changes from the data provider and resolves the provider. This should be\n   * used by sub Layer classes that wish to create their own custom draw handlers.\n   *\n   * Set preserverProvider to true to let the system know the provider's changes are still\n   * required.\n   */\n  resolveChanges(preserveProvider?: boolean) {\n    // Consume the diffs for the instances to update each element\n    const changeList = this.props.data.changeList;\n    // Set needsViewDrawn to be true if there is any change\n    if (changeList.length > 0) this.needsViewDrawn = true;\n\n    // See if we should make the provider not consume it's changes yet\n    if (!preserveProvider) {\n      // Resolve the changes from the provider so it can start collecting\n      // a new list of changes to apply\n      this.props.data.resolve(this.id);\n    }\n\n    // Clear the changes from all instances to be ready for next frame\n    for (let i = 0, iMax = changeList.length; i < iMax; ++i) {\n      changeList[i][0].changes = {};\n    }\n\n    // Return the list of changes so the changes can be handled in some fashion\n    return changeList;\n  }\n\n  /**\n   * Applies a buffer manager to the layer which handles instance changes and applies those changes\n   * to an appropriate buffer at the appropriate location.\n   */\n  setBufferManager(bufferManager: BufferManagerBase<T, IBufferLocation>) {\n    if (!this._bufferManager) {\n      this._bufferManager = bufferManager;\n      this.diffManager = new InstanceDiffManager<T>();\n      this.diffManager.makeProcessor(this, bufferManager);\n    } else {\n      console.warn(\n        \"You can not change a layer's buffer strategy once it has been instantiated.\"\n      );\n    }\n  }\n\n  /**\n   * Only allows the buffer type to be set once\n   */\n  setBufferType(val: LayerBufferType) {\n    if (this._bufferType === undefined) {\n      this._bufferType = val;\n    } else {\n      console.warn(\n        \"You can not change a layers buffer strategy once it has been instantiated.\"\n      );\n    }\n  }\n\n  /**\n   * This method returns a flag indicating whether or not the layer should trigger it's view to redraw.\n   * By default, a redraw is triggered (this returns true) when a shallow comparison of the current props\n   * and the incoming props are different.\n   * This method can be overridden to place custom logic at this point to indicate when redraws should happen.\n   *\n   * NOTE: This should be considered for redraw logic centered around changes in the layer itself.\n   * There ARE additional triggers in the system that causes redraws. This method just aids in ensuring\n   * necessary redraws take place for layer level logic and props.\n   */\n  shouldDrawView(oldProps: U, newProps: U) {\n    for (const key in newProps) {\n      if (newProps[key] !== oldProps[key]) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * This triggers the layer to update the material uniforms that have been created for the layer.\n   * This is primarily used internally.\n   */\n  updateUniforms() {\n    let uniform: IUniformInternal;\n    let value: UniformIOValue;\n\n    // Loop through the uniforms that are across all instances\n    for (let i = 0, end = this.shaderIOInfo.uniforms.length; i < end; ++i) {\n      uniform = this.shaderIOInfo.uniforms[i];\n      value = uniform.update(uniform);\n      uniform.materialUniforms.forEach(\n        materialUniform => (materialUniform.value = value)\n      );\n    }\n  }\n\n  /**\n   * Lifecycle: Fires before the props object is updated with the newProps. Allows layer to\n   * respond to diff changes.\n   */\n  willUpdateProps(newProps: ILayerProps<T>) {\n    // Pick type changes needs to trigger layer rebuild.\n    if (newProps.picking !== this.props.picking) {\n      this.rebuildLayer();\n    }\n\n    // Populate the ref with the information of this layer\n    if (newProps.ref !== this.props.ref && this.props.ref) {\n      this.props.ref.easing = this.easingManager;\n    }\n  }\n}\n","let toEmit: { [key: string]: [Function, number, number] } = {};\n\nexport function emitOnce(\n  id: string,\n  callback: (calledCountBeforeEmit: number, id: string) => void\n) {\n  const emit = toEmit[id] || [callback, -1, 0];\n  toEmit[id] = emit;\n  emit[2]++;\n\n  clearTimeout(emit[1]);\n  emit[1] = window.setTimeout(() => {\n    callback(emit[2], id);\n    delete toEmit[id];\n  }, 1);\n}\n\nexport function flushEmitOnce() {\n  for (const id in toEmit) {\n    const emit = toEmit[id];\n    clearTimeout(emit[1]);\n    emit[0](emit[2], id);\n  }\n\n  toEmit = {};\n}\n","import { uniformBufferInstanceBufferName } from \"../../../constants\";\nimport { Attribute, Geometry, Material, Model } from \"../../../gl\";\nimport {\n  IMaterialUniform,\n  isUniformVec4Array,\n  MaterialUniformType\n} from \"../../../gl/types\";\nimport { Instance } from \"../../../instance-provider\";\nimport { Vec2, Vec4 } from \"../../../math\";\nimport { IInstanceAttribute } from \"../../../types\";\nimport { uid } from \"../../../util\";\nimport { Layer } from \"../../layer\";\nimport { generateLayerModel } from \"../../layer-processing/generate-layer-model\";\nimport { LayerScene } from \"../../layer-scene\";\nimport { BufferManagerBase, IBufferLocation } from \"../buffer-manager-base\";\n\nexport interface IUniformBufferLocation extends IBufferLocation {\n  /** This is the index of the instance as it appears in the buffer */\n  instanceIndex: number;\n  /** This is the instance data uniform */\n  buffer: IMaterialUniform<MaterialUniformType.VEC4_ARRAY>;\n  /** This is the instance data range within the instanceData uniform */\n  range: Vec2;\n}\n\n/**\n * Typeguard for uniform buffer locations\n */\nexport function isUniformBufferLocation(\n  val: any\n): val is IUniformBufferLocation {\n  return (\n    val &&\n    val.buffer &&\n    val.buffer.value &&\n    val.type === MaterialUniformType.VEC4_ARRAY\n  );\n}\n\nexport interface InstanceUniformBuffer {\n  /** This tracks which instances are active. Helps optimize draw range */\n  activeInstances: boolean[];\n  /** This is all of the clusters within this buffer */\n  clusters: IUniformBufferLocation[];\n  /** The first instance in the draw range */\n  firstInstance: number;\n  /** The unique geometry object for the buffer: Used to set draw range */\n  geometry: Geometry;\n  /** The last instance in the draw range */\n  lastInstance: number;\n  /** The unique material for the buffer: Used to provide a new set of uniforms */\n  material: Material;\n  /** The unique model generated for the buffer: Used to allow the buffer to be rendered by adding to a scene */\n  model: Model;\n}\n\n/**\n * This is a Buffer Management system that performs instancing via the uniforms available to the hardware.\n * This improves compatibility with instancing for systems DRAMATICALLY as ALL systems WILL support uniforms.\n * This will NOT perform the best against true hardware instancing support, but it will have edge cases where it\n * is needed.\n *\n * When a layer has too many instance + vertex attributes for the hardware, the system will defer to this buffer methodology.\n *\n * This class does a whoooooole lot of making the magical instancing optimization controls possible.\n *\n * Our instancing hackyness comes from the idea that uniforms are fast, and you don't have to commit\n * ALL of them when you touch just a little piece, and you don't have worry about drivers not supporting\n * partial vertex buffer updates.\n *\n * This also is WebGL 1.0 compatible without any extensions that are poorly implemented. And again: does\n * NOT require entire attribute buffer commits.\n *\n * Uniforms are limited for any given draw call. So we have to create multiple materials to support\n * chunks of the instances that need to be drawn. We then have to associate an instance with the set\n * of uniforms that is related to the instance and keep them paired together. If we have too many instances\n * we must generate more buffers to accomodate them.\n *\n * If we remove instances, we must free up the uniform set so that others can use the uniforms. While the uniforms\n * are not in use, the instance should not be rendering.\n */\nexport class UniformBufferManager<T extends Instance> extends BufferManagerBase<\n  T,\n  IUniformBufferLocation\n> {\n  /** The number of uniform blocks an instance requires */\n  private uniformBlocksPerInstance: number;\n  /** The generated buffers by this manager */\n  private buffers: InstanceUniformBuffer[] = [];\n  /** The uniform clusters that are free and can be used by an instance */\n  private availableClusters: IUniformBufferLocation[] = [];\n  /** A lookup of an instance to a cluster of uniforms associated with it */\n  private instanceToCluster: { [key: number]: IUniformBufferLocation } = {};\n  /** A map of a cluster of uniforms to the buffer it comes from */\n  private clusterToBuffer = new Map<\n    IUniformBufferLocation,\n    InstanceUniformBuffer\n  >();\n\n  constructor(layer: Layer<T, any>, scene: LayerScene) {\n    super(layer, scene);\n\n    let maxUniformBlock: number = 0;\n    layer.shaderIOInfo.instanceAttributes.forEach(\n      (attributes: IInstanceAttribute<T>) => {\n        maxUniformBlock = Math.max(attributes.block || 0, maxUniformBlock);\n      }\n    );\n\n    this.uniformBlocksPerInstance = maxUniformBlock + 1;\n  }\n\n  /**\n   * This adds an instance to the manager and gives the instance an associative\n   * block of uniforms to work with.\n   */\n  add = (instance: T) => {\n    // If there are no available buffers, we must add a buffer\n    if (this.availableClusters.length <= 0) {\n      this.makeNewBuffer();\n    }\n\n    const cluster = this.availableClusters.pop();\n\n    if (cluster) {\n      this.instanceToCluster[instance.uid] = cluster;\n    } else {\n      console.warn(\n        \"No valid cluster available for instance added to uniform manager.\"\n      );\n    }\n\n    return cluster;\n  };\n\n  /**\n   * Free all resources this manager may be holding onto\n   */\n  destroy() {\n    this.buffers.forEach(buffer => {\n      buffer.geometry.dispose();\n      buffer.material.dispose();\n    });\n  }\n\n  /**\n   * This retireves the uniforms associated with an instance, or returns nothing\n   * if the instance has not been associated yet.\n   */\n  getBufferLocations(instance: T) {\n    return this.instanceToCluster[instance.uid];\n  }\n\n  /**\n   * TODO: The uniform buffer does not need to utilize this yet. it will be more necessary\n   * when this manager updates only changed properties.\n   */\n  getActiveAttributePropertyId() {\n    return -1;\n  }\n\n  /**\n   * TODO: This is irrelevant tot his manager for now.\n   * Number of instances this buffer manages.\n   */\n  getInstanceCount() {\n    return -1;\n  }\n\n  /**\n   * TODO: The uniform buffer updates ALL attributes every change for any property so far.\n   * This should be fixed for performance improvements on the compatibility mode.\n   */\n  getUpdateAllPropertyIdList() {\n    return [];\n  }\n\n  /**\n   * Checks to see if the instance is managed by this manager.\n   */\n  managesInstance(instance: T) {\n    return this.instanceToCluster[instance.uid] === undefined;\n  }\n\n  /**\n   * Disassociates an instance with it's group of uniforms and makes the instance\n   * in the buffer no longer drawable.\n   */\n  remove = function(instance: T) {\n    const cluster = this.instanceToCluster[instance.uid];\n\n    // If the instance is associated with a cluster, we can add the cluster back to being available\n    // For another instance.\n    if (cluster) {\n      delete this.instanceToCluster[instance.uid];\n      this.availableClusters.push(cluster);\n    }\n\n    return instance;\n  };\n\n  /**\n   * Clears all elements of this manager from the current scene it was in.\n   */\n  removeFromScene() {\n    const scene = this.scene;\n\n    if (scene.container) {\n      for (let i = 0, end = this.buffers.length; i < end; ++i) {\n        const buffer = this.buffers[i];\n        scene.container.remove(buffer.model);\n      }\n\n      delete this.scene;\n    }\n  }\n\n  /**\n   * Applies the buffers to the provided scene for rendering.\n   */\n  setScene(scene: LayerScene) {\n    if (scene.container) {\n      for (let i = 0, end = this.buffers.length; i < end; ++i) {\n        const buffer = this.buffers[i];\n        scene.container.add(buffer.model);\n      }\n\n      this.scene = scene;\n    } else {\n      console.warn(\"Can not set a scene that has an undefined container.\");\n    }\n  }\n\n  /**\n   * This generates a new buffer of uniforms to associate instances with.\n   */\n  makeNewBuffer() {\n    const shaderIOInfo = this.layer.shaderIOInfo;\n    // We generate a new geometry object for the buffer as the geometry\n    // Needs to have it's own unique draw range per buffer for optimal\n    // Performance\n    const newGeometry = new Geometry();\n    shaderIOInfo.vertexAttributes.forEach(attribute => {\n      if (attribute.materialAttribute) {\n        newGeometry.addAttribute(attribute.name, attribute.materialAttribute);\n      }\n    });\n\n    // This is the material that is generated for the layer that utilizes all of the generated and\n    // Injected shader IO and shader fragments\n    const newMaterial = shaderIOInfo.material.clone();\n    // Now make a Model for the buffer so it can be rendered withn the scene\n    const newModel = generateLayerModel(\n      newGeometry,\n      newMaterial,\n      shaderIOInfo.model.drawMode\n    );\n    // Ensure the draw range covers every instance in the geometry.\n    newModel.vertexDrawRange = [\n      0,\n      shaderIOInfo.maxInstancesPerBuffer * shaderIOInfo.instanceVertexCount\n    ];\n\n    // Make our new buffer which will manage the geometry and everything necessary\n    const buffer: InstanceUniformBuffer = {\n      activeInstances: [],\n      clusters: [],\n      firstInstance: 0,\n      geometry: newGeometry,\n      lastInstance: 0,\n      material: newMaterial,\n      model: newModel\n    };\n\n    this.buffers.push(buffer);\n\n    // Now that we have created a new buffer, we have all of it's uniforms\n    // To use to render more instances. We must take the instancing uniforms\n    // And divvy them up into clusters for our available buffer.\n    let uniformIndex = 0;\n    const uniformName = uniformBufferInstanceBufferName;\n    const instanceData = newMaterial.uniforms[uniformName];\n\n    // Type guard this uniform to ensure we're dealing with the correct type\n    if (isUniformVec4Array(instanceData)) {\n      // We must ensure the vector objects are TOTALLY unique otherwise they'll get shared across buffers\n      instanceData.value = instanceData.value.map<Vec4>(() => [\n        0.0,\n        0.0,\n        0.0,\n        0.0\n      ]);\n    } else {\n      console.warn(\n        \"Material is utilizing an invalid uniform type for Uniform Buffer Management. Buffering will not be possible.\"\n      );\n      return;\n    }\n\n    // A fake attribute to satisfy type requirements\n    const fakeAttribute = Object.assign(\n      {},\n      shaderIOInfo.instanceAttributes[0],\n      {\n        bufferAttribute: new Attribute(new Float32Array(1), 1),\n        uid: uid()\n      }\n    );\n\n    for (let i = 0, end = shaderIOInfo.maxInstancesPerBuffer; i < end; ++i) {\n      const cluster: IUniformBufferLocation = {\n        attribute: fakeAttribute, // TODO: This is not needed for the uniform method yet. When we break down\n        // the uniform updates into attributes, this will be utilized.\n        buffer: instanceData,\n        instanceIndex: i,\n        range: [uniformIndex, 0]\n      };\n\n      uniformIndex += this.uniformBlocksPerInstance;\n      cluster.range[1] = uniformIndex;\n\n      buffer.clusters.push(cluster);\n      this.availableClusters.push(cluster);\n      this.clusterToBuffer.set(cluster, buffer);\n    }\n\n    // Grab the global uniforms from the material and add it to the uniform's materialUniform list so that\n    // We can keep uniforms consistent across all Instances\n    for (let i = 0, end = shaderIOInfo.uniforms.length; i < end; ++i) {\n      const uniform = shaderIOInfo.uniforms[i];\n      uniform.materialUniforms.push(newMaterial.uniforms[uniform.name]);\n    }\n\n    // Now that we are ready to utilize the buffer, let's add it to the scene so it may be rendered.\n    // Each new buffer equates to one draw call.\n    if (this.scene && this.scene.container) {\n      this.scene.container.add(buffer.model);\n    }\n  }\n}\n","import { Instance } from \"../../instance-provider\";\nimport { InstanceDiff } from \"../../types\";\nimport {\n  BufferManagerBase,\n  IBufferLocation,\n  IBufferLocationGroup\n} from \"./buffer-manager-base\";\nimport { IInstanceDiffManagerTarget } from \"./instance-diff-manager\";\n\n/**\n * Base requirements for handling diffs from a layer.\n */\nexport abstract class BaseDiffProcessor<T extends Instance> {\n  layer: IInstanceDiffManagerTarget<T>;\n  bufferManager: BufferManagerBase<T, IBufferLocation>;\n\n  constructor(\n    layer: IInstanceDiffManagerTarget<T>,\n    bufferManager: BufferManagerBase<T, IBufferLocation>\n  ) {\n    this.layer = layer;\n    this.bufferManager = bufferManager;\n  }\n\n  /** Perform an 'add' operation for the instance's buffer */\n  abstract addInstance(\n    manager: this,\n    instance: T,\n    propIds: number[],\n    bufferLocation?: IBufferLocation | IBufferLocationGroup<IBufferLocation>\n  ): void;\n  /** Perform a 'change' operation for the instance's buffer */\n  abstract changeInstance(\n    manager: this,\n    instance: T,\n    propIds: number[],\n    bufferLocation?: IBufferLocation | IBufferLocationGroup<IBufferLocation>\n  ): void;\n  /** Perform a 'remove' operation for the instance's buffer */\n  abstract removeInstance(\n    manager: this,\n    instance: T,\n    propIds: number[],\n    bufferLocation?: IBufferLocation | IBufferLocationGroup<IBufferLocation>\n  ): void;\n\n  /**\n   * This indicates all changes have been applied, this allows the processor to finalize buffer updates\n   */\n  abstract commit(): void;\n  /**\n   * This will be called with the changes that WILL be processed. This allows this processor to make extra judgement calls on\n   * how it will process the changes and let's it optimize itself before changes are actually processed. An example optimization:\n   *\n   * Buffers have an update range we can adjust so only a piece of the buffer is updated. However, calculating that range causes\n   * overhead to calculate the affected range. So, if we have mass changes happening for major sections of the buffer (number of\n   * changes approaches some large percentage of the instances supported by the buffer), then it would be more efficient just to\n   * update the entire buffer rather than discover the portion needing updating.\n   */\n  abstract incomingChangeList(changes: InstanceDiff<T>[]): void;\n}\n","module.exports = \"vec3 cameraSpace(vec3 world) {\\nreturn (world + cameraOffset) * cameraScale2D;\\n}\\nvec3 cameraSpaceSize(vec3 worldSize) {\\nreturn worldSize * cameraScale2D;\\n}\\nvec4 clipSpace(vec3 world) {\\nreturn (projection * view) * vec4(cameraSpace(world), 1.0);\\n}\\nvec4 clipSpaceSize(vec3 worldSize) {\\nreturn (projection * view) * vec4(cameraSpaceSize(worldSize), 0.0);\\n}\"","export * from \"./basic-camera-2d-controller\";\nexport * from \"./camera-2d\";\nexport * from \"./control-2d\";\nexport * from \"./layer-2d\";\nexport * from \"./reference-camera-2d\";\nexport * from \"./view-2d\";\n","export enum EdgeScaleType {\n  /** All dimensions are within world space */\n  NONE,\n  /**\n   * The control points are a delta from the end points within screen space, and the line thickness is within\n   * screen space as well all measured in pixels. The scaleFactor scales both thickness and control delta values.\n   * The endpoints remain in world space\n   */\n  SCREEN_CURVE\n}\n\nexport enum EdgeType {\n  /** Makes a straight edge with no curve */\n  LINE,\n  /** Makes a single control point Bezier curve */\n  BEZIER,\n  /** Makes a two control point bezier curve */\n  BEZIER2\n}\n\n/**\n * This is the broadphase control for edges to help handle quad tree adjustments for picking. If the edge scale type\n * is NONE, you don't need to utilize this. If you use screen space and have camera distortions along an axis, this\n * can help greatly.\n */\nexport enum EdgeBroadphase {\n  /** Use this if the broad phase detection should use both width and height of the edge's bounds */\n  ALL,\n  /** Use this to ensure a test against the edge is performed if the mouse aligns with it on the x-axis */\n  PASS_Y,\n  /** Use this to ensure a test against the edge is performed if the mouse aligns with it on the y axis */\n  PASS_X\n}\n","import { InstanceProvider } from \"../../../instance-provider/instance-provider\";\nimport { IAutoEasingMethod } from \"../../../math/auto-easing-method\";\nimport { copy2, copy4, dot2, scale2, Vec, Vec2 } from \"../../../math/vector\";\nimport { fontRequest, IFontResourceRequest } from \"../../../resources\";\nimport { KernedLayout } from \"../../../resources/text/font-map\";\nimport {\n  ILayerConstructionClass,\n  LayerInitializer\n} from \"../../../surface/layer\";\nimport { InstanceDiffType, IPickInfo, ResourceType } from \"../../../types\";\nimport { createLayer, isDefined } from \"../../../util\";\nimport { Anchor, AnchorType, ScaleMode } from \"../../types\";\nimport { ILayer2DProps, Layer2D } from \"../../view/layer-2d\";\nimport { GlyphInstance } from \"./glyph-instance\";\nimport { GlyphLayer, IGlyphLayerOptions } from \"./glyph-layer\";\nimport { LabelInstance } from \"./label-instance\";\n\n/**\n * Default characters for truncating a label.\n */\nconst DEFAULT_TRUNCATION = \"...\";\n\n/**\n * This is a lookup to quickly find the proper calculation for setting the correct anchor\n * position based on the anchor type.\n */\nconst anchorCalculator: {\n  [key: number]: (anchor: Anchor, label: LabelInstance) => void;\n} = {\n  [AnchorType.TopLeft]: (anchor: Anchor, _label: LabelInstance) => {\n    anchor.x = 0;\n    anchor.y = 0;\n  },\n  [AnchorType.TopMiddle]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.size[0] / 2.0;\n    anchor.y = 0;\n  },\n  [AnchorType.TopRight]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.size[0];\n    anchor.y = 0;\n  },\n  [AnchorType.MiddleLeft]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = 0;\n    anchor.y = label.size[1] / 2;\n  },\n  [AnchorType.Middle]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.size[0] / 2.0;\n    anchor.y = label.size[1] / 2.0;\n  },\n  [AnchorType.MiddleRight]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.size[0];\n    anchor.y = label.size[1] / 2.0;\n  },\n  [AnchorType.BottomLeft]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = 0;\n    anchor.y = label.size[1];\n  },\n  [AnchorType.BottomMiddle]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.size[0] / 2.0;\n    anchor.y = label.size[1];\n  },\n  [AnchorType.BottomRight]: (anchor: Anchor, label: LabelInstance) => {\n    anchor.x = label.size[0];\n    anchor.y = label.size[1];\n  },\n  [AnchorType.Custom]: (anchor: Anchor, _label: LabelInstance) => {\n    anchor.x = anchor.x || 0;\n    anchor.y = anchor.y || 0;\n  }\n};\n\nconst directions: Vec2[] = [\n  [-1, -1],\n  [0, -1],\n  [1, -1],\n  [-1, 0],\n  [0, 0],\n  [1, 0],\n  [-1, 1],\n  [0, 1],\n  [1, 1]\n].map((dir: Vec2) => {\n  const mag = Math.sqrt(dot2(dir, dir));\n  return scale2(dir, 1 / -mag);\n});\n\n/**\n * Lookup to quickly calculate the padding direction based on the the provided anchor type.\n */\nconst paddingCalculator: {\n  [key: number]: (anchor: Anchor) => void;\n} = {\n  [AnchorType.TopLeft]: (anchor: Anchor) => {\n    anchor.paddingDirection = scale2(directions[0], anchor.padding);\n  },\n  [AnchorType.TopMiddle]: (anchor: Anchor) => {\n    anchor.paddingDirection = scale2(directions[1], anchor.padding);\n  },\n  [AnchorType.TopRight]: (anchor: Anchor) => {\n    anchor.paddingDirection = scale2(directions[2], anchor.padding);\n  },\n  [AnchorType.MiddleLeft]: (anchor: Anchor) => {\n    anchor.paddingDirection = scale2(directions[3], anchor.padding);\n  },\n  [AnchorType.Middle]: (anchor: Anchor) => {\n    anchor.paddingDirection = [0, 0];\n  },\n  [AnchorType.MiddleRight]: (anchor: Anchor) => {\n    anchor.paddingDirection = scale2(directions[5], anchor.padding);\n  },\n  [AnchorType.BottomLeft]: (anchor: Anchor) => {\n    anchor.paddingDirection = scale2(directions[6], anchor.padding);\n  },\n  [AnchorType.BottomMiddle]: (anchor: Anchor) => {\n    anchor.paddingDirection = scale2(directions[7], anchor.padding);\n  },\n  [AnchorType.BottomRight]: (anchor: Anchor) => {\n    anchor.paddingDirection = scale2(directions[8], anchor.padding);\n  },\n  [AnchorType.Custom]: (anchor: Anchor) => {\n    anchor.paddingDirection = anchor.paddingDirection;\n  }\n};\n\n/**\n * Converts a Glyph interaction event to a Label interaction event\n */\nfunction mapHandler(handler?: (info: IPickInfo<LabelInstance>) => void) {\n  if (!handler) return undefined;\n  return (info: IPickInfo<GlyphInstance>) => {\n    handler({\n      ...info,\n      instances: info.instances.map(g => g.parentLabel).filter(isDefined)\n    } as IPickInfo<LabelInstance>);\n  };\n}\n\n/**\n * Constructor props for making a new label layer\n */\nexport interface ILabelLayerProps<TInstance extends LabelInstance>\n  extends ILayer2DProps<TInstance> {\n  /** Animation methods for various properties of the glyphs */\n  animate?: {\n    anchor?: IAutoEasingMethod<Vec>;\n    color?: IAutoEasingMethod<Vec>;\n    offset?: IAutoEasingMethod<Vec>;\n    origin?: IAutoEasingMethod<Vec>;\n  };\n  /** A custom layer to handle rendering glyph instances */\n  customGlyphLayer?: ILayerConstructionClass<\n    GlyphInstance,\n    IGlyphLayerOptions<GlyphInstance>\n  >;\n  /** String identifier of the resource font to use for the layer */\n  resourceKey?: string;\n  /** The scaling strategy the labels will use wheh scaling the scene up and down */\n  scaleMode?: ScaleMode;\n  /**\n   * This defines what characters to use to indicate truncation of labels when needed. This\n   * defaults to ellipses or three periods '...'\n   */\n  truncation?: string;\n  /** This indicates whether a label is in a textarea */\n  inTextArea?: boolean;\n\n  onMouseClick?(info: IPickInfo<TInstance>): void;\n}\n\n/**\n * This is a composite layer that will take in and manage Label Instances. The true instance\n * that will be rendered as a result of a Label Instance will simply be Glyph Instances. Hence\n * this is a composite layer that is merely a manager to split up the label's requested string\n * into Glyphs to render.\n */\nexport class LabelLayer<\n  TInstance extends LabelInstance,\n  TProps extends ILabelLayerProps<TInstance>\n> extends Layer2D<TInstance, TProps> {\n  static defaultProps: ILabelLayerProps<LabelInstance> = {\n    key: \"\",\n    data: new InstanceProvider<LabelInstance>()\n  };\n\n  /**\n   * When this is flagged, we must do a complete recomputation of all our label's glyphs positions and kernings.\n   * This event really only takes place when the font resource changes.\n   */\n  fullUpdate: boolean = false;\n  /** Provider for the glyph layer this layer manages */\n  glyphProvider = new InstanceProvider<GlyphInstance>();\n  /**\n   * Tracks all assigned glyphs for the given label.\n   */\n  labelToGlyphs = new Map<LabelInstance, GlyphInstance[]>();\n  /**\n   * This maps a label to it's request made for all of the kerning information needed for the label.\n   */\n  labelToKerningRequest = new Map<LabelInstance, IFontResourceRequest>();\n  /**\n   * This stores all of the glyphs the label is waiting on to fire the onReady event.\n   */\n  labelWaitingOnGlyph = new Map<LabelInstance, Set<GlyphInstance>>();\n  /**\n   * These are the property ids for the instances that we need to know when they changed so we can adjust\n   * the underlying glyphs.\n   */\n  propertyIds: { [key: string]: number } | undefined;\n  /**\n   * This stores the kerning request for the truncation characters.\n   */\n  truncationKerningRequest?: IFontResourceRequest;\n  /**\n   * This is the width of the truncation glyphs.\n   */\n  truncationWidth: number = -1;\n\n  /**\n   * This provides the child layers that will render on behalf of this layer.\n   *\n   * For Labels, a label is simply a group of well placed glyphs. So we defer all of\n   * the labels changes by converting the label into glyphs and applying the changes to\n   * it's set of glyphs.\n   */\n  childLayers(): LayerInitializer[] {\n    return [\n      createLayer(this.props.customGlyphLayer || GlyphLayer, {\n        animate: this.props.animate,\n        data: this.glyphProvider,\n        key: `${this.id}.glyphs`,\n        resourceKey: this.props.resourceKey,\n        scaleMode: this.props.scaleMode || ScaleMode.BOUND_MAX,\n        inTextArea: this.props.inTextArea,\n\n        picking: this.props.picking,\n        onMouseClick: mapHandler(this.props.onMouseClick),\n        onMouseUp: mapHandler(this.props.onMouseUp),\n        onMouseDown: mapHandler(this.props.onMouseDown),\n        onMouseOut: mapHandler(this.props.onMouseOut),\n        onMouseOver: mapHandler(this.props.onMouseOver),\n        onMouseMove: mapHandler(this.props.onMouseMove),\n        onMouseUpOutside: mapHandler(this.props.onMouseUpOutside),\n        onTap: mapHandler(this.props.onTap),\n        onTouchDown: mapHandler(this.props.onTouchDown),\n        onTouchUp: mapHandler(this.props.onTouchUp),\n        onTouchUpOutside: mapHandler(this.props.onTouchUpOutside),\n        onTouchMove: mapHandler(this.props.onTouchMove),\n        onTouchOut: mapHandler(this.props.onTouchOut),\n        onTouchOver: mapHandler(this.props.onTouchOver),\n        onTouchAllEnd: mapHandler(this.props.onTouchAllEnd),\n        onTouchAllOut: mapHandler(this.props.onTouchAllOut)\n      })\n    ];\n  }\n\n  /**\n   * We override the draw method of the layer to handle the diffs of the provider in a\n   * custom fashion by delegating the changes of the provider to the child layers.\n   */\n  draw() {\n    // Retrieve changes properly\n    const changes = this.resolveChanges();\n    // No changes, nothing to be done\n    if (changes.length <= 0) return;\n\n    // Make sure our instance property ids are established for the instance type involved\n    // We want only the ids of changes that causes us to\n    if (!this.propertyIds) {\n      const instance = changes[0][0];\n      this.propertyIds = this.getInstanceObservableIds(instance, [\n        \"text\",\n        \"active\",\n        \"anchor\",\n        \"color\",\n        \"origin\",\n        \"fontSize\",\n        \"maxWidth\",\n        \"maxScale\",\n        \"letterSpacing\"\n      ]);\n    }\n\n    const {\n      text: textId,\n      active: activeId,\n      anchor: anchorId,\n      color: colorId,\n      origin: originId,\n      fontSize: fontSizeId,\n      maxWidth: maxWidthId,\n      maxScale: maxScaleId,\n      letterSpacing: letterSpacingId\n    } = this.propertyIds;\n\n    for (let i = 0, iMax = changes.length; i < iMax; ++i) {\n      const [instance, diffType, changed] = changes[i];\n\n      switch (diffType) {\n        case InstanceDiffType.CHANGE:\n          // Perform the insert action instead of the change if the label has never been registered\n          if (!this.labelToGlyphs.get(instance)) {\n            this.insert(instance);\n            continue;\n          }\n\n          // If text was changed, the glyphs all need updating of their characters and\n          // possibly have glyphs added or removed to handle the issue.\n          if (changed[textId] !== undefined) {\n            this.invalidateRequest(instance);\n            this.layoutGlyphs(instance);\n          } else if (changed[activeId] !== undefined) {\n            if (instance.active) {\n              this.layoutGlyphs(instance);\n              this.showGlyphs(instance);\n            } else {\n              this.hideGlyphs(instance);\n            }\n          }\n\n          if (changed[anchorId]) {\n            this.updateAnchor(instance);\n          }\n\n          if (changed[colorId] !== undefined) {\n            this.updateGlyphColors(instance);\n          }\n\n          if (changed[originId] !== undefined) {\n            this.updateGlyphOrigins(instance);\n          }\n\n          if (changed[maxScaleId] !== undefined) {\n            this.updateGlyphMaxScales(instance);\n          }\n\n          if (changed[fontSizeId] !== undefined) {\n            this.invalidateRequest(instance);\n            this.layoutGlyphs(instance);\n          }\n\n          if (changed[maxWidthId] !== undefined) {\n            this.invalidateRequest(instance);\n            this.layoutGlyphs(instance);\n          }\n\n          if (changed[letterSpacingId] !== undefined) {\n            this.invalidateRequest(instance);\n            this.layoutGlyphs(instance);\n          }\n          break;\n\n        case InstanceDiffType.INSERT:\n          this.insert(instance);\n          break;\n\n        case InstanceDiffType.REMOVE:\n          const glyphs = this.labelToGlyphs.get(instance);\n\n          if (glyphs) {\n            for (let i = 0, iMax = glyphs.length; i < iMax; ++i) {\n              this.glyphProvider.remove(glyphs[i]);\n            }\n\n            this.labelToGlyphs.delete(instance);\n            this.labelToKerningRequest.delete(instance);\n            this.labelWaitingOnGlyph.delete(instance);\n          }\n          break;\n      }\n    }\n  }\n\n  /**\n   * Handles first insertion operation for the label\n   */\n  private insert(instance: TInstance) {\n    // Our management flag is dependent on if the label has glyph storage or not\n    if (!instance.preload) {\n      const storage = this.labelToGlyphs.get(instance);\n      if (!storage) this.labelToGlyphs.set(instance, []);\n    }\n\n    // Make sure the instance is removed from the provider for preloads\n    else {\n      this.props.data.remove(instance);\n    }\n\n    // Insertions force a full update of all glyphs for the label\n    this.layoutGlyphs(instance);\n  }\n\n  /**\n   * When the glyph is ready to render this executes.\n   */\n  handleGlyphReady = (glyph: GlyphInstance) => {\n    // The glyph must be associated to have this work\n    if (!glyph.parentLabel) {\n      // If no parent label, we should not have this glyph returningfalse alarms to this method\n      delete glyph.onReady;\n\n      return;\n    }\n\n    // Get the label this glyph is a part of\n    const label = glyph.parentLabel;\n    // Get the list of glyphs the label is waiting on.\n    const waiting = this.labelWaitingOnGlyph.get(glyph.parentLabel);\n\n    if (!waiting) {\n      return;\n    }\n\n    // Clear this glyph from the waiting list\n    if (waiting.has(glyph)) {\n      waiting.delete(glyph);\n\n      if (waiting.size <= 0) {\n        // If the waiting list is empty we can get the label to execute it's ready handler\n        const onReady = label.onReady;\n        // Execute the callback if present\n        if (onReady) onReady(label);\n      }\n    }\n  };\n\n  /**\n   * Unmounts all of the glyphs that make the lable\n   */\n  hideGlyphs(instance: TInstance) {\n    const glyphs = this.labelToGlyphs.get(instance);\n    if (!glyphs) return;\n\n    for (let i = 0, iMax = glyphs.length; i < iMax; ++i) {\n      this.glyphProvider.remove(glyphs[i]);\n    }\n  }\n\n  /**\n   * Tell the system this layer is not providing any rendering IO information for the GPU to render.\n   */\n  initShader() {\n    return null;\n  }\n\n  /**\n   * This invalidates the request for the instance thus requiring a new request to be made\n   * to trigger the layout of the label.\n   */\n  invalidateRequest(instance: TInstance) {\n    this.labelToKerningRequest.delete(instance);\n  }\n\n  /**\n   * This uses calculated kerning information to place the glyph relative to it's left character neighbor.\n   * The first glyph will use metrics of the glyphs drop down amount to determine where the glyph\n   * will be placed.\n   */\n  layoutGlyphs(instance: TInstance) {\n    // Make sure the kerning is ready\n    if (!this.updateKerning(instance)) return;\n    // Instance must be active\n    if (!instance.active) return;\n    // Get the kerning request for the instance\n    const kerningRequest = this.labelToKerningRequest.get(instance);\n    // We must have kerning calculated for the instance to be valid for laying out the glyphs\n    if (!kerningRequest || !kerningRequest.fontMap) return;\n    // See if our request provided the metrics for the text yet\n    const requestMetrics = kerningRequest.metrics;\n    if (!requestMetrics || !requestMetrics.layout) return;\n\n    // Get the layout that will be used for the request\n    const layout = requestMetrics.layout;\n    // Update the glyphs based on the provided layout\n    this.updateGlyphs(instance, layout);\n    // Get the glyphs of the label\n    const glyphs = instance.glyphs;\n    // Store the calculated size of the label\n    instance.size = layout.size;\n    // Update the calculated anchor for the label now that size is determined\n    anchorCalculator[instance.anchor.type](instance.anchor, instance);\n    paddingCalculator[instance.anchor.type](instance.anchor);\n\n    const anchor = instance.anchor;\n    const padding = instance.anchor.paddingDirection;\n\n    // Apply the offsets calculated to each glyph\n    for (\n      let i = 0, iMax = Math.min(layout.positions.length, glyphs.length);\n      i < iMax;\n      ++i\n    ) {\n      const offset = layout.positions[i];\n      const glyph = glyphs[i];\n      glyph.offset = offset;\n      glyph.fontScale = layout.fontScale;\n      glyph.anchor = [anchor.x || 0, anchor.y || 0];\n      glyph.origin = copy2(instance.origin);\n      glyph.padding = padding || [0, 0];\n\n      glyph.maxScale = instance.maxScale;\n    }\n  }\n\n  /**\n   * This layer does not have or use a buffer manager thus it must track management of an instance\n   * in it's own way.\n   */\n  managesInstance(instance: TInstance) {\n    return Boolean(this.labelToGlyphs.get(instance));\n  }\n\n  /**\n   * This makes a label's glyphs visible by adding them to the glyph layer rendering the glyphs.\n   */\n  showGlyphs(instance: TInstance) {\n    const glyphs = this.labelToGlyphs.get(instance);\n    if (!glyphs) return;\n\n    for (let i = 0, iMax = glyphs.length; i < iMax; ++i) {\n      this.glyphProvider.add(glyphs[i]);\n    }\n  }\n\n  /**\n   * Updates the anchor position of the instance when set\n   */\n  updateAnchor(instance: TInstance) {\n    const glyphs = instance.glyphs;\n    if (!glyphs) return;\n\n    anchorCalculator[instance.anchor.type](instance.anchor, instance);\n    paddingCalculator[instance.anchor.type](instance.anchor);\n\n    const anchor = instance.anchor;\n    const padding = instance.anchor.paddingDirection;\n\n    for (let i = 0, iMax = glyphs.length; i < iMax; ++i) {\n      glyphs[i].anchor = [anchor.x || 0, anchor.y || 0];\n      glyphs[i].padding = padding || [0, 0];\n    }\n  }\n\n  /**\n   * This ensures the correct number of glyphs is being provided for the label indicated.\n   */\n  updateGlyphs(instance: TInstance, layout: KernedLayout) {\n    // Get the current glyphs rendering for the label\n    let currentGlyphs = this.labelToGlyphs.get(instance);\n\n    // Make sure we have glyph storage\n    if (!currentGlyphs) {\n      currentGlyphs = [];\n      this.labelToGlyphs.set(instance, currentGlyphs);\n    }\n\n    // Get the current list of glyphs in the waiting queue\n    let waiting = this.labelWaitingOnGlyph.get(instance);\n\n    if (!waiting) {\n      waiting = new Set();\n      this.labelWaitingOnGlyph.set(instance, waiting);\n    }\n\n    // Update the character used by existing glyphs\n    for (\n      let i = 0, iMax = Math.min(currentGlyphs.length, layout.glyphs.length);\n      i < iMax;\n      ++i\n    ) {\n      const glyph = currentGlyphs[i];\n\n      if (glyph.character !== layout.glyphs[i]) {\n        glyph.character = layout.glyphs[i];\n\n        if (\n          !glyph.request ||\n          !glyph.request.fontMap ||\n          !glyph.request.fontMap.glyphMap[glyph.character]\n        ) {\n          waiting.add(glyph);\n        }\n      }\n    }\n\n    // Make any missing glyphs\n    if (currentGlyphs.length < layout.glyphs.length) {\n      let sourceIndex = 0;\n\n      for (\n        let i = currentGlyphs.length, iMax = layout.glyphs.length;\n        i < iMax;\n        ++i, ++sourceIndex\n      ) {\n        const char = layout.glyphs[i];\n        const glyph = new GlyphInstance({\n          character: char,\n          color: instance.color,\n          origin: instance.origin,\n          maxScale: instance.maxScale,\n          onReady: this.handleGlyphReady\n        });\n\n        glyph.parentLabel = instance;\n        currentGlyphs.push(glyph);\n\n        if (instance.active) {\n          this.glyphProvider.add(glyph);\n        }\n\n        waiting.add(glyph);\n      }\n    }\n\n    // Remove excess glyphs\n    else if (currentGlyphs.length > layout.glyphs.length) {\n      for (\n        let i = layout.glyphs.length, iMax = currentGlyphs.length;\n        i < iMax;\n        ++i\n      ) {\n        const glyph = currentGlyphs[i];\n        this.glyphProvider.remove(glyph);\n      }\n\n      // Remove the glyphs from the list the label utilizes\n      while (currentGlyphs.length > layout.glyphs.length) currentGlyphs.pop();\n    }\n\n    // Update the list of glyphs that are utilized for the label's rendering\n    instance.glyphs = currentGlyphs;\n  }\n\n  /**\n   * Updates the glyph colors to match the label's glyph colors\n   */\n  updateGlyphColors(instance: TInstance) {\n    const glyphs = instance.glyphs;\n    if (!glyphs) return;\n\n    for (let i = 0, iMax = glyphs.length; i < iMax; ++i) {\n      glyphs[i].color = copy4(instance.color);\n    }\n  }\n\n  /**\n   * This updates all of the glyphs for the label to have the same position\n   * as the label.\n   */\n  updateGlyphOrigins(instance: TInstance) {\n    const glyphs = instance.glyphs;\n    if (!glyphs) return;\n    const origin = instance.origin;\n\n    for (let i = 0, iMax = glyphs.length; i < iMax; ++i) {\n      glyphs[i].origin = [origin[0], origin[1]];\n    }\n  }\n\n  /**\n   * This updates all of the glyphs for the label to have the same position\n   * as the label.\n   */\n  updateGlyphMaxScales(instance: TInstance) {\n    const glyphs = instance.glyphs;\n    if (!glyphs) return;\n    const maxScale = instance.maxScale;\n\n    for (let i = 0, iMax = glyphs.length; i < iMax; ++i) {\n      glyphs[i].maxScale = maxScale;\n    }\n  }\n\n  /**\n   * Checks the label to ensure calculated kerning supports the text specified.\n   *\n   * Returns true when the kerning information is already available\n   */\n  updateKerning(instance: TInstance) {\n    // A change in glyphs requires a potential kerning request\n    let labelKerningRequest = this.labelToKerningRequest.get(instance);\n    // This is the text the label will be making for the request\n    const checkText = instance.text;\n\n    // If we have the label kerning request, we should check to see if the font map\n    // supports the contents of the label.\n    if (labelKerningRequest) {\n      // If the request already embodies the request for the text, we just see if the\n      // font map has been provided yet to indicate if the kerning information is ready\n      if (\n        labelKerningRequest.kerningPairs &&\n        labelKerningRequest.kerningPairs.indexOf(checkText) > -1\n      ) {\n        return Boolean(labelKerningRequest.fontMap);\n      }\n\n      // If the request exists for a different text, and the font map does not support\n      // the kerning needs of the text, then we must make a new request.\n      if (\n        labelKerningRequest.fontMap &&\n        !labelKerningRequest.fontMap.supportsKerning(\n          checkText.replace(/\\s/g, \"\")\n        )\n      ) {\n        this.labelToKerningRequest.delete(instance);\n        labelKerningRequest = undefined;\n      }\n\n      // Otherwise, nothing needs to happen and we can use the font map for kerning information\n      else {\n        return true;\n      }\n    }\n\n    // If no request is present we must make one\n    if (!labelKerningRequest) {\n      const metrics: IFontResourceRequest[\"metrics\"] = {\n        // We want the request to return all of the metrics for the text as well\n        fontSize: instance.fontSize,\n        text: instance.text,\n        letterSpacing: instance.letterSpacing\n      };\n\n      // Include truncation metrics if the text needs it\n      if (instance.maxWidth > 0) {\n        metrics.maxWidth = instance.maxWidth;\n        metrics.truncation = this.props.truncation || DEFAULT_TRUNCATION;\n      }\n\n      // Make the request for retrieving the kerning information.\n      labelKerningRequest = fontRequest({\n        key: this.props.resourceKey || \"\",\n        character: \"\",\n        kerningPairs: [checkText],\n        metrics\n      });\n\n      // In order for the glyphs to be laid out, we need the font map to get the kerning information.\n      // So we send out a request to the font manager for the resource.\n      // Once the kerning information has been retrieved, the label active property will be triggered\n      // to true.\n      if (!instance.preload) {\n        this.resource.request(this, instance, labelKerningRequest, {\n          resource: {\n            type: ResourceType.FONT,\n            key: this.props.resourceKey || \"\"\n          }\n        });\n\n        this.labelToKerningRequest.set(instance, labelKerningRequest);\n      }\n\n      // For preload labels, simply make the request, but modify the resource trigger to fire off the ready\n      // event for the label\n      else {\n        instance.resourceTrigger = () => {\n          if (instance.onReady) instance.onReady(instance);\n        };\n\n        this.resource.request(this, instance, labelKerningRequest);\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * If our resource changes, we need a full update of all instances.\n   * If our provider changes, we probably want to ensure our property identifiers are correct.\n   */\n  willUpdateProps(newProps: TProps) {\n    if (newProps.data !== this.props.data) {\n      delete this.propertyIds;\n    }\n\n    // Scale mode change changes the shader needs of the underlying glyphs\n    if (newProps.scaleMode !== this.props.scaleMode) {\n      this.rebuildLayer();\n    }\n\n    if (newProps.resourceKey !== this.props.resourceKey) {\n      this.fullUpdate = true;\n    }\n  }\n}\n","import {\n  IInstanceOptions,\n  Instance,\n  observable\n} from \"../../../instance-provider\";\nimport { Vec2, Vec4 } from \"../../../math/vector\";\nimport { IFontResourceRequest } from \"../../../resources\";\nimport { Omit } from \"../../../types\";\nimport { LabelInstance } from \"./label-instance\";\n\nexport type GlyphInstanceOptions = Omit<\n  Partial<GlyphInstance>,\n  \"resourceTrigger\" | keyof Instance | \"parentLabel\" | \"request\"\n> &\n  IInstanceOptions;\n\n/**\n * Instance representing a single glyph being rendered.\n */\nexport class GlyphInstance extends Instance {\n  /** Adjustment to position the glyph relative to an anchor location on an overrarching label */\n  @observable anchor: Vec2 = [0, 0];\n  /** This is the character the glyph will render. */\n  @observable character: string = \"a\";\n  /** The color to tint the glyph */\n  @observable color: Vec4 = [1, 1, 1, 1];\n  /** Z distance of the glyph */\n  @observable depth: number = 0;\n  /**\n   * This is the scale of the glyph compared to the font resource's rendering. If the font resource\n   * is rendered at 32px, then this needs to be 20 / 32 to render the glyph at a font size of 20.\n   */\n  @observable fontScale: number = 1;\n  /** When in BOUND_MAX mode, this controls how much scaling is allowed up to the base font size */\n  @observable maxScale: number = 1;\n  /** The top left location of this glyph's offset from it's origin */\n  @observable offset: Vec2 = [0, 0];\n  /** This is the anchor point of the glyph to which the glyph scales and rotates about and is positioned */\n  @observable origin: Vec2 = [0, 0];\n  /** This is the amount of padding from the origin position to the anchor position */\n  @observable padding: Vec2 = [0, 0];\n\n  /** The label this glyph is associated with (may NOT be associated at all) */\n  parentLabel?: LabelInstance;\n  /** Fires when this instance is ready for rendering */\n  onReady?: (glyph: GlyphInstance) => void;\n  /** This is populated as a result of character updates */\n  request: IFontResourceRequest;\n\n  constructor(options: GlyphInstanceOptions) {\n    super(options);\n\n    this.origin = options.origin || this.origin;\n    this.offset = options.offset || this.offset;\n    this.character = options.character || this.character;\n    this.color = options.color || this.color;\n    this.maxScale = options.maxScale || this.maxScale;\n    this.padding = options.padding || this.padding;\n    this.anchor = options.anchor || this.anchor;\n    this.onReady = options.onReady;\n  }\n\n  /**\n   * Make a duplicate of this glyph\n   */\n  clone() {\n    const glyph = new GlyphInstance(this);\n    glyph.onReady = this.onReady;\n    glyph.request = this.request;\n  }\n\n  /**\n   * This will trigger when the resource nmanager is ready to render this glyph.\n   */\n  resourceTrigger() {\n    this.offset = this.offset;\n    this.origin = this.origin;\n    this.character = this.character;\n    this.color = this.color;\n\n    // Indicate this glyph is getting ready to render to the screen\n    if (this.onReady) this.onReady(this);\n  }\n}\n","import { InstanceProvider } from \"../../../instance-provider\";\nimport { IAutoEasingMethod, Vec, Vec2 } from \"../../../math\";\nimport {\n  fontRequest,\n  FontResourceRequestFetch,\n  IFontResourceRequest\n} from \"../../../resources\";\nimport {\n  createMaterialOptions,\n  IInstanceAttribute,\n  ILayerMaterialOptions,\n  InstanceAttributeSize,\n  IShaderInitialization,\n  VertexAttributeSize\n} from \"../../../types\";\nimport { CommonMaterialOptions } from \"../../../util\";\nimport { ScaleMode } from \"../../types\";\nimport { ILayer2DProps, Layer2D } from \"../../view/layer-2d\";\nimport { GlyphInstance } from \"./glyph-instance\";\n\n/**\n * Options available to this layer as props.\n */\nexport interface IGlyphLayerOptions<T extends GlyphInstance>\n  extends ILayer2DProps<T> {\n  /** Specifies which attributes to animate */\n  animate?: {\n    anchor?: IAutoEasingMethod<Vec>;\n    color?: IAutoEasingMethod<Vec>;\n    offset?: IAutoEasingMethod<Vec>;\n    origin?: IAutoEasingMethod<Vec>;\n  };\n  /** This is the font resource this pulls from in order to render the glyphs */\n  resourceKey?: string;\n  /** This is the scaling strategy the glyph will use when text is involved. */\n  scaleMode?: ScaleMode;\n  /** This indicates whether a glyph is in a textArea */\n  inTextArea?: boolean;\n}\n\n/**\n * Handles rendering single character glyphs using SDF and MSDF techniques\n */\nexport class GlyphLayer<\n  T extends GlyphInstance,\n  U extends IGlyphLayerOptions<T>\n> extends Layer2D<T, U> {\n  /** Set up the default props so our auto complete is a happier place */\n  static defaultProps: IGlyphLayerOptions<GlyphInstance> = {\n    key: \"\",\n    data: new InstanceProvider<GlyphInstance>(),\n    resourceKey: \"No resource specified\"\n  };\n\n  /**\n   * Easy access names of each attribute to make easing controls easier\n   */\n  static attributeNames = {\n    color: \"color\",\n    depth: \"depth\",\n    anchor: \"anchor\",\n    origin: \"origin\",\n    offset: \"offset\"\n  };\n\n  /**\n   * These are all of the requests the glyphs have generated for each character. This let's us\n   * recycle requests for same glyphs.\n   */\n  glyphRequests: { [key: string]: IFontResourceRequest } = {};\n\n  /**\n   * Create the Shader IO needed to tie our instances and the GPU together.\n   */\n  initShader(): IShaderInitialization<T> {\n    const animate = this.props.animate || {};\n    const {\n      anchor: animateAnchor,\n      color: animateColor,\n      offset: animateOffset,\n      origin: animateOrigin\n    } = animate;\n\n    const vertexInfo: { [key: number]: Vec2 } = {\n      0: [0, 0],\n      1: [0, 0],\n      2: [1, 0],\n      3: [0, 1],\n      4: [1, 1],\n      5: [1, 1]\n    };\n\n    const glyphTextureAttr: IInstanceAttribute<T> = {\n      name: \"texture\",\n      resource: {\n        key: () => this.props.resourceKey || \"\",\n        name: \"fontMap\"\n      },\n      update: o => {\n        const char = o.character;\n\n        if (!o.request || o.character !== o.request.character) {\n          if (this.glyphRequests[o.character]) {\n            o.request = this.glyphRequests[o.character];\n          } else {\n            o.request = fontRequest({\n              key: this.props.resourceKey || \"\",\n              character: char\n            });\n\n            this.glyphRequests[o.character] = o.request;\n          }\n\n          // Do a check to see if the request has been resolved. If so, the glyph is ready.\n          if (o.request.fontMap) {\n            if (o.onReady) o.onReady(o);\n          }\n        }\n\n        o.request.fetch = FontResourceRequestFetch.TEXCOORDS;\n        return this.resource.request(this, o, o.request);\n      }\n    };\n\n    /**\n     * We must make this attribute a child attribute as it is based on the exact same property\n     * as another attribute from an instance. This ensures that the change on the instance property\n     * triggers this attribute as well.\n     */\n    const glyphSizeAttr: IInstanceAttribute<T> = {\n      name: \"glyphSize\",\n      parentAttribute: glyphTextureAttr,\n      resource: {\n        key: () => this.props.resourceKey || \"\",\n        name: \"fontMap\"\n      },\n      size: InstanceAttributeSize.TWO,\n      update: o => {\n        const char = o.character;\n\n        if (!o.request || o.character !== o.request.character) {\n          if (this.glyphRequests[o.character]) {\n            o.request = this.glyphRequests[o.character];\n          } else {\n            o.request = fontRequest({\n              key: this.props.resourceKey || \"\",\n              character: char\n            });\n\n            this.glyphRequests[o.character] = o.request;\n          }\n\n          // Do a check to see if the request has been resolved. If so, the glyph is ready.\n          if (o.request.fontMap) {\n            if (o.onReady) o.onReady(o);\n          }\n        }\n\n        o.request.fetch = FontResourceRequestFetch.IMAGE_SIZE;\n        return this.resource.request(this, o, o.request);\n      }\n    };\n\n    glyphTextureAttr.childAttributes = [glyphSizeAttr];\n\n    let fs: string, vs: string;\n    const scaleMode = this.props.scaleMode || ScaleMode.ALWAYS;\n\n    switch (scaleMode) {\n      case ScaleMode.BOUND_MAX: {\n        fs = this.props.inTextArea\n          ? require(\"./text-area-layer-bound-max.fs\")\n          : require(\"./glyph-layer-bound-max.fs\");\n        vs = this.props.inTextArea\n          ? require(\"./text-area-layer-bound-max.vs\")\n          : require(\"./glyph-layer-bound-max.vs\");\n        break;\n      }\n\n      case ScaleMode.NEVER: {\n        fs = this.props.inTextArea\n          ? require(\"./glyph-layer-never.fs\")\n          : require(\"./text-area-layer-never.fs\");\n        vs = this.props.inTextArea\n          ? require(\"./text-area-layer-never.vs\")\n          : require(\"./glyph-layer-never.vs\");\n        break;\n      }\n\n      case ScaleMode.ALWAYS: {\n        fs = this.props.inTextArea\n          ? require(\"./text-area-layer-always.fs\")\n          : require(\"./glyph-layer-always.fs\");\n        vs = this.props.inTextArea\n          ? require(\"./text-area-layer-always.vs\")\n          : require(\"./glyph-layer-always.vs\");\n        break;\n      }\n\n      default: {\n        fs = require(\"./glyph-layer-always.fs\");\n        vs = require(\"./glyph-layer-always.vs\");\n        break;\n      }\n    }\n\n    return {\n      fs,\n      instanceAttributes: [\n        {\n          easing: animateColor,\n          name: GlyphLayer.attributeNames.color,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.color\n        },\n        {\n          name: GlyphLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        {\n          name: \"fontScale\",\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.fontScale]\n        },\n        {\n          easing: animateAnchor,\n          name: GlyphLayer.attributeNames.anchor,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.anchor\n        },\n        {\n          easing: animateOrigin,\n          name: GlyphLayer.attributeNames.origin,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.origin\n        },\n        {\n          easing: animateOffset,\n          name: GlyphLayer.attributeNames.offset,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.offset\n        },\n        {\n          name: \"padding\",\n          size: InstanceAttributeSize.TWO,\n          update: o => o.padding\n        },\n        {\n          name: \"maxScale\",\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.maxScale]\n        },\n        glyphSizeAttr,\n        glyphTextureAttr\n      ],\n      uniforms: [],\n      vertexAttributes: [\n        {\n          name: \"normals\",\n          size: VertexAttributeSize.TWO,\n          update: (vertex: number) =>\n            // Quad vertex side information\n            vertexInfo[vertex]\n        }\n      ],\n      vertexCount: 6,\n      vs\n    };\n  }\n\n  draw() {\n    super.draw();\n  }\n\n  /**\n   * Set up material options for the layer\n   */\n  getMaterialOptions(): ILayerMaterialOptions {\n    return Object.assign(\n      {},\n      CommonMaterialOptions.transparentImageBlending,\n      createMaterialOptions({\n        depthTest: false\n      })\n    );\n  }\n\n  /**\n   * Handle changes that need special handling\n   */\n  willUpdateProps(nextProps: U) {\n    // If the target resource changes, then we must make all of the requests re-process their requests for the new\n    // resource.\n    if (nextProps.resourceKey !== this.props.resourceKey) {\n      Object.values(this.glyphRequests).forEach(req => {\n        delete req.fontMap;\n        req.key = nextProps.resourceKey || \"\";\n      });\n      this.rebuildLayer();\n    }\n  }\n}\n","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec4 texColor = texture2D(fontMap, texCoord);\\nif (texColor.r <= 0.0) discard;\\ntexColor.a = texColor.r;\\nsetColor(texColor * vertexColor);\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec2 pushOut = normals * glyphSize * fontScale;\\nvec3 position = vec3(origin + padding - anchor + offset + pushOut, depth);\\ngl_Position = clipSpace(position);\\ntexCoord = texture.xy + (texture.zw - texture.xy) * normals;\\nvertexColor = color * color.a;\\n}\"","import { observable } from \"../../../instance-provider/observable\";\nimport { Vec1Compat } from \"../../../math\";\nimport { BorderInstance } from \"./border-instance\";\nimport { ILabelInstanceOptions, LabelInstance } from \"./label-instance\";\n\n/**\n * Alignment mode for text within a region.\n */\nexport enum TextAlignment {\n  LEFT,\n  RIGHT,\n  CENTERED\n}\n\n/**\n * WordWrap mode\n * */\nexport enum WordWrap {\n  /**\n   * NONE: New lines ONLY happen when an explicit newline character ('\\n', '\\r', '\\n\\r') occurs.\n   * Lines that exceed the maxWidth will be truncated.\n   */\n  NONE,\n  /**\n   * CHARACTER: Newlines happen on newline characters OR they happen when the row exceeds maxWidth\n   * and some characters stay in this line while the rest continue on the next line.\n   */\n  CHARACTER,\n  /**\n   * WORD: Newlines happen on newline characters OR they happen when the row exceeds maxWidth\n   * and the whole word continues on the next line.\n   */\n  WORD\n}\n\n/** This is used to mark the specialLetter when divide the textArea into several labels */\nexport enum NewLineCharacterMode {\n  /** When the scanner meets a new line sign (\"/n\", \"/r\", \"/n/r\") */\n  NEWLINE\n}\n\nexport type TextAreaLabel = LabelInstance | NewLineCharacterMode;\n\n/**\n * Options for customaizing a TextAreaInstance\n * */\nexport interface ITextAreaInstanceOptions extends ILabelInstanceOptions {\n  /* This sets the alignment of TextArea */\n  alignment?: TextAlignment;\n  /* This sets thickness of border if included */\n  borderWidth?: number;\n  /* This decides whehter the border of textArea is included */\n  hasBorder?: boolean;\n  /* This sets the distance between letters in a word */\n  letterSpacing?: number;\n  /* This sets the distance from line to next line of text */\n  lineHeight?: number;\n  /**\n   * This sets max height the text area can render. Any text beyond this point will not be rendered\n   * This also establishes the borders' height to be rendered if included\n   */\n  maxHeight?: number;\n  /* This sets distance from top, left, right, bottom of border to content of text */\n  padding?: Vec1Compat;\n  /* This decides the way to wrap a word whether this word exceeds maxWidth */\n  wordWrap?: WordWrap;\n}\n\n/**\n * This defines a multi-line area that renders text. This is essentially a label\n * with added properties to handle multi-lining.\n */\nexport class TextAreaInstance extends LabelInstance {\n  /**\n   * Specifies how tall the text area can become. If this is exceeded, the final line\n   * in the text area will end with ellipses.\n   */\n  @observable maxHeight: number = 0;\n\n  /**\n   * This specifies how tall a line should be for each line.\n   */\n  @observable lineHeight: number = 0;\n  /**\n   * This indicates if a single line of text should wrap or not. If not, the first word that goes\n   * out of bounds will be removed and replaced with ellipses. If true, excess words in a single line\n   * will wrap down to the next line to stay within the space allowed.\n   */\n  @observable wordWrap: WordWrap = WordWrap.NONE;\n  /**\n   * This changes how the alignment for the text within the region will appear.\n   */\n  @observable alignment: TextAlignment = TextAlignment.LEFT;\n  /**\n   * When onReady is called, this will be populated with all of the labels used to compose this text area\n   * SpecialLetter will be used when layouting labels, it may indicates a new line\n   */\n  labels: TextAreaLabel[] = [];\n  /** This will be used to hold new labels when a label should be divided into two labels because label is at the end a line */\n  newLabels: LabelInstance[] = [];\n  /** This holds the borders of textArea */\n  borders: BorderInstance[] = [];\n  /** This stores the old origin which is used to calculate the new positions of labels */\n  oldOrigin: [number, number];\n  /** Stores paddings for the text area, [top, right, bottom, left] */\n  @observable padding: Vec1Compat = [0, 0, 0, 0];\n  /** Border width */\n  @observable borderWidth: number = 6;\n  /** Whether the textArea has border */\n  @observable hasBorder: boolean = true;\n  /** Width of space in a textArea */\n  spaceWidth: number = 0;\n\n  constructor(options: ITextAreaInstanceOptions) {\n    super(options);\n\n    this.color = options.color;\n    this.origin = options.origin;\n    this.oldOrigin = options.origin;\n    this.text = options.text;\n    this.fontSize = options.fontSize || this.fontSize;\n    this.maxWidth = options.maxWidth || this.maxWidth;\n    this.maxHeight = options.maxHeight || this.maxHeight;\n    this.lineHeight = options.lineHeight || this.lineHeight;\n    this.wordWrap = options.wordWrap || this.wordWrap;\n    this.alignment = options.alignment || this.alignment;\n    this.padding = options.padding || this.padding;\n    this.borderWidth = options.borderWidth || this.borderWidth;\n    this.hasBorder =\n      options.hasBorder !== undefined ? options.hasBorder : this.hasBorder;\n    this.letterSpacing = options.letterSpacing || this.letterSpacing;\n  }\n}\n","import { observable } from \"../../../instance-provider\";\nimport {\n  IInstanceOptions,\n  Instance\n} from \"../../../instance-provider/instance\";\nimport { Vec2 } from \"../../../math/vector\";\nimport { Anchor, AnchorType, ScaleMode } from \"../../types\";\n\nexport interface IRectangleInstanceOptions extends IInstanceOptions {\n  /**\n   * The point on the rectangle which will be placed in world space via the x, y coords. This is also the point\n   * which the rectangle will be scaled around.\n   */\n  anchor?: Anchor;\n  /** Depth sorting of the rectangle (or the z value of the box) */\n  depth?: number;\n  /** Sets the way the rectangle scales with the world */\n  scaling?: ScaleMode;\n  /** The color the rectangle should render as */\n  color?: [number, number, number, number];\n  /** The coordinate where the rectangle will be anchored to in world space */\n  position?: Vec2;\n  /** The size of the rectangle as it is to be rendered in world space */\n  size?: Vec2;\n}\n\n/**\n * This is a lookup to quickly find the proper calculation for setting the correct anchor\n * position based on the anchor type.\n */\nconst anchorCalculator: {\n  [key: number]: (anchor: Anchor, rectangle: RectangleInstance) => void;\n} = {\n  [AnchorType.TopLeft]: (anchor: Anchor, _rectangle: RectangleInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopMiddle]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.size[0] / 2.0;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopRight]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.size[0] + anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.MiddleLeft]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = rectangle.size[1] / 2;\n  },\n  [AnchorType.Middle]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.size[0] / 2.0;\n    anchor.y = rectangle.size[1] / 2.0;\n  },\n  [AnchorType.MiddleRight]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.size[0] + anchor.padding;\n    anchor.y = rectangle.size[1] / 2.0;\n  },\n  [AnchorType.BottomLeft]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = rectangle.size[1] + anchor.padding;\n  },\n  [AnchorType.BottomMiddle]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.size[0] / 2.0;\n    anchor.y = rectangle.size[1] + anchor.padding;\n  },\n  [AnchorType.BottomRight]: (anchor: Anchor, rectangle: RectangleInstance) => {\n    anchor.x = rectangle.size[0] + anchor.padding;\n    anchor.y = rectangle.size[1] + anchor.padding;\n  },\n  [AnchorType.Custom]: (anchor: Anchor, _rectangle: RectangleInstance) => {\n    anchor.x = anchor.x || 0;\n    anchor.y = anchor.y || 0;\n  }\n};\n\n/**\n * This generates a new rectangle instance which will render a single line of text for a given layer.\n * There are restrictions surrounding rectangles due to texture sizes and rendering limitations.\n *\n * Currently, we only support rendering a rectangle via canvas, then rendering it to an Atlas texture\n * which is used to render to cards in the world for rendering. This is highly performant, but means:\n *\n * - Rectangles should only be so long.\n * - Multiline is not supported inherently\n * - Once a rectangle is constructed, only SOME properties can be altered thereafter\n *\n * A rectangle that is constructed can only have some properties set upon creating the rectangle and are locked\n * thereafter. The only way to modify them would be to destroy the rectangle, then construct a new rectangle\n * with the modifications. This has to deal with performance regarding rasterizing the rectangle\n */\nexport class RectangleInstance extends Instance {\n  /** This is the rendered color of the rectangle */\n  @observable color: [number, number, number, number] = [0, 0, 0, 1];\n  /** Depth sorting of the rectangle (or the z value of the rectangle) */\n  @observable depth: number = 0;\n  /** When in BOUND_MAX mode, this allows the rectangle to scale up beyond it's max size */\n  @observable maxScale: number = 1;\n  /** Scales the rectangle uniformly */\n  @observable scale: number = 1;\n  /** Sets the way the rectangle scales with the world */\n  @observable scaling: ScaleMode = ScaleMode.BOUND_MAX;\n  /** The size of the rectangle as it is to be rendered in world space */\n  @observable size: Vec2 = [1, 1];\n  /** The coordinate where the rectangle will be anchored to in world space */\n  @observable position: Vec2 = [0, 0];\n\n  // These are properties that can be altered, but have side effects from being changed\n\n  /** This is the anchor location on the  */\n  @observable\n  private _anchor: Anchor = {\n    padding: 0,\n    type: AnchorType.TopLeft,\n    x: 0,\n    y: 0\n  };\n\n  constructor(options: IRectangleInstanceOptions) {\n    super(options);\n\n    this.depth = options.depth || this.depth;\n    this.color = options.color || this.color;\n    this.scaling = options.scaling || this.scaling;\n    this.position = options.position || this.position;\n    this.size = options.size || this.size;\n\n    // Make sure the anchor is set to the appropriate location\n    options.anchor && this.setAnchor(options.anchor);\n  }\n\n  get anchor() {\n    return this._anchor;\n  }\n\n  /**\n   * This applies a new anchor to this rectangle and properly determines it's anchor position on the rectangle\n   */\n  setAnchor(anchor: Anchor) {\n    const newAnchor = {\n      padding: anchor.padding || 0,\n      type: anchor.type,\n      x: anchor.x || 0,\n      y: anchor.y || 0\n    };\n\n    // Calculate the new anchors position values\n    anchorCalculator[newAnchor.type](newAnchor, this);\n    // Apply the anchor\n    this._anchor = newAnchor;\n  }\n}\n","module.exports = \"vec3 rgb2hsv(vec3 c) {\\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\nvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\nvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\nfloat d = q.x - min(q.w, q.y);\\nfloat e = 1.0e-10;\\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\\nvec3 hsv2rgb(vec3 c) {\\nvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\"","import { Bounds } from \"../../math/primitives/bounds\";\nimport { IViewProps, View } from \"../../surface\";\nimport { LayerScene } from \"../../surface/layer-scene\";\nimport { Camera, CameraProjectionType, isPerspective } from \"../../util/camera\";\nimport { Projection3D } from \"./projection-3d\";\n\n/**\n * Defines the input metrics of a view for a scene.\n */\nexport interface IView3DProps extends IViewProps {}\n\n/**\n * Type guard to ensure the camera type is orthographic\n */\nfunction isOrthographic(val: Camera): val is Camera {\n  return val.projectionType === CameraProjectionType.ORTHOGRAPHIC;\n}\n\n/**\n * A View renders a perspective of a scene to a given surface or surfaces. The 3D view system assumes a y-axis\n * up system. The view also assumes the camera is located in the middle of the viewport.\n */\nexport class View3D<TViewProps extends IView3DProps> extends View<TViewProps> {\n  static defaultProps: IView3DProps = {\n    key: \"\",\n    camera: new Camera({\n      type: CameraProjectionType.PERSPECTIVE,\n      width: 100,\n      height: 100,\n      fov: Math.PI / 2,\n      far: 100000,\n      near: 1\n    }),\n    viewport: {\n      left: 0,\n      right: 0,\n      bottom: 0,\n      top: 0\n    }\n  };\n\n  projection: Projection3D;\n\n  constructor(scene: LayerScene, options: TViewProps) {\n    super(scene, options);\n    this.projection = new Projection3D();\n    this.projection.camera = options.camera;\n    this.projection.pixelRatio = this.pixelRatio;\n  }\n\n  /**\n   * This operation makes sure we have the view camera adjusted to the new viewport's needs.\n   * For default behavior this ensures that the coordinate system has no distortion or perspective, orthographic,\n   * top left as 0,0 with +y axis pointing down.\n   */\n  fitViewtoViewport(\n    _surfaceDimensions: Bounds<never>,\n    viewBounds: Bounds<View<IViewProps>>\n  ) {\n    if (isPerspective(this.props.camera)) {\n      const width = viewBounds.width;\n      const height = viewBounds.height;\n\n      const viewport = {\n        near: 1,\n        far: 100000,\n        width,\n        height\n      };\n\n      const camera = this.props.camera;\n\n      camera.projectionOptions = Object.assign(\n        camera.projectionOptions,\n        viewport\n      );\n\n      camera.update();\n\n      this.projection.pixelRatio = this.pixelRatio;\n      this.projection.viewBounds = viewBounds;\n      this.projection.viewBounds.d = this;\n      this.projection.screenBounds = new Bounds<View<TViewProps>>({\n        height: this.projection.viewBounds.height / this.pixelRatio,\n        width: this.projection.viewBounds.width / this.pixelRatio,\n        x: this.projection.viewBounds.x / this.pixelRatio,\n        y: this.projection.viewBounds.y / this.pixelRatio\n      });\n      this.projection.screenBounds.d = this;\n    } else if (!isOrthographic(this.props.camera)) {\n      console.warn(\"View3D does not support orthographic cameras yet.\");\n    }\n  }\n\n  willUpdateProps(newProps: IView3DProps) {\n    this.projection.camera = newProps.camera;\n  }\n}\n","import {\n  Mat4x4,\n  multiply4x4,\n  project3As4ToScreen,\n  transform4\n} from \"../../math\";\nimport { BaseProjection } from \"../../math/base-projection\";\nimport { apply2, apply3, scale2, Vec2, Vec3, vec4 } from \"../../math/vector\";\nimport { Camera, CameraProjectionType } from \"../../util/camera\";\n\nexport class Projection3D extends BaseProjection<any> {\n  /** Camera used for the 3d view. */\n  camera: Camera;\n\n  /**\n   * Maps a coordinate relative to the screen to the pixel's location within the 3D world. Remember that a camera with\n   * a view creates a frustum to work within the 3D world. This frustum has a near clipping plane and a far clipping\n   * plane.\n   *\n   * This method provides a point located in front of the camera that would be located on a ray eminating from the\n   * camera to the world.\n   *\n   * To make a ray from this point simply: rayFromPoints(camera.position, screenToWorld([x, y]))\n   */\n  screenToWorld(point: Vec2, out?: Vec3): Vec3 {\n    out = out || [0, 0, 0];\n    // Make sure the point is relative to the view then use the view to world projection\n    this.viewToWorld(this.screenToView(point), out);\n\n    return out;\n  }\n\n  /**\n   * Maps a coordinate found within the world to a relative coordinate within the screen space.\n   */\n  worldToScreen(point: Vec3, out?: Vec2) {\n    out = out || [0, 0];\n\n    const viewProjection: Mat4x4 = multiply4x4(\n      this.camera.projection,\n      this.camera.view\n    );\n\n    const screen = project3As4ToScreen(\n      viewProjection,\n      point,\n      this.viewBounds.width,\n      this.viewBounds.height\n    );\n\n    return apply2(\n      out,\n      screen[0] / this.pixelRatio,\n      screen[1] / this.pixelRatio\n    );\n  }\n\n  /**\n   * Maps a coordinate relative to the view to the pixel's location within the 3D world. Remember that a camera with\n   * a view creates a frustum to work within the 3D world. This frustum has a near clipping plane and a far clipping\n   * plane.\n   *\n   * This method provides a point located in front of the camera that would be located on a ray eminating from the\n   * camera to the world.\n   *\n   * To make a ray from this point simply: const ray = rayFromPoints(camera.position, screenToWorld([x, y]))\n   * To get a point located a distance from the camera: rayToLocation(ray, distance);\n   */\n  viewToWorld(point: Vec2, out?: Vec3) {\n    out = out || [0, 0, 0];\n    const { width, height } = this.viewBounds;\n    const { projectionOptions } = this.camera;\n    const renderSpace = scale2(point, this.pixelRatio);\n    const { tan } = Math;\n\n    // We here analyze the point specified and calculate a ray that would project out into the world such that it\n    // eminates where the ray would appear as a dot flying away from the screen.\n    if (projectionOptions.type === CameraProjectionType.PERSPECTIVE) {\n      const { fov, near } = projectionOptions;\n      let Px, Py;\n\n      const aspect = height / width;\n      const r = tan(fov / 2) * near;\n\n      // We assume z = 1 and algebraically reverse the projection operation to solve for the vector input instead of the\n      // screen.\n      Px = (2 * ((renderSpace[0] + 0.5) / width) - 1) * r;\n      Py = (1 - 2 * ((renderSpace[1] + 0.5) / height)) * r * aspect;\n\n      const rayReference: Vec3 = [Px, Py, -1];\n      const world = transform4(\n        this.camera.transform.matrix,\n        vec4(rayReference, 1)\n      );\n      apply3(out, world[0], world[1], world[2]);\n    } else {\n      console.warn(\n        \"Projections with orthographic cameras and 3D contexts are not working yet\"\n      );\n    }\n\n    return out;\n  }\n\n  /**\n   * Maps a coordinate found within the world to a relative coordinate within the view's viewport.\n   */\n  worldToView(point: Vec3, out?: Vec2) {\n    out = out || [0, 0];\n\n    const viewProjection: Mat4x4 = multiply4x4(\n      this.camera.projection,\n      this.camera.view\n    );\n\n    const screen = project3As4ToScreen(\n      viewProjection,\n      point,\n      this.viewBounds.width,\n      this.viewBounds.height\n    );\n\n    return apply2(\n      out,\n      screen[0] / this.pixelRatio,\n      screen[1] / this.pixelRatio\n    );\n  }\n}\n","export * from \"./transform\";\nexport * from \"./node-3d\";\n","import {\n  IInstanceOptions,\n  Instance,\n  observable\n} from \"../../../instance-provider\";\nimport { Quaternion, Vec3 } from \"../../../math\";\nimport { Transform } from \"../../scene-graph\";\n\nexport interface IInstance3DOptions extends IInstanceOptions {\n  /** The transform object that will manage this instance */\n  transform: Transform;\n}\n\n/**\n * Basic properties of an instance that exists within a 3D world.\n */\nexport class Instance3D extends Instance {\n  /** This is the 3D transform that will place this object within the 3D world. */\n  @observable private _transform: Transform;\n  get transform() {\n    return this._transform;\n  }\n  set transform(val: Transform) {\n    if (this._position !== val.position) this._position = val.position;\n    if (this._rotation !== val.rotation) this._rotation = val.rotation;\n    if (this.scale !== val.scale) this._scale = val.scale;\n    this._transform = val;\n  }\n\n  /** World position of the Instance */\n  get position() {\n    return this._position;\n  }\n  @observable private _position: Vec3 = [0, 0, 0];\n\n  /** Rotation of the Instance */\n  get rotation() {\n    return this._rotation;\n  }\n  @observable private _rotation: Quaternion = [1, 0, 0, 0];\n\n  get scale() {\n    return this._scale;\n  }\n  @observable private _scale: Vec3 = [1, 1, 1];\n\n  constructor(options: IInstance3DOptions) {\n    super(options);\n    this.transform = options.transform;\n  }\n}\n","import \"./util/webgl2-type-shim\";\n\nexport * from \"./event-management\";\nexport * from \"./2d\";\nexport * from \"./3d\";\nexport * from \"./instance-provider\";\nexport * from \"./surface\";\nexport * from \"./types\";\nexport * from \"./util\";\nexport * from \"./shaders\";\nexport * from \"./resources\";\nexport * from \"./gl\";\nexport * from \"./base-surfaces\";\nexport * from \"./util-layers\";\nexport * from \"./math\";\n","/**\n * This provides a WebGL2RenderingContext class object for the system to check instanceof so\n * type checking for WebGL2RenderingContext does not break the system\n * when the target device does not have any notion of WebGL2 within it's environment.\n *\n * This does not attempt to mimic ANY behavior, it merely makes:\n *\n * foo instanceof WebGL2RenderingContext\n *\n * return false instead of break and error the system.\n */\n(window as any).WebGL2RenderingContext =\n  (window as any).WebGL2RenderingContext ||\n  function WebGL2RenderingContext() {\n    /** Do nothing */\n  };\n","export * from \"./event-manager\";\nexport * from \"./simple-event-handler\";\nexport * from \"./types\";\nexport * from \"./user-input-event-manager\";\n","import { Vec2 } from \"../math/vector\";\nimport { IViewProps, View } from \"../surface/view\";\n\nexport enum MouseButton {\n  /** No button detected */\n  NONE = -1,\n  /** Mouse click left */\n  LEFT = 0,\n  /** Usually mouse wheel click */\n  AUX = 1,\n  /** Mosue right click */\n  RIGHT = 2,\n  /** Usually side left mouse button (will cause 'browser back' in some cases) */\n  FOURTH = 3,\n  /** Usually side right mouse button (will cause 'browser forward' in some cases) */\n  FIFTH = 4\n}\n\nexport interface IEventInteraction {\n  /** Metrics of the interaction in screen space */\n  screen: {\n    position: Vec2;\n  };\n  /**\n   * The View the touch was 'down' on. The position stored is the screen position relative to the view.\n   */\n  start: {\n    /** Position the touch started relative to the view */\n    position: Vec2;\n    /** The immediate view beneath the touch when the touch started */\n    view: View<IViewProps>;\n    /** All of the views beneath the touch when the touch started */\n    views: {\n      /** The position of the touch where it started relative to the view */\n      position: Vec2;\n      /** A view beneath the start position of the touch, but possibly not the immediate view */\n      view: View<IViewProps>;\n    }[];\n  };\n  /** The View Immediately underneath the touch. The position stored is the screen position relative to the view. */\n  target: {\n    /** The position of the touch relative to the target */\n    position: Vec2;\n    /** The view imeediately beneath the touch */\n    view: View<IViewProps>;\n    /** All views beneath the touch (views that may be overlapping within the area) */\n    views: {\n      /** The position of the touch relative to the view indicated */\n      position: Vec2;\n      /** One of the view's beneath the touch currently. */\n      view: View<IViewProps>;\n    }[];\n  };\n}\n\n/**\n * This represents an interaction with the Layer Surface. It provides mouse metrics with how the mouse\n * interacts with the views below it.\n */\nexport interface IMouseInteraction extends IEventInteraction {\n  /** The metrics associated with the mouse during this interaction */\n  mouse: IMouseMetrics;\n}\n\nexport interface IWheelMetrics {\n  delta: [number, number];\n}\n\n/**\n * This is metrics measured between two touches\n */\nexport interface ITouchRelation {\n  /** The direction to the other touch */\n  direction: Vec2;\n  /** The current distance to the other touch */\n  distance: number;\n  /** The id of the other touch */\n  id: number;\n}\n\n/**\n * This is the information of a touch for a given frame.\n */\nexport interface ITouchFrame {\n  /** This is the location or delta location of the touch for this frame */\n  location: Vec2;\n  /** This is the direction from the start touch frame */\n  direction: Vec2;\n  /** This is the metrics or delta metrics of the touch relative to the other touches for the frame */\n  relations: Map<number, ITouchRelation>;\n}\n\nexport interface IInteractionMetrics {\n  /** The current position of the touch on the screen */\n  currentPosition: Vec2;\n  /** The change in position the touch has experienced from last event to this event */\n  deltaPosition: Vec2;\n  /** The location of the touch from it's previous event */\n  previousPosition: Vec2;\n  /** The time stamp this touch began */\n  startTime: number;\n  /** The position this touch started */\n  start: Vec2;\n  /** The beginning view of the touch */\n  startView: View<IViewProps> | undefined;\n}\n\n/**\n * Metrics calculated and stored for the mouse\n */\nexport interface IMouseMetrics extends IInteractionMetrics {\n  /** The mouse button pressed */\n  button: MouseButton;\n  /** Flag for storing whether a mouse event is still eligible to register a click event */\n  canClick: boolean;\n  /** The latest event object associated with this mouse event */\n  event: MouseEvent;\n  /** Information derived for the wheel */\n  wheel: IWheelMetrics;\n}\n\n/**\n * Metrics calculated and stored per touch\n */\nexport interface ITouchMetrics extends IInteractionMetrics {\n  /** Flag storing whether a touch is still eligible to register a tap event */\n  canTap: boolean;\n  /**\n   * The start position of the touch relative to other touches. When a new touch is down, all of the other touches\n   * register their current position as a new starting position relative to when that touch was down.\n   */\n  startRelative: Map<ITouchMetrics, Vec2>;\n  /** The base touch object making this metric */\n  touch: Touch;\n}\n\n/**\n * Metrics calculated for multitouch information\n */\nexport interface IMultiTouchMetrics {\n  /**\n   * The average distance increase/decrease all touches are from the center present from spreading or pinching gesture\n   * from previous event to this event.\n   */\n  averageSpreadDelta: number;\n  /**\n   * The change in the central point as all fingers migrate from one location to another from previous event to\n   * this event.\n   */\n  centerDelta: Vec2;\n  /** The central point between all current touches for the current event */\n  currentCenter: Vec2;\n  /** Stores the current rotation the touches have on average exhibited around the central point */\n  currentRotation: number;\n  /**\n   * The change in rotation of the touches around the central point as the touches move from previous event to\n   * this event.\n   */\n  rotationDelta: number;\n  /** The central point between all current touches when all of the touches began */\n  startCenter: Vec2;\n  /** All of the touch metrics that makes this multitouch information */\n  touches: ITouchMetrics[];\n}\n\n/**\n * Metrics calculated for all touches to be broadcasted to the event managers\n */\nexport interface ITouchInteraction {\n  /** Contains ALL of the touch interactions with the screen that currently exists */\n  allTouches: ISingleTouchInteraction[];\n  /**\n   * Stores multitouch interaction information. All multitouch information is query based\n   */\n  multitouch: IMultiTouchInteraction;\n  /** Contains all of the touch interactions with the screen for the given event */\n  touches: ISingleTouchInteraction[];\n}\n\n/**\n * Metrics calculated for a single touch on the screen\n */\nexport interface ISingleTouchInteraction extends IEventInteraction {\n  /** The source touch metrics for the touch */\n  touch: ITouchMetrics;\n}\n\n/**\n * This is multitouch information. This stores multitouch metrics between every touch and every permutation of every\n * touch. This means if you have four touches on the screen, you can query multitouch information between any of the\n * touches.\n */\nexport interface IMultiTouchInteraction {\n  /**\n   * Produces an identifier for the set of touches that will always be the same identifier for the same touches.\n   */\n  id(touches: ISingleTouchInteraction[]): string;\n  /**\n   * The average distance all touches are from the center for the current event.\n   */\n  spread(touches: ISingleTouchInteraction[]): number;\n  /**\n   * The average distance increase/decrease all touches are from the center present from spreading or pinching gesture.\n   */\n  spreadDelta(touches: ISingleTouchInteraction[]): number;\n  /**\n   * The average distance all touches are from the center when the touches first became present on the context.\n   */\n  spreadStart(touches: ISingleTouchInteraction[]): number;\n  /** This is the calculated center of all the touches queried */\n  center(touches: ISingleTouchInteraction[]): Vec2;\n  /** This is the position change of the center of the touches */\n  centerDelta(touches: ISingleTouchInteraction[]): Vec2;\n  /** Gets the starting center point of the touches */\n  centerStart(touches: ISingleTouchInteraction[]): Vec2;\n  /** Gets the current rotation orientation of the touches around their center point */\n  rotation(touches: ISingleTouchInteraction[]): number;\n  /** This is the change in rotation of the touches around their perceived center. */\n  rotationDelta(touches: ISingleTouchInteraction[]): number;\n  /** Gets the starting touch rotation orientation */\n  rotationStart(touches: ISingleTouchInteraction[]): number;\n}\n","/**\n * Defines an attribute applied to a geometry object. This keeps track of a buffer associated\n * with the attribute to bind to attributes within the shader program.\n */\nexport class Attribute {\n  /**\n   * The data buffer that is applied to the GPU. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData\n   */\n  data: Float32Array;\n  /**\n   * Anything specific to gl state is stored here for this object.\n   * Modifying anything in here outside of the framework probably will\n   * break everything.\n   */\n  gl?: {\n    /** Stores the buffer id for the attribute */\n    bufferId: WebGLBuffer;\n    /** Stores the buffer type (typically gl.ARRAY_BUFFER) */\n    type: number;\n    /** Stores the locations of each attribute discovered for each program identified */\n    locations?: Map<WebGLProgram, number>;\n  };\n  /**\n   * The optimization state for frequently changing buffers. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData\n   */\n  get isDynamic() {\n    return this._isDynamic;\n  }\n  private _isDynamic: boolean;\n  /**\n   * Indicates the data in this attribute is structured per instance rather than per vertex.\n   */\n  get isInstanced() {\n    return this._isInstanced;\n  }\n  private _isInstanced: boolean = false;\n  /** Indicates a full update of the buffer will happen. This is managed internally to determine when needed */\n  get fullUpdate() {\n    return this._fullUpdate;\n  }\n  private _fullUpdate: boolean = false;\n  /** Indicates if the data should be normalized when provided to the shader. */\n  normalize: boolean = false;\n  /** This flags the attribute as needing to commit updates to it's buffer */\n  get needsUpdate() {\n    return this._needsUpdate;\n  }\n  private _needsUpdate: boolean;\n  /**\n   * The packing size of the vertex attribute (how many floats per attribute). See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enableVertexAttribArray\n   */\n  size: number;\n  /**\n   * Defines a range to update for the buffer object. Getting the range object is a copy of the object.\n   * Setting the updateRange triggers an update.\n   *\n   * Although these properties represent vertex indicies it directly ties to all implications of:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferSubData\n   */\n  get updateRange() {\n    return this._updateRange;\n  }\n  set updateRange(val: Attribute[\"_updateRange\"]) {\n    this._updateRange = val;\n    this._needsUpdate = true;\n  }\n  private _updateRange = {\n    /** Number of vertices to update */\n    count: -1,\n    /** Offset to the first vertex to begin updating */\n    offset: -1\n  };\n\n  /**\n   * The data provided is the array that holds all of the information that should be pushed to\n   * the GPU. The size defines how large the vertex attribute is defined in the shader.\n   */\n  constructor(\n    data: Float32Array,\n    size: number,\n    isDynamic: boolean = false,\n    isInstanced: boolean = false\n  ) {\n    this.data = data;\n    this.size = size;\n    this._isDynamic = isDynamic;\n    this._isInstanced = isInstanced;\n  }\n\n  /**\n   * Flags this attribute as completely resolved in it's needs for updates\n   */\n  resolve() {\n    this._needsUpdate = false;\n    this._fullUpdate = false;\n  }\n\n  /**\n   * Flags the buffer as dynamic. This is a performance optimization that some GPUs can use for\n   * buffers that change their contents frequently. Toggling this\n   */\n  setDynamic(isDynmaic: boolean) {\n    this._isDynamic = isDynmaic;\n    this._needsUpdate = true;\n    this._fullUpdate = true;\n  }\n}\n","import { Attribute } from \"./attribute\";\n\n/**\n * This represents a buffer of data that is expressed as attributes to be placed\n * within a scene. This is generally paired with a Material in a Model to indicate\n * the configuration for how the buffer should be rendered.\n */\nexport class Geometry {\n  /** The attributes bound to this geometry.  */\n  private _attributes: { [key: string]: Attribute } = {};\n  get attributes() {\n    return new Map(Object.entries(this._attributes));\n  }\n  /** This contains any gl specific state associated with this object */\n  gl = {};\n  /** Number of instances this geometry covers */\n  maxInstancedCount: number = 0;\n  /** If all attributes added are instanced or not instanced, then this geometry is not instanced */\n  isInstanced: boolean = false;\n\n  /**\n   * Adds an attribute to this geometry. This will associate the attribute's buffer to an attribute\n   * with the same name used within the shader program.\n   */\n  addAttribute(name: string, attribute: Attribute) {\n    this._attributes[name] = attribute;\n    this.isInstanced = false;\n    let didChange: number | undefined;\n\n    // Check to see if the attributes are uniform or not in instancing\n    Object.values(this._attributes).forEach(attr => {\n      const check = attr.isInstanced ? 1 : 0;\n      // Initialize the check value if it has not been yet\n      if (didChange === undefined) didChange = check;\n      // If a change occurs then we have dynamic and instanced attributes, which means this geometry is instanced drawing\n      if ((didChange ^ check) === 1) this.isInstanced = true;\n    });\n  }\n\n  /**\n   * Removes any attributes associated with the specified identifying name.\n   */\n  removeAttribute(name: string) {\n    delete this._attributes[name];\n  }\n\n  dispose() {\n    // TODO\n  }\n}\n","import {\n  add3,\n  copy3,\n  normalize3,\n  scale3,\n  subtract3,\n  Vec3\n} from \"../math/vector\";\n\n/**\n * Represents a ray starting from some origin eminating in a direction.\n * [Origin, Direction]. The direction is a unit vector so:\n *\n * add3(Origin, scale3(Direction, Distance)) is how you would use the ray to find a location in a given direction.\n */\nexport type Ray = [Vec3, Vec3];\n\n/**\n * Provides a location based on a ray and a given distance away\n */\nexport function rayToLocation(ray: Ray, distance: number, out?: Vec3): Vec3 {\n  out = out || [0, 0, 0];\n\n  return add3(ray[0], scale3(ray[1], distance), out);\n}\n\n/**\n * Generates a ray from two points. Ray starts at 'origin' and points toward 'destination'\n */\nexport function rayFromPoints(origin: Vec3, destination: Vec3, out?: Ray): Ray {\n  out = out || [\n    [0, 0, 0],\n    [0, 0, 0]\n  ];\n  copy3(origin, out[0]);\n  normalize3(subtract3(destination, origin), out[1]);\n\n  return out;\n}\n","function isFunction(val: any): val is Function {\n  return val && val.constructor === Function;\n}\n\n/**\n * Method for handling retrieving a map value. This will inject a provided default value if the key does not return\n * a valid value. This will not work as expected if 'undefined' is a valid expected value.\n */\nexport function mapInjectDefault<T, U>(\n  map: Map<T, U>,\n  key: T,\n  defaultValue: U | (() => U)\n): U {\n  let value = map.get(key);\n\n  if (value === undefined) {\n    if (isFunction(defaultValue)) {\n      value = defaultValue();\n    } else {\n      value = defaultValue;\n    }\n\n    map.set(key, value);\n  }\n\n  return value;\n}\n\n/**\n * Method for handling retrieving a map value. This will provide a provided default value with no mutation to the map.\n * This will not work as expected if 'undefined' is a valid expected value.\n */\nexport function mapGetWithDefault<T, U>(\n  map: Map<T, U>,\n  key: T,\n  defaultValue: U | (() => U)\n): U {\n  let value = map.get(key);\n\n  if (value === undefined) {\n    if (isFunction(defaultValue)) {\n      value = defaultValue();\n    } else {\n      value = defaultValue;\n    }\n  }\n\n  return value;\n}\n","import { Instance } from \"../instance-provider\";\nimport { IEasingControl, NOOP } from \"../types\";\nimport { onFrame } from \"./frame\";\n\n/** Handler type for discovered easing controls using the all() method */\nexport type EasingUtilAllHandler<T extends Instance> = (\n  easing: IEasingControl,\n  instance: T,\n  instanceIndex: number,\n  attrIndex: number\n) => void;\n\n/**\n * This contains helper methods to make setting easing values easier to instances that are a part of animated layers\n */\nexport class EasingUtil {\n  /**\n   * This retrieves all easing metrics for every instance for every specified eased attribute.\n   */\n  static async modify<T extends Instance>(\n    instances: T[],\n    layerAttributes: string[],\n    adjust: EasingUtilAllHandler<T>\n  ) {\n    for (let i = 0, iMax = layerAttributes.length; i < iMax; ++i) {\n      const attr = layerAttributes[i];\n\n      for (let k = 0, kMax = instances.length; k < kMax; ++k) {\n        const instance = instances[k];\n        const easing = instance.getEasing(attr);\n\n        if (easing) {\n          adjust(easing, instance, k, i);\n        }\n      }\n    }\n  }\n\n  /**\n   * This finds all easing controls requested for all instances.\n   *\n   * If wait is true, then this method's returned promise will resolve AFTER the time\n   * of all discovered easing objects has passed.\n   */\n  static async all<T extends Instance>(\n    wait: boolean,\n    instances: T[],\n    layerAttributes: string[],\n    adjust?: EasingUtilAllHandler<T>\n  ) {\n    let resolver: Function = NOOP;\n    const promise = new Promise(resolve => (resolver = resolve));\n    let finishedTime = 0;\n\n    for (let i = 0, iMax = layerAttributes.length; i < iMax; ++i) {\n      const attr = layerAttributes[i];\n\n      for (let k = 0, kMax = instances.length; k < kMax; ++k) {\n        const instance = instances[k];\n        const easing = instance.getEasing(attr);\n\n        if (easing) {\n          if (adjust) adjust(easing, instance, k, i);\n          finishedTime = Math.max(\n            (easing.delay || 0) + easing.duration,\n            finishedTime\n          );\n        }\n      }\n    }\n\n    // Keep looking at next frame until the animations are complete\n    const checkNextFrame = (t: number) => {\n      if (t < finishedTime) {\n        onFrame(checkNextFrame);\n      } else resolver();\n    };\n\n    if (wait) {\n      onFrame(t => {\n        finishedTime += t;\n        checkNextFrame(t);\n      });\n    } else {\n      resolver();\n    }\n\n    return promise;\n  }\n}\n","import { Instance } from \"../instance-provider/instance\";\nimport { IShaderInitialization, IShaderIOExtension } from \"../types\";\nimport { shaderTemplate } from \"./shader-templating\";\n\nexport function extendShader<T extends Instance>(\n  shaderIO: IShaderInitialization<T>,\n  extend: IShaderIOExtension<T>\n): IShaderInitialization<T> {\n  const extendedShaders = {\n    vs: shaderIO.vs,\n    fs: shaderIO.fs\n  };\n\n  if (extend.vs) {\n    extendedShaders.vs = shaderTemplate({\n      options: {},\n      required: {\n        name: \"Shader Extension\",\n        values: []\n      },\n      shader: shaderIO.vs,\n\n      // We do not want to remove any template macros that do not deal with extension\n      onToken: token => `$\\{${token}}`,\n\n      onMain(body: string | null) {\n        if (body === null) {\n          console.warn(\n            \"Could not extend the shader as the void main method could not be determined\"\n          );\n          return \"\";\n        }\n\n        if (!extend.vs) return body;\n\n        return {\n          header: extend.vs.header || \"\",\n          main: extend.vs.main\n            ? `${extend.vs.main.pre || \"\"}\\n${body}\\n${extend.vs.main.post ||\n                \"\"}`\n            : body\n        };\n      }\n    }).shader;\n  }\n\n  if (extend.fs) {\n    extendedShaders.fs = shaderTemplate({\n      options: {},\n      required: {\n        name: \"Shader Extension\",\n        values: []\n      },\n      shader: shaderIO.fs,\n\n      // We do not want to remove any template macros that do not deal with extension\n      onToken: token => `$\\{${token}}`,\n\n      onMain(body: string | null) {\n        if (body === null) {\n          console.warn(\n            \"Could not extend the shader as the void main method could not be determined\"\n          );\n          return \"\";\n        }\n\n        if (!extend.fs) return body;\n\n        return {\n          header: extend.fs.header || \"\",\n          main: extend.fs.main\n            ? `${extend.fs.main.pre || \"\"}\\n${body}\\n${extend.fs.main.post ||\n                \"\"}`\n            : body\n        };\n      }\n    }).shader;\n  }\n\n  return {\n    fs: extendedShaders.fs,\n    instanceAttributes: (shaderIO.instanceAttributes || []).concat(\n      extend.instanceAttributes || []\n    ),\n    uniforms: (shaderIO.uniforms || []).concat(extend.uniforms || []),\n    vertexAttributes: (shaderIO.vertexAttributes || []).concat(\n      extend.vertexAttributes || []\n    ),\n    vertexCount: shaderIO.vertexCount,\n    vs: extendedShaders.vs\n  };\n}\n","import { normalizeWheel } from \"./normalizeWheel\";\n\nexport { normalizeWheel };\n","/**\n  BSD License\n\n  Copyright (c) 2015, Facebook, Inc. All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without modification,\n  are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n  * Neither the name Facebook nor the names of its contributors may be used to\n    endorse or promote products derived from this software without specific\n    prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\"use strict\";\n\nconst UserAgent_DEPRECATED = require(\"./UserAgent_DEPRECATED\");\n\nconst isEventSupported = require(\"./isEventSupported\");\n\n// Reasonable defaults\nconst PIXEL_STEP = 10;\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\n\n/**\n * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is\n * complicated, thus this doc is long and (hopefully) detailed enough to answer\n * your questions.\n *\n * If you need to react to the mouse wheel in a predictable way, this code is\n * like your bestest friend. * hugs *\n *\n * As of today, there are 4 DOM event types you can listen to:\n *\n *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)\n *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari\n *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!\n *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003\n *\n * So what to do?  The is the best:\n *\n *   normalizeWheel.getEventType();\n *\n * In your event callback, use this code to get sane interpretation of the\n * deltas.  This code will return an object with properties:\n *\n *   spinX   -- normalized spin speed (use for zoom) - x plane\n *   spinY   -- \" - y plane\n *   pixelX  -- normalized distance (to pixels) - x plane\n *   pixelY  -- \" - y plane\n *\n * Wheel values are provided by the browser assuming you are using the wheel to\n * scroll a web page by a number of lines or pixels (or pages).  Values can vary\n * significantly on different platforms and browsers, forgetting that you can\n * scroll at different speeds.  Some devices (like trackpads) emit more events\n * at smaller increments with fine granularity, and some emit massive jumps with\n * linear speed or acceleration.\n *\n * This code does its best to normalize the deltas for you:\n *\n *   - spin is trying to normalize how far the wheel was spun (or trackpad\n *     dragged).  This is super useful for zoom support where you want to\n *     throw away the chunky scroll steps on the PC and make those equal to\n *     the slow and smooth tiny steps on the Mac. Key data: This code tries to\n *     resolve a single slow step on a wheel to 1.\n *\n *   - pixel is normalizing the desired scroll delta in pixel units.  You'll\n *     get the crazy differences between browsers, but at least it'll be in\n *     pixels!\n *\n *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This\n *     should translate to positive value zooming IN, negative zooming OUT.\n *     This matches the newer 'wheel' event.\n *\n * Why are there spinX, spinY (or pixels)?\n *\n *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn\n *     with a mouse.  It results in side-scrolling in the browser by default.\n *\n *   - spinY is what you expect -- it's the classic axis of a mouse wheel.\n *\n *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and\n *     probably is by browsers in conjunction with fancy 3D controllers .. but\n *     you know.\n *\n * Implementation info:\n *\n * Examples of 'wheel' event if you scroll slowly (down) by one step with an\n * average mouse:\n *\n *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)\n *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)\n *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)\n *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)\n *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)\n *\n * On the trackpad:\n *\n *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)\n *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)\n *\n * On other/older browsers.. it's more complicated as there can be multiple and\n * also missing delta values.\n *\n * The 'wheel' event is more standard:\n *\n * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents\n *\n * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and\n * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain\n * backward compatibility with older events.  Those other values help us\n * better normalize spin speed.  Example of what the browsers provide:\n *\n *                          | event.wheelDelta | event.detail\n *        ------------------+------------------+--------------\n *          Safari v5/OS X  |       -120       |       0\n *          Safari v5/Win7  |       -120       |       0\n *         Chrome v17/OS X  |       -120       |       0\n *         Chrome v17/Win7  |       -120       |       0\n *                IE9/Win7  |       -120       |   undefined\n *         Firefox v4/OS X  |     undefined    |       1\n *         Firefox v4/Win7  |     undefined    |       3\n *\n */\nexport function normalizeWheel(/*object*/ event: any) /*object*/ {\n  let sX = 0,\n    sY = 0, // spinX, spinY\n    pX = 0,\n    pY = 0; // pixelX, pixelY\n\n  // Legacy\n  if (\"detail\" in event) {\n    sY = event.detail;\n  }\n  if (\"wheelDelta\" in event) {\n    sY = -event.wheelDelta / 120;\n  }\n  if (\"wheelDeltaY\" in event) {\n    sY = -event.wheelDeltaY / 120;\n  }\n  if (\"wheelDeltaX\" in event) {\n    sX = -event.wheelDeltaX / 120;\n  }\n\n  // side scrolling on FF with DOMMouseScroll\n  if (\"axis\" in event && event.axis === event.HORIZONTAL_AXIS) {\n    sX = sY;\n    sY = 0;\n  }\n\n  pX = sX * PIXEL_STEP;\n  pY = sY * PIXEL_STEP;\n\n  if (\"deltaY\" in event) {\n    pY = event.deltaY;\n  }\n  if (\"deltaX\" in event) {\n    pX = event.deltaX;\n  }\n\n  if ((pX || pY) && event.deltaMode) {\n    if (event.deltaMode === 1) {\n      // delta in LINE units\n      pX *= LINE_HEIGHT;\n      pY *= LINE_HEIGHT;\n    } else {\n      // delta in PAGE units\n      pX *= PAGE_HEIGHT;\n      pY *= PAGE_HEIGHT;\n    }\n  }\n\n  // Fall-back if spin cannot be determined\n  if (pX && !sX) {\n    sX = pX < 1 ? -1 : 1;\n  }\n  if (pY && !sY) {\n    sY = pY < 1 ? -1 : 1;\n  }\n\n  return {\n    spinX: sX,\n    spinY: -sY,\n    pixelX: pX,\n    pixelY: -pY\n  };\n}\n\n/**\n * The best combination if you prefer spinX + spinY normalization.  It favors\n * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with\n * 'wheel' event, making spin speed determination impossible.\n */\nnormalizeWheel.getEventType = function() /*string*/ {\n  return UserAgent_DEPRECATED.firefox()\n    ? \"DOMMouseScroll\"\n    : isEventSupported(\"wheel\")\n    ? \"wheel\"\n    : \"mousewheel\";\n};\n","/**\n  BSD License\n\n  Copyright (c) 2015, Facebook, Inc. All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without modification,\n  are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n  * Neither the name Facebook nor the names of its contributors may be used to\n    endorse or promote products derived from this software without specific\n    prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n *  Provides entirely client-side User Agent and OS detection. You should prefer\n *  the non-deprecated UserAgent module when possible, which exposes our\n *  authoritative server-side PHP-based detection to the client.\n *\n *  Usage is straightforward:\n *\n *    if (UserAgent_DEPRECATED.ie()) {\n *      //  IE\n *    }\n *\n *  You can also do version checks:\n *\n *    if (UserAgent_DEPRECATED.ie() >= 7) {\n *      //  IE7 or better\n *    }\n *\n *  The browser functions will return NaN if the browser does not match, so\n *  you can also do version compares the other way:\n *\n *    if (UserAgent_DEPRECATED.ie() < 7) {\n *      //  IE6 or worse\n *    }\n *\n *  Note that the version is a float and may include a minor version number,\n *  so you should always use range operators to perform comparisons, not\n *  strict equality.\n *\n *  **Note:** You should **strongly** prefer capability detection to browser\n *  version detection where it's reasonable:\n *\n *    http://www.quirksmode.org/js/support.html\n *\n *  Further, we have a large number of mature wrapper functions and classes\n *  which abstract away many browser irregularities. Check the documentation,\n *  grep for things, or ask on javascript@lists.facebook.com before writing yet\n *  another copy of \"event || window.event\".\n *\n */\n\nvar _populated = false;\n\n// Browsers\nvar _ie, _firefox, _opera, _webkit, _chrome;\n\n// Actual IE browser for compatibility mode\nvar _ie_real_version;\n\n// Platforms\nvar _osx, _windows, _linux, _android;\n\n// Architectures\nvar _win64;\n\n// Devices\nvar _iphone, _ipad, _native;\n\nvar _mobile;\n\nfunction _populate() {\n  if (_populated) {\n    return;\n  }\n\n  _populated = true;\n\n  // To work around buggy JS libraries that can't handle multi-digit\n  // version numbers, Opera 10's user agent string claims it's Opera\n  // 9, then later includes a Version/X.Y field:\n  //\n  // Opera/9.80 (foo) Presto/2.2.15 Version/10.10\n  var uas = navigator.userAgent;\n  var agent = /(?:MSIE.(\\d+\\.\\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\\d+\\.\\d+))|(?:Opera(?:.+Version.|.)(\\d+\\.\\d+))|(?:AppleWebKit.(\\d+(?:\\.\\d+)?))|(?:Trident\\/\\d+\\.\\d+.*rv:(\\d+\\.\\d+))/.exec(\n    uas\n  );\n  var os = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);\n\n  _iphone = /\\b(iPhone|iP[ao]d)/.exec(uas);\n  _ipad = /\\b(iP[ao]d)/.exec(uas);\n  _android = /Android/i.exec(uas);\n  _native = /FBAN\\/\\w+;/i.exec(uas);\n  _mobile = /Mobile/i.exec(uas);\n\n  // Note that the IE team blog would have you believe you should be checking\n  // for 'Win64; x64'.  But MSDN then reveals that you can actually be coming\n  // from either x64 or ia64;  so ultimately, you should just check for Win64\n  // as in indicator of whether you're in 64-bit IE.  32-bit IE on 64-bit\n  // Windows will send 'WOW64' instead.\n  _win64 = !!/Win64/.exec(uas);\n\n  if (agent) {\n    _ie = agent[1]\n      ? parseFloat(agent[1])\n      : agent[5]\n        ? parseFloat(agent[5])\n        : NaN;\n    // IE compatibility mode\n    if (_ie && document && document.documentMode) {\n      _ie = document.documentMode;\n    }\n    // grab the \"true\" ie version from the trident token if available\n    var trident = /(?:Trident\\/(\\d+.\\d+))/.exec(uas);\n    _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;\n\n    _firefox = agent[2] ? parseFloat(agent[2]) : NaN;\n    _opera = agent[3] ? parseFloat(agent[3]) : NaN;\n    _webkit = agent[4] ? parseFloat(agent[4]) : NaN;\n    if (_webkit) {\n      // We do not add the regexp to the above test, because it will always\n      // match 'safari' only since 'AppleWebKit' appears before 'Chrome' in\n      // the userAgent string.\n      agent = /(?:Chrome\\/(\\d+\\.\\d+))/.exec(uas);\n      _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;\n    } else {\n      _chrome = NaN;\n    }\n  } else {\n    _ie = _firefox = _opera = _chrome = _webkit = NaN;\n  }\n\n  if (os) {\n    if (os[1]) {\n      // Detect OS X version.  If no version number matches, set _osx to true.\n      // Version examples:  10, 10_6_1, 10.7\n      // Parses version number as a float, taking only first two sets of\n      // digits.  If only one set of digits is found, returns just the major\n      // version number.\n      var ver = /(?:Mac OS X (\\d+(?:[._]\\d+)?))/.exec(uas);\n\n      _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;\n    } else {\n      _osx = false;\n    }\n    _windows = !!os[2];\n    _linux = !!os[3];\n  } else {\n    _osx = _windows = _linux = false;\n  }\n}\n\nvar UserAgent_DEPRECATED = {\n  /**\n   *  Check if the UA is Internet Explorer.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  ie: function() {\n    return _populate() || _ie;\n  },\n\n  /**\n   * Check if we're in Internet Explorer compatibility mode.\n   *\n   * @return bool true if in compatibility mode, false if\n   * not compatibility mode or not ie\n   */\n  ieCompatibilityMode: function() {\n    return _populate() || _ie_real_version > _ie;\n  },\n\n  /**\n   * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we\n   * only need this because Skype can't handle 64-bit IE yet.  We need to remove\n   * this when we don't need it -- tracked by #601957.\n   */\n  ie64: function() {\n    return UserAgent_DEPRECATED.ie() && _win64;\n  },\n\n  /**\n   *  Check if the UA is Firefox.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  firefox: function() {\n    return _populate() || _firefox;\n  },\n\n  /**\n   *  Check if the UA is Opera.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  opera: function() {\n    return _populate() || _opera;\n  },\n\n  /**\n   *  Check if the UA is WebKit.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  webkit: function() {\n    return _populate() || _webkit;\n  },\n\n  /**\n   *  For Push\n   *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit\n   */\n  safari: function() {\n    return UserAgent_DEPRECATED.webkit();\n  },\n\n  /**\n   *  Check if the UA is a Chrome browser.\n   *\n   *\n   *  @return float|NaN Version number (if match) or NaN.\n   */\n  chrome: function() {\n    return _populate() || _chrome;\n  },\n\n  /**\n   *  Check if the user is running Windows.\n   *\n   *  @return bool `true' if the user's OS is Windows.\n   */\n  windows: function() {\n    return _populate() || _windows;\n  },\n\n  /**\n   *  Check if the user is running Mac OS X.\n   *\n   *  @return float|bool   Returns a float if a version number is detected,\n   *                       otherwise true/false.\n   */\n  osx: function() {\n    return _populate() || _osx;\n  },\n\n  /**\n   * Check if the user is running Linux.\n   *\n   * @return bool `true' if the user's OS is some flavor of Linux.\n   */\n  linux: function() {\n    return _populate() || _linux;\n  },\n\n  /**\n   * Check if the user is running on an iPhone or iPod platform.\n   *\n   * @return bool `true' if the user is running some flavor of the\n   *    iPhone OS.\n   */\n  iphone: function() {\n    return _populate() || _iphone;\n  },\n\n  mobile: function() {\n    return _populate() || (_iphone || _ipad || _android || _mobile);\n  },\n\n  nativeApp: function() {\n    // webviews inside of the native apps\n    return _populate() || _native;\n  },\n\n  android: function() {\n    return _populate() || _android;\n  },\n\n  ipad: function() {\n    return _populate() || _ipad;\n  },\n};\n\nmodule.exports = UserAgent_DEPRECATED;\n","/**\n  BSD License\n\n  Copyright (c) 2015, Facebook, Inc. All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without modification,\n  are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n  * Neither the name Facebook nor the names of its contributors may be used to\n    endorse or promote products derived from this software without specific\n    prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n'use strict';\n\nvar ExecutionEnvironment = require('./ExecutionEnvironment');\n\nvar useHasFeature;\nif (ExecutionEnvironment.canUseDOM) {\n  useHasFeature =\n    document.implementation &&\n    document.implementation.hasFeature &&\n    // always returns true in newer browsers as per the standard.\n    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n    document.implementation.hasFeature('', '') !== true;\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @param {?boolean} capture Check if the capture phase is supported.\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nfunction isEventSupported(eventNameSuffix, capture) {\n  if (\n    !ExecutionEnvironment.canUseDOM ||\n    (capture && !('addEventListener' in document))\n  ) {\n    return false;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = eventName in document;\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\n\nmodule.exports = isEventSupported;\n","/**\n  BSD License\n\n  Copyright (c) 2015, Facebook, Inc. All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without modification,\n  are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n  * Neither the name Facebook nor the names of its contributors may be used to\n    endorse or promote products derived from this software without specific\n    prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n'use strict';\n\nvar canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners:\n    canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM, // For now, this is true - might change in the future.\n};\n\nmodule.exports = ExecutionEnvironment;\n","/**\n * Promise based wait wrapper for setTimeout\n */\nexport function wait(t: number) {\n  return new Promise(resolve => setTimeout(resolve, t));\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","import { Omit, TypeVec } from \"../types\";\nimport { GLProxy } from \"./gl-proxy\";\nimport { GLSettings } from \"./gl-settings\";\nimport { IMaterialUniform, MaterialUniformType } from \"./types\";\n\nexport type MaterialOptions = Omit<\n  Partial<Material>,\n  \"clone\" | \"dispose\" | \"gl\"\n>;\n\n/**\n * This represents a Shader configuration and a state for the configuration to be applied\n * when a model is rendered.\n */\nexport class Material {\n  /** This is the computed blend mode state. Set to null to deactivate */\n  blending: {\n    blendDst: GLSettings.Material.BlendingDstFactor;\n    blendEquation: GLSettings.Material.BlendingEquations;\n    blendSrc: GLSettings.Material.BlendingSrcFactor;\n  } | null = {\n    blendDst: GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha,\n    blendEquation: GLSettings.Material.BlendingEquations.Add,\n    blendSrc: GLSettings.Material.BlendingSrcFactor.SrcAlpha\n  };\n  /**\n   * The write mask to the color buffer. Each channel can be toggled on or off as the color buffer is written to. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/colorMask\n   */\n  colorWrite: TypeVec<boolean> = [true, true, true, true];\n  /** Sets the cull mode of GL for the polygons */\n  culling: GLSettings.Material.CullSide = GLSettings.Material.CullSide.CCW;\n  /** The comparator used to classify when a fragment will be rendered vs discarded when tested against the depth buffer */\n  depthFunc: GLSettings.Material.DepthFunctions =\n    GLSettings.Material.DepthFunctions.LESS_OR_EQUAL;\n  /**\n   * Enable / disable depth test (determines if the fragment depth is compared to the depth buffer before writing). See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enable\n   */\n  depthTest: boolean = true;\n  /**\n   * Enable / disable depth mask (determines if fragments write to the depth buffer). See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/depthMask\n   */\n  depthWrite: boolean = true;\n  /**\n   * Sets whether or not GL should use it's dithering routine. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enable\n   */\n  dithering: boolean = true;\n  /** The fragment shader in raw text format that will be compiled to run as the program to use when this material is used */\n  fragmentShader: string = \"\";\n  /**\n   * Stores any gl state associated with this object. Modifying this outside the framework\n   * is almost guaranteed to break something.\n   */\n  gl?: {\n    fsId: WebGLShader;\n    vsId: WebGLShader;\n    programId: WebGLProgram;\n    proxy: GLProxy;\n  };\n  /** A name for the  */\n  name: string = \"\";\n  /**\n   * TODO: This is NOT IN USE YET\n   * GL Polygon offset settings. When set, enables polygon offset modes within the gl state. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/enable\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/polygonOffset\n   */\n  polygonOffset?: {\n    polygonOffsetFactor?: number;\n    polygonOffsetUnits?: number;\n  };\n\n  /** Uniforms that will be synced with the GPU when this material is used */\n  uniforms: { [key: string]: IMaterialUniform<MaterialUniformType> } = {};\n  /** The vertex shader that will be compiled to run as the program to use when this material is used */\n  vertexShader: string = \"\";\n\n  constructor(options: MaterialOptions) {\n    // Take in the properties\n    Object.assign(this, options);\n    // Ensure the gl property did not get copied in if using the copy constructor new Material(Material)\n    delete this.gl;\n  }\n\n  /**\n   * Makes a duplicate material with identical settings as this material. It provides the\n   * benefit of being able to adjust uniform values for the new material while sharing the same\n   * programs and shaders.\n   */\n  clone() {\n    // Make a new copy material container and copy over the properties (shallow copy)\n    const copy = new Material(this);\n    // Now we deeper copy any sub objects\n    copy.blending = Object.assign({}, this.blending);\n    copy.polygonOffset = Object.assign({}, this.polygonOffset);\n    // And last we need a deep copy of uniforms, such that we get new uniform objects\n    copy.uniforms = Object.assign({}, this.uniforms);\n\n    // Deeper copy objects\n    // We DO NOT copy the data object as it is expected to be able to share data buffers\n    // between uniforms.\n    for (const name in copy.uniforms) {\n      const uniform: IMaterialUniform<MaterialUniformType> =\n        copy.uniforms[name];\n\n      // Make sure the gl references are the same but their own object\n      if (uniform.gl) {\n        const newLocations = new Map();\n        uniform.gl.forEach((location, program) => {\n          newLocations.set(program, Object.assign({}, location));\n        });\n      }\n    }\n\n    return copy;\n  }\n\n  /**\n   * This frees up all GL resources utilized by this material.\n   */\n  dispose() {\n    if (this.gl) {\n      this.gl.proxy.disposeMaterial(this);\n    }\n  }\n}\n","import { Vec2 } from \"../math\";\nimport { Geometry } from \"./geometry\";\nimport { GLSettings } from \"./gl-settings\";\nimport { Material } from \"./material\";\n\n/**\n * This represents a Geometry with a Material as a paired configuration to be rendered\n * within a scene.\n */\nexport class Model {\n  /** Specifies how the system will utilize the geometry applied */\n  drawMode: GLSettings.Model.DrawMode = GLSettings.Model.DrawMode.TRIANGLES;\n  /** Specifies the vertices to render within the Model */\n  vertexDrawRange?: Vec2 = [-1, -1];\n  /** This specifies how many instances to draw of this model */\n  drawInstances: number = -1;\n  /** The vertex information of the Model */\n  geometry: Geometry;\n  /** The material associated with the model */\n  material: Material;\n  /** Specifies the number of vertices available to the underlying geometry */\n  vertexCount: number = 0;\n\n  constructor(geometry: Geometry, material: Material) {\n    this.geometry = geometry;\n    this.material = material;\n  }\n}\n","// Shader mdoules have no exports and should simply be imported to execute their registration\nimport \"./world-2d.shader\";\n","import { ShaderModule } from \"../../shaders/processing\";\nimport { Layer } from \"../../surface\";\nimport { ShaderInjectionTarget, UniformSize } from \"../../types\";\nimport { Camera2D } from \"../view/camera-2d\";\nimport { Layer2D } from \"../view/layer-2d\";\n\n/**\n * This module provides uniforms for retrieving camera propeerties within the shader.\n */\nShaderModule.register([\n  {\n    moduleId: \"world2D\",\n    content: require(\"./shader-fragments/world-2d-projection.vs\"),\n    compatibility: ShaderInjectionTarget.ALL,\n    uniforms: (layer: Layer<any, any>) => {\n      if (!(layer instanceof Layer2D)) {\n        console.warn(\n          \"A shader requested the module world2D; however, the layer the shader comes from is NOT a Layer2D which is\",\n          \"required for the module to work.\"\n        );\n        return [];\n      }\n\n      return [\n        // This injects the projection matrix from the view camera\n        {\n          name: \"projection\",\n          size: UniformSize.MATRIX4,\n          update: () => layer.view.props.camera.projection\n        },\n        // This injects the model view matrix from the view camera\n        {\n          name: \"view\",\n          size: UniformSize.MATRIX4,\n          update: () => layer.view.props.camera.view\n        },\n        // This injects a 2D camera's offset\n        {\n          name: \"cameraOffset\",\n          size: UniformSize.THREE,\n          update: () =>\n            layer.view.props.camera instanceof Camera2D\n              ? layer.view.props.camera.control2D.offset\n              : [0, 0, 0]\n        },\n        // This injects the camera's current position\n        {\n          name: \"cameraPosition\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.position\n        },\n        // This injects the camera's current scale\n        {\n          name: \"cameraScale\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.scale\n        },\n        // This injects the camera's 2D current scale\n        {\n          name: \"cameraScale2D\",\n          size: UniformSize.THREE,\n          update: () =>\n            layer.view.props.camera instanceof Camera2D\n              ? layer.view.props.camera.scale2D\n              : [1, 1, 1]\n        },\n        // This injects the camera's Euler rotation\n        {\n          name: \"cameraRotation\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.scale\n        },\n        // This injects the pixel width and height of the view\n        {\n          name: \"viewSize\",\n          size: UniformSize.TWO,\n          update: () => [\n            layer.view.viewBounds.width,\n            layer.view.viewBounds.height\n          ]\n        },\n        // This injects the current layer's pixel ratio so pixel ratio dependent items can react to it\n        // Things like gl_PointSize will need this metric if not working in clip space\n        {\n          name: \"pixelRatio\",\n          size: UniformSize.ONE,\n          update: () => [layer.view.pixelRatio]\n        }\n      ];\n    }\n  }\n]);\n","import { EventManager } from \"../event-management/event-manager\";\nimport { UserInputEventManager } from \"../event-management/user-input-event-manager\";\nimport {\n  GLSettings,\n  isOffscreenCanvas,\n  RenderTarget,\n  Scene,\n  Texture\n} from \"../gl\";\nimport { WebGLRenderer } from \"../gl/webgl-renderer\";\nimport { Instance } from \"../instance-provider/instance\";\nimport { BaseProjection } from \"../math\";\nimport { getAbsolutePositionBounds } from \"../math/primitives/absolute-position\";\nimport { Bounds } from \"../math/primitives/bounds\";\nimport { copy4, Vec2, Vec4 } from \"../math/vector\";\nimport {\n  BaseResourceManager,\n  BaseResourceOptions,\n  BaseResourceRequest,\n  FontResourceManager,\n  ResourceRouter\n} from \"../resources\";\nimport { AtlasResourceManager } from \"../resources/texture/atlas-resource-manager\";\nimport { ActiveIOExpansion } from \"../surface/layer-processing/base-io-expanders/active-io-expansion\";\nimport { FrameMetrics, ResourceType, SurfaceErrorType } from \"../types\";\nimport {\n  IdentifiableById,\n  IInstanceAttribute,\n  IPipeline,\n  IResourceType,\n  PickType\n} from \"../types\";\nimport { onFrame, PromiseResolver } from \"../util\";\nimport { analyzeColorPickingRendering } from \"../util/color-picking-analysis\";\nimport { ReactiveDiff } from \"../util/reactive-diff\";\nimport { BaseIOSorting } from \"./base-io-sorting\";\nimport { LayerMouseEvents } from \"./event-managers/layer-mouse-events\";\nimport { Layer } from \"./layer\";\nimport { BasicIOExpansion } from \"./layer-processing/base-io-expanders/basic-io-expansion\";\nimport { EasingIOExpansion } from \"./layer-processing/base-io-expanders/easing-io-expansion\";\nimport { BaseIOExpansion } from \"./layer-processing/base-io-expansion\";\nimport { ISceneOptions, LayerScene } from \"./layer-scene\";\nimport { ClearFlags, IViewProps, View } from \"./view\";\n\n/**\n * Default IO expansion controllers applied to the system when explicit settings\n * are not provided.\n */\nexport const DEFAULT_IO_EXPANSION: BaseIOExpansion[] = [\n  // Basic expansion to handle writing attributes and uniforms to the shader\n  new BasicIOExpansion(),\n  // Expansion to write in the active attribute handler. Any expansion injected AFTER\n  // this expander will have it's processes canceled out for the destructuring portion\n  // of the expansion when an instance is not active (if the instance has an active\n  // attribute).\n  new ActiveIOExpansion(),\n  // Expansion to handle easing IO attributes and write AutoEasingMethods to the shaders\n  new EasingIOExpansion()\n];\n\n/**\n * Default resource managers the system will utilize to handle default / basic resources.\n */\nexport const DEFAULT_RESOURCE_MANAGEMENT: ISurfaceOptions[\"resourceManagers\"] = [\n  {\n    type: ResourceType.ATLAS,\n    manager: new AtlasResourceManager({})\n  },\n  {\n    type: ResourceType.FONT,\n    manager: new FontResourceManager()\n  }\n];\n\n/**\n * Options for generating a new layer surface.\n */\nexport interface ISurfaceOptions {\n  /**\n   * Provides the context the surface will use while rendering\n   */\n  context?: HTMLCanvasElement;\n  /**\n   * This is the event managers to respond to the mouse events.\n   */\n  eventManagers?: EventManager[];\n  /**\n   * Set to true to allow this surface to absorb and handle wheel events from the mouse.\n   */\n  handlesWheelEvents?: boolean;\n  /**\n   * Provides additional expansion controllers that will contribute to our Shader IO configuration\n   * for the layers. If this is not provided, this defaults to default system behaviors.\n   *\n   * To add additional Expansion controllers and keep default system controllers utilize a Function\n   * instead:\n   *\n   * ioExpansion: (defaultExpanders: BaseIOExpansion) => [...defaultExpanders, <your own expanders>]\n   *\n   * For instance: easing properties on attributes requires the attribute to be expanded to additional\n   * attributes + modified behavior of the base attribute. Thus the system by default adds in the\n   * EasinggIOExpansion controller when this is not provided to make those property types work.\n   */\n  ioExpansion?:\n    | BaseIOExpansion[]\n    | ((defaultExpanders: BaseIOExpansion[]) => BaseIOExpansion[]);\n  /**\n   * This specifies the density of rendering in the surface. The default value is window.devicePixelRatio to match the\n   * monitor for optimal clarity. Using a value of 1 will be acceptable, will not get high density renders, but will\n   * have better performance if needed.\n   */\n  pixelRatio?: number;\n  /** Sets some options for the renderer which deals with top level settings that can only be set when the context is retrieved */\n  rendererOptions?: {\n    /**\n     * This indicates the back buffer for the webgl context will have an alpha channel. This affects performance some, but is mainly\n     * for the DOM compositing the canvas with the other DOM elements.\n     */\n    alpha?: boolean;\n    /** Hardware antialiasing. Disabled by default. Enabled makes things prettier but slower. */\n    antialias?: boolean;\n    /**\n     * This tells the browser what to expect from the colors rendered into the canvas. This will affect how compositing\n     * the canvas with the rest of the DOM will be accomplished. This should match the color values being written to\n     * the final FBO target (render target null). If incorrect, bizarre color blending with the DOM can occur.\n     */\n    premultipliedAlpha?: boolean;\n    /**\n     * This sets what the browser will do with the target frame buffer object after it's done using it for compositing.\n     * If you wish to take a snap shot of the canvas being rendered into, this must be true. This has the potential\n     * to hurt performance, thus it is disabled by default.\n     */\n    preserveDrawingBuffer?: boolean;\n  };\n  /**\n   * This specifies the resource managers that will be applied to the surface. If this is not\n   * provided, this will default to DEFAULT_RESOURCE_MANAGEMENT.\n   *\n   * To add additional managers to the default framework:\n   * [\n   *   ...DEFAULT_RESOURCE_MANAGEMENT,\n   *   <your own resource managers>\n   * ]\n   *\n   * Resource managers handle a layer's requests for a resource (this.resource.request(layer, instance, requestObject))\n   * during update cycles of the attributes.\n   */\n  resourceManagers?: {\n    type: number;\n    manager: BaseResourceManager<IResourceType, BaseResourceRequest>;\n  }[];\n}\n\n/**\n * If a view does not specify a background color, this is the color that will be cleared to\n * when the color buffer is cleared for the view\n */\nconst DEFAULT_BACKGROUND_COLOR: Vec4 = [0.0, 0.0, 0.0, 0.0];\n\n/**\n * Sort method for any object with an 'order' property\n */\nfunction sortByOrder<T extends { order?: number }>(a: T, b: T) {\n  return (\n    (a.order || Number.MAX_SAFE_INTEGER) - (b.order || Number.MAX_SAFE_INTEGER)\n  );\n}\n\n/**\n * This is a render controller for managing GPU rendering techniques via a layering system. This is the entry object\n * that contains and monitors all resources for performing the GPU actions.\n */\nexport class Surface {\n  /** This is the gl context this surface is rendering to */\n  private context: WebGLRenderingContext;\n  /**\n   * This is the metrics of the current running frame\n   */\n  frameMetrics: FrameMetrics = {\n    currentFrame: 0,\n    currentTime: Date.now() | 0,\n    frameDuration: 1000 / 60,\n    previousTime: Date.now() | 0\n  };\n  /** This is used to help resolve concurrent draws and resolving resource request dequeue operations. */\n  private isBufferingResources = false;\n  /** These are the registered expanders of Shader IO configuration */\n  private ioExpanders: BaseIOExpansion[] = [];\n  /**\n   * This is the sorting controller for sorting attributes/uniforms of a layer after all the attributes have been\n   * generated that are needed\n   */\n  ioSorting = new BaseIOSorting();\n  /** This manages the mouse events for the current canvas context */\n  mouseManager: UserInputEventManager;\n  /** This is a target used to perform rendering our picking pass */\n  pickingTarget: RenderTarget;\n  /** This is the density the rendering renders for the surface */\n  pixelRatio: number = window.devicePixelRatio;\n  /** This is the GL render system we use to render scenes with views */\n  renderer: WebGLRenderer;\n  /** This is the resource manager that handles resource requests for instances */\n  resourceManager: ResourceRouter;\n  /** When set to true, the next render will make sure color picking is updated for layer interactions */\n  updateColorPick?: {\n    position: Vec2;\n    views: View<IViewProps>[];\n  };\n  /**\n   * This map is a quick look up for a view to determine other views that\n   * would need to be redrawn as a consequence of the key view needing a redraw.\n   */\n  private viewDrawDependencies = new Map<\n    View<IViewProps>,\n    View<IViewProps>[]\n  >();\n  /**\n   * This is used to indicate the surface has loaded it's initial systems. This is complete after init has executed\n   * successfully for this surface.\n   */\n  ready: Promise<Surface>;\n  /** This is used to reolve this surface as ready */\n  private readyResolver: PromiseResolver<Surface>;\n\n  /**\n   * Picking gets deferred to the beginning of next draw. Thus picking operations get queued till next\n   * frame using this store here.\n   */\n  private queuedPicking?: [\n    LayerScene,\n    View<IViewProps>,\n    Layer<any, any>[],\n    Vec2\n  ][];\n\n  /** Diff manager to handle diffing resource objects for the pipeline */\n  resourceDiffs: ReactiveDiff<\n    IdentifiableById,\n    BaseResourceOptions\n  > = new ReactiveDiff({\n    buildItem: async (initializer: BaseResourceOptions) => {\n      await this.resourceManager.initResource(initializer);\n\n      return {\n        id: initializer.key\n      };\n    },\n\n    destroyItem: async (\n      initializer: BaseResourceOptions,\n      _item: IdentifiableById\n    ) => {\n      await this.resourceManager.destroyResource(initializer);\n\n      return true;\n    },\n\n    updateItem: async (\n      initializer: BaseResourceOptions,\n      _item: IdentifiableById\n    ) => {\n      await this.resourceManager.updateResource(initializer);\n    }\n  });\n\n  /** Diff manager to handle diffing scene objects for the pipeline */\n  sceneDiffs: ReactiveDiff<LayerScene, ISceneOptions> = new ReactiveDiff({\n    buildItem: async (initializer: ISceneOptions) => {\n      const scene = new LayerScene(this, {\n        key: initializer.key,\n        views: initializer.views,\n        layers: initializer.layers\n      });\n\n      return scene;\n    },\n\n    destroyItem: async (_initializer: ISceneOptions, item: LayerScene) => {\n      item.destroy();\n      return true;\n    },\n\n    updateItem: async (initializer: ISceneOptions, item: LayerScene) => {\n      await item.update(initializer);\n    }\n  });\n\n  constructor(options?: ISurfaceOptions) {\n    this.readyResolver = new PromiseResolver();\n    this.ready = this.readyResolver.promise;\n\n    if (options) {\n      this.init(options);\n    }\n  }\n\n  /** Read only getter for the gl context */\n  get gl() {\n    return this.context;\n  }\n\n  /** Get all of the scenes for this surface */\n  get scenes() {\n    return this.sceneDiffs.items;\n  }\n\n  /**\n   * Retrieves all IO Expanders applied to this surface\n   */\n  getIOExpanders() {\n    return this.ioExpanders;\n  }\n\n  /**\n   * Retrieves the controller for sorting the IO for the layers.\n   */\n  getIOSorting() {\n    return this.ioSorting;\n  }\n\n  /**\n   * This processes what is rendered into the picking render target to see if the mouse interacted with\n   * any elements.\n   */\n  private analyzePickRendering() {\n    if (!this.queuedPicking) return;\n\n    for (let i = 0, iMax = this.queuedPicking.length; i < iMax; ++i) {\n      const [, view, pickingPass, mouse] = this.queuedPicking[i];\n\n      // Optimized rendering of the view will make the view discard picking rendering\n      if (view.optimizeRendering) {\n        continue;\n      }\n\n      // Make our metrics for how much of the image we wish to analyze\n      const pickWidth = 5;\n      const pickHeight = 5;\n      const numBytesPerColor = 4;\n      const out = new Uint8Array(pickWidth * pickHeight * numBytesPerColor);\n\n      // Read the pixels out\n      this.renderer.readPixels(\n        Math.floor(mouse[0] - pickWidth / 2),\n        Math.floor(mouse[1] - pickHeight / 2),\n        pickWidth,\n        pickHeight,\n        out\n      );\n\n      // Analyze the rendered color data for the picking routine\n      const pickingData = analyzeColorPickingRendering(\n        [mouse[0] - view.screenBounds.x, mouse[1] - view.screenBounds.y],\n        out,\n        pickWidth,\n        pickHeight\n      );\n\n      // We must redraw the layers so they will update their uniforms to adapt to a picking pass\n      for (let j = 0, endj = pickingPass.length; j < endj; ++j) {\n        const layer = pickingPass[j];\n\n        if (layer.picking.type === PickType.SINGLE) {\n          layer.interactions.colorPicking = pickingData;\n        }\n      }\n    }\n\n    delete this.queuedPicking;\n  }\n\n  /**\n   * The performs all of the needed updates that layers need to commit to the scene and buffers\n   * to be ready for a draw pass. This is callable outside of the draw loop to allow for specialized\n   * procedures or optimizations to take place, where incremental updates to the buffers would make\n   * the most sense.\n   *\n   * @param time The start time of the given frame\n   * @param frameIncrement When true, the frame count for the frame metrics will increment\n   * @param onViewReady Callback for when all of the layers of a scene view have been committed\n   *                    and are thus potentially ready to be rendered.\n   */\n  async commit(\n    time?: number,\n    frameIncrement?: boolean,\n    onViewReady?: (\n      needsDraw: boolean,\n      scene: LayerScene,\n      view: View<IViewProps>,\n      pickingPass: Layer<any, any>[]\n    ) => void\n  ) {\n    if (!this.gl) return;\n\n    // For now, while certain mysteries remain, we will track only if any view needs to be redrawn.\n    // Any view that needs to be redrawn will trigger a redraw of the entire surface for now until\n    // we can optimize down to only drawing a single view without erasing views that were not redrawn.\n    let needsDraw = false;\n\n    // We are rendering a new frame so increment our frame count\n    if (frameIncrement) this.frameMetrics.currentFrame++;\n    this.frameMetrics.frameDuration =\n      this.frameMetrics.currentTime - this.frameMetrics.previousTime;\n    this.frameMetrics.previousTime = this.frameMetrics.currentTime;\n\n    // If no manual time was provided, we shall use Date.now in 32 bit format\n    if (time === undefined) {\n      this.frameMetrics.currentTime = Date.now() | 0;\n    } else {\n      // If this is our first frame and we have a manual time entry, then we first need to sync up\n      // The manual time as our previous timing.\n      if (this.frameMetrics.previousTime === this.frameMetrics.currentTime) {\n        this.frameMetrics.previousTime = time;\n      }\n\n      this.frameMetrics.currentTime = time;\n    }\n\n    // Now that we have established what the time should be, let's swap our input parameter to reflect\n    // the time we will be using for this frame\n    time = this.frameMetrics.currentTime;\n\n    // Get the scenes in their added order\n    const scenes = this.sceneDiffs.items;\n    scenes.sort(sortByOrder);\n    const erroredLayers: { [key: string]: [Layer<any, any>, Error] } = {};\n    const pickingPassByView = new Map<View<IViewProps>, Layer<any, any>[]>();\n\n    // Loop through scenes\n    for (let i = 0, end = scenes.length; i < end; ++i) {\n      const scene = scenes[i];\n      const views = scene.views;\n      const layers = scene.layers;\n      const validLayers: { [key: string]: Layer<any, any> } = {};\n\n      // Make sure the views and layers are ordered such that they render in the appropriate order\n      views.sort(sortByOrder);\n      layers.sort(sortByOrder);\n\n      // Loop through the views\n      for (let k = 0, endk = views.length; k < endk; ++k) {\n        const view = views[k];\n        // When this flags true, a picking pass will be rendered for the provided scene / view\n        const pickingPass: Layer<any, any>[] = [];\n\n        // Get the bounds of the screen to hand to the view\n        const screenBounds = new Bounds<never>({\n          height: this.context.canvas.height,\n          width: this.context.canvas.width,\n          x: 0,\n          y: 0\n        });\n\n        // Calculate the bounds of the viewport relative to the screen\n        const viewportBounds = getAbsolutePositionBounds<View<IViewProps>>(\n          view.props.viewport,\n          screenBounds,\n          this.pixelRatio\n        );\n\n        // We must perform any operations necessary to make the view camera fit the viewport\n        // Correctly\n        view.fitViewtoViewport(screenBounds, viewportBounds);\n\n        // Let the layers update their uniforms before the draw\n        for (let j = 0, endj = layers.length; j < endj; ++j) {\n          // Get the layer to be rendered in the scene\n          const layer = layers[j];\n          // Update the layer with the view it is about to be rendered with\n          layer.view = view;\n\n          // Make sure the layer is given the opportunity to update all of it's uniforms\n          // To match the view state and update any unresolved diffs internally\n          try {\n            // Update uniforms, resolve diff changes\n            layer.draw();\n            // If any of the layers under the view need a redraw\n            // Then the view needs a redraw\n            if (layer.needsViewDrawn || layer.isAnimationContinuous) {\n              view.needsDraw = true;\n            }\n            // Flag the layer as valid\n            validLayers[layer.id] = layer;\n            // The view's animationEndTime is the largest end time found on one of the view's child layers.\n            view.animationEndTime = Math.max(\n              view.animationEndTime,\n              layer.animationEndTime,\n              view.props.camera.animationEndTime\n            );\n            // Indicate this layer is being rendered at the current time frame\n            layer.lastFrameTime = time;\n          } catch (err) {\n            if (!erroredLayers[layer.id]) {\n              erroredLayers[layer.id] = [layer, err];\n            }\n          }\n\n          // If this layer specifies a picking draw pass, then we shall store it in the current draw order\n          // For that next step\n          if (layer.picking.type === PickType.SINGLE) {\n            pickingPass.push(layer);\n          }\n        }\n\n        // Analyze the view's animation end timings and the camera to see if there are view changes\n        // that will trigger a redraw outside of our layer changes\n        if (\n          view.needsDraw ||\n          (time && time < view.lastFrameTime) ||\n          (time && time < view.animationEndTime) ||\n          view.props.camera.needsViewDrawn\n        ) {\n          view.needsDraw = true;\n          needsDraw = true;\n\n          // Get all of the dependent views for that view\n          const overlapViews = this.viewDrawDependencies.get(view);\n\n          // And make all of them need a redraw.\n          if (overlapViews) {\n            overlapViews.forEach(view => {\n              view.needsDraw = true;\n            });\n          }\n        }\n\n        // Store the picking pass for the view to use when the view is ready to draw\n        pickingPassByView.set(view, pickingPass);\n      }\n\n      // Re-render but only include non-errored layers\n      const keepLayers = Object.values(validLayers);\n      if (layers.length !== keepLayers.length) {\n        scene.layerDiffs.diff(keepLayers.map(layer => layer.initializer));\n      }\n    }\n\n    // If any draw need was detected, redraw the surface\n    for (let i = 0, end = scenes.length; i < end; ++i) {\n      const scene = scenes[i];\n      // Our scene must have a valid container to operate\n      if (!scene.container) continue;\n      const views = scene.views;\n\n      for (let k = 0, endk = views.length; k < endk; ++k) {\n        const view = views[k];\n\n        // Now perform the rendering\n        if (onViewReady) {\n          onViewReady(\n            needsDraw,\n            scene,\n            view,\n            pickingPassByView.get(view) || []\n          );\n        }\n      }\n    }\n\n    // Get the layers with errors flagged for them\n    const errors = Object.values(erroredLayers);\n\n    if (errors.length > 0) {\n      console.warn(\n        \"Some layers errored during their draw update. These layers will be removed. They can be re-added if render() is called again:\",\n        errors.map(err => err[0].id)\n      );\n\n      // Output each layer and why it errored\n      errors.forEach(err => {\n        console.warn(`Layer ${err[0].id} removed for the following error:`);\n\n        if (err[1]) {\n          const message = err[1].stack || err[1].message;\n          console.error(message);\n\n          // This is a specific error to instances updating an attribute but returning a value that is larger\n          // than the attribute size. The only way to debug this is to run every instance in the layer and\n          // retrieve it's update value and compare the return to the expected size.\n          if (\n            message.indexOf(\"RangeError\") > -1 ||\n            message.indexOf(\"Source is too large\") > -1\n          ) {\n            const layer = err[0];\n            const changes = layer.bufferManager.changeListContext;\n            let singleMessage:\n              | [string, Instance, IInstanceAttribute<Instance>]\n              | undefined;\n            let errorCount = 0;\n\n            for (let i = 0, iMax = changes.length; i < iMax; ++i) {\n              const [instance] = changes[i];\n              layer.shaderIOInfo.instanceAttributes.forEach(attr => {\n                const check = attr.update(instance);\n                if (check.length !== attr.size) {\n                  if (!singleMessage) {\n                    singleMessage = [\n                      \"Example instance returned the wrong sized value for an attribute:\",\n                      instance,\n                      attr\n                    ];\n                  }\n\n                  errorCount++;\n                }\n              });\n            }\n\n            if (singleMessage) {\n              console.error(\n                \"The following output shows discovered issues related to the specified error\"\n              );\n              console.error(\n                \"Instances are returning too large IO for an attribute\\n\",\n                singleMessage[0],\n                singleMessage[1],\n                singleMessage[2],\n                \"Total errors for too large IO values\",\n                errorCount\n              );\n            }\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Free all resources consumed by this surface that gets applied to the GPU.\n   */\n  destroy() {\n    this.resourceManager.destroy();\n    this.mouseManager.destroy();\n    this.sceneDiffs.destroy();\n    this.renderer.dispose();\n    this.pickingTarget.dispose();\n    delete this.context;\n  }\n\n  /**\n   * This is the draw loop that must be called per frame for updates to take effect and display.\n   *\n   * @param time This is an optional time flag so one can manually control the time flag for the frame.\n   *             This will affect animations and other automated gpu processes.\n   */\n  async draw(time?: number) {\n    if (!this.gl) return;\n\n    // The theoretically least blocking moment for pixels to be read is the beginning of the next frame\n    // right before next frame is rendered. This will have given optimal time for the GPU to have finished\n    // flushing it's commands. If the GPU has not completed it's tasks by this time, then we're in a major\n    // GPU intensive operation.\n    this.analyzePickRendering();\n    // Gather all of our picking calls to call at the end to prevent readPixels from\n    // becoming a major blocking operation\n    const toPick: [LayerScene, View<IViewProps>, Layer<any, any>[]][] = [];\n\n    // Before we draw the frame, we must have every camera resolve broadcasting changes so everything can respond\n    // to the change before all of the drawing operations take place.\n    for (let i = 0, iMax = this.sceneDiffs.items.length; i < iMax; ++i) {\n      const scene = this.sceneDiffs.items[i];\n\n      for (let k = 0, kMax = scene.views.length; k < kMax; ++k) {\n        const view = scene.views[k];\n        view.props.camera.broadcast(view.id);\n      }\n    }\n\n    // Make the layers commit their changes to the buffers then draw each scene view on\n    // Completion.\n    await this.commit(time, true, (needsDraw, scene, view, pickingPass) => {\n      // Our scene must have a valid container to operate\n      if (!scene.container) return;\n\n      if (needsDraw) {\n        // Now perform the rendering\n        this.drawSceneView(scene.container, view);\n      }\n\n      // If a layer needs a picking pass, then perform a picking draw pass only\n      // if a request for the color pick has been made, then we query the pixels rendered to our picking target\n      if (pickingPass.length > 0 && this.updateColorPick) {\n        toPick.push([scene, view, pickingPass]);\n      }\n    });\n\n    // After we have drawn our views of our scenes, we can now ensure all of the bounds\n    // Are updated in the interactions and flag our interactions ready for mouse input\n    if (this.mouseManager.waitingForRender) {\n      this.mouseManager.waitingForRender = false;\n    }\n\n    // Now that all of our layers have performed updates to everything, we can now dequeue\n    // All resource requests\n    // We create this gate in case multiple draw calls flow through before a buffer opertion is completed\n    if (!this.isBufferingResources) {\n      this.isBufferingResources = true;\n      const didBuffer = await this.resourceManager.dequeueRequests();\n      this.isBufferingResources = false;\n\n      // If buffering did occur and completed, then we should be performing a draw to ensure all of the\n      // Changes are committed and pushed out.\n      if (didBuffer) {\n        this.draw(await onFrame());\n      }\n    }\n\n    // Each frame needs to analyze if draws are needed or not. Thus we reset all draw needs so they will\n    // be considered resolved for the current set of changes.\n    // Set draw needs of cameras and views back to false\n    for (let i = 0, iMax = this.sceneDiffs.items.length; i < iMax; ++i) {\n      const scene = this.sceneDiffs.items[i];\n\n      // Resolve view renders\n      for (let i = 0, iMax = scene.views.length; i < iMax; ++i) {\n        const view = scene.views[i];\n        view.needsDraw = false;\n        view.props.camera.resolve();\n      }\n\n      // Resolve layer renders\n      for (let i = 0, iMax = scene.layers.length; i < iMax; ++i) {\n        const layer = scene.layers[i];\n        layer.needsViewDrawn = false;\n      }\n    }\n\n    // We render color picking to our color picking render target, but we save it's result for the beginning of next\n    // frame. The longest delay picking can cause is from the readPixels operation being CPU blocking. Additionally, the\n    // block will cause a full GPU sync to happen before the picels are read which means the CPU and GPU  are blocked\n    // from adiditional operations UNTIL ALL of the current operations are completed first. Thus, readPixels at the\n    // beginning of next frame makes the most sense as all operations should be assurred to be completed before then.\n    for (let i = 0, iMax = toPick.length; i < iMax; ++i) {\n      const picking = toPick[i];\n      const didDraw = this.drawPicking(picking[0], picking[1], picking[2]);\n\n      if (\n        didDraw &&\n        picking.length > 0 &&\n        !picking[1].optimizeRendering &&\n        this.updateColorPick\n      ) {\n        if (!this.queuedPicking) this.queuedPicking = [];\n        this.queuedPicking.push([\n          picking[0],\n          picking[1],\n          picking[2],\n          this.updateColorPick.position\n        ]);\n      }\n    }\n\n    // Clear out the flag requesting a pick pass so we don't perform a pick render pass unless we have\n    // another requested from mouse interactions\n    delete this.updateColorPick;\n\n    // Uncomment this to see a minimap of the picking render target in real time. Crashes performance, but makes it much\n    // easier to fix underlying bugs when you can see the output pipeline properly.\n    // debugRenderTarget(this.renderer, this.pickingTarget);\n\n    // Dequeue rendering debugs\n    // flushDebug();\n  }\n\n  /**\n   * NOTE: This is a temp way to handle picking. Picking will be handled with MRT once that pipeline is set up.\n   *\n   * This renders a selected scene/view into our picking target. Settings get adjusted\n   */\n  private drawPicking(\n    scene: LayerScene,\n    view: View<IViewProps>,\n    pickingPass: Layer<any, any>[]\n  ) {\n    if (!this.updateColorPick) return false;\n    if (!scene.container) return false;\n    // Optimized rendering of the view will make the view discard picking rendering\n    if (view.optimizeRendering) return false;\n\n    // Get the requested metrics for the pick\n    const views = this.updateColorPick.views;\n\n    // Ensure the view provided is a view that is registered with this surface\n    if (views.indexOf(view) > -1) {\n      // Picking uses a pixel ratio of 1\n      view.pixelRatio = 1.0;\n      // Get the current flags for the view\n      const flags = view.clearFlags.slice(0);\n      // Store the current background of the view\n      const background = view.props.background && copy4(view.props.background);\n      // Set color rendering flag\n      view.props.clearFlags = [ClearFlags.COLOR, ClearFlags.DEPTH];\n      // Set the view's background to a solid black so we don't interfere with color encoding\n      view.props.background = [0, 0, 0, 0];\n\n      // We change the bounds for the view to occupy relative to the render target\n      let screenBounds = new Bounds<never>({\n        height: this.pickingTarget.height,\n        width: this.pickingTarget.width,\n        x: 0,\n        y: 0\n      });\n\n      // Calculate the bounds the viewport will occupy relative to the render target's space\n      let viewportBounds = getAbsolutePositionBounds<View<IViewProps>>(\n        view.props.viewport,\n        screenBounds,\n        1.0\n      );\n\n      // We must perform any operations necessary to make the view camera fit the viewport\n      // Correctly with the possibly adjusted pixel ratio\n      view.fitViewtoViewport(screenBounds, viewportBounds);\n\n      // We must redraw the layers so they will update their uniforms to adapt to a picking pass\n      for (let j = 0, endj = pickingPass.length; j < endj; ++j) {\n        const layer = pickingPass[j];\n        // Adjust the layer to utilize the proper pick mode, thus causing the layer to properly\n        // Set it's uniforms into a pick mode.\n        layer.picking.currentPickMode = PickType.SINGLE;\n\n        // Update the layer's material uniforms and avoid causing the changelist to attempt updates again\n        try {\n          layer.updateUniforms();\n        } catch (err) {\n          /** No-op, the first draw should have output an error for bad draw calls */\n          console.warn(err);\n        }\n\n        layer.picking.currentPickMode = PickType.NONE;\n      }\n\n      // Draw the scene with our picking target as the target\n      this.drawSceneView(\n        scene.container,\n        view,\n        this.renderer,\n        this.pickingTarget\n      );\n\n      // Return the pixel ratio back to the rendered ratio\n      view.pixelRatio = this.pixelRatio;\n      // Return the view's clear flags\n      view.props.clearFlags = flags;\n      // Return the view's background color\n      view.props.background = background;\n\n      // Revert the bounds back to being relative to the screen space\n      screenBounds = new Bounds<never>({\n        height: this.context.canvas.height,\n        width: this.context.canvas.width,\n        x: 0,\n        y: 0\n      });\n\n      // Calculate the bounds the viewport will occupy relative to the screen space\n      viewportBounds = getAbsolutePositionBounds<View<IViewProps>>(\n        view.props.viewport,\n        screenBounds,\n        this.pixelRatio\n      );\n\n      // After reverting the pixel ratio, we must return to the state we came from so that mouse interactions\n      // will work properly\n      view.fitViewtoViewport(screenBounds, viewportBounds);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * This finalizes everything and sets up viewports and clears colors and performs the actual render step\n   */\n  private drawSceneView(\n    scene: Scene,\n    view: View<IViewProps>,\n    renderer?: WebGLRenderer,\n    target?: RenderTarget\n  ) {\n    renderer = renderer || this.renderer;\n    const offset = { x: view.viewBounds.left, y: view.viewBounds.top };\n    const size = view.viewBounds;\n    const background = view.props.background || DEFAULT_BACKGROUND_COLOR;\n    const willClearColorBuffer = view.clearFlags.indexOf(ClearFlags.COLOR) > -1;\n\n    // Make sure the correct render target is applied\n    renderer.setRenderTarget(target || null);\n\n    // Set the scissor rectangle.\n    renderer.setScissor(\n      {\n        x: offset.x,\n        y: offset.y,\n        width: size.width,\n        height: size.height\n      },\n      target\n    );\n    // If a background is established, we should clear the background color\n    // Specified for this context\n    if (willClearColorBuffer) {\n      // Clear the rect of color and depth so the region is totally it's own\n      renderer.clearColor([\n        background[0],\n        background[1],\n        background[2],\n        background[3]\n      ]);\n    }\n\n    // Make sure the viewport is set properly for the next render\n    renderer.setViewport({\n      x: offset.x,\n      y: offset.y,\n      width: size.width,\n      height: size.height\n    });\n\n    // Get the view's clearing preferences\n    if (view.clearFlags && view.clearFlags.length > 0) {\n      renderer.clear(\n        willClearColorBuffer,\n        view.clearFlags.indexOf(ClearFlags.DEPTH) > -1,\n        view.clearFlags.indexOf(ClearFlags.STENCIL) > -1\n      );\n    } else {\n      renderer.clear(false);\n    }\n\n    // Render the scene with the provided view metrics\n    renderer.render(scene, target);\n    // Indicate this view has been rendered for the given time allottment\n    view.lastFrameTime = this.frameMetrics.currentTime;\n  }\n\n  /**\n   * This gathers all the overlap views of every view\n   */\n  private gatherViewDrawDependencies() {\n    if (!this.sceneDiffs) return;\n    this.viewDrawDependencies.clear();\n    const scenes = this.sceneDiffs.items;\n\n    // Fit all views to viewport\n    for (let i = 0, endi = scenes.length; i < endi; i++) {\n      const scene = scenes[i];\n\n      for (let k = 0, kMax = scene.views.length; k < kMax; ++k) {\n        const view = scene.views[k];\n\n        // To look for the overlaps of the view in screen space, we must calculate the view's viewport bounds\n        // relative to the screenspace.\n        const screenBounds = new Bounds<never>({\n          height: this.context.canvas.height,\n          width: this.context.canvas.width,\n          x: 0,\n          y: 0\n        });\n\n        // Calculate the bounds the viewport will occupy relative to the screen space\n        const viewportBounds = getAbsolutePositionBounds<View<IViewProps>>(\n          view.props.viewport,\n          screenBounds,\n          this.pixelRatio\n        );\n\n        view.fitViewtoViewport(screenBounds, viewportBounds);\n      }\n    }\n\n    // Set viewDrawDependencies\n    for (let i = 0, endi = scenes.length; i < endi; i++) {\n      const scene = scenes[i];\n\n      for (let k = 0, kMax = scene.views.length; k < kMax; ++k) {\n        const sourceView = scene.views[k];\n        const overlapViews: View<IViewProps>[] = [];\n\n        for (let j = 0, endj = scenes.length; j < endj; j++) {\n          if (j !== i) {\n            const scene = scenes[j];\n\n            for (let l = 0, lMax = scene.views.length; l < lMax; ++l) {\n              const targetView = scene.views[l];\n\n              if (sourceView.viewBounds.hitBounds(targetView.viewBounds)) {\n                overlapViews.push(targetView);\n              }\n            }\n          }\n        }\n\n        this.viewDrawDependencies.set(sourceView, overlapViews);\n      }\n    }\n  }\n\n  /**\n   * This allws for querying a view's screen bounds. Null i;s returned if the view id\n   * specified does not exist.\n   */\n  getViewSize(viewId: string): Bounds<View<IViewProps>> | null {\n    for (let i = 0, iMax = this.sceneDiffs.items.length; i < iMax; ++i) {\n      const scene = this.sceneDiffs.items[i];\n      const view = scene.viewDiffs.getByKey(viewId);\n      if (view) return view.screenBounds;\n    }\n\n    return null;\n  }\n\n  /**\n   * This queries a view's window into a world's space.\n   */\n  getViewWorldBounds(viewId: string): Bounds<never> | null {\n    for (let i = 0, iMax = this.sceneDiffs.items.length; i < iMax; ++i) {\n      const scene = this.sceneDiffs.items[i];\n      const view = scene.viewDiffs.getByKey(viewId);\n\n      if (view) {\n        if (view.screenBounds) {\n          const topLeft = view.projection.viewToWorld([0, 0]);\n          const bottomRight = view.projection.screenToWorld([\n            view.screenBounds.right,\n            view.screenBounds.bottom\n          ]);\n\n          return new Bounds({\n            bottom: bottomRight[1],\n            left: topLeft[0],\n            right: bottomRight[0],\n            top: topLeft[1]\n          });\n        } else {\n          return null;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Retrieves the projection methods for a given view, null if the view id does not exist\n   * in the surface\n   */\n  getProjections(viewId: string): BaseProjection<any> | null {\n    for (let i = 0, iMax = this.sceneDiffs.items.length; i < iMax; ++i) {\n      const scene = this.sceneDiffs.items[i];\n      const view = scene.viewDiffs.getByKey(viewId);\n\n      if (view) return view.projection;\n    }\n\n    return null;\n  }\n\n  /**\n   * This is the beginning of the system. This should be called immediately after the surface is constructed.\n   * We make this mandatory outside of the constructor so we can make it follow an async pattern.\n   */\n  async init(options: ISurfaceOptions) {\n    // If this already has initialized it's context, then there's nothing to be done\n    if (this.context) return this;\n    // Make sure our desired pixel ratio is set up\n    this.pixelRatio = options.pixelRatio || this.pixelRatio;\n\n    if (this.pixelRatio < 1.0) {\n      this.pixelRatio = 1.0;\n    }\n\n    // Initialize our GL needs that set the basis for rendering\n    const context = this.initGL(options);\n\n    if (!context) {\n      this.readyResolver.reject({\n        error: SurfaceErrorType.NO_WEBGL_CONTEXT,\n        message:\n          \"Could not establish a webgl context. Surface is being destroyed to free resources.\"\n      });\n      this.destroy();\n      return this;\n    }\n\n    this.context = context;\n\n    if (this.gl) {\n      // Initialize our event manager that handles mouse interactions/gestures with the canvas\n      this.initMouseManager(options);\n      // Initialize any resources requested or needed, such as textures or rendering surfaces\n      await this.initResources(options);\n      // Initialize any io expanders requested or needed. This must happen after resource initialization\n      // as resource managers can produce their own expanders.\n      await this.initIOExpanders(options);\n    } else {\n      console.warn(\n        \"Could not establish a GL context. Layer Surface will be unable to render\"\n      );\n    }\n\n    this.readyResolver.resolve(this);\n\n    return this;\n  }\n\n  /**\n   * This initializes the Canvas GL contexts needed for rendering.\n   */\n  private initGL(options: ISurfaceOptions) {\n    // Get the canvas of our context to set up our GL settings\n    const canvas = options.context;\n    if (!canvas) return null;\n\n    // Apply the deltav version to the attributes of the canvas so we have more debugging information available\n    try {\n      canvas.setAttribute(\"data-deltav\", require(\"../release\").version);\n    } catch (err) {\n      // NOOP - We want the application of the version to happen, but it is not application critical\n    }\n\n    // Get the starting width and height so adjustments don't affect it\n    const width = canvas.width;\n    const height = canvas.height;\n    let hasContext = true;\n\n    const rendererOptions: ISurfaceOptions[\"rendererOptions\"] = Object.assign(\n      {\n        alpha: false,\n        antialias: false,\n        preserveDrawingBuffer: false,\n        premultiplyAlpha: false\n      },\n      options.rendererOptions\n    );\n\n    // Generate the renderer along with it's properties\n    this.renderer = new WebGLRenderer({\n      // Context supports rendering to an alpha canvas only if the background color has a transparent\n      // Alpha value.\n      alpha: rendererOptions.alpha,\n      // Yes to antialias! Make it preeeeetty!\n      antialias: rendererOptions.antialias,\n      // Make the GL use an existing canvas rather than generate another\n      canvas,\n      // If it's true it allows us to snapshot the rendering in the canvas\n      // But we dont' always want it as it makes performance drop a bit.\n      preserveDrawingBuffer: rendererOptions.preserveDrawingBuffer,\n      // This indicates if the information written to the canvas is going to be written as premultiplied values\n      // or if they will be standard rgba values. Helps with compositing with the DOM.\n      premultipliedAlpha: rendererOptions.premultipliedAlpha,\n\n      // Let's us know if there is no valid webgl context to work with or not\n      onNoContext: () => {\n        hasContext = false;\n      }\n    });\n\n    if (!hasContext || !this.renderer.gl) return null;\n    this.context = this.renderer.gl;\n\n    if (this.resourceManager) {\n      this.resourceManager.setWebGLRenderer(this.renderer);\n    }\n\n    // Generate a target for the picking pass\n    this.pickingTarget = new RenderTarget({\n      buffers: {\n        color: new Texture({\n          generateMipMaps: false,\n          data: {\n            width,\n            height,\n            buffer: null\n          }\n        }),\n        depth: GLSettings.RenderTarget.DepthBufferFormat.DEPTH_COMPONENT16\n      },\n      // We want a target with a pixel ratio of just 1, which will be more than enough accuracy for mouse picking\n      width,\n      height\n    });\n\n    // This sets the pixel ratio to handle differing pixel densities in screens\n    this.setRendererSize(width, height);\n    // Set the pixel ratio to match the pixel density of the monitor in use\n    this.renderer.setPixelRatio(this.pixelRatio);\n\n    return this.renderer.gl;\n  }\n\n  /**\n   * Initializes the expanders that should be applied to the surface for layer processing.\n   */\n  private initIOExpanders(options: ISurfaceOptions) {\n    // Handle expanders passed in as an array or blank\n    if (\n      Array.isArray(options.ioExpansion) ||\n      options.ioExpansion === undefined\n    ) {\n      // Initialize the Shader IO expansion objects\n      this.ioExpanders =\n        (options.ioExpansion && options.ioExpansion.slice(0)) ||\n        (DEFAULT_IO_EXPANSION && DEFAULT_IO_EXPANSION.slice(0)) ||\n        [];\n    }\n\n    // Handle expanders passed in as a method\n    else if (options.ioExpansion instanceof Function) {\n      this.ioExpanders = options.ioExpansion(DEFAULT_IO_EXPANSION);\n    }\n\n    // Retrieve any expansion objects the resource managers may provide\n    const managerIOExpanders = this.resourceManager.getIOExpansion();\n    // Add the expanders to our current handled list.\n    this.ioExpanders = this.ioExpanders.concat(managerIOExpanders);\n  }\n\n  /**\n   * Initializes elements for handling mouse interactions with the canvas.\n   */\n  private initMouseManager(options: ISurfaceOptions) {\n    // We must inject an event manager to broadcast events through the layers themselves\n    const eventManagers: EventManager[] = ([\n      new LayerMouseEvents()\n    ] as EventManager[]).concat(options.eventManagers || []);\n\n    // Generate the mouse manager for the layer\n    this.mouseManager = new UserInputEventManager(\n      this.context.canvas,\n      this,\n      eventManagers,\n      options.handlesWheelEvents\n    );\n  }\n\n  /**\n   * This initializes resources needed or requested such as textures or render surfaces.\n   */\n  private async initResources(options: ISurfaceOptions) {\n    // Create the controller for handling all resource managers\n    this.resourceManager = new ResourceRouter();\n    // Set the GL renderer to the\n    this.resourceManager.setWebGLRenderer(this.renderer);\n\n    // Get the managers requested by the configuration\n    const managers =\n      (options.resourceManagers && options.resourceManagers.slice(0)) ||\n      (DEFAULT_RESOURCE_MANAGEMENT && DEFAULT_RESOURCE_MANAGEMENT.slice(0)) ||\n      [];\n\n    // Register all of the managers for use by their type.\n    managers.forEach(manager => {\n      this.resourceManager.setManager(manager.type, manager.manager);\n    });\n  }\n\n  /**\n   * Use this to establish the rendering pipeline the application should be using at the current time.\n   *\n   * NOTE: If you update the pipeline on a loop of any sort, you will want to await the pipeline to complete\n   * it's diff before you issue a draw command. Failure to do so invites undefined behavior which often causes\n   * elements tobe comepltely not rendered at all in many cases.\n   */\n  async pipeline(pipeline: IPipeline) {\n    if (pipeline.resources) {\n      await this.resourceDiffs.diff(pipeline.resources);\n    }\n\n    if (pipeline.scenes) {\n      await this.sceneDiffs.diff(pipeline.scenes);\n    }\n\n    // This gathers the draw dependencies of the views (which views overlap other views.)\n    // This will let the system know when a view is needing re-rendering how it can preserve other views\n    // and prevent them from needing a redraw\n    this.gatherViewDrawDependencies();\n  }\n\n  /**\n   * This must be executed when the canvas changes size so that we can re-calculate the scenes and views\n   * dimensions for handling all of our rendered elements.\n   */\n  fitContainer(_pixelRatio?: number) {\n    if (isOffscreenCanvas(this.context.canvas)) return;\n    const container = this.context.canvas.parentElement;\n\n    if (container) {\n      const canvas = this.context.canvas;\n      canvas.className = \"\";\n      canvas.setAttribute(\"style\", \"\");\n      container.style.position = \"relative\";\n      canvas.style.position = \"absolute\";\n      canvas.style.left = \"0xp\";\n      canvas.style.top = \"0xp\";\n      canvas.style.width = \"100%\";\n      canvas.style.height = \"100%\";\n      canvas.setAttribute(\"width\", \"\");\n      canvas.setAttribute(\"height\", \"\");\n      const containerBox = container.getBoundingClientRect();\n      const box = canvas.getBoundingClientRect();\n\n      this.resize(box.width || 100, containerBox.height || 100);\n    }\n  }\n\n  /**\n   * This resizes the canvas and retains pixel ratios amongst all of the resources involved.\n   */\n  resize(width: number, height: number, pixelRatio?: number) {\n    this.pixelRatio = pixelRatio || this.pixelRatio;\n\n    if (this.pixelRatio < 1.0) {\n      this.pixelRatio = 1.0;\n    }\n\n    if (this.sceneDiffs) {\n      const scenes = this.sceneDiffs.items;\n      for (let i = 0, iMax = scenes.length; i < iMax; ++i) {\n        const scene = scenes[i];\n\n        for (let k = 0, kMax = scene.views.length; k < kMax; ++k) {\n          const view = scene.views[k];\n          view.pixelRatio = this.pixelRatio;\n        }\n      }\n    }\n\n    this.setRendererSize(width, height);\n    this.renderer.setPixelRatio(this.pixelRatio);\n    this.mouseManager.resize();\n\n    // After the resize happens, the view draw dependencies may change as the views will cover different region sizes\n    this.gatherViewDrawDependencies();\n  }\n\n  /**\n   * This flags all views to fully re-render\n   */\n  redraw() {\n    for (let i = 0, iMax = this.sceneDiffs.items.length; i < iMax; ++i) {\n      const viewLayers = this.sceneDiffs.items[i];\n\n      for (let k = 0, kMax = viewLayers.views.length; k < kMax; ++k) {\n        const view = viewLayers.views[k];\n        view.needsDraw = true;\n      }\n    }\n  }\n\n  /**\n   * This applies a new size to the renderer and resizes any additional resources that requires being\n   * sized along with the renderer.\n   */\n  private setRendererSize(width: number, height: number) {\n    width = width || 100;\n    height = height || 100;\n\n    // Set the canvas size for the renderer\n    this.renderer.setSize(width, height);\n    // Set the picking target size to be the dimensions of our renderer as well\n    this.pickingTarget.setSize(width, height);\n  }\n\n  /**\n   * This triggers an update to all of the layers that perform picking, the pixel data\n   * within the specified mouse range.\n   */\n  updateColorPickPosition(position: Vec2, views: View<IViewProps>[]) {\n    // We will flag the color range as needing an update\n    this.updateColorPick = {\n      position,\n      views\n    };\n  }\n}\n","import { WebGLRenderer } from \"../gl\";\nimport { Instance } from \"../instance-provider/instance\";\nimport { ILayerProps, Layer } from \"../surface/layer\";\nimport { BaseIOExpansion } from \"../surface/layer-processing/base-io-expansion\";\nimport { InstanceIOValue, IResourceContext, IResourceType } from \"../types\";\nimport {\n  BaseResourceManager,\n  INVALID_RESOURCE_MANAGER\n} from \"./base-resource-manager\";\n\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * This is the manager of all Resource Managers. This handles registering managers for various resource types\n * and delegates resource requests to the appropriate manager.\n */\nexport class ResourceRouter {\n  /** This is the list of managers for handling resource requests */\n  managers = new Map<number, BaseResourceManager<any, any>>();\n  /**\n   * This tracks a resource's identifier to the type of resource it is. This allows for less information to be\n   * required of Layer attributes by making the resource key the identifier of the resource.s\n   */\n  resourceKeyToType = new Map<string, number>();\n  /** This is the webgl renderer that is passed to the resource managers */\n  webGLRenderer?: WebGLRenderer;\n\n  /**\n   * This is called by the system to cause the managers to dequeue their requests in an asynchronous fashion\n   */\n  async dequeueRequests() {\n    let didUpdate = false;\n    const managers = Array.from(this.managers.values());\n\n    for (let i = 0, iMax = managers.length; i < iMax; ++i) {\n      const manager = managers[i];\n      const update = await manager.dequeueRequests();\n      didUpdate = didUpdate || update;\n    }\n\n    return didUpdate;\n  }\n\n  /**\n   * Destroys all managers managed by this manager.\n   */\n  destroy() {\n    this.managers.forEach(manager => manager.destroy());\n    this.resourceKeyToType.clear();\n    this.managers.clear();\n    delete this.webGLRenderer;\n  }\n\n  /**\n   * This hands the destruction of a resource to the correct Resource Manager.\n   */\n  async destroyResource<T extends IResourceType>(\n    resource: T & { key: string }\n  ) {\n    const manager = this.managers.get(resource.type);\n\n    if (!manager) {\n      console.warn(\n        `A Resource is trying to be destroyed but has no manager to facilitate the operation: ${resource.type}`\n      );\n\n      return;\n    }\n\n    // Clear the key of the resource from it's registered type\n    this.resourceKeyToType.delete(resource.key);\n\n    return await manager.destroyResource(resource);\n  }\n\n  /**\n   * Retrieves the Shader IO Expansion controllers that may be provided by resource managers.\n   */\n  getIOExpansion() {\n    let all: BaseIOExpansion[] = [];\n\n    this.managers.forEach(manager => {\n      all = all.concat(manager.getIOExpansion());\n    });\n\n    return all;\n  }\n\n  /**\n   * Gets the manager for the provided resource type\n   */\n  getManager(resourceType: number): BaseResourceManager<any, any> {\n    const manager = this.managers.get(resourceType);\n\n    if (!manager) {\n      console.warn(\n        `A manager was requested that does not exist for type ${resourceType}`\n      );\n      return INVALID_RESOURCE_MANAGER;\n    }\n\n    return manager;\n  }\n\n  /**\n   * Retrieves the resource type that a resource key is associated with. This is undefined if the key does\n   * not exist.\n   */\n  getResourceType(resourceKey: string): number | undefined {\n    return this.resourceKeyToType.get(resourceKey);\n  }\n\n  /**\n   * This hands the initialization of a resource to the correct Resource Manager.\n   */\n  async initResource<T extends IResourceType>(resource: T & { key: string }) {\n    const manager = this.managers.get(resource.type);\n\n    if (!manager) {\n      console.warn(\n        `A Resource is trying to be created but has no manager to facilitate the operation: ${resource.type}`\n      );\n\n      return;\n    }\n\n    if (this.resourceKeyToType.has(resource.key)) {\n      console.warn(\n        \"Detected two resources with identical keys. The duplicate resource will not be generated:\",\n        resource.key\n      );\n\n      return;\n    }\n\n    // Store the key of the resource to the type it is.\n    this.resourceKeyToType.set(resource.key, resource.type);\n\n    return await manager.initResource(resource);\n  }\n\n  /**\n   * This is called by layers to request resources being generated.\n   */\n  request<\n    T extends Instance,\n    U extends ILayerProps<T>,\n    V extends IResourceType\n  >(\n    layer: Layer<T, U>,\n    instance: Instance,\n    resource: V,\n    context?: IResourceContext\n  ): InstanceIOValue {\n    const manager = this.managers.get(resource.type);\n\n    if (!manager) {\n      console.warn(\n        `A Layer is requesting a resource for which there is no manager set. Please make sure a Resource Manager is set for resource of type: ${resource.type}`\n      );\n      return [-1, -1, -1, -1];\n    }\n\n    return manager.request(layer, instance, resource, context);\n  }\n\n  /**\n   * Every resource type needs a manager associated with it so it can have requests processed. This\n   * allows a manager to be set for a resource type.\n   */\n  setManager(resourceType: number, manager: BaseResourceManager<any, any>) {\n    const currentManager = this.managers.get(resourceType);\n\n    if (currentManager) {\n      debug(\n        `A manager was assigned to a resource type: ${resourceType} that overrides another manager already set to that type.`\n      );\n    }\n\n    manager.router = this;\n    this.managers.set(resourceType, manager);\n    manager.webGLRenderer = this.webGLRenderer;\n  }\n\n  /**\n   * This sets the current gl renderer used for handling GL operations.\n   */\n  setWebGLRenderer(renderer: WebGLRenderer) {\n    this.webGLRenderer = renderer;\n    this.managers.forEach(manager => (manager.webGLRenderer = renderer));\n  }\n\n  /**\n   * This hands the update of a resource to the correct Resource Manager.\n   */\n  async updateResource<T extends IResourceType>(resource: T & { key: string }) {\n    const manager = this.managers.get(resource.type);\n\n    if (!manager) {\n      console.warn(\n        `A Resource is trying to be updated but has no manager to facilitate the operation: ${resource.type}`\n      );\n\n      return;\n    }\n\n    return await manager.updateResource(resource);\n  }\n}\n","export * from \"./cpu-sdf\";\nexport * from \"./font-manager\";\nexport * from \"./font-map\";\nexport * from \"./font-renderer\";\nexport * from \"./font-resource-manager\";\nexport * from \"./font-resource-request\";\nexport * from \"./glyph-renderer\";\n","import { dot2, subtract2, Vec2 } from \"../../math/vector\";\n\nconst { ceil, max, log2, pow, sqrt } = Math;\n\n/** This is the pixel that  */\nconst NO_DATA: Vec2 = [-1, -1];\n\n/**\n * Gets the seed array for the JFA\n */\nfunction getSeed(canvas: HTMLCanvasElement, imageData: Uint8ClampedArray) {\n  const { width, height } = canvas;\n  let a;\n  const buffer: Vec2[][] = [];\n  const inverse: Vec2[][] = [];\n\n  for (let i = 0; i < width; ++i) {\n    buffer[i] = [];\n    inverse[i] = [];\n\n    for (let k = 0; k < height; ++k) {\n      const redIndex = k * (width * 4) + i * 4;\n      a = imageData[redIndex + 3];\n\n      // Any non-transparent pixel is a seed\n      if (a) {\n        buffer[i][k] = [i, k];\n        inverse[i][k] = NO_DATA;\n      } else {\n        buffer[i][k] = NO_DATA;\n        inverse[i][k] = [i, k];\n      }\n    }\n  }\n\n  return {\n    seed: buffer,\n    inverse\n  };\n}\n\n/**\n * Makes a buffer the same size as the input buffer. This assumes that the\n * input buffer is N x M in size, meaning each row is the same size.\n */\nfunction makeEmptyBuffer(buffer: Vec2[][]) {\n  const newBuffer: Vec2[][] = [];\n\n  for (let i = 0, iMax = buffer.length; i < iMax; ++i) {\n    newBuffer[i] = [];\n  }\n\n  return newBuffer;\n}\n\n/**\n * Takes a positional buffer and converts it to a distance field that is normalized to 0 - 255\n */\nfunction normalizedDistanceField(\n  buffer: Vec2[][],\n  noData: Vec2,\n  negate: boolean = false\n) {\n  const sign = negate ? -1 : 1;\n  let position: Vec2, current: Vec2, direction: Vec2;\n  let distance;\n  const distanceBuffer: number[][] = [];\n  let maxDistance: number = -1;\n\n  // Calculate the distances and get the max distance so we can normalize the output\n  for (let x = 0, xMax = buffer.length; x < xMax; ++x) {\n    const col = buffer[x];\n    distanceBuffer[x] = [];\n\n    for (let y = 0, yMax = col.length; y < yMax; ++y) {\n      position = col[y];\n\n      if (position === noData) {\n        distance = 256;\n      } else {\n        current = [x, y];\n        direction = subtract2(position, current);\n        distance = sqrt(dot2(direction, direction));\n      }\n\n      // Store the distance in our buffer for when we generate the canvas rendering\n      distanceBuffer[x][y] = distance;\n      // Update our max distance found so we can normalize the values\n      maxDistance = max(distance, maxDistance);\n    }\n  }\n\n  // Convert our distance buffer to our canvas buffer\n  for (let x = 0, xMax = buffer.length; x < xMax; ++x) {\n    const col = buffer[x];\n\n    for (let y = 0, yMax = col.length; y < yMax; ++y) {\n      distance = distanceBuffer[x][y];\n      distanceBuffer[x][y] = (distance / maxDistance) * 255 * sign;\n    }\n  }\n\n  return distanceBuffer;\n}\n\n/**\n * Takes the positional buffer of JFA and maps it to an Image Data buffer to be rendered as the canvas\n */\nfunction mapToDistanceField(\n  toSeedBuffer: Vec2[][],\n  fromSeedBuffer: Vec2[][],\n  noData: Vec2,\n  outBuffer: Uint8ClampedArray\n) {\n  let outColor;\n  // This is the distance field repsenting our distance to the seed values\n  const toSeedDistance = normalizedDistanceField(toSeedBuffer, noData, true);\n  // This is the negated distance field from the seed to the nearest non-seed slot\n  const fromSeedDistance = normalizedDistanceField(\n    fromSeedBuffer,\n    noData,\n    false\n  );\n\n  const width = toSeedDistance.length;\n  const outputDistance = toSeedDistance;\n\n  // Combine the buffers to get our font SDF\n  for (let x = 0, xMax = toSeedDistance.length; x < xMax; ++x) {\n    const toSeedCol = toSeedDistance[x];\n    const fromSeedCol = fromSeedDistance[x];\n\n    for (let y = 0, yMax = toSeedCol.length; y < yMax; ++y) {\n      const toSeed = toSeedCol[y];\n      const fromSeed = fromSeedCol[y];\n\n      toSeedCol[y] = toSeed + fromSeed;\n    }\n  }\n\n  for (let x = 0, xMax = outputDistance.length; x < xMax; ++x) {\n    const toSeedCol = outputDistance[x];\n\n    for (let y = 0, yMax = toSeedCol.length; y < yMax; ++y) {\n      outColor = toSeedCol[y];\n      // We use the 1 - signed distance (images are more human happy and algo happy)\n      outColor = outColor;\n\n      const redIndex = y * (width * 4) + x * 4;\n      outBuffer[redIndex] = outColor;\n      outBuffer[redIndex + 1] = outColor;\n      outBuffer[redIndex + 2] = outColor;\n      outBuffer[redIndex + 3] = 255;\n    }\n  }\n}\n\n/**\n * This contains the JFA pass logic portion of the algorithm. This requires the seedBuffer\n * and the number of passes to execute.\n */\nfunction jfaPasses(seedBuffer: Vec2[][], passes: number) {\n  const width = seedBuffer.length;\n  const height = seedBuffer[0].length;\n  // Set the current out to the seed as the each pass places the out into the read as the first step\n  let readBuffer: Vec2[][] = makeEmptyBuffer(seedBuffer);\n  let outBuffer: Vec2[][] = seedBuffer;\n  let c: Vec2;\n  let delta: Vec2;\n  let samples: Vec2[];\n  let nearestValue: number;\n  let nearestIndex: number;\n  let distance;\n  let x, y, i;\n\n  // We run the JFA passes over the buffers until complete\n  for (let pass = 0; pass < passes; ++pass) {\n    // We dont want to destroy the old read buffer as we will just write over the old data\n    // so we don't allocate a new buffer for each pass.\n    const temp = readBuffer;\n    // Swap the out buffer from last pass to the read buffer of this pass\n    readBuffer = outBuffer;\n    // We now write to the other buffer\n    outBuffer = temp;\n    // Next make a new out buffer to write into\n    const offset = pow(2, passes - pass - 1);\n\n    // Now loop through all of the buffer 'pixels' and take the JFA sampling\n    for (x = 0; x < width; ++x) {\n      for (y = 0; y < height; ++y) {\n        c = [x, y];\n        samples = [\n          (readBuffer[x - offset] || [])[y - offset] || NO_DATA,\n          (readBuffer[x] || [])[y - offset] || NO_DATA,\n          (readBuffer[x + offset] || [])[y - offset] || NO_DATA,\n          (readBuffer[x - offset] || [])[y] || NO_DATA,\n          (readBuffer[x] || [])[y] || NO_DATA,\n          (readBuffer[x + offset] || [])[y] || NO_DATA,\n          (readBuffer[x - offset] || [])[y + offset] || NO_DATA,\n          (readBuffer[x] || [])[y + offset] || NO_DATA,\n          (readBuffer[x + offset] || [])[y + offset] || NO_DATA\n        ];\n\n        nearestIndex = 0;\n        nearestValue = Number.MAX_VALUE;\n\n        for (i = 0; i < 9; ++i) {\n          const s = samples[i];\n\n          // NO_DATA does not require analysis\n          if (s !== NO_DATA) {\n            delta = subtract2(s, c);\n            distance = dot2(delta, delta);\n\n            if (distance < nearestValue) {\n              nearestValue = distance;\n              nearestIndex = i;\n            }\n          }\n        }\n\n        // We write to the buffer with our result which will either be NO_DATA or a pixel location\n        outBuffer[x][y] = samples[nearestIndex];\n      }\n    }\n  }\n\n  return outBuffer;\n}\n\n/**\n * Redraws the contents of the provided canvas as a signed distance field.\n * Signed distance fields are great for many techniques.\n *\n * As of right now this SDF merely represents distance to nearest occupied\n * pixel.\n *\n * This  particular SDF calculation utilizes JFA\n *\n * This algortihm follows the following:\n * Make a buffer that is the size of the canvas and seed it with values equal to the pixel position of filled pixels\n * Next calculate how many passes JFA will need to run based on the size of the canvas: log_2(max dimension of the canvas)\n * Next sample the buffer in a 3x3 grid with each having an offset that is 2^(number of passes - current pass - 1). The center\n * sample is the current pixel.\n * Each sample will contain either NO DATA or will contain the pixel position of the nearest filled pixel.\n * Each sample will calculate the distance of the sample to the current pixel position, the nearest sample will fill the buffer at\n * that position.\n *\n * After all passes, the buffer should be filled with the nearest pixel positions. You can take that and map it to either distances\n * or use other techniques desired.\n */\nexport function convertToSDF(\n  canvas: HTMLCanvasElement,\n  mapMethod: (\n    toSeedBuffer: Vec2[][],\n    fromSeedBuffer: Vec2[][],\n    noDataObject: Vec2,\n    outData: Uint8ClampedArray\n  ) => void = mapToDistanceField\n) {\n  const { width, height } = canvas;\n  const context = canvas.getContext(\"2d\");\n  if (!context) return;\n\n  const imageData = context.getImageData(0, 0, width, height).data;\n\n  // This gets the dimension to use as our max dimension for the JFA algorithm pass calculation\n  const maxDimension = max(width, height);\n  // Determine how many passes to execute\n  const passes = ceil(log2(maxDimension));\n  // This is the initial seed buffer for the JFA\n  const seedBuffer = getSeed(canvas, imageData);\n  // Runt he passes on the initial seed buffer to make the positional buffer\n  const positionBuffer = jfaPasses(seedBuffer.seed, passes);\n  const inversePositionBuffer = jfaPasses(seedBuffer.inverse, passes);\n  // Make an image data object that we can manipulate and apply to the canvas\n  const outImageData = new ImageData(width, height);\n  // Map the positional buffer to something that can be rendered to a canvas. By default, this will\n  // be a distance field.\n  mapMethod(positionBuffer, inversePositionBuffer, NO_DATA, outImageData.data);\n  // Render the out data to the input canvas\n  context.putImageData(outImageData, 0, 0);\n}\n\n/**\n * Makes a SDF of the input font specified\n */\nexport function makeFontSDF(_canvas: HTMLCanvasElement) {\n  // TODO\n}\n","import { PromiseResolver } from \"../../util\";\n\nconst img = document.createElement(\"img\");\nconst canvas = document.createElement(\"canvas\");\n\n/**\n * This takes a very simple svg and converts it to a data object for pixel examination.\n */\nexport async function svgToData(svg: SVGSVGElement) {\n  const resolver = new PromiseResolver<ImageData | null>();\n  if (!img || !canvas) return null;\n\n  // Get svg data\n  const xml = new XMLSerializer().serializeToString(svg);\n  // Make it base64\n  const svg64 = btoa(xml);\n  const b64Start = \"data:image/svg+xml;base64,\";\n  // Prepend the base64 \"header\"\n  const image64 = b64Start + svg64;\n  let didDraw = false;\n\n  // Method for rendering to the canvas once the svg image is ready\n  const draw = () => {\n    // Ensure we only draw once\n    if (didDraw) return;\n    didDraw = true;\n    // Make sure the canvas accommodates your monitor density!\n    canvas.width = img.width * window.devicePixelRatio;\n    canvas.height = img.height * window.devicePixelRatio;\n    const ctx = canvas.getContext(\"2d\");\n\n    if (!ctx) {\n      resolver.resolve(null);\n      return;\n    }\n\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    (ctx as any).mozImageSmoothingEnabled = false;\n    (ctx as any).webkitImageSmoothingEnabled = false;\n    (ctx as any).msImageSmoothingEnabled = false;\n    ctx.imageSmoothingEnabled = false;\n\n    ctx.drawImage(\n      img,\n      0,\n      0,\n      img.width * window.devicePixelRatio,\n      img.height * window.devicePixelRatio\n    );\n\n    resolver.resolve(ctx.getImageData(0, 0, canvas.width, canvas.height));\n\n    // Clean up used RAM useage for the image and canvas context\n    img.src = \"\";\n    // To debug this, simply uncomment this line and comment out the width/height change\n    // document.body.appendChild(canvas);\n    canvas.width = 0;\n    canvas.height = 0;\n    canvas.style.position = \"absolute\";\n    canvas.style.top = \"0px\";\n    canvas.style.zIndex = \"9999\";\n  };\n\n  img.onload = draw;\n  img.src = image64;\n\n  // If the width is already set then the image already has rendered it's contents and is ready to render to the\n  // canvas context.\n  if (img.width > 0 && img.height > 0) {\n    draw();\n  }\n\n  const result = await resolver.promise;\n  return result;\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport {\n  SubTexture,\n  subTextureIOValue\n} from \"../../resources/texture/sub-texture\";\nimport { ILayerProps, Layer } from \"../../surface/layer\";\nimport { BaseIOExpansion } from \"../../surface/layer-processing/base-io-expansion\";\nimport {\n  InstanceIOValue,\n  IResourceContext,\n  IResourceInstanceAttribute,\n  ResourceType\n} from \"../../types\";\nimport { nextFrame, shallowCompare } from \"../../util\";\nimport {\n  BaseResourceManager,\n  BaseResourceOptions\n} from \"../base-resource-manager\";\nimport { TextureIOExpansion } from \"../texture/texture-io-expansion\";\nimport {\n  FontManager,\n  IFontResourceOptions,\n  isFontResource\n} from \"./font-manager\";\nimport { FontMap } from \"./font-map\";\nimport {\n  FontResourceRequestFetch,\n  IFontResourceRequest\n} from \"./font-resource-request\";\n\nconst debug = require(\"debug\")(\"performance\");\n\nexport interface IFontResourceRequestInternal extends IFontResourceRequest {\n  /**\n   * This is used to flag a request object as requested so that the same request object can be used for\n   * similar resources without generating two request lifecycles.\n   */\n  isRequested?: boolean;\n}\n\n/**\n * This manager controls and manages Font type resources that are requested for generation. This manager\n * will utilize the request given to it to provide the best possible solution in both load times and\n * run time performance available to the manager.\n *\n * This manager will have the ability to handle resources\n */\nexport class FontResourceManager extends BaseResourceManager<\n  IFontResourceOptions,\n  IFontResourceRequest\n> {\n  /** The current attribute that is making request calls */\n  currentAttribute: IResourceInstanceAttribute<Instance>;\n  /**\n   * This tracks if a resource is already in the request queue. This also stores ALL instances awaiting the resource.\n   */\n  private requestLookup = new Map<\n    string,\n    Map<IFontResourceRequest, [Layer<any, any>, Instance][]>\n  >();\n\n  /** This stores all of the requests awaiting dequeueing */\n  private requestQueue = new Map<string, IFontResourceRequest[]>();\n  /** This is the lookup for generated font map resources */\n  private resourceLookup = new Map<string, FontMap>();\n  /** This is the manager that is used to create and update font resources */\n  private fontManager = new FontManager();\n\n  /**\n   * This is so the system can control when requests are made so this manager has the opportunity\n   * to verify and generate the resources the request requires.\n   */\n  async dequeueRequests(): Promise<boolean> {\n    // This flag will be modified to reflect if a dequeue operation has occurred\n    let didDequeue = false;\n    const resourceRequestsWithKey: [string, IFontResourceRequest[]][] = [];\n\n    this.requestQueue.forEach((requests, resourceKey) => {\n      resourceRequestsWithKey.push([resourceKey, requests]);\n    });\n\n    this.requestQueue.clear();\n\n    // Loop through all requests paired with their resource key context\n    for (let i = 0, iMax = resourceRequestsWithKey.length; i < iMax; ++i) {\n      const [fontResource, allRequests] = resourceRequestsWithKey[i];\n\n      if (allRequests.length > 0) {\n        // We did dequeue\n        didDequeue = true;\n        // Pull out all of the requests into a new array and empty the existing queue to allow the queue to register\n        // New requests while this dequeue is being processed\n        const requests = allRequests.slice(0);\n        // Empty the queue to begin taking in new requests as needed\n        allRequests.length = 0;\n\n        debug(\"Processing requests for resource '%s'\", fontResource);\n\n        // Tell the font manager to update with all of the requested resources\n        await this.fontManager.updateFontMap(fontResource, requests);\n        // Tell the manager to process all of the metrics requests for the text\n        await this.fontManager.calculateMetrics(fontResource, requests);\n        // Get the requests for the given font\n        const glyphRequests = this.requestLookup.get(fontResource);\n\n        if (glyphRequests) {\n          // Once the manager has been updated, we can now flag all of the instances waiting for the resources\n          // As active, which should thus trigger an update to the layers to perform a diff for each instance\n          requests.forEach(resource => {\n            const request = glyphRequests.get(resource);\n            glyphRequests.delete(resource);\n\n            if (request) {\n              for (let i = 0, iMax = request.length; i < iMax; ++i) {\n                const [layer, instance] = request[i];\n                // If the instance is still associated with buffer locations, then the instance can be activated. Having\n                // A buffer location is indicative the instance has not been deleted.\n                if (layer.managesInstance(instance)) {\n                  // Make sure the instance is active\n                  instance.active = true;\n                }\n              }\n\n              // Do a delay to next frame before we do our resource trigger so we can see any lingering updates get\n              // applied to the instance's rendering\n              nextFrame(() => {\n                const triggered = new Set();\n\n                for (let i = 0, iMax = request.length; i < iMax; ++i) {\n                  const instance = request[i][1];\n\n                  if (!triggered.has(instance)) {\n                    triggered.add(instance);\n                    instance.resourceTrigger();\n                  }\n                }\n              });\n            }\n          });\n\n          debug(\"All requests for resource '%s' are processed\", fontResource);\n        } else {\n          debug(\n            \"There were no Font requests waiting for completion for resource\",\n            fontResource\n          );\n        }\n      }\n    }\n\n    return didDequeue;\n  }\n\n  /**\n   * This will force this manager to free all of it's beloved resources that it manages should\n   * it be holding onto resources that can not be freed by lack of references.\n   */\n  destroy(): void {\n    this.fontManager.destroy();\n  }\n\n  /**\n   * Destroy a single resource if the system deems it's time for it to go\n   */\n  destroyResource(init: BaseResourceOptions) {\n    const resource = this.resourceLookup.get(init.key);\n    if (!resource) return;\n    this.fontManager.destroyFontMap(resource.id);\n    this.resourceLookup.delete(init.key);\n  }\n\n  /**\n   * This will provide the resource generated from the initResource operation.\n   */\n  getResource(resourceKey: string) {\n    return this.resourceLookup.get(resourceKey) || null;\n  }\n\n  /**\n   * Make the expander to handle making the attribute changes necessary to have the texture applied\n   * to a uniform when the attribute places a resource request with a key.\n   */\n  getIOExpansion(): BaseIOExpansion[] {\n    return [new TextureIOExpansion(ResourceType.FONT, this)];\n  }\n\n  /**\n   * This is a request to intiialize a resource by this manager.\n   */\n  async initResource(options: BaseResourceOptions) {\n    if (isFontResource(options)) {\n      const fontMap = await this.fontManager.createFontMap(options);\n\n      if (fontMap) {\n        this.resourceLookup.set(options.key, fontMap);\n      }\n\n      debug(\"Font map created->\", fontMap);\n    }\n  }\n\n  /**\n   * This is for attributes making a request for a resource of this type to create shader compatible info\n   * regarding the requests properties.\n   */\n  request<U extends Instance, V extends ILayerProps<U>>(\n    layer: Layer<U, V>,\n    instance: Instance,\n    req: IFontResourceRequest,\n    _context?: IResourceContext\n  ): InstanceIOValue {\n    const request: IFontResourceRequestInternal = req;\n    const fontMap = request.fontMap;\n    let texture: SubTexture | null = null;\n\n    // If the texture is ready and available, then we simply return the IO values\n    if (fontMap) {\n      // If this is a character request, then we output the texture desired. Kerning requests only needs\n      // the font map populated in the request.\n      if (request.character) {\n        texture = fontMap.getGlyphTexture(request.character);\n      }\n\n      if (texture) {\n        if (request.fetch === FontResourceRequestFetch.IMAGE_SIZE) {\n          return [texture.pixelWidth, texture.pixelHeight];\n        }\n\n        return subTextureIOValue(texture);\n      }\n\n      if (request.fetch === FontResourceRequestFetch.IMAGE_SIZE) {\n        return [0, 0];\n      }\n\n      return subTextureIOValue(null);\n    }\n\n    // This is the attributes resource key being requested\n    const resourceKey = req.key;\n    // If a request is already made, then we must save the instance making the request for deactivation and\n    // Reactivation but without any additional atlas loading\n    let fontRequests = this.requestLookup.get(resourceKey);\n\n    if (fontRequests) {\n      const existingRequests = fontRequests.get(request);\n\n      if (existingRequests) {\n        existingRequests.push([layer, instance]);\n        instance.active = false;\n\n        if (request.fetch === FontResourceRequestFetch.IMAGE_SIZE) {\n          return [0, 0];\n        }\n\n        return subTextureIOValue(texture);\n      }\n    } else {\n      fontRequests = new Map();\n      this.requestLookup.set(resourceKey, fontRequests);\n    }\n\n    // If the texture is not available, then we must load the resource, deactivate the instance\n    // And wait for the resource to become available. Once the resource is available, the system\n    // Must activate the instance to render the resource.\n    instance.active = false;\n    let requests = this.requestQueue.get(resourceKey);\n\n    if (!requests) {\n      requests = [];\n      this.requestQueue.set(resourceKey, requests);\n    }\n\n    requests.push(request);\n    fontRequests.set(request, [[layer, instance]]);\n\n    // This returns essentially returns blank values for the resource lookup\n    if (request.fetch) {\n      return [0, 0];\n    }\n\n    return subTextureIOValue(texture);\n  }\n\n  /**\n   * Responds to the system detecting properties for a resource need updating.\n   */\n  updateResource(options: BaseResourceOptions) {\n    if (!isFontResource(options)) return;\n    const resource = this.resourceLookup.get(options.key);\n    if (!resource) return;\n    if (shallowCompare(options.fontSource, resource.fontSource)) return;\n\n    debug(\n      \"Font resources currently do not update. To update their properties simply destroy and recreate for now.\"\n    );\n  }\n}\n","export * from \"./atlas-manager\";\nexport * from \"./atlas-resource-manager\";\nexport * from \"./atlas-resource-request\";\nexport * from \"./atlas\";\nexport * from \"./image-rasterizer\";\nexport * from \"./pack-node\";\nexport * from \"./sub-texture\";\nexport * from \"./texture-io-expansion\";\n","import { onFrame } from \"../../util\";\nimport { SubTexture } from \"./sub-texture\";\n\n/**\n * This object monitors a video and it's corresponding texture it is rendered to. This will ensure the video and the\n * texture are in sync with each other.\n */\nexport class VideoTextureMonitor {\n  /** Indictaes if this resource is valid or not */\n  private isDestroyed: boolean = false;\n  /** This is the current rendered time frame that is applied to the subtexture */\n  private renderedTime: number = -1;\n\n  previousTime: number = -1;\n  playedFrames: number = 0;\n  caughtFrames: number = 0;\n  timeFrame: number = 0;\n\n  constructor(public video: HTMLVideoElement, public subTexture: SubTexture) {\n    this.addEventListeners();\n  }\n\n  /**\n   * Applies all of the necessary listeners to the video object\n   */\n  private async addEventListeners() {\n    if (this.isDestroyed) return;\n    this.loop(await onFrame());\n  }\n\n  /**\n   * Allows all resources to be freed.\n   */\n  destroy() {\n    this.video.pause();\n    this.isDestroyed = true;\n    this.removeEventListeners();\n  }\n\n  /**\n   * Performs the update operation no matter which event it  comes from\n   */\n  private doUpdate = () => {\n    // Only a change in time from what was currently rendered will require a render update\n    if (Math.abs(this.video.currentTime - this.renderedTime) < 0.015) {\n      return;\n    }\n\n    // Make sure we don't trigger duplicate updates by tracking the time we have rendered\n    this.renderedTime = this.video.currentTime;\n    // Tell the sub texture to update from it's source again which will grab the newest and bestest pixels\n    this.subTexture.update();\n  };\n\n  /**\n   * Render loop. We utilize this loop as all video playback events are inconsistent across browsers and have no truly\n   * perfect callback\n   */\n  private loop = (_t: number) => {\n    this.doUpdate();\n    if (!this.isDestroyed) onFrame(this.loop);\n  };\n\n  /**\n   * Cleans up any listeners this may have registered to ensure the video does not get retained\n   */\n  private removeEventListeners() {\n    // No listeners needed yet\n  }\n}\n","import { Omit, ResourceType } from \"../../types\";\nimport { BaseResourceRequest } from \"../base-resource-manager\";\nimport { SubTexture } from \"./sub-texture\";\n\nexport type AtlasVideoResource = {\n  videoSrc: string;\n};\n\nexport type AtlasResource = string | TexImageSource;\n\nconst EMPTY_IMAGE = new Image();\n\n/**\n * Base information an atlas resource can provide\n */\nexport interface IAtlasResourceRequest extends BaseResourceRequest {\n  /**\n   * When this is set in conjunction with the resource requested, this will cause the resource to be\n   * removed from the resource manager, thus allowing the resource's space to be used at a later\n   * time.\n   */\n  disposeResource?: boolean;\n  /**\n   * This is the key of the resource to be used for the request. Resources are defined in the pipeline.\n   */\n  key: string;\n  /**\n   * This scales the image to be rendered to the texture. A value of 1 means the image will be\n   * rendered full size to the texture. A value of .5 means it will be rendered half size to\n   * the texture.\n   */\n  rasterizationScale?: number;\n  /** This is the requested resource to be loaded into the manager system */\n  source: AtlasResource;\n  /**\n   * Once loaded into the texture, this will be populated revealing the informaion needed to sample the image\n   * from the atlas.\n   */\n  texture?: SubTexture;\n  /** Set the type of this resource for categorization by resource managers */\n  type: ResourceType.ATLAS;\n}\n\n/**\n * Simple wrapper to make autocomplete easier for making an atlas request.\n */\nexport function atlasRequest(\n  options: Omit<Partial<IAtlasResourceRequest>, \"type\"> &\n    Pick<IAtlasResourceRequest, \"key\">\n): IAtlasResourceRequest {\n  return {\n    type: ResourceType.ATLAS,\n    source: EMPTY_IMAGE,\n    ...options\n  };\n}\n","import { activeAttributeName } from \"../../../constants\";\nimport { Instance } from \"../../../instance-provider/instance\";\nimport { ShaderDeclarationStatements } from \"../../../shaders/processing/base-shader-io-injection\";\nimport { MetricsProcessing } from \"../../../shaders/processing/metrics-processing\";\nimport { ILayerProps, Layer } from \"../../../surface/layer\";\nimport { BaseIOExpansion } from \"../../../surface/layer-processing/base-io-expansion\";\nimport { IInstanceAttribute, IUniform, IVertexAttribute } from \"../../../types\";\n\nconst debugCtx = \"ActiveIOExpansion\";\n\n/**\n * This is a special case io expander that handles detecting the _active attribute\n * and properly injecting the _active handler in the destructuring phase.\n *\n * Any IO expansion that writes destructuring logic will have it's destructuring logic\n */\nexport class ActiveIOExpansion extends BaseIOExpansion {\n  processAttributeDestructuring(\n    _layer: Layer<Instance, ILayerProps<Instance>>,\n    declarations: ShaderDeclarationStatements,\n    _metrics: MetricsProcessing,\n    _vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<Instance>[],\n    _uniforms: IUniform[]\n  ): string {\n    const out = \"\";\n\n    // Find the active attribute. If it exists we inject our active attribute handler\n    if (!instanceAttributes.find(attr => attr.name === activeAttributeName)) {\n      return out;\n    }\n\n    // The final item in the destructuring will always be the active attribute handler to ensure elements\n    // honor the active control\n    this.setDeclaration(\n      declarations,\n      \"__active_attribute_handler__\",\n      require(\"./fragments/active-attribute-handler.vs\"),\n      debugCtx\n    );\n\n    return out;\n  }\n}\n","module.exports = \"if (_active == 0.0) {\\ngl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\nreturn;\\n}\"","import { Vec2, Vec4 } from \"../math/vector\";\nimport { IColorPickingData } from \"../types\";\n\n/**\n * This analyzes the rendered data for color picking and outputs the metrics and data needed\n * for the operation.\n */\nexport function analyzeColorPickingRendering(\n  mouse: Vec2,\n  data: Uint8Array,\n  width: number,\n  height: number\n) {\n  const pickingData: IColorPickingData = {\n    allColors: [],\n    colorData: data,\n    dataHeight: height,\n    dataWidth: width,\n    mouse,\n    nearestColor: 0,\n    nearestColorBytes: [0, 0, 0, 0]\n  };\n\n  const uniqueColors = new Map<number, boolean>();\n  let pixelIndex = 0;\n  const colors: number[][] = [];\n  const mouseX: number = width / 2;\n  const mouseY: number = height / 2;\n\n  let nearestColor = 0x000000;\n  let nearestColorBytes: Vec4 = [0, 0, 0, 0];\n  let distance = Number.MAX_SAFE_INTEGER;\n\n  for (let i = 0; i < height; ++i) {\n    const row: number[] = [];\n    colors.push(row);\n\n    for (let k = 0; k < width; ++k) {\n      const r = data[pixelIndex];\n      const g = data[pixelIndex + 1];\n      const b = data[pixelIndex + 2];\n      pixelIndex += 4;\n\n      const color = (r << 16) | (g << 8) | b;\n      uniqueColors.set(color, true);\n      row.push(color);\n\n      // If the color is not black, let's test the distance against currnet nearest color\n      if (color !== 0x000000) {\n        const dx = k - mouseX;\n        const dy = i - mouseY;\n        const testDistance = dx * dx + dy * dy;\n\n        if (testDistance < distance) {\n          distance = testDistance;\n          nearestColor = color;\n          nearestColorBytes = [r, g, b, 255];\n        }\n      }\n    }\n  }\n\n  // Apply all of the unique colors that were discovered within the rendering\n  pickingData.allColors = Array.from(uniqueColors.keys());\n  // The nearest color will be the element in the middle of the array of colors\n  pickingData.nearestColor = nearestColor;\n  // The nearest color in byte components\n  pickingData.nearestColorBytes = nearestColorBytes;\n\n  return pickingData;\n}\n","import { Instance } from \"../instance-provider/instance\";\nimport { IInstanceAttribute, IUniform, IVertexAttribute } from \"../types\";\n\n/**\n * This provides the sorting methods to be applied to\n */\nexport class BaseIOSorting {\n  /**\n   * This sorts the attributes such that the attributes that MUST be updated first are put to the top.\n   * This is necessary for complex attributes like atlas and easing attributes who have other attributes\n   * that have dependent behaviors based on their source attribute.\n   */\n  sortInstanceAttributes<T extends Instance>(\n    a: IInstanceAttribute<T>,\n    b: IInstanceAttribute<T>\n  ) {\n    if (a.resource && !b.resource) return -1;\n    if (a.easing && !b.easing) return -1;\n    return 1;\n  }\n\n  /**\n   * This sorts the vertex attributes in the expected order of updating.\n   */\n  sortVertexAttributes(_a: IVertexAttribute, _b: IVertexAttribute) {\n    return 1;\n  }\n\n  /**\n   * This sorts the uniforms in the expected order of updating.\n   */\n  sortUniforms(_a: IUniform, _b: IUniform) {\n    return 1;\n  }\n}\n","import { SimpleEventHandler } from \"../../event-management/simple-event-handler\";\nimport {\n  IEventInteraction,\n  IMouseInteraction,\n  ITouchInteraction\n} from \"../../event-management/types\";\nimport { BaseProjection } from \"../../math\";\nimport { PickType } from \"../../types\";\nimport {\n  isDefined,\n  mapGetWithDefault,\n  mapInjectDefault,\n  nextFrame\n} from \"../../util\";\nimport { Layer } from \"../layer\";\nimport { LayerScene } from \"../layer-scene\";\nimport { IViewProps, View } from \"../view\";\n\n/**\n * This class is an injected event manager for the surface, it specifically handles taking in mouse events intended for view interactions\n * and broadcasts them to the layers that have picking enabled, thus allowing the layers to respond to\n * mouse view locations and broadcast Instance interactions based on the interaction with the View the layer is a part of\n *\n * In Summary: This is an adapter that takes in interactions to the views and injects those events into the layers associated with\n * the views so that the layers can translate the events to gestures.\n */\nexport class LayerMouseEvents extends SimpleEventHandler {\n  /** This tracks which views have the mouse over them so we can properly broadcast view is out events */\n  isOver = new Set<View<IViewProps>>();\n  /** This tracks which views have touches over them */\n  isTouchOver = new Map<number, Set<View<IViewProps>>>();\n  /** This is the surface this manager is aiding with broadcasting events to layers */\n  get scenes(): LayerScene[] {\n    if (!this.surface || !this.surface.sceneDiffs) return [];\n    return this.surface.sceneDiffs.items;\n  }\n\n  constructor() {\n    super({});\n  }\n\n  getSceneViewsUnderMouse(e: IEventInteraction) {\n    const viewByViewId = new Map<string, View<IViewProps>>();\n\n    // Map the scenes to SceneViews\n    for (let i = 0, iMax = this.scenes.length; i < iMax; ++i) {\n      const scene = this.scenes[i];\n\n      for (let k = 0, kMax = scene.views.length; k < kMax; ++k) {\n        const view = scene.views[k];\n        viewByViewId.set(view.id, view);\n      }\n    }\n\n    // Now retrieve and convert each view under the mouse to the scene view it coincides with\n    return e.target.views\n      .map(viewItem => viewByViewId.get(viewItem.view.id))\n      .filter(isDefined);\n  }\n\n  handleClick(e: IMouseInteraction) {\n    this.handleInteraction(e, (layer, view) => {\n      layer.interactions.handleMouseClick(view, e);\n    });\n  }\n\n  handleTap(e: ITouchInteraction) {\n    e.touches.forEach(interaction => {\n      this.handleInteraction(interaction, (layer, view) => {\n        layer.interactions.handleTap(view, e, interaction);\n      });\n    });\n  }\n\n  handleDrag(e: IMouseInteraction) {\n    this.handleInteraction(e, (layer, view) => {\n      layer.interactions.handleMouseDrag(view, e);\n    });\n  }\n\n  handleMouseDown(e: IMouseInteraction) {\n    this.handleInteraction(e, (layer, view) =>\n      layer.interactions.handleMouseDown(view, e)\n    );\n  }\n\n  async handleTouchDown(e: ITouchInteraction) {\n    const views: View<IViewProps>[] = [];\n\n    e.touches.forEach(interaction => {\n      interaction.target.views.forEach(target => views.push(target.view));\n    });\n\n    if (this.surface) {\n      this.surface.updateColorPickPosition(e.touches[0].screen.position, views);\n    }\n\n    await nextFrame();\n\n    e.touches.forEach(interaction => {\n      this.handleInteraction(interaction, (layer, view) =>\n        layer.interactions.handleTouchDown(view, e, interaction)\n      );\n    });\n  }\n\n  handleMouseUp(e: IMouseInteraction) {\n    this.handleInteraction(e, (layer, view) =>\n      layer.interactions.handleMouseUp(view, e)\n    );\n  }\n\n  handleTouchUp(e: ITouchInteraction) {\n    e.touches.forEach(interaction => {\n      this.handleInteraction(interaction, (layer, view) =>\n        layer.interactions.handleTouchUp(view, e, interaction)\n      );\n    });\n  }\n\n  handleMouseOut(e: IMouseInteraction) {\n    // All views that are moused over should no longer be considered over and broadcast a mouse out\n    this.isOver.forEach(view => {\n      this.handleView(view, (layer, view) =>\n        layer.interactions.handleMouseOut(view, e)\n      );\n    });\n\n    // Nothing is over anymore\n    this.isOver.clear();\n  }\n\n  handleTouchOut(e: ITouchInteraction) {\n    e.touches.forEach(interaction => {\n      const isTouchOver = mapGetWithDefault(\n        this.isTouchOver,\n        interaction.touch.touch.identifier,\n        new Set()\n      );\n\n      // All views that are moused over should no longer be considered over and broadcast a mouse out\n      isTouchOver.forEach(view => {\n        this.handleView(view, (layer, view) =>\n          layer.interactions.handleTouchOut(view, e, interaction)\n        );\n      });\n\n      // Nothing is over anymore\n      this.isOver.clear();\n    });\n  }\n\n  handleMouseMove(e: IMouseInteraction) {\n    if (this.surface) {\n      this.surface.updateColorPickPosition(\n        e.screen.position,\n        e.target.views.map(v => v.view)\n      );\n    }\n\n    // Get all of the scenes we have interacted with, and broadcast a move event for each\n    const allSceneViews = this.handleInteraction(e, (layer, view) =>\n      layer.interactions.handleMouseMove(view, e)\n    );\n\n    // For quick lookups map all of the current SceneViews that are over\n    const currentSceneViews = new Set<View<IViewProps>>();\n    allSceneViews.forEach(v => currentSceneViews.add(v));\n\n    // Detect which of the views are no longer over\n    this.isOver.forEach(view => {\n      if (!currentSceneViews.has(view)) {\n        this.handleView(view, (layer, view) =>\n          layer.interactions.handleMouseOut(view, e)\n        );\n      }\n    });\n\n    // Detect which of the views are newly over\n    currentSceneViews.forEach(sceneView => {\n      if (!this.isOver.has(sceneView)) {\n        this.handleView(sceneView, (layer, view) =>\n          layer.interactions.handleMouseOver(view, e)\n        );\n      }\n    });\n\n    // Update the current views that are over to the currently over views for next event\n    this.isOver = currentSceneViews;\n  }\n\n  /**\n   * Touch dragging is essentially touch moving as it's the only way to make a touch glide across the screen\n   */\n  handleTouchDrag(e: ITouchInteraction) {\n    e.touches.forEach(interaction => {\n      if (this.surface) {\n        this.surface.updateColorPickPosition(\n          interaction.screen.position,\n          interaction.target.views.map(v => v.view)\n        );\n      }\n\n      // Get all of the scenes we have interacted with, and broadcast a move event for each\n      const allSceneViews = this.handleInteraction(interaction, (layer, view) =>\n        layer.interactions.handleTouchMove(view, e, interaction)\n      );\n\n      // For quick lookups map all of the current SceneViews that are over\n      const currentSceneViews = new Set<View<IViewProps>>();\n      allSceneViews.forEach(v => currentSceneViews.add(v));\n      const isTouchOver = mapInjectDefault(\n        this.isTouchOver,\n        interaction.touch.touch.identifier,\n        new Set()\n      );\n\n      // Detect which of the views are no longer over\n      isTouchOver.forEach(view => {\n        if (!currentSceneViews.has(view)) {\n          this.handleView(view, (layer, view) =>\n            layer.interactions.handleTouchOut(view, e, interaction)\n          );\n        }\n      });\n\n      // Detect which of the views are newly over\n      currentSceneViews.forEach(sceneView => {\n        if (!isTouchOver.has(sceneView)) {\n          this.handleView(sceneView, (layer, view) =>\n            layer.interactions.handleTouchOver(view, e, interaction)\n          );\n        }\n      });\n\n      // Update the current views that are over to the currently over views for next event\n      this.isTouchOver.set(\n        interaction.touch.touch.identifier,\n        currentSceneViews\n      );\n    });\n  }\n\n  handleInteraction(\n    e: IEventInteraction,\n    callback: (layer: Layer<any, any>, view: BaseProjection<any>) => void\n  ) {\n    // Get all of the scenes under the mouse\n    const views = this.getSceneViewsUnderMouse(e);\n\n    // For every view of every scene, we must tell it's layers it's world space is receiving mouse interactions\n    for (let i = 0, iMax = views.length; i < iMax; ++i) {\n      const view = views[i];\n      this.handleView(view, callback);\n    }\n\n    return views;\n  }\n\n  handleView(\n    view: View<IViewProps>,\n    callback: (layer: Layer<any, any>, view: BaseProjection<any>) => void\n  ) {\n    for (let i = 0, iMax = view.scene.layers.length; i < iMax; ++i) {\n      const layer = view.scene.layers[i];\n\n      if (layer.picking && layer.picking.type !== PickType.NONE) {\n        callback(layer, view.projection);\n      }\n    }\n  }\n}\n","import { uniformBufferInstanceBufferName } from \"../../../constants\";\nimport { MaterialUniformType } from \"../../../gl/types\";\nimport { Instance } from \"../../../instance-provider/instance\";\nimport { Vec4 } from \"../../../math/vector\";\nimport {\n  ShaderDeclarationStatements,\n  ShaderIOHeaderInjectionResult\n} from \"../../../shaders/processing/base-shader-io-injection\";\nimport { MetricsProcessing } from \"../../../shaders/processing/metrics-processing\";\nimport { ILayerProps, Layer } from \"../../../surface/layer\";\nimport { BaseIOExpansion } from \"../../../surface/layer-processing/base-io-expansion\";\nimport {\n  IInstanceAttribute,\n  InstanceAttributeSize,\n  IUniform,\n  IVertexAttribute,\n  LayerBufferType,\n  PickType,\n  ShaderInjectionTarget\n} from \"../../../types\";\n\n/** Provides a label for performance debugging */\nconst debugCtx = \"BasicIOExpansion\";\n/** Defines the elements for destructuring out of a vector */\nconst VECTOR_COMPONENTS = [\"x\", \"y\", \"z\", \"w\"];\n\n/** Converts a size to a shader type */\nconst sizeToType: { [key: number]: string } = {\n  1: \"float\",\n  2: \"vec2\",\n  3: \"vec3\",\n  4: \"vec4\",\n  9: \"mat3\",\n  16: \"mat4\",\n  /** This is the special case for instance attributes that want an atlas resource */\n  99: \"vec4\"\n};\n\n/**\n * This method properly provides a vector's chunk of data based on a swizzle. So a size of 2\n * provides vector.xy and a size of 4 provides vector.xyzw.\n */\nfunction makeVectorSwizzle(start: number, size: number) {\n  return VECTOR_COMPONENTS.slice(start, start + size).join(\"\");\n}\n\n/**\n * This is the basic needs of processing attributes and uniforms and injecting their declarations into the shader.\n * This will handle buffer management associated with normal hardware instancing, vertex packing, and\n * uniform packing.\n *\n * This will not expand the IO in any way, rather this forms the basis for the IO input declarations in the shader\n * and arranges these declarations to handle all of the base Buffer management systems provided in the\n * default DeltaV library.\n */\nexport class BasicIOExpansion extends BaseIOExpansion {\n  /**\n   * This is the special case where attributes are packed into a uniform buffer instead of into\n   * attributes. This is to maximize compatibility with hardware and maximize flexibility in creative approaches\n   * to utilizing shaders that need a lot of input.\n   */\n  private generateUniformAttributePacking(\n    declarations: ShaderDeclarationStatements,\n    metrics: MetricsProcessing\n  ): ShaderIOHeaderInjectionResult {\n    // Add the uniform buffer to the shader\n    this.setDeclaration(\n      declarations,\n      uniformBufferInstanceBufferName,\n      `\\n// Instance Attributes as a packed Uniform Buffer\\nuniform vec4 ${uniformBufferInstanceBufferName}[${metrics.totalInstanceUniformBlocks}];\\n`,\n      debugCtx\n    );\n    // Add the number of blocks an instance utilizes\n    this.setDeclaration(\n      declarations,\n      \"instanceSize\",\n      `int instanceSize = ${metrics.totalInstanceUniformBlocks};`,\n      debugCtx\n    );\n    // Add the block retrieval method to aid in the Destructuring process\n    this.setDeclaration(\n      declarations,\n      \"getBlock\",\n      `vec4 getBlock(int index, int instanceIndex) { return ${uniformBufferInstanceBufferName}[(instanceSize * instanceIndex) + index]; }`,\n      debugCtx\n    );\n\n    return {\n      injection: \"\",\n      material: {\n        uniforms: [\n          {\n            name: uniformBufferInstanceBufferName,\n            type: MaterialUniformType.VEC4_ARRAY,\n            value: new Array(metrics.totalInstanceUniformBlocks)\n              .fill(0)\n              .map<Vec4>(() => [0, 0, 0, 0])\n          }\n        ]\n      }\n    };\n  }\n\n  /**\n   * This properly handles any special case destructuring for making the decalred attribute names available\n   * after the ${attribute} declaration.\n   */\n  processAttributeDestructuring(\n    layer: Layer<Instance, ILayerProps<Instance>>,\n    declarations: ShaderDeclarationStatements,\n    metrics: MetricsProcessing,\n    _vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<Instance>[],\n    _uniforms: IUniform[]\n  ): string {\n    let out = \"\";\n\n    // Prevent mutating\n    const orderedAttributes = instanceAttributes.slice(0);\n\n    // See which buffer strategy our layer is using and produce a destructuring strategy that suits it\n    switch (layer.bufferType) {\n      case LayerBufferType.INSTANCE_ATTRIBUTE:\n        out = this.processDestructuringInstanceAttribute(\n          declarations,\n          orderedAttributes\n        );\n        break;\n\n      case LayerBufferType.INSTANCE_ATTRIBUTE_PACKING:\n        out = this.processDestructuringInstanceAttributePacking(\n          declarations,\n          orderedAttributes\n        );\n        break;\n\n      case LayerBufferType.UNIFORM:\n        out = this.processDestructuringUniformBuffer(\n          declarations,\n          orderedAttributes,\n          metrics.blocksPerInstance\n        );\n        break;\n    }\n\n    // For now we add in our picking varying assignment should it be needed\n    if (layer.picking.type === PickType.SINGLE) {\n      out +=\n        \"\\n// This portion is where the shader assigns the picking color that gets passed to the fragment shader\\n_picking_color_pass_ = _pickingColor;\\n\";\n    }\n\n    return out;\n  }\n\n  /**\n   * Destructuring for normal instancing via attributes with no packing\n   */\n  private processDestructuringInstanceAttribute(\n    _declarations: ShaderDeclarationStatements,\n    _orderedAttributes: IInstanceAttribute<Instance>[]\n  ) {\n    // No-op, the attributes for normal instance attribute destructuring will simply be used directly\n    // as they will not be packed in and will simply out\n    return \"\";\n  }\n\n  /**\n   * This generates all Destructuring needs for the Instance Attribute Packing strategy. For this scenario\n   * attributes are tighly packed into attribute blocks rather than explicitly named attributes, thus the blocks\n   * must be destructured into the proper names of the attributes.\n   *\n   * This will, as well, destructure the auto easing methods.\n   */\n  private processDestructuringInstanceAttributePacking<T extends Instance>(\n    declarations: ShaderDeclarationStatements,\n    orderedAttributes: IInstanceAttribute<T>[]\n  ) {\n    let out = \"\";\n\n    // The attributes are generated in blocks already. Thus all that need be done for this scenario\n    // is merely perform block destructuring\n    out += this.processDestructureBlocks(declarations, orderedAttributes);\n\n    return out;\n  }\n\n  /**\n   * This generates all Destructuring needs for the Uniform Packing strategy. For this scenario,\n   * attributes are tighly packed into uniform blocks rather than attributes, thus the blocks\n   * must be destructured into the proper names of the attributes.\n   *\n   * This will, as well, destructure the auto easing methods.\n   */\n  private processDestructuringUniformBuffer<T extends Instance>(\n    declarations: ShaderDeclarationStatements,\n    orderedAttributes: IInstanceAttribute<T>[],\n    blocksPerInstance: number\n  ) {\n    this.setDeclaration(\n      declarations,\n      \"instanceIndex\",\n      \"int instanceIndex = int(instance);\",\n      debugCtx\n    );\n\n    // Generate the blocks\n    for (let i = 0; i < blocksPerInstance; ++i) {\n      this.setDeclaration(\n        declarations,\n        `block${i}`,\n        `  vec4 block${i} = getBlock(${i}, instanceIndex);\\n`,\n        debugCtx\n      );\n    }\n\n    // Destructure the blocks\n    return this.processDestructureBlocks(declarations, orderedAttributes);\n  }\n\n  /**\n   * This produces the destructuring elements needed to utilize the attribute data stored in blocks with names\n   * like:\n   *\n   * vec4 block0;\n   * vec4 block1;\n   *\n   * etc\n   */\n  private processDestructureBlocks<T extends Instance>(\n    declarations: ShaderDeclarationStatements,\n    orderedAttributes: IInstanceAttribute<T>[]\n  ) {\n    const out = \"\";\n\n    orderedAttributes.forEach(attribute => {\n      const block = attribute.block || 0;\n\n      // An attribute that is utilizing a matrix will span itself across 4 blocks\n      if (attribute.size === InstanceAttributeSize.MAT4X4) {\n        // If we have a size the size of a block, then don't swizzle the vector\n        this.setDeclaration(\n          declarations,\n          attribute.name,\n          `  ${sizeToType[attribute.size]} ${\n            attribute.name\n          } = mat4(block${block}, block${block + 1}, block${block +\n            2}, block${block + 3});\\n`,\n          debugCtx\n        );\n      } else if (attribute.size === InstanceAttributeSize.FOUR) {\n        // If we have a size the size of a block, then don't swizzle the vector\n        this.setDeclaration(\n          declarations,\n          attribute.name,\n          `  ${sizeToType[attribute.size]} ${\n            attribute.name\n          } = block${block};\\n`,\n          debugCtx\n        );\n      } else {\n        // Do normal destructuring with any other size and type\n        this.setDeclaration(\n          declarations,\n          attribute.name,\n          `  ${sizeToType[attribute.size || 1]} ${\n            attribute.name\n          } = block${block}.${makeVectorSwizzle(\n            attribute.blockIndex || 0,\n            attribute.size || 1\n          )};\\n`,\n          debugCtx\n        );\n      }\n    });\n\n    return out;\n  }\n\n  /**\n   * This processes the declarations needed to set up the Input for the shader from the layer.\n   *\n   * This handles the buffer strategies of:\n   *\n   * Vertex Attributes,\n   * Vertex Attribute Packing,\n   * Uniform Packing\n   */\n  processHeaderInjection(\n    target: ShaderInjectionTarget,\n    declarations: ShaderDeclarationStatements,\n    layer: Layer<Instance, ILayerProps<Instance>>,\n    metrics: MetricsProcessing,\n    vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<Instance>[],\n    uniforms: IUniform[]\n  ): ShaderIOHeaderInjectionResult {\n    let attributeDeclarations = {\n      injection: \"\"\n    };\n\n    // Attributes are only injected into the vertex shader\n    if (target === ShaderInjectionTarget.VERTEX) {\n      attributeDeclarations = this.processAttributeHeader(\n        declarations,\n        layer,\n        metrics,\n        vertexAttributes,\n        instanceAttributes\n      );\n    }\n\n    const uniformDeclaration = this.processUniformHeader(\n      declarations,\n      uniforms,\n      target\n    );\n\n    return {\n      ...attributeDeclarations,\n      injection: attributeDeclarations.injection + uniformDeclaration\n    };\n  }\n\n  /**\n   * Processes all IO for attribute declarations needed in the header of the shader.\n   */\n  private processAttributeHeader(\n    declarations: ShaderDeclarationStatements,\n    layer: Layer<Instance, ILayerProps<Instance>>,\n    metrics: MetricsProcessing,\n    vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<Instance>[]\n  ): ShaderIOHeaderInjectionResult {\n    let materialChanges = undefined;\n    let out = \"// Shader input\\n\";\n\n    // If we are in a uniform buffer type strategy. Then we generate a uniform buffer that will contain\n    // our instance attribute information along with some extras to help dereference from the buffer.\n    if (\n      layer.bufferType === LayerBufferType.UNIFORM &&\n      instanceAttributes.length > 0\n    ) {\n      const packing = this.generateUniformAttributePacking(\n        declarations,\n        metrics\n      );\n      materialChanges = packing.material;\n      out += packing.injection;\n    }\n\n    // Add in the vertex attributes input\n    out += this.processVertexAttributes(declarations, vertexAttributes);\n\n    // If we are in an instance attribute Buffer Type strategy, then we simply list out\n    // the attributes listed in our instance attributes as attributes.\n    if (\n      layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE &&\n      instanceAttributes.length > 0\n    ) {\n      out += this.processInstanceAttributeBufferStrategy(\n        declarations,\n        instanceAttributes\n      );\n    }\n\n    // If we are in an instance attribute \"packing\" buffer type strategy, then the layer\n    // is expecting to have attributes that are \"blocks\" instead of explicitally named\n    // attributes. The layer will be utilizing the blocks to efficiently pack in our instance information\n    if (\n      layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE_PACKING &&\n      instanceAttributes.length > 0\n    ) {\n      out += this.processInstanceAttributePackingBufferStrategy(\n        declarations,\n        metrics.instanceMaxBlock\n      );\n    }\n\n    return {\n      injection: out,\n      material: materialChanges\n    };\n  }\n\n  /**\n   * Processes all IO for uniform declarations needed in the header of the shader.\n   */\n  private processUniformHeader(\n    declarations: ShaderDeclarationStatements,\n    uniforms: IUniform[],\n    injectionType: ShaderInjectionTarget\n  ) {\n    const out = \"\";\n    const injection = injectionType || ShaderInjectionTarget.VERTEX;\n\n    uniforms.forEach(uniform => {\n      uniform.shaderInjection =\n        uniform.shaderInjection || ShaderInjectionTarget.VERTEX;\n\n      if (\n        uniform.shaderInjection === injection ||\n        uniform.shaderInjection === ShaderInjectionTarget.ALL\n      ) {\n        this.setDeclaration(\n          declarations,\n          uniform.name,\n          `uniform ${uniform.qualifier || \"\"}${uniform.qualifier ? \" \" : \"\"}${\n            sizeToType[uniform.size]\n          } ${uniform.name};\\n`,\n          debugCtx\n        );\n      }\n    });\n\n    return out;\n  }\n\n  /**\n   * Produces attributes that are explicitally named and set by the attribute itself.\n   */\n  private processInstanceAttributeBufferStrategy<T extends Instance>(\n    declarations: ShaderDeclarationStatements,\n    instanceAttributes: IInstanceAttribute<T>[]\n  ) {\n    instanceAttributes.forEach(attribute => {\n      this.setDeclaration(\n        declarations,\n        attribute.name,\n        `attribute ${sizeToType[attribute.size || 1]} ${attribute.qualifier ||\n          \"\"}${(attribute.qualifier && \" \") || \"\"} ${attribute.name};\\n`,\n        debugCtx\n      );\n    });\n\n    return \"\";\n  }\n\n  /**\n   * Produces attributes that are blocks instead of individual attributes. The system uses these\n   * blocks to pack attributes tightly together to maximize capabilities.\n   */\n  private processInstanceAttributePackingBufferStrategy(\n    declarations: ShaderDeclarationStatements,\n    maxBlock: number\n  ) {\n    // Now print out blocks up to that block\n    for (let i = 0, iMax = maxBlock + 1; i < iMax; ++i) {\n      this.setDeclaration(\n        declarations,\n        `block${i}`,\n        `attribute ${sizeToType[InstanceAttributeSize.FOUR]} block${i};\\n`,\n        debugCtx\n      );\n    }\n\n    return \"\";\n  }\n\n  /**\n   * Produces the vertex attributes without any bias or modification.\n   */\n  private processVertexAttributes(\n    declarations: ShaderDeclarationStatements,\n    vertexAttributes: IVertexAttribute[]\n  ) {\n    // No matter what, vertex attributes listed are strictly vertex attributes\n    vertexAttributes.forEach(attribute => {\n      this.setDeclaration(\n        declarations,\n        attribute.name,\n        `attribute ${sizeToType[attribute.size]} ${attribute.qualifier ||\n          \"\"}${(attribute.qualifier && \" \") || \"\"}${attribute.name};\\n`,\n        debugCtx\n      );\n    });\n\n    return \"\";\n  }\n}\n","import { Instance } from \"../../../instance-provider\";\nimport { AutoEasingLoopStyle } from \"../../../math/auto-easing-method\";\nimport { Vec, VecMath, VecMethods } from \"../../../math/vector\";\nimport {\n  ShaderDeclarationStatements,\n  ShaderIOHeaderInjectionResult\n} from \"../../../shaders/processing/base-shader-io-injection\";\nimport { MetricsProcessing } from \"../../../shaders/processing/metrics-processing\";\nimport { ILayerProps, Layer } from \"../../../surface/layer\";\nimport {\n  FrameMetrics,\n  IEasingInstanceAttribute,\n  IEasingProps,\n  IInstanceAttribute,\n  InstanceAttributeSize,\n  InstanceIOValue,\n  IUniform,\n  IVertexAttribute,\n  ShaderInjectionTarget\n} from \"../../../types\";\nimport { EasingProps } from \"../../../util/easing-props\";\nimport {\n  IShaderTemplateRequirements,\n  shaderTemplate\n} from \"../../../util/shader-templating\";\nimport { BaseIOExpansion, ShaderIOExpansion } from \"../base-io-expansion\";\n\nconst debugCtx = \"EasingIOExpansion\";\n\nconst { abs, max } = Math;\n\nconst BLANK_EASING_PROPS: IEasingProps = {\n  duration: 0,\n  start: [0],\n  end: [0],\n  startTime: 0\n};\n\n/** Converts a size to a shader type */\nconst sizeToType: { [key: number]: string } = {\n  1: \"float\",\n  2: \"vec2\",\n  3: \"vec3\",\n  4: \"vec4\",\n  9: \"mat3\",\n  16: \"mat4\",\n  /** This is the special case for instance attributes that want an atlas resource */\n  99: \"vec4\"\n};\n\n/**\n * These are the templating names used within Auto Easing gpu methods\n */\nconst templateVars = {\n  easingMethod: \"easingMethod\",\n  T: \"T\"\n};\n\n/**\n * Tests an attribute to see if it is an easing attribute\n */\nfunction isEasingAttribute<T extends Instance>(\n  attr: any\n): attr is IEasingInstanceAttribute<T> {\n  return (\n    Boolean(attr) && attr.easing && attr.size !== undefined && attr.size <= 4\n  );\n}\n\n/**\n * This is an expansion handler for easing attributes.\n */\nexport class EasingIOExpansion extends BaseIOExpansion {\n  /** This is used to make it easy to remember an easing attribute's original name */\n  private baseAttributeName = new Map<IInstanceAttribute<Instance>, string>();\n\n  /**\n   * Provides expanded IO for attributes with easing properties.\n   *\n   * Most of this process is hijacking the existing easing attribute to inject it's own\n   * update method to handle calculating current position to animate to a new position\n   * when a value is changed.\n   *\n   * This also provides new child attributes that must be changed when the original attributes\n   * value is changed.\n   */\n  expand<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>,\n    instanceAttributes: IInstanceAttribute<T>[],\n    _vertexAttributes: IVertexAttribute[],\n    _uniforms: IUniform[]\n  ): ShaderIOExpansion<T> {\n    const usedInstanceAttributes = new Set<number>();\n    const easingAttributes: IEasingInstanceAttribute<T>[] = [];\n    const newAttributes: IInstanceAttribute<T>[] = [];\n\n    // We gather all of the easing attributes first so we can modify the attribute array\n    // On next pass\n    for (const attribute of instanceAttributes) {\n      if (isEasingAttribute(attribute)) {\n        easingAttributes.push(attribute);\n      }\n    }\n\n    const easingIds: { [key: string]: number } = {};\n    layer.easingId = easingIds;\n\n    // Now loop through each easing attribute and generate attributes needed for the easing method\n    for (let i = 0, iMax = easingAttributes.length; i < iMax; ++i) {\n      const attribute = easingAttributes[i];\n      const { cpu: easing, loop, uid: providedUID } = attribute.easing;\n      const { name, size, update } = attribute;\n      const easingUID = providedUID;\n\n      // The attribute that is the primary attribute that declares the easing attribute\n      // will become the \"_end\" attribute as whenever it is set, it will change the\n      // destination value of the easing method.\n      this.baseAttributeName.set(attribute, attribute.name);\n      attribute.name = `_${attribute.name}_end`;\n\n      // Make our easing ID lookup so instances can access their easing information for higher level\n      // animation control.\n      easingIds[attribute.name] = easingUID;\n\n      // Ensure the AutoEasing method is unique\n      if (usedInstanceAttributes.has(easingUID)) {\n        console.error(\n          \"Undefined behavior occurs if you reuse an IAutoEasingMethod. Please ensure you are using uid() from the util to give the IAutoEasingMethod its uid, or just use the default provided methods\"\n        );\n      }\n\n      // Flag the uid of the easing method as used\n      usedInstanceAttributes.add(easingUID);\n      // We keep this in a scope above the update as we utilize the fact that the attributes will update\n      // In the order they are declared for a single instance. The attributes will all share this information.\n      const attributeDataShare: { values: IEasingProps } = {\n        values: BLANK_EASING_PROPS\n      };\n\n      // Remove declaring any variables within the scope of the update method for speed\n      let delay: number,\n        attributeDelay: number,\n        attributeDuration: number,\n        duration: number,\n        easingValues: IEasingProps,\n        timeValue: number,\n        end: InstanceIOValue,\n        currentTime: number,\n        frameMetrics: FrameMetrics,\n        values: IEasingProps | undefined,\n        vecMethods: VecMethods<Vec>,\n        instanceEasing: Map<number, IEasingProps>,\n        isContinuous: boolean;\n\n      // Hijack the update from the attribute to a new update method which will\n      // Be able to interact with the values for the easing methodology\n      attribute.update = instance => {\n        frameMetrics = layer.surface.frameMetrics;\n        // We retrieve properties that we want to be dynamic from the easing equation\n        attributeDelay = attribute.easing.delay;\n        attributeDuration = attribute.easing.duration;\n        // First get the value that is to be our new destination\n        end = update(instance);\n        currentTime = frameMetrics.currentTime;\n        // Get the easing values specific to an instance.\n        instance.easing = instanceEasing = instance.easing || new Map();\n        values = instanceEasing.get(easingUID);\n\n        // If the easing values do not exist yet, make them now\n        if (!vecMethods || !values) {\n          // Get all of the vector methods that apply to the provided item\n          vecMethods = VecMath(end);\n\n          values = new EasingProps({\n            duration: attributeDuration,\n            end: vecMethods.copy(end),\n            start: vecMethods.copy(end),\n            startTime: currentTime\n          });\n\n          // Make sure the instance contains the current easing values\n          instanceEasing.set(easingUID, values);\n        }\n\n        // On instance reactivation we want the easing to just be at it's end value\n        else if (instance.reactivate) {\n          vecMethods.copy(end, values.end);\n          vecMethods.copy(end, values.end);\n          values.startTime = currentTime;\n        }\n\n        // Assign the established values\n        easingValues = values;\n        duration = attributeDuration;\n        delay = attributeDelay;\n\n        if (easingValues.isTimeSet) {\n          duration = easingValues.duration || attributeDuration;\n          delay = easingValues.delay || 0;\n        }\n\n        if (!easingValues.isManualStart) {\n          // Previous position time value\n          timeValue = 1;\n\n          switch (loop) {\n            // Continuous means we start at 0 and let the time go to infinity\n            case AutoEasingLoopStyle.CONTINUOUS:\n              timeValue = (currentTime - easingValues.startTime) / duration;\n              isContinuous = true;\n              break;\n\n            // Repeat means going from 0 to 1 then 0 to 1 etc etc\n            case AutoEasingLoopStyle.REPEAT:\n              timeValue =\n                ((currentTime - easingValues.startTime) / duration) % 1;\n              isContinuous = true;\n              break;\n\n            // Reflect means going from 0 to 1 then 1 to 0 then 0 to 1 etc etc\n            case AutoEasingLoopStyle.REFLECT:\n              const timePassed =\n                (currentTime - easingValues.startTime) / duration;\n              // This is a triangle wave for an input\n              timeValue = abs(((timePassed / 2.0) % 1) - 0.5) * 2.0;\n              isContinuous = true;\n              break;\n\n            // No loop means just linear time\n            case AutoEasingLoopStyle.NONE:\n            default:\n              timeValue = (currentTime - easingValues.startTime) / duration;\n              isContinuous = false;\n              break;\n          }\n\n          // Now get the value of where our instance currently is located this frame\n          easingValues.start = easing(\n            easingValues.start,\n            easingValues.end,\n            timeValue,\n            easingValues.start\n          );\n        }\n\n        // Set the current time as the start time of our animation\n        easingValues.startTime = currentTime + delay;\n        // Set the provided value as our destination\n        vecMethods.copy(end, easingValues.end);\n        // Update the information shared between this attribute and it's children\n        attributeDataShare.values = easingValues;\n\n        // Set the layer's animation end time\n        layer.animationEndTime = max(\n          layer.animationEndTime,\n          easingValues.startTime + duration + frameMetrics.frameDuration\n        );\n\n        // Flag the layer's continuous animation so continuous easing loop styles will keep rendering indefinitely\n        layer.isAnimationContinuous = isContinuous;\n\n        return end;\n      };\n\n      // The attribute is going to generate some child attributes\n      // Making the additional attributes children of this attribute\n      // will force them to update when the parent attribute is updated.\n      attribute.childAttributes = attribute.childAttributes || [];\n\n      // Attribute for the start value of the animation\n      const startAttr: IInstanceAttribute<T> = {\n        name: `_${name}_start`,\n        parentAttribute: attribute,\n        size,\n        update: _o => attributeDataShare.values.start\n      };\n\n      attribute.childAttributes.push(startAttr);\n      newAttributes.push(startAttr);\n\n      // Attribute for the starting time of the animation\n      const startTimeAttr: IInstanceAttribute<T> = {\n        name: `_${name}_start_time`,\n        parentAttribute: attribute,\n        size: InstanceAttributeSize.ONE,\n        update: _o => [attributeDataShare.values.startTime]\n      };\n\n      attribute.childAttributes.push(startTimeAttr);\n      newAttributes.push(startTimeAttr);\n\n      // Attribute for how long the animation will run\n      const durationAttr: IInstanceAttribute<T> = {\n        name: `_${name}_duration`,\n        parentAttribute: attribute,\n        size: InstanceAttributeSize.ONE,\n        update: _o => [attributeDataShare.values.duration]\n      };\n\n      attribute.childAttributes.push(durationAttr);\n      newAttributes.push(durationAttr);\n    }\n\n    // Return all of the new attributes to work with\n    return {\n      instanceAttributes: newAttributes,\n      vertexAttributes: [],\n      uniforms: []\n    };\n  }\n\n  /**\n   * Validates the IO about to be expanded.\n   */\n  validate<T extends Instance, U extends ILayerProps<T>>(\n    _layer: Layer<T, U>,\n    instanceAttributes: IInstanceAttribute<T>[],\n    _vertexAttributes: IVertexAttribute[],\n    _uniforms: IUniform[]\n  ): boolean {\n    let foundError = false;\n\n    instanceAttributes.forEach(attribute => {\n      if (attribute.easing && attribute.resource) {\n        console.warn(\n          \"An instance attribute can not have both easing and resource properties. Undefined behavior will occur.\"\n        );\n        console.warn(attribute);\n\n        foundError = true;\n      }\n\n      if (attribute.easing) {\n        if (attribute.size === undefined) {\n          console.warn(\n            \"An Instance Attribute with easing MUST have a size declared\"\n          );\n        }\n      }\n    });\n\n    return !foundError;\n  }\n\n  /**\n   * Easing provides some unique destructuring for the packed in vertex information.\n   */\n  processAttributeDestructuring(\n    _layer: Layer<Instance, ILayerProps<Instance>>,\n    declarations: ShaderDeclarationStatements,\n    _metrics: MetricsProcessing,\n    _vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<Instance>[],\n    _uniforms: IUniform[]\n  ): string {\n    // We analyze our instance attributes for easing attributes. When we find an attribute with\n    // easing, we can make a quick assumption about the names of attributes provided that we can easily\n    // use to destructure a properly named attribute that contains the correct algorithm to produce\n    // the specified easing for the attribute.\n    const out = \"\";\n\n    for (let i = 0, iMax = instanceAttributes.length; i < iMax; ++i) {\n      const attribute = instanceAttributes[i];\n\n      // If this is the source easing attribute, we must add it in as an eased method along with a calculation for the\n      // Easing interpolation time value based on the current time and the injected start time of the change.\n      if (!attribute.easing || !attribute.size) continue;\n      // Get the base name of the attribute since the original name gets changed for the expansion process.\n      const baseName = this.baseAttributeName.get(attribute);\n\n      if (!baseName) {\n        console.warn(\n          \"Could not determine a base name for an easing attribute.\"\n        );\n        continue;\n      }\n\n      // Clear the basename out as it's only needed for this operation.\n      this.baseAttributeName.delete(attribute);\n\n      // We first write in the time calculation based on the loop style of the easing method\n      const time = `_${baseName}_time`;\n      const duration = `_${baseName}_duration`;\n      const startTime = `_${baseName}_start_time`;\n\n      switch (attribute.easing.loop) {\n        // Continuous means letting the time go from 0 to infinity\n        case AutoEasingLoopStyle.CONTINUOUS: {\n          this.setDeclaration(\n            declarations,\n            time,\n            `  float ${time} = (currentTime - ${startTime}) / ${duration};\\n`,\n            debugCtx\n          );\n          break;\n        }\n\n        // Repeat means going from 0 to 1 then 0 to 1 etc etc\n        case AutoEasingLoopStyle.REPEAT: {\n          this.setDeclaration(\n            declarations,\n            time,\n            `  float ${time} = clamp(fract((currentTime - ${startTime}) / ${duration}), 0.0, 1.0);\\n`,\n            debugCtx\n          );\n          break;\n        }\n\n        // Reflect means going from 0 to 1 then 1 to 0 then 0 to 1 etc etc\n        case AutoEasingLoopStyle.REFLECT: {\n          const timePassed = `_${baseName}_timePassed`;\n          const pingPong = `_${baseName}_pingPong`;\n\n          // Get the time passed in a linear fashion\n          this.setDeclaration(\n            declarations,\n            timePassed,\n            `  float ${timePassed} = (currentTime - ${startTime}) / ${duration};\\n`,\n            debugCtx\n          );\n          // Make a triangle wave from the time passed to ping pong the value\n          this.setDeclaration(\n            declarations,\n            pingPong,\n            `  float ${pingPong} = abs((fract(${timePassed} / 2.0)) - 0.5) * 2.0;\\n`,\n            debugCtx\n          );\n          // Ensure we're clamped to the right values\n          this.setDeclaration(\n            declarations,\n            time,\n            `  float ${time} = clamp(${pingPong}, 0.0, 1.0);\\n`,\n            debugCtx\n          );\n          break;\n        }\n\n        // No loop means just linear time\n        case AutoEasingLoopStyle.NONE:\n        default: {\n          this.setDeclaration(\n            declarations,\n            time,\n            `  float ${time} = clamp((currentTime - ${startTime}) / ${duration}, 0.0, 1.0);\\n`,\n            debugCtx\n          );\n          break;\n        }\n      }\n\n      // After the time calculation we inject the actual easing equation to calculate the value needed\n      // for the attribute in the shader\n      this.setDeclaration(\n        declarations,\n        baseName,\n        `  ${sizeToType[attribute.size]} ${baseName} = ${\n          attribute.easing.methodName\n        }(_${baseName}_start, _${baseName}_end, _${baseName}_time);\\n`,\n        debugCtx\n      );\n    }\n\n    return out;\n  }\n\n  /**\n   * For easing, the header must be populated with the easing method\n   */\n  processHeaderInjection(\n    target: ShaderInjectionTarget,\n    declarations: ShaderDeclarationStatements,\n    _layer: Layer<Instance, ILayerProps<Instance>>,\n    _metrics: MetricsProcessing,\n    _vertexAttributes: IVertexAttribute[],\n    instanceAttributes: IInstanceAttribute<Instance>[],\n    _uniforms: IUniform[]\n  ): ShaderIOHeaderInjectionResult {\n    const out = { injection: \"\" };\n\n    // Easing equations are only applicable to the vertex shader where attribute destructuring happens\n    if (target !== ShaderInjectionTarget.VERTEX) return out;\n\n    const methods = new Map<string, Map<InstanceAttributeSize, string>>();\n    out.injection = \"// Auto Easing Methods specified by the layer\\n\";\n\n    // First dedupe the methods needed by their method name\n    instanceAttributes.forEach(attribute => {\n      if (attribute.easing && attribute.size) {\n        let methodSizes = methods.get(attribute.easing.methodName);\n\n        if (!methodSizes) {\n          methodSizes = new Map<InstanceAttributeSize, string>();\n          methods.set(attribute.easing.methodName, methodSizes);\n        }\n\n        methodSizes.set(attribute.size, attribute.easing.gpu);\n      }\n    });\n\n    if (methods.size === 0) {\n      out.injection = \"\";\n      return out;\n    }\n\n    const required: IShaderTemplateRequirements = {\n      name: \"Easing Method Generation\",\n      values: [templateVars.easingMethod]\n    };\n\n    // Now generate the full blown method for each element. We create overloaded methods for\n    // Each method name for each vector size required\n    methods.forEach(\n      (methodSizes: Map<InstanceAttributeSize, string>, methodName: string) => {\n        methodSizes.forEach((method, size) => {\n          const sizeType = sizeToType[size];\n\n          const templateOptions: { [key: string]: string } = {\n            [templateVars.easingMethod]: `${sizeType} ${methodName}(${sizeType} start, ${sizeType} end, float t)`,\n            [templateVars.T]: `${sizeType}`\n          };\n\n          const results = shaderTemplate({\n            options: templateOptions,\n            required,\n            shader: method\n          });\n\n          this.setDeclaration(\n            declarations,\n            `${sizeType} ${methodName}`,\n            `${results.shader}\\n`,\n            debugCtx\n          );\n        });\n      }\n    );\n\n    return out;\n  }\n}\n","/**\n * The purpose of this file and processes is to take a layers attributes and\n * instance attributes and optimally pack them into blocks. As it should be known\n * an attribute and a uniform is limited by the hardware in 'blocks'. Each block\n * for webgl 1.0 is 4 floats. If you use a single float and not the rest, you have\n * used an entire block.\n *\n * Thus, we pack down the attributes into appropriate block indices and slots.\n */\n\nimport { Instance } from \"../../instance-provider/instance\";\nimport { IInstanceAttribute, InstanceAttributeSize } from \"../../types\";\n\n/**\n * A quick representation of an available block with a convenience method to easily apply\n * metrics to an attribute if it fits.\n */\nclass Block<T extends Instance> {\n  index: number = 0;\n  available: number = 4;\n\n  constructor(blockIndex: number) {\n    this.index = blockIndex;\n  }\n\n  setAttribute(attr: IInstanceAttribute<T>) {\n    if ((attr.size || 0) <= this.available) {\n      attr.block = this.index;\n      attr.blockIndex = 4 - this.available;\n      this.available -= attr.size || 0;\n\n      return true;\n    }\n\n    return false;\n  }\n}\n\n/**\n * This loops through all attributes and ensures each attribute is applied\n */\nfunction ensureSizes<T extends Instance>(attributes: IInstanceAttribute<T>[]) {\n  attributes.forEach(attr => {\n    if (attr.resource && attr.size === undefined) {\n      attr.size = InstanceAttributeSize.FOUR;\n    }\n\n    // If the size of the attribute is not determiend at this point, we do our best\n    // to find it by whatever means possible\n    if (!attr.size) {\n      try {\n        // We inject a very phoney instance, we don't need accurate data, we will be happy if we get\n        // an array of undefineds which should be in line with the size of the attribute.\n        const check = attr.update(new Instance({}) as T);\n\n        // We see if the output is sane\n        if (check.length > 0 && check.length <= InstanceAttributeSize.FOUR) {\n          attr.size = check.length;\n        }\n      } catch (err) {\n        console.warn(\n          \"The system could not determine the size of the provided attribute. Please provide the size of the attribute:\",\n          attr\n        );\n      }\n    }\n  });\n}\n\n/**\n * This is the packing method that calculates the block and block index best suited for an attribute\n * so a layer developer does not have to worry about it.\n */\nexport function packAttributes<T extends Instance>(\n  attributes: IInstanceAttribute<T>[]\n) {\n  // First make sure each attribute has a size\n  ensureSizes(attributes);\n  // Keep a list of the blocks we have decided needs to be in use\n  const blocks: Block<T>[] = [];\n\n  // Loop through all attributes and pack em' in\n  attributes.forEach(attr => {\n    // A matrix 4x4 is a special case where it requires 4 consecutive blocks to work correctly\n    if (attr.size && attr.size === InstanceAttributeSize.MAT4X4) {\n      attr.block = blocks.length;\n      attr.blockIndex = 0;\n\n      // We know any block that gets created instantly receives some content. Thus we know to fit the matrix\n      // we need to simply immediately create 4 blocks.\n      for (let i = 0; i < 4; ++i) {\n        const newBlock = new Block(blocks.length);\n        newBlock.available = 0;\n        newBlock.index = 0;\n        blocks.push(newBlock);\n      }\n\n      return;\n    }\n\n    // Look for a block that can fit our attribute\n    const block = blocks.find(block => {\n      if (block.setAttribute(attr)) {\n        return Boolean(block);\n      }\n\n      return false;\n    });\n\n    // If our attribute did not fit into any of the existing blocks, then we must create a new block\n    // to stuff our attribute into.\n    if (!block) {\n      const newBlock = new Block(blocks.length);\n      blocks.push(newBlock);\n\n      if (!newBlock.setAttribute(attr)) {\n        console.warn(\n          \"There was a problem packing an attribute into a block. No block would accommodate it:\",\n          attr\n        );\n      }\n    }\n  });\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport { BaseIOSorting } from \"../../surface/base-io-sorting\";\nimport { ILayerProps, Layer } from \"../../surface/layer\";\nimport { BaseIOExpansion } from \"../../surface/layer-processing/base-io-expansion\";\nimport { injectShaderIO } from \"../../surface/layer-processing/inject-shader-io\";\nimport {\n  IInstanceAttribute,\n  IInstancingUniform,\n  IShaderInitialization,\n  IShaders,\n  IUniformInternal,\n  IVertexAttributeInternal,\n  ShaderInjectionTarget\n} from \"../../types\";\nimport { shaderTemplate } from \"../../util/shader-templating\";\nimport { templateVars } from \"../template-vars\";\nimport { ShaderIOHeaderInjectionResult } from \"./base-shader-io-injection\";\nimport { MetricsProcessing } from \"./metrics-processing\";\nimport { ShaderModule } from \"./shader-module\";\nimport { ShaderModuleUnit } from \"./shader-module-unit\";\n\n/**\n * This is the expected results from processing the shader and it's layer's attributes.\n */\nexport interface IShaderProcessingResults<T extends Instance> {\n  /** The resulting fragment shader from processing the module */\n  fs: string;\n  /** Any additional system uniforms that arose from the processing */\n  materialUniforms: IInstancingUniform[];\n  /** Calculated max instances per buffer (mostly for uniform packing procedures) */\n  maxInstancesPerBuffer: number;\n  /** The modules that were included within the module processing */\n  modules: ShaderModuleUnit[];\n  /** The resulting vertex shader from processing the module */\n  vs: string;\n  /** All instance attributes that arise from module processing */\n  instanceAttributes: IInstanceAttribute<T>[];\n  /** All vertex attributes that arise from module processing */\n  vertexAttributes: IVertexAttributeInternal[];\n  /** All uniform attributes that arise from module processing */\n  uniforms: IUniformInternal[];\n}\n\n/** Expected results from processing shader imports */\nexport type ProcessShaderImportResults =\n  | (IShaders & { shaderModuleUnits: Set<ShaderModuleUnit> })\n  | null;\n\n/**\n * The intent of this processor is to analyze a layer's Shader IO elements and produce a functional\n * shader from those elements. This includes supporting a layer's capabilties with the client systems\n * capabilities and matching compatibilities.\n *\n * This inlcudes:\n *\n * Injecting needed module imports based on the layers specifications\n * Resolving Module imports and handling errors\n * Utilizing layer information to create attributes and uniforms based on attribute packing strategies\n * Destructuring attributes based on easing requirements or if attributes were packed\n * Swapping out miscellaneous template variables\n */\nexport class ShaderProcessor {\n  /** Processor that calculates shared metrics across all processors */\n  metricsProcessing: MetricsProcessing = new MetricsProcessing();\n\n  /**\n   * This processes a layer, it's Shader IO requirements, and it's shaders to produce a fully functional\n   * shader that is compatible with the client's system.\n   */\n  process<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>,\n    shaderIO: IShaderInitialization<T>,\n    ioExpansion: BaseIOExpansion[],\n    sortIO: BaseIOSorting\n  ): IShaderProcessingResults<T> | null {\n    try {\n      // First process imports to retrieve the requested IO the shader modules would be requiring\n      const shadersWithImports = this.processImports(layer, shaderIO);\n      if (!shadersWithImports) return null;\n\n      // After processing our imports, we can now fully aggregate the needed shader IO to make our layer\n      // operate properly. Process all of the attributes and apply IO expansion to all of the discovered\n      // shader IO the layer will need to execute.\n      const { vertexAttributes, instanceAttributes, uniforms } = injectShaderIO(\n        layer.surface.gl,\n        layer,\n        shaderIO,\n        ioExpansion,\n        sortIO,\n        shadersWithImports\n      );\n      // After all of the shader IO is established, let's calculate the appropriate buffering strategy\n      // For the layer.\n      layer.getLayerBufferType(\n        layer.surface.gl,\n        vertexAttributes,\n        instanceAttributes\n      );\n\n      // Calculate needed metrics that may be used by any of the processors\n      this.metricsProcessing.process(instanceAttributes, uniforms);\n\n      // We are going to gather headers for both vertex and fragment from our processors\n      let vsHeader = \"\";\n      let fsHeader = \"\";\n      // We will also gather the destructuring structure for the attributes from our processor\n      let destructuring = \"\";\n      // In processing, this may generate changes to the Material to accommodate features required\n      const materialChanges: ShaderIOHeaderInjectionResult[\"material\"] = {\n        uniforms: []\n      };\n\n      const vsHeaderDeclarations = new Map();\n      const fsHeaderDeclarations = new Map();\n      const destructureDeclarations = new Map();\n\n      // Loop through all of our processors that handle expanding all IO into headers for the shader\n      for (let i = 0, iMax = ioExpansion.length; i < iMax; ++i) {\n        const processor = ioExpansion[i];\n\n        // Generate vertex header declarations\n        const vsHeaderInfo = processor.processHeaderInjection(\n          ShaderInjectionTarget.VERTEX,\n          vsHeaderDeclarations,\n          layer,\n          this.metricsProcessing,\n          vertexAttributes,\n          instanceAttributes,\n          uniforms\n        );\n\n        vsHeader += vsHeaderInfo.injection;\n\n        if (vsHeaderInfo.material) {\n          materialChanges.uniforms = materialChanges.uniforms.concat(\n            vsHeaderInfo.material.uniforms || []\n          );\n        }\n\n        // Generate fragment header declarations\n        const fsHeaderInfo = processor.processHeaderInjection(\n          ShaderInjectionTarget.FRAGMENT,\n          fsHeaderDeclarations,\n          layer,\n          this.metricsProcessing,\n          vertexAttributes,\n          instanceAttributes,\n          uniforms\n        );\n\n        fsHeader += fsHeaderInfo.injection;\n\n        if (fsHeaderInfo.material) {\n          materialChanges.uniforms = materialChanges.uniforms.concat(\n            fsHeaderInfo.material.uniforms || []\n          );\n        }\n\n        // Destructure the elements\n        destructuring += processor.processAttributeDestructuring(\n          layer,\n          destructureDeclarations,\n          this.metricsProcessing,\n          vertexAttributes,\n          instanceAttributes,\n          uniforms\n        );\n      }\n\n      // After we have aggregated all of our declarations, we now piece them together\n      let declarations = \"\";\n\n      vsHeaderDeclarations.forEach(declaration => {\n        declarations += declaration;\n      });\n\n      vsHeader = declarations + vsHeader;\n      declarations = \"\";\n\n      fsHeaderDeclarations.forEach(declaration => {\n        declarations += declaration;\n      });\n\n      fsHeader = declarations + fsHeader;\n      declarations = \"\";\n\n      destructureDeclarations.forEach(declaration => {\n        declarations += declaration;\n      });\n\n      destructuring = declarations + destructuring;\n\n      // Create a default precision modifier for now\n      const precision = \"precision highp float;\\n\\n\";\n      // Now we concatenate the shader pieces into one glorious shader of compatibility and happiness\n      const fullShaderVS = precision + vsHeader + shadersWithImports.vs;\n      const fullShaderFS = precision + fsHeader + shadersWithImports.fs;\n\n      // Last we replace any templating variables with their relevant values\n      let templateOptions: { [key: string]: string } = {\n        [templateVars.attributes]: destructuring\n      };\n\n      // This flag will determine if the attributes are manually placed in the shader. If this is not true, then the\n      // attributes will get injected into the main() method.\n      let hasAttributes = false;\n\n      const processedShaderVS = shaderTemplate({\n        options: templateOptions,\n        required: undefined,\n        shader: fullShaderVS,\n\n        onToken(token: string, replace: string) {\n          if (token === templateVars.attributes) {\n            hasAttributes = true;\n          }\n\n          return replace;\n        },\n\n        onMain(body: string | null) {\n          if (hasAttributes) return body || \"\";\n\n          if (body === null) {\n            console.warn(\"The body of void main() could not be determined.\");\n            return \"\";\n          }\n\n          return `${destructuring}\\n${body}`;\n        }\n      });\n\n      // We process the Fragment shader as well, currently with nothing to replace\n      // aside from removing any superfluous template requests\n      templateOptions = {};\n\n      const processShaderFS = shaderTemplate({\n        options: templateOptions,\n        required: undefined,\n        shader: fullShaderFS\n      });\n\n      const results = {\n        fs: processShaderFS.shader.trim(),\n        materialUniforms: materialChanges.uniforms,\n        maxInstancesPerBuffer: this.metricsProcessing\n          .maxInstancesPerUniformBuffer,\n        modules: Array.from(shadersWithImports.shaderModuleUnits),\n        vs: processedShaderVS.shader.trim(),\n        vertexAttributes,\n        instanceAttributes,\n        uniforms\n      };\n\n      return results;\n    } catch (err) {\n      console.warn(\n        \"An unknown error occurred while processing the shaders for layer:\",\n        layer.id\n      );\n      console.warn(\"Error:\");\n      console.warn(err && (err.stack || err.message));\n      return null;\n    }\n  }\n\n  /**\n   * This applies the imports for the specified layer and generates the appropriate shaders from the output.\n   * Upon failure, this will just return null.\n   *\n   * This also does some additional work to add in some modules based on the layer's preferences\n   */\n  private processImports<T extends Instance, U extends ILayerProps<T>>(\n    layer: Layer<T, U>,\n    shaders: IShaderInitialization<T>\n  ): ProcessShaderImportResults {\n    const shaderModuleUnits = new Set<ShaderModuleUnit>();\n    let baseModules = layer.baseShaderModules(shaders);\n\n    if (layer.props.baseShaderModules) {\n      baseModules = layer.props.baseShaderModules(shaders, baseModules);\n    }\n\n    // Process imports for the vertex shader\n    const vs = ShaderModule.process(\n      layer.id,\n      shaders.vs,\n      ShaderInjectionTarget.VERTEX,\n      baseModules.vs\n    );\n\n    if (vs.errors.length > 0) {\n      console.warn(\n        \"Error processing imports for the vertex shader of layer:\",\n        layer.id,\n        \"Errors\",\n        ...vs.errors.reverse()\n      );\n\n      return null;\n    }\n\n    // Process imports for the fragment shader\n    const fs = ShaderModule.process(\n      layer.id,\n      shaders.fs,\n      ShaderInjectionTarget.FRAGMENT,\n      baseModules.fs\n    );\n\n    if (fs.errors.length > 0) {\n      console.warn(\n        \"Error processing imports for the fragment shader of layer:\",\n        layer.id,\n        \"Errors\",\n        ...fs.errors.reverse()\n      );\n\n      return null;\n    }\n\n    // Gather all discovered Shader Module Units\n    vs.shaderModuleUnits.forEach(moduleUnit =>\n      shaderModuleUnits.add(moduleUnit)\n    );\n    fs.shaderModuleUnits.forEach(moduleUnit =>\n      shaderModuleUnits.add(moduleUnit)\n    );\n\n    return {\n      fs: fs.shader || \"\",\n      vs: vs.shader || \"\",\n      shaderModuleUnits\n    };\n  }\n}\n","export const templateVars = {\n  attributes: \"attributes\",\n  easingMethod: \"easingMethod\",\n  extend: \"extend\",\n  extendHeader: \"extendHeader\",\n  T: \"T\"\n};\n","import { WebGLStat } from \"../../gl/webgl-stat\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport { IInstanceAttribute, IUniform } from \"../../types\";\n\n/**\n * This handles processing some metrics that are commonly needed by other processors.\n */\nexport class MetricsProcessing {\n  /** This is an instance's max listed block */\n  instanceMaxBlock: number;\n  /** This is the number of blocks each instance will use */\n  blocksPerInstance: number;\n  /** This is how many uniform blocks the current device can utilize in a shader */\n  maxUniforms: number;\n  /** This reflects how many uniform blocks are available for instancing */\n  maxUniformsForInstancing: number;\n  /** Get the number of instances the client's system supports specifically for uniform instancing */\n  maxInstancesPerUniformBuffer: number;\n  /** This is the total blocks to be used in our uniform buffer for handling instances */\n  totalInstanceUniformBlocks: number;\n\n  /**\n   * This calculates how many uniform blocks are utilized based on the input uniforms\n   */\n  static calculateUniformBlockUseage(uniforms: IUniform[]) {\n    let count = 0;\n\n    for (let i = 0, end = uniforms.length; i < end; ++i) {\n      count += Math.ceil(uniforms[i].size / 4);\n    }\n\n    return count;\n  }\n\n  /**\n   * Calculates all of the metrics that will be needed in this processor.\n   */\n  process<T extends Instance>(\n    instanceAttributes: IInstanceAttribute<T>[],\n    uniforms: IUniform[]\n  ) {\n    this.instanceMaxBlock = 0;\n\n    // First find the max block to be utilized\n    instanceAttributes.forEach(attribute => {\n      this.instanceMaxBlock = Math.max(\n        this.instanceMaxBlock,\n        attribute.block || 0\n      );\n    });\n\n    this.blocksPerInstance = this.instanceMaxBlock + 1;\n    this.maxUniforms = WebGLStat.MAX_VERTEX_UNIFORMS;\n    this.maxUniformsForInstancing =\n      this.maxUniforms -\n      MetricsProcessing.calculateUniformBlockUseage(uniforms);\n    this.maxInstancesPerUniformBuffer = Math.floor(\n      this.maxUniformsForInstancing / this.blocksPerInstance\n    );\n    this.totalInstanceUniformBlocks =\n      this.maxInstancesPerUniformBuffer * this.blocksPerInstance;\n  }\n}\n","export * from \"./buffer-manager-base\";\nexport * from \"./instance-attribute-buffering/instance-attribute-buffer-manager\";\nexport * from \"./instance-attribute-packed-buffering/instance-attribute-packing-buffer-manager\";\nexport * from \"./uniform-buffering/uniform-buffer-manager\";\n","\"use strict\";\n\nimport { Attribute, Geometry, Material, Model } from \"../../../gl\";\nimport { Instance, ObservableMonitoring } from \"../../../instance-provider\";\nimport {\n  IInstanceAttribute,\n  IInstanceAttributeInternal,\n  InstanceDiffType\n} from \"../../../types\";\nimport { emitOnce, flushEmitOnce } from \"../../../util/emit-once\";\nimport { uid } from \"../../../util/uid\";\nimport { Layer } from \"../../layer\";\nimport { generateLayerModel } from \"../../layer-processing/generate-layer-model\";\nimport { LayerScene } from \"../../layer-scene\";\nimport {\n  BufferManagerBase,\n  IBufferLocation,\n  IBufferLocationGroup\n} from \"../buffer-manager-base\";\n\nconst debug = require(\"debug\")(\"performance\");\nconst { max } = Math;\n\n/**\n * This represents the location of data for an instance's property to the piece of attribute buffer\n * it will update when it changes.\n */\nexport interface IInstanceAttributeBufferLocation extends IBufferLocation {\n  /** We narrow the buffer type for instance attributes down to just array buffers */\n  buffer: {\n    value: Float32Array | Uint8Array;\n  };\n\n  /** We narrow the chaild locations to be the same as this buffer location */\n  childLocations?: IInstanceAttributeBufferLocation[];\n}\n\n/** Represents the Location Groupings for Instance attribute Buffer locations */\nexport type IInstanceAttributeBufferLocationGroup = IBufferLocationGroup<\n  IInstanceAttributeBufferLocation\n>;\n\n/**\n * Typeguard for the instance attribute buffer location.\n */\nexport function isInstanceAttributeBufferLocation(\n  val: IBufferLocation\n): val is IInstanceAttributeBufferLocation {\n  return Boolean(val && val.buffer && val.buffer.value);\n}\n\n/**\n * This manages instances in how they associate with buffer data for an instanced attribute strategy.\n */\nexport class InstanceAttributeBufferManager<\n  T extends Instance\n> extends BufferManagerBase<T, IInstanceAttributeBufferLocation> {\n  /** This stores an attribute's name to the buffer locations generated for it */\n  private allBufferLocations: { [key: string]: IBufferLocation[] } = {};\n  /** This contains the buffer locations the system will have available */\n  private availableLocations: IInstanceAttributeBufferLocationGroup[] = [];\n  /** This is the number of instances the buffer draws currently */\n  currentInstancedCount = 0;\n  /** This is the mapped buffer location to the provided Instance */\n  private instanceToBufferLocation: {\n    [key: number]: IInstanceAttributeBufferLocationGroup;\n  } = {};\n  /** This is the number of instances the buffer currently supports */\n  private maxInstancedCount: number = 0;\n\n  // These are the only GL objects that must be monitored for disposal\n  private geometry?: Geometry;\n  private material?: Material;\n  private model?: Model;\n  private attributes?: IInstanceAttributeInternal<T>[];\n\n  /** This is a mapping of all attributes to their associated property ids that, when the property changes, the attribute will be updated */\n  private attributeToPropertyIds = new Map<IInstanceAttribute<T>, number[]>();\n  /**\n   * This is a trimmed listing of minimum property ids needed to trigger an update on all properties.\n   * This is used by the diffing process mostly to handle adding a new instance.\n   */\n  private updateAllPropertyIdList: number[] = [];\n  /**\n   * This is the discovered property id of the active attribute for the instance type this manager manages.\n   * This is used by the diffing process to target updates related to deactivating an instance.\n   */\n  private activePropertyId: number = -1;\n  /**\n   * As changes are processed, instances will be added into the buffers. As they are added in, the instance\n   * will take over available locations within the buffer. Normally we would have these available locations\n   * in a queue and we would push and shift into that queue to retrieve the locations; however, shifting queues\n   * when done in VERY large quantities causes javascript to lag horrendously. Thus we instead have this index\n   * to monitor the next available item to pull during processing changes. AFTER changes have been processed\n   * we perform a one time operation splice to delete any list of available locations that have been used. This\n   * GREATLY improves performance for these types of operations.\n   */\n  private currentAvailableLocation: number = -1;\n\n  constructor(layer: Layer<T, any>, scene: LayerScene) {\n    super(layer, scene);\n    // Start our add method as a registration step.\n    this.add = this.doAddWithRegistration;\n  }\n\n  /**\n   * This is the tail end of processing changes and lets us clean up anything that might have been used to aid in the\n   * processing.\n   */\n  changesProcessed() {\n    super.changesProcessed();\n    // Clean out available locations that have been consumed during processing changes\n    this.availableLocations.splice(0, this.currentAvailableLocation + 1);\n    // All elements in the availableLocations buffer are now valid locations so we reset this index back to the\n    // beginning which is -1 since our loop iterates with it using ++currentAvailableLocation.\n    this.currentAvailableLocation = -1;\n  }\n\n  /**\n   * First instance to be added to this manager will be heavily analyzed for used observables per attribute.\n   */\n  private doAddWithRegistration(instance: T) {\n    // We need to find out how an instance interacts with the attributes, so we will\n    // loop through the instances, call their updates and get feedback\n    this.layer.shaderIOInfo.instanceAttributes.forEach(attribute => {\n      // We don't need to register child attributes as they get updated as a consequence to parent attributes\n      if (attribute.parentAttribute) return;\n      // Activate monitoring of ids, this also resets the monitor's list\n      ObservableMonitoring.setObservableMonitor(true);\n      // Access the update which accesses an instances properties (usually)\n      attribute.update(instance);\n      // We now have all of the ids of the properties that were used in updating the attributes\n      const propertyIdsForAttribute = ObservableMonitoring.getObservableMonitorIds(\n        true\n      );\n      // Store the mapping of the property ids\n      this.attributeToPropertyIds.set(attribute, propertyIdsForAttribute);\n\n      // If this is the active attribute, then we track the property id that modifies it\n      // for handling internal instance management.\n      if (attribute === this.layer.shaderIOInfo.activeAttribute) {\n        this.activePropertyId = propertyIdsForAttribute[0];\n      }\n    });\n\n    // SUPER IMPORTANT to deactivate this here. Leaving this turned on causes memory to be chewed up\n    // for every property getter.\n    ObservableMonitoring.setObservableMonitor(false);\n    // This analyzes the properties and how they affect the attributes. It determines the smallest\n    // list possible of property ids needed to trigger an update on all of the attributes.\n    this.makeUpdateAllPropertyIdList();\n    // Do the first resize which creates the buffer and makes all of the initial buffer locations\n    const locationInfo = this.resizeBuffer();\n    // After all of the property id to attribute associations are made, we must break down the buffers\n    // into locations and then group those locations which will become our instance to buffer location\n    // slots\n    this.gatherLocationsIntoGroups(\n      locationInfo.newLocations,\n      locationInfo.growth\n    );\n    // After the first registration add, we gear shift to a more efficient add method.\n    this.add = this.doAdd;\n\n    // Perform the add after all of the registration process is complete\n    return this.doAdd(instance);\n  }\n\n  /**\n   * After the registration add happens, we gear shift over to this add method which will only pair instances\n   * with their appropriate buffer location.\n   */\n  private doAdd(instance: T) {\n    // Ensure we have buffer locations available\n    if (\n      this.availableLocations.length <= 0 ||\n      this.currentAvailableLocation >= this.availableLocations.length - 1\n    ) {\n      // Resice the buffer to accommodate more instances\n      const locationInfo = this.resizeBuffer();\n      // Break down the newly generated buffers into property groupings for the instances\n      this.gatherLocationsIntoGroups(\n        locationInfo.newLocations,\n        locationInfo.growth\n      );\n    }\n\n    // Get the next available location\n    const bufferLocations = this.availableLocations[\n      ++this.currentAvailableLocation\n    ];\n\n    // Pair up the instance with it's buffer location\n    if (bufferLocations && this.geometry) {\n      this.instanceToBufferLocation[instance.uid] = bufferLocations;\n      this.currentInstancedCount = this.geometry.maxInstancedCount = max(\n        this.currentInstancedCount,\n        // Instance index + 1 because the indices are zero indexed and the maxInstancedCount is a count value\n        bufferLocations.instanceIndex + 1\n      );\n\n      if (this.model) {\n        this.model.vertexDrawRange = [\n          0,\n          this.layer.shaderIOInfo.instanceVertexCount\n        ];\n        this.model.drawInstances = this.currentInstancedCount;\n\n        if (this.layer.shaderIOInfo.instanceVertexCount === 0) {\n          this.model.vertexDrawRange[1] = this.model.drawInstances;\n        }\n      }\n    } else {\n      console.error(\n        \"Add Error: Instance Attribute Buffer Manager failed to pair an instance with a buffer location\"\n      );\n    }\n\n    return bufferLocations;\n  }\n\n  /**\n   * Free any buffer and material resources this is managing.\n   */\n  destroy() {\n    if (this.geometry) this.geometry.dispose();\n    if (this.material) this.material.dispose();\n\n    if (this.scene && this.scene.container && this.model) {\n      this.scene.container.remove(this.model);\n    }\n  }\n\n  /**\n   * This retireves the buffer locations associated with an instance, or returns nothing\n   * if the instance has not been associated yet.\n   */\n  getBufferLocations(instance: T) {\n    return this.instanceToBufferLocation[instance.uid];\n  }\n\n  /**\n   * This is the property id of the active attribute.\n   */\n  getActiveAttributePropertyId() {\n    return this.activePropertyId;\n  }\n\n  /**\n   * This is the bare minimum property ids that, when triggered for update, will update ALL of the attribute buffers\n   * for the managed layer.\n   */\n  getUpdateAllPropertyIdList() {\n    return this.updateAllPropertyIdList;\n  }\n\n  /**\n   * Checks to see if an instance is managed by this manager.\n   */\n  managesInstance(instance: T) {\n    // We know this instance is managed if the instance has buffer location real estate assigned to it\n    return this.instanceToBufferLocation[instance.uid] !== undefined;\n  }\n\n  /**\n   * Analyzes the list of attributes to the property ids that affects them. This populates the list\n   * of minimal property ids needed to trigger updates on all of the attributes.\n   */\n  private makeUpdateAllPropertyIdList() {\n    // Make a deduping list of ids\n    const updateAllPropertyIdList: { [key: number]: number } = {};\n\n    // Get unique ids that will target all attributes\n    this.attributeToPropertyIds.forEach(ids => {\n      updateAllPropertyIdList[ids[0]] = ids[0];\n    });\n\n    // Store the list for the diffing process to utilize\n    this.updateAllPropertyIdList = Object.values(\n      updateAllPropertyIdList\n    ).filter(Boolean);\n  }\n\n  /**\n   * Disassociates an instance with a buffer\n   */\n  remove = (instance: T) => {\n    const location = this.instanceToBufferLocation[instance.uid];\n\n    if (location) {\n      delete this.instanceToBufferLocation[instance.uid];\n      this.availableLocations.push(location);\n    }\n\n    return instance;\n  };\n\n  /**\n   * Clears all elements of this manager from the current scene it was in.\n   */\n  removeFromScene() {\n    if (this.scene && this.scene.container && this.model) {\n      this.scene.container.remove(this.model);\n    }\n\n    delete this.scene;\n  }\n\n  /**\n   * This generates a new buffer of uniforms to associate instances with.\n   */\n  private resizeBuffer() {\n    // Get the shader io information from the layer to reduce deep references\n    const shaderIOInfo = this.layer.shaderIOInfo;\n    // This stores how much the buffer will be able to regrow\n    let growth = 0;\n    // Each attribute will generate lists of new buffer locations after being created or expanded\n    const attributeToNewBufferLocations = new Map<\n      string,\n      IInstanceAttributeBufferLocation[]\n    >();\n\n    // As an optimization to guarantee the buffer is resized only a single time for a single changelist\n    // we  will calculate the necessary growth of the buffer by finding all of the insertions the changelist\n    // will cause.\n    if (this.changeListContext) {\n      // We will always grow beyond a 1000 units. That way there is room to prevent immediate resize operations\n      // from happening too frequently.\n      growth = 1000;\n\n      // We loop through all of the changes to find which operations will result in an additional unit\n      for (let i = 0, iMax = this.changeListContext.length; i < iMax; ++i) {\n        const diff = this.changeListContext[i];\n\n        switch (diff[1]) {\n          case InstanceDiffType.CHANGE:\n          case InstanceDiffType.INSERT:\n            // If the instance is not managed, it is a buffer growth\n            if (!this.instanceToBufferLocation[diff[0].uid]) growth++;\n            break;\n\n          default:\n            break;\n        }\n      }\n    }\n\n    debug(\"BEGIN: Resizing unpacked attribute buffer by %d instances\", growth);\n\n    // If our geometry is not created yet, then it need be made\n    if (!this.geometry) {\n      // The buffer grows from 0 to our initial instance count\n      this.maxInstancedCount += growth;\n      // We generate a new geometry object for the buffer as the geometry\n      // Needs to have it's own unique draw range per buffer for optimal\n      // Performance.\n      this.geometry = new Geometry();\n\n      // The geometry needs the vertex information (which should be shared amongst all instances of the layer)\n      for (const attribute of shaderIOInfo.vertexAttributes) {\n        if (attribute.materialAttribute) {\n          this.geometry.addAttribute(\n            attribute.name,\n            attribute.materialAttribute\n          );\n        }\n      }\n\n      this.attributes = [];\n\n      // We now take the instance attributes and add them as Instanced Attributes to our geometry\n      for (const attribute of shaderIOInfo.instanceAttributes) {\n        // We start with enough data in the buffer to accommodate 1024 instances\n        const size: number = attribute.size || 0;\n        const buffer = new Float32Array(size * this.maxInstancedCount);\n        const bufferAttribute = new Attribute(buffer, size, true, true);\n        bufferAttribute.setDynamic(true);\n        this.geometry.addAttribute(attribute.name, bufferAttribute);\n        let newBufferLocations = attributeToNewBufferLocations.get(\n          attribute.name\n        );\n\n        if (!newBufferLocations) {\n          newBufferLocations = [];\n          attributeToNewBufferLocations.set(attribute.name, newBufferLocations);\n        }\n\n        const allLocations = this.allBufferLocations[attribute.name] || [];\n        this.allBufferLocations[attribute.name] = allLocations;\n\n        const internalAttribute: IInstanceAttributeInternal<T> = Object.assign(\n          {},\n          attribute,\n          { uid: uid(), bufferAttribute: bufferAttribute }\n        );\n\n        for (let i = 0; i < this.maxInstancedCount; ++i) {\n          const newLocation: IInstanceAttributeBufferLocation = {\n            attribute: internalAttribute,\n            buffer: {\n              value: buffer\n            },\n            instanceIndex: i,\n            range: [i * size, i * size + size]\n          };\n\n          newBufferLocations.push(newLocation);\n          allLocations.push(newLocation);\n        }\n\n        // Make an internal instance attribute for tracking\n        this.attributes.push(internalAttribute);\n      }\n\n      // Ensure the draw range covers every instance in the geometry.\n      this.geometry.maxInstancedCount = 0;\n      // This is the material that is generated for the layer that utilizes all of the generated and\n      // Injected shader IO and shader fragments\n      this.material = shaderIOInfo.material.clone();\n\n      // Grab the global uniforms from the material and add it to the uniform's materialUniform list so that\n      // We can keep uniforms consistent across all Instances\n      for (let i = 0, end = shaderIOInfo.uniforms.length; i < end; ++i) {\n        const uniform = shaderIOInfo.uniforms[i];\n        uniform.materialUniforms.push(this.material.uniforms[uniform.name]);\n      }\n    } else {\n      // If the geometry is already created, then we will expand each instanced attribute to the next growth\n      // level and generate the new buffer locations based on the expansion\n      // Since were are resizing the buffer, let's destroy the old buffer and make one anew\n      this.geometry.dispose();\n      this.geometry = new Geometry();\n      const previousInstanceAmount = this.maxInstancedCount;\n\n      // The geometry needs the vertex information (which should be shared amongst all instances of the layer)\n      for (const attribute of shaderIOInfo.vertexAttributes) {\n        if (attribute.materialAttribute) {\n          this.geometry.addAttribute(\n            attribute.name,\n            attribute.materialAttribute\n          );\n        }\n      }\n\n      this.maxInstancedCount += growth;\n\n      // Ensure attributes is still defined\n      this.attributes = this.attributes || [];\n\n      for (const attribute of this.attributes) {\n        const bufferAttribute = attribute.bufferAttribute;\n        const size: number = attribute.size || 0;\n\n        if (bufferAttribute.data instanceof Float32Array) {\n          // Make a new buffer that is the proper size\n          const buffer: Float32Array = new Float32Array(\n            this.maxInstancedCount * size\n          );\n          // Retain all of the information in the previous buffer\n          buffer.set(bufferAttribute.data, 0);\n          // Make our new attribute based on the grown buffer\n          const newAttribute = new Attribute(buffer, size, true, true);\n          // Set the attribute to dynamic so we can update ranges within it\n          newAttribute.setDynamic(true);\n          // Make sure our attribute is updated with the newly made attribute\n          attribute.bufferAttribute = newAttribute;\n          // Add the new attribute to our new geometry object\n          this.geometry.addAttribute(attribute.name, newAttribute);\n          // Get the temp storage for new buffer locations\n          let newBufferLocations = attributeToNewBufferLocations.get(\n            attribute.name\n          );\n\n          // Since we have a new buffer object we are working with, we must update all of the existing buffer\n          // locations to utilize this new buffer. The locations keep everything else the same, but the buffer\n          // object itself should be updated\n          const allLocations = this.allBufferLocations[attribute.name] || [];\n          this.allBufferLocations[attribute.name] = allLocations;\n\n          for (let k = 0, endk = allLocations.length; k < endk; ++k) {\n            allLocations[k].buffer.value = buffer;\n          }\n\n          if (!newBufferLocations) {\n            newBufferLocations = [];\n            attributeToNewBufferLocations.set(\n              attribute.name,\n              newBufferLocations\n            );\n          }\n\n          for (\n            let i = previousInstanceAmount, end = this.maxInstancedCount;\n            i < end;\n            ++i\n          ) {\n            const newLocation: IInstanceAttributeBufferLocation = {\n              attribute,\n              buffer: {\n                value: buffer\n              },\n              instanceIndex: i,\n              range: [i * size, i * size + size]\n            };\n\n            newBufferLocations.push(newLocation);\n            allLocations.push(newLocation);\n          }\n        }\n      }\n\n      if (this.scene.container && this.model) {\n        this.scene.container.remove(this.model);\n      }\n    }\n\n    if (this.scene && this.model && this.scene.container) {\n      this.scene.container.remove(this.model);\n    }\n\n    // Ensure material is defined\n    this.material = this.material || shaderIOInfo.material.clone();\n    // Remake the model with the generated geometry\n    this.model = generateLayerModel(\n      this.geometry,\n      this.material,\n      shaderIOInfo.model.drawMode\n    );\n\n    // Now that we are ready to utilize the buffer, let's add it to the scene so it may be rendered.\n    // Each new buffer equates to one draw call.\n    if (this.scene && this.scene.container && this.model) {\n      this.scene.container.add(this.model);\n    }\n\n    debug(\"COMPLETE: Resizing unpacked attribute buffer\");\n\n    return {\n      growth,\n      newLocations: attributeToNewBufferLocations\n    };\n  }\n\n  /**\n   * This takes newly created buffer locations and groups them by the property ids identified by the\n   * registration phase.\n   */\n  private gatherLocationsIntoGroups(\n    attributeToNewBufferLocations: Map<\n      string,\n      IInstanceAttributeBufferLocation[]\n    >,\n    totalNewInstances: number\n  ) {\n    if (this.attributeToPropertyIds.size === 0) return;\n\n    debug(\"BEGIN: Unpacked attribute manager grouping new buffer locations\");\n\n    // Optimize inner loops by pre-fetching lookups by names\n    const attributesBufferLocations: {\n      attribute: IInstanceAttribute<T>;\n      bufferLocationsForAttribute: IInstanceAttributeBufferLocation[];\n      childBufferLocations: {\n        location: IInstanceAttributeBufferLocation[];\n        // This is one of those odd but extremely necessary optimizations. Normally while assigning these buffers to\n        // groups, one would simply use the available items and shift() those items out into the group; however,\n        // shift() or pop() is VERY ineffecient in mass quantities in that it causes massive amounts of memory\n        // allocation and movement. So instead of shifting the buffer, we simply keep an index to move to the next\n        // buffer to use. It makes the mental works a lot harder to envision, but the gains are immense doing this.\n        bufferIndex: number;\n      }[];\n      ids: number[];\n      bufferIndex: number;\n    }[] = [];\n\n    this.attributeToPropertyIds.forEach((ids, attribute) => {\n      attributesBufferLocations.push({\n        attribute,\n        bufferLocationsForAttribute:\n          attributeToNewBufferLocations.get(attribute.name) || [],\n        childBufferLocations: (attribute.childAttributes || []).map(attr => ({\n          location: attributeToNewBufferLocations.get(attr.name) || [],\n          bufferIndex: -1\n        })),\n        ids,\n        bufferIndex: -1\n      });\n    });\n\n    let allLocations,\n      attribute: IInstanceAttribute<T>,\n      ids: number[],\n      bufferLocationsForAttribute: IInstanceAttributeBufferLocation[],\n      bufferLocation: IInstanceAttributeBufferLocation | undefined,\n      childAttribute: IInstanceAttribute<T>;\n\n    // Loop through all of the new instances available and gather all of the buffer locations\n    for (let i = 0; i < totalNewInstances; ++i) {\n      const group: IInstanceAttributeBufferLocationGroup = {\n        instanceIndex: -1,\n        propertyToBufferLocation: {}\n      };\n\n      // Loop through all of the property ids that affect specific attributes. Each of these ids\n      // needs an association with the buffer location they modify.\n      for (let j = 0, endj = attributesBufferLocations.length; j < endj; ++j) {\n        allLocations = attributesBufferLocations[j];\n        attribute = allLocations.attribute;\n        ids = allLocations.ids;\n        bufferLocationsForAttribute = allLocations.bufferLocationsForAttribute;\n\n        if (!bufferLocationsForAttribute) {\n          emitOnce(\n            \"Instance Attribute Buffer Error\",\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: There is an error in forming buffer location groups in InstanceAttributeBufferManager. Error count: ${count}`\n              );\n            }\n          );\n          continue;\n        }\n\n        bufferLocation =\n          bufferLocationsForAttribute[++allLocations.bufferIndex];\n\n        if (!bufferLocation) {\n          emitOnce(\n            \"Instance Attribute Buffer Error\",\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: There is an error in forming buffer location groups in InstanceAttributeBufferManager. Error count: ${count}`\n              );\n            }\n          );\n          continue;\n        }\n\n        if (group.instanceIndex === -1) {\n          group.instanceIndex = bufferLocation.instanceIndex;\n        } else if (bufferLocation.instanceIndex !== group.instanceIndex) {\n          emitOnce(\n            \"Instance Attribute Parallelism Error\",\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: A buffer location does not have a matching instance index which means the buffer locations are not in parallel with each other somehow. Error count: ${count}`\n              );\n              console.warn(attribute.name, bufferLocation);\n            }\n          );\n          continue;\n        }\n\n        // If the attribute has children attributes. Then when the attribute is updated, the child attributes should\n        // be updated as well. Thus the buffer location needs the child attribute buffer locations.\n        if (attribute.childAttributes) {\n          bufferLocation.childLocations = [];\n\n          for (\n            let k = 0, endk = attribute.childAttributes.length;\n            k < endk;\n            ++k\n          ) {\n            const bufferLocationsForChildAttribute =\n              allLocations.childBufferLocations[k];\n\n            if (bufferLocationsForChildAttribute) {\n              const childBufferLocation =\n                bufferLocationsForChildAttribute.location[\n                  ++bufferLocationsForChildAttribute.bufferIndex\n                ];\n              // count++;\n              if (childBufferLocation) {\n                bufferLocation.childLocations.push(childBufferLocation);\n              } else {\n                childAttribute = attribute.childAttributes[k];\n                emitOnce(\n                  \"Instance Attribute Child Attribute Error\",\n                  (count: number, id: string) => {\n                    console.warn(\n                      `${id}: A child attribute does not have a buffer location available. Error count: ${count}`\n                    );\n                    console.warn(\n                      `Parent Attribute: ${attribute.name} Child Attribute: ${childAttribute.name}`\n                    );\n                  }\n                );\n              }\n            }\n          }\n        }\n\n        // In the group, associate the property ids that affect a buffer location WITH the buffer location they affect\n        for (let k = 0, endk = ids.length; k < endk; ++k) {\n          group.propertyToBufferLocation[ids[k]] = bufferLocation;\n        }\n      }\n\n      // Store this group as a group that is ready to be associated with an instance\n      this.availableLocations.push(group);\n    }\n\n    debug(\n      \"COMPLETE: Unpacked attribute buffer manager buffer location grouping\"\n    );\n    // This helps ensure errors get reported in a timely fashion in case this triggers some massive looping\n    flushEmitOnce();\n  }\n\n  /**\n   * Returns the total instances this buffer manages.\n   */\n  getInstanceCount() {\n    return this.maxInstancedCount;\n  }\n}\n","import { Instance } from \"./instance\";\n\n/**\n * This is an instance that is basically an instance stub that won't throw any implementation\n * errors when used, but will effectively do nothing.\n */\nexport class BasicInstance extends Instance {\n  resourceTrigger() {\n    // NO -OP\n  }\n}\n","import { Attribute, Geometry, Material, Model } from \"../../../gl\";\nimport { Instance, ObservableMonitoring } from \"../../../instance-provider\";\nimport {\n  IInstanceAttribute,\n  IInstanceAttributeInternal,\n  InstanceAttributeSize,\n  InstanceDiffType\n} from \"../../../types\";\nimport { uid } from \"../../../util\";\nimport { emitOnce, flushEmitOnce } from \"../../../util/emit-once\";\nimport { Layer } from \"../../layer\";\nimport { generateLayerModel } from \"../../layer-processing/generate-layer-model\";\nimport { LayerScene } from \"../../layer-scene\";\nimport {\n  BufferManagerBase,\n  IBufferLocation,\n  IBufferLocationGroup\n} from \"../buffer-manager-base\";\n\nconst { max } = Math;\nconst debug = require(\"debug\")(\"performance\");\n\n/**\n * This represents the location of data for an instance's property to the piece of attribute buffer\n * it will update when it changes.\n */\nexport interface IInstanceAttributePackingBufferLocation\n  extends IBufferLocation {}\n\n/** Represents the Location Groupings for Instance attribute Buffer locations */\nexport type IInstanceAttributePackingBufferLocationGroup = IBufferLocationGroup<\n  IInstanceAttributePackingBufferLocation\n>;\n\n/**\n * This manages instances in how they associate with buffer data for an instanced attribute strategy that is\n * packed tightly.\n */\nexport class InstanceAttributePackingBufferManager<\n  T extends Instance\n> extends BufferManagerBase<T, IInstanceAttributePackingBufferLocation> {\n  /** This stores an attribute's name to the buffer locations generated for it */\n  private allBufferLocations: { [key: string]: IBufferLocation[] } = {};\n  /** This contains the buffer locations the system will have available */\n  private availableLocations: IInstanceAttributePackingBufferLocationGroup[] = [];\n  /** This is the number of instances the buffer draws currently */\n  currentInstancedCount = 0;\n  /** This is the mapped buffer location to the provided Instance */\n  private instanceToBufferLocation: {\n    [key: number]: IInstanceAttributePackingBufferLocationGroup;\n  } = {};\n  /** This is the number of instances the buffer currently supports */\n  private maxInstancedCount: number = 1000;\n\n  // These are the only GL objects that must be monitored for disposal\n  private geometry?: Geometry;\n  private material?: Material;\n  private model?: Model;\n  private attributes?: IInstanceAttributeInternal<T>[];\n  private blockAttributes?: IInstanceAttributeInternal<T>[];\n  private blockSubAttributesLookup = new Map<number, IInstanceAttribute<T>[]>();\n\n  /** This is a mapping of all attributes to their associated property ids that, when the property changes, the attribute will be updated */\n  private attributeToPropertyIds = new Map<IInstanceAttribute<T>, number[]>();\n  /**\n   * This is a trimmed listing of minimum property ids needed to trigger an update on all properties.\n   * This is used by the diffing process mostly to handle adding a new instance.\n   */\n  private updateAllPropertyIdList: number[] = [];\n  /**\n   * This is the discovered property id of the active attribute for the instance type this manager manages.\n   * This is used by the diffing process to target updates related to deactivating an instance.\n   */\n  private activePropertyId: number = -1;\n  /**\n   * As changes are processed, instances will be added into the buffers. As they are added in, the instance\n   * will take over available locations within the buffer. Normally we would have these available locations\n   * in a queue and we would push and shift into that queue to retrieve the locations; however, shifting queues\n   * when done in VERY large quantities causes javascript to lag horrendously. Thus we instead have this index\n   * to monitor the next available item to pull during processing changes. AFTER changes have been processed\n   * we perform a one time operation splice to delete any list of available locations that have been used. This\n   * GREATLY improves performance for these types of operations.\n   */\n  private currentAvailableLocation: number = -1;\n\n  constructor(layer: Layer<T, any>, scene: LayerScene) {\n    super(layer, scene);\n    // Start our add method as a registration step.\n    this.add = this.doAddWithRegistration;\n  }\n\n  /**\n   * This is the tail end of processing changes and lets us clean up anything that might have been used to aid in the\n   * processing.\n   */\n  changesProcessed() {\n    super.changesProcessed();\n    // Clean out available locations that have been consumed during processing changes\n    this.availableLocations.splice(0, this.currentAvailableLocation + 1);\n    // All elements in the availableLocations buffer are now valid locations so we reset this index back to the\n    // beginning which is -1 since our loop iterates with it using ++currentAvailableLocation.\n    this.currentAvailableLocation = -1;\n  }\n\n  /**\n   * First instance to be added to this manager will be heavily analyzed for used observables per attribute.\n   */\n  private doAddWithRegistration(instance: T) {\n    // We need to find out how an instance interacts with the attributes, so we will\n    // loop through the instances, call their updates and get feedback\n    this.layer.shaderIOInfo.instanceAttributes.forEach(attribute => {\n      // We don't need to register child attributes as they get updated as a consequence to parent attributes\n      if (attribute.parentAttribute) return;\n      // Activate monitoring of ids, this also resets the monitor's list\n      ObservableMonitoring.setObservableMonitor(true);\n      // Access the update which accesses an instance's properties (usually)\n      attribute.update(instance);\n      // We now have all of the ids of the properties that were used in updating the attributes\n      const propertyIdsForAttribute = ObservableMonitoring.getObservableMonitorIds(\n        true\n      );\n      // Store the mapping of the property ids\n      this.attributeToPropertyIds.set(attribute, propertyIdsForAttribute);\n\n      // If this is the active attribute, then we track the property id that modifies it\n      // for handling internal instance management.\n      if (attribute === this.layer.shaderIOInfo.activeAttribute) {\n        this.activePropertyId = propertyIdsForAttribute[0];\n      }\n    });\n\n    // SUPER IMPORTANT to deactivate this here. Leaving this turned on causes memory to be chewed up\n    // for every property getter.\n    ObservableMonitoring.setObservableMonitor(false);\n    // This analyzes the properties and how they affect the attributes. It determines the smallest\n    // list possible of property ids needed to trigger an update on all of the attributes.\n    this.makeUpdateAllPropertyIdList();\n    // Do the first resize which creates the buffer and makes all of the initial buffer locations\n    const locationInfo = this.resizeBuffer();\n    // After all of the property id to attribute associations are made, we must break down the buffers\n    // into locations and then group those locations which will become our instance to buffer location\n    // slots\n    this.gatherLocationsIntoGroups(\n      locationInfo.newLocations,\n      locationInfo.growth\n    );\n    // After the first registration add, we gear shift to a more efficient add method.\n    this.add = this.doAdd;\n\n    // Perform the add after all of the registration process is complete\n    return this.doAdd(instance);\n  }\n\n  /**\n   * After the registration add happens, we gear shift over to this add method which will only pair instances\n   * with their appropriate buffer location.\n   */\n  private doAdd(instance: T) {\n    // Ensure we have buffer locations available\n    if (\n      this.availableLocations.length <= 0 ||\n      this.currentAvailableLocation >= this.availableLocations.length - 1\n    ) {\n      // Resice the buffer to accommodate more instances\n      const locationInfo = this.resizeBuffer();\n      // Break down the newly generated buffers into property groupings for the instances\n      this.gatherLocationsIntoGroups(\n        locationInfo.newLocations,\n        locationInfo.growth\n      );\n    }\n\n    // Get the next available location\n    const bufferLocations = this.availableLocations[\n      ++this.currentAvailableLocation\n    ];\n\n    // Pair up the instance with it's buffer location\n    if (bufferLocations && this.geometry) {\n      this.instanceToBufferLocation[instance.uid] = bufferLocations;\n      this.currentInstancedCount = this.geometry.maxInstancedCount = max(\n        this.currentInstancedCount,\n        // Instance index + 1 because the indices are zero indexed and the maxInstancedCount is a count value\n        bufferLocations.instanceIndex + 1\n      );\n\n      if (this.model) {\n        this.model.vertexDrawRange = [\n          0,\n          this.layer.shaderIOInfo.instanceVertexCount\n        ];\n        this.model.drawInstances = this.currentInstancedCount;\n\n        if (this.layer.shaderIOInfo.instanceVertexCount === 0) {\n          this.model.vertexDrawRange[1] = this.model.drawInstances;\n        }\n      }\n    } else {\n      console.error(\n        \"Add Error: Instance Attribute Buffer Manager failed to pair an instance with a buffer location\"\n      );\n    }\n\n    return bufferLocations;\n  }\n\n  /**\n   * Destroy this manager and clear out all elements utilized within the scene.\n   */\n  destroy() {\n    if (this.geometry) this.geometry.dispose();\n    if (this.material) this.material.dispose();\n\n    if (this.scene && this.scene.container && this.model) {\n      this.scene.container.remove(this.model);\n    }\n  }\n\n  /**\n   * This retireves the buffer locations associated with an instance, or returns nothing\n   * if the instance has not been associated yet.\n   */\n  getBufferLocations(instance: T) {\n    return this.instanceToBufferLocation[instance.uid];\n  }\n\n  /**\n   * This is the property id of the active attribute.\n   */\n  getActiveAttributePropertyId() {\n    return this.activePropertyId;\n  }\n\n  /**\n   * This is the bare minimum property ids that, when triggered for update, will update ALL of the attribute buffers\n   * for the managed layer.\n   */\n  getUpdateAllPropertyIdList() {\n    return this.updateAllPropertyIdList;\n  }\n\n  /**\n   * Checks to see if this buffer manager manages the indicated instance\n   */\n  managesInstance(instance: T) {\n    return this.instanceToBufferLocation[instance.uid] !== undefined;\n  }\n\n  /**\n   * Analyzes the list of attributes to the property ids that affects them. This populates the list\n   * of minimal property ids needed to trigger updates on all of the attributes.\n   */\n  private makeUpdateAllPropertyIdList() {\n    // Make a deduping list of ids\n    const updateAllPropertyIdList: { [key: number]: number } = {};\n\n    // Get unique ids that will target all attributes\n    this.attributeToPropertyIds.forEach(ids => {\n      updateAllPropertyIdList[ids[0]] = ids[0];\n    });\n\n    // Store the list for the diffing process to utilize\n    this.updateAllPropertyIdList = Object.values(\n      updateAllPropertyIdList\n    ).filter(Boolean);\n  }\n\n  /**\n   * Disassociates an instance with a buffer\n   */\n  remove = (instance: T) => {\n    const location = this.instanceToBufferLocation[instance.uid];\n\n    if (location) {\n      delete this.instanceToBufferLocation[instance.uid];\n      this.availableLocations.push(location);\n    }\n\n    return instance;\n  };\n\n  /**\n   * Clears all elements of this manager from the current scene it was in.\n   */\n  removeFromScene() {\n    if (this.scene && this.scene.container && this.model) {\n      this.scene.container.remove(this.model);\n    }\n\n    delete this.scene;\n  }\n\n  /**\n   * This generates a new buffer of attributes to associate instances with.\n   *\n   * This method for the attribute packing strategy creates a vertex attribute for each block required.\n   * The individual properties are then packed into each of these blocks.\n   */\n  private resizeBuffer() {\n    // Get the shader io information from the layer to reduce deep references\n    const shaderIOInfo = this.layer.shaderIOInfo;\n    // This stores how much the buffer will be able to regrow\n    let growth = 0;\n    // Each attribute will generate lists of new buffer locations after being created or expanded\n    const attributeToNewBufferLocations = new Map<\n      string,\n      IInstanceAttributePackingBufferLocation[]\n    >();\n\n    // As an optimization to guarantee the buffer is resized only a single time for a single changelist\n    // we  will calculate the necessary growth of the buffer by finding all of the insertions the changelist\n    // will cause.\n    if (this.changeListContext) {\n      // We will always grow beyond a 1000 units. That way there is room to prevent immediate resize operations\n      // from happening too frequently.\n      growth = 1000;\n\n      // We loop through all of the changes to find which operations will result in an additional unit\n      for (let i = 0, iMax = this.changeListContext.length; i < iMax; ++i) {\n        const diff = this.changeListContext[i];\n\n        switch (diff[1]) {\n          case InstanceDiffType.CHANGE:\n          case InstanceDiffType.INSERT:\n            // If the instance is not managed, it is a buffer growth\n            if (!this.instanceToBufferLocation[diff[0].uid]) growth++;\n            break;\n\n          default:\n            break;\n        }\n      }\n    }\n\n    debug(\"BEGIN: Resizing packed attribute buffer by %d instances\", growth);\n\n    // If our geometry is not created yet, then it need be made\n    if (!this.geometry) {\n      // The buffer grows from 0 to our initial instance count\n      this.maxInstancedCount += growth;\n      // We generate a new geometry object for the buffer as the geometry\n      // Needs to have it's own unique draw range per buffer for optimal\n      // Performance.\n      this.geometry = new Geometry();\n\n      // The geometry needs the vertex information (which should be shared amongst all instances of the layer)\n      // These are static non-dynamic buffers for the instance.\n      for (const attribute of shaderIOInfo.vertexAttributes) {\n        if (attribute.materialAttribute) {\n          this.geometry.addAttribute(\n            attribute.name,\n            attribute.materialAttribute\n          );\n        }\n      }\n\n      this.attributes = [];\n      this.blockAttributes = [];\n\n      // We have to determine how many blocks will be used to cram all of our instance properties into.\n      // So we calculate how big each block will be. The number of sizes calculated will be how many blocks\n      // need to be generated.\n      const blockSizes = new Map<number, number>();\n      const blockSubAttributesLookup = new Map<\n        number,\n        IInstanceAttribute<T>[]\n      >();\n      this.blockSubAttributesLookup = blockSubAttributesLookup;\n\n      for (\n        let i = 0, iMax = shaderIOInfo.instanceAttributes.length;\n        i < iMax;\n        ++i\n      ) {\n        const attribute = shaderIOInfo.instanceAttributes[i];\n        const block = attribute.block || 0;\n        let blockSize = blockSizes.get(block) || 0;\n        // Determine the bigger of the block sizes (incoming attribute or previously checked attribute)\n        blockSize = Math.max(\n          blockSize,\n          (attribute.blockIndex || 0) + (attribute.size || 0)\n        );\n        // Store the larger size for the block\n        blockSizes.set(block, blockSize);\n        // We need to store all of the attributes associated with a block\n        let blockAttributes = blockSubAttributesLookup.get(block);\n\n        if (!blockAttributes) {\n          blockAttributes = [];\n          blockSubAttributesLookup.set(block, blockAttributes);\n        }\n\n        blockAttributes.push(attribute);\n      }\n\n      // Let's sort all of the attributes associated with each block by their index in the block\n      // so from here on out we can assume they are in ascending order\n      blockSubAttributesLookup.forEach(attributes =>\n        attributes.sort((a, b) => (a.blockIndex || 0) - (b.blockIndex || 0))\n      );\n\n      // Now that we have the blocks that will be needed to accommodate the attributes, we will\n      // create these blocks as attributes attached to the geometry.\n      for (let block = 0, iMax = blockSizes.size; block < iMax; ++block) {\n        // Get the size each attribute will be for the block\n        const blockSize: number = blockSizes.get(block) || 0;\n        // This is an interesting case, the attributes that are generated are packed into other attributes\n        // for optimal use of the vertex attributes allotted for a systems resources.\n        const blockAttributeUID = uid();\n\n        if (!blockSize) {\n          console.warn(\n            \"Instance Attribute Packing Error: The system tried to build an attribute with a size of zero.\",\n            \"These are the attributes used:\",\n            shaderIOInfo.instanceAttributes,\n            \"These are the block sizes calculated\",\n            blockSizes,\n            \"This is the block to attribute lookup generated\",\n            blockSubAttributesLookup\n          );\n        }\n\n        // Make our attribute buffer to accommodate all of the instances to be rendered.\n        const buffer = new Float32Array(blockSize * this.maxInstancedCount);\n        // Make an instanced buffer to take advantage of hardware instancing\n        const bufferAttribute = new Attribute(buffer, blockSize, true, true);\n\n        // Add the attribute to our geometry labeled as a block like the uniform block packing strategy\n        this.geometry.addAttribute(`block${block}`, bufferAttribute);\n\n        // Get all of the attributes that will be applied to this block\n        const blockSubAttributes = blockSubAttributesLookup.get(block);\n\n        if (blockSubAttributes) {\n          for (let k = 0, kMax = blockSubAttributes.length; k < kMax; ++k) {\n            const attribute = blockSubAttributes[k];\n\n            let newBufferLocations = attributeToNewBufferLocations.get(\n              attribute.name\n            );\n\n            if (!newBufferLocations) {\n              newBufferLocations = [];\n              attributeToNewBufferLocations.set(\n                attribute.name,\n                newBufferLocations\n              );\n            }\n\n            const allLocations = this.allBufferLocations[attribute.name] || [];\n            this.allBufferLocations[attribute.name] = allLocations;\n\n            const internalAttribute: IInstanceAttributeInternal<T> = Object.assign(\n              {},\n              attribute,\n              {\n                uid: block,\n                packUID: blockAttributeUID,\n                bufferAttribute,\n                size: blockSize\n              }\n            );\n\n            const startAttributeIndex = attribute.blockIndex || 0;\n            const attributeSize = attribute.size || 1;\n\n            for (let i = 0; i < this.maxInstancedCount; ++i) {\n              const newLocation: IBufferLocation = {\n                attribute: internalAttribute,\n                block,\n                buffer: {\n                  value: buffer\n                },\n                instanceIndex: i,\n                range: [\n                  i * blockSize + startAttributeIndex,\n                  i * blockSize + startAttributeIndex + attributeSize\n                ]\n              };\n\n              newBufferLocations.push(newLocation);\n              allLocations.push(newLocation);\n            }\n\n            this.attributes.push(internalAttribute);\n          }\n\n          // Make an internal instance attribute for tracking\n          this.blockAttributes.push({\n            uid: uid(),\n            packUID: blockAttributeUID,\n            bufferAttribute,\n            name: `block${block}`,\n            size: InstanceAttributeSize.FOUR,\n            update: () => [0]\n          });\n        } else {\n          console.warn(\n            \"Instance Attribute Packing Buffer Error: Somehow there are no attributes associated with a block.\",\n            \"These are the attributes used:\",\n            shaderIOInfo.instanceAttributes,\n            \"These are the block sizes calculated\",\n            blockSizes,\n            \"This is the block to attribute lookup generated\",\n            blockSubAttributesLookup\n          );\n        }\n      }\n\n      // Ensure the draw range covers every instance in the geometry.\n      this.geometry.maxInstancedCount = 0;\n      // This is the material that is generated for the layer that utilizes all of the generated and\n      // Injected shader IO and shader fragments\n      this.material = shaderIOInfo.material.clone();\n\n      // Grab the global uniforms from the material and add it to the uniform's materialUniform list so that\n      // We can keep uniforms consistent across all Instances\n      for (let i = 0, end = shaderIOInfo.uniforms.length; i < end; ++i) {\n        const uniform = shaderIOInfo.uniforms[i];\n        uniform.materialUniforms.push(this.material.uniforms[uniform.name]);\n      }\n    } else {\n      debug(\n        `Info: Vertex packing buffer is being resized for layer ${this.layer.id}`\n      );\n      // If the geometry is already created, then we will expand each instanced attribute to the next growth\n      // level and generate the new buffer locations based on the expansion\n      // Since were are resizing the buffer, let's destroy the old buffer and make one anew\n      this.geometry.dispose();\n      this.geometry = new Geometry();\n      const previousInstanceAmount = this.maxInstancedCount;\n\n      // The geometry needs the vertex information (which should be shared amongst all instances of the layer)\n      for (const attribute of shaderIOInfo.vertexAttributes) {\n        if (attribute.materialAttribute) {\n          this.geometry.addAttribute(\n            attribute.name,\n            attribute.materialAttribute\n          );\n        }\n      }\n\n      this.maxInstancedCount += growth;\n\n      // Ensure attributes is still defined\n      this.attributes = this.attributes || [];\n      this.blockAttributes = this.blockAttributes || [];\n\n      for (\n        let block = 0, iMax = this.blockAttributes.length;\n        block < iMax;\n        ++block\n      ) {\n        const attribute = this.blockAttributes[block];\n        let bufferAttribute = attribute.bufferAttribute;\n        const size: number = attribute.size || 0;\n\n        if (bufferAttribute.data instanceof Float32Array) {\n          // Make a new buffer that is the proper size\n          const buffer: Float32Array = new Float32Array(\n            this.maxInstancedCount * size\n          );\n          // Retain all of the information in the previous buffer\n          buffer.set(bufferAttribute.data, 0);\n          // Make our new attribute based on the grown buffer\n          const newAttribute = new Attribute(buffer, size, true, true);\n          // Make sure our attribute is updated with the newly made attribute\n          attribute.bufferAttribute = bufferAttribute = newAttribute;\n          // Add the new attribute to our new geometry object\n          this.geometry.addAttribute(attribute.name, newAttribute);\n\n          // Since we have a new buffer object we are working with, we must update all of the existing buffer\n          // locations to utilize this new buffer. The locations keep everything else the same, but the buffer\n          // object itself should be updated\n          // Get all of the attributes that will be applied to this block\n          const blockSubAttributes = this.blockSubAttributesLookup.get(block);\n          const blockSize = attribute.size || 0;\n\n          if (blockSubAttributes) {\n            for (let k = 0, kMax = blockSubAttributes.length; k < kMax; ++k) {\n              const subAttribute = blockSubAttributes[k];\n\n              let newBufferLocations = attributeToNewBufferLocations.get(\n                subAttribute.name\n              );\n\n              if (!newBufferLocations) {\n                newBufferLocations = [];\n                attributeToNewBufferLocations.set(\n                  subAttribute.name,\n                  newBufferLocations\n                );\n              }\n\n              const allLocations =\n                this.allBufferLocations[subAttribute.name] || [];\n              this.allBufferLocations[subAttribute.name] = allLocations;\n\n              const internalAttribute: IInstanceAttributeInternal<T> = Object.assign(\n                {},\n                subAttribute,\n                {\n                  uid: uid(),\n                  packUID: attribute.packUID,\n                  bufferAttribute\n                }\n              );\n\n              const startAttributeIndex = subAttribute.blockIndex || 0;\n              const attributeSize = subAttribute.size || 1;\n\n              // Update all existing attribute locations with the new internal attribute and new buffer\n              for (let j = 0, jMax = allLocations.length; j < jMax; ++j) {\n                const location = allLocations[j];\n                location.attribute = internalAttribute;\n                location.buffer = {\n                  value: buffer\n                };\n              }\n\n              // Create new locations for each new instance we will cover\n              for (\n                let i = previousInstanceAmount;\n                i < this.maxInstancedCount;\n                ++i\n              ) {\n                const newLocation: IBufferLocation = {\n                  attribute: internalAttribute,\n                  block,\n                  buffer: {\n                    value: buffer\n                  },\n                  instanceIndex: i,\n                  range: [\n                    i * blockSize + startAttributeIndex,\n                    i * blockSize + startAttributeIndex + attributeSize\n                  ]\n                };\n\n                newBufferLocations.push(newLocation);\n                allLocations.push(newLocation);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Remove any existing model\n    if (this.scene && this.model && this.scene.container) {\n      this.scene.container.remove(this.model);\n    }\n\n    // Ensure material is defined\n    this.material = this.material || this.layer.shaderIOInfo.material.clone();\n    // Remake the model with the generated geometry\n    this.model = generateLayerModel(\n      this.geometry,\n      this.material,\n      this.layer.shaderIOInfo.model.drawMode\n    );\n\n    // Now that we are ready to utilize the buffer, let's add it to the scene so it may be rendered.\n    // Each new buffer equates to one draw call.\n    if (this.scene && this.scene.container && this.model) {\n      this.scene.container.add(this.model);\n    }\n\n    debug(\"COMPLETE: Resizing unpacked attribute buffer\");\n\n    return {\n      growth,\n      newLocations: attributeToNewBufferLocations\n    };\n  }\n\n  /**\n   * This takes newly created buffer locations and groups them by the property ids identified by the\n   * registration phase.\n   */\n  private gatherLocationsIntoGroups(\n    attributeToNewBufferLocations: Map<\n      string,\n      IInstanceAttributePackingBufferLocation[]\n    >,\n    totalNewInstances: number\n  ) {\n    if (this.attributeToPropertyIds.size === 0) return;\n\n    debug(\"BEGIN: Packed attribute manager grouping new buffer locations\");\n\n    // Optimize inner loops by pre-fetching lookups by names\n    const attributesBufferLocations: {\n      attribute: IInstanceAttribute<T>;\n      bufferLocationsForAttribute: IInstanceAttributePackingBufferLocation[];\n      childBufferLocations: {\n        location: IInstanceAttributePackingBufferLocation[];\n        // This is one of those odd but extremely necessary optimizations. Normally while assigning these buffers to\n        // groups, one would simply use the available items and shift() those items out into the group; however,\n        // shift() or pop() is VERY ineffecient in mass quantities in that it causes massive amounts of memory\n        // allocation and movement. So instead of shifting the buffer, we simply keep an index to move to the next\n        // buffer to use. It makes the mental works a lot harder to envision, but the gains are immense doing this.\n        bufferIndex: number;\n      }[];\n      ids: number[];\n      // This is one of those odd but extremely necessary optimizations. Normally while assigning these buffers to\n      // groups, one would simply use the available items and shift() those items out into the group; however,\n      // shift() or pop() is VERY ineffecient in mass quantities in that it causes massive amounts of memory\n      // allocation and movement. So instead of shifting the buffer, we simply keep an index to move to the next\n      // buffer to use. It makes the mental works a lot harder to envision, but the gains are immense doing this.\n      bufferIndex: number;\n    }[] = [];\n\n    this.attributeToPropertyIds.forEach((ids, attribute) => {\n      attributesBufferLocations.push({\n        attribute,\n        bufferLocationsForAttribute:\n          attributeToNewBufferLocations.get(attribute.name) || [],\n        childBufferLocations: (attribute.childAttributes || []).map(attr => ({\n          location: attributeToNewBufferLocations.get(attr.name) || [],\n          bufferIndex: -1\n        })),\n        ids,\n        bufferIndex: -1\n      });\n    });\n\n    // Loop through all of the new instances available and gather all of the buffer locations\n    for (let i = 0; i < totalNewInstances; ++i) {\n      const group: IInstanceAttributePackingBufferLocationGroup = {\n        instanceIndex: -1,\n        propertyToBufferLocation: {}\n      };\n\n      // Loop through all of the property ids that affect specific attributes. Each of these ids\n      // needs an association with the buffer location they modify.\n      for (let j = 0, endj = attributesBufferLocations.length; j < endj; ++j) {\n        const allLocations = attributesBufferLocations[j];\n        const attribute = allLocations.attribute;\n        const ids = allLocations.ids;\n        const bufferLocationsForAttribute =\n          allLocations.bufferLocationsForAttribute;\n\n        if (!bufferLocationsForAttribute) {\n          emitOnce(\n            \"Instance Attribute Buffer Error\",\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: There is an error in forming buffer location groups in InstanceAttributePackingBufferManager. Error count: ${count}`\n              );\n            }\n          );\n          continue;\n        }\n\n        const bufferLocation =\n          bufferLocationsForAttribute[++allLocations.bufferIndex];\n\n        if (!bufferLocation) {\n          emitOnce(\n            \"Instance Attribute Buffer Error\",\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: There is an error in forming buffer location groups in InstanceAttributePackingBufferManager. Error count: ${count}`\n              );\n            }\n          );\n          continue;\n        }\n\n        if (group.instanceIndex === -1) {\n          group.instanceIndex = bufferLocation.instanceIndex;\n        } else if (bufferLocation.instanceIndex !== group.instanceIndex) {\n          emitOnce(\n            \"Instance Attribute Parallelism Error\",\n            (count: number, id: string) => {\n              console.warn(\n                `${id}: A buffer location does not have a matching instance index which means the buffer locations are not in parallel with each other somehow. Error count: ${count}`\n              );\n              console.warn(attribute.name, bufferLocation);\n            }\n          );\n          continue;\n        }\n\n        // If the attribute has children attributes. Then when the attribute is updated, the child attributes should\n        // be updated as well. Thus the buffer location needs the child attribute buffer locations.\n        if (attribute.childAttributes) {\n          const childLocations = [];\n\n          for (\n            let k = 0, endk = attribute.childAttributes.length;\n            k < endk;\n            ++k\n          ) {\n            const childAttribute = attribute.childAttributes[k];\n            const bufferLocationsForChildAttribute =\n              allLocations.childBufferLocations[k];\n\n            if (bufferLocationsForChildAttribute) {\n              const childBufferLocation =\n                bufferLocationsForChildAttribute.location[\n                  ++bufferLocationsForChildAttribute.bufferIndex\n                ];\n              if (childBufferLocation) {\n                childLocations.push(childBufferLocation);\n              } else {\n                emitOnce(\n                  \"Instance Attribute Child Attribute Error\",\n                  (count: number, id: string) => {\n                    console.warn(\n                      `${id}: A child attribute does not have a buffer location available. Error count: ${count}`\n                    );\n                    console.warn(\n                      `Parent Attribute: ${attribute.name} Child Attribute: ${childAttribute.name}`\n                    );\n                  }\n                );\n              }\n            }\n          }\n\n          bufferLocation.childLocations = childLocations;\n        }\n\n        // In the group, associate the property ids that affect a buffer location WITH the buffer location they affect\n        for (let k = 0, endk = ids.length; k < endk; ++k) {\n          const id = ids[k];\n          group.propertyToBufferLocation[id] = bufferLocation;\n        }\n      }\n\n      // Store this group as a group that is ready to be associated with an instance\n      this.availableLocations.push(group);\n    }\n\n    debug(\"COMPLETE: Packed attribute buffer manager buffer location grouping\");\n\n    // This helps ensure errors get reported in a timely fashion in case this triggers some massive looping\n    flushEmitOnce();\n  }\n\n  /**\n   * Returns the total instances this buffer manages.\n   */\n  getInstanceCount() {\n    return this.maxInstancedCount;\n  }\n}\n","import { Instance } from \"../../instance-provider/instance\";\nimport { ResourceRouter } from \"../../resources\";\nimport {\n  INonePickingMetrics,\n  ISinglePickingMetrics,\n  LayerBufferType\n} from \"../../types\";\nimport { ILayerShaderIOInfo } from \"../layer\";\nimport { BaseDiffProcessor } from \"./base-diff-processor\";\nimport { IBufferLocationGroup } from \"./buffer-manager-base\";\nimport { BufferManagerBase, IBufferLocation } from \"./buffer-manager-base\";\nimport { InstanceAttributeDiffProcessor } from \"./instance-attribute-buffering/instance-attribute-diff-processor\";\nimport { UniformDiffProcessor } from \"./uniform-buffering/uniform-diff-processor\";\n\n/** Signature of a method that handles a diff */\nexport type DiffHandler<T extends Instance> = (\n  manager: BaseDiffProcessor<T>,\n  instance: T,\n  propIds: number[],\n  bufferLocations?: IBufferLocation | IBufferLocationGroup<IBufferLocation>\n) => void;\n/** A set of diff handling methods in this order [change, add, remove] */\nexport type DiffLookup<T extends Instance> = DiffHandler<T>[];\n\n/**\n * This interface is the bare minimum properties needed for this diff manager to map instance updates to\n * uniform changes. We don't use a Layer as a target explicitly to avoid circular/hard dependencies\n */\nexport interface IInstanceDiffManagerTarget<T extends Instance> {\n  /** Contains the shader IO information available in the target */\n  shaderIOInfo: ILayerShaderIOInfo<T>;\n  /** This is the picking metrics for how Instances are picked with the mouse */\n  picking: ISinglePickingMetrics<T> | INonePickingMetrics;\n  /** This is the resource manager for the target which let's us fetch information from an atlas for an instance */\n  resource: ResourceRouter;\n  /** This is the manager that links an instance to it's uniform cluster for populating the uniform buffer */\n  bufferManager: BufferManagerBase<T, IBufferLocation>;\n  /** This is the buffering strategy being used */\n  bufferType: LayerBufferType;\n\n  /**\n   * This is a hook for the layer to respond to an instance being added via the diff manager. This is a simple\n   * opportunity to set some expectations of the instance and tie it directly to the layer it is processing under.\n   *\n   * For example: the primary case this arose was from instances needing the easing id mapping to allow for retrieval\n   * of the instance's easing information for a given layer association.\n   *\n   * WARNING: This is tied into a MAJOR performance sensitive portion of the framework. This should involve VERY simple\n   * assignments at best. Do NOT perform any logic in this callback or your application WILL suffer.\n   */\n  onDiffAdd?(instance: T): void;\n\n  /**\n   * This is an opportunity to clean up any instance's association with the layer it was originally a part of.\n   *\n   * WARNING: This is tied into a MAJOR performance sensitive portion of the framework. This should involve VERY simple\n   * assignments at best. Do NOT perform any logic in this callback or your application WILL suffer.\n   *\n   * EXTRA WARNING: You better make sure you instantiate this if you instantiated onDiffManagerAdd so you can clean out\n   * any bad memory allocation choices you made.\n   */\n  onDiffRemove?(instance: T): void;\n}\n\n/**\n * This is a simple organizational class that generates a diff processor and provides a processing tuple that is used\n * in processing the diffs.\n */\nexport class InstanceDiffManager<T extends Instance> {\n  processor: BaseDiffProcessor<T>;\n  processing: DiffLookup<T>;\n\n  /**\n   * This returns the proper diff processor for handling diffs\n   */\n  makeProcessor(\n    layer: IInstanceDiffManagerTarget<T>,\n    bufferManager: BufferManagerBase<T, IBufferLocation>\n  ): DiffLookup<T> {\n    // If this manager has already figured out which processor to use. Just return that processor.\n    if (this.processing) return this.processing;\n\n    if (\n      layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE ||\n      layer.bufferType === LayerBufferType.INSTANCE_ATTRIBUTE_PACKING\n    ) {\n      this.processor = new InstanceAttributeDiffProcessor(layer, bufferManager);\n    } else {\n      this.processor = new UniformDiffProcessor(layer, bufferManager);\n    }\n\n    this.processing = [\n      this.processor.changeInstance,\n      this.processor.addInstance,\n      this.processor.removeInstance\n    ];\n\n    return this.processing;\n  }\n}\n","import { Instance } from \"../../../instance-provider/instance\";\nimport { Mat4x4, Vec } from \"../../../math\";\nimport { IInstanceAttributeInternal, InstanceDiff } from \"../../../types\";\nimport { BaseDiffProcessor } from \"../base-diff-processor\";\nimport {\n  IBufferLocation,\n  IBufferLocationGroup,\n  isBufferLocationGroup\n} from \"../buffer-manager-base\";\nimport { IInstanceDiffManagerTarget } from \"../instance-diff-manager\";\nimport {\n  IInstanceAttributeBufferLocation,\n  IInstanceAttributeBufferLocationGroup\n} from \"./instance-attribute-buffer-manager\";\n\nconst EMPTY: number[] = [];\nconst { min, max } = Math;\n\nenum DiffMode {\n  /** This mode will analyze incoming buffer location changes and only update the range of changed buffer */\n  PARTIAL,\n  /** This mode will not spend time figuring out what has changed for a buffer, rather the whole buffer will get an update */\n  FULL\n}\n\n/**\n * Manages diffs for layers that are utilizing the base uniform instancing buffer strategy.\n */\nexport class InstanceAttributeDiffProcessor<\n  T extends Instance\n> extends BaseDiffProcessor<T> {\n  /** This is the processor's current diff mode for consuming instance updates. */\n  private diffMode: DiffMode = DiffMode.PARTIAL;\n\n  /** This tracks a buffer attribute's uid to the range of data that it should update */\n  bufferAttributeUpdateRange: {\n    [key: number]: [IInstanceAttributeInternal<T>, number, number];\n  } = {};\n\n  /** This tracks a buffer attribute's uid that will perform a complete update */\n  bufferAttributeWillUpdate: {\n    [key: number]: IInstanceAttributeInternal<T>;\n  } = {};\n\n  /**\n   * The instance updating is a property instead of a method as we will want to be able to gear shift it for varying levels\n   * of adjustments.\n   */\n  updateInstance: (\n    layer: IInstanceDiffManagerTarget<T>,\n    instance: T,\n    propIds: number[],\n    bufferLocations: IBufferLocationGroup<IBufferLocation>\n  ) => void = this.updateInstancePartial;\n\n  /**\n   * This processes add operations from changes in the instancing data\n   */\n  addInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    bufferLocations?: IInstanceAttributeBufferLocationGroup\n  ) {\n    // If the uniform cluster already exists, then we swap over to a change update\n    if (bufferLocations) {\n      manager.changeInstance(manager, instance, EMPTY, bufferLocations);\n    } else {\n      // Otherwise, we DO need to perform an add and we link a Uniform cluster to our instance\n      const newBufferLocations = manager.layer.bufferManager.add(instance);\n\n      if (isBufferLocationGroup(newBufferLocations)) {\n        instance.active = true;\n\n        if (manager.layer.onDiffAdd) {\n          manager.layer.onDiffAdd(instance);\n        }\n\n        manager.updateInstance(\n          manager.layer,\n          instance,\n          EMPTY,\n          newBufferLocations\n        );\n      }\n    }\n  }\n\n  /**\n   * This processes change operations from changes in the instancing data\n   */\n  changeInstance(\n    manager: this,\n    instance: T,\n    propIds: number[],\n    bufferLocations?: IInstanceAttributeBufferLocationGroup\n  ) {\n    // If there is an existing uniform cluster for this instance, then we can update the bufferLocations\n    if (bufferLocations) {\n      manager.updateInstance(manager.layer, instance, propIds, bufferLocations);\n    } else {\n      // If we don't have existing bufferLocations, then we must add the instance\n      manager.addInstance(manager, instance, EMPTY, bufferLocations);\n    }\n  }\n\n  /**\n   * This processes remove operations from changes in the instancing data\n   */\n  removeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    bufferLocations?: IInstanceAttributeBufferLocationGroup\n  ) {\n    if (bufferLocations) {\n      // We deactivate the instance so it does not render anymore\n      instance.active = false;\n\n      // Execute the remove hook for the instance on behalf of the layer\n      if (manager.layer.onDiffRemove) {\n        manager.layer.onDiffRemove(instance);\n      }\n\n      // We do one last update on the instance to update to it's deactivated state\n      manager.updateInstance(manager.layer, instance, EMPTY, bufferLocations);\n      // Unlink the instance from the uniform cluster\n      manager.layer.bufferManager.remove(instance);\n    }\n  }\n\n  /**\n   * This performs the actual updating of buffers the instance needs to update\n   */\n  updateInstancePartial(\n    _layer: IInstanceDiffManagerTarget<T>,\n    instance: T,\n    propIds: number[],\n    bufferLocations: IBufferLocationGroup<IInstanceAttributeBufferLocation>\n  ) {\n    const propertyToLocation = bufferLocations.propertyToBufferLocation;\n    const bufferAttributeUpdateRange = this.bufferAttributeUpdateRange;\n\n    let location: IInstanceAttributeBufferLocation;\n    let updateValue: Vec | Mat4x4;\n    let updateRange;\n    let childLocations: IInstanceAttributeBufferLocation[];\n    let attribute: IInstanceAttributeInternal<T>;\n    let attributeChangeUID;\n\n    if (instance.active) {\n      // If no prop ids provided, then we perform a complete instance property update\n      if (propIds.length === 0 || instance.reactivate) {\n        propIds = this.bufferManager.getUpdateAllPropertyIdList();\n      }\n\n      for (let i = 0, end = propIds.length; i < end; ++i) {\n        // First update for the instance attribute itself\n        location = propertyToLocation[propIds[i]];\n        // Not finding a location can indicate an observable property changed on the instance that is not used by the\n        // layer\n        if (!location) continue;\n        attribute = location.attribute;\n        attributeChangeUID = attribute.packUID || attribute.uid;\n        updateValue = attribute.update(instance);\n        location.buffer.value.set(updateValue, location.range[0]);\n        updateRange = bufferAttributeUpdateRange[attributeChangeUID] || [\n          null,\n          Number.MAX_SAFE_INTEGER,\n          Number.MIN_SAFE_INTEGER\n        ];\n        updateRange[0] = attribute;\n        updateRange[1] = min(location.range[0], updateRange[1]);\n        updateRange[2] = max(location.range[1], updateRange[2]);\n        bufferAttributeUpdateRange[attributeChangeUID] = updateRange;\n\n        // Now update any child attributes that would need updating based on the parent attribute changing\n        if (location.childLocations) {\n          childLocations = location.childLocations;\n\n          for (let k = 0, endk = childLocations.length; k < endk; ++k) {\n            location = childLocations[k];\n            // Not finding a location can indicate an observable property changed on the instance that is not used by\n            // the layer\n            if (!location) continue;\n            attributeChangeUID =\n              location.attribute.packUID || location.attribute.uid;\n            updateValue = location.attribute.update(instance);\n            location.buffer.value.set(updateValue, location.range[0]);\n            updateRange = bufferAttributeUpdateRange[attributeChangeUID] || [\n              null,\n              Number.MAX_SAFE_INTEGER,\n              Number.MIN_SAFE_INTEGER\n            ];\n            updateRange[0] = location.attribute;\n            updateRange[1] = min(location.range[0], updateRange[1]);\n            updateRange[2] = max(location.range[1], updateRange[2]);\n            bufferAttributeUpdateRange[attributeChangeUID] = updateRange;\n          }\n        }\n      }\n    } else {\n      // When the instance is inactive all we update is the active attribute to false\n      location =\n        propertyToLocation[this.bufferManager.getActiveAttributePropertyId()];\n      attribute = location.attribute;\n      attributeChangeUID = attribute.packUID || attribute.uid;\n      updateValue = attribute.update(instance);\n      location.buffer.value.set(updateValue, location.range[0]);\n      updateRange = bufferAttributeUpdateRange[attributeChangeUID] || [\n        null,\n        Number.MAX_SAFE_INTEGER,\n        Number.MIN_SAFE_INTEGER\n      ];\n      updateRange[0] = attribute;\n      updateRange[1] = min(location.range[0], updateRange[1]);\n      updateRange[2] = max(location.range[1], updateRange[2]);\n      bufferAttributeUpdateRange[attributeChangeUID] = updateRange;\n    }\n\n    // Make sure the instance reactivation process is not executed again\n    instance.reactivate = false;\n  }\n\n  /**\n   * This performs an update on the buffers with the intent the entire buffer is going to update\n   * rather than a chunk of it.\n   */\n  updateInstanceFull(\n    _layer: IInstanceDiffManagerTarget<T>,\n    instance: T,\n    propIds: number[],\n    bufferLocations: IBufferLocationGroup<IInstanceAttributeBufferLocation>\n  ) {\n    const propertyToLocation = bufferLocations.propertyToBufferLocation;\n    const bufferAttributeWillUpdate = this.bufferAttributeWillUpdate;\n\n    let location: IInstanceAttributeBufferLocation;\n    let updateValue: Vec | Mat4x4;\n    let childLocations: IInstanceAttributeBufferLocation[];\n    let attribute: IInstanceAttributeInternal<T>;\n\n    if (instance.active) {\n      // If no prop ids provided, then we perform a complete instance property update\n      if (propIds.length === 0 || instance.reactivate) {\n        propIds = this.bufferManager.getUpdateAllPropertyIdList();\n      }\n\n      for (let i = 0, end = propIds.length; i < end; ++i) {\n        // First update for the instance attribute itself\n        location = propertyToLocation[propIds[i]];\n        // Not finding a location can indicate an observable property changed on the instance that is not used by the\n        // layer\n        if (!location) continue;\n        attribute = location.attribute;\n        updateValue = attribute.update(instance);\n        location.buffer.value.set(updateValue, location.range[0]);\n        bufferAttributeWillUpdate[\n          attribute.packUID || attribute.uid\n        ] = attribute;\n\n        // Now update any child attributes that would need updating based on the parent attribute changing\n        if (location.childLocations) {\n          childLocations = location.childLocations;\n\n          for (let k = 0, endk = childLocations.length; k < endk; ++k) {\n            location = childLocations[k];\n            // Not finding a location can indicate an observable property changed on the instance that is not used by the\n            // layer\n            if (!location) continue;\n            attribute = location.attribute;\n            updateValue = attribute.update(instance);\n            location.buffer.value.set(updateValue, location.range[0]);\n            bufferAttributeWillUpdate[\n              attribute.packUID || attribute.uid\n            ] = attribute;\n          }\n        }\n      }\n    } else {\n      // When the instance is inactive all we update is the active attribute to false\n      location =\n        propertyToLocation[this.bufferManager.getActiveAttributePropertyId()];\n      attribute = location.attribute;\n      updateValue = attribute.update(instance);\n      location.buffer.value.set(updateValue, location.range[0]);\n      bufferAttributeWillUpdate[attribute.packUID || attribute.uid] = attribute;\n    }\n\n    // Make sure the instance reactivation process is not executed again\n    instance.reactivate = false;\n  }\n\n  /**\n   * Finalize all of the buffer changes and apply the correct update ranges\n   */\n  commit() {\n    // If we're in a partial mode: just update the portion of the buffer that needs updating.\n    if (this.diffMode === DiffMode.PARTIAL) {\n      // We now grab all of the attributes and set their update ranges\n      const updates = Object.values(this.bufferAttributeUpdateRange);\n\n      for (let i = 0, end = updates.length; i < end; ++i) {\n        const update = updates[i];\n        const attribute = update[0].bufferAttribute;\n        attribute.updateRange = {\n          count: update[2] - update[1],\n          offset: update[1]\n        };\n      }\n    } else {\n      // Otherwise just update the full buffer\n      // We now grab all of the attributes and set their update ranges\n      const updates = Object.values(this.bufferAttributeWillUpdate);\n\n      for (let i = 0, end = updates.length; i < end; ++i) {\n        const attribute = updates[i].bufferAttribute;\n        attribute.updateRange = {\n          count: -1,\n          offset: 0\n        };\n      }\n    }\n\n    // Clear the attribute update metrics\n    this.bufferAttributeUpdateRange = {};\n  }\n\n  /**\n   * This will optimize the update method used. If there are enough instances being updated, we will\n   * cause the entire attribute buffer to update. If there are not enough, then we will update with\n   * additional steps to only update the chunks of the buffer that are affected by the changelist.\n   */\n  incomingChangeList(changes: InstanceDiff<T>[]) {\n    if (changes.length === 0) {\n      this.diffMode = DiffMode.PARTIAL;\n    } else if (changes.length > this.bufferManager.getInstanceCount() * 0.7) {\n      this.diffMode = DiffMode.FULL;\n    } else {\n      this.diffMode = DiffMode.PARTIAL;\n    }\n\n    if (this.diffMode === DiffMode.PARTIAL) {\n      this.updateInstance = this.updateInstancePartial;\n    } else {\n      this.updateInstance = this.updateInstanceFull;\n    }\n  }\n}\n","import { Instance } from \"../../../instance-provider\";\nimport { Vec4 } from \"../../../math/vector\";\nimport { InstanceDiff } from \"../../../types\";\nimport { BaseDiffProcessor } from \"../base-diff-processor\";\nimport { IInstanceDiffManagerTarget } from \"../instance-diff-manager\";\nimport {\n  isUniformBufferLocation,\n  IUniformBufferLocation\n} from \"./uniform-buffer-manager\";\n\n// This is a mapping of the vector properties as they relate to an array order\nconst EMPTY: number[] = [];\n\n/**\n * Manages diffs for layers that are utilizing the base uniform instancing buffer strategy.\n */\nexport class UniformDiffProcessor<T extends Instance> extends BaseDiffProcessor<\n  T\n> {\n  /**\n   * This processes add operations from changes in the instancing data\n   */\n  addInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster?: IUniformBufferLocation\n  ) {\n    // If the uniform cluster already exists, then we swap over to a change update\n    if (uniformCluster) {\n      manager.changeInstance(manager, instance, EMPTY, uniformCluster);\n    } else {\n      // Otherwise, we DO need to perform an add and we link a Uniform cluster to our instance\n      const uniforms = manager.layer.bufferManager.add(instance);\n\n      if (isUniformBufferLocation(uniforms)) {\n        instance.active = true;\n\n        if (manager.layer.onDiffAdd) {\n          manager.layer.onDiffAdd(instance);\n        }\n\n        manager.updateInstance(manager.layer, instance, uniforms);\n      }\n    }\n  }\n\n  /**\n   * This processes change operations from changes in the instancing data\n   */\n  changeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster?: IUniformBufferLocation\n  ) {\n    // If there is an existing uniform cluster for this instance, then we can update the uniforms\n    if (uniformCluster) {\n      manager.updateInstance(manager.layer, instance, uniformCluster);\n    } else {\n      // If we don't have existing uniforms, then we must remove the instance\n      manager.addInstance(manager, instance, EMPTY, uniformCluster);\n    }\n  }\n\n  /**\n   * This processes remove operations from changes in the instancing data\n   */\n  removeInstance(\n    manager: this,\n    instance: T,\n    _propIds: number[],\n    uniformCluster?: IUniformBufferLocation\n  ) {\n    if (uniformCluster) {\n      // We deactivate the instance so it does not render anymore\n      instance.active = false;\n\n      // Execute the remove hook for the instance on behalf of the layer\n      if (manager.layer.onDiffRemove) {\n        manager.layer.onDiffRemove(instance);\n      }\n\n      // We do one last update on the instance to update to it's deactivated state\n      manager.updateInstance(manager.layer, instance, uniformCluster);\n      // Unlink the instance from the uniform cluster\n      manager.layer.bufferManager.remove(instance);\n    }\n  }\n\n  /**\n   * TODO: We should be updating based on prop ids instead of always updating all props for every change.\n   *\n   * This performs the actual updating of buffers the instance needs to update\n   */\n  updateInstance(\n    layer: IInstanceDiffManagerTarget<T>,\n    instance: T,\n    uniformCluster: IUniformBufferLocation\n  ) {\n    if (instance.active) {\n      const uniforms = uniformCluster.buffer;\n      const uniformRangeStart = uniformCluster.range[0];\n      const instanceData: Vec4[] = uniforms.value;\n      let instanceUniform, value, block, start;\n      let k: number, endk;\n\n      // Loop through the instance attributes and update the uniform cluster with the values\n      // Calculated for the instance\n      for (\n        let i = 0, end = layer.shaderIOInfo.instanceAttributes.length;\n        i < end;\n        ++i\n      ) {\n        instanceUniform = layer.shaderIOInfo.instanceAttributes[i];\n        value = instanceUniform.update(instance);\n        block = instanceData[uniformRangeStart + (instanceUniform.block || 0)];\n        start = instanceUniform.blockIndex;\n\n        if (start === undefined) {\n          continue;\n        }\n\n        // Vec4 updating routine. Makes sure the correct components are updated for the provided values\n        for (k = start, endk = value.length + start; k < endk; ++k) {\n          block[k] = value[k - start];\n        }\n      }\n\n      uniforms.value = instanceData;\n    } else {\n      const uniforms = uniformCluster.buffer;\n      const uniformRangeStart = uniformCluster.range[0];\n      const instanceData: Vec4[] = uniforms.value;\n      let instanceUniform, value, block, start;\n\n      // Only update the _active attribute to ensure it is false. When it is false, there is no\n      // Point to updating any other uniform\n      instanceUniform = layer.shaderIOInfo.activeAttribute;\n      value = instanceUniform.update(instance);\n      block = instanceData[uniformRangeStart + (instanceUniform.block || 0)];\n      start = instanceUniform.blockIndex;\n\n      if (start !== undefined) {\n        // Hyper optimized vector filling routine. It uses properties that are globally scoped\n        // To greatly reduce overhead\n        for (\n          let k: number = start, endk = value.length + start;\n          k < endk;\n          ++k\n        ) {\n          block[k] = value[k - start];\n        }\n      }\n\n      uniforms.value = instanceData;\n    }\n  }\n\n  /**\n   * Right now there is no operations for committing for the uniform manager.\n   */\n  commit() {\n    /** no-op */\n  }\n\n  /**\n   * There are no optimizations available for this processor yet.\n   */\n  incomingChangeList(_changes: InstanceDiff<T>[]) {\n    /** no-op */\n  }\n}\n","import {\n  IMouseInteraction,\n  ISingleTouchInteraction,\n  ITouchInteraction\n} from \"../event-management/types\";\nimport { Instance } from \"../instance-provider/instance\";\nimport { BaseProjection } from \"../math/base-projection\";\nimport {\n  IColorPickingData,\n  IMousePickInfo,\n  ITouchPickInfo,\n  PickType\n} from \"../types\";\nimport { mapGetWithDefault, mapInjectDefault } from \"../util\";\nimport { ILayerProps, Layer } from \"./layer\";\n\n/**\n * This manages mouse gestures broadcast to the layer and handles appropriate actions such as determining\n * how to make the interaction translate to picking events for the layer's instances.\n *\n * Summarized: layer-mouse-events processes and filters events for the Views, this processes those events for the layers\n * and their instances.\n */\nexport class LayerInteractionHandler<\n  T extends Instance,\n  U extends ILayerProps<T>\n> {\n  /** This is the color picking information most recently rendered */\n  colorPicking?: IColorPickingData;\n  /** This tracks the elements that have the mouse currently over them */\n  isMouseOver = new Set<T>();\n  /** This tracks the elements the mouse was down on */\n  isMouseDown = new Set<T>();\n  /** This is the layer the interaction handler manages events for */\n  layer: Layer<T, U>;\n\n  /** Tracks elements that have a touch over them */\n  isTouchOver = new Map<number, Set<T>>();\n  isTouchDown = new Map<number, Set<T>>();\n\n  constructor(layer: Layer<T, U>) {\n    this.layer = layer;\n  }\n\n  /**\n   * Retrieves the color picking instance determined for the procedure.\n   */\n  getColorPickInstance() {\n    if (this.colorPicking && this.layer.picking.type === PickType.SINGLE) {\n      return this.layer.uidToInstance.get(\n        0xffffff - this.colorPicking.nearestColor\n      );\n    }\n\n    return null;\n  }\n\n  /**\n   * Handles mouse down gestures for a layer within a view\n   */\n  handleMouseOver(_view: BaseProjection<any>, _interaction: IMouseInteraction) {\n    // This is the mouse over for the view itself. We should probably just let the mouse over events handle the interactions\n    // With the instances\n  }\n\n  /**\n   * Handles touch down gestures for a layer within a view\n   */\n  handleTouchOver(\n    _view: BaseProjection<any>,\n    _interaction: ITouchInteraction,\n    _touch: ISingleTouchInteraction\n  ) {\n    // This is the touch over for the view itself. We should probably just let the touch over events handle the interactions\n    // With the instances\n  }\n\n  /**\n   * Handles mouse down gestures for a layer within a view\n   */\n  handleMouseDown(view: BaseProjection<any>, interaction: IMouseInteraction) {\n    // This handles interactions for PickType ALL layers\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      const { onMouseDown } = this.layer.props;\n\n      // If we have a listener for either event we should continue to process the event in more detail\n      if (onMouseDown) {\n        const world = view.screenToWorld(interaction.screen.position);\n        const instances: T[] = [];\n\n        if (this.layer.picking.type === PickType.SINGLE) {\n          // Get the instance for the nearest color\n          const instanceForColor = this.getColorPickInstance();\n\n          if (instanceForColor) {\n            instances.push(instanceForColor);\n          }\n        }\n\n        const info: IMousePickInfo<T> = {\n          interaction,\n          instances,\n          layer: this.layer.id,\n          projection: view,\n          screen: interaction.screen.position,\n          world\n        };\n\n        onMouseDown(info);\n\n        // We track all the elements the mouse is currently down on\n        this.isMouseDown.clear();\n        instances.forEach(o => this.isMouseDown.add(o));\n      }\n    }\n  }\n\n  /**\n   * Handles touch events for instances for layers\n   */\n  handleTouchDown(\n    view: BaseProjection<any>,\n    interaction: ITouchInteraction,\n    touch: ISingleTouchInteraction\n  ) {\n    const { onTouchDown, onTouchOver } = this.layer.props;\n\n    // Validate the conditions on the layer justifies having events be processed for the layer\n    if (\n      !this.layer.picking ||\n      this.layer.picking.type === PickType.NONE ||\n      (!onTouchDown && !onTouchOver)\n    ) {\n      return;\n    }\n\n    const world = view.screenToWorld(touch.screen.position);\n    const instances: T[] = [];\n\n    if (this.layer.picking.type === PickType.SINGLE) {\n      // Get the instance for the nearest color\n      const instanceForColor = this.getColorPickInstance();\n\n      if (instanceForColor) {\n        instances.push(instanceForColor);\n      }\n    }\n\n    const info: ITouchPickInfo<T> = {\n      interaction,\n      touch,\n      instances,\n      layer: this.layer.id,\n      projection: view,\n      screen: touch.screen.position,\n      world\n    };\n\n    // Add the instances involved in the touch down to our down state items.\n    // Being down also happens to cause the touch to be in an 'over' state as well\n    // This is more unique to touch as there is not a cursor following the event before the event happens\n    const isTouchDown = mapInjectDefault(\n      this.isTouchDown,\n      touch.touch.touch.identifier,\n      () => new Set()\n    );\n\n    const isTouchOver = mapInjectDefault(\n      this.isTouchOver,\n      touch.touch.touch.identifier,\n      () => new Set()\n    );\n\n    instances.forEach(instance => {\n      isTouchDown.add(instance);\n      isTouchOver.add(instance);\n    });\n\n    // Broadcast the touch over/down event\n    if (onTouchOver) onTouchOver(info);\n    if (onTouchDown) onTouchDown(info);\n  }\n\n  /**\n   * Handles mouse out events for a layer within the view\n   */\n  handleMouseOut(view: BaseProjection<any>, interaction: IMouseInteraction) {\n    // This will fire an instance mouse out for any over instances in the queue since we left the view\n    // Thus no instances shall be considered 'over'\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      const { onMouseOut } = this.layer.props;\n\n      if (onMouseOut) {\n        const world = view.screenToWorld(interaction.screen.position);\n\n        const info: IMousePickInfo<T> = {\n          interaction,\n          instances: Array.from(this.isMouseOver.keys()),\n          layer: this.layer.id,\n          projection: view,\n          screen: interaction.screen.position,\n          world\n        };\n\n        onMouseOut(info);\n      }\n    }\n\n    // We clear as no instances are over anymore\n    this.isMouseOver.clear();\n  }\n\n  /**\n   * Handles touch events that have been dragged off of a view\n   */\n  handleTouchOut(\n    view: BaseProjection<any>,\n    interaction: ITouchInteraction,\n    touch: ISingleTouchInteraction\n  ) {\n    const { onTouchOut } = this.layer.props;\n\n    if (\n      !this.layer.picking ||\n      this.layer.picking.type === PickType.NONE ||\n      !onTouchOut\n    ) {\n      return;\n    }\n\n    const world = view.screenToWorld(touch.screen.position);\n\n    const info: ITouchPickInfo<T> = {\n      interaction,\n      touch,\n      instances: Array.from(this.isMouseOver.keys()),\n      layer: this.layer.id,\n      projection: view,\n      screen: touch.screen.position,\n      world\n    };\n\n    onTouchOut(info);\n\n    // We must clear out ALL touch over state for the touch as we are not even on the view anymore\n    this.isTouchOver.delete(touch.touch.touch.identifier);\n  }\n\n  /**\n   * Handles mouse up gestures for the layer within the provided view\n   */\n  handleMouseUp(view: BaseProjection<any>, interaction: IMouseInteraction) {\n    const { onMouseUp, onMouseUpOutside } = this.layer.props;\n\n    // Check to ensure the layer is configured to accept the events\n    if (\n      !this.layer.picking ||\n      this.layer.picking.type === PickType.NONE ||\n      !onMouseUp\n    ) {\n      return;\n    }\n\n    const world = view.screenToWorld(interaction.screen.position);\n    const instances: T[] = [];\n\n    if (this.layer.picking.type === PickType.SINGLE) {\n      // Get the instance for the nearest color\n      const instanceForColor = this.getColorPickInstance();\n\n      if (instanceForColor) {\n        instances.push(instanceForColor);\n      }\n    }\n\n    let info: IMousePickInfo<T> = {\n      interaction,\n      instances,\n      layer: this.layer.id,\n      projection: view,\n      screen: interaction.screen.position,\n      world\n    };\n\n    // Broadcast the mouse up event to the layers\n    onMouseUp(info);\n    // Now we look to see which of the mouse down instances were NOT in the mouse up instances to detect mouse up\n    // outside events\n    instances.forEach(instance => this.isMouseDown.delete(instance));\n    // If no mouse downs remain, then we simply stop here\n    if (this.isMouseDown.size <= 0 || !onMouseUpOutside) return;\n\n    // Otherwise, broadcast a mouse up outside event for all instances remaining\n    info = {\n      interaction,\n      instances: Array.from(this.isMouseDown.values()),\n      layer: this.layer.id,\n      projection: view,\n      screen: interaction.screen.position,\n      world\n    };\n\n    // Broadcast the mouse up outside event to the layers\n    onMouseUpOutside(info);\n  }\n\n  /**\n   * Handles touch up events that occur over a view\n   */\n  handleTouchUp(\n    view: BaseProjection<any>,\n    interaction: ITouchInteraction,\n    touch: ISingleTouchInteraction\n  ) {\n    const {\n      onTouchUp,\n      onTouchUpOutside,\n      onTouchOut,\n      onTouchAllEnd\n    } = this.layer.props;\n\n    // Check to ensure the layer is configured to accept the events\n    if (\n      !this.layer.picking ||\n      this.layer.picking.type === PickType.NONE ||\n      (!onTouchUp && !onTouchUpOutside && !onTouchOut && !onTouchAllEnd)\n    ) {\n      return;\n    }\n\n    const world = view.screenToWorld(touch.screen.position);\n    const instances: T[] = [];\n\n    if (this.layer.picking.type === PickType.SINGLE) {\n      // Get the instance for the nearest color\n      const instanceForColor = this.getColorPickInstance();\n\n      if (instanceForColor) {\n        instances.push(instanceForColor);\n      }\n    }\n\n    let info: ITouchPickInfo<T> = {\n      interaction,\n      touch,\n      instances,\n      layer: this.layer.id,\n      projection: view,\n      screen: touch.screen.position,\n      world\n    };\n\n    // Broadcast the touch up event to the layers\n    if (onTouchOut) onTouchOut(info);\n    if (onTouchUp) onTouchUp(info);\n\n    // If this is touch down\n    const isTouchDown = mapGetWithDefault(\n      this.isTouchDown,\n      touch.touch.touch.identifier,\n      new Set()\n    );\n    // Now we look to see which of the touch down instances were NOT in the touch up instances to detect touch up\n    // outside events\n    instances.forEach(instance => isTouchDown.delete(instance));\n\n    // If no touch downs remain, then we simply stop here\n    if (isTouchDown.size > 0 && onTouchUpOutside) {\n      // Otherwise, broadcast a touch up outside event for all instances remaining\n      info = {\n        interaction,\n        touch,\n        instances: Array.from(isTouchDown.values()),\n        layer: this.layer.id,\n        projection: view,\n        screen: touch.screen.position,\n        world\n      };\n\n      // Broadcast the mouse up outside event to the layers\n      onTouchUpOutside(info);\n    }\n\n    // Clear the touch down state information\n    this.isTouchDown.delete(touch.touch.touch.identifier);\n\n    // If no more touches are considered down anymore, then we have an all end event\n    if (this.isTouchDown.size <= 0 && onTouchAllEnd) {\n      info = {\n        interaction,\n        touch,\n        instances: [],\n        layer: this.layer.id,\n        projection: view,\n        screen: touch.screen.position,\n        world\n      };\n\n      onTouchAllEnd(info);\n    }\n  }\n\n  /**\n   * Mouse move events on the layer will detect when instances have their item newly over or just moved on\n   */\n  handleMouseMove(view: BaseProjection<any>, interaction: IMouseInteraction) {\n    // This handles interactions for PickType ALL layers\n    const { onMouseOver, onMouseMove, onMouseOut } = this.layer.props;\n\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      // If we have a listener for either event we should continue to process the event in more detail\n      if (onMouseOver || onMouseMove || onMouseOut) {\n        let info: IMousePickInfo<T>;\n        const world = view.screenToWorld(interaction.screen.position);\n        const instances: T[] = [];\n\n        if (this.layer.picking.type === PickType.SINGLE) {\n          // Get the instance for the nearest color\n          const instanceForColor = this.getColorPickInstance();\n\n          if (instanceForColor) {\n            instances.push(instanceForColor);\n          }\n        }\n\n        // MOUSE OUT\n        // First broadcast Mouse out events\n        const isCurrentlyOver = new Set<T>();\n        instances.forEach(o => isCurrentlyOver.add(o));\n\n        // Broadcast the the picking info for all instances that the mouse moved off of\n        if (onMouseOut) {\n          const noLongerOver: T[] = [];\n\n          this.isMouseOver.forEach(o => {\n            if (!isCurrentlyOver.has(o)) {\n              noLongerOver.push(o);\n            }\n          });\n\n          // This is the pick info object we will broadcast from the layer\n          info = {\n            interaction,\n            instances: noLongerOver,\n            layer: this.layer.id,\n            projection: view,\n            screen: interaction.screen.position,\n            world\n          };\n\n          if (noLongerOver.length > 0) onMouseOut(info);\n        }\n\n        // MOUSE OVER\n        // Broadcast the picking info for newly over instances to any of the layers listeners if needed\n        if (onMouseOver) {\n          const notOverInstances = instances.filter(\n            o => !this.isMouseOver.has(o)\n          );\n          info = {\n            interaction,\n            instances: notOverInstances,\n            layer: this.layer.id,\n            projection: view,\n            screen: interaction.screen.position,\n            world\n          };\n\n          if (notOverInstances.length > 0) onMouseOver(info);\n        }\n\n        // MOUSE MOVE\n        // Broadcast the the picking info for all instances that the mouse moved on\n        if (onMouseMove) {\n          // This is the pick info object we will broadcast from the layer\n          info = {\n            interaction,\n            instances,\n            layer: this.layer.id,\n            projection: view,\n            screen: interaction.screen.position,\n            world\n          };\n\n          onMouseMove(info);\n        }\n\n        // We store the current hovered over items as our over item list for next interaction\n        this.isMouseOver = isCurrentlyOver;\n      }\n    }\n  }\n\n  /**\n   * Handles touches that are moving along the screen\n   */\n  handleTouchMove(\n    view: BaseProjection<any>,\n    interaction: ITouchInteraction,\n    touch: ISingleTouchInteraction\n  ) {\n    // This handles interactions for PickType ALL layers\n    const { onTouchOver, onTouchMove, onTouchOut } = this.layer.props;\n\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      // If we have a listener for either event we should continue to process the event in more detail\n      if (onTouchOver || onTouchMove || onTouchOut) {\n        let info: ITouchPickInfo<T>;\n        const world = view.screenToWorld(touch.screen.position);\n        const instances: T[] = [];\n\n        if (this.layer.picking.type === PickType.SINGLE) {\n          // Get the instance for the nearest color\n          const instanceForColor = this.getColorPickInstance();\n\n          if (instanceForColor) {\n            instances.push(instanceForColor);\n          }\n        }\n\n        // Get the current touch over state for the given touch.\n        const isTouchOver = mapGetWithDefault(\n          this.isTouchOver,\n          touch.touch.touch.identifier,\n          new Set()\n        );\n\n        // TOUCH OUT\n        // First broadcast touch out events\n        const isCurrentlyOver = new Set<T>();\n        instances.forEach(o => isCurrentlyOver.add(o));\n\n        // Broadcast the the picking info for all instances that the touch moved off of\n        if (onTouchOut) {\n          const noLongerOver: T[] = [];\n\n          isTouchOver.forEach(o => {\n            if (!isCurrentlyOver.has(o)) {\n              noLongerOver.push(o);\n            }\n          });\n\n          // This is the pick info object we will broadcast from the layer\n          info = {\n            interaction,\n            touch,\n            instances: noLongerOver,\n            layer: this.layer.id,\n            projection: view,\n            screen: touch.screen.position,\n            world\n          };\n\n          if (noLongerOver.length > 0) onTouchOut(info);\n        }\n\n        // TOUCH OVER\n        // Broadcast the picking info for newly over instances to any of the layers listeners if needed\n        if (onTouchOver) {\n          const notOverInstances = instances.filter(o => !isTouchOver.has(o));\n          info = {\n            interaction,\n            touch,\n            instances: notOverInstances,\n            layer: this.layer.id,\n            projection: view,\n            screen: touch.screen.position,\n            world\n          };\n\n          if (notOverInstances.length > 0) onTouchOver(info);\n        }\n\n        // TOUCH MOVE\n        // Broadcast the the picking info for all instances that the touch moved on\n        if (onTouchMove) {\n          // This is the pick info object we will broadcast from the layer\n          info = {\n            interaction,\n            touch,\n            instances,\n            layer: this.layer.id,\n            projection: view,\n            screen: touch.screen.position,\n            world\n          };\n\n          onTouchMove(info);\n        }\n\n        // We store the current hovered over items as our over item list for next interaction\n        this.isMouseOver = isCurrentlyOver;\n      }\n    }\n  }\n\n  /**\n   * Handles click gestures on the layer within a view\n   */\n  handleMouseClick(view: BaseProjection<any>, interaction: IMouseInteraction) {\n    // This handles interactions for PickType ALL layers\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      const { onMouseClick } = this.layer.props;\n\n      // If we have a listener for either event we should continue to process the event in more detail\n      if (onMouseClick) {\n        const world = view.screenToWorld(interaction.screen.position);\n        const instances: T[] = [];\n\n        if (this.layer.picking.type === PickType.SINGLE) {\n          // Get the instance for the nearest color\n          const instanceForColor = this.getColorPickInstance();\n\n          if (instanceForColor) {\n            instances.push(instanceForColor);\n          }\n        }\n\n        const info: IMousePickInfo<T> = {\n          interaction,\n          instances,\n          layer: this.layer.id,\n          projection: view,\n          screen: interaction.screen.position,\n          world\n        };\n\n        onMouseClick(info);\n      }\n    }\n  }\n\n  /**\n   * Handles tap interactions with the view\n   */\n  handleTap(\n    view: BaseProjection<any>,\n    interaction: ITouchInteraction,\n    touch: ISingleTouchInteraction\n  ) {\n    // This handles interactions for PickType ALL layers\n    if (this.layer.picking && this.layer.picking.type !== PickType.NONE) {\n      const { onTap } = this.layer.props;\n\n      // If we have a listener for either event we should continue to process the event in more detail\n      if (onTap) {\n        const world = view.screenToWorld(touch.screen.position);\n        const instances: T[] = [];\n\n        if (this.layer.picking.type === PickType.SINGLE) {\n          // Get the instance for the nearest color\n          const instanceForColor = this.getColorPickInstance();\n\n          if (instanceForColor) {\n            instances.push(instanceForColor);\n          }\n        }\n\n        const info: ITouchPickInfo<T> = {\n          interaction,\n          touch,\n          instances,\n          layer: this.layer.id,\n          projection: view,\n          screen: touch.screen.position,\n          world\n        };\n\n        onTap(info);\n      }\n    }\n  }\n\n  /**\n   * Handles drag gestures for the layer within the view\n   */\n  handleMouseDrag(_view: BaseProjection<any>, _interaction: IMouseInteraction) {\n    // We probably should not broadcast drag events for the sake of instances. Instance dragging should be handled on\n    // An instance by instance basis rather than coming from the view's gestures\n  }\n}\n","import { SimpleEventHandler } from \"../../event-management/simple-event-handler\";\nimport {\n  IMouseInteraction,\n  ISingleTouchInteraction,\n  ITouchInteraction\n} from \"../../event-management/types\";\nimport {\n  add3,\n  AutoEasingMethod,\n  BaseProjection,\n  copy3,\n  divide2,\n  divide3,\n  length2,\n  max3,\n  min3,\n  scale3,\n  subtract2,\n  subtract3,\n  Vec2,\n  Vec3,\n  vec3\n} from \"../../math\";\nimport { Bounds } from \"../../math/primitives/bounds\";\nimport { IViewProps, View } from \"../../surface/view\";\nimport { touchesContainsStartView, touchesHasStartView, uid } from \"../../util\";\nimport { Camera2D } from \"./camera-2d\";\n\n/**\n * Anchor options for the controller\n */\nexport enum CameraBoundsAnchor {\n  TOP_LEFT,\n  TOP_MIDDLE,\n  TOP_RIGHT,\n  MIDDLE_LEFT,\n  MIDDLE,\n  MIDDLE_RIGHT,\n  BOTTOM_LEFT,\n  BOTTOM_MIDDLE,\n  BOTTOM_RIGHT\n}\n\n/**\n * This represents how the camera should be bounded in the world space. This gives enough information\n * to handle all cases of bounding, including screen padding and anchoring for cases where the viewed space\n * is smaller than the view.\n */\nexport interface ICameraBoundsOptions {\n  /** How the bounded world space should anchor itself within the view when the projected world space to the screen is smaller than the view */\n  anchor: CameraBoundsAnchor;\n  /** Minimum settings the camera can scale to */\n  scaleMin?: Vec3;\n  /** Maximum settings the camera can scale to */\n  scaleMax?: Vec3;\n  /** The actual screen pixels the bounds can exceed when the camera's view has reached the bounds of the world */\n  screenPadding: { left: number; right: number; top: number; bottom: number };\n  /** This is the view for which the bounds applies towards */\n  view: string;\n  /** The area the camera is bound inside */\n  worldBounds: Bounds<any>;\n}\n\nexport interface IBasicCamera2DControllerOptions {\n  /** Takes in the options to be used for creating a new ViewBounds object on this controller. */\n  bounds?: ICameraBoundsOptions;\n  /** This is the camera this controller will manipulate */\n  camera: Camera2D;\n  /** When this is set to true, the start view can be targetted even when behind other views */\n  ignoreCoverViews?: boolean;\n  /**\n   * This is a handler for when the camera has applied changes to the visible range of what is seen.\n   * Which most likely means offset or scale has been altered.\n   */\n  onRangeChanged?(camera: Camera2D, projections: BaseProjection<any>): void;\n  /**\n   * This provides a control to filter panning that will be applied to the camera. The input and\n   * output of this will be the delta value to be applied.\n   */\n  panFilter?(\n    offset: [number, number, number],\n    view: View<IViewProps>,\n    allViews: View<IViewProps>[]\n  ): [number, number, number];\n  /**\n   * This adjusts how fast scaling is applied from the mouse wheel\n   */\n  scaleFactor?: number;\n  /**\n   * This provides a control to filter scaling that will be applied to the camera. The input and\n   * output of this will be the delta value to be applied.\n   */\n  scaleFilter?(\n    scale: [number, number, number],\n    view: View<IViewProps>,\n    allViews: View<IViewProps>[]\n  ): [number, number, number];\n  /**\n   * This is the view that MUST be the start view from the events.\n   * If not provided, then dragging anywhere will adjust the camera.\n   * This MUST be set for onRangeChange to broadcast animated camera movements.\n   */\n  startView?: string | string[];\n  /** When this is set, it will require two fingers to be down at minimum to pan the camera */\n  twoFingerPan?: boolean;\n  /**\n   * This specifies whether a view can be scrolled by wheel\n   * If this is not specified or set false, the view can be zoomed by wheel\n   */\n  wheelShouldScroll?: boolean;\n}\n\n/**\n * This provides some very basic common needs for a camera control system. This is not a total solution\n * for every scenario. This should just often handle most basic needs.\n */\nexport class BasicCamera2DController extends SimpleEventHandler {\n  /** Unique identifier of this controller */\n  get uid() {\n    return this._uid;\n  }\n  private _uid = uid();\n  /**\n   * If total bounds of worldbounds + screenpadding is smaller\n   * than width or height of view, anchor dictates placement.\n   */\n  bounds?: ICameraBoundsOptions;\n  /** This is the camera that this controller will manipulate */\n  get camera() {\n    return this._camera;\n  }\n  private _camera: Camera2D;\n  /** When this is set to true, the start view can be targetted even when behind other views */\n  ignoreCoverViews?: boolean;\n  /** Informative property indicating the controller is panning the chart or not */\n  isPanning: boolean = false;\n  /** Informative property indicationt he controller is scaling via touch gesture */\n  isScaling: boolean = false;\n  /** This is the filter applied to panning operations */\n  private panFilter = (\n    offset: [number, number, number],\n    _view: View<IViewProps>,\n    _allViews: View<IViewProps>[]\n  ) => offset;\n  /** The rate scale is adjusted with the mouse wheel */\n  scaleFactor: number;\n  /** This is the filter applied to tscaling operations */\n  private scaleFilter = (\n    scale: [number, number, number],\n    _view: View<IViewProps>,\n    _allViews: View<IViewProps>[]\n  ) => scale;\n  /** The view that must be the start or focus of the interactions in order for the interactions to occur */\n  startViews: string[] = [];\n  /** Whether a view can be scrolled by wheel */\n  wheelShouldScroll: boolean;\n  /** Indicates if panning will happen with two or more fingers down instead of one */\n  twoFingerPan: boolean;\n  /** Stores the views this controller has flagged for optimizing */\n  private optimizedViews = new Set<View<IViewProps>>();\n  /** The animation used to immediately position the camera */\n  private cameraImmediateAnimation = AutoEasingMethod.immediate<Vec3>(0);\n  /** This is the identifier of the primary touch controlling panning */\n  private targetTouches = new Set<number>();\n\n  /**\n   * If an unconvered start view is not available, this is the next available covered view, if present\n   */\n  private coveredStartView: View<IViewProps>;\n  /**\n   * Callback for when the range has changed for the camera in a view\n   */\n  private onRangeChanged = (\n    _camera: Camera2D,\n    _targetView: BaseProjection<any>\n  ) => {\n    /* no-op */\n  };\n\n  /**\n   * This flag is set to true when a start view is targetted on mouse down even if it is not\n   * the top most view.\n   */\n  private startViewDidStart: boolean = false;\n\n  constructor(options: IBasicCamera2DControllerOptions) {\n    super({});\n\n    if (options.bounds) {\n      this.setBounds(options.bounds);\n    }\n\n    this._camera = options.camera;\n    this.scaleFactor = options.scaleFactor || 1000.0;\n    this.ignoreCoverViews = options.ignoreCoverViews || false;\n    this.twoFingerPan = options.twoFingerPan || false;\n\n    if (options.startView) {\n      if (Array.isArray(options.startView)) {\n        this.startViews = options.startView;\n        this._camera.control2D.setViewChangeHandler(\n          this.handleCameraViewChange\n        );\n      } else {\n        this.startViews = [options.startView];\n        this._camera.control2D.setViewChangeHandler(\n          this.handleCameraViewChange\n        );\n      }\n    }\n\n    this.panFilter = options.panFilter || this.panFilter;\n    this.scaleFilter = options.scaleFilter || this.scaleFilter;\n    this.onRangeChanged = options.onRangeChanged || this.onRangeChanged;\n\n    if (options.wheelShouldScroll) {\n      this.wheelShouldScroll = options.wheelShouldScroll;\n    }\n  }\n\n  /**\n   * Corrects camera offset to respect the current bounds and anchor.\n   */\n  applyBounds = () => {\n    if (this.bounds && this.camera) {\n      const targetView = this.getView(this.bounds.view);\n      this.applyScaleBounds();\n\n      // Next bound the positioning\n      if (targetView) {\n        this.camera.control2D.getOffset()[0] = this.boundsHorizontalOffset(\n          targetView,\n          this.bounds\n        );\n\n        this.camera.control2D.getOffset()[1] = this.boundsVerticalOffset(\n          targetView,\n          this.bounds\n        );\n      }\n    }\n  };\n\n  /**\n   * Corrects camera scale to respect the current bounds and anchor.\n   */\n  applyScaleBounds = () => {\n    if (this.camera && this.bounds) {\n      // First bound the scaling\n      if (this.bounds.scaleMin) {\n        this.camera.control2D.setScale(\n          max3(this.camera.control2D.getScale(), this.bounds.scaleMin)\n        );\n      }\n\n      if (this.bounds.scaleMax) {\n        this.camera.control2D.setScale(\n          min3(this.camera.control2D.getScale(), this.bounds.scaleMax)\n        );\n      }\n    }\n  };\n\n  /**\n   * Calculation for adhering to an anchor - x-axis offset only.\n   */\n  anchoredByBoundsHorizontal(\n    targetView: View<IViewProps>,\n    bounds: ICameraBoundsOptions\n  ) {\n    switch (bounds.anchor) {\n      case CameraBoundsAnchor.TOP_LEFT:\n      case CameraBoundsAnchor.MIDDLE_LEFT:\n      case CameraBoundsAnchor.BOTTOM_LEFT:\n        return -(\n          bounds.worldBounds.left -\n          bounds.screenPadding.left / this.camera.control2D.getScale()[0]\n        );\n\n      case CameraBoundsAnchor.TOP_MIDDLE:\n      case CameraBoundsAnchor.MIDDLE:\n      case CameraBoundsAnchor.BOTTOM_MIDDLE:\n        return -(\n          bounds.worldBounds.right -\n          bounds.worldBounds.width / 2 -\n          0.5 *\n            ((targetView.screenBounds.width + bounds.screenPadding.right) /\n              this.camera.control2D.getScale()[0])\n        );\n\n      case CameraBoundsAnchor.TOP_RIGHT:\n      case CameraBoundsAnchor.MIDDLE_RIGHT:\n      case CameraBoundsAnchor.BOTTOM_RIGHT:\n        return -(\n          bounds.worldBounds.right -\n          (targetView.screenBounds.width - bounds.screenPadding.right) /\n            this.camera.control2D.getScale()[0]\n        );\n    }\n  }\n\n  /**\n   * Calculation for adhering to an anchor - y-axis offset only.\n   */\n  anchoredByBoundsVertical(\n    targetView: View<IViewProps>,\n    bounds: ICameraBoundsOptions\n  ) {\n    switch (bounds.anchor) {\n      case CameraBoundsAnchor.TOP_LEFT:\n      case CameraBoundsAnchor.TOP_MIDDLE:\n      case CameraBoundsAnchor.TOP_RIGHT:\n        return -(\n          bounds.worldBounds.top -\n          bounds.screenPadding.top / this.camera.control2D.getScale()[1]\n        );\n\n      case CameraBoundsAnchor.MIDDLE_LEFT:\n      case CameraBoundsAnchor.MIDDLE:\n      case CameraBoundsAnchor.MIDDLE_RIGHT:\n        return -(\n          bounds.worldBounds.bottom -\n          bounds.worldBounds.height / 2 -\n          0.5 *\n            ((targetView.screenBounds.height + bounds.screenPadding.bottom) /\n              this.camera.control2D.getScale()[1])\n        );\n\n      case CameraBoundsAnchor.BOTTOM_LEFT:\n      case CameraBoundsAnchor.BOTTOM_MIDDLE:\n      case CameraBoundsAnchor.BOTTOM_RIGHT:\n        return -(\n          bounds.worldBounds.bottom -\n          (targetView.screenBounds.height - bounds.screenPadding.bottom) /\n            this.camera.control2D.getScale()[1]\n        );\n    }\n  }\n\n  /**\n   * Returns offset on x-axis due to current bounds and anchor.\n   */\n  boundsHorizontalOffset(\n    targetView: View<IViewProps>,\n    bounds: ICameraBoundsOptions\n  ) {\n    const worldTLinScreenSpace = targetView.projection.worldToScreen([\n      bounds.worldBounds.left,\n      bounds.worldBounds.top\n    ]);\n    const worldBRinScreenSpace = targetView.projection.worldToScreen([\n      bounds.worldBounds.right,\n      bounds.worldBounds.bottom\n    ]);\n\n    const widthDifference =\n      worldBRinScreenSpace[0] -\n      worldTLinScreenSpace[0] +\n      bounds.screenPadding.left +\n      bounds.screenPadding.right -\n      targetView.screenBounds.width;\n\n    // If the worldBounds are smaller than the screenBounds,\n    // We offset according to the anchoring\n    if (widthDifference < 0) {\n      return this.anchoredByBoundsHorizontal(targetView, bounds);\n    }\n\n    if (\n      worldBRinScreenSpace[0] <\n      targetView.screenBounds.right - bounds.screenPadding.right\n    ) {\n      return (\n        -bounds.worldBounds.right +\n        (targetView.screenBounds.width - bounds.screenPadding.right) /\n          this.camera.control2D.getScale()[0]\n      );\n    }\n\n    if (\n      worldTLinScreenSpace[0] >\n      targetView.screenBounds.left + bounds.screenPadding.left\n    ) {\n      return (\n        -bounds.worldBounds.left +\n        bounds.screenPadding.left / this.camera.control2D.getScale()[0]\n      );\n    }\n\n    return this.camera.control2D.getOffset()[0];\n  }\n\n  /**\n   * Returns offset on y-axis due to current bounds and anchor.\n   */\n  boundsVerticalOffset(\n    targetView: View<IViewProps>,\n    bounds: ICameraBoundsOptions\n  ) {\n    const worldTLinScreenSpace = targetView.projection.worldToScreen([\n      bounds.worldBounds.left,\n      bounds.worldBounds.top\n    ]);\n    const worldBRinScreenSpace = targetView.projection.worldToScreen([\n      bounds.worldBounds.right,\n      bounds.worldBounds.bottom\n    ]);\n\n    const heightDifference =\n      worldBRinScreenSpace[1] -\n      worldTLinScreenSpace[1] +\n      bounds.screenPadding.top +\n      bounds.screenPadding.bottom -\n      targetView.screenBounds.height;\n\n    // If the viewBounds are larger than the screenBounds,\n    // We offset according to the anchoring\n    if (heightDifference < 0) {\n      return this.anchoredByBoundsVertical(targetView, bounds);\n    }\n\n    if (\n      worldBRinScreenSpace[1] <\n      targetView.screenBounds.bottom - bounds.screenPadding.bottom\n    ) {\n      return (\n        -bounds.worldBounds.bottom +\n        (targetView.screenBounds.height - bounds.screenPadding.bottom) /\n          this.camera.control2D.getScale()[1]\n      );\n    }\n\n    if (\n      worldTLinScreenSpace[1] >\n      targetView.screenBounds.top + bounds.screenPadding.top\n    ) {\n      return (\n        -bounds.worldBounds.top +\n        bounds.screenPadding.top / this.camera.control2D.getScale()[0]\n      );\n    }\n\n    return this.camera.control2D.getOffset()[1];\n  }\n\n  private canStart(viewId: string) {\n    return (\n      this.startViews.length === 0 ||\n      (this.startViews && this.startViews.indexOf(viewId) > -1) ||\n      (this.startViewDidStart && this.ignoreCoverViews)\n    );\n  }\n\n  /**\n   * Centers the camera on a position. Must provide a reference view.\n   */\n  centerOn(viewId: string, position: Vec3) {\n    if (!this.camera.control2D.surface) return;\n\n    const viewBounds = this.camera.control2D.surface.getViewSize(viewId);\n    if (!viewBounds) return;\n    const midScreen: Vec3 = [viewBounds.width / 2, viewBounds.height / 2, 0];\n    const fromScreenCenter: Vec3 = subtract3(\n      position,\n      divide3(midScreen, this.camera.control2D.getScale())\n    );\n\n    const newOffset = scale3(fromScreenCenter, -1);\n\n    this.setOffset(viewId, newOffset);\n  }\n\n  /**\n   * Performs the panning operation for the camera\n   *\n   * @param allViews This is all of the related views under the event interactions\n   * @param relativeView This is the view that performs the projections related to the operation\n   * @param allViews All the views associated with the operation or event interaction\n   * @param delta This is the amount of panning being requested to happen\n   */\n  private doPan(\n    allViews: View<IViewProps>[],\n    relativeView: View<IViewProps>,\n    delta: [number, number]\n  ) {\n    let pan: Vec3 = vec3(divide2(delta, this.camera.control2D.getScale()), 0);\n\n    if (this.panFilter) {\n      pan = this.panFilter(pan, relativeView, allViews);\n    }\n\n    this.camera.control2D.getOffset()[0] += pan[0];\n    this.camera.control2D.getOffset()[1] += pan[1];\n\n    // Add additional correction for bounds\n    this.applyBounds();\n    // Broadcast the change occurred\n    this.onRangeChanged(this.camera, relativeView.projection);\n    // Add additional correction for bounds\n    this.applyBounds();\n    // Indicate the camera needs a refresh\n    this.camera.control2D.update();\n  }\n\n  /**\n   * Scales the camera relative to a point and a view.\n   *\n   * @param focalPoint The point the scaling happens around\n   * @param targetView The relative view this operation happens in relation to\n   * @param deltaScale The amount of scaling per axis that should happen\n   */\n  private doScale(\n    focalPoint: Vec2,\n    targetView: View<IViewProps>,\n    allViews: View<IViewProps>[],\n    deltaScale: Vec3\n  ) {\n    const beforeZoom = targetView.projection.screenToWorld(focalPoint);\n    const currentZoomX = this.camera.control2D.getScale()[0] || 1.0;\n    const currentZoomY = this.camera.control2D.getScale()[1] || 1.0;\n\n    if (this.scaleFilter) {\n      deltaScale = this.scaleFilter(deltaScale, targetView, allViews);\n    }\n\n    this.camera.control2D.getScale()[0] = currentZoomX + deltaScale[0];\n    this.camera.control2D.getScale()[1] = currentZoomY + deltaScale[1];\n\n    // Ensure the new scale values are within bounds before attempting to correct offsets\n    this.applyScaleBounds();\n\n    const afterZoom = targetView.projection.screenToWorld(focalPoint);\n    const deltaZoom = subtract2(beforeZoom, afterZoom);\n    this.camera.control2D.getOffset()[0] -= deltaZoom[0];\n    this.camera.control2D.getOffset()[1] -= deltaZoom[1];\n\n    // Add additional correction for bounds\n    this.applyBounds();\n    // Broadcast the change occurred\n    this.onRangeChanged(this.camera, targetView.projection);\n    // Add additional correction for bounds\n    this.applyBounds();\n\n    // Make sure the camera updates\n    this.camera.control2D.update();\n    // Set the immediate animation AFTER setting so we don't get the offset to immediately jump\n    // to the end\n    this.camera.control2D.animation = this.cameraImmediateAnimation;\n  }\n\n  /**\n   * This filters a set of touches to be touches that had a valid starting view interaction.\n   */\n  filterTouchesByValidStart(touches: ISingleTouchInteraction[]) {\n    // If we ignore cover views, then the touches only have to contain a start view upon touch down\n    if (this.ignoreCoverViews) {\n      return touches.filter(touchesContainsStartView(this.startViews));\n    }\n\n    // Otherwise, the start touch has to be the primary start view\n    else {\n      return touches.filter(touchesHasStartView(this.startViews));\n    }\n  }\n\n  /**\n   * Finds a view within the event that matches a start view even if the view is covered by other views at the event's\n   * interaction point.\n   */\n  private findCoveredStartView(e: IMouseInteraction) {\n    const found = e.target.views.find(\n      under => this.startViews.indexOf(under.view.id) > -1\n    );\n    this.startViewDidStart = Boolean(found);\n\n    if (found) {\n      this.coveredStartView = found.view;\n    }\n  }\n\n  /**\n   * Evaluates the world bounds the specified view is observing\n   *\n   * @param viewId The id of the view when the view was generated when the surface was made\n   */\n  getRange(viewId: string): Bounds<never> {\n    /** Get the projections for the provided view */\n    const projection = this.getProjection(viewId);\n    /** Get the bounds on the screen for the indicated view */\n    const screenBounds = this.getViewScreenBounds(viewId);\n\n    // Make sure we have a valid projection and screen bounds to make the adjustment\n    if (projection && screenBounds) {\n      /** Get the current viewed world bounds of the view */\n      const topLeft = projection.screenToWorld([\n        screenBounds.x,\n        screenBounds.y\n      ]);\n      const bottomRight = projection.screenToWorld([\n        screenBounds.right,\n        screenBounds.bottom\n      ]);\n\n      return new Bounds({\n        height: bottomRight[1] - topLeft[1],\n        width: bottomRight[0] - topLeft[0],\n        x: topLeft[0],\n        y: topLeft[1]\n      });\n    }\n\n    return new Bounds({ x: 0, y: 0, width: 1, height: 1 });\n  }\n\n  private getTargetView(e: IMouseInteraction) {\n    // If we have a start view and we do not ignore covering views,\n    // Then our target view is the view we started with\n    if (this.startViews && !this.ignoreCoverViews) {\n      return e.target.view;\n    } else {\n      // Otherwise, we use the covered start view\n      return this.coveredStartView;\n    }\n  }\n\n  /**\n   * Used to aid in handling the pan effect and determine the contextual view targetted.\n   */\n  handleMouseDown(e: IMouseInteraction) {\n    if (this.startViews) {\n      // We look for valid covered views on mouse down so dragging will work\n      this.findCoveredStartView(e);\n\n      // If this is a valid start view, then we enter a panning state with the mouse down\n      if (e.start) {\n        this.isPanning = this.canStart(e.start.view.id) || this.isPanning;\n      }\n    }\n  }\n\n  /**\n   * Aids in understanding how the user is interacting with the views. If a single touch is present, we're panning.\n   * If multiple touches are present, we're panning and we're zooming\n   */\n  handleTouchDown(e: ITouchInteraction) {\n    if (this.startViews) {\n      const validTouches = this.filterTouchesByValidStart(e.allTouches);\n\n      if (this.twoFingerPan) {\n        if (validTouches.length > 1) {\n          this.isPanning = true;\n        }\n      } else {\n        if (validTouches.length > 0) {\n          this.isPanning = true;\n        }\n      }\n\n      if (validTouches.length > 1) {\n        this.isScaling = true;\n      }\n\n      for (let i = 0, iMax = validTouches.length; i < iMax; ++i) {\n        const touch = validTouches[i];\n        this.targetTouches.add(touch.touch.touch.identifier);\n      }\n    }\n  }\n\n  /**\n   * Used to aid in handling the pan effect. Stops panning operations when mouse is up.\n   */\n  handleMouseUp(_e: IMouseInteraction) {\n    this.startViewDidStart = false;\n    this.isPanning = false;\n    this.optimizedViews.forEach(view => (view.optimizeRendering = false));\n    this.optimizedViews.clear();\n  }\n\n  /**\n   * Used to stop panning and scaling effects\n   */\n  handleTouchUp(e: ITouchInteraction) {\n    e.touches.forEach(touch => {\n      this.targetTouches.delete(touch.touch.touch.identifier);\n\n      if (this.targetTouches.size <= 0) {\n        this.startViewDidStart = false;\n        this.isPanning = false;\n        this.optimizedViews.forEach(view => (view.optimizeRendering = false));\n        this.optimizedViews.clear();\n      }\n    });\n\n    this.isPanning = false;\n    this.isScaling = false;\n\n    if (this.targetTouches.size > 0) {\n      this.isPanning = true;\n    }\n\n    if (this.targetTouches.size > 1) {\n      this.isScaling = true;\n    }\n  }\n\n  /**\n   * Used to stop panning and scaling effects when touches are forcibly ejected from existence.\n   */\n  handleTouchCancelled(e: ITouchInteraction) {\n    e.touches.forEach(touch => {\n      this.targetTouches.delete(touch.touch.touch.identifier);\n\n      if (this.targetTouches.size <= 0) {\n        this.startViewDidStart = false;\n        this.isPanning = false;\n        this.optimizedViews.forEach(view => (view.optimizeRendering = false));\n        this.optimizedViews.clear();\n      }\n    });\n\n    this.isPanning = false;\n    this.isScaling = false;\n\n    if (this.targetTouches.size > 0) {\n      this.isPanning = true;\n    }\n\n    if (this.targetTouches.size > 1) {\n      this.isScaling = true;\n    }\n  }\n\n  /**\n   * Applies a panning effect by adjusting the camera's offset.\n   */\n  handleDrag(e: IMouseInteraction) {\n    if (e.start) {\n      if (this.canStart(e.start.view.id)) {\n        e.target.views.forEach(view => {\n          view.view.optimizeRendering = true;\n          this.optimizedViews.add(view.view);\n        });\n\n        // Panning the camera will always be immediate\n        this.doPan(\n          e.target.views.map(v => v.view),\n          e.start.view,\n          e.mouse.deltaPosition\n        );\n        // Set the immediate animation AFTER setting so we don't get the offset to immediately jump\n        // to the end\n        this.camera.control2D.animation = this.cameraImmediateAnimation;\n      }\n    }\n  }\n\n  /**\n   * Applies panning effect from single or multitouch interaction.\n   */\n  handleTouchDrag(e: ITouchInteraction) {\n    const validTouches = this.filterTouchesByValidStart(e.allTouches);\n\n    if (validTouches.length > 0 && this.isPanning) {\n      for (let i = 0, iMax = validTouches.length; i < iMax; ++i) {\n        const targetTouch = validTouches[i];\n\n        targetTouch.target.views.forEach(view => {\n          view.view.optimizeRendering = true;\n          this.optimizedViews.add(view.view);\n        });\n      }\n\n      // The relative view will be the view that was touched first.\n      // We also gather all relatedviews during this search.\n      const allViews = new Set<View<IViewProps>>();\n      const firstTouch = validTouches.reduce((p, n) => {\n        for (let i = 0, iMax = n.target.views.length; i < iMax; ++i) {\n          const v = n.target.views[i];\n          allViews.add(v.view);\n        }\n\n        return n.touch.startTime < p.touch.startTime ? n : p;\n      }, validTouches[0]);\n\n      const relativeView = firstTouch.start.view;\n\n      if (this.isPanning) {\n        // Panning the camera will always be immediate\n        this.doPan(\n          Array.from(allViews.values()),\n          relativeView,\n          e.multitouch.centerDelta(validTouches)\n        );\n        // Set the immediate animation AFTER setting so we don't get the offset to immediately jump\n        // to the end\n        this.camera.control2D.animation = this.cameraImmediateAnimation;\n      }\n\n      // Now we handle the magic of pinch to zoom. To make this 'feel' right the gesture needs to scale the surface so\n      // that (in the case of two fingers) the fingers will remain on the world coordinates of what they were touching\n      // throughout the scaling experience.\n      if (this.isScaling) {\n        // We must get the centroid of the touches for the current event\n        const currentWorldCenter = e.multitouch.center(validTouches);\n\n        // We must also calculate the current frame's distance from the centroid to compare against the previous frame's\n        const currentCenterToTouch = subtract2(\n          validTouches[0].touch.currentPosition,\n          currentWorldCenter\n        );\n\n        // We must get the centroid of the touches for the previous known event\n        const previousWorldCenter = subtract2(\n          currentWorldCenter,\n          e.multitouch.centerDelta(validTouches)\n        );\n\n        // We must now calculate how far our touch in the previous frame was from our current frame\n        const previousCenterToTouch = subtract2(\n          validTouches[0].touch.previousPosition,\n          previousWorldCenter\n        );\n\n        // This is how much scaling it takes to get from the previous touch to the current touch relative to the vectors\n        // per axis\n        const scaleToCurrentTouch =\n          length2(currentCenterToTouch) / length2(previousCenterToTouch);\n\n        const deltaScale: Vec3 = [\n          scaleToCurrentTouch * this.camera.scale2D[0] - this.camera.scale2D[0],\n          scaleToCurrentTouch * this.camera.scale2D[1] - this.camera.scale2D[1],\n          0\n        ];\n\n        if (scaleToCurrentTouch !== 1) {\n          this.doScale(\n            currentWorldCenter,\n            relativeView,\n            Array.from(allViews.values()),\n            deltaScale\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Applies a scaling effect to the camera for mouse wheel events\n   */\n  handleWheel(e: IMouseInteraction) {\n    // Every mouse wheel event must look to see if it's over a valid covered start view\n    this.findCoveredStartView(e);\n\n    if (this.canStart(e.target.view.id)) {\n      if (this.wheelShouldScroll) {\n        const deltaPosition: [number, number] = [\n          -e.mouse.wheel.delta[0],\n          e.mouse.wheel.delta[1]\n        ];\n\n        if (e.start) {\n          this.doPan(\n            e.target.views.map(v => v.view),\n            e.start.view,\n            deltaPosition\n          );\n        }\n      } else {\n        const currentZoomX = this.camera.control2D.getScale()[0] || 1.0;\n        const currentZoomY = this.camera.control2D.getScale()[1] || 1.0;\n        const targetView = this.getTargetView(e);\n\n        const deltaScale: [number, number, number] = [\n          (e.mouse.wheel.delta[1] / this.scaleFactor) * currentZoomX,\n          (e.mouse.wheel.delta[1] / this.scaleFactor) * currentZoomY,\n          1\n        ];\n\n        this.doScale(\n          e.screen.position,\n          targetView,\n          e.target.views.map(v => v.view),\n          deltaScale\n        );\n      }\n    }\n  }\n\n  /**\n   * Handles changes broadcasted by the camera\n   */\n  private handleCameraViewChange = (cam: Camera2D, viewId: string) => {\n    if (viewId !== this.startViews[0]) return;\n    const projections = this.surface.getProjections(viewId);\n    if (!projections) return;\n    this.onRangeChanged(cam, projections);\n  };\n\n  /**\n   * Retrieves the current pan of the controlled camera\n   */\n  get pan(): Vec3 {\n    return this.camera.control2D.offset;\n  }\n\n  /**\n   * Retrieves the current scale of the camera\n   */\n  get scale(): Vec3 {\n    return this.camera.control2D.getScale();\n  }\n\n  /**\n   * Sets bounds applicable to the supplied view.\n   * If no view is supplied, it uses the first in the startViews array\n   */\n  setBounds(bounds: ICameraBoundsOptions) {\n    this.bounds = bounds;\n    this.applyBounds();\n  }\n\n  /**\n   * Tells the controller to set an explicit offset for the camera.\n   * Must provide a reference view.\n   */\n  setOffset(viewId: string, offset: Vec3) {\n    const startOffset = copy3(this.camera.control2D.offset);\n\n    this.camera.control2D.getOffset()[0] = offset[0];\n    this.camera.control2D.getOffset()[1] = offset[1];\n    this.camera.control2D.getOffset()[2] = offset[2];\n\n    // Add additional correction for bounds\n    this.applyBounds();\n\n    // Broadcast the change occurred\n    if (this.camera.control2D.surface) {\n      const projections = this.camera.control2D.surface.getProjections(viewId);\n\n      if (projections) {\n        this.onRangeChanged(this.camera, projections);\n      }\n    }\n\n    // Add additional correction for bounds\n    this.applyBounds();\n    const newOffset = copy3(this.camera.control2D.getOffset());\n\n    const currentAnimation = this.camera.control2D.animation;\n    this.camera.control2D.setOffset(startOffset);\n    this.camera.control2D.animation = this.cameraImmediateAnimation;\n    this.camera.control2D.setOffset(newOffset);\n    this.camera.control2D.animation = currentAnimation;\n  }\n\n  /**\n   * This lets you set the visible range of a view based on the view's camera. This will probably not work\n   * as expected if the view indicated and this controller do not share the same camera.\n   *\n   * @param viewId The id of the view when the view was generated when the surface was made\n   */\n  setRange(newWorld: Bounds<{}>, viewId: string) {\n    /** Get the projections for the provided view */\n    const projection = this.getProjection(viewId);\n    /** Get the bounds on the screen for the indicated view */\n    const screenBounds = this.getViewScreenBounds(viewId);\n    /** Get the view the range is being applied towards */\n    const view = this.getView(viewId);\n\n    // Make sure we have a valid projection and screen bounds to make the adjustment\n    if (projection && screenBounds && view) {\n      const deltaScale = subtract3(\n        [\n          screenBounds.width / newWorld.width,\n          screenBounds.height / newWorld.height,\n          1\n        ],\n        this.camera.control2D.getScale()\n      );\n\n      this.camera.control2D.setScale(\n        add3(\n          this.camera.control2D.getScale(),\n          this.scaleFilter(deltaScale, view, [view])\n        )\n      );\n\n      const deltaPan = subtract3(\n        [-newWorld.x, -newWorld.y, 0],\n        this.camera.control2D.offset\n      );\n\n      this.camera.control2D.setOffset(\n        add3(\n          this.camera.control2D.offset,\n          this.scaleFilter(deltaPan, view, [view])\n        )\n      );\n\n      // Bound the camera to the specified bounding range\n      this.applyBounds();\n      // Broadcast the change occurred\n      this.onRangeChanged(this.camera, view.projection);\n      // Bound the camera to the specified bounding range\n      this.applyBounds();\n    }\n  }\n\n  /**\n   * Applies a handler for the range changing.\n   */\n  setRangeChangeHandler(handler: BasicCamera2DController[\"onRangeChanged\"]) {\n    this.onRangeChanged = handler;\n  }\n}\n","import { Camera2D } from \"./camera-2d\";\nimport { Control2D } from \"./control-2d\";\n\nexport interface IReferenceControl2DOptions {\n  /** This is the base camera to monitor */\n  base: Control2D;\n  /**\n   * This is a filter applied to the offset that comes from the chart camera.\n   */\n  offsetFilter?(offset: [number, number, number]): [number, number, number];\n  /**\n   * This is a filter applied to the scale that comes from the chart camera.\n   */\n  scaleFilter?(scale: [number, number, number]): [number, number, number];\n}\n\nclass ReferenceControl2D extends Control2D {\n  base: Control2D;\n  private offsetFilter = (offset: [number, number, number]) => offset;\n  private scaleFilter = (scale: [number, number, number]) => scale;\n\n  set offset(_val: any) {\n    /** no-op */\n  }\n\n  get offset() {\n    return this.offsetFilter(this.base.offset);\n  }\n\n  set scale(_val: any) {\n    /** no-op */\n  }\n\n  get scale() {\n    return this.scaleFilter(this.base.scale);\n  }\n\n  constructor(camera: Camera2D, options: IReferenceControl2DOptions) {\n    super(camera);\n    this.base = options.base;\n    this.offsetFilter = options.offsetFilter || this.offsetFilter;\n    this.scaleFilter = options.scaleFilter || this.scaleFilter;\n  }\n}\n\nexport interface IReferenceCamera2DOptions {\n  /** This is the base camera to monitor */\n  base: Camera2D;\n  /**\n   * This is a filter applied to the offset that comes from the chart camera.\n   */\n  offsetFilter?(offset: [number, number, number]): [number, number, number];\n  /**\n   * This is a filter applied to the scale that comes from the chart camera.\n   */\n  scaleFilter?(scale: [number, number, number]): [number, number, number];\n}\n\n/**\n * This is a camera that is based on another camera. This can apply filters\n * to the information provided from the base camera.\n *\n * Useful for situations such as a chart having a chart area and a list on the\n * left. This can use the same camera the chart area uses, but filter the response\n * to only track the y offset of the base camera.\n *\n * That would allow easy tracking of the left list to track with elements in the\n * chart and only manipulate a single camera instead of managing many cameras and\n * tie them together with lots of events.\n */\nexport class ReferenceCamera2D extends Camera2D {\n  private base: Camera2D;\n  private _control2D: ReferenceControl2D;\n\n  set control2D(_val: Control2D) {\n    /** Noop */\n  }\n  get control2D() {\n    return this._control2D;\n  }\n\n  constructor(options: IReferenceCamera2DOptions) {\n    super();\n    this.base = options.base;\n\n    this._control2D = new ReferenceControl2D(this.base, {\n      base: this.base.control2D,\n      offsetFilter: options.offsetFilter,\n      scaleFilter: options.scaleFilter\n    });\n  }\n}\n","import { Bounds } from \"../../math/primitives/bounds\";\nimport { add3 } from \"../../math/vector\";\nimport { IViewProps, View } from \"../../surface\";\nimport { LayerScene } from \"../../surface/layer-scene\";\nimport { Camera, CameraProjectionType } from \"../../util/camera\";\nimport { Camera2D } from \"./camera-2d\";\nimport { Projection2D } from \"./projection-2d\";\n\n/**\n * Defines the input metrics of a view for a scene.\n */\nexport interface IView2DProps extends IViewProps {\n  /** Redefine the camera applied to this view to ensure it's a 2D camera. */\n  camera: Camera2D;\n}\n\n/**s\n * Type guard to ensure the camera type is orthographic\n */\nfunction isOrthographic(val: Camera): val is Camera {\n  return val.projectionType === CameraProjectionType.ORTHOGRAPHIC;\n}\n\n/**\n * A View renders a perspective of a scene to a given surface or surfaces.\n */\nexport class View2D<TViewProps extends IView2DProps> extends View<TViewProps> {\n  static defaultProps: IView2DProps = {\n    key: \"\",\n    camera: new Camera2D(),\n    viewport: {\n      left: 0,\n      right: 0,\n      bottom: 0,\n      top: 0\n    }\n  };\n\n  /** These are the projection methods specific to rendering with this 2D system. */\n  projection: Projection2D = new Projection2D();\n\n  constructor(scene: LayerScene, options: TViewProps) {\n    super(scene, options);\n    this.projection.camera = options.camera;\n  }\n\n  /**\n   * This operation makes sure we have the view camera adjusted to the new viewport's needs.\n   * For default behavior this ensures that the coordinate system has no distortion or perspective, orthographic,\n   * top left as 0,0 with +y axis pointing down.\n   */\n  fitViewtoViewport(\n    _surfaceDimensions: Bounds<never>,\n    viewBounds: Bounds<View<IViewProps>>\n  ) {\n    if (isOrthographic(this.props.camera)) {\n      const width = viewBounds.width;\n      const height = viewBounds.height;\n\n      const viewport = {\n        bottom: -height / 2,\n        far: 10000000,\n        left: -width / 2,\n        near: -100,\n        right: width / 2,\n        top: height / 2\n      };\n\n      const scaleX = 1 / this.pixelRatio;\n      const scaleY = 1 / this.pixelRatio;\n      const camera = this.props.camera;\n\n      camera.projectionOptions = Object.assign(\n        camera.projectionOptions,\n        viewport\n      );\n      camera.position = [\n        viewBounds.width / 2.0,\n        -viewBounds.height / 2.0,\n        camera.position[2]\n      ];\n      camera.scale = [scaleX, -scaleY, 1.0];\n      camera.lookAt(add3(camera.position, [0, 0, -1]), [0, 1, 0]);\n      camera.update();\n\n      this.projection.viewBounds = viewBounds;\n      viewBounds.d = this;\n      this.projection.screenBounds = new Bounds<View<TViewProps>>({\n        height: this.viewBounds.height / this.pixelRatio,\n        width: this.viewBounds.width / this.pixelRatio,\n        x: this.viewBounds.x / this.pixelRatio,\n        y: this.viewBounds.y / this.pixelRatio\n      });\n      this.screenBounds.d = this;\n    } else if (!isOrthographic(this.props.camera)) {\n      console.warn(\"View2D does not support non-orthographic cameras yet.\");\n    }\n  }\n\n  willUpdateProps(newProps: IView2DProps) {\n    this.projection.camera = newProps.camera;\n  }\n}\n","import { BaseProjection, Vec2 } from \"../../math\";\nimport { Camera2D } from \"./camera-2d\";\n\nexport class Projection2D extends BaseProjection<any> {\n  camera: Camera2D;\n\n  /**\n   * Maps a coordinate relative to the screen to a coordinate found within the world space.\n   */\n  screenToWorld(point: Vec2, out?: Vec2) {\n    const view = this.screenToView(point);\n\n    const world = out || [0, 0];\n    world[0] =\n      (view[0] - this.camera.control2D.offset[0] * this.camera.scale2D[0]) /\n      this.camera.scale2D[0];\n    world[1] =\n      (view[1] - this.camera.control2D.offset[1] * this.camera.scale2D[1]) /\n      this.camera.scale2D[1];\n\n    return world;\n  }\n\n  /**\n   * Maps a coordinate found within the world to a relative coordinate within the screen space.\n   */\n  worldToScreen(point: Vec2, out?: Vec2) {\n    const screen: Vec2 = [0, 0];\n\n    // Calculate from the camera to view space\n    screen[0] =\n      (point[0] * this.camera.scale2D[0] +\n        this.camera.control2D.offset[0] * this.camera.scale2D[0]) *\n      this.pixelRatio;\n    screen[1] =\n      (point[1] * this.camera.scale2D[1] +\n        this.camera.control2D.offset[1] * this.camera.scale2D[1]) *\n      this.pixelRatio;\n\n    // Convert from view to screen space\n    return this.viewToScreen(screen, out);\n  }\n\n  /**\n   * Maps a coordinate relative to the view's viewport to a coordinate found within the world.\n   */\n  viewToWorld(point: Vec2, out?: Vec2) {\n    const world = out || [0, 0];\n\n    const screen = point;\n    world[0] =\n      (screen[0] - this.camera.control2D.offset[0] * this.camera.scale2D[0]) /\n      this.camera.scale2D[0];\n    world[1] =\n      (screen[1] - this.camera.control2D.offset[1] * this.camera.scale2D[1]) /\n      this.camera.scale2D[1];\n\n    return world;\n  }\n\n  /**\n   * Maps a coordinate found within the world to a relative coordinate within the view's viewport.\n   */\n  worldToView(point: Vec2, out?: Vec2) {\n    const screen = out || [0, 0];\n\n    // Calculate from the camera to view space\n    screen[0] =\n      point[0] * this.camera.scale2D[0] +\n      this.camera.control2D.offset[0] * this.camera.scale2D[0];\n    screen[1] =\n      point[1] * this.camera.scale2D[1] +\n      this.camera.control2D.offset[1] * this.camera.scale2D[1];\n\n    return screen;\n  }\n}\n","export * from \"./arcs\";\nexport * from \"./circles\";\nexport * from \"./edges\";\nexport * from \"./images\";\nexport * from \"./labels\";\nexport * from \"./rectangle\";\nexport * from \"./rings\";\n","export * from \"./arc-layer\";\nexport * from \"./arc-instance\";\n","import { GLSettings } from \"../../../gl\";\nimport { InstanceProvider } from \"../../../instance-provider\";\nimport { IAutoEasingMethod, Vec } from \"../../../math\";\nimport {\n  ILayerMaterialOptions,\n  InstanceAttributeSize,\n  IShaderInitialization,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../../types\";\nimport { CommonMaterialOptions } from \"../../../util\";\nimport { ILayer2DProps, Layer2D } from \"../../view/layer-2d\";\nimport { ArcInstance } from \"./arc-instance\";\n\nexport enum ArcScaleType {\n  /** All dimensions are within world space */\n  NONE,\n  /**\n   * The thickness of the arc is in screen space. Thus, camera zoom changes will not affect it and\n   * must be controlled by scaleFactor alone.\n   */\n  SCREEN_CURVE\n}\n\nexport interface IArcLayerProps<T extends ArcInstance>\n  extends ILayer2DProps<T> {\n  scaleType?: ArcScaleType;\n  animate?: {\n    angle?: IAutoEasingMethod<Vec>;\n    angleOffset?: IAutoEasingMethod<Vec>;\n    center?: IAutoEasingMethod<Vec>;\n    colorEnd?: IAutoEasingMethod<Vec>;\n    colorStart?: IAutoEasingMethod<Vec>;\n    radius?: IAutoEasingMethod<Vec>;\n    thickness?: IAutoEasingMethod<Vec>;\n  };\n}\n\n/**\n * This layer displays Arcs and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class ArcLayer<\n  T extends ArcInstance,\n  U extends IArcLayerProps<T>\n> extends Layer2D<T, U> {\n  static defaultProps: IArcLayerProps<ArcInstance> = {\n    data: new InstanceProvider<ArcInstance>(),\n    key: \"\",\n    scaleType: ArcScaleType.NONE\n  };\n\n  /** Easy lookup of all attribute names for the layer */\n  static attributeNames = {\n    angle: \"angle\",\n    angleOffset: \"angleOffset\",\n    center: \"center\",\n    colorEnd: \"colorEnd\",\n    colorStart: \"colorStart\",\n    depth: \"depth\",\n    radius: \"radius\",\n    thickness: \"thickness\"\n  };\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<ArcInstance> {\n    const { scaleType } = this.props;\n    const animations = this.props.animate || {};\n    const {\n      angle: animateAngle,\n      angleOffset: animateAngleOffset,\n      center: animateCenter,\n      radius: animateRadius,\n      thickness: animateThickness,\n      colorStart: animateColorStart,\n      colorEnd: animateColorEnd\n    } = animations;\n\n    const MAX_SEGMENTS = 150;\n\n    // Calculate the normals and interpolations for our vertices\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      [MAX_SEGMENTS * 2 + 2]: -1\n    };\n\n    const vertexInterpolation: { [key: number]: number } = {\n      0: 0,\n      [MAX_SEGMENTS * 2 + 2]: 1\n    };\n\n    let sign = 1;\n    for (let i = 0; i < MAX_SEGMENTS * 2; ++i) {\n      vertexToNormal[i + 1] = sign;\n      vertexInterpolation[i + 1] = Math.floor(i / 2) / (MAX_SEGMENTS - 1);\n      sign *= -1;\n    }\n\n    const vs =\n      scaleType === ArcScaleType.NONE\n        ? require(\"./arc-layer.vs\")\n        : require(\"./arc-layer-screen-space.vs\");\n\n    return {\n      fs: require(\"./arc-layer.fs\"),\n      instanceAttributes: [\n        {\n          easing: animateCenter,\n          name: ArcLayer.attributeNames.center,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.center\n        },\n        {\n          easing: animateRadius,\n          name: ArcLayer.attributeNames.radius,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.radius]\n        },\n        {\n          name: ArcLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        {\n          easing: animateThickness,\n          name: ArcLayer.attributeNames.thickness,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.thickness\n        },\n        {\n          easing: animateAngle,\n          name: ArcLayer.attributeNames.angle,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.angle\n        },\n        {\n          easing: animateAngleOffset,\n          name: ArcLayer.attributeNames.angleOffset,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.angleOffset]\n        },\n        {\n          easing: animateColorStart,\n          name: ArcLayer.attributeNames.colorStart,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.colorStart\n        },\n        {\n          easing: animateColorEnd,\n          name: ArcLayer.attributeNames.colorEnd,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.colorEnd\n        }\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: _u => [1]\n        }\n      ],\n      vertexAttributes: [\n        {\n          name: \"vertex\",\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexInterpolation[vertex],\n            // The number of vertices\n            MAX_SEGMENTS * 2\n          ]\n        }\n      ],\n      vertexCount: MAX_SEGMENTS * 2 + 2,\n      vs\n    };\n  }\n\n  getMaterialOptions(): ILayerMaterialOptions {\n    return Object.assign({}, CommonMaterialOptions.transparentShapeBlending, {\n      culling: GLSettings.Material.CullSide.NONE\n    } as ILayerMaterialOptions);\n  }\n}\n","module.exports = \"${import: arc}\\nprecision highp float;\\nvarying vec4 vertexColor;\\nvoid main() {\\nfloat startAngle = angle.x + angleOffset;\\nfloat endAngle = angle.y + angleOffset;\\nfloat widthStart = thickness.x;\\nfloat widthEnd = thickness.y;\\nfloat normal = vertex.x;\\nfloat interpolationTime = vertex.y;\\nfloat interpolationIncrement = 1.0 / vertex.z;\\nvec2 currentPosition = arc(interpolationTime, center, radius, startAngle, endAngle);\\nvec2 currentNormal = normalize(currentPosition - center);\\nfloat lineThickness = mix(widthStart, widthEnd, interpolationTime) / 2.0;\\nvec2 vertex = currentPosition + currentNormal * (normal * lineThickness);\\nvertexColor = mix(colorStart, colorEnd, interpolationTime);\\ngl_Position = clipSpace(vec3(vertex, depth));\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvec2 interpolation(float t, vec2 center, float radius, float start, float end) {\\nfloat angle = (end - start) * t + start;\\nreturn center + vec2(cos(angle) * radius, sin(angle) * radius);\\n}\\nvoid main() {\\nfloat startAngle = angle.x;\\nfloat endAngle = angle.y;\\nfloat widthStart = thickness.x;\\nfloat widthEnd = thickness.y;\\nvec4 centerClip = clipSpace(vec3(center, depth));\\nvec2 centerScreen = (centerClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\nfloat normal = position.x;\\nfloat interpolationTime = position.y;\\nfloat interpolationIncrement = 1.0 / position.z;\\nvec2 currentPosition = interpolation(interpolationTime, centerScreen, radius, startAngle, endAngle);\\nvec2 currentNormal = normalize(currentPosition - centerScreen);\\nfloat lineThickness = mix(widthStart, widthEnd, interpolationTime) / 2.0;\\nvec2 vertex = currentPosition + currentNormal * (normal * lineThickness);\\nvertexColor = mix(colorStart, colorEnd, interpolationTime);\\nvertexColor *= vertexColor.a;\\ngl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), centerClip.zw);\\ngl_PointSize = 5.0;\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvoid main() {\\nsetColor(vertexColor);\\n}\"","import { observable } from \"../../../instance-provider\";\nimport {\n  IInstanceOptions,\n  Instance\n} from \"../../../instance-provider/instance\";\nimport { Vec2, Vec4 } from \"../../../math\";\n\nexport interface IArcInstanceOptions extends IInstanceOptions {\n  /** The start and end angle of the arc */\n  angle: Vec2;\n  /** The center point where the arc wraps around */\n  center: Vec2;\n  /** This is the end color of the arc */\n  colorEnd?: Vec4;\n  /** This is the start color of the arc */\n  colorStart?: Vec4;\n  /** Depth sorting of the arc (or the z value of the arc) */\n  depth?: number;\n  /** The radius of how far the middle of the arc is from the center point */\n  radius: number;\n  /** The start to end thickness of the arc */\n  thickness?: Vec2;\n}\n\n/**\n * This generates a new arc instance. An arc is a shape with a center and an angle that\n * is spans. This effectively can be used for a 'pie slice' or just the edge line on the pie\n * slice.\n */\nexport class ArcInstance extends Instance {\n  /** The start and end angle of the arc */\n  @observable angle: Vec2 = [0, Math.PI];\n  /** This is the end color of the arc */\n  @observable colorEnd: Vec4 = [1, 1, 1, 1];\n  /** This is the start color of the arc */\n  @observable colorStart: Vec4 = [1, 1, 1, 1];\n  /** The center point where the arc wraps around */\n  @observable center: Vec2 = [0, 0];\n  /** Depth sorting of the arc (or the z value of the arc) */\n  @observable depth: number = 0;\n  /** An offset to apply to the angle. This makes it easy to animate the arc or set a point of reference for angle 0 */\n  @observable angleOffset: number = 0;\n  /** The radius of how far the middle of the arc is from the center point */\n  @observable radius: number = 1;\n  /** The start to end thickness of the arc */\n  @observable thickness: Vec2 = [5, 5];\n\n  constructor(options: IArcInstanceOptions) {\n    super(options);\n\n    this.angle = options.angle || this.angle;\n    this.colorEnd = options.colorEnd || this.colorEnd;\n    this.colorStart = options.colorStart || this.colorStart;\n    this.center = options.center || this.center;\n    this.depth = options.depth || this.depth;\n    this.radius = options.radius || this.radius;\n    this.thickness = options.thickness || this.thickness;\n  }\n}\n","export * from \"./circle-layer\";\nexport * from \"./circle-instance\";\n","import { GLSettings } from \"../../../gl\";\nimport { InstanceProvider } from \"../../../instance-provider\";\nimport { Vec } from \"../../../math\";\nimport { IAutoEasingMethod } from \"../../../math/auto-easing-method\";\nimport {\n  ILayerMaterialOptions,\n  InstanceAttributeSize,\n  IShaderInitialization,\n  IUniform,\n  IVertexAttribute,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../../types\";\nimport { CommonMaterialOptions } from \"../../../util\";\nimport { ILayer2DProps, Layer2D } from \"../../view/layer-2d\";\nimport { CircleInstance } from \"./circle-instance\";\n\nexport interface ICircleLayerProps<T extends CircleInstance>\n  extends ILayer2DProps<T> {\n  /**\n   * This is the properties that can toggle on animations.\n   *\n   * NOTE: The more properties declared as animated will reduce the performance of the layer.\n   * if animated properties are created, it can be beneficial to have other layers with no\n   * animations be available for the Instances to 'rest' in when not moving.\n   */\n  animate?: {\n    center?: IAutoEasingMethod<Vec>;\n    radius?: IAutoEasingMethod<Vec>;\n    color?: IAutoEasingMethod<Vec>;\n  };\n  /** This sets a scaling factor for the circle's radius */\n  scaleFactor?(): number;\n  /** Opacity of the layer as a whole */\n  opacity?(): number;\n  /**\n   * When set, this causes the circles to be rendered utilizing the hardware POINTS mode. POINTS mode has limitations:\n   * Different GPUs have different MAX POINT SIZE values, so the points can only be rendered up to a certain size. Also\n   * points can have unexpected culling that occurs at the edge of the viewport.\n   *\n   * However, this mode has GREATLY improved performance when utilized correctly. So use for the correct situation, but\n   * beware it's weak 'points' <- this is a pun in the comments of this code base. <- this is me being over zealous in\n   * clarifying so the apostraphes don't lead to unecessary conclusions.\n   */\n  usePoints?: boolean;\n}\n\n/**\n * This layer displays circles and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class CircleLayer<\n  T extends CircleInstance,\n  U extends ICircleLayerProps<T>\n> extends Layer2D<T, U> {\n  static defaultProps: ICircleLayerProps<CircleInstance> = {\n    data: new InstanceProvider<CircleInstance>(),\n    key: \"\",\n    scaleFactor: () => 1\n  };\n\n  static attributeNames = {\n    center: \"center\",\n    color: \"color\",\n    depth: \"depth\",\n    radius: \"radius\"\n  };\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<CircleInstance> {\n    const {\n      animate = {},\n      scaleFactor = () => 1,\n      usePoints = false,\n      opacity = () => 1\n    } = this.props;\n\n    const {\n      center: animateCenter,\n      radius: animateRadius,\n      color: animateColor\n    } = animate;\n\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: -1,\n      1: -1,\n      2: -1,\n      3: 1,\n      4: 1,\n      5: 1\n    };\n\n    const vertexAttributes: IVertexAttribute[] = [\n      {\n        name: \"normals\",\n        size: VertexAttributeSize.TWO,\n        update: (vertex: number) => [\n          // Normal\n          vertexToNormal[vertex],\n          // The side of the quad\n          vertexToSide[vertex]\n        ]\n      }\n    ];\n\n    const vertexCount = 6;\n\n    return {\n      drawMode: usePoints\n        ? GLSettings.Model.DrawMode.POINTS\n        : GLSettings.Model.DrawMode.TRIANGLE_STRIP,\n      fs: usePoints\n        ? require(\"./circle-layer-points.fs\")\n        : require(\"./circle-layer.fs\"),\n      instanceAttributes: [\n        {\n          easing: animateCenter,\n          name: CircleLayer.attributeNames.center,\n          size: InstanceAttributeSize.TWO,\n          update: circle => circle.center\n        },\n        {\n          easing: animateRadius,\n          name: CircleLayer.attributeNames.radius,\n          size: InstanceAttributeSize.ONE,\n          update: circle => [circle.radius]\n        },\n        {\n          name: CircleLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: circle => [circle.depth]\n        },\n        {\n          easing: animateColor,\n          name: CircleLayer.attributeNames.color,\n          size: InstanceAttributeSize.FOUR,\n          update: circle => circle.color\n        }\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: (_uniform: IUniform) => [scaleFactor()]\n        },\n        {\n          name: \"layerOpacity\",\n          size: UniformSize.ONE,\n          update: (_uniform: IUniform) => [opacity()]\n        }\n      ],\n      vertexAttributes: usePoints ? undefined : vertexAttributes,\n      vertexCount: usePoints ? 0 : vertexCount,\n      vs: usePoints\n        ? require(\"./circle-layer-points.vs\")\n        : require(\"./circle-layer.vs\")\n    };\n  }\n\n  getMaterialOptions(): ILayerMaterialOptions {\n    return CommonMaterialOptions.transparentShapeBlending;\n  }\n}\n","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvarying float edgeSharpness;\\nvarying float edgeSharpnessBase;\\nfloat circle(vec2 coord, float radius){\\nvec2 dist = coord - vec2(0.5);\\nreturn 1.0 - smoothstep(\\nradius - (radius * edgeSharpness),\\nradius + (radius * edgeSharpnessBase),\\ndot(dist, dist) * 4.0\\n);\\n}\\nvoid main() {\\nfloat step_factor = circle(gl_PointCoord, 1.0);\\nsetColor(mix(\\nvec4(0.0, 0.0, 0.0, 0.0),\\nvertexColor,\\nstep_factor\\n));\\nif (gl_FragColor.a <= 0.0) discard;\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvarying float edgeSharpness;\\nvarying float edgeSharpnessBase;\\nvarying vec2 pointCoord;\\nfloat circle(vec2 coord, float radius){\\nvec2 dist = coord - vec2(0.5);\\nreturn 1.0 - smoothstep(\\nradius - (radius * edgeSharpness),\\nradius + (radius * edgeSharpnessBase),\\ndot(dist, dist) * 4.0\\n);\\n}\\nvoid main() {\\nfloat step_factor = circle(pointCoord, 1.0);\\nsetColor(mix(\\nvec4(0.0, 0.0, 0.0, 0.0),\\nvertexColor,\\nstep_factor\\n));\\nif (gl_FragColor.a <= 0.0) discard;\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvarying float edgeSharpness;\\nvarying float edgeSharpnessBase;\\nvoid main() {\\nvertexColor = color;\\nvertexColor.a *= layerOpacity;\\nfloat size = radius * scaleFactor;\\nedgeSharpness = mix(0.8, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));\\nedgeSharpnessBase = mix(0.1, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));\\ngl_Position = clipSpace(vec3(center, depth));\\ngl_PointSize = size * 2.0 * pixelRatio;\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvarying float edgeSharpness;\\nvarying float edgeSharpnessBase;\\nvarying vec2 pointCoord;\\nvoid main() {\\nvertexColor = color;\\nvertexColor.a *= layerOpacity;\\nfloat size = radius * scaleFactor * pixelRatio;\\nedgeSharpness = mix(0.8, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));\\nedgeSharpnessBase = mix(0.1, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));\\npointCoord = (normals.xy + vec2(1.0, 1.0)) / 2.0;\\nvec4 clipCenter = clipSpace(vec3(center, depth));\\nvec2 screenCenter = (clipCenter.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\nvec2 vertex = (normals.xy * size) + screenCenter;\\ngl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), clipCenter.zw);\\n}\"","import { observable } from \"../../../instance-provider\";\nimport {\n  IInstanceOptions,\n  Instance\n} from \"../../../instance-provider/instance\";\nimport { Vec2 } from \"../../../math\";\n\nexport interface ICircleInstanceOptions extends IInstanceOptions {\n  /** Center position of the circle */\n  center: Vec2;\n  /** The radius of the circle */\n  radius: number;\n  /** The color of this circle */\n  color?: [number, number, number, number];\n  /** The z depth of the circle (for draw ordering) */\n  depth?: number;\n}\n\nexport class CircleInstance extends Instance {\n  /** The color of this circle */\n  @observable color: [number, number, number, number] = [1.0, 1.0, 1.0, 1.0];\n  /** The z depth of the circle (for draw ordering) */\n  @observable depth: number = 0;\n  /** The radius of the circle */\n  @observable radius: number = 0;\n  /** Center position of the circle */\n  @observable center: Vec2 = [0, 0];\n\n  constructor(options: ICircleInstanceOptions) {\n    super(options);\n\n    this.color = options.color || this.color;\n    this.radius = options.radius || this.radius;\n    this.center = options.center || this.center;\n    this.depth = options.depth || this.depth;\n  }\n\n  get width() {\n    return this.radius * 2;\n  }\n\n  get height() {\n    return this.radius * 2;\n  }\n}\n","export * from \"./edge-layer\";\nexport * from \"./edge-instance\";\nexport * from \"./types\";\n","import { InstanceProvider } from \"../../../instance-provider\";\nimport { IAutoEasingMethod, Vec } from \"../../../math\";\nimport {\n  ILayerMaterialOptions,\n  InstanceAttributeSize,\n  InstanceIOValue,\n  IShaderInitialization,\n  IUniform,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../../types\";\nimport { CommonMaterialOptions, shaderTemplate } from \"../../../util\";\nimport { ILayer2DProps, Layer2D } from \"../../view/layer-2d\";\nimport { EdgeInstance } from \"./edge-instance\";\nimport { EdgeBroadphase, EdgeScaleType, EdgeType } from \"./types\";\n\nexport interface IEdgeLayerProps<T extends EdgeInstance>\n  extends ILayer2DProps<T> {\n  /** Properties for animating attributes */\n  animate?: {\n    end?: IAutoEasingMethod<Vec>;\n    start?: IAutoEasingMethod<Vec>;\n    startColor?: IAutoEasingMethod<Vec>;\n    endColor?: IAutoEasingMethod<Vec>;\n    control?: IAutoEasingMethod<Vec>;\n    thickness?: IAutoEasingMethod<Vec>;\n  };\n  /** Allows adjustments for broadphase interactions for an edge */\n  broadphase?: EdgeBroadphase;\n  /** Any distance to the mouse from an edge that is less than this distance will be picked */\n  minPickDistance?: number;\n  /** The transparency of the layer as a whole. (Makes for very efficient fading of all elements) */\n  opacity?: number;\n  /** This sets a scaling factor for the edge's line width and curve  */\n  scaleFactor?(): number;\n  /**\n   * If this is set, then the thickness of the line and the curvature of the line exists in screen space\n   * rather than world space.\n   */\n  scaleType?: EdgeScaleType;\n  /** Specifies how the edge is formed */\n  type: EdgeType;\n}\n\nexport interface IEdgeLayerState {}\n\n/** Converts a control list to an IO value */\nfunction toInstanceIOValue(value: [number, number][]): InstanceIOValue {\n  return [value[0][0], value[0][1], value[1][0], value[1][1]];\n}\n\n/** This picks the appropriate shader for the edge type desired */\nconst pickVS = {\n  [EdgeType.LINE]: require(\"./shader/edge-layer-line.vs\"),\n  [EdgeType.BEZIER]: require(\"./shader/edge-layer-bezier.vs\"),\n  [EdgeType.BEZIER2]: require(\"./shader/edge-layer-bezier2.vs\")\n};\n\n/** This is the base edge layer which is a template that can be filled with the needed specifics for a given line type */\nconst baseVS = require(\"./shader/edge-layer.vs\");\nconst screenVS = require(\"./shader/edge-layer-screen-curve.vs\");\nconst edgeFS = require(\"./shader/edge-layer.fs\");\n\n/**\n * This layer displays edges and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class EdgeLayer<\n  T extends EdgeInstance,\n  U extends IEdgeLayerProps<T>\n> extends Layer2D<T, U> {\n  // Set default props for the layer\n  static defaultProps: IEdgeLayerProps<EdgeInstance> = {\n    broadphase: EdgeBroadphase.ALL,\n    data: new InstanceProvider<EdgeInstance>(),\n    key: \"none\",\n    scaleType: EdgeScaleType.NONE,\n    type: EdgeType.LINE\n  };\n\n  static attributeNames = {\n    control: \"control\",\n    depth: \"depth\",\n    end: \"end\",\n    endColor: \"endColor\",\n    start: \"start\",\n    startColor: \"startColor\",\n    thickness: \"thickness\"\n  };\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<EdgeInstance> {\n    const {\n      animate = {},\n      scaleFactor = () => 1,\n      type,\n      scaleType = EdgeScaleType.NONE\n    } = this.props;\n\n    const {\n      end: animateEnd,\n      start: animateStart,\n      startColor: animateColorStart,\n      endColor: animateColorEnd,\n      control: animateControl,\n      thickness: animateThickness\n    } = animate;\n\n    const MAX_SEGMENTS = type === EdgeType.LINE ? 2 : 50;\n\n    // Calculate the normals and interpolations for our vertices\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      [MAX_SEGMENTS * 2 + 2]: -1\n    };\n\n    const vertexInterpolation: { [key: number]: number } = {\n      0: 0,\n      [MAX_SEGMENTS * 2 + 2]: 1\n    };\n\n    let sign = 1;\n    for (let i = 0; i < MAX_SEGMENTS * 2; ++i) {\n      vertexToNormal[i + 1] = sign;\n      vertexInterpolation[i + 1] = Math.floor(i / 2) / (MAX_SEGMENTS - 1);\n      sign *= -1;\n    }\n\n    const templateOptions = {\n      interpolation: pickVS[type]\n    };\n\n    const vs = shaderTemplate({\n      options: templateOptions,\n      required: {\n        name: \"Edge Layer\",\n        values: [\"interpolation\"]\n      },\n      shader: scaleType === EdgeScaleType.NONE ? baseVS : screenVS,\n\n      // We do not want to remove any other templating options present\n      onToken: (token, replace) => {\n        if (!(token in templateOptions)) {\n          return `$\\{${token}}`;\n        }\n\n        return replace;\n      }\n    });\n\n    return {\n      fs: edgeFS,\n      instanceAttributes: [\n        {\n          easing: animateColorStart,\n          name: EdgeLayer.attributeNames.startColor,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.startColor\n        },\n        {\n          easing: animateColorEnd,\n          name: EdgeLayer.attributeNames.endColor,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.endColor\n        },\n        {\n          easing: animateStart,\n          name: EdgeLayer.attributeNames.start,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.start\n        },\n        {\n          easing: animateEnd,\n          name: EdgeLayer.attributeNames.end,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.end\n        },\n        {\n          easing: animateThickness,\n          name: EdgeLayer.attributeNames.thickness,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.thickness\n        },\n        {\n          name: EdgeLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        type === EdgeType.LINE\n          ? {\n              easing: animateControl,\n              name: EdgeLayer.attributeNames.control,\n              size: InstanceAttributeSize.FOUR,\n              update: _o => [0, 0, 0, 0]\n            }\n          : null,\n        type === EdgeType.BEZIER\n          ? {\n              easing: animateControl,\n              name: EdgeLayer.attributeNames.control,\n              size: InstanceAttributeSize.FOUR,\n              update: o => [o.control[0][0], o.control[0][1], 0, 0]\n            }\n          : null,\n        type === EdgeType.BEZIER2\n          ? {\n              easing: animateControl,\n              name: EdgeLayer.attributeNames.control,\n              size: InstanceAttributeSize.FOUR,\n              update: o => toInstanceIOValue(o.control)\n            }\n          : null\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: (_uniform: IUniform) => [scaleFactor()]\n        },\n        {\n          name: \"layerOpacity\",\n          size: UniformSize.ONE,\n          update: (_uniform: IUniform) => [\n            this.props.opacity === undefined ? 1.0 : this.props.opacity\n          ]\n        }\n      ],\n      vertexAttributes: [\n        {\n          name: \"vertex\",\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexInterpolation[vertex],\n            // The number of vertices\n            MAX_SEGMENTS * 2\n          ]\n        }\n      ],\n      vertexCount: MAX_SEGMENTS * 2 + 2,\n      vs: vs.shader\n    };\n  }\n\n  getMaterialOptions(): ILayerMaterialOptions {\n    return CommonMaterialOptions.transparentShapeBlending;\n  }\n}\n","module.exports = \"vec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {\\nreturn p1 + (p2 - p1) * t;\\n}\"","module.exports = \"vec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {\\nreturn (1.0 - t) * (1.0 - t) * p1 + 2.0 * t * (1.0 - t) * c1 + t * t * p2;\\n}\"","module.exports = \"vec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {\\nfloat t1 = 1.0 - t;\\nreturn pow(t1, 3.0) * p1 + 3.0 * t * pow(t1, 2.0) * c1 + 3.0 * pow(t, 2.0) * t1 * c2 + pow(t, 3.0) * p2;\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\n${interpolation}\\nvoid main() {\\nfloat normal = vertex.x;\\nfloat interpolationTime = vertex.y;\\nfloat interpolationIncrement = 1.0 / vertex.z;\\nvec2 currentPosition = interpolation(interpolationTime, start, end, control.xy, control.zw);\\nvec2 prePosition = interpolation(interpolationTime - interpolationIncrement, start, end, control.xy, control.zw);\\nvec2 nextPosition = interpolation(interpolationTime + interpolationIncrement, start, end, control.xy, control.zw);\\nvec2 preLine = prePosition - currentPosition;\\nvec2 nextLine = nextPosition - currentPosition;\\nvec2 currentNormal = mix(\\nnormalize(vec2(preLine.y, -preLine.x)),\\nmix(\\nnormalize(vec2(preLine.y, -preLine.x) + vec2(-nextLine.y, nextLine.x)),\\nnormalize(vec2(-nextLine.y, nextLine.x)),\\nfloat(vertex.x >= 1.0)\\n),\\nfloat(vertex.x > 0.0)\\n);\\nfloat lineThickness = mix(thickness.x, thickness.y, interpolationTime) / 2.0;\\nvec2 vertexPos = currentPosition + currentNormal * (normal * lineThickness);\\nvertexColor = mix(startColor, endColor, interpolationTime);\\ngl_Position = clipSpace(vec3(vertexPos, depth));\\ngl_PointSize = 5.0;\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\n${interpolation}\\nvoid main() {\\nfloat normal = vertex.x;\\nfloat interpolationTime = vertex.y;\\nfloat interpolationIncrement = 1.0 / vertex.z;\\nvec4 startClip = clipSpace(vec3(start, depth));\\nvec4 endClip = clipSpace(vec3(end, depth));\\nvec2 startScreen = (startClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\nvec2 endScreen = (endClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\nvec2 control1 = startScreen + vec2(control.x, -control.y) * scaleFactor;\\nvec2 control2 = endScreen + vec2(control.z, -control.w) * scaleFactor;\\nvec2 currentPosition = interpolation(interpolationTime, startScreen, endScreen, control1, control2);\\nvec2 prePosition = interpolation(interpolationTime - interpolationIncrement, startScreen, endScreen, control1, control2);\\nvec2 nextPosition = interpolation(interpolationTime + interpolationIncrement, startScreen, endScreen, control1, control2);\\nvec2 preLine = prePosition - currentPosition;\\nvec2 nextLine = nextPosition - currentPosition;\\nvec2 currentNormal = mix(\\nnormalize(vec2(preLine.y, -preLine.x)),\\nmix(\\nnormalize(vec2(preLine.y, -preLine.x) + vec2(-nextLine.y, nextLine.x)),\\nnormalize(vec2(-nextLine.y, nextLine.x)),\\nfloat(vertex.x >= 1.0)\\n),\\nfloat(vertex.x > 0.0)\\n);\\nfloat lineThickness = mix(thickness.x, thickness.y, interpolationTime) / 2.0;\\nvec2 vertexPos = currentPosition + currentNormal * (-normal * lineThickness * scaleFactor);\\nvertexColor = mix(startColor, endColor, interpolationTime);\\ngl_Position = vec4((vertexPos / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), startClip.zw);\\ngl_PointSize = 5.0;\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvoid main() {\\nsetColor(vertexColor);\\n}\"","import {\n  IInstanceOptions,\n  Instance\n} from \"../../../instance-provider/instance\";\nimport { observable } from \"../../../instance-provider/observable\";\nimport { copy4, Vec2, Vec4 } from \"../../../math\";\n\nexport interface IEdgeInstanceOptions extends IInstanceOptions {\n  /** This is the list of control points  */\n  control?: Vec2[];\n  /** The z depth of the edge (for draw ordering) */\n  depth?: number;\n  /** End point of the edge. */\n  end: Vec2;\n  /** End color of the edge */\n  endColor?: Vec4;\n  /** Beginning point of the edge. */\n  start: Vec2;\n  /** Start color of the edge */\n  startColor?: Vec4;\n  /** Start width of the edge. */\n  thickness?: Vec2;\n}\n\nexport class EdgeInstance extends Instance {\n  @observable control: Vec2[] = [\n    [0, 0],\n    [0, 0]\n  ];\n  @observable depth: number = 0;\n  @observable end: Vec2 = [0, 0];\n  @observable endColor: Vec4 = [1.0, 1.0, 1.0, 1.0];\n  @observable start: Vec2 = [0, 0];\n  @observable startColor: Vec4 = [1.0, 1.0, 1.0, 1.0];\n  @observable thickness: Vec2 = [1.0, 1.0];\n\n  /**\n   * Calculates length from beginning point to end point\n   */\n  get length() {\n    const delta = [this.end[0] - this.start[0], this.end[1] - this.start[1]];\n\n    return Math.sqrt(delta[0] * delta[0] + delta[1] * delta[1]);\n  }\n\n  /**\n   * Calculates the midpoint of the edge\n   */\n  get midpoint() {\n    return 0;\n  }\n\n  /**\n   * Calculates a perpendicular direction vector to the edge\n   */\n  get perpendicular(): Vec2 {\n    const length = this.length;\n\n    return [\n      (this.end[1] - this.start[1]) / length,\n      -(this.end[0] - this.start[0]) / length\n    ];\n  }\n\n  /**\n   * Applies the edge width to the start and end\n   */\n  setEdgeThickness(thickness: number) {\n    this.thickness = [thickness, thickness];\n  }\n\n  /**\n   * Applies the color to the start and end\n   */\n  setColor(color: Vec4) {\n    this.startColor = copy4(color);\n    this.endColor = copy4(color);\n  }\n\n  constructor(options: IEdgeInstanceOptions) {\n    super(options);\n    this.startColor = options.startColor || this.startColor;\n    this.endColor = options.endColor || this.endColor;\n    this.control = options.control || this.control;\n    this.depth = options.depth || this.depth;\n    this.end = options.end || this.end;\n    this.thickness = options.thickness || this.thickness;\n    this.start = options.start || this.start;\n  }\n}\n","export * from \"./image-layer\";\nexport * from \"./image-instance\";\n","import { InstanceProvider } from \"../../../instance-provider\";\nimport {\n  atlasRequest,\n  AtlasResource,\n  IAtlasResourceRequest\n} from \"../../../resources\";\nimport { LayerInitializer } from \"../../../surface/layer\";\nimport { InstanceDiffType } from \"../../../types\";\nimport { createLayer, mapInjectDefault } from \"../../../util\";\nimport { PromiseResolver } from \"../../../util/promise-resolver\";\nimport { Layer2D } from \"../../view/layer-2d\";\nimport { debugVideoEvents } from \"./debug-video\";\nimport { ImageInstance } from \"./image-instance\";\nimport { IImageRenderLayerProps, ImageRenderLayer } from \"./image-render-layer\";\n\nexport interface IImageLayerProps<T extends ImageInstance>\n  extends IImageRenderLayerProps<T> {}\n\nexport type ImageVideoResource = {\n  /**\n   * IF AND ONLY IF the browser supports it. This will cause the video to begin playing immediately when ready and\n   * loaded. This merely prevents the need to add video.play() to something after onReady has been called. All other\n   * expected video patterns are expected to apply.\n   */\n  autoPlay?: boolean;\n  /**\n   * This is the source the video will load.\n   */\n  videoSrc: string;\n};\n\nexport type ImageInstanceResource =\n  | string\n  | ImageBitmap\n  | ImageData\n  | HTMLImageElement\n  | HTMLCanvasElement\n  | ImageVideoResource;\n\n/**\n * Typeguard for video resource requests\n */\nexport function isVideoResource(val: any): val is ImageVideoResource {\n  return val && val.videoSrc;\n}\n\n/** Simple image source to be used for waiting elements */\nconst WHITE_PIXEL = new Image();\nWHITE_PIXEL.src =\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\";\n\n/**\n * This layer displays Images and provides as many controls as possible for displaying\n * them in interesting ways. This is the primary handler for image instances.\n */\nexport class ImageLayer<\n  T extends ImageInstance,\n  U extends IImageLayerProps<T>\n> extends Layer2D<T, U> {\n  static defaultProps: IImageLayerProps<any> = {\n    atlas: \"default\",\n    key: \"\",\n    data: new InstanceProvider<ImageInstance>()\n  };\n\n  /** Internal provider for child layers for this layer to hand off to */\n  childProvider = new InstanceProvider<ImageInstance>();\n  /**\n   * This tracks which resource this image is associated with This allows us to know what resource an image\n   * moves on from, thus allowing us to dispatch a disposal request of the resource.\n   */\n  imageToResource = new Map<ImageInstance, IAtlasResourceRequest[\"source\"]>();\n  /** The cached property ids of the instances so they are not processed every draw */\n  propertyIds?: { [key: string]: number };\n  /** We can consolidate requests at this layer level to reduce memory footprint of requests */\n  sourceToRequest = new Map<AtlasResource, IAtlasResourceRequest>();\n  /** Map video resource requests to their corresponding video element */\n  sourceToVideo = new Map<string, HTMLVideoElement>();\n  /**\n   * Stores a lookup to see which instances are using a video source. This helps track when the video source is no\n   * longer in use and can be disposed.\n   */\n  usingVideo = new Map<string, Set<ImageInstance>>();\n  /**\n   * These are the instances waiting for a video source to finish loading and have valid dimensions to be used by the\n   * resource manager.\n   */\n  waitingForVideo = new Map<string, Set<ImageInstance>>();\n  /**\n   * Instance lookup to see which video source the instance is waiting on.\n   */\n  waitForVideoSource = new Map<ImageInstance, string>();\n  /**\n   * In cases where the image has a special case loading procedure like videos, the image will have it's onReady\n   */\n  originalOnReadyCallbacks = new Map<\n    ImageInstance,\n    ImageInstance[\"onReady\"] | undefined\n  >();\n\n  /**\n   * The image layer will manage the resources for the images, and the child layer will concern itself\n   * with rendering.\n   */\n  childLayers(): LayerInitializer[] {\n    return [\n      createLayer(ImageRenderLayer, {\n        ...this.props,\n        key: `${this.props.key}.image-render-layer`\n      })\n    ];\n  }\n\n  destroy() {\n    super.destroy();\n    this.sourceToVideo.forEach(video => {\n      video.pause();\n      this.sourceToVideo.clear();\n      this.waitingForVideo.clear();\n      this.waitForVideoSource.clear();\n    });\n  }\n\n  /**\n   * Hijack the draw method to control changes to the source so we can send the manager dispose requests\n   * of a given image.\n   */\n  draw() {\n    // Get the changes we need to handle. We make sure the provider's changes remain in tact for\n    // the child layer to process them.\n    const changes = this.resolveChanges(true);\n    // Make sure we are triggering redraws appropriately\n    this.updateAnimationState();\n    // No changes, do nadda\n    if (changes.length <= 0) return;\n\n    if (!this.propertyIds) {\n      this.propertyIds = this.getInstanceObservableIds(changes[0][0], [\n        \"source\"\n      ]);\n    }\n\n    // Destructure the ids to work with\n    const { source: sourceId } = this.propertyIds;\n\n    for (let i = 0, iMax = changes.length; i < iMax; ++i) {\n      const [instance, diffType, changed] = changes[i];\n\n      switch (diffType) {\n        case InstanceDiffType.CHANGE:\n          // Indicates changes took place\n          if (changed[sourceId] !== undefined) {\n            // We get the previously stored resource\n            const previous = this.imageToResource.get(instance);\n            // Make sure we get the atlas appropriate resource for the instance\n            let resource = this.getAtlasSource(instance);\n            // Nothing needs to happen if the resource didn't change\n            if (resource === previous) break;\n\n            // If the previous is a video source we need to clear the instance out from utilizing the video\n            if (previous instanceof HTMLVideoElement) {\n              // Remove the potentially existing 'waiting on the video' references\n              const waitingOnSource = this.waitForVideoSource.get(instance);\n\n              if (waitingOnSource) {\n                this.waitForVideoSource.delete(instance);\n                const instancesWaiting = this.waitingForVideo.get(\n                  waitingOnSource\n                );\n\n                if (instancesWaiting) {\n                  instancesWaiting.delete(instance);\n                }\n              }\n\n              // Remove the instance from 'using' the video source\n              let instancesUsing = this.usingVideo.get(\n                previous.getAttribute(\"data-source\") || \"\"\n              );\n\n              if (!instancesUsing) {\n                instancesUsing = new Set();\n              }\n\n              instancesUsing.delete(instance);\n\n              if (instancesUsing.size <= 0) {\n                this.sourceToVideo.delete(\n                  previous.getAttribute(\"data-source\") || \"\"\n                );\n              }\n\n              // Revert the instance's onReady back to what it originally was\n              instance.onReady = this.originalOnReadyCallbacks.get(instance);\n            }\n\n            // Video resources must be prepped to handle special circumstances\n            if (isVideoResource(instance.source)) {\n              this.prepareVideo(instance, instance.source);\n              // Prepping the video can potentially temp swap the source of the image\n              resource = this.getAtlasSource(instance);\n              // Add the video to the video's use list\n              const usingList = mapInjectDefault(\n                this.usingVideo,\n                instance.source.videoSrc,\n                new Set()\n              );\n              usingList.add(instance);\n            }\n\n            // We set the new resource\n            this.imageToResource.set(instance, resource);\n            // We make a disposal request to the resource manager\n            this.resource.request(\n              this,\n              instance,\n              atlasRequest({\n                key: this.props.atlas || \"\",\n                disposeResource: true,\n                source: previous\n              })\n            );\n\n            // Look for similar requests for resources and consolidate\n            if (resource) {\n              let request = this.sourceToRequest.get(resource);\n\n              if (!request || (request.texture && !request.texture.isValid)) {\n                request = atlasRequest({\n                  key: this.props.atlas || \"\",\n                  source: resource,\n                  rasterizationScale: this.props.rasterizationScale\n                });\n\n                this.sourceToRequest.set(resource, request);\n              }\n\n              instance.request = request;\n              this.resource.request(this, instance, request);\n            }\n          }\n          break;\n\n        case InstanceDiffType.INSERT:\n          // Look for similar requests for resources and consolidate\n          if (instance.source) {\n            // Make sure we get the atlas appropriate resource for the instance\n            let resource = this.getAtlasSource(instance);\n\n            if (isVideoResource(instance.source)) {\n              this.prepareVideo(instance, instance.source);\n              // Prepping the video can potentially temp swap the source of the image\n              resource = this.getAtlasSource(instance);\n              // Add the video to the video's use list\n              const usingList = mapInjectDefault(\n                this.usingVideo,\n                instance.source.videoSrc,\n                new Set()\n              );\n              usingList.add(instance);\n            }\n\n            // See if we have an existing request for this resource\n            let request = this.sourceToRequest.get(resource);\n\n            if (!request || (request.texture && !request.texture.isValid)) {\n              request = atlasRequest({\n                key: this.props.atlas || \"\",\n                source: resource,\n                rasterizationScale: this.props.rasterizationScale\n              });\n\n              this.sourceToRequest.set(resource, request);\n            }\n\n            instance.request = request;\n          }\n\n          break;\n\n        case InstanceDiffType.REMOVE:\n          // Make sure we get the atlas appropriate resource for the instance\n          const resource = this.getAtlasSource(instance);\n          // Clear out any state the instance may have retained in this layer\n          this.imageToResource.delete(instance);\n\n          // Clear out video useage\n          if (isVideoResource(instance.source)) {\n            const waitingOnSource = this.waitForVideoSource.get(instance);\n\n            if (waitingOnSource) {\n              this.waitForVideoSource.delete(instance);\n              const instancesWaiting = this.waitingForVideo.get(\n                waitingOnSource\n              );\n\n              if (instancesWaiting) {\n                instancesWaiting.delete(instance);\n              }\n            }\n\n            let instancesUsing = this.usingVideo.get(instance.source.videoSrc);\n\n            if (!instancesUsing) {\n              instancesUsing = new Set();\n            }\n\n            instancesUsing.delete(instance);\n\n            if (instancesUsing.size <= 0) {\n              this.sourceToVideo.delete(instance.source.videoSrc);\n            }\n\n            this.originalOnReadyCallbacks.delete(instance);\n          }\n\n          // We make a disposal request here\n          this.resource.request(\n            this,\n            instance,\n            atlasRequest({\n              key: this.props.atlas || \"\",\n              disposeResource: true,\n              source: resource\n            })\n          );\n          break;\n      }\n    }\n\n    // After all changes are processed, we need to check to see if any video sources are no longer in use and clear out\n    // any remaining references to the video.\n    const toRemoveVideoSources: string[] = [];\n\n    this.usingVideo.forEach((usingVideoSet, videoSrc) => {\n      if (usingVideoSet.size <= 0) {\n        toRemoveVideoSources.push(videoSrc);\n      }\n    });\n\n    for (let i = 0, iMax = toRemoveVideoSources.length; i < iMax; ++i) {\n      const source = toRemoveVideoSources[i];\n      this.usingVideo.delete(source);\n      this.sourceToVideo.delete(source);\n    }\n  }\n\n  /**\n   * Gets the source that is atlas reques compatible.\n   */\n  private getAtlasSource(image: ImageInstance) {\n    if (isVideoResource(image.source)) {\n      return this.sourceToVideo.get(image.source.videoSrc) || WHITE_PIXEL;\n    }\n\n    return image.source;\n  }\n\n  /**\n   * This handles creating the video object from the source. It then queues up the waiting needs and temporarily\n   * converts the video Image to a simple white image that will take on the tint of the ImageInstance.\n   */\n  private prepareVideo(image: ImageInstance, source: ImageVideoResource) {\n    const check = this.sourceToVideo.get(source.videoSrc);\n    const checkCallback = this.originalOnReadyCallbacks.get(image);\n\n    if (!checkCallback) {\n      this.originalOnReadyCallbacks.set(image, image.onReady);\n    }\n\n    // Let's first see if the source provided already is being monitored by this layer.\n    if (check) {\n      const waitingInstances = this.waitingForVideo.get(source.videoSrc);\n\n      // If waiting instances exists, then the video has not loaded yet and this becomes an additional instance waiting\n      // for the video to be ready.\n      if (waitingInstances) {\n        waitingInstances.add(image);\n        this.waitForVideoSource.set(image, source.videoSrc);\n        image.onReady = undefined;\n        image.source = WHITE_PIXEL;\n\n        image.videoLoad = () => {\n          check.load();\n\n          if (source.autoPlay) {\n            check.play();\n          }\n        };\n      }\n\n      // Otherwise, the video IS ready and the instance can carry on as a normal instance\n      else {\n        const onReady =\n          this.originalOnReadyCallbacks.get(image) || image.onReady;\n        if (!onReady) return;\n\n        // Replace the onReady that the resource manager will fire with an onReady that will execute with the video\n        // that is prepped and ready included.\n        image.onReady = (image: ImageInstance) => {\n          onReady(image, check);\n        };\n      }\n\n      return;\n    }\n\n    // Create the physical video element to use.\n    const video = document.createElement(\"video\");\n    this.sourceToVideo.set(source.videoSrc, video);\n    // Store the exact source path on the element (the src attribute gets resolved to relative http request)\n    video.setAttribute(\"data-source\", source.videoSrc);\n\n    debugVideoEvents(video);\n\n    // We must load the video properly to make it compatible with the texture and have all of it's properties\n    // set in an appropriate fashion to not violate current video playback standards.\n    const metaResolver = new PromiseResolver<void>();\n    const dataResolver = new PromiseResolver<void>();\n\n    const removeListeners = () => {\n      video.removeEventListener(\"loadedmetadata\", waitForMetaData);\n      video.removeEventListener(\"loadeddata\", waitForData);\n      video.removeEventListener(\"error\", waitForError);\n\n      this.waitingForVideo.delete(source.videoSrc);\n      this.waitForVideoSource.delete(image);\n    };\n\n    const waitForData = () => {\n      dataResolver.resolve();\n    };\n\n    const waitForMetaData = () => {\n      metaResolver.resolve();\n    };\n\n    const waitForError = (event: any) => {\n      let error;\n\n      // Chrome v60\n      if (event.path && event.path[0]) {\n        error = event.path[0].error;\n      }\n\n      // Firefox v55\n      if (event.originalTarget) {\n        error = event.originalTarget.error;\n      }\n\n      // Broadcast the error\n      console.warn(\n        \"There was an error loading the video resource to the atlas texture context\"\n      );\n      console.warn(error);\n\n      // Reject the blocking promises\n      metaResolver.reject({});\n      dataResolver.reject({});\n    };\n\n    // We must ensure the source has it's meta data and first frame available. The meta data ensures a\n    // videoWidth and height are available and the first frame ensures WebGL does not throw an error in some\n    // browsers like chrome that will think the video is initially invalid.\n    video.addEventListener(\"loadedmetadata\", waitForMetaData);\n    video.addEventListener(\"loadeddata\", waitForData);\n    video.addEventListener(\"error\", waitForError);\n\n    // We now initialize the image as waiting on the video\n    // The image may have a custom onReady set awaiting the video's completion. We must not allow it to happen for\n    // loading the placeholder white image. So we replace it with a NOOP until the video itself is actually ready to\n    // be loaded into the resource manager.\n    image.onReady = undefined;\n    // We must also register the video source as waiting\n    const waitingInstances = mapInjectDefault(\n      this.waitingForVideo,\n      source.videoSrc,\n      new Set()\n    );\n    waitingInstances.add(image);\n    this.waitForVideoSource.set(image, source.videoSrc);\n    // Make the video's source point to the empty white image\n    image.source = WHITE_PIXEL;\n    // Lastly, make the image videoLoad method actually be a valid video operation.\n    image.videoLoad = () => {\n      video.load();\n\n      if (source.autoPlay) {\n        video.play();\n      }\n    };\n\n    // Current standard declares unmuted videos CAN NOT be auto played via javascript and must play in the context of\n    // a user event\n    video.muted = true;\n    // Set the video source after the events have been assigned so we can wait for the video to begin playback\n    video.src = source.videoSrc;\n\n    Promise.all([metaResolver.promise, dataResolver.promise])\n      // This executes when the video is officially ready and will be loaded into the resource manager for play back\n      .then(() => {\n        // Make sure the video start from the beginning\n        video.currentTime = 0;\n\n        // Check the video source preferences to see if the video should play immediately upon loading.\n        if (source.autoPlay) {\n          video.play();\n        }\n\n        // Retrieve all of the instances waiting for this video to be ready\n        const waitingInstances = this.waitingForVideo.get(source.videoSrc);\n\n        if (waitingInstances) {\n          waitingInstances.forEach(instance => {\n            // Set the instance's source back to the video. Since this is asynchronous, it should trigger the change and\n            // flow through the provider\n            instance.source = source;\n            instance.onReady = this.originalOnReadyCallbacks.get(instance);\n          });\n        }\n\n        removeListeners();\n      })\n      .catch(() => {\n        removeListeners();\n      });\n  }\n\n  /**\n   * This asserts whether or not the layer should be triggering redraws or not.\n   */\n  private updateAnimationState() {\n    // We should check to see if any of the video sources are playing or not\n    let isVideoPlaying = false;\n\n    this.sourceToVideo.forEach(video => {\n      if (!video.paused) {\n        isVideoPlaying = true;\n      }\n    });\n\n    // When videos are in use AND playing, this layer should be on continuous redraws to ensure the video renders continuously.\n    this.isAnimationContinuous = this.usingVideo.size > 0 && isVideoPlaying;\n  }\n\n  /**\n   * Parent layer has no rendering needs\n   */\n  initShader() {\n    return null;\n  }\n}\n","const debug = require(\"debug\")(\"video\");\n\n/**\n * This logs ALL events a video will fire. To see the logs simply open the console in the browser, then execute:\n * localStorage.debug = 'video';\n */\nexport function debugVideoEvents(video: HTMLVideoElement) {\n  if (debug.enabled) {\n    video.addEventListener(\"abort\", () => debug(\"abort\"));\n    video.addEventListener(\"canplay\", () => debug(\"canplay\"));\n    video.addEventListener(\"canplaythrough\", () => debug(\"canplaythrough\"));\n    video.addEventListener(\"durationchange\", () => debug(\"durationchange\"));\n    video.addEventListener(\"emptied\", () => debug(\"emptied\"));\n    video.addEventListener(\"ended\", () => debug(\"ended\"));\n    video.addEventListener(\"error\", () => debug(\"error\"));\n    video.addEventListener(\"loadeddata\", () => debug(\"loadeddata\"));\n    video.addEventListener(\"loadedmetadata\", () => debug(\"loadedmetadata\"));\n    video.addEventListener(\"loadstart\", () => debug(\"loadstart\"));\n    video.addEventListener(\"pause\", () => debug(\"pause\"));\n    video.addEventListener(\"play\", () => debug(\"play\"));\n    video.addEventListener(\"playing\", () => debug(\"playing\"));\n    video.addEventListener(\"progress\", () => debug(\"progress\"));\n    video.addEventListener(\"ratechange\", () => debug(\"ratechange\"));\n    video.addEventListener(\"seeked\", () => debug(\"seeked\"));\n    video.addEventListener(\"seeking\", () => debug(\"seeking\"));\n    video.addEventListener(\"stalled\", () => debug(\"stalled\"));\n    video.addEventListener(\"suspend\", () => debug(\"suspend\"));\n    video.addEventListener(\"timeupdate\", () => debug(\"timeupdate\"));\n    video.addEventListener(\"volumechange\", () => debug(\"volumechange\"));\n    video.addEventListener(\"waiting\", () => debug(\"waiting\"));\n  }\n}\n","import { InstanceProvider } from \"../../../instance-provider\";\nimport { IAutoEasingMethod, Vec } from \"../../../math\";\nimport {\n  ILayerMaterialOptions,\n  InstanceAttributeSize,\n  IShaderInitialization,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../../types\";\nimport { CommonMaterialOptions } from \"../../../util/common-options\";\nimport { ILayer2DProps, Layer2D } from \"../../view/layer-2d\";\nimport { ImageInstance } from \"./image-instance\";\n\nexport interface IImageRenderLayerProps<T extends ImageInstance>\n  extends ILayer2DProps<T> {\n  /** The id of the atlas to load resources into */\n  atlas?: string;\n  /** The properties we wish to animate for the image */\n  animate?: {\n    tint?: IAutoEasingMethod<Vec>;\n    location?: IAutoEasingMethod<Vec>;\n    size?: IAutoEasingMethod<Vec>;\n  };\n  /**\n   * This is the scale resources for the images will be loaded into the atlas. A value of\n   * 0.5 will cause images to load at 50% their source size to the atlas.\n   */\n  rasterizationScale?: number;\n}\n\n/**\n * This layer displays Images and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class ImageRenderLayer<\n  T extends ImageInstance,\n  U extends IImageRenderLayerProps<T>\n> extends Layer2D<T, U> {\n  static defaultProps: IImageRenderLayerProps<any> = {\n    key: \"\",\n    data: new InstanceProvider<ImageInstance>()\n  };\n\n  /** Easy lookup of attribute names to aid in modifications to be applied to elements */\n  static attributeNames = {\n    location: \"location\",\n    anchor: \"anchor\",\n    size: \"size\",\n    depth: \"depth\",\n    scaling: \"scaling\",\n    texture: \"texture\",\n    tint: \"tint\"\n  };\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<ImageInstance> {\n    const animations = this.props.animate || {};\n    const {\n      tint: animateTint,\n      location: animateLocation,\n      size: animateSize\n    } = animations;\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: 0,\n      1: 0,\n      2: 0,\n      3: 1,\n      4: 1,\n      5: 1\n    };\n\n    return {\n      fs: require(\"./image-layer.fs\"),\n      instanceAttributes: [\n        {\n          easing: animateLocation,\n          name: ImageRenderLayer.attributeNames.location,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.origin\n        },\n        {\n          name: ImageRenderLayer.attributeNames.anchor,\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.anchor.x || 0, o.anchor.y || 0]\n        },\n        {\n          easing: animateSize,\n          name: ImageRenderLayer.attributeNames.size,\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.width, o.height]\n        },\n        {\n          name: ImageRenderLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        {\n          name: ImageRenderLayer.attributeNames.scaling,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scaling]\n        },\n        {\n          name: ImageRenderLayer.attributeNames.texture,\n          resource: {\n            key: () => this.props.atlas || \"\",\n            name: \"imageAtlas\"\n          },\n          update: o => {\n            o.source;\n\n            if (!o.request) {\n              console.warn(\n                \"An image utilizing the image-render-layer does not have its request specified yet.\",\n                \"The image-render-layer does NOT manage requests and should be handled before this layer deals with the instance\"\n              );\n\n              return [0, 0, 0, 0];\n            }\n\n            return this.resource.request(this, o, o.request);\n          }\n        },\n        {\n          easing: animateTint,\n          name: ImageRenderLayer.attributeNames.tint,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.tint\n        }\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: _u => [1]\n        }\n      ],\n      vertexAttributes: [\n        {\n          name: \"normals\",\n          size: VertexAttributeSize.TWO,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexToSide[vertex]\n          ]\n        }\n      ],\n      vertexCount: 6,\n      vs: require(\"./image-layer.vs\")\n    };\n  }\n\n  getMaterialOptions(): ILayerMaterialOptions {\n    return CommonMaterialOptions.transparentImageBlending;\n  }\n}\n","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\ngl_FragColor = texture2D(imageAtlas, texCoord) * vertexColor;\\nsetColor(gl_FragColor * gl_FragColor.a);\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec3 screenSize = cameraSpaceSize(vec3(size, 1.0));\\nbool largerOnScreen = screenSize.y > size.y;\\nfloat useScaleMode = float(\\n(\\nscaling == 3.0 ||\\n(largerOnScreen && scaling == 2.0)\\n) &&\\nscaling != 1.0\\n);\\nfloat unequalZooms = float(cameraScale2D.x != cameraScale2D.y);\\nfloat normal = normals.x;\\nfloat side = normals.y;\\nvec2 worldAnchor = location + anchor;\\ntexCoord = texture.xy + ((texture.zw - texture.xy) * vec2(side, float(normal == -1.0)));\\nvertexColor = tint;\\nvec2 adjustedSize = mix(\\nsize,\\n(size * cameraScale2D.yx),\\nunequalZooms\\n);\\nvec2 adjustedAnchor = mix(\\nanchor,\\n(anchor * cameraScale2D.yx),\\nunequalZooms\\n);\\nvec2 vertex = vec2(side, float(normal == 1.0)) * adjustedSize + location - adjustedAnchor;\\nfloat imageScreenScale = mix(\\nscreenSize.y / adjustedSize.y,\\nscreenSize.x / adjustedSize.x,\\nfloat((cameraScale2D.x < 1.0) || (cameraScale2D.x > 1.0))\\n);\\nvec2 anchorToVertex = vertex - location;\\nvertex = mix(\\nvertex,\\n(anchorToVertex / imageScreenScale) + location,\\nuseScaleMode\\n);\\ngl_Position = clipSpace(vec3(vertex, depth));\\n}\"","import { observable } from \"../../../instance-provider\";\nimport {\n  IInstanceOptions,\n  Instance\n} from \"../../../instance-provider/instance\";\nimport { Vec2 } from \"../../../math/vector\";\nimport { IAtlasResourceRequest } from \"../../../resources\";\nimport { NOOP } from \"../../../types\";\nimport { Anchor, AnchorType, ScaleMode } from \"../../types\";\nimport { ImageInstanceResource } from \"./image-layer\";\n\nconst { max } = Math;\n\nexport interface IImageInstanceOptions extends IInstanceOptions {\n  /**\n   * The point on the image which will be placed in world space via the x, y coords. This is also the point\n   * which the image will be scaled around.\n   */\n  anchor?: Anchor;\n  /** Depth sorting of the image (or the z value of the image) */\n  depth?: number;\n  /** This is the HTMLImageElement that the image is to render. This element MUST be loaded completely before this instance is created. */\n  source: ImageInstanceResource;\n  /** The height of the image as it is to be rendered in world space */\n  height?: number;\n  /** The coordinate where the image will be anchored to in world space */\n  origin?: Vec2;\n  /** Sets the way the image scales with the world */\n  scaling?: ScaleMode;\n  /** The color the image should render as */\n  tint: [number, number, number, number];\n  /** The width of the image as it is to be rendered in world space */\n  width?: number;\n\n  /** Triggered when it's detected that the image will never render correctly */\n  onError?(): void;\n  /** Triggered when the image has fully loaded it's resources */\n  onReady?(image: ImageInstance, video?: HTMLVideoElement): void;\n}\n\n/**\n * This is a lookup to quickly find the proper calculation for setting the correct anchor\n * position based on the anchor type.\n */\nconst anchorCalculator: {\n  [key: number]: (anchor: Anchor, image: ImageInstance) => void;\n} = {\n  [AnchorType.TopLeft]: (anchor: Anchor, _image: ImageInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopMiddle]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width / 2.0;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.TopRight]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width + anchor.padding;\n    anchor.y = -anchor.padding;\n  },\n  [AnchorType.MiddleLeft]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = image.height / 2;\n  },\n  [AnchorType.Middle]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width / 2.0;\n    anchor.y = image.height / 2.0;\n  },\n  [AnchorType.MiddleRight]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width + anchor.padding;\n    anchor.y = image.height / 2.0;\n  },\n  [AnchorType.BottomLeft]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = -anchor.padding;\n    anchor.y = image.height + anchor.padding;\n  },\n  [AnchorType.BottomMiddle]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width / 2.0;\n    anchor.y = image.height + anchor.padding;\n  },\n  [AnchorType.BottomRight]: (anchor: Anchor, image: ImageInstance) => {\n    anchor.x = image.width + anchor.padding;\n    anchor.y = image.height + anchor.padding;\n  },\n  [AnchorType.Custom]: (anchor: Anchor, _image: ImageInstance) => {\n    anchor.x = anchor.x || 0;\n    anchor.y = anchor.y || 0;\n  }\n};\n\n/**\n * This generates a new image instance.\n * There are restrictions surrounding images due to texture sizes and rendering limitations.\n *\n * Currently, we only support rendering a image via canvas, then rendering it to an Atlas texture\n * which is used to render to cards in the world for rendering. This is highly performant, but means:\n *\n * - Images should only be so large.\n * - Once a image is constructed, only SOME properties can be altered thereafter\n *\n * An image that is constructed can only have some properties set upon creating the image and are locked\n * thereafter. The only way to modify them would be to destroy the image, then construct a new image\n * with the modifications. This has to deal with performance regarding rasterizing the image.\n */\nexport class ImageInstance extends Instance {\n  /** This is the rendered color of the image */\n  @observable tint: [number, number, number, number] = [0, 0, 0, 1];\n  /** Depth sorting of the image (or the z value of the image) */\n  @observable depth: number = 0;\n  /**\n   * The height of the image as it is to be rendered in world space.\n   * After onReady: this is immediately populated with the width and height of the image as it\n   * appears in the atlas.\n   */\n  @observable height: number = 1;\n  /** The coordinate where the image will be located in world space */\n  @observable origin: Vec2 = [0, 0];\n  /** Sets the way the image scales with the world */\n  @observable scaling: ScaleMode = ScaleMode.BOUND_MAX;\n  /** This is where the source of the image will come from */\n  @observable source: ImageInstanceResource;\n  /**\n   * The width of the image as it is to be rendered in world space.\n   * After onReady: this is immediately populated with the width and height of the image as it\n   * appears in the atlas.\n   */\n  @observable width: number = 1;\n\n  /**\n   * This property reflects the maximum size a single dimension of the image will take up.\n   * This means if you set this value to 100 at least the width or the height will be 100\n   * depending on the aspect ratio of the image.\n   */\n  get maxSize() {\n    return max(this.width, this.height);\n  }\n  set maxSize(value: number) {\n    const aspect = this.width / this.height;\n    this.width = value * aspect;\n    this.height = value;\n  }\n\n  /** Event called when there is an error attempting to load and render the image */\n  onError?: IImageInstanceOptions[\"onError\"];\n  /** Event called when the instance has it's resource loaded and ready for use */\n  onReady?: IImageInstanceOptions[\"onReady\"];\n  /** This is the request generated for the instance to retrieve the correct resource */\n  request?: IAtlasResourceRequest;\n  /** After onReady: This is populated with the width of the source image loaded into the Atlas */\n  sourceWidth: number = 0;\n  /** After onReady: This is populated with the height of the source image loaded into the Atlas */\n  sourceHeight: number = 0;\n\n  /**\n   * This is a position relative to the image. This will align the image such that the anchor point on\n   * the image will be located at the origin in world space.\n   */\n  @observable\n  private _anchor: Anchor = {\n    padding: 0,\n    type: AnchorType.TopLeft,\n    x: 0,\n    y: 0\n  };\n\n  constructor(options: IImageInstanceOptions) {\n    super(options);\n\n    this.depth = options.depth || this.depth;\n    this.tint = options.tint || this.tint;\n    this.scaling = options.scaling || this.scaling;\n    this.origin = options.origin || this.origin;\n    this.width = options.width || 1;\n    this.height = options.height || 1;\n    this.source = options.source;\n    this.onReady = options.onReady;\n\n    // Make sure the anchor is set to the appropriate location\n    options.anchor && this.setAnchor(options.anchor);\n  }\n\n  get anchor() {\n    return this._anchor;\n  }\n\n  /**\n   * In the event that video auto play is not permitted, one may have to respond to a user input gesture to begin\n   * loading and playing the video. While your video is not ready to play, the ImageInstance will NOT fire the onReady\n   * callback. Instead it will wait idle as an image that is merely the 'tint color' provided. Once this is called\n   * (within a user gesture) the video will for sure start loading, the onReady will call back once the video has\n   * properly prepped.\n   */\n  videoLoad: Function = NOOP;\n\n  /** This is triggered after the request has been completed */\n  resourceTrigger() {\n    // Only the source needs to be triggered to get the texture info to update from the request\n    this.source = this.source;\n\n    if (this.request && this.request.texture) {\n      this.sourceWidth = this.request.texture.pixelWidth;\n      this.sourceHeight = this.request.texture.pixelHeight;\n    }\n\n    if (this.onReady) this.onReady(this);\n  }\n\n  /**\n   * This applies a new anchor to this image and properly determines it's anchor position on the image\n   */\n  setAnchor(anchor: Anchor) {\n    const newAnchor = {\n      padding: anchor.padding || 0,\n      type: anchor.type,\n      x: anchor.x || 0,\n      y: anchor.y || 0\n    };\n\n    // Calculate the new anchors position values\n    anchorCalculator[newAnchor.type](newAnchor, this);\n    // Apply the anchor\n    this._anchor = newAnchor;\n  }\n}\n","export * from \"./label-layer\";\nexport * from \"./label-instance\";\nexport * from \"./glyph-instance\";\nexport * from \"./glyph-layer\";\nexport * from \"./text-area-instance\";\nexport * from \"./text-area-layer\";\n","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec4 texColor = texture2D(fontMap, texCoord);\\nif (texColor.r <= 0.0) discard;\\ntexColor.a = texColor.r;\\nsetColor(texColor * vertexColor);\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec4 texColor = texture2D(fontMap, texCoord);\\nif (texColor.r <= 0.0) discard;\\ntexColor.a = texColor.r;\\nsetColor(texColor * vertexColor);\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec2 scale = fontScale * cameraScale2D.xy;\\nfloat scaleBy = max(scale.x, scale.y) / maxScale;\\nvec2 pushOut = normals * glyphSize * fontScale;\\nfloat vx = mix(\\n(origin.x + padding.x + offset.x + pushOut.x),\\norigin.x + anchor.x + (padding.x - anchor.x + offset.x + pushOut.x) / scaleBy,\\nfloat(scale.x >= maxScale)\\n);\\nfloat vy = mix(\\n(origin.y + padding.y + offset.y + pushOut.y),\\norigin.y + anchor.y + (padding.y - anchor.y + offset.y + pushOut.y) / scaleBy,\\nfloat(scale.y >= maxScale)\\n);\\nvec3 position = vec3(vec2(vx, vy), depth);\\ngl_Position = clipSpace(position);\\ntexCoord = texture.xy + (texture.zw - texture.xy) * normals;\\nvertexColor = color * color.a;\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec2 scale = fontScale * cameraScale2D.xy;\\nfloat scaleBy = max(scale.x, scale.y) / maxScale;\\nvec2 pushOut = normals * glyphSize * fontScale;\\nfloat vx = mix(\\n(-anchor.x + offset.x + pushOut.x),\\n(-anchor.x + offset.x + pushOut.x) / scaleBy,\\nfloat(scale.x >= maxScale)\\n);\\nfloat vy = mix(\\n(-anchor.y + offset.y + pushOut.y),\\n(-anchor.y + offset.y + pushOut.y) / scaleBy,\\nfloat(scale.y >= maxScale)\\n);\\nvec3 position = vec3(origin + padding + vec2(vx, vy), depth);\\ngl_Position = clipSpace(position);\\ntexCoord = texture.xy + (texture.zw - texture.xy) * normals;\\nvertexColor = color * color.a;\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec4 texColor = texture2D(fontMap, texCoord);\\nif (texColor.r <= 0.0) discard;\\ntexColor.a = texColor.r;\\nsetColor(texColor * vertexColor);\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec4 texColor = texture2D(fontMap, texCoord);\\nif (texColor.r <= 0.0) discard;\\ntexColor.a = texColor.r;\\nsetColor(texColor * vertexColor);\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec2 pushOut = normals * glyphSize * fontScale;\\nvec3 position = vec3(origin + anchor + (padding - anchor + offset + pushOut) / cameraScale2D.xy , depth);\\ngl_Position = clipSpace(position);\\ntexCoord = texture.xy + (texture.zw - texture.xy) * normals;\\nvertexColor = color * color.a;\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec2 pushOut = normals * glyphSize * fontScale;\\nvec3 position = vec3(origin + padding + (-anchor + offset + pushOut) / cameraScale2D.xy, depth);\\ngl_Position = clipSpace(position);\\ntexCoord = texture.xy + (texture.zw - texture.xy) * normals;\\nvertexColor = color * color.a;\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec4 texColor = texture2D(fontMap, texCoord);\\nif (texColor.r <= 0.0) discard;\\ntexColor.a = texColor.r;\\nsetColor(texColor * vertexColor);\\n}\"","module.exports = \"varying vec4 vertexColor;\\nvarying vec2 texCoord;\\nvoid main() {\\nvec2 pushOut = normals * glyphSize * fontScale;\\nvec3 position = vec3(origin + padding + offset + pushOut, depth);\\ngl_Position = clipSpace(position);\\ntexCoord = texture.xy + (texture.zw - texture.xy) * normals;\\nvertexColor = color * color.a;\\n}\"","import { InstanceProvider } from \"../../../instance-provider/instance-provider\";\nimport { IAutoEasingMethod } from \"../../../math/auto-easing-method\";\nimport { add2, copy4, scale2, Vec, Vec2 } from \"../../../math/vector\";\nimport { fontRequest, IFontResourceRequest } from \"../../../resources\";\nimport {\n  ILayerConstructionClass,\n  LayerInitializer\n} from \"../../../surface/layer\";\nimport { InstanceDiffType, newLineRegEx } from \"../../../types\";\nimport { createLayer } from \"../../../util/create-util\";\nimport { AnchorType, ScaleMode } from \"../../types\";\nimport { ILayer2DProps, Layer2D } from \"../../view/layer-2d\";\nimport { BorderInstance } from \"./border-instance\";\nimport { BorderLayer } from \"./border-layer\";\nimport { GlyphInstance } from \"./glyph-instance\";\nimport { IGlyphLayerOptions } from \"./glyph-layer\";\nimport { LabelInstance } from \"./label-instance\";\nimport { LabelLayer } from \"./label-layer\";\nimport {\n  NewLineCharacterMode,\n  TextAlignment,\n  TextAreaInstance,\n  TextAreaLabel,\n  WordWrap\n} from \"./text-area-instance\";\n\n/** CalculatesanchorCalulater the ancho position of a textArea based on AnchorType */\nconst anchorCalulater: {\n  [key: number]: (textArea: TextAreaInstance) => Vec2;\n} = {\n  [AnchorType.TopLeft]: (_textArea: TextAreaInstance) => [0, 0],\n  [AnchorType.TopMiddle]: (textArea: TextAreaInstance) => [\n    textArea.maxWidth / 2.0,\n    0.0\n  ],\n  [AnchorType.TopRight]: (textArea: TextAreaInstance) => [\n    textArea.maxWidth,\n    0.0\n  ],\n  [AnchorType.MiddleLeft]: (textArea: TextAreaInstance) => [\n    0.0,\n    textArea.maxHeight / 2.0\n  ],\n  [AnchorType.Middle]: (textArea: TextAreaInstance) => [\n    textArea.maxWidth / 2.0,\n    textArea.maxHeight / 2.0\n  ],\n  [AnchorType.MiddleRight]: (textArea: TextAreaInstance) => [\n    textArea.maxWidth,\n    textArea.maxHeight / 2.0\n  ],\n  [AnchorType.BottomLeft]: (textArea: TextAreaInstance) => [\n    0.0,\n    textArea.maxHeight\n  ],\n  [AnchorType.BottomMiddle]: (textArea: TextAreaInstance) => [\n    textArea.maxWidth / 2.0,\n    textArea.maxHeight\n  ],\n  [AnchorType.BottomRight]: (textArea: TextAreaInstance) => [\n    textArea.maxWidth,\n    textArea.maxHeight\n  ],\n  [AnchorType.Custom]: (textArea: TextAreaInstance) => [\n    textArea.anchor.x || 0.0,\n    textArea.anchor.y || 0.0\n  ]\n};\n\n/**\n * Get the offsetY of a word by comparing offsetYs of all its letters. So we can put the word to the\n * the right position.\n */\nfunction getOffsetY(text: string, map: Map<string, number>) {\n  let offsetY = Number.MAX_SAFE_INTEGER;\n\n  for (let i = 0, endi = text.length; i < endi; i++) {\n    const c = text[i];\n    const height = map.get(c);\n\n    if (height === 0) {\n      offsetY = 0;\n    } else if (height && height < offsetY) {\n      offsetY = height;\n    }\n  }\n\n  return offsetY === Number.MAX_SAFE_INTEGER ? 0 : offsetY;\n}\n\n/**\n * Split words from a text by space and new line sign\n */\nfunction generateWords(text: string): string[] {\n  const wordsToLayout: string[] = [];\n  const lines: string[] = text.split(newLineRegEx);\n\n  for (let i = 0, endi = lines.length - 1; i < endi; i++) {\n    const line = lines[i];\n    const wordsInLine = line.split(\" \");\n\n    wordsInLine.forEach(word => {\n      if (word !== \"\") {\n        wordsToLayout.push(word);\n      }\n    });\n\n    // Create an element with text \"/n\" to indicate a new line will be created\n    wordsToLayout.push(\"/n\");\n  }\n\n  const lastLine = lines[lines.length - 1];\n  const wordsInLine = lastLine.split(\" \");\n\n  wordsInLine.forEach(word => {\n    if (word !== \"\") {\n      wordsToLayout.push(word);\n    }\n  });\n\n  return wordsToLayout;\n}\n\n/**\n * Generate the map for every glyph to offsetY, then we can use info to get correct offsetY for\n * every label by checking all the letters' offsetY of a label.\n */\nfunction generateGlyphOffsetYMap(\n  instance: TextAreaInstance,\n  kerningRequest: IFontResourceRequest\n) {\n  const glyphToOffsetY = new Map<string, number>();\n\n  if (kerningRequest.fontMap) {\n    const sourceFontSize = kerningRequest.fontMap.fontSource.size;\n    const fontScale = instance.fontSize / sourceFontSize;\n    const fontMap = kerningRequest.fontMap;\n    const checkText = instance.text.replace(/\\s/g, \"\");\n    let minY = Number.MAX_SAFE_INTEGER;\n    let offsetY = 0;\n    let kernY;\n    let leftChar = \"\";\n\n    for (let i = 0, iMax = checkText.length; i < iMax; ++i) {\n      const char = checkText[i];\n      kernY = 0;\n\n      if (leftChar) {\n        kernY = fontMap.kerning[leftChar][char][1] || 0;\n      }\n\n      offsetY = offsetY + kernY * fontScale;\n      glyphToOffsetY.set(char, offsetY);\n      minY = Math.min(offsetY, minY);\n      leftChar = char;\n    }\n\n    glyphToOffsetY.forEach((value, key) => {\n      glyphToOffsetY.set(key, value - minY);\n    });\n  }\n\n  return glyphToOffsetY;\n}\n\n/**\n * Generate glyphWidths for a label in a TextAreaInstance. It stores the widths of the first letter,\n * width of the first two letters, width of the first three letters untill the width of the label.\n * It will help to know where to wrap a word in character wordwrap mode.\n */\nfunction getGlyphWidths(\n  label: LabelInstance,\n  instance: TextAreaInstance,\n  kerningRequest: IFontResourceRequest\n) {\n  const glyphWidths = [];\n  const sourceFontSize = kerningRequest.fontMap\n    ? kerningRequest.fontMap.fontSource.size\n    : instance.fontSize;\n\n  const fontScale = instance.fontSize / sourceFontSize;\n\n  let leftChar = \"\";\n  let currentWidth = 0;\n  let offset: Vec2 = [0, 0];\n\n  for (let i = 0, iMax = label.text.length; i < iMax; i++) {\n    const char = label.text[i];\n\n    if (kerningRequest.fontMap) {\n      let kern: Vec2 = [0, 0];\n\n      if (leftChar) {\n        kern = kerningRequest.fontMap.kerning[leftChar][char] || [0, 0];\n      }\n\n      offset = add2(offset, scale2(kern, fontScale));\n      if (i !== 0) offset = add2(offset, [instance.letterSpacing, 0]);\n      const image = kerningRequest.fontMap.glyphMap[char];\n      currentWidth = offset[0] + image.pixelWidth * fontScale;\n      glyphWidths.push(currentWidth);\n      leftChar = char;\n    }\n  }\n\n  return glyphWidths;\n}\n\n/**\n * Constructor props for making a new label layer\n */\nexport interface ITextAreaLayerProps<T extends LabelInstance>\n  extends ILayer2DProps<T> {\n  /** Animation methods for various properties of the glyphs */\n  animateLabel?: {\n    anchor?: IAutoEasingMethod<Vec>;\n    color?: IAutoEasingMethod<Vec>;\n    offset?: IAutoEasingMethod<Vec>;\n    origin?: IAutoEasingMethod<Vec>;\n  };\n  /** Animation methods fro various properties of the borders */\n  animateBorder?: {\n    color?: IAutoEasingMethod<Vec>;\n    location?: IAutoEasingMethod<Vec>;\n  };\n  /** A custom layer to handle rendering glyph instances */\n  customGlyphLayer?: ILayerConstructionClass<\n    GlyphInstance,\n    IGlyphLayerOptions<GlyphInstance>\n  >;\n  /** String identifier of the resource font to use for the layer */\n  resourceKey?: string;\n  /** This number represents how much space each whitespace character represents */\n  whiteSpaceKerning?: number;\n  /** This sets the scaling mode of textArea, cound be ALWAYS, BOUND_MAX or NEVER */\n  scaling?: ScaleMode;\n}\n\n/**\n * This is a composite layer that will take in and manage Label Instances. The true instance\n * that will be rendered as a result of a Label Instance will simply be Glyph Instances. Hence\n * this is a composite layer that is merely a manager to split up the label's requested string\n * into Glyphs to render.\n */\nexport class TextAreaLayer<\n  T extends TextAreaInstance,\n  U extends ITextAreaLayerProps<T>\n> extends Layer2D<T, U> {\n  static defaultProps: ITextAreaLayerProps<TextAreaInstance> = {\n    key: \"\",\n    data: new InstanceProvider<TextAreaInstance>(),\n    scaling: ScaleMode.ALWAYS\n  };\n\n  providers = {\n    /** Provider for the label layer this layer manages */\n    labels: new InstanceProvider<LabelInstance>(),\n    /** Provider for the border layer that renders the border of text area */\n    borders: new InstanceProvider<BorderInstance>()\n  };\n\n  /**\n   * These are the property ids for the instances that we need to know when they changed so we can adjust\n   * the underlying glyphs.\n   */\n  propertyIds: { [key: string]: number } | undefined;\n  /**\n   * When this is flagged, we must do a complete recomputation of all our label's glyphs positions and kernings.\n   * This event really only takes place when the font resource changes.\n   */\n  fullUpdate: boolean = false;\n  /** Tracks all assigned labels to the text area */\n  areaToLabels = new Map<TextAreaInstance, TextAreaLabel[]>();\n  /** Tracks the labels assigned to an area and are grouped by the line they appear within */\n  areaToLines = new Map<TextAreaInstance, LabelInstance[][]>();\n  /** This stores all of the glyphs the label is waiting on to fire the onReady event. */\n  areaWaitingOnLabel = new Map<TextAreaInstance, Set<LabelInstance>>();\n  /** This stores kerningRequest of TextAreaInstance */\n  areaTokerningRequest = new Map<TextAreaInstance, IFontResourceRequest>();\n  /** This stores splited words of a textArea */\n  areaToWords = new Map<TextAreaInstance, string[]>();\n\n  labelsInLine: LabelInstance[] = [];\n\n  /**\n   * This provides the child layers that will render on behalf of this layer.\n   *\n   * For Labels, a label is simply a group of well placed glyphs. So we defer all of\n   * the labels changes by converting the label into glyphs and applying the changes to\n   * it's set of glyphs.\n   */\n  childLayers(): LayerInitializer[] {\n    const animateLabel = this.props.animateLabel || {};\n    const animateBorder = this.props.animateBorder || {};\n    const labelScaling = this.props.scaling;\n\n    return [\n      createLayer(LabelLayer, {\n        animate: animateLabel,\n        customGlyphLayer: this.props.customGlyphLayer,\n        data: this.providers.labels,\n        key: `${this.id}.labels`,\n        resourceKey: this.props.resourceKey,\n        scaleMode: labelScaling,\n        inTextArea: true\n      }),\n      createLayer(BorderLayer, {\n        animate: {\n          color: animateBorder.color,\n          location: animateBorder.location\n        },\n        data: this.providers.borders,\n        key: `${this.id}.border`\n      })\n    ];\n  }\n\n  /**\n   * We override the draw method of the layer to handle the diffs of the provider in a\n   * custom fashion by delegating the changes of the provider to the child layers.\n   */\n  draw() {\n    // Retrieve changes properly\n    const changes = this.resolveChanges();\n    // No changes, nothing to be done\n    if (changes.length <= 0) return;\n    // Make sure our instance property ids are established for the instance type involved\n    // We want only the ids of changes that causes us to\n    if (!this.propertyIds) {\n      const instance = changes[0][0];\n      this.propertyIds = this.getInstanceObservableIds(instance, [\n        \"active\",\n        \"alignment\",\n        \"borderWidth\",\n        \"color\",\n        \"fontSize\",\n        \"hasBorder\",\n        \"letterSpacing\",\n        \"lineHeight\",\n        \"maxHeight\",\n        \"maxWidth\",\n        \"origin\",\n        \"padding\",\n        \"text\",\n        \"wordWrap\"\n      ]);\n    }\n\n    const {\n      active: activeId,\n      alignment: alignmentId,\n      borderWidth: borderWidthId,\n      color: colorId,\n      fontSize: fontSizeId,\n      hasBorder: hasBorderId,\n      letterSpacing: letterSpacingId,\n      lineHeight: lineHeightId,\n      maxHeight: maxHeightId,\n      maxWidth: maxWidthId,\n      origin: originId,\n      padding: paddingId,\n      text: textId,\n      wordWrap: wordWrapId\n    } = this.propertyIds;\n\n    for (let i = 0, iMax = changes.length; i < iMax; ++i) {\n      const [instance, diffType, changed] = changes[i];\n\n      switch (diffType) {\n        case InstanceDiffType.CHANGE:\n          // Perform the insert action instead of the change if the textArea has never been registered\n          if (!this.areaToLabels.get(instance)) {\n            this.insert(instance);\n            continue;\n          }\n          // If text was changed, the glyphs all need updating of their characters and\n          // possibly have glyphs added or removed to handle the issue.\n          if (changed[textId] !== undefined) {\n            this.clear(instance);\n            this.updateLabels(instance);\n            this.layout(instance);\n          } else if (changed[activeId] !== undefined) {\n            if (instance.active) {\n              this.layout(instance);\n              this.showLabels(instance);\n            } else {\n              this.hideLabels(instance);\n            }\n          }\n\n          if (changed[alignmentId] !== undefined) {\n            this.clear(instance);\n            this.updateLabels(instance);\n            this.layoutLabels(instance);\n          }\n\n          if (changed[colorId] !== undefined) {\n            this.updateLabelColors(instance);\n          }\n\n          if (changed[originId] !== undefined) {\n            this.updateLabelOrigins(instance);\n          }\n\n          if (changed[fontSizeId] !== undefined) {\n            this.updateLabelFontSizes(instance);\n          }\n\n          if (changed[wordWrapId] !== undefined) {\n            this.updateLabelLineWrap(instance);\n          }\n\n          if (changed[lineHeightId] !== undefined) {\n            this.updateLabelLineHeight(instance);\n          }\n\n          if (changed[maxWidthId] !== undefined) {\n            this.updateTextAreaSize(instance);\n          }\n\n          if (changed[maxHeightId] !== undefined) {\n            this.updateTextAreaSize(instance);\n          }\n\n          if (changed[paddingId] !== undefined) {\n            this.updateTextAreaSize(instance);\n          }\n\n          if (changed[borderWidthId] !== undefined) {\n            this.updateBorderWidth(instance);\n          }\n\n          if (changed[hasBorderId] !== undefined) {\n            this.updateBorder(instance);\n          }\n\n          if (changed[letterSpacingId] !== undefined) {\n            this.updateLetterSpacing(instance);\n          }\n\n          break;\n\n        case InstanceDiffType.INSERT:\n          // Insertions force a full update of all labels for the text-area\n          this.insert(instance);\n          break;\n\n        case InstanceDiffType.REMOVE:\n          const labels = this.areaToLabels.get(instance);\n\n          if (labels) {\n            for (let i = 0, iMax = labels.length; i < iMax; ++i) {\n              const label = labels[i];\n              if (label instanceof LabelInstance) {\n                this.providers.labels.remove(label);\n              }\n            }\n\n            this.areaToLabels.delete(instance);\n            this.areaWaitingOnLabel.delete(instance);\n          }\n          break;\n      }\n    }\n  }\n\n  /**\n   * Handles insertion operation for the textArea\n   */\n  private insert(instance: T) {\n    this.layout(instance);\n    this.updateLabels(instance);\n  }\n\n  /**\n   * When the glyph is ready to render this executes.\n   */\n  handleLabelReady = (label: LabelInstance) => {\n    // The glyph must be associated to have this work\n    if (!label.parentTextArea) {\n      // If no parent text area, we should not have this glyph returning false alarms to this method\n      delete label.onReady;\n\n      return;\n    }\n\n    // Get the text area this label is a part of\n    const textArea = label.parentTextArea;\n    // Get the list of glyphs the label is waiting on.\n    const waiting = this.areaWaitingOnLabel.get(textArea);\n\n    if (!waiting) {\n      return;\n    }\n\n    // Clear this label from the waiting list\n    if (waiting.has(label)) {\n      waiting.delete(label);\n\n      if (waiting.size <= 0) {\n        textArea.active = true;\n        // If the waiting list is empty we can get the label to execute it's ready handler\n        const onReady = textArea.onReady;\n        // Execute the callback if present\n        if (onReady) onReady(textArea);\n      }\n    }\n  };\n\n  /**\n   * Unmount all of the glyphs that make the label\n   */\n  hideLabels(instance: T) {\n    const labels = this.areaToLabels.get(instance);\n    if (!labels) return;\n\n    for (let i = 0, iMax = labels.length; i < iMax; ++i) {\n      const label = labels[i];\n      if (label instanceof LabelInstance) {\n        this.providers.labels.remove(label);\n      }\n    }\n  }\n\n  /**\n   * Tell the system this layer is not providing any rendering IO information for the GPU to render.\n   */\n  initShader() {\n    return null;\n  }\n\n  /** When text is changed, labels should be clear in order to generate new labels */\n  clear(instance: T) {\n    const labels = instance.labels;\n\n    for (let i = 0, iMax = labels.length; i < iMax; i++) {\n      const label = labels[i];\n      if (label instanceof LabelInstance) {\n        this.providers.labels.remove(label);\n      }\n    }\n\n    instance.labels = [];\n    const newLabels = instance.newLabels;\n\n    for (let i = 0, iMax = newLabels.length; i < iMax; i++) {\n      const label = newLabels[i];\n      if (label instanceof LabelInstance) {\n        this.providers.labels.remove(label);\n      }\n    }\n\n    instance.newLabels = [];\n    this.areaToLabels.delete(instance);\n    this.areaWaitingOnLabel.delete(instance);\n    this.areaToWords.delete(instance);\n  }\n\n  /** When a label exceeds the maxWidth of a textArea, sperate it into several parts */\n  seperateLabel(\n    instance: TextAreaInstance,\n    label: LabelInstance,\n    glyphToHeight: Map<string, number>,\n    word: string,\n    index: number,\n    currentX: number,\n    currentY: number,\n    spaceWidth: number,\n    glyphWidths: number[]\n  ): [number, number] {\n    const topPadding = instance.padding[0];\n    const rightPadding = instance.padding[1] || 0;\n    const bottomPadding = instance.padding[2] || 0;\n    const leftPadding = instance.padding[3] || 0;\n    const maxWidth = instance.maxWidth - leftPadding - rightPadding;\n    const maxHeight = instance.maxHeight - topPadding - bottomPadding;\n    const originX = instance.origin[0];\n    const originY = instance.origin[1];\n\n    label.active = false;\n\n    // Label1\n    const text1 = word.substring(0, index + 1);\n    const offsetY1 = getOffsetY(text1, glyphToHeight);\n    const textAreaAnchor = anchorCalulater[instance.anchor.type](instance);\n\n    const label1 = new LabelInstance({\n      anchor: {\n        padding: 0,\n        type: AnchorType.Custom,\n        paddingDirection: [\n          currentX + leftPadding,\n          currentY + topPadding + offsetY1\n        ],\n        x: textAreaAnchor[0],\n        y: textAreaAnchor[1]\n      },\n      color: instance.color,\n      fontSize: instance.fontSize,\n      letterSpacing: instance.letterSpacing,\n      origin: [originX, originY],\n      text: text1\n    });\n\n    label1.size = [glyphWidths[index], label.size[1]];\n    this.providers.labels.add(label1);\n    instance.newLabels.push(label1);\n\n    this.labelsInLine.push(label1);\n    currentX += label1.getWidth() + spaceWidth;\n\n    // New Line if word wrap mode is normal\n    if (\n      instance.wordWrap === WordWrap.CHARACTER ||\n      instance.wordWrap === WordWrap.WORD\n    ) {\n      this.setTextAlignment(\n        currentX,\n        currentY,\n        spaceWidth,\n        maxWidth,\n        instance.alignment\n      );\n\n      currentX = 0;\n      currentY += instance.lineHeight;\n\n      // Label2\n      if (currentY + instance.lineHeight <= maxHeight) {\n        let widthLeft =\n          glyphWidths[glyphWidths.length - 1] - glyphWidths[index];\n\n        while (\n          widthLeft > maxWidth &&\n          currentY + instance.lineHeight <= maxHeight\n        ) {\n          let lastIndexOfLine = glyphWidths.length - 1;\n\n          // Get the lastIndex in a label that stay in current line\n          while (glyphWidths[lastIndexOfLine] - glyphWidths[index] > maxWidth) {\n            lastIndexOfLine--;\n          }\n\n          const text = word.substring(index + 1, lastIndexOfLine + 1);\n          const offsetY = getOffsetY(text, glyphToHeight);\n          const label3 = new LabelInstance({\n            anchor: {\n              padding: 0,\n              type: AnchorType.Custom,\n              paddingDirection: [\n                currentX + leftPadding,\n                currentY + topPadding + offsetY\n              ],\n              x: textAreaAnchor[0],\n              y: textAreaAnchor[1]\n            },\n            color: instance.color,\n            fontSize: instance.fontSize,\n            letterSpacing: instance.letterSpacing,\n            origin: [originX, originY],\n            text\n          });\n\n          label3.size = [\n            glyphWidths[lastIndexOfLine] - glyphWidths[index],\n            label.size[1]\n          ];\n\n          currentX += label3.getWidth() + spaceWidth;\n\n          this.labelsInLine.push(label3);\n\n          this.providers.labels.add(label3);\n          instance.newLabels.push(label3);\n\n          this.setTextAlignment(\n            currentX,\n            currentY,\n            spaceWidth,\n            maxWidth,\n            instance.alignment\n          );\n\n          currentX = 0;\n          currentY += instance.lineHeight;\n          index = lastIndexOfLine;\n          widthLeft = glyphWidths[glyphWidths.length - 1] - glyphWidths[index];\n        }\n\n        if (currentY + instance.lineHeight <= maxHeight) {\n          const text2 = word.substring(index + 1);\n          const offsetY2 = getOffsetY(text2, glyphToHeight);\n          const label2 = new LabelInstance({\n            anchor: {\n              padding: 0,\n              type: AnchorType.Custom,\n              paddingDirection: [\n                currentX + leftPadding,\n                currentY + topPadding + offsetY2\n              ],\n              x: textAreaAnchor[0],\n              y: textAreaAnchor[1]\n            },\n            color: instance.color,\n            fontSize: instance.fontSize,\n            letterSpacing: instance.letterSpacing,\n            origin: [originX, originY],\n            text: text2\n          });\n\n          label2.size = [\n            glyphWidths[glyphWidths.length - 1] - glyphWidths[index],\n            label.size[1]\n          ];\n\n          this.labelsInLine.push(label2);\n\n          const widths: number[] = [];\n\n          for (let i = index + 1; i < glyphWidths.length; i++) {\n            widths.push(glyphWidths[i] - glyphWidths[index]);\n          }\n\n          this.providers.labels.add(label2);\n          instance.newLabels.push(label2);\n\n          currentX += label2.getWidth() + spaceWidth;\n        }\n      }\n    }\n\n    // If wordWrap is NONE, stay in the line\n    else if (instance.wordWrap === WordWrap.NONE) {\n      currentX += label1.getWidth() + spaceWidth;\n    }\n\n    return [currentX, currentY];\n  }\n\n  /**\n   * This updates textAreaInstance after lineWrap is changed\n   */\n  updateLabelLineWrap(instance: T) {\n    const labels = this.areaToLabels.get(instance);\n    if (!labels) return;\n\n    // Set active of all labels to be true in order to awake those hidden labels when wrapping word\n    for (let i = 0, iMax = labels.length; i < iMax; ++i) {\n      const label = labels[i];\n      if (label instanceof LabelInstance) {\n        label.active = true;\n      }\n    }\n\n    // Clear all new labels\n    for (let i = 0, iMax = instance.newLabels.length; i < iMax; ++i) {\n      const label = instance.newLabels[i];\n      this.providers.labels.remove(label);\n    }\n\n    instance.newLabels = [];\n    this.layoutLabels(instance);\n  }\n\n  /**\n   * This updates textAreaInstance after lineHeight is changed\n   */\n  updateLabelLineHeight(instance: T) {\n    const labels = this.areaToLabels.get(instance);\n    if (!labels) return;\n\n    // Set active of all labels to be true in order to awake those hidden labels when wrapping word\n    for (let i = 0, iMax = labels.length; i < iMax; ++i) {\n      const label = labels[i];\n      if (label instanceof LabelInstance) {\n        label.active = true;\n      }\n    }\n\n    // Clear all new labels\n    for (let i = 0, iMax = instance.newLabels.length; i < iMax; ++i) {\n      const label = instance.newLabels[i];\n      this.providers.labels.remove(label);\n    }\n\n    instance.newLabels = [];\n    this.layoutLabels(instance);\n  }\n\n  /**\n   * This updates textAreaInstance after textArea width or height is changed\n   */\n  updateTextAreaSize(instance: T) {\n    const labels = this.areaToLabels.get(instance);\n    if (!labels) return;\n\n    // Set active of all labels to be true in order to awake those hidden labels when wrapping word\n    for (let i = 0, iMax = labels.length; i < iMax; ++i) {\n      const label = labels[i];\n      if (label instanceof LabelInstance) {\n        label.active = true;\n      }\n    }\n\n    // Clear all new labels\n    for (let i = 0, iMax = instance.newLabels.length; i < iMax; ++i) {\n      const label = instance.newLabels[i];\n      this.providers.labels.remove(label);\n    }\n\n    instance.newLabels = [];\n\n    // Clear all borders\n    for (let i = 0, iMax = instance.borders.length; i < iMax; ++i) {\n      const border = instance.borders[i];\n      this.providers.borders.remove(border);\n    }\n\n    instance.borders = [];\n    this.layoutBorder(instance);\n    this.layoutLabels(instance);\n  }\n\n  /**\n   * Update thickness of border\n   */\n  updateBorderWidth(instance: T) {\n    // Clear all borders\n    for (let i = 0, iMax = instance.borders.length; i < iMax; ++i) {\n      const border = instance.borders[i];\n      this.providers.borders.remove(border);\n    }\n\n    instance.borders = [];\n    this.layoutBorder(instance);\n  }\n\n  /**\n   * Update the border of textArea to remove border or add border\n   */\n  updateBorder(instance: T) {\n    if (instance.hasBorder) {\n      this.layoutBorder(instance);\n    } else {\n      for (let i = 0, iMax = instance.borders.length; i < iMax; ++i) {\n        const border = instance.borders[i];\n        this.providers.borders.remove(border);\n      }\n\n      instance.borders = [];\n    }\n  }\n\n  /**\n   * Update letterSpacing of all labels in textArea\n   */\n  updateLetterSpacing(instance: T) {\n    this.clear(instance);\n    this.updateLabels(instance);\n    this.layout(instance);\n  }\n\n  /**\n   * Sets the alignment of TextArea by adjusting all the labels' origin\n   */\n  setTextAlignment(\n    currentX: number,\n    currentY: number,\n    spaceWidth: number,\n    maxWidth: number,\n    alignment: TextAlignment\n  ) {\n    if (currentX - spaceWidth < maxWidth) {\n      if (alignment !== TextAlignment.LEFT) {\n        const offset = maxWidth - currentX + spaceWidth;\n        const toMove = alignment === TextAlignment.RIGHT ? offset : offset / 2;\n\n        this.labelsInLine.forEach(label => {\n          const oldAnchor = label.anchor;\n\n          label.anchor = {\n            padding: oldAnchor.padding,\n            type: AnchorType.Custom,\n            paddingDirection: [\n              (oldAnchor.paddingDirection ? oldAnchor.paddingDirection[0] : 0) +\n                toMove,\n              oldAnchor.paddingDirection\n                ? oldAnchor.paddingDirection[1]\n                : currentY\n            ],\n            x: oldAnchor.x,\n            y: oldAnchor.y\n          };\n        });\n      }\n    }\n\n    // Empty the labels array\n    this.labelsInLine = [];\n  }\n\n  /**\n   * Layout the border of textAreaInstance\n   */\n  layoutBorder(instance: T) {\n    if (instance.hasBorder) {\n      const kerningRequest = this.areaTokerningRequest.get(instance);\n      if (!kerningRequest) return;\n\n      const fontSourceSize = kerningRequest.fontMap\n        ? kerningRequest.fontMap.fontSource.size\n        : instance.fontSize;\n      const fontScale = instance.fontSize / fontSourceSize;\n      const scaling = this.props.scaling;\n      const borderWidth = instance.borderWidth;\n\n      const topBorder: BorderInstance = new BorderInstance({\n        color: instance.color,\n        fontScale,\n        scaling,\n        size: [instance.maxWidth + 2 * borderWidth, borderWidth],\n        textAreaOrigin: instance.origin,\n        textAreaAnchor: anchorCalulater[instance.anchor.type](instance),\n        position: [-borderWidth, -borderWidth]\n      });\n\n      const leftBorder: BorderInstance = new BorderInstance({\n        color: instance.color,\n        fontScale,\n        scaling,\n        size: [borderWidth, instance.maxHeight + 2 * borderWidth],\n        textAreaOrigin: instance.origin,\n        textAreaAnchor: anchorCalulater[instance.anchor.type](instance),\n        position: [-borderWidth, -borderWidth]\n      });\n\n      const rightBorder: BorderInstance = new BorderInstance({\n        color: instance.color,\n        fontScale,\n        scaling,\n        size: [borderWidth, instance.maxHeight + 2 * borderWidth],\n        textAreaOrigin: instance.origin,\n        textAreaAnchor: anchorCalulater[instance.anchor.type](instance),\n        position: [instance.maxWidth, -borderWidth]\n      });\n\n      const bottomBorder: BorderInstance = new BorderInstance({\n        color: instance.color,\n        fontScale,\n        scaling,\n        size: [instance.maxWidth + 2 * borderWidth, borderWidth],\n        textAreaOrigin: instance.origin,\n        textAreaAnchor: anchorCalulater[instance.anchor.type](instance),\n        position: [-borderWidth, instance.maxHeight]\n      });\n\n      this.providers.borders.add(topBorder);\n      this.providers.borders.add(leftBorder);\n      this.providers.borders.add(rightBorder);\n      this.providers.borders.add(bottomBorder);\n\n      instance.borders.push(topBorder);\n      instance.borders.push(leftBorder);\n      instance.borders.push(rightBorder);\n      instance.borders.push(bottomBorder);\n    }\n  }\n\n  /**\n   * Calculate the positions of labels\n   */\n  layoutLabels(instance: T) {\n    const kerningRequest = this.areaTokerningRequest.get(instance);\n    if (!kerningRequest) return;\n\n    const topPadding = instance.padding[0];\n    const rightPadding = instance.padding[1] || 0;\n    const bottomPadding = instance.padding[2] || 0;\n    const leftPadding = instance.padding[3] || 0;\n    const maxWidth = instance.maxWidth - leftPadding - rightPadding;\n    const maxHeight = instance.maxHeight - topPadding - bottomPadding;\n\n    const originX = instance.origin[0];\n    const originY = instance.origin[1];\n\n    let spaceWidth = 0;\n\n    if (instance.spaceWidth) {\n      spaceWidth = instance.spaceWidth;\n    } else {\n      if (kerningRequest.fontMap) {\n        const fontSourceSize = kerningRequest.fontMap.fontSource.size;\n        const fontScale = instance.fontSize / fontSourceSize;\n        spaceWidth = kerningRequest.fontMap.spaceWidth * fontScale;\n      } else {\n        spaceWidth = this.props.whiteSpaceKerning || instance.fontSize / 2;\n      }\n\n      instance.spaceWidth = spaceWidth;\n    }\n\n    const glyphToOffsetY = generateGlyphOffsetYMap(instance, kerningRequest);\n    let currentX = 0;\n    let currentY = 0;\n\n    this.labelsInLine = [];\n\n    // Layout labels within maxWidth and maxHeight one after one, line after line.\n    // Labels which exceed maxHeight will be hidden, labels which exceed maxWidth will be wrap,\n    // hidden to move to next line based on wordWrap mode.\n    for (let i = 0, endi = instance.labels.length; i < endi; ++i) {\n      const label = instance.labels[i];\n\n      if (label instanceof LabelInstance) {\n        const width = label.getWidth();\n        const offsetY = getOffsetY(label.text, glyphToOffsetY);\n        const glyphWidths = getGlyphWidths(label, instance, kerningRequest);\n\n        // label.textAreaOrigin = [originX, originY];\n        // Make sure all the labels are within maxHeight and first letter is not bigger than maxWidth\n        if (\n          currentY + instance.lineHeight <= maxHeight &&\n          glyphWidths[0] <= maxWidth\n        ) {\n          // Whole label can be put within maxWidth\n          if (currentX + width <= maxWidth) {\n            label.origin = [originX, originY];\n            const textAreaAnchor = anchorCalulater[instance.anchor.type](\n              instance\n            );\n\n            label.anchor = {\n              padding: 0,\n              paddingDirection: [\n                currentX + leftPadding,\n                currentY + topPadding + offsetY\n              ],\n              type: AnchorType.Custom,\n              x: textAreaAnchor[0],\n              y: textAreaAnchor[1]\n            };\n\n            currentX += width + spaceWidth;\n            this.labelsInLine.push(label);\n\n            if (currentX >= maxWidth) {\n              // If next label is not NEWLINE, no need to move to next line\n              if (\n                instance.wordWrap === WordWrap.CHARACTER &&\n                i + 1 < endi &&\n                instance.labels[i + 1] !== NewLineCharacterMode.NEWLINE\n              ) {\n                this.setTextAlignment(\n                  currentX,\n                  currentY,\n                  spaceWidth,\n                  maxWidth,\n                  instance.alignment\n                );\n\n                currentX = 0;\n                currentY += instance.lineHeight;\n              }\n            }\n          } else {\n            // A label which will just put to next line if it exceeds the maxWidth when in WORD mode\n            // The label's width should be smaller than maxWidth\n            if (\n              instance.wordWrap === WordWrap.WORD &&\n              label.getWidth() <= instance.maxWidth\n            ) {\n              this.setTextAlignment(\n                currentX,\n                currentY,\n                spaceWidth,\n                maxWidth,\n                instance.alignment\n              );\n\n              currentX = 0;\n              currentY += instance.lineHeight;\n\n              if (currentY + instance.lineHeight <= maxHeight) {\n                label.origin = [originX, originY];\n                const textAreaAnchor = anchorCalulater[instance.anchor.type](\n                  instance\n                );\n                label.anchor = {\n                  padding: 0,\n                  paddingDirection: [\n                    currentX + leftPadding,\n                    currentY + topPadding + offsetY\n                  ],\n                  type: AnchorType.Custom,\n                  x: textAreaAnchor[0],\n                  y: textAreaAnchor[1]\n                };\n\n                this.labelsInLine.push(label);\n\n                currentX += label.getWidth() + spaceWidth;\n              } else {\n                label.active = false;\n              }\n            }\n            // A label will be cut into two parts if label's width exceeds maxwidth\n            else {\n              const spaceLeft = maxWidth - currentX;\n              let index = glyphWidths.length - 1;\n              const word = label.text;\n\n              // Find the index to retrieve the part of word that stay in this line\n              while (glyphWidths[index] > spaceLeft) {\n                index--;\n              }\n\n              // Some part of label stay in this line\n              if (index >= 0) {\n                const sizes = this.seperateLabel(\n                  instance,\n                  label,\n                  glyphToOffsetY,\n                  word,\n                  index,\n                  currentX,\n                  currentY,\n                  spaceWidth,\n                  glyphWidths\n                );\n\n                currentX = sizes[0];\n                currentY = sizes[1];\n              }\n              // The whole word moves to next line or set active false if index < 0\n              else {\n                if (\n                  instance.wordWrap === WordWrap.CHARACTER ||\n                  instance.wordWrap === WordWrap.WORD\n                ) {\n                  this.setTextAlignment(\n                    currentX,\n                    currentY,\n                    spaceWidth,\n                    maxWidth,\n                    instance.alignment\n                  );\n\n                  // Move position to next line\n                  currentY += instance.lineHeight;\n                  currentX = 0;\n\n                  if (currentY + instance.lineHeight < maxHeight) {\n                    // Put label with in the line\n                    if (currentX + label.getWidth() <= maxWidth) {\n                      label.origin = [originX, originY];\n                      const textAreaAnchor = anchorCalulater[\n                        instance.anchor.type\n                      ](instance);\n\n                      label.anchor = {\n                        padding: 0,\n                        paddingDirection: [\n                          currentX + leftPadding,\n                          currentY + topPadding + offsetY\n                        ],\n                        type: AnchorType.Custom,\n                        x: textAreaAnchor[0],\n                        y: textAreaAnchor[1]\n                      };\n\n                      this.labelsInLine.push(label);\n\n                      currentX += label.getWidth() + spaceWidth;\n\n                      if (\n                        currentX >= maxWidth &&\n                        i + 1 < endi &&\n                        instance.labels[i + 1] !== NewLineCharacterMode.NEWLINE\n                      ) {\n                        this.setTextAlignment(\n                          currentX,\n                          currentY,\n                          spaceWidth,\n                          maxWidth,\n                          instance.alignment\n                        );\n\n                        currentX = 0;\n                        currentY += instance.lineHeight;\n                      }\n                    }\n                    // Put part of label in this line, move other part to following lines\n                    else {\n                      const spaceLeft = maxWidth - currentX;\n                      let index = glyphWidths.length - 1;\n                      const word = label.text;\n\n                      while (glyphWidths[index] > spaceLeft) {\n                        index--;\n                      }\n\n                      if (index >= 0) {\n                        const sizes = this.seperateLabel(\n                          instance,\n                          label,\n                          glyphToOffsetY,\n                          word,\n                          index,\n                          currentX,\n                          currentY,\n                          spaceWidth,\n                          glyphWidths\n                        );\n\n                        currentX = sizes[0];\n                        currentY = sizes[1];\n                      }\n                    }\n                  }\n                  // Exceeds maxHeight\n                  else {\n                    label.active = false;\n                  }\n                }\n                // Word which is supposed to put to next line set false when lineWrap is none\n                else if (instance.wordWrap === WordWrap.NONE) {\n                  label.active = false;\n                }\n              }\n            }\n          }\n        }\n\n        // Exceeds maxHeight\n        else {\n          label.active = false;\n        }\n      }\n\n      // New line\n      else if (label === NewLineCharacterMode.NEWLINE) {\n        this.setTextAlignment(\n          currentX,\n          currentY,\n          spaceWidth,\n          maxWidth,\n          instance.alignment\n        );\n\n        currentX = 0;\n        currentY += instance.lineHeight;\n      }\n    }\n\n    this.setTextAlignment(\n      currentX,\n      currentY,\n      spaceWidth,\n      maxWidth,\n      instance.alignment\n    );\n  }\n\n  /**\n   * This uses calculated kerning information to place the glyph relative to it's left character neighbor.\n   * The first glyph will use metrics of the glyphs drop down amount to determine where the glyph\n   * will be placed.\n   */\n  layout(instance: T) {\n    this.updateKerning(instance);\n    const kerningRequest = this.areaTokerningRequest.get(instance);\n    if (!kerningRequest || !kerningRequest.fontMap) return;\n\n    // Make sure the labels are all rendered\n    const waiting = this.areaWaitingOnLabel.get(instance);\n    if (waiting && waiting.size > 0) return;\n    // Instance must be active\n    if (!instance.active) return;\n    // Glyphs must be established for the label to continue\n    const labels = this.areaToLabels.get(instance);\n    if (!labels || labels.length === 0) return;\n\n    this.updateLabels(instance);\n    this.layoutBorder(instance);\n    this.layoutLabels(instance);\n  }\n\n  /**\n   * Update kerning of textArea Instance, retrieve kerning request from map or create a new one\n   */\n  updateKerning(instance: T) {\n    let labelKerningRequest = this.areaTokerningRequest.get(instance);\n    const checkText = instance.text;\n\n    if (labelKerningRequest) {\n      if (\n        labelKerningRequest.kerningPairs &&\n        labelKerningRequest.kerningPairs.indexOf(checkText) > -1\n      ) {\n        return Boolean(labelKerningRequest.fontMap);\n      }\n\n      if (\n        labelKerningRequest.fontMap &&\n        !labelKerningRequest.fontMap.supportsKerning(checkText)\n      ) {\n        this.areaTokerningRequest.delete(instance);\n        labelKerningRequest = undefined;\n      } else {\n        return false;\n      }\n    } else {\n      const metrics: IFontResourceRequest[\"metrics\"] = {\n        fontSize: instance.fontSize,\n        text: instance.text,\n        letterSpacing: instance.letterSpacing\n      };\n\n      labelKerningRequest = fontRequest({\n        character: \"\",\n        key: this.props.resourceKey || \"\",\n        kerningPairs: [checkText],\n        metrics\n      });\n\n      if (!instance.preload) {\n        this.resource.request(this, instance, labelKerningRequest);\n        this.areaTokerningRequest.set(instance, labelKerningRequest);\n      } else {\n        instance.resourceTrigger = () => {\n          if (instance.onReady) instance.onReady(instance);\n        };\n\n        this.resource.request(this, instance, labelKerningRequest);\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * This layer does not have or use a buffer manager thus it must track management of an instance\n   * in it's own way.\n   */\n  managesInstance(instance: T) {\n    return Boolean(this.areaToLabels.get(instance));\n  }\n\n  /**\n   * This makes a label's glyphs visible by adding them to the glyph layer rendering the glyphs.\n   */\n  showLabels(instance: T) {\n    const labels = this.areaToLabels.get(instance);\n    if (!labels) return;\n\n    for (let i = 0, iMax = labels.length; i < iMax; ++i) {\n      const label = labels[i];\n      if (label instanceof LabelInstance) {\n        this.providers.labels.add(label);\n      }\n    }\n  }\n\n  /**\n   * This ensures the correct number of glyphs is being provided for the label indicated.\n   */\n  updateLabels(instance: T) {\n    let currentLabels = this.areaToLabels.get(instance);\n    const topPadding = instance.padding[0];\n    const leftPadding = instance.padding[3] || 0;\n    const originX = instance.origin[0] + leftPadding;\n    const originY = instance.origin[1] + topPadding;\n\n    if (!currentLabels) {\n      currentLabels = [];\n      this.areaToLabels.set(instance, currentLabels);\n    }\n\n    let waiting = this.areaWaitingOnLabel.get(instance);\n\n    if (!waiting) {\n      waiting = new Set();\n      this.areaWaitingOnLabel.set(instance, waiting);\n    }\n\n    let wordsToLayout = this.areaToWords.get(instance);\n\n    if (!wordsToLayout) {\n      wordsToLayout = generateWords(instance.text);\n    }\n\n    if (currentLabels.length < wordsToLayout.length) {\n      for (\n        let i = currentLabels.length, iMax = wordsToLayout.length;\n        i < iMax;\n        ++i\n      ) {\n        const word = wordsToLayout[i];\n\n        if (word === \"/n\") {\n          currentLabels.push(NewLineCharacterMode.NEWLINE);\n        } else {\n          const label = new LabelInstance({\n            active: false,\n            color: instance.color,\n            fontSize: instance.fontSize,\n            letterSpacing: instance.letterSpacing,\n            text: word,\n            origin: [originX, originY],\n            onReady: this.handleLabelReady\n          });\n\n          label.parentTextArea = instance;\n          currentLabels.push(label);\n          this.providers.labels.add(label);\n          waiting.add(label);\n        }\n      }\n    }\n\n    instance.labels = currentLabels;\n  }\n\n  /**\n   * Updates the label colors to match the label's label colors\n   */\n  updateLabelColors(instance: T) {\n    const labels = this.areaToLabels.get(instance);\n    if (!labels) return;\n\n    for (let i = 0, iMax = labels.length; i < iMax; ++i) {\n      const label = labels[i];\n      if (label instanceof LabelInstance) {\n        label.color = copy4(instance.color);\n      }\n    }\n\n    for (let i = 0, endi = instance.newLabels.length; i < endi; ++i) {\n      instance.newLabels[i].color = copy4(instance.color);\n    }\n\n    for (let i = 0, endi = instance.borders.length; i < endi; ++i) {\n      instance.borders[i].color = copy4(instance.color);\n    }\n  }\n\n  /**\n   * Updates fontsize of all labels\n   */\n  updateLabelFontSizes(instance: T) {\n    this.clear(instance);\n    this.updateLabels(instance);\n    this.areaTokerningRequest.delete(instance);\n    this.layout(instance);\n  }\n\n  /**\n   * This updates all of the labels for the label to have the same position\n   * as the label.\n   */\n  updateLabelOrigins(instance: T) {\n    const labels = this.areaToLabels.get(instance);\n    if (!labels) return;\n    const origin = instance.origin;\n    const oldOrigin = instance.oldOrigin;\n\n    // Update new origins of all labels\n    for (let i = 0, iMax = labels.length; i < iMax; ++i) {\n      const label = labels[i];\n      if (label instanceof LabelInstance) {\n        const labelOrigin = label.origin;\n        label.origin = [\n          labelOrigin[0] + origin[0] - oldOrigin[0],\n          labelOrigin[1] + origin[1] - oldOrigin[1]\n        ];\n      }\n    }\n\n    // Update new origins of all new labels\n    for (let i = 0, iMax = instance.newLabels.length; i < iMax; ++i) {\n      const label = instance.newLabels[i];\n      if (label instanceof LabelInstance) {\n        const labelOrigin = label.origin;\n        label.origin = [\n          labelOrigin[0] + origin[0] - oldOrigin[0],\n          labelOrigin[1] + origin[1] - oldOrigin[1]\n        ];\n      }\n    }\n\n    // Update all borders new location\n    for (let i = 0, iMax = instance.borders.length; i < iMax; ++i) {\n      const border = instance.borders[i];\n      border.position = [\n        border.position[0] + origin[0] - oldOrigin[0],\n        border.position[1] + origin[1] - oldOrigin[1]\n      ];\n    }\n\n    instance.oldOrigin = instance.origin;\n  }\n\n  /**\n   * If our resource changes, we need a full update of all instances.\n   * If our provider changes, we probably want to ensure our property identifiers are correct.\n   */\n  willUpdateProps(newProps: U) {\n    if (newProps.data !== this.props.data) {\n      delete this.propertyIds;\n    }\n\n    if (newProps.resourceKey !== this.props.resourceKey) {\n      this.fullUpdate = true;\n    }\n  }\n}\n","import { observable } from \"../../../instance-provider\";\nimport { Vec2 } from \"../../../math\";\nimport {\n  IRectangleInstanceOptions,\n  RectangleInstance\n} from \"../rectangle/rectangle-instance\";\n\nexport interface IBorderInstanceOptions extends IRectangleInstanceOptions {\n  /** Sets the fontScale of textArea the border locates */\n  fontScale?: number;\n  /** Sets the textArea's origin where the border is in */\n  textAreaOrigin?: Vec2;\n  /** Set the textArea's anchor where the border is in */\n  textAreaAnchor?: Vec2;\n}\n\nexport class BorderInstance extends RectangleInstance {\n  /** FontScale is used to help the scaling of border in a right amount */\n  @observable fontScale: number = 1;\n  /** TextArea's origin where the border is in */\n  @observable textAreaOrigin: Vec2 = [0, 0];\n  /** TextArea's anchor where the border is in */\n  @observable textAreaAnchor: Vec2 = [0, 0];\n\n  constructor(options: IBorderInstanceOptions) {\n    super(options);\n    this.fontScale = options.fontScale || this.fontScale;\n    this.textAreaOrigin = options.textAreaOrigin || this.textAreaOrigin;\n    this.textAreaAnchor = options.textAreaAnchor || this.textAreaAnchor;\n  }\n}\n","import { InstanceProvider } from \"../../../instance-provider\";\nimport { IAutoEasingMethod, Vec } from \"../../../math\";\nimport {\n  ILayerMaterialOptions,\n  InstanceAttributeSize,\n  IShaderInitialization,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../../types\";\nimport { CommonMaterialOptions } from \"../../../util/common-options\";\nimport { ILayer2DProps, Layer2D } from \"../../view\";\nimport { BorderInstance } from \"./border-instance\";\n\nexport interface IBorderLayerProps<T extends BorderInstance>\n  extends ILayer2DProps<T> {\n  animate?: {\n    color?: IAutoEasingMethod<Vec>;\n    location?: IAutoEasingMethod<Vec>;\n  };\n  atlas?: string;\n  /** Scale factor determining the scale size of the border */\n  scaleFactor?(): number;\n}\n\n/**\n * This layer displays Borders and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class BorderLayer<\n  T extends BorderInstance,\n  U extends IBorderLayerProps<T>\n> extends Layer2D<T, U> {\n  static defaultProps: IBorderLayerProps<BorderInstance> = {\n    key: \"\",\n    data: new InstanceProvider<BorderInstance>()\n  };\n\n  static attributeNames = {\n    anchor: \"anchor\",\n    color: \"color\",\n    depth: \"depth\",\n    fontScale: \"fontScale\",\n    location: \"location\",\n    maxScale: \"maxScale\",\n    scale: \"scale\",\n    scaling: \"scaling\",\n    size: \"size\"\n  };\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<BorderInstance> {\n    const animate = this.props.animate || {};\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: 0,\n      1: 0,\n      2: 0,\n      3: 1,\n      4: 1,\n      5: 1\n    };\n\n    const { scaleFactor = () => 1 } = this.props;\n\n    return {\n      fs: require(\"./border-layer.fs\"),\n      instanceAttributes: [\n        {\n          easing: animate.location,\n          name: BorderLayer.attributeNames.location,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.position\n        },\n        {\n          name: BorderLayer.attributeNames.anchor,\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.anchor.x || 0, o.anchor.y || 0]\n        },\n        {\n          name: BorderLayer.attributeNames.size,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.size\n        },\n        {\n          name: BorderLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        {\n          name: BorderLayer.attributeNames.scaling,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scaling]\n        },\n        {\n          easing: animate.color,\n          name: BorderLayer.attributeNames.color,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.color\n        },\n        {\n          name: BorderLayer.attributeNames.scale,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scale]\n        },\n        {\n          name: BorderLayer.attributeNames.maxScale,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.maxScale]\n        },\n        {\n          name: BorderLayer.attributeNames.fontScale,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.fontScale]\n        },\n        {\n          name: \"textAreaOrigin\",\n          size: InstanceAttributeSize.TWO,\n          update: o => o.textAreaOrigin\n        },\n        {\n          name: \"textAreaAnchor\",\n          size: InstanceAttributeSize.TWO,\n          update: o => o.textAreaAnchor\n        }\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: _u => [scaleFactor()]\n        }\n      ],\n      vertexAttributes: [\n        {\n          name: \"normals\",\n          size: VertexAttributeSize.TWO,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexToSide[vertex]\n          ]\n        }\n      ],\n      vertexCount: 6,\n      vs: require(\"./border-layer.vs\")\n    };\n  }\n\n  getMaterialOptions(): ILayerMaterialOptions {\n    return CommonMaterialOptions.transparentShapeBlending;\n  }\n}\n","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvoid main() {\\nsetColor(vertexColor);\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvoid main() {\\nfloat borderScale = mix(fontScale, 1.0, float(scaling == 3.0));\\nvec3 screenSize = cameraSpaceSize(vec3(size * scale * borderScale / scaleFactor / maxScale, 1.0));\\nbool largerOnScreen = screenSize.y > size.y || screenSize.x > size.x;\\nfloat useScaleMode = float(\\n(\\nscaling == 3.0 ||\\n(largerOnScreen && scaling == 2.0)\\n) &&\\nscaling != 1.0\\n);\\nfloat unequalZooms = float(cameraScale2D.x != cameraScale2D.y);\\nvec2 adjustedSize = mix(\\nsize,\\n(size * cameraScale2D.yx),\\nunequalZooms\\n);\\nfloat normal = normals.x;\\nfloat side = normals.y;\\nvec2 scaledAnchor = anchor * scale;\\nvec2 worldAnchor = location + scaledAnchor;\\nvec2 adjustedAnchor = mix(\\nscaledAnchor,\\n(scaledAnchor * cameraScale2D.yx),\\nunequalZooms\\n);\\nvec2 vertex = vec2(side, float(normal == 1.0)) * scale * adjustedSize + location - adjustedAnchor;\\nfloat labelScreenScale = mix(\\nscreenSize.y / adjustedSize.y,\\nscreenSize.x / adjustedSize.x,\\nfloat((cameraScale2D.x != 1.0))\\n);\\nfloat currentScale = labelScreenScale * scale;\\nvec2 anchorToVertex = vertex - location;\\nvertex = mix(\\nvertex + textAreaOrigin,\\n(anchorToVertex + location - textAreaAnchor) / labelScreenScale + textAreaOrigin + textAreaAnchor,\\nuseScaleMode\\n);\\nvertexColor = color;\\ngl_Position = clipSpace(vec3(vertex, depth));\\n}\"","export * from \"./rectangle-layer\";\nexport * from \"./rectangle-instance\";\n","import { InstanceProvider } from \"../../../instance-provider\";\nimport { IAutoEasingMethod, Vec } from \"../../../math\";\nimport {\n  ILayerMaterialOptions,\n  InstanceAttributeSize,\n  IShaderInitialization,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../../types\";\nimport { CommonMaterialOptions } from \"../../../util\";\nimport { ILayer2DProps, Layer2D } from \"../../view/layer-2d\";\nimport { RectangleInstance } from \"./rectangle-instance\";\n\nexport interface IRectangleLayerProps<T extends RectangleInstance>\n  extends ILayer2DProps<T> {\n  animate?: {\n    color?: IAutoEasingMethod<Vec>;\n    location?: IAutoEasingMethod<Vec>;\n  };\n  /** Scale factor determining the scale size of the rectangle */\n  scaleFactor?(): number;\n}\n\n/**\n * This layer displays Rectangles and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class RectangleLayer<\n  T extends RectangleInstance,\n  U extends IRectangleLayerProps<T>\n> extends Layer2D<T, U> {\n  static defaultProps: IRectangleLayerProps<RectangleInstance> = {\n    key: \"\",\n    data: new InstanceProvider<RectangleInstance>()\n  };\n\n  static attributeNames = {\n    anchor: \"anchor\",\n    color: \"color\",\n    depth: \"depth\",\n    location: \"location\",\n    maxScale: \"maxScale\",\n    scale: \"scale\",\n    scaling: \"scaling\",\n    size: \"size\"\n  };\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<RectangleInstance> {\n    const animate = this.props.animate || {};\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: 0,\n      1: 0,\n      2: 0,\n      3: 1,\n      4: 1,\n      5: 1\n    };\n\n    const { scaleFactor = () => 1 } = this.props;\n\n    return {\n      fs: require(\"./rectangle-layer.fs\"),\n      instanceAttributes: [\n        {\n          easing: animate.location,\n          name: RectangleLayer.attributeNames.location,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.position\n        },\n        {\n          name: RectangleLayer.attributeNames.anchor,\n          size: InstanceAttributeSize.TWO,\n          update: o => [o.anchor.x || 0, o.anchor.y || 0]\n        },\n        {\n          name: RectangleLayer.attributeNames.size,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.size\n        },\n        {\n          name: RectangleLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        {\n          name: RectangleLayer.attributeNames.scaling,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scaling]\n        },\n        {\n          easing: animate.color,\n          name: RectangleLayer.attributeNames.color,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.color\n        },\n        {\n          name: RectangleLayer.attributeNames.scale,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.scale]\n        },\n        {\n          name: RectangleLayer.attributeNames.maxScale,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.maxScale]\n        }\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: _u => [scaleFactor()]\n        }\n      ],\n      vertexAttributes: [\n        {\n          name: \"normals\",\n          size: VertexAttributeSize.TWO,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexToSide[vertex]\n          ]\n        }\n      ],\n      vertexCount: 6,\n      vs: require(\"./rectangle-layer.vs\")\n    };\n  }\n\n  getMaterialOptions(): ILayerMaterialOptions {\n    return CommonMaterialOptions.transparentShapeBlending;\n  }\n}\n","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvoid main() {\\nsetColor(vertexColor);\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvoid main() {\\nvec3 screenSize = cameraSpaceSize(vec3(size * scale / scaleFactor / maxScale, 1.0));\\nbool largerOnScreen = screenSize.y > size.y || screenSize.x > size.x;\\nfloat useScaleMode = float(\\n(\\nscaling == 3.0 ||\\n(largerOnScreen && scaling == 2.0)\\n) &&\\nscaling != 1.0\\n);\\nfloat unequalZooms = float(cameraScale2D.x != cameraScale2D.y);\\nvec2 adjustedSize = mix(\\nsize,\\n(size * cameraScale2D.yx),\\nunequalZooms\\n);\\nfloat normal = normals.x;\\nfloat side = normals.y;\\nvec2 scaledAnchor = anchor * scale;\\nvec2 worldAnchor = location + scaledAnchor;\\nvec2 adjustedAnchor = mix(\\nscaledAnchor,\\n(scaledAnchor * cameraScale2D.yx),\\nunequalZooms\\n);\\nvec2 vertex = vec2(side, float(normal == 1.0)) * scale * adjustedSize + location - adjustedAnchor;\\nfloat labelScreenScale = mix(\\nscreenSize.y / adjustedSize.y,\\nscreenSize.x / adjustedSize.x,\\nfloat((cameraScale2D.x != 1.0))\\n);\\nfloat currentScale = labelScreenScale * scale;\\nvec2 anchorToVertex = vertex - location;\\nvertex = mix(\\nvertex,\\n(anchorToVertex / labelScreenScale) + location,\\nuseScaleMode\\n);\\nvertexColor = color;\\ngl_Position = clipSpace(vec3(vertex, depth));\\n}\"","export * from \"./ring-instance\";\nexport * from \"./ring-layer\";\n","import {\n  IInstanceOptions,\n  Instance\n} from \"../../../instance-provider/instance\";\nimport { observable } from \"../../../instance-provider/observable\";\nimport { Vec2 } from \"../../../math\";\n\nexport interface IRingInstanceOptions extends IInstanceOptions {\n  /** The center of the ring */\n  center?: Vec2;\n  /** The color of this ring */\n  color?: [number, number, number, number];\n  /** The z depth of the ring (for draw ordering) */\n  depth?: number;\n  /** The outer radius of the ring */\n  radius?: number;\n  /** The thickness of the ring */\n  thickness?: number;\n}\n\nexport class RingInstance extends Instance {\n  @observable color: [number, number, number, number] = [1.0, 1.0, 1.0, 1.0];\n  @observable depth: number = 0;\n  @observable radius: number = 0;\n  @observable thickness: number = 1;\n  @observable center: Vec2 = [0, 0];\n\n  constructor(options: IRingInstanceOptions) {\n    super(options);\n\n    this.color = options.color || this.color;\n    this.depth = options.depth || this.depth;\n    this.radius = options.radius || this.radius;\n    this.thickness = options.thickness || this.thickness;\n    this.center = options.center || this.center;\n  }\n\n  get width() {\n    return this.radius * 2;\n  }\n\n  get height() {\n    return this.radius * 2;\n  }\n\n  get innerRadius() {\n    return this.radius - this.thickness;\n  }\n}\n","import { InstanceProvider } from \"../../../instance-provider\";\nimport { IAutoEasingMethod, Vec } from \"../../../math\";\nimport {\n  ILayerMaterialOptions,\n  InstanceAttributeSize,\n  IShaderInitialization,\n  IUniform,\n  UniformSize,\n  VertexAttributeSize\n} from \"../../../types\";\nimport { CommonMaterialOptions } from \"../../../util\";\nimport { ILayer2DProps, Layer2D } from \"../../view/layer-2d\";\nimport { RingInstance } from \"./ring-instance\";\n\nexport interface IRingLayerProps<T extends RingInstance>\n  extends ILayer2DProps<T> {\n  /** This sets a scaling factor for the circle's radius */\n  scaleFactor?(): number;\n  animate?: {\n    color?: IAutoEasingMethod<Vec>;\n    center?: IAutoEasingMethod<Vec>;\n    radius?: IAutoEasingMethod<Vec>;\n  };\n}\n\n/**\n * This layer displays circles and provides as many controls as possible for displaying\n * them in interesting ways.\n */\nexport class RingLayer<\n  T extends RingInstance,\n  U extends IRingLayerProps<T>\n> extends Layer2D<T, U> {\n  static defaultProps: IRingLayerProps<RingInstance> = {\n    key: \"\",\n    data: new InstanceProvider<RingInstance>()\n  };\n\n  static attributeNames = {\n    center: \"center\",\n    radius: \"radius\",\n    depth: \"depth\",\n    color: \"color\",\n    thickness: \"thickness\"\n  };\n\n  /**\n   * Define our shader and it's inputs\n   */\n  initShader(): IShaderInitialization<RingInstance> {\n    const scaleFactor = this.props.scaleFactor || (() => 1);\n    const animations = this.props.animate || {};\n    const {\n      color: animateColor,\n      center: animateCenter,\n      radius: animateRadius\n    } = animations;\n\n    const vertexToNormal: { [key: number]: number } = {\n      0: 1,\n      1: 1,\n      2: -1,\n      3: 1,\n      4: -1,\n      5: -1\n    };\n\n    const vertexToSide: { [key: number]: number } = {\n      0: -1,\n      1: -1,\n      2: -1,\n      3: 1,\n      4: 1,\n      5: 1\n    };\n\n    return {\n      fs: require(\"./ring-layer.fs\"),\n      instanceAttributes: [\n        {\n          easing: animateCenter,\n          name: RingLayer.attributeNames.center,\n          size: InstanceAttributeSize.TWO,\n          update: o => o.center\n        },\n        {\n          easing: animateRadius,\n          name: RingLayer.attributeNames.radius,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.radius]\n        },\n        {\n          name: RingLayer.attributeNames.depth,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.depth]\n        },\n        {\n          easing: animateColor,\n          name: RingLayer.attributeNames.color,\n          size: InstanceAttributeSize.FOUR,\n          update: o => o.color\n        },\n        {\n          name: RingLayer.attributeNames.thickness,\n          size: InstanceAttributeSize.ONE,\n          update: o => [o.thickness]\n        }\n      ],\n      uniforms: [\n        {\n          name: \"scaleFactor\",\n          size: UniformSize.ONE,\n          update: (_: IUniform) => [scaleFactor()]\n        }\n      ],\n      vertexAttributes: [\n        {\n          name: \"normals\",\n          size: VertexAttributeSize.TWO,\n          update: (vertex: number) => [\n            // Normal\n            vertexToNormal[vertex],\n            // The side of the quad\n            vertexToSide[vertex]\n          ]\n        }\n      ],\n      vertexCount: 6,\n      vs: require(\"./ring-layer.vs\")\n    };\n  }\n\n  getMaterialOptions(): ILayerMaterialOptions {\n    return CommonMaterialOptions.transparentShapeBlending;\n  }\n}\n","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvarying float edgeSharpness;\\nvarying float borderSize;\\nvarying vec2 pointCoord;\\nvarying float scale;\\nfloat circle(vec2 coord, float radius){\\nvec2 dist = coord - vec2(0.5);\\nreturn 1.0 - smoothstep(\\nradius - (radius * edgeSharpness),\\nradius,\\ndot(dist, dist) * 4.0\\n);\\n}\\nvoid main() {\\nfloat outer_step_factor = circle(pointCoord, 1.0);\\nfloat inner_step_factor = circle(pointCoord, 1.0 - borderSize * scale);\\nsetColor(mix(\\nmix(\\nvec4(0.0, 0.0, 0.0, 0.0),\\nvertexColor,\\nouter_step_factor\\n),\\nvec4(0.0, 0.0, 0.0, 0.0),\\ninner_step_factor\\n));\\n}\"","module.exports = \"precision highp float;\\nvarying vec4 vertexColor;\\nvarying float edgeSharpness;\\nvarying float borderSize;\\nvarying vec2 pointCoord;\\nvarying float scale;\\nvoid main() {\\nscale = scaleFactor;\\nvertexColor = color;\\nfloat size = radius * scaleFactor * pixelRatio;\\nfloat ringWidth = mix(2.0 , thickness, float(thickness > 2.0));\\nborderSize = mix(\\n(ringWidth) / size,\\n((ringWidth * pixelRatio) / size),\\nfloat(pixelRatio > 1.0)\\n);\\nedgeSharpness = min(0.2 / (ringWidth * scale), 0.1);\\npointCoord = (normals.xy + vec2(1.0, 1.0)) / 2.0;\\nvec4 clipCenter = clipSpace(vec3(center, depth));\\nvec2 screenCenter = (clipCenter.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;\\nvec2 vertex = (normals.xy * size) + screenCenter;\\ngl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), clipCenter.zw);\\n}\"","import \"./shader-modules\";\n\nexport * from \"./view\";\nexport * from \"./scene-graph\";\nexport * from \"./layers\";\n","import \"./world-2d-xy.shader\";\nimport \"./world-2d-xz.shader\";\nimport \"./world-2d-yz.shader\";\n","import { Control2D } from \"../../2d\";\nimport { Layer2D } from \"../../2d/view/layer-2d\";\nimport { ShaderModule } from \"../../shaders\";\nimport { Layer } from \"../../surface/layer\";\nimport { ShaderInjectionTarget, UniformSize } from \"../../types\";\n\n/**\n * This module changes the projections for Layer2D style layers to map [x, y] -> [x, z]\n */\nShaderModule.register([\n  {\n    moduleId: \"world2DXY\",\n    content: require(\"../../2d/shader-modules/shader-fragments/world-2d-projection.vs\"),\n    compatibility: ShaderInjectionTarget.ALL,\n    uniforms: (layer: Layer<any, any>) => {\n      if (!(layer instanceof Layer2D)) {\n        console.warn(\n          \"A shader requesed the module world2DXZ; however, the layer the shader comes from is NOT a Layer2D which is\",\n          \"required for the module to work.\"\n        );\n        return [];\n      }\n\n      if (!layer.props.control2D) {\n        console.warn(\n          \"For a layer 2D to be compatible with a 3D View, the layer requires an additional prop of control2D\"\n        );\n        return [];\n      }\n\n      return [\n        // This injects the projection matrix from the view camera\n        {\n          name: \"projection\",\n          size: UniformSize.MATRIX4,\n          update: () => layer.view.props.camera.projection\n        },\n        // This injects the model view matrix from the view camera\n        {\n          name: \"view\",\n          size: UniformSize.MATRIX4,\n          update: () => layer.view.props.camera.view\n        },\n        // This injects a 2D camera's offset\n        {\n          name: \"cameraOffset\",\n          size: UniformSize.THREE,\n          update: () =>\n            layer.props.control2D instanceof Control2D\n              ? layer.props.control2D.offset\n              : [0, 0, 0]\n        },\n        // This injects the camera's current position\n        {\n          name: \"cameraPosition\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.position\n        },\n        // This injects the camera's current scale\n        {\n          name: \"cameraScale\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.scale\n        },\n        // This injects the camera's 2D current scale\n        {\n          name: \"cameraScale2D\",\n          size: UniformSize.THREE,\n          update: () =>\n            layer.props.control2D instanceof Control2D\n              ? layer.props.control2D.scale\n              : [1, 1, 1]\n        },\n        // This injects the camera's Euler rotation\n        {\n          name: \"cameraRotation\",\n          size: UniformSize.FOUR,\n          update: () => layer.view.props.camera.transform.rotation\n        },\n        // This injects the pixel width and height of the view\n        {\n          name: \"viewSize\",\n          size: UniformSize.TWO,\n          update: () => [\n            layer.view.viewBounds.width,\n            layer.view.viewBounds.height\n          ]\n        },\n        // This injects the current layer's pixel ratio so pixel ratio dependent items can react to it\n        // Things like gl_PointSize will need this metric if not working in clip space\n        {\n          name: \"pixelRatio\",\n          size: UniformSize.ONE,\n          update: () => [layer.view.pixelRatio]\n        }\n      ];\n    }\n  }\n]);\n","import \"./camera-metrics.shader\";\nimport \"./dim-color.shader\";\nimport \"./frame-metrics.shader\";\nimport \"./hsv.shader\";\nimport \"./instancing.shader\";\nimport \"./math.shader\";\nimport \"./matrix.shader\";\nimport \"./picking.shader\";\nimport \"./util.shader\";\n","import { Layer } from \"../../surface/layer\";\nimport { ShaderInjectionTarget, UniformSize } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\n/**\n * This module provides uniforms for retrieving camera propeerties within the shader.\n */\nShaderModule.register([\n  {\n    moduleId: \"camera\",\n    // No explicit functional content is required, we will only use the uniforms for injecting information for this\n    // module.\n    content: \"\",\n    compatibility: ShaderInjectionTarget.ALL,\n    uniforms: (layer: Layer<any, any>) => [\n      // This injects the projection matrix from the view camera\n      {\n        name: \"projection\",\n        size: UniformSize.MATRIX4,\n        update: () => layer.view.props.camera.projection\n      },\n      {\n        name: \"viewProjection\",\n        size: UniformSize.MATRIX4,\n        update: () => layer.view.props.camera.viewProjection\n      },\n      // This injects the model view matrix from the view camera\n      {\n        name: \"view\",\n        size: UniformSize.MATRIX4,\n        update: () => layer.view.props.camera.view\n      },\n      // This injects the camera's current position\n      {\n        name: \"cameraPosition\",\n        size: UniformSize.THREE,\n        update: () => layer.view.props.camera.position\n      },\n      // This injects the camera's current scale\n      {\n        name: \"cameraScale\",\n        size: UniformSize.THREE,\n        update: () => layer.view.props.camera.scale\n      },\n      // This injects the camera's Euler rotation\n      {\n        name: \"cameraRotation\",\n        size: UniformSize.THREE,\n        update: () => layer.view.props.camera.scale\n      },\n      // This injects the pixel width and height of the view\n      {\n        name: \"viewSize\",\n        size: UniformSize.TWO,\n        update: () => [\n          layer.view.viewBounds.width,\n          layer.view.viewBounds.height\n        ]\n      },\n      // This injects the current layer's pixel ratio so pixel ratio dependent items can react to it\n      // Things like gl_PointSize will need this metric if not working in clip space\n      {\n        name: \"pixelRatio\",\n        size: UniformSize.ONE,\n        update: () => [layer.view.pixelRatio]\n      }\n    ]\n  },\n  {\n    moduleId: \"projection\",\n    content: require(\"./shader-fragments/projection.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  }\n]);\n","module.exports = \"${import: camera}\\nvec3 cameraSpace(vec3 world) {\\nreturn (view * vec4(world, 1.0)).xyz;\\n}\\nvec3 cameraSpaceSize(vec3 worldSize) {\\nreturn (view * vec4(worldSize, 0.0)).xyz;\\n}\\nvec4 clipSpace(vec3 world) {\\nreturn (projection * view) * vec4(world, 1.0);\\n}\\nvec4 clipSpaceSize(vec3 worldSize) {\\nreturn (projection * view) * vec4(worldSize, 0.0);\\n}\"","import { ShaderInjectionTarget } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\n/**\n * This module provides uniforms for retrieving camera propeerties within the shader.\n */\nShaderModule.register({\n  moduleId: \"dimColor\",\n  content: require(\"./shader-fragments/hsv.vs\"),\n  compatibility: ShaderInjectionTarget.ALL\n});\n","import { Layer } from \"../../surface/layer\";\nimport { ShaderInjectionTarget, UniformSize } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\n/**\n * This module provides uniforms for retrieving camera propeerties within the shader.\n */\nShaderModule.register({\n  moduleId: \"frame\",\n  content: \"\",\n  compatibility: ShaderInjectionTarget.ALL,\n  uniforms: (layer: Layer<any, any>) => [\n    // This will be the current frame's current time which is updated in the layer's surface draw call\n    {\n      name: \"currentTime\",\n      size: UniformSize.ONE,\n      update: () => [layer.surface.frameMetrics.currentTime]\n    },\n    {\n      name: \"currentFrame\",\n      size: UniformSize.ONE,\n      update: () => [layer.surface.frameMetrics.currentFrame]\n    }\n  ]\n});\n","import { ShaderInjectionTarget } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\n/**\n * This module provides uniforms for retrieving camera propeerties within the shader.\n */\nShaderModule.register({\n  moduleId: \"hsv\",\n  content: require(\"./shader-fragments/hsv.vs\"),\n  compatibility: ShaderInjectionTarget.ALL\n});\n","import { Instance } from \"../../instance-provider/instance\";\nimport {\n  IInstanceAttribute,\n  InstanceAttributeSize,\n  LayerBufferType,\n  ShaderInjectionTarget,\n  VertexAttributeSize\n} from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\n/**\n * This module contains the basic needs required to facilitate instancing for our shaders\n */\nShaderModule.register({\n  moduleId: \"instancing\",\n  content: \"\",\n  compatibility: ShaderInjectionTarget.ALL,\n\n  instanceAttributes: layer => {\n    // This is injected so the system can control when an instance should not be rendered.\n    // This allows for holes to be in the buffer without having to correct them immediately\n    const activeAttribute: IInstanceAttribute<Instance> = {\n      name: \"_active\",\n      size: InstanceAttributeSize.ONE,\n      update: o => [o.active ? 1 : 0]\n    };\n\n    // Set the active attribute to the layer for quick reference\n    layer.shaderIOInfo.activeAttribute = activeAttribute;\n\n    return [activeAttribute];\n  },\n\n  vertexAttributes: layer => {\n    // Only the uniform buffering strategy requires instance information in it's vertex attributes\n    if (layer.bufferType === LayerBufferType.UNIFORM) {\n      return [\n        // We add an inherent instance attribute to our vertices so they can determine the instancing\n        // Data to retrieve.\n        {\n          name: \"instance\",\n          size: VertexAttributeSize.ONE,\n          // We no op this as our geometry generating routine will establish the values needed here\n          update: () => [0]\n        }\n      ];\n    }\n\n    return [];\n  }\n});\n","import { ShaderInjectionTarget } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\n// All of the constants fragments\nconst constants = [\n  {\n    moduleId: \"PI_INV\",\n    content: require(\"./shader-fragments/constants/pi_inv.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"PI2_INV\",\n    content: require(\"./shader-fragments/constants/pi2_inv.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"PI_2\",\n    content: require(\"./shader-fragments/constants/pi_2.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"PI_4\",\n    content: require(\"./shader-fragments/constants/pi_4.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"PI\",\n    content: require(\"./shader-fragments/constants/pi.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"PI2\",\n    content: require(\"./shader-fragments/constants/pi2.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"toDegrees\",\n    content: require(\"./shader-fragments/constants/to-degrees.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"toRadians\",\n    content: require(\"./shader-fragments/constants/to-radians.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  }\n];\n\n// A bin import that let's you add all common constants to your shader\nconst allConstants = {\n  moduleId: \"constants\",\n  content: `$\\{import: ${constants.map(c => c.moduleId).join(\", \")}}`,\n  compatibility: ShaderInjectionTarget.ALL\n};\n\n// All of the mathematical methods\nconst methods = [\n  {\n    moduleId: \"bezier1\",\n    content: require(\"./shader-fragments/bezier1.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"bezier2\",\n    content: require(\"./shader-fragments/bezier2.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"arc\",\n    content: require(\"./shader-fragments/arc.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"fmod\",\n    content: require(\"./shader-fragments/fmod.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"wrap\",\n    content: require(\"./shader-fragments/wrap.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"fcos\",\n    content: require(\"./shader-fragments/fcos.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  },\n  {\n    moduleId: \"fsin\",\n    content: require(\"./shader-fragments/fsin.vs\"),\n    compatibility: ShaderInjectionTarget.ALL\n  }\n];\n\n// Register all modules\nShaderModule.register([...methods, ...constants, allConstants]);\n","module.exports = \"float PI_INV = 0.3183098862;\"","module.exports = \"float PI2_INV = 0.1591549431;\"","module.exports = \"float PI_2 = 1.5707963268;\"","module.exports = \"float PI_4 = 0.7853981634;\"","module.exports = \"float PI = 3.14159265;\"","module.exports = \"float PI2 = 6.2831853;\"","module.exports = \"float toDegrees = 57.2957795131;\"","module.exports = \"float toRadians = 0.01745329252;\"","module.exports = \"vec2 bezier1(float t, vec2 p1, vec2 p2, vec2 c1) {\\nreturn (1.0 - t) * (1.0 - t) * p1 + 2.0 * t * (1.0 - t) * c1 + t * t * p2;\\n}\"","module.exports = \"vec2 bezier2(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {\\nfloat t1 = 1.0 - t;\\nreturn pow(t1, 3.0) * p1 + 3.0 * t * pow(t1, 2.0) * c1 + 3.0 * pow(t, 2.0) * t1 * c2 + pow(t, 3.0) * p2;\\n}\"","module.exports = \"${import: PI, PI2, fsin, fcos, wrap}\\nvec2 arc(float t, vec2 center, float radius, float start, float end) {\\nfloat angle = wrap((end - start) * t + start, 0.0, PI2);\\nreturn center + vec2(fcos(angle), fsin(angle)) * radius;\\n}\"","module.exports = \"float fmod(float x, float m, float m_inv) {\\nreturn x - m * floor(x * m_inv);\\n}\"","module.exports = \"float wrap(float value, float start, float end) {\\nfloat width = end - start;\\nfloat offsetValue = value - start;\\nreturn (offsetValue - (floor(offsetValue / width) * width)) + start;\\n}\"","module.exports = \"${import: PI, PI2, PI_2}\\nfloat fcos(float x) {\\nfloat sine;\\nx += PI_2;\\nx += mix(\\nmix(\\n0.0,\\n-PI2, float(x > PI)\\n),\\nPI2, float(x < -PI)\\n);\\nsine = 1.27323954 * x;\\nsine += mix(-1.0, 1.0, float(x < 0.0)) * 0.405284735 * x * x;\\nsine = 0.225 * (sine * (mix(1.0, -1.0, float(sine < 0.0)) * sine) - sine) + sine;\\nreturn sine;\\n}\"","module.exports = \"${import: PI, PI2}\\nfloat fsin(float x) {\\nfloat sine;\\nx += mix(\\nmix(\\n0.0,\\n-PI2, float(x > PI)\\n),\\nPI2, float(x < -PI)\\n);\\nsine = 1.27323954 * x;\\nsine += mix(-1.0, 1.0, float(x < 0.0)) * 0.405284735 * x * x;\\nsine = 0.225 * (sine * (mix(1.0, -1.0, float(sine < 0.0)) * sine) - sine) + sine;\\nreturn sine;\\n}\"","import { ShaderInjectionTarget } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\nShaderModule.register([\n  {\n    moduleId: \"translation\",\n    compatibility: ShaderInjectionTarget.ALL,\n    content: require(\"./shader-fragments/matrix/translation.vs\")\n  },\n  {\n    moduleId: \"rotation\",\n    compatibility: ShaderInjectionTarget.ALL,\n    content: require(\"./shader-fragments/matrix/rotation.vs\")\n  },\n  {\n    moduleId: \"scale\",\n    compatibility: ShaderInjectionTarget.ALL,\n    content: require(\"./shader-fragments/matrix/scale.vs\")\n  },\n  {\n    moduleId: \"transform\",\n    compatibility: ShaderInjectionTarget.ALL,\n    content: require(\"./shader-fragments/matrix/transform.vs\")\n  }\n]);\n","module.exports = \"mat4 translation(vec3 t) {\\nreturn mat4(\\n1, 0, 0, 0,\\n0, 1, 0, 0,\\n0, 0, 1, 0,\\nt.x, t.y, t.z, 1\\n);\\n}\"","module.exports = \"mat4 rotationFromQuaternion(vec4 q) {\\nfloat x2 = q.y + q.y;\\nfloat y2 = q.z + q.z;\\nfloat z2 = q.w + q.w;\\nfloat xx = q.y * x2;\\nfloat xy = q.y * y2;\\nfloat xz = q.y * z2;\\nfloat yy = q.z * y2;\\nfloat yz = q.z * z2;\\nfloat zz = q.w * z2;\\nfloat wx = q.x * x2;\\nfloat wy = q.x * y2;\\nfloat wz = q.x * z2;\\nreturn mat4(\\n1.0 - (yy + zz), xy - wz, xz + wy, 0.0,\\nxy + wz, 1.0 - (xx + zz), yz - wx, 0.0,\\nxz - wy, yz + wx, 1.0 - (xx + yy), 0.0,\\n0, 0, 0, 1\\n);\\n}\"","module.exports = \"mat4 scale(vec3 s) {\\nreturn mat4(\\ns.x, 0, 0, 0,\\n0, s.y, 0, 0,\\n0, 0, s.z, 0,\\n0, 0, 0, 1\\n);\\n}\"","module.exports = \"${import: translation, rotation, scale}\\nmat4 transform(vec3 s, vec4 r, vec3 t) {\\nreturn translation(t) * rotationFromQuaternion(r) * scale(s);\\n}\"","import { Layer } from \"../../surface/layer\";\nimport {\n  InstanceAttributeSize,\n  PickType,\n  ShaderInjectionTarget,\n  UniformSize\n} from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\nShaderModule.register([\n  {\n    moduleId: \"picking\",\n    content: require(\"./shader-fragments/picking.vs\"),\n    compatibility: ShaderInjectionTarget.VERTEX,\n\n    instanceAttributes: (_layer: Layer<any, any>) => [\n      {\n        name: \"_pickingColor\",\n        size: InstanceAttributeSize.FOUR,\n        update: o => {\n          // We start from white and move down so the colors are more visible\n          // For debugging\n          const color = 0xffffff - o.uid;\n\n          // Do bit maths do get float components out of the int color\n          return [\n            ((color & 0xff0000) >> 16) / 255.0,\n            ((color & 0x00ff00) >> 8) / 255.0,\n            (color & 0x0000ff) / 255.0,\n            1\n          ];\n        }\n      }\n    ],\n\n    uniforms: layer => [\n      {\n        name: \"pickingActive\",\n        shaderInjection: ShaderInjectionTarget.ALL,\n        size: UniformSize.ONE,\n        update: () => [\n          layer.picking.currentPickMode === PickType.SINGLE ? 1.0 : 0.0\n        ]\n      }\n    ]\n  },\n  {\n    moduleId: \"picking\",\n    content: require(\"./shader-fragments/picking.fs\"),\n    compatibility: ShaderInjectionTarget.FRAGMENT\n  },\n  {\n    moduleId: \"no-picking\",\n    content: require(\"./shader-fragments/no-picking.vs\"),\n    compatibility: ShaderInjectionTarget.VERTEX\n  },\n  {\n    moduleId: \"no-picking\",\n    content: require(\"./shader-fragments/no-picking.fs\"),\n    compatibility: ShaderInjectionTarget.FRAGMENT\n  }\n]);\n","module.exports = \"varying highp vec4 _picking_color_pass_;\"","module.exports = \"varying highp vec4 _picking_color_pass_;\\nhighp vec4 setColor(vec4 color) {\\ngl_FragColor = mix(color, _picking_color_pass_, pickingActive);\\nif (color.a == 0.0) {\\ndiscard;\\n}\\nreturn gl_FragColor;\\n}\"","module.exports = \"\"","module.exports = \"lowp vec4 setColor(vec4 color) {\\ngl_FragColor = color;\\nreturn gl_FragColor;\\n}\"","import { ShaderInjectionTarget } from \"../../types\";\nimport { ShaderModule } from \"../processing\";\n\nShaderModule.register([\n  {\n    moduleId: \"no-op\",\n    content: require(\"./shader-fragments/no-op.vs\"),\n    compatibility: ShaderInjectionTarget.VERTEX\n  },\n  {\n    moduleId: \"no-op\",\n    content: require(\"./shader-fragments/no-op.fs\"),\n    compatibility: ShaderInjectionTarget.FRAGMENT\n  }\n]);\n","module.exports = \"void main() {\\ngl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n}\"","module.exports = \"void main() {\\ngl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\\n}\"","import { Control2D } from \"../../2d\";\nimport { Layer2D } from \"../../2d/view/layer-2d\";\nimport { ShaderModule } from \"../../shaders\";\nimport { Layer } from \"../../surface/layer\";\nimport { ShaderInjectionTarget, UniformSize } from \"../../types\";\n\n/**\n * This module changes the projections for Layer2D style layers to map [x, y] -> [x, z]\n */\nShaderModule.register([\n  {\n    moduleId: \"world2DXZ\",\n    content: require(\"./shader-fragments/world-2d-xz-projection.vs\"),\n    compatibility: ShaderInjectionTarget.ALL,\n    uniforms: (layer: Layer<any, any>) => {\n      if (!(layer instanceof Layer2D)) {\n        console.warn(\n          \"A shader requesed the module world2DXZ; however, the layer the shader comes from is NOT a Layer2D which is\",\n          \"required for the module to work.\"\n        );\n        return [];\n      }\n\n      if (!layer.props.control2D) {\n        console.warn(\n          \"For a layer 2D to be compatible with a 3D View, the layer requires an additional prop of control2D\"\n        );\n        return [];\n      }\n\n      return [\n        // This injects the projection matrix from the view camera\n        {\n          name: \"projection\",\n          size: UniformSize.MATRIX4,\n          update: () => layer.view.props.camera.projection\n        },\n        // This injects the model view matrix from the view camera\n        {\n          name: \"view\",\n          size: UniformSize.MATRIX4,\n          update: () => layer.view.props.camera.view\n        },\n        // This injects a 2D camera's offset\n        {\n          name: \"cameraOffset\",\n          size: UniformSize.THREE,\n          update: () =>\n            layer.props.control2D instanceof Control2D\n              ? layer.props.control2D.offset\n              : [0, 0, 0]\n        },\n        // This injects the camera's current position\n        {\n          name: \"cameraPosition\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.position\n        },\n        // This injects the camera's current scale\n        {\n          name: \"cameraScale\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.scale\n        },\n        // This injects the camera's 2D current scale\n        {\n          name: \"cameraScale2D\",\n          size: UniformSize.THREE,\n          update: () =>\n            layer.props.control2D instanceof Control2D\n              ? layer.props.control2D.scale\n              : [1, 1, 1]\n        },\n        // This injects the camera's Euler rotation\n        {\n          name: \"cameraRotation\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.scale\n        },\n        // This injects the pixel width and height of the view\n        {\n          name: \"viewSize\",\n          size: UniformSize.TWO,\n          update: () => [\n            layer.view.viewBounds.width,\n            layer.view.viewBounds.height\n          ]\n        },\n        // This injects the current layer's pixel ratio so pixel ratio dependent items can react to it\n        // Things like gl_PointSize will need this metric if not working in clip space\n        {\n          name: \"pixelRatio\",\n          size: UniformSize.ONE,\n          update: () => [layer.view.pixelRatio]\n        }\n      ];\n    }\n  }\n]);\n","module.exports = \"vec3 cameraSpace(vec3 world) {\\nreturn (world + cameraOffset) * cameraScale2D;\\n}\\nvec3 cameraSpaceSize(vec3 worldSize) {\\nreturn worldSize * cameraScale2D;\\n}\\nvec4 clipSpace(vec3 world) {\\nreturn ((projection * view) * vec4(cameraSpace(world.xzy), 1.0));\\n}\\nvec4 clipSpaceSize(vec3 worldSize) {\\nreturn ((projection * view) * vec4(cameraSpaceSize(worldSize.xzy), 0.0));\\n}\"","import { Control2D } from \"../../2d/view/control-2d\";\nimport { Layer2D } from \"../../2d/view/layer-2d\";\nimport { ShaderModule } from \"../../shaders\";\nimport { Layer } from \"../../surface/layer\";\nimport { ShaderInjectionTarget, UniformSize } from \"../../types\";\n\n/**\n * This module changes the projections for Layer2D style layers to map [x, y] -> [z, y]\n */\nShaderModule.register([\n  {\n    moduleId: \"world2DYZ\",\n    content: require(\"./shader-fragments/world-2d-yz-projection.vs\"),\n    compatibility: ShaderInjectionTarget.ALL,\n    uniforms: (layer: Layer<any, any>) => {\n      if (!(layer instanceof Layer2D)) {\n        console.warn(\n          \"A shader requesed the module world2DYZ; however, the layer the shader comes from is NOT a Layer2D which is\",\n          \"required for the module to work.\"\n        );\n        return [];\n      }\n\n      if (!layer.props.control2D) {\n        console.warn(\n          \"For a layer 2D to be compatible with a 3D View, the layer requires an additional prop of control2D\"\n        );\n        return [];\n      }\n\n      return [\n        // This injects the projection matrix from the view camera\n        {\n          name: \"projection\",\n          size: UniformSize.MATRIX4,\n          update: () => layer.view.props.camera.projection\n        },\n        // This injects the model view matrix from the view camera\n        {\n          name: \"view\",\n          size: UniformSize.MATRIX4,\n          update: () => layer.view.props.camera.view\n        },\n        // This injects a 2D camera's offset\n        {\n          name: \"cameraOffset\",\n          size: UniformSize.THREE,\n          update: () =>\n            layer.props.control2D instanceof Control2D\n              ? layer.props.control2D.offset\n              : [0, 0, 0]\n        },\n        // This injects the camera's current position\n        {\n          name: \"cameraPosition\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.position\n        },\n        // This injects the camera's current scale\n        {\n          name: \"cameraScale\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.scale\n        },\n        // This injects the camera's 2D current scale\n        {\n          name: \"cameraScale2D\",\n          size: UniformSize.THREE,\n          update: () =>\n            layer.props.control2D instanceof Control2D\n              ? layer.props.control2D.scale\n              : [1, 1, 1]\n        },\n        // This injects the camera's Euler rotation\n        {\n          name: \"cameraRotation\",\n          size: UniformSize.THREE,\n          update: () => layer.view.props.camera.scale\n        },\n        // This injects the pixel width and height of the view\n        {\n          name: \"viewSize\",\n          size: UniformSize.TWO,\n          update: () => [\n            layer.view.viewBounds.width,\n            layer.view.viewBounds.height\n          ]\n        },\n        // This injects the current layer's pixel ratio so pixel ratio dependent items can react to it\n        // Things like gl_PointSize will need this metric if not working in clip space\n        {\n          name: \"pixelRatio\",\n          size: UniformSize.ONE,\n          update: () => [layer.view.pixelRatio]\n        }\n      ];\n    }\n  }\n]);\n","module.exports = \"vec3 cameraSpace(vec3 world) {\\nreturn (world + cameraOffset) * cameraScale2D;\\n}\\nvec3 cameraSpaceSize(vec3 worldSize) {\\nreturn worldSize * cameraScale2D;\\n}\\nvec4 clipSpace(vec3 world) {\\nreturn ((projection * view) * vec4(cameraSpace(world.zyx), 1.0));\\n}\\nvec4 clipSpaceSize(vec3 worldSize) {\\nreturn ((projection * view) * vec4(cameraSpaceSize(worldSize.zyx), 0.0));\\n}\"","export * from \"./view-3d\";\nexport * from \"./layer-2d-in-3d\";\nexport * from \"./projection-3d\";\nexport * from \"./view-3d\";\n","import { Control2D, Layer2D } from \"../../2d\";\nimport { Instance } from \"../../instance-provider/instance\";\nimport { ILayerConstructable, ILayerProps } from \"../../surface/layer\";\nimport { IShaderInitialization, Omit } from \"../../types\";\nimport { createLayer } from \"../../util/create-util\";\n\n/**\n * Specifies a 2D axis system within a 3D world.\n */\nexport enum Axis2D {\n  /** X-axis remains x-axis and y-axis remains y-axis */\n  XY,\n  /** X-axis remains x-axis and y-axis is now mapped to the z axis */\n  XZ,\n  /** X-axis is mapped to the z-axis and the y-axis remains y-axis */\n  YZ\n}\n\n/**\n * This method provides a means for a layer2d to be injected into a 3d world along a different axis system. This way\n * the 2d elements can render their positional information in the correct manner within the 3D world and remain\n * versatile enough to be used in many cases without having to render into a rendering context and then into the\n * 3D world.\n *\n * Mapped 2D layers will sometimes behave as expected and sometimes will not. For instance: rendering labels within\n * the 3D space will merely render their anchor position correctly within 3D but will not render the glyphs flat along\n * the axis. The glyphs will actually remain upright and rendered within the screen space.\n *\n * To render elements truly flat within the 3D world, use a render target first, then render the target within the 3D\n * world.\n */\nexport function createLayer2Din3D<T extends Instance, U extends ILayerProps<T>>(\n  axis2D: Axis2D,\n  classType: ILayerConstructable<T> & { defaultProps: U },\n  props: Omit<U, \"key\"> & Partial<Pick<U, \"key\">> & { control2D: Control2D }\n) {\n  const doesInheritLayer2D =\n    classType === Layer2D || classType.prototype instanceof Layer2D;\n\n  if (!doesInheritLayer2D) {\n    console.warn(\n      \"A Layer type was specified for createLayer2din3D that is NOT a Layer2D type, which is invalid.\",\n      \"The layer will be used without being modified.\"\n    );\n    return createLayer(classType, props);\n  }\n\n  let newModule: string;\n\n  switch (axis2D) {\n    case Axis2D.XY:\n      newModule = \"world2DXY\";\n      break;\n    case Axis2D.XZ:\n      newModule = \"world2DXZ\";\n      break;\n    case Axis2D.YZ:\n      newModule = \"world2DYZ\";\n      break;\n\n    default:\n      return createLayer(classType, props);\n  }\n\n  const modifiedProps = Object.assign({}, props, {\n    baseShaderModules: (\n      _shaderIO: IShaderInitialization<Instance>,\n      layerModules: { fs: string[]; vs: string[] }\n    ) => {\n      // We remove the world 2D module to replace it with our custom module that will handle the projections correctly.\n      let world2DIndex = layerModules.vs.indexOf(\"world2D\");\n\n      if (world2DIndex >= 0) {\n        layerModules.vs.splice(world2DIndex, 1, newModule);\n      }\n\n      world2DIndex = layerModules.fs.indexOf(\"world2D\");\n\n      if (world2DIndex >= 0) {\n        layerModules.fs.splice(world2DIndex, 1, newModule);\n      }\n\n      return layerModules;\n    }\n  });\n\n  return createLayer(classType, modifiedProps);\n}\n","import { identity4, Mat4x4 } from \"../../math\";\nimport { Node } from \"./node\";\nimport { Transform } from \"./transform\";\n\n/**\n * Expresses an item in the 3D world within a SceneGraph. Allows the concept of parent child relationships and provides\n * calculated world transforms as the culmination of the relationships.\n */\nexport class Node3D extends Node<Node3D> {\n  /** The transform in local space of this node. If there is no parent, this transform === the world transform */\n  get local() {\n    return this._local.matrix;\n  }\n  private _local: Transform = new Transform();\n\n  /** The parent node of this node */\n  get parent() {\n    return this._parent;\n  }\n  private _parent: Node3D | null = null;\n\n  /**\n   * The world transform matrix computed for this node. This is the transform used to position objects within\n   * the world. This returns the local transform if no world transform is computed for this node (ie- this node has\n   * no parent).\n   */\n  get world() {\n    if (!this._world) {\n      return this._local.matrix;\n    }\n\n    return this._world;\n  }\n  private _world: Mat4x4 | null = identity4();\n\n  willMount(): void {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  didMount(): void {\n    throw new Error(\"Method not implemented.\");\n  }\n}\n","import { uid } from \"../../util\";\n\n/**\n * This is the most basic node that will be within a Scene Graph. This is simply a container that makes an element\n * compatible with the SceneGraph. Specific types of nodes can extend this node to be injected in the Graph to take\n * advantage of the Graph's basic capabilities.\n */\nexport abstract class Node<TSibling extends Node<any>> {\n  /** Unique numerical identifier to make identification of this object easier */\n  get uid() {\n    return this._uid;\n  }\n  private _uid = uid();\n  /** These are the siblings related to this specified node */\n  get siblings(): ReadonlyMap<number, TSibling> {\n    return this._siblings;\n  }\n  private _siblings = new Map<number, TSibling>();\n\n  /**\n   * This adds a child node to this node's list of children\n   */\n  addSibling(sibling: TSibling, stopRecurse?: boolean) {\n    this._siblings.set(sibling.uid, sibling);\n\n    if (!stopRecurse && !sibling.siblings.has(this.uid)) {\n      sibling.addSibling(this, true);\n    }\n  }\n\n  /**\n   * Adds a list of siblings to this node\n   */\n  addSiblings(siblings: TSibling[]) {\n    for (let i = 0, iMax = siblings.length; i < iMax; ++i) {\n      const sibling = siblings[i];\n      this._siblings.set(sibling.uid, sibling);\n\n      if (!sibling.siblings.has(this.uid)) {\n        sibling.addSibling(this, true);\n      }\n    }\n  }\n\n  /**\n   * Removes this node from all siblings.\n   */\n  remove() {\n    this._siblings.forEach(sibling => {\n      sibling.removeSibling(this);\n    });\n\n    this._siblings.clear();\n  }\n\n  /**\n   * Removes a sibling from this node if it exists as a sibling.\n   */\n  removeSibling(sibling: TSibling, stopRecurse?: boolean) {\n    if (this._siblings.delete(sibling.uid) && !stopRecurse) {\n      sibling.removeSibling(this, true);\n    }\n  }\n\n  /**\n   * Generic trigger method\n   */\n  trigger() {\n    // NOOP\n  }\n\n  /**\n   * Lifecycle: Executes when the node is about to be mounted into\n   */\n  abstract willMount(): void;\n\n  abstract didMount(): void;\n}\n","export * from \"./base\";\nexport * from \"./cube\";\n","export * from \"./instance-3d\";\n","export * from \"./cube-layer\";\nexport * from \"./cube-instance\";\n","import { GLSettings } from \"../../../gl\";\nimport { InstanceProvider } from \"../../../instance-provider\";\nimport { Vec2, Vec3 } from \"../../../math/vector\";\nimport { ILayerProps, Layer } from \"../../../surface/layer\";\nimport {\n  InstanceAttributeSize,\n  IShaderInitialization,\n  VertexAttributeSize\n} from \"../../../types\";\nimport { CommonMaterialOptions, createAttribute } from \"../../../util\";\nimport { IdentityTransform } from \"../../scene-graph\";\nimport { CubeInstance } from \"./cube-instance\";\n\nexport interface ICubeLayerProps<TInstance extends CubeInstance>\n  extends ILayerProps<TInstance> {}\n\n/**\n * Layer for rendering simple cube primitives\n */\nexport class CubeLayer<\n  TInstance extends CubeInstance,\n  TProps extends ICubeLayerProps<TInstance>\n> extends Layer<TInstance, TProps> {\n  static defaultProps: ICubeLayerProps<CubeInstance> = {\n    data: new InstanceProvider<CubeInstance>(),\n    key: \"\",\n    materialOptions: CommonMaterialOptions.transparentShapeBlending\n  };\n\n  initShader(): IShaderInitialization<TInstance> | null {\n    const FRT: Vec3 = [1, 1, 1];\n    const BRT: Vec3 = [1, 1, -1];\n    const BRB: Vec3 = [1, -1, -1];\n    const FRB: Vec3 = [1, -1, 1];\n\n    const FLT: Vec3 = [-1, 1, 1];\n    const BLT: Vec3 = [-1, 1, -1];\n    const BLB: Vec3 = [-1, -1, -1];\n    const FLB: Vec3 = [-1, -1, 1];\n\n    const positions: Vec3[] = [\n      // right\n      FRT,\n      BRT,\n      BRB,\n      FRT,\n      BRB,\n      FRB,\n      // front\n      FLT,\n      FRT,\n      FRB,\n      FLT,\n      FRB,\n      FLB,\n      // left\n      FLT,\n      BLB,\n      BLT,\n      FLT,\n      FLB,\n      BLB,\n      // back\n      BLT,\n      BRB,\n      BRT,\n      BLT,\n      BLB,\n      BRB,\n      // up\n      FLT,\n      BRT,\n      FRT,\n      FLT,\n      BLT,\n      BRT,\n      // down\n      FLB,\n      FRB,\n      BRB,\n      FLB,\n      BRB,\n      BLB\n    ];\n\n    const right: Vec3 = [1, 0, 0];\n    const forward: Vec3 = [0, 0, 1];\n    const left: Vec3 = [-1, 0, 0];\n    const backward: Vec3 = [0, 0, -1];\n    const up: Vec3 = [0, 1, 0];\n    const down: Vec3 = [0, -1, 0];\n\n    const normals = [\n      right,\n      right,\n      right,\n      right,\n      right,\n      right,\n      forward,\n      forward,\n      forward,\n      forward,\n      forward,\n      forward,\n      left,\n      left,\n      left,\n      left,\n      left,\n      left,\n      backward,\n      backward,\n      backward,\n      backward,\n      backward,\n      backward,\n      up,\n      up,\n      up,\n      up,\n      up,\n      up,\n      down,\n      down,\n      down,\n      down,\n      down,\n      down\n    ];\n\n    const tex: Vec2[] = [\n      [0, 0],\n      [1, 0],\n      [1, 1],\n      [0, 0],\n      [1, 1],\n      [0, 1],\n\n      [0, 0],\n      [1, 0],\n      [1, 1],\n      [0, 0],\n      [1, 1],\n      [0, 1],\n\n      [0, 0],\n      [1, 1],\n      [1, 0],\n      [0, 0],\n      [0, 1],\n      [1, 1],\n\n      [0, 0],\n      [1, 1],\n      [1, 0],\n      [0, 0],\n      [0, 1],\n      [1, 1],\n\n      [0, 0],\n      [1, 1],\n      [1, 0],\n      [0, 0],\n      [0, 1],\n      [1, 1],\n\n      [0, 0],\n      [1, 0],\n      [1, 1],\n      [0, 0],\n      [1, 1],\n      [0, 1]\n    ];\n\n    return {\n      drawMode: GLSettings.Model.DrawMode.TRIANGLES,\n      fs: require(\"./cube-layer.fs\"),\n      instanceAttributes: [\n        createAttribute({\n          name: \"transform\",\n          size: InstanceAttributeSize.MAT4X4,\n          update: o => (o.transform || IdentityTransform).matrix\n        }),\n        createAttribute({\n          name: \"size\",\n          size: InstanceAttributeSize.THREE,\n          update: o => o.size\n        })\n      ],\n      uniforms: [],\n      vertexAttributes: [\n        {\n          name: \"position\",\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => positions[vertex]\n        },\n        {\n          name: \"normal\",\n          size: VertexAttributeSize.THREE,\n          update: (vertex: number) => normals[vertex]\n        },\n        {\n          name: \"texCoord\",\n          size: VertexAttributeSize.TWO,\n          update: (vertex: number) => tex[vertex]\n        }\n      ],\n      vertexCount: 36,\n      vs: require(\"./cube-layer.vs\")\n    };\n  }\n\n  getMaterialOptions() {\n    return Object.assign({}, CommonMaterialOptions.transparentShapeBlending, {\n      cullSide: GLSettings.Material.CullSide.CCW\n    });\n  }\n}\n","module.exports = \"varying vec2 _texCoord;\\nvoid main() {\\ngl_FragColor = mix(\\nvec4(1.0, 0.0, 0.0, 1.0),\\nvec4(0.0, 0.0, 0.0, 1.0),\\nfloat(_texCoord.x <= 0.01 || _texCoord.x > 0.99 || _texCoord.y < 0.01 || _texCoord.y > 0.99)\\n);\\n}\"","module.exports = \"${import: projection}\\nvarying vec2 _texCoord;\\nvoid main() {\\nvec4 pos = vec4(position * size, 1.0);\\nvec4 world = transform * pos;\\n_texCoord = texCoord;\\ngl_Position = clipSpace(world.xyz);\\n}\"","import { observable } from \"../../../instance-provider\";\nimport { Color, Size } from \"../../../types\";\nimport { IInstance3DOptions, Instance3D } from \"../base/instance-3d\";\n\n/** Customizes a new Cube instance */\nexport interface ICubeOptions extends IInstance3DOptions {\n  /** Sets the dimensions of the cube */\n  size?: Size;\n  /** Sets the color of the cube */\n  color?: Color;\n}\n\n/**\n * Represents a cube model within 3D space.\n */\nexport class CubeInstance extends Instance3D {\n  /** Dimensions of the cube */\n  @observable size: Size = [1, 1, 1];\n  /** Color of the cube */\n  @observable color: Color = [1, 1, 1, 1];\n\n  constructor(options: ICubeOptions) {\n    super(options);\n    this.size = options.size || this.size;\n    this.color = options.color || this.color;\n  }\n}\n","export * from \"./basic-surface\";\n","import { EventManager } from \"../event-management/event-manager\";\nimport { Instance, InstanceProvider } from \"../instance-provider\";\nimport { Bounds } from \"../math/primitives/bounds\";\nimport { BaseResourceOptions } from \"../resources\";\nimport {\n  ISceneOptions,\n  ISurfaceOptions,\n  IViewProps,\n  LayerInitializer,\n  Surface,\n  View,\n  ViewInitializer\n} from \"../surface\";\nimport { IPipeline, Lookup, Omit, Size, SurfaceErrorType } from \"../types\";\nimport { onAnimationLoop, PromiseResolver, stopAnimationLoop } from \"../util\";\nimport { Camera } from \"../util/camera\";\nimport { waitForValidDimensions } from \"../util/wait-for-valid-dimensions\";\n\n/**\n * This gets all of the values of a Lookup\n */\nfunction lookupValues<T>(check: Function, lookup: Lookup<T> | T[]): T[] {\n  const out: T[] = [];\n  const toProcess = Object.values(lookup);\n\n  for (let index = 0; index < toProcess.length; ++index) {\n    const next = toProcess[index];\n\n    if (next instanceof check) {\n      out.push(next as T);\n    } else {\n      toProcess.push(...Object.values(next));\n    }\n  }\n\n  return out;\n}\n\n/**\n * This gets all of the values of a Lookup\n */\nfunction mapLookupValues<T, U>(\n  label: string,\n  check: (value: T | Lookup<T>) => boolean,\n  lookup: Lookup<T>,\n  callback: (key: string, value: T) => U\n): U[] {\n  const added = new Set();\n  const out: U[] = [];\n  const toProcess = Object.keys(lookup).map<[string, T | Lookup<T>]>(key => [\n    key,\n    (lookup as any)[key]\n  ]);\n\n  for (let index = 0; index < toProcess.length; ++index) {\n    const next = toProcess[index];\n\n    if (check(next[1])) {\n      out.push(callback(next[0], next[1] as T));\n    } else {\n      let error = false;\n\n      Object.keys(next[1]).forEach(key => {\n        const value = (next[1] as any)[key];\n\n        if (!added.has(value)) {\n          toProcess.push([`${next[0]}.${key}`, value]);\n          added.add(value);\n        } else {\n          error = true;\n          console.warn(\"Invalid lookup for BasicSurface detected:\", label);\n        }\n      });\n\n      if (error) break;\n    }\n  }\n\n  return out;\n}\n\n/** Non-keyed View options with ordering property to specify rendering order */\nexport type BasicSurfaceView<TViewProps extends IViewProps> = Omit<\n  ViewInitializer<TViewProps>,\n  \"key\"\n> &\n  Partial<Pick<IViewProps, \"key\">>;\n/** Non-keyed layer initializer with ordering property to specify rendering order */\nexport type BasicSurfaceLayer = Omit<LayerInitializer, \"key\"> &\n  Partial<Pick<IViewProps, \"key\">>;\n\n/**\n * Defines a scene that elements are injected to. Each scene can be viewed with multiple views\n * and have several layers of injection into it.\n *\n * These are scene options without elements needing to specify keys. Instead, the keys will be\n * generated via Lookup definition keys.\n */\nexport type BasicSurfaceSceneOptions = Omit<\n  ISceneOptions,\n  \"key\" | \"views\" | \"layers\"\n> & {\n  /** Layers to inject elements into the scene */\n  layers: Lookup<BasicSurfaceLayer> | BasicSurfaceLayer[];\n  /** Views for rendering a perspective of the scene to a surface */\n  views: Lookup<BasicSurfaceView<IViewProps>> | BasicSurfaceView<IViewProps>[];\n};\n\nexport type BasicSurfaceResourceOptions = Omit<BaseResourceOptions, \"key\"> & {\n  key?: string;\n};\n\nexport interface IBasicSurfacePipeline {\n  /** Easy define the scenes to be used for the render pipeline */\n  scenes: Lookup<BasicSurfaceSceneOptions>;\n}\n\n/**\n * Customization for the basic surface\n */\nexport interface IBasicSurfaceOptions<\n  T extends Lookup<InstanceProvider<Instance>>,\n  U extends Lookup<Camera>,\n  V extends Lookup<EventManager> | EventManager[],\n  W extends Lookup<BaseResourceOptions>\n> {\n  /** The container this surface will fill with a canvas to render within */\n  container: HTMLElement;\n  /**\n   * A lookup of all cameras the surface will utilize. They are injected with identifiers to make it easy to\n   * reference them later. It's highly recommended to use an enum to identify the camera.\n   */\n  cameras: U;\n  /**\n   * Tell the surface to absorb wheel events to prevent the wheel from scolling the page.\n   * This defaults to true as it's more common to need wheel controls than not. Explicitly set to false to disable.\n   */\n  handlesWheelEvents?: boolean;\n  /**\n   * A list of providers you will utilize within your application. They are injected with identifiers to make it easy to\n   * reference them later. It's highly recommended to use an enum to identify the provider.\n   *\n   * NOTE: This is optional as it is usually VERY handy to have strong typed providers\n   */\n  providers: T;\n  /** Options used to specify settings for the surface itself and how it will be composited in the DOM */\n  rendererOptions?: ISurfaceOptions[\"rendererOptions\"];\n  /** The resources to be used for the pipeline */\n  resources?: W;\n\n  // CALLBACKS\n\n  /**\n   * All of the event managers used to control the surface. They are injected with identifiers to make it easy to\n   * reference them later. It's highly recommended to use an enum to identify the event manager.\n   */\n  eventManagers(cameras: U): V;\n  /** A callback that provides the pipeline to use in the surface */\n  scenes(\n    resources: W,\n    providers: T,\n    cameras: U,\n    managers: V\n  ): Lookup<BasicSurfaceSceneOptions> | BasicSurfaceSceneOptions[];\n  /** This will be called if no webgl context is detected */\n  onNoWebGL?(): void;\n}\n\n/**\n * This is a surface that has some concepts already set up within it, such as monitoring\n * resizing, waiting for a valid size to be present, a render loop tied into requestAnimationFrame.\n * Nothing here is difficult to set up in your own custom Surface implementation, this may provide\n * enough basics to quickly get started or be enough for most small projects.\n *\n * This auto generates a canvas object that tracks the size of the provided container HTMLElement. Essentially\n * this surface attempts to fill in the provided container.\n */\nexport class BasicSurface<\n  T extends Lookup<InstanceProvider<Instance>>,\n  U extends Lookup<Camera>,\n  V extends Lookup<EventManager> | EventManager[],\n  W extends Lookup<BaseResourceOptions>\n> {\n  /** The context generated by this surface to render into. */\n  private context: HTMLCanvasElement;\n  /** This is the last known time this surface executed it's draw loop */\n  private currentTime: number = 0;\n  /** This is the identifier of the requestAnimationFrame, used for canceling */\n  private drawRequestId: Promise<number>;\n  /** The target canvas to render on */\n  private options: IBasicSurfaceOptions<T, U, V, W>;\n  /** This is the timer id for resize events. This is used to debounce resize events */\n  private resizeTimer: number = 0;\n  /** Tracks the last visibility state the browser is in */\n  private visibility: VisibilityState = \"visible\";\n  /** This is the context  */\n  private waitForSize = waitForValidDimensions();\n\n  /** The cameras specified for this surface */\n  cameras: U;\n  /** The surface we are implementing */\n  base?: Surface;\n  /** The event managers specified for this surface */\n  eventManagers: V;\n  /** The providers specified for this surface */\n  providers: T;\n  /** A promise to await for the surface to be ready for rendering */\n  ready: Promise<BasicSurface<T, U, V, W>>;\n  /** The resources specified for the surface pipeline */\n  resources: W;\n\n  constructor(options: IBasicSurfaceOptions<T, U, V, W>) {\n    this.rebuild(options);\n  }\n\n  /**\n   * Generates the proper context for our surface to work with.\n   */\n  private createContext() {\n    // If our context is not defined, then one must be made\n    if (!this.context) {\n      this.context = document.createElement(\"canvas\");\n      this.context.title = \"\";\n      this.context.width =\n        (this.options.container.offsetWidth || 0) * window.devicePixelRatio;\n      this.context.height =\n        (this.options.container.offsetHeight || 0) * window.devicePixelRatio;\n      this.context.style.width = `${this.options.container.offsetWidth || 0}px`;\n      this.context.style.height = `${this.options.container.offsetHeight ||\n        0}px`;\n      this.options.container.appendChild(this.context);\n    }\n  }\n\n  /**\n   * Frees all GPU memory and resources used by this Surface.\n   */\n  destroy = () => {\n    if (this.base) {\n      this.base.destroy();\n      delete this.base;\n    }\n\n    if (this.context) {\n      this.context.remove();\n      delete this.context;\n    }\n\n    stopAnimationLoop(this.drawRequestId);\n    window.removeEventListener(\"resize\", this.handleResize);\n  };\n\n  /**\n   * The draw loop of the surface\n   */\n  private draw = async (time: number) => {\n    if (!this.base) return;\n    this.currentTime = time;\n    this.base.draw(time);\n  };\n\n  /**\n   * This is a handler that responds to varying resize events\n   */\n  private handleResize = () => {\n    clearTimeout(this.resizeTimer);\n    if (!this.base) return;\n\n    this.resizeTimer = window.setTimeout(() => {\n      this.fitContainer();\n    }, 100);\n  };\n\n  /**\n   * This is a handler that responds to the browser window losing visibility\n   */\n  private handleVisibility = () => {\n    if (document.visibilityState === \"visible\") {\n      if (this.visibility !== document.visibilityState) {\n        this.base?.redraw();\n      }\n    }\n\n    this.visibility = document.visibilityState;\n  };\n\n  /**\n   * Initializes all elements for the surface\n   */\n  async init() {\n    // If the base is established, then this is initialized\n    if (this.base) return;\n    // We wait for the DOM container to establish a size we can work with\n    const valid = await this.waitForSize(this.options.container);\n    // If the waiting process returns false it means we canceled the operation from overlapping calls into init()\n    if (!valid) return;\n    // Make the canvas context we wish to render into\n    this.createContext();\n\n    // In our initial calls to the surface we can have numerous errors emitted. Some errors are valid feedback into\n    // the state of the client's browser. Some errors are system failures that should be handled gracefully and logged\n    // appropriately for debugging.\n    try {\n      // Establish the providers this surface will track\n      this.providers = this.options.providers;\n      // Establish the cameras desired to be used in the surface\n      this.cameras = this.options.cameras;\n      // Establish the resources desired to be used in the surface\n      this.resources = this.options.resources || ({} as W);\n      // Establish the event managers to be used in the surface\n      this.eventManagers = this.options.eventManagers(this.cameras);\n\n      // Create the surface to work with\n      this.base = await new Surface({\n        context: this.context,\n        handlesWheelEvents:\n          this.options.handlesWheelEvents !== undefined\n            ? this.options.handlesWheelEvents\n            : true,\n        pixelRatio: window.devicePixelRatio,\n        eventManagers: lookupValues<EventManager>(\n          EventManager,\n          this.eventManagers\n        ),\n        rendererOptions: Object.assign(\n          {\n            alpha: true,\n            antialias: false\n          },\n          this.options.rendererOptions\n        )\n      }).ready;\n\n      // Make sure the context fits the container\n      this.fitContainer(true);\n      // Use the established cameras and managers to establish the initial pipeline for the surface\n      // await this.updatePipeline();\n      // Begin the draw loop\n      this.drawRequestId = onAnimationLoop(this.draw);\n      // Use the established cameras and managers to establish the initial pipeline for the surface\n      await this.updatePipeline();\n      // Establish event listeners\n      window.addEventListener(\"resize\", this.handleResize);\n      document.addEventListener(\"visibilitychange\", this.handleVisibility);\n    } catch (err) {\n      // We catch any initialization errors from the surface\n      if (err.error === SurfaceErrorType.NO_WEBGL_CONTEXT) {\n        if (this.options.onNoWebGL) this.options.onNoWebGL();\n      } else {\n        console.error(\"The Basic Surface could not be initialized\");\n        console.error(err.stack || err.message);\n      }\n    }\n  }\n\n  /**\n   * Tells the surface to resize to the container if it's not fitted currently.\n   */\n  fitContainer(preventRedraw?: boolean) {\n    if (this.base) {\n      this.context.remove();\n\n      this.base.resize(\n        this.options.container.offsetWidth || 0,\n        this.options.container.offsetHeight || 0\n      );\n\n      this.options.container.appendChild(this.context);\n      if (!preventRedraw) this.base.draw(this.currentTime);\n    }\n  }\n\n  /**\n   * Retrieves the projection methods for a given view. If the projections do not exist, this returns null.\n   */\n  getViewProjections(viewId: string) {\n    if (!this.base) return null;\n    return this.base.getProjections(viewId);\n  }\n\n  /**\n   * Retrieves the size of the view as it appears on the screen if the ID exists in the current pipeline.\n   * If it does not exist yet, this will return [0, 0]\n   */\n  getViewScreenSize(viewId: string): Size {\n    if (!this.base) return [0, 0];\n    const bounds = this.base.getViewSize(viewId);\n    if (!bounds) return [0, 0];\n\n    return [bounds.width, bounds.height];\n  }\n\n  /**\n   * Retrieves the bounds of the view as it appears on the screen (relative to the canvas).\n   * If it does not exist yet, this will return a dimensionless Bounds object.\n   */\n  getViewScreenBounds(viewId: string): Bounds<View<IViewProps>> {\n    if (!this.base) return new Bounds({ x: 0, y: 0, width: 0, height: 0 });\n    const bounds = this.base.getViewWorldBounds(viewId);\n    if (!bounds) return new Bounds({ x: 0, y: 0, width: 0, height: 0 });\n\n    return bounds;\n  }\n\n  /**\n   * Gets the bounds of the view within world space.\n   * If it does not exist yet, this will return a dimensionless Bounds object.\n   */\n  getViewWorldBounds(viewId: string): Bounds<View<IViewProps>> {\n    if (!this.base) return new Bounds({ x: 0, y: 0, width: 0, height: 0 });\n    const bounds = this.base.getViewWorldBounds(viewId);\n    if (!bounds) return new Bounds({ x: 0, y: 0, width: 0, height: 0 });\n\n    return bounds;\n  }\n\n  /**\n   * Redeclare the pipeline\n   */\n  async pipeline(callback: IBasicSurfaceOptions<T, U, V, W>[\"scenes\"]) {\n    this.options.scenes = callback;\n    if (!this.base) return;\n    await this.updatePipeline();\n  }\n\n  /**\n   * Destroys all current existing GPU resources and reconstructs them anew.\n   *\n   * NOTE: options parameter f\n   */\n  async rebuild(): Promise<void>;\n  async rebuild(clearProviders?: boolean): Promise<void>;\n  async rebuild(options?: IBasicSurfaceOptions<T, U, V, W>): Promise<void>;\n  async rebuild(param?: IBasicSurfaceOptions<T, U, V, W> | boolean) {\n    let options;\n\n    // See if the rebuild wanted to clear the providers or not.\n    if (typeof param === \"boolean\") {\n      if (param && this.providers) {\n        const providers = lookupValues<InstanceProvider<Instance>>(\n          InstanceProvider,\n          this.providers\n        );\n\n        for (let i = 0, iMax = providers.length; i < iMax; ++i) {\n          const provider = providers[i];\n          provider.clear();\n        }\n      }\n    }\n\n    // Otherwise, the parameter is options injected for the surface initial build\n    else {\n      options = param;\n    }\n\n    if (this.options && options) {\n      console.warn(\n        \"Ignoring options provided to rebuild method. The constructor is the only way to apply an options configuration object\"\n      );\n    }\n\n    // Destroy any existing base\n    if (this.base) {\n      this.base.destroy();\n    }\n\n    if (this.context) {\n      this.context.remove();\n      delete this.context;\n    }\n\n    // Only if the options have not been established will this work\n    if (!this.options && options) this.options = options;\n    // Make a resolver to handle making a promise and a way to resolve it easily\n    const resolver = new PromiseResolver<BasicSurface<T, U, V, W>>();\n    // Set our ready marker so contructors of the surface have an easy async pattern\n    this.ready = resolver.promise;\n    // Initialize this surface\n    await this.init();\n    // Resolve anything awaiting the ready marker for the basic surface. This is\n    // primarily for the contructor to have an easy async pattern.\n    resolver.resolve(this);\n  }\n\n  /**\n   * Point to a new container to fill.\n   */\n  setContainer(container: HTMLElement) {\n    this.options.container = container;\n    container.appendChild(this.context);\n    this.fitContainer();\n  }\n\n  /**\n   * Calls the pipeline callback to retrieve an updated pipeline for the surface\n   */\n  async updatePipeline() {\n    if (!this.base) return;\n\n    // NOTE: This chunk establishes the potentially undeclared keys of the resource declaration objects. Thus it needs\n    //       to execute before blocks that require the key to be established.\n    //\n    // Take the resource lookup and flatten it's values to a list. Each value will be given a key based on whether the\n    // value expressed an explicit key or will be a key made from the properties leading up to the value in the lookup.\n    const resources =\n      mapLookupValues(\n        \"resources\",\n        (val: any) => val && val.type !== undefined,\n        this.resources || [],\n        (key: string, val: BaseResourceOptions) => {\n          const resource: BaseResourceOptions = {\n            ...val,\n            key: val.key || key\n          };\n\n          val.key = resource.key;\n          return resource;\n        }\n      ) || [];\n\n    // We must convert all look ups of scenes and layers etc into a list of items that contain keys\n    const pipelineWithLookups = this.options.scenes(\n      this.resources || ({} as W),\n      this.providers,\n      this.cameras,\n      this.eventManagers\n    );\n\n    const scenes = mapLookupValues(\n      \"scenes\",\n      (val: any) => val && val.views !== undefined && val.layers !== undefined,\n      pipelineWithLookups,\n      (sceneKey: string, val: BasicSurfaceSceneOptions) => {\n        const views = mapLookupValues(\n          \"views\",\n          (val: any) => val && val.init !== undefined && val.init.length === 2,\n          val.views,\n          (key: string, val: BasicSurfaceView<IViewProps>) => {\n            const view: ViewInitializer<IViewProps> = {\n              ...val,\n              key: `${sceneKey}.${val.key || key}`\n            };\n\n            // Make the props it's own object so we don't mutate the originating object when we apply the\n            // calculated key\n            view.init[1] = {\n              ...view.init[1],\n              key: view.key\n            };\n\n            return view;\n          }\n        );\n\n        const layers = mapLookupValues(\n          \"layers\",\n          (val: any) => val && val.init !== undefined,\n          val.layers,\n          (key: string, val: BasicSurfaceLayer) => {\n            const layer: LayerInitializer = {\n              init: val.init,\n              key: val.key || key\n            };\n\n            val.init[1].key = layer.key;\n            return layer;\n          }\n        );\n\n        const scene: ISceneOptions = {\n          key: sceneKey,\n          order: val.order,\n          views,\n          layers\n        };\n\n        if (val.order === undefined) {\n          delete scene.order;\n        }\n\n        return scene;\n      }\n    );\n\n    const pipeline: IPipeline = {\n      resources,\n      scenes\n    };\n\n    return await this.base.pipeline(pipeline);\n  }\n}\n","export * from \"./log-changes-layer\";\n","import { Instance, InstanceProvider } from \"../instance-provider\";\nimport {\n  ILayerConstructable,\n  ILayerProps,\n  Layer,\n  LayerInitializer,\n  LayerScene,\n  Surface\n} from \"../surface\";\nimport { Omit } from \"../types\";\nimport { createLayer } from \"../util/create-util\";\n\n/**\n * Options for generating a Logging layer\n */\ninterface ILogChangesLayerProps<T extends Instance>\n  extends Omit<ILayerProps<T>, \"key\"> {\n  /** Gets the key for the layer. */\n  key: string;\n  /** Provides a header to the log output to make the logs easier to understand */\n  messageHeader?(): string;\n  /** This is the wrapped layer initializer */\n  wrap?: LayerInitializer;\n}\n\n/**\n * This is a layer intended to help debug changes streaming through instances. This layer wraps\n * another layer and analyzes the changes passed to the child layer without editing the layer in any\n * way.\n */\nclass LogChangesLayer<\n  T extends Instance,\n  U extends ILogChangesLayerProps<T>\n> extends Layer<T, U> {\n  /** Default props for the Layer */\n  static defaultProps: ILogChangesLayerProps<any> = {\n    data: new InstanceProvider(),\n    key: \"default\",\n    messageHeader: () => \"\",\n    wrap: createLayer(Layer, {\n      data: new InstanceProvider(),\n      scene: \"default\"\n    })\n  };\n\n  constructor(surface: Surface, scene: LayerScene, props: U) {\n    super(surface, scene, props);\n\n    console.warn(\n      \"Please ensure all debugLayer calls are removed for production:\",\n      props.key\n    );\n  }\n\n  /**\n   * Hand the wrapped layer as a child layer to this layer\n   */\n  childLayers(): LayerInitializer[] {\n    if (!this.props.wrap) return [];\n    this.props.wrap.init[1].key = `debug-wrapper.${this.props.key}`;\n    return [this.props.wrap];\n  }\n\n  /**\n   * Our draw loop. We use this to hijack the changes flowing to our wrapped layer so we can output\n   * significant information about the changes.\n   */\n  draw() {\n    if (!this.props.wrap) return;\n    const changes = this.resolveChanges(true);\n    if (changes.length === 0) return;\n    const { messageHeader = () => \"\" } = this.props;\n\n    console.warn(`${messageHeader()}\\n`, {\n      totalChanges: changes.length,\n      changes\n    });\n  }\n\n  /**\n   * Log the shader information of the layer\n   */\n  initShader() {\n    if (!this.props.wrap) return null;\n\n    const layer = new this.props.wrap.init[0](\n      this.surface,\n      this.scene,\n      this.props.wrap.init[1]\n    );\n    const toProcess = layer.childLayers();\n    const childLayers: { [key: string]: {} } = {};\n\n    while (toProcess.length > 0) {\n      const child = toProcess.pop();\n      if (!child) continue;\n      const childLayer = new child.init[0](\n        this.surface,\n        this.scene,\n        child.init[1]\n      );\n\n      childLayers[childLayer.id] = {\n        shaderIO: childLayer.initShader()\n      };\n\n      childLayer.childLayers().forEach(l => toProcess.push(l));\n    }\n\n    console.warn(`Shader IO: ${this.id}\\n`, {\n      shaderIO: layer.initShader(),\n      childLayers\n    });\n\n    return null;\n  }\n}\n\n/**\n * Can use this instead of createLayer to view changes streaming through a layer.\n */\nexport function debugLayer<T extends Instance, U extends ILayerProps<T>>(\n  layerClass: ILayerConstructable<T> & { defaultProps: U },\n  props: Omit<U, \"key\"> & Partial<Pick<U, \"key\">>\n): LayerInitializer {\n  const initializer: LayerInitializer = createLayer(LogChangesLayer, {\n    messageHeader: () => `CHANGES FOR: ${initializer.init[1].key}`,\n    wrap: createLayer(layerClass, props),\n    data: props.data\n  });\n\n  return initializer;\n}\n"],"sourceRoot":""}