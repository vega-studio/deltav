(function(){"use strict";try{if(typeof document<"u"){var e=document.createElement("style");e.appendChild(document.createTextNode(".SurfaceJSX{flex:1 1 auto;display:flex;flex-direction:column;width:100%;height:100%;overflow:hidden}")),document.head.appendChild(e)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}})();
(function(h,j){var ht=document.createElement("style");ht.textContent=`.SurfaceJSX{flex:1 1 auto;display:flex;flex-direction:column;width:100%;height:100%;overflow:hidden}
`,document.head.appendChild(ht),typeof exports=="object"&&typeof module<"u"?j(exports,require("react")):typeof define=="function"&&define.amd?define(["exports","react"],j):(h=typeof globalThis<"u"?globalThis:h||self,j(h.deltav={},h.React))})(this,function(h,j){"use strict";var Ew=Object.defineProperty;var _w=(h,j,ht)=>j in h?Ew(h,j,{enumerable:!0,configurable:!0,writable:!0,value:ht}):h[j]=ht;var f=(h,j,ht)=>(_w(h,typeof j!="symbol"?j+"":j,ht),ht);window.WebGL2RenderingContext=window.WebGL2RenderingContext||function(){};class ht{constructor(){f(this,"userInputManager")}get surface(){return this.userInputManager.surface}getProjection(t){const e=this.userInputManager.getView(t);return e?e.projection:null}getView(t){return this.userInputManager&&this.userInputManager.getView(t)||null}getViewScreenBounds(t){const e=this.userInputManager.getView(t);return e?e.screenBounds:null}setUserInputManager(t){this.userInputManager=t}willRender(){}didRender(){}}class bs extends ht{constructor(t){super(),Object.assign(this,t)}handleMouseDown(t){}handleMouseUp(t){}handleMouseOver(t){}handleMouseOut(t){}handleMouseMove(t){}handleClick(t){}handleDrag(t){}handleWheel(t){}handleTouchCancelled(t){}handleTouchDown(t){}handleTouchUp(t){}handleTouchOut(t){}handleTouchDrag(t){}handleTap(t){}handleDoubleTap(t){}handleLongTouch(t){}handleLongTap(t){}handlePinch(t){}handleSpread(t){}handleTouchRotate(t){}handleSwipe(t){}}var xl=(n=>(n[n.NONE=-1]="NONE",n[n.LEFT=0]="LEFT",n[n.AUX=1]="AUX",n[n.RIGHT=2]="RIGHT",n[n.FOURTH=3]="FOURTH",n[n.FIFTH=4]="FIFTH",n))(xl||{});const{sqrt:Ua,max:St,min:Mt,floor:Ct,ceil:Lt,abs:Ot,acos:gp,sin:Fa}=Math,Xe=new Array(20).fill(0).map(n=>[0,0,0]),Rl=new Array(20).fill(0).map(n=>[0,0,0,0]);function Al(n){return n&&Array.isArray(n)&&n.length===1}function ka(n){return n&&Array.isArray(n)&&n.length===2}function Il(n){return n&&Array.isArray(n)&&n.length===3}function V(n){return n&&Array.isArray(n)&&n.length===4}function ke(n,t){return n=n||[],n[0]=t,n}function ws(n,t,e){return ke(e,n[0]+t[0])}function Ga(n,t){return ke(t,Lt(n[0]))}function za(n,t){return n[0]===t[0]}function Sl(n,t,e){return Ot(n[0]-t[0])<=e}function Va(n,t){return ke(t,n[0])}function $a(){return[0]}function Wa(n,t,e){return ke(e,0)}function ja(n,t,e){return ke(e,n[0]/t[0])}function Ha(n){return ke(n,0)}function Xa(n,t){t=t||[];for(let e=0,i=n.length;e<i;++e)t.push(n[e][0]);return t}function Qa(n,t){return ke(t,Ct(n[0]))}function Ya(n,t){return ke(t,1/n[0])}function Ts(n,t,e){return ke(e,n[0]*t)}function ys(n,t,e){return ke(e,n[0]-t[0])}function qa(n,t,e){return ke(e,St(n[0],t[0]))}function Ka(n,t,e){return ke(e,Mt(n[0],t[0]))}function Za(n,t,e){return ke(e,n[0]*t[0])}function Ja(n,t){return ke(t,1)}function eo(n,t){return n[0]*t[0]}function Ml(n,t){return n[0]*t[0]}function to(n,t,e,i){return ws(Ts(ys(t,n),e),n,i)}function no(n){return n[0]}function Cl(n){return n}function io(n,...t){let e;if(t=t||[],Array.isArray(n)?e=n.slice(0,1):e=[n],e.length<1)for(let i=0,r=t.length;i<r&&e.length<1;++i){const s=t[i];Array.isArray(s)?e.push(...s.slice(0,1-e.length)):e.push(s)}for(;e.length<1;)e.push(0);return e}function ge(n,t,e){return n=n||new Array(2),n[0]=t,n[1]=e,n}function xn(n,t,e){return ge(e,n[0]+t[0],n[1]+t[1])}function ro(n,t){return ge(t,Lt(n[0]),Lt(n[1]))}function Es(n,t){return ge(t,n[0],n[1])}function so(n){return ge(n,1,0)}function ao(n,t,e){return ge(e,0,0)}function _s(n,t){return n[0]===t[0]&&n[1]===t[1]}function Ll(n,t,e){return Ot(n[0]-t[0])<=e&&Ot(n[1]-t[1])<=e}function wr(n,t,e){return ge(e,n[0]/t[0],n[1]/t[1])}function oo(n){return ge(n,0,0)}function co(n,t){t=t||new Array(n.length*2);for(let e=0,i=0,r=n.length;e<r;++e,i+=2){const s=n[e];t[i]=s[0],t[i+1]=s[1]}return t}function lo(n,t){return ge(t,Ct(n[0]),Ct(n[1]))}function xs(n,t){return ge(t,1/n[0],1/n[1])}function uo(n,t,e){return ge(e,St(n[0],t[0]),St(n[1],t[1]))}function ho(n,t,e){return ge(e,Mt(n[0],t[0]),Mt(n[1],t[1]))}function Ce(n,t,e){return ge(e,n[0]*t,n[1]*t)}function Ae(n,t,e){const i=e||new Array(2);return i[0]=n[0]-t[0],i[1]=n[1]-t[1],i}function fo(n,t,e){return ge(e,n[0]*t[0],n[1]*t[1])}function po(n,t){const e=Hn(n);return ge(t,n[0]/e,n[1]/e)}function Gi(n,t){return n[0]*t[0]+n[1]*t[1]}function Ol(n,t){return n[0]*t[0]-n[1]*t[1]}function Nl(n,t){return n[0]*t[1]-n[1]*t[0]}function Pl(n,t){return ge(t,n[1],n[0])}function go(n,t,e,i){return xn(Ce(Ae(t,n),e),n,i)}function Hn(n){return mo(n[0],n[1])}function mo(n,t){return Ua(n*n+t*t)}function Rs(n,...t){let e;if(t=t||[],Array.isArray(n)?e=n.slice(0,2):e=[n],e.length<2)for(let i=0,r=t.length;i<r&&e.length<2;++i){const s=t[i];Array.isArray(s)?e.push(...s.slice(0,2-e.length)):e.push(s)}for(;e.length<2;)e.push(0);return e}function ve(n,t,e,i){return n=n||new Array(3),n[0]=t,n[1]=e,n[2]=i,n}function Nt(n,t,e){return ve(e,n[0]+t[0],n[1]+t[1],n[2]+t[2])}function vo(n,t){return ve(t,Lt(n[0]),Lt(n[1]),Lt(n[2]))}function st(n,t){return ve(t,n[0],n[1],n[2])}function Tr(n,t){return n[0]===t[0]&&n[1]===t[1]&&n[2]===t[2]}function Dl(n,t,e){return Ot(n[0]-t[0])<=e&&Ot(n[1]-t[1])<=e&&Ot(n[2]-t[2])<=e}function fi(n){return ve(n,0,0,-1)}function Ze(n,t,e){return e=e||new Array(3),e[0]=n[1]*t[2]-n[2]*t[1],e[1]=n[2]*t[0]-n[0]*t[2],e[2]=n[0]*t[1]-n[1]*t[0],e}function yr(n,t,e){return ve(e,n[0]/t[0],n[1]/t[1],n[2]/t[2])}function bo(n){return ve(n,0,0,0)}function wo(n,t){t=t||new Array(n.length*3);for(let e=0,i=0,r=n.length;e<r;++e,i+=3){const s=n[e];t[i]=s[0],t[i+1]=s[1],t[i+2]=s[2]}return t}function To(n,t){return ve(t,Ct(n[0]),Ct(n[1]),Ct(n[2]))}function zi(n,t){return ve(t,1/n[0],1/n[1],1/n[2])}function at(n,t,e){return ve(e,n[0]*t,n[1]*t,n[2]*t)}function Pt(n,t,e){return ve(e,n[0]-t[0],n[1]-t[1],n[2]-t[2])}function yo(n,t,e){return ve(e,n[0]*t[0],n[1]*t[1],n[2]*t[2])}function Eo(n,t,e,i){return Nt(at(Pt(t,n),e),n,i)}function As(n){return _o(n[0],n[1],n[2])}function _o(n,t,e){return Ua(n*n+t*t+e*e)}function Is(n,t,e){return ve(e,St(n[0],t[0]),St(n[1],t[1]),St(n[2],t[2]))}function Ss(n,t,e){return ve(e,Mt(n[0],t[0]),Mt(n[1],t[1]),Mt(n[2],t[2]))}function dt(n,t){t=t||new Array(3);const e=As(n);return t[0]=n[0]/e,t[1]=n[1]/e,t[2]=n[2]/e,t}function Er(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function Bl(n,t){return n[0]*t[0]-n[1]*t[1]-n[2]*t[2]}function Ul(n,t){return ve(t,n[2],n[1],n[0])}function Xn(n,...t){let e;if(t=t||[],Array.isArray(n)?e=n.slice(0,3):e=[n],e.length<3)for(let i=0,r=t.length;i<r&&e.length<3;++i){const s=t[i];Array.isArray(s)?e.push(...s.slice(0,3-e.length)):e.push(s)}for(;e.length<3;)e.push(0);return e}function Fl(n,t,e){return e=e||[0,0,0],dt(Ze(Ze(n,t),n),e)}function kl(n,t,e){return e=e||[0,0,0],dt(Ze(n,t),e)}function Gl(n,t,e){return e=e||[0,0,0],dt(Ze(t,n),e)}function zl(n,t,e){return e=e||[0,0,0],dt(Ze(n,Ze(n,t)),e)}function me(n,t,e,i,r){return n=n||new Array(4),n[0]=t,n[1]=e,n[2]=i,n[3]=r,n}function Ms(n,t,e){return me(e,n[0]+t[0],n[1]+t[1],n[2]+t[2],n[3]+t[3])}function Vl(n,t,e){return me(e,n[0]+t[0],n[1]+t[1],n[2]+t[2],n[3])}function xo(n,t){return me(t,Lt(n[0]),Lt(n[1]),Lt(n[2]),Lt(n[3]))}function Dt(n,t){return me(t,n[0],n[1],n[2],n[3])}function Cs(n,t){return n[0]===t[0]&&n[1]===t[1]&&n[2]===t[2]&&n[3]===t[3]}function $l(n,t,e){return Ot(n[0]-t[0])<=e&&Ot(n[1]-t[1])<=e&&Ot(n[2]-t[2])<=e&&Ot(n[3]-t[3])<=e}function Ro(n){return me(n,0,0,-1,0)}function Ao(n,t,e){return me(e,0,0,0,1)}function Io(n,t,e){return me(e,n[0]/t[0],n[1]/t[1],n[2]/t[2],n[3]/t[3])}function So(n){return me(n,0,0,0,0)}function Ls(n,t){t=t||new Array(4);for(let e=0,i=0,r=n.length;e<r;++e,i+=4){const s=n[e];t[i]=s[0],t[i+1]=s[1],t[i+2]=s[2],t[i+3]=s[3]}return t}function Mo(n,t){return me(t,Ct(n[0]),Ct(n[1]),Ct(n[2]),Ct(n[3]))}function Co(n,t){return me(t,1/n[0],1/n[1],1/n[2],1/n[3])}function Os(n,t,e){return me(e,n[0]*t,n[1]*t,n[2]*t,n[3]*t)}function Ns(n,t,e){return me(e,n[0]-t[0],n[1]-t[1],n[2]-t[2],n[3]-t[3])}function Lo(n,t,e){return me(e,n[0]*t[0],n[1]*t[1],n[2]*t[2],n[3]*t[3])}function Ps(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]*t[3]}function Wl(n,t){return n[0]*t[0]-n[1]*t[1]-n[2]*t[2]-n[3]*t[3]}function jl(n,t){return me(t,n[3],n[2],n[1],n[0])}function Oo(n,t,e,i){return Ms(Os(Ns(t,n),e),n,i)}function Ds(n){return Rn(n[0],n[1],n[2],n[3])}function Rn(n,t,e,i){return Ua(n*n+t*t+e*e+i*i)}function No(n,t,e){return me(e,St(n[0],t[0]),St(n[1],t[1]),St(n[2],t[2]),St(n[3],t[3]))}function Po(n,t,e){return me(e,Mt(n[0],t[0]),Mt(n[1],t[1]),Mt(n[2],t[2]),Mt(n[3],t[3]))}function Do(n,t){const e=Ds(n);return me(t,n[0]/e,n[1]/e,n[2]/e,n[3]/e)}function _r(n,...t){let e;if(t=t||[],Array.isArray(n)?e=n.slice(0,4):e=[n],e.length<4)for(let i=0,r=t.length;i<r&&e.length<4;++i){const s=t[i];Array.isArray(s)?e.push(...s.slice(0,4-e.length)):e.push(s)}for(;e.length<4;)e.push(0);return e}function Hl(n,t){return t=t||[0,0,0,0],me(t,((n&16711680)>>16)/255,((n&65280)>>8)/255,(n&255)/255,1)}function Xl(n,t){return t=t||[0,0,0,0],me(t,((n&4278190080)>>24)/255,((n&16711680)>>16)/255,((n&65280)>>8)/255,(n&255)/255)}function Bo(n,t,e,i){i=i||[0,0,0,0];const r=[0,0,0,0];let s,a,o,c,l;return a=n[1]*t[1]+n[2]*t[2]+n[3]*t[3]+n[0]*t[0],a<0?(a=-a,r[0]=-t[0],r[1]=-t[1],r[2]=-t[2],r[3]=-t[3]):(r[0]=t[0],r[1]=t[1],r[2]=t[2],r[3]=t[3]),1-a>1e-7?(s=gp(a),o=Fa(s),c=Fa((1-e)*s)/o,l=Fa(e*s)/o):(c=1-e,l=e),i[1]=c*n[1]+l*r[1],i[2]=c*n[2]+l*r[2],i[3]=c*n[3]+l*r[3],i[0]=c*n[0]+l*r[0],i}const Uo={add:ws,ceil:Ga,copy:Va,compare:za,cross:Wa,divide:ja,dot:eo,empty:Ha,flatten:Xa,floor:Qa,forward:$a,inverse:Ya,length:no,linear:to,max:qa,min:Ka,multiply:Za,normalize:Ja,scale:Ts,subtract:ys,vec:io},Fo={add:xn,ceil:ro,copy:Es,compare:_s,cross:ao,divide:wr,dot:Gi,empty:oo,flatten:co,floor:lo,forward:so,inverse:xs,length:Hn,linear:go,max:uo,min:ho,multiply:fo,normalize:po,scale:Ce,subtract:Ae,vec:Rs},ko={add:Nt,ceil:vo,copy:st,compare:Tr,cross:Ze,divide:yr,dot:Er,empty:bo,flatten:wo,floor:To,forward:fi,inverse:zi,length:As,linear:Eo,max:Is,min:Ss,multiply:yo,normalize:dt,scale:at,subtract:Pt,vec:Xn},Go={add:Ms,ceil:xo,copy:Dt,compare:Cs,cross:Ao,divide:Io,dot:Ps,empty:So,flatten:Ls,floor:Mo,forward:Ro,inverse:Co,length:Ds,linear:Oo,max:No,min:Po,multiply:Lo,normalize:Do,scale:Os,subtract:Ns,vec:_r,slerpQuat:Bo};function G(n){let t;return n.length===1?(t=Uo,t):n.length===2?(t=Fo,t):n.length===3?(t=ko,t):(t=Go,t)}function Ql(n){return`[${n[0]}]`}function Yl(n){return`[${n[0]}, ${n[1]}]`}function ql(n){return`[${n[0]}, ${n[1]}, ${n[2]}]`}function Kl(n){return`[${n[0]}, ${n[1]}, ${n[2]}, ${n[3]}]`}const mp=Object.freeze(Object.defineProperty({__proto__:null,V3R:Xe,V4R:Rl,VecMath:G,add1:ws,add2:xn,add3:Nt,add4:Ms,add4by3:Vl,apply1:ke,apply2:ge,apply3:ve,apply4:me,ceil1:Ga,ceil2:ro,ceil3:vo,ceil4:xo,color4FromHex3:Hl,color4FromHex4:Xl,compare1:za,compare2:_s,compare3:Tr,compare4:Cs,copy1:Va,copy2:Es,copy3:st,copy4:Dt,cross1:Wa,cross2:ao,cross3:Ze,cross4:Ao,divide1:ja,divide2:wr,divide3:yr,divide4:Io,dot1:eo,dot2:Gi,dot3:Er,dot4:Ps,down3:zl,empty1:Ha,empty2:oo,empty3:bo,empty4:So,flatten1:Xa,flatten2:co,flatten3:wo,flatten4:Ls,floor1:Qa,floor2:lo,floor3:To,floor4:Mo,forward1:$a,forward2:so,forward3:fi,forward4:Ro,fuzzyCompare1:Sl,fuzzyCompare2:Ll,fuzzyCompare3:Dl,fuzzyCompare4:$l,inverse1:Ya,inverse2:xs,inverse3:zi,inverse4:Co,isVec1:Al,isVec2:ka,isVec3:Il,isVec4:V,left3:Gl,length1:no,length1Components:Cl,length2:Hn,length2Components:mo,length3:As,length3Components:_o,length4:Ds,length4Components:Rn,linear1:to,linear2:go,linear3:Eo,linear4:Oo,max1:qa,max2:uo,max3:Is,max4:No,min1:Ka,min2:ho,min3:Ss,min4:Po,multiply1:Za,multiply2:fo,multiply3:yo,multiply4:Lo,normalize1:Ja,normalize2:po,normalize3:dt,normalize4:Do,reverse2:Pl,reverse3:Ul,reverse4:jl,right3:kl,scale1:Ts,scale2:Ce,scale3:at,scale4:Os,slerpQuat:Bo,subtract1:ys,subtract2:Ae,subtract3:Pt,subtract4:Ns,toString1:Ql,toString2:Yl,toString3:ql,toString4:Kl,tod1:Ml,tod2:Ol,tod3:Bl,tod4:Wl,tod_flip2:Nl,up3:Fl,vec1:io,vec1Methods:Uo,vec2:Rs,vec2Methods:Fo,vec3:Xn,vec3Methods:ko,vec4:_r,vec4Methods:Go},Symbol.toStringTag,{value:"Module"})),{min:Bs,max:Us}=Math;class ie{constructor(t){f(this,"x",0);f(this,"y",0);f(this,"width",0);f(this,"height",0);f(this,"d");this.x=t.x||t.left||0,this.y=t.y||t.top||0,this.height=t.height||(t.bottom||0)-this.y||0,this.width=t.width||(t.right||0)-this.x||0}get area(){return this.width*this.height}get bottom(){return this.y+this.height}get left(){return this.x}get mid(){return[this.x+this.width/2,this.y+this.height/2]}get right(){return this.x+this.width}get top(){return this.y}static emptyBounds(){return new ie({height:0,width:0,x:0,y:0})}containsPoint(t){return!(t[0]<this.x||t[1]<this.y||t[0]>this.right||t[1]>this.bottom)}encapsulate(t){return t instanceof ie?(t.x<this.x&&(this.width+=Math.abs(t.x-this.x),this.x=t.x),t.y<this.y&&(this.height+=Math.abs(t.y-this.y),this.y=t.y),this.right<t.right&&(this.width+=t.right-this.right),this.bottom<t.bottom&&(this.height+=t.bottom-this.bottom),!0):(t[0]<this.x&&(this.width+=this.x-t[0],this.x=t[0]),t[0]>this.right&&(this.width+=t[0]-this.x),t[1]<this.y&&(this.height+=this.y-t[1],this.y=t[1]),t[1]>this.bottom&&(this.height+=t[1]-this.y),!0)}encapsulateAll(t){if(t.length<=0)return;let e=Number.MAX_SAFE_INTEGER,i=Number.MIN_SAFE_INTEGER,r=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER;if(t[0]instanceof ie){const a=t;for(let o=0,c=a.length;o<c;++o){const l=a[o];e=Bs(e,l.left),i=Us(i,l.right),r=Bs(r,l.top),s=Us(s,l.bottom)}}else{const a=t;for(let o=0,c=a.length;o<c;++o){const[l,u]=a[o];e=Bs(e,l),i=Us(i,l),r=Bs(r,u),s=Us(s,u)}}this.x=Math.min(this.x,e),this.y=Math.min(this.y,r),this.width=Math.max(this.width,i-e),this.height=Math.max(this.height,s-r)}fits(t){return this.width===t.width&&this.height===t.height?1:this.width>=t.width&&this.height>=t.height?2:0}hitBounds(t){return!(this.right<t.x||this.x>t.right||this.bottom<t.y||this.y>t.bottom)}isInside(t){return this.x>=t.x&&this.right<=t.right&&this.y>=t.y&&this.bottom<=t.bottom}get location(){return[this.x,this.y]}toString(){return`{x: ${this.x} y:${this.y} w:${this.width} h:${this.height}}`}}function Bt(n,t,e){const i=`${n}`,r=parseFloat(i);return isNaN(r)?0:i.indexOf("%")>-1?r/100*t:r*e}const Vi=new WeakSet;function zo(n,t,e){(t.width===0||t.height===0)&&(Vi.has(n)||(console.warn("An AbsolutePosition evaluated to invalid dimensions.","Please ensure that the object provided and the reference has valid dimensions","to produce dimensions with width and height that are non-zero.","item:",n,"reference:",t.toString()),Vi.add(n)));const i=ie.emptyBounds();let r,s;if(n.width)i.width=Bt(n.width,t.width,e),n.left!==void 0?i.x=Bt(n.left,t.width,e):n.right!==void 0&&(i.x=t.width-Bt(n.right,t.width,e)-i.width);else{const a=Bt(n.left||0,t.width,e);r=t.width-Bt(n.right||0,t.width,e)-a,r<0&&(Vi.has(n)||(console.warn("An AbsolutePosition evaluated to invalid dimensions.","Please ensure that the object provided and the reference has valid dimensions","to produce dimensions with width and height that are greater than zero.","item:",n,"reference:",t.toString()),Vi.add(n))),i.x=a,i.width=r}if(n.height)i.height=Bt(n.height,t.height,e),n.top!==void 0?i.y=Bt(n.top,t.height,e):n.bottom!==void 0&&(i.y=t.height-Bt(n.bottom,t.height,e)-i.height);else{const a=Bt(n.top||0,t.height,e);s=t.height-Bt(n.bottom||0,t.height,e)-a,(s===void 0||s<0)&&(Vi.has(n)||(console.warn("An AbsolutePosition evaluated to invalid dimensions.","Please ensure that the object provided and the reference has valid dimensions","to produce dimensions with width and height that are greater than zero.","item:",n,"reference:",t.toString()),Vi.add(n))),i.y=a,i.height=s}return(i.width===0||i.height===0||isNaN(i.x+i.y+i.width+i.height))&&(i.x=0,i.y=0,i.width=t.width,i.height=t.height),i}class Ut{constructor(t,e,i=!1,r=!1){f(this,"data");f(this,"gl");f(this,"_isDynamic");f(this,"_isInstanced",!1);f(this,"_fullUpdate",!1);f(this,"normalize",!1);f(this,"_needsUpdate",!1);f(this,"size");f(this,"_updateRange",{count:-1,offset:-1});this.data=t,this.size=e,this._isDynamic=i,this._isInstanced=r}get isDynamic(){return this._isDynamic}get isInstanced(){return this._isInstanced}get fullUpdate(){return this._fullUpdate}get needsUpdate(){return this._needsUpdate}get count(){return this.data.length/this.size}get updateRange(){return this._updateRange}set updateRange(t){this._updateRange=t,this._needsUpdate=!0}destroy(){this.data=new Float32Array(0),this.gl&&this.gl.proxy.disposeAttribute(this)}rebuild(){this.gl&&this.gl.proxy.disposeAttribute(this)}resolve(){this._needsUpdate=!1,this._fullUpdate=!1}resize(t,e){e===void 0?e=this.data.length:e=e*this.size;const i=new Float32Array(t*this.size);i.length>=e?e===this.data.length?i.set(this.data):i.set(this.data.subarray(0,e)):i.set(this.data.subarray(0,i.length)),this.destroy(),this.data=i,this._needsUpdate=!0,this._fullUpdate=!0}repeatInstances(t,e,i=1){if(i<1)throw new Error("Can not use repeatInstance on attribute with a startInstance of less than 1");const r=e*this.size;if(i*r+r>this.data.length)return;const s=Math.floor(this.data.length/r),a=Math.min(i+t,s),o=i*r;this.data.copyWithin(o,0,r);let c=1,l=a-i-1,u=36;for(;l>0&&--u>0;)this.data.copyWithin(i+c*r,o,Math.min(l,c)*r),l-=c,c+=c}setDynamic(t){this._isDynamic=t,this._needsUpdate=!0,this._fullUpdate=!0}}class An{constructor(){f(this,"_attributes",{});f(this,"_attributeMap");f(this,"_indexBuffer");f(this,"gl");f(this,"maxInstancedCount",0);f(this,"isInstanced",!1)}get attributes(){return this._attributeMap?this._attributeMap:(this._attributeMap=new Map(Object.entries(this._attributes)),this._attributeMap)}get indexBuffer(){return this._indexBuffer}addAttribute(t,e){delete this._attributeMap,this._attributes[t]=e,this.isInstanced=!1;let i;Object.values(this._attributes).forEach(r=>{const s=r.isInstanced?1:0;i===void 0&&(i=s),(i^s)===1&&(this.isInstanced=!0)})}setIndexBuffer(t){this._indexBuffer=t}removeAttribute(t){delete this._attributeMap,delete this._attributes[t]}resizeVertexCount(t,e){const i=Object.values(this._attributes);for(const r of i)r.resize(t);this.gl&&this.gl.proxy.disposeGeometry(this),this._indexBuffer&&e!==void 0&&this._indexBuffer.resize(e,t)}destroy(){var t;delete this._attributeMap,this.attributes.forEach(e=>e.destroy()),(t=this.indexBuffer)==null||t.destroy(),this.gl&&this.gl.proxy.disposeGeometry(this),this._attributes={}}rebuild(){var t;delete this._attributeMap,(t=this.gl)==null||t.proxy.disposeGeometry(this)}}h.GLSettings=void 0,(n=>{(t=>{(e=>{e[e.RGBA4=0]="RGBA4",e[e.RGB565=1]="RGB565",e[e.RGB5_A1=2]="RGB5_A1",e[e.R8=3]="R8",e[e.R8UI=4]="R8UI",e[e.R8I=5]="R8I",e[e.R16UI=6]="R16UI",e[e.R16I=7]="R16I",e[e.R32UI=8]="R32UI",e[e.R32I=9]="R32I",e[e.RG8=10]="RG8",e[e.RG8UI=11]="RG8UI",e[e.RG8I=12]="RG8I",e[e.RG16UI=13]="RG16UI",e[e.RG16I=14]="RG16I",e[e.RG32UI=15]="RG32UI",e[e.RG32I=16]="RG32I",e[e.RGB8=17]="RGB8",e[e.RGBA8=18]="RGBA8",e[e.SRGB8_ALPHA8=19]="SRGB8_ALPHA8",e[e.RGB10_A2=20]="RGB10_A2",e[e.RGBA8UI=21]="RGBA8UI",e[e.RGBA8I=22]="RGBA8I",e[e.RGB10_A2UI=23]="RGB10_A2UI",e[e.RGBA16UI=24]="RGBA16UI",e[e.RGBA16I=25]="RGBA16I",e[e.RGBA32I=26]="RGBA32I",e[e.RGBA32UI=27]="RGBA32UI"})(t.ColorBufferFormat||(t.ColorBufferFormat={})),(e=>{e[e.DEPTH_COMPONENT16=0]="DEPTH_COMPONENT16",e[e.DEPTH_STENCIL=1]="DEPTH_STENCIL",e[e.DEPTH_COMPONENT24=2]="DEPTH_COMPONENT24",e[e.DEPTH_COMPONENT32F=3]="DEPTH_COMPONENT32F",e[e.DEPTH24_STENCIL8=4]="DEPTH24_STENCIL8",e[e.DEPTH32F_STENCIL8=5]="DEPTH32F_STENCIL8"})(t.DepthBufferFormat||(t.DepthBufferFormat={})),(e=>{e[e.STENCIL_INDEX8=0]="STENCIL_INDEX8"})(t.StencilBufferFormat||(t.StencilBufferFormat={}))})(n.RenderTarget||(n.RenderTarget={})),(t=>{(e=>{e[e.NoBlending=-1]="NoBlending",e[e.NormalBlending=1]="NormalBlending",e[e.AdditiveBlending=2]="AdditiveBlending",e[e.SubtractiveBlending=3]="SubtractiveBlending",e[e.MultiplyBlending=4]="MultiplyBlending"})(t.Blending||(t.Blending={})),(e=>{e[e.Zero=-1]="Zero",e[e.One=1]="One",e[e.SrcColor=2]="SrcColor",e[e.OneMinusSrcColor=3]="OneMinusSrcColor",e[e.SrcAlpha=4]="SrcAlpha",e[e.OneMinusSrcAlpha=5]="OneMinusSrcAlpha",e[e.DstAlpha=6]="DstAlpha",e[e.OneMinusDstAlpha=7]="OneMinusDstAlpha",e[e.DstColor=8]="DstColor",e[e.OneMinusDstColor=9]="OneMinusDstColor"})(t.BlendingDstFactor||(t.BlendingDstFactor={})),(e=>{e[e.Zero=-1]="Zero",e[e.One=1]="One",e[e.SrcColor=2]="SrcColor",e[e.OneMinusSrcColor=3]="OneMinusSrcColor",e[e.SrcAlpha=4]="SrcAlpha",e[e.OneMinusSrcAlpha=5]="OneMinusSrcAlpha",e[e.DstAlpha=6]="DstAlpha",e[e.OneMinusDstAlpha=7]="OneMinusDstAlpha",e[e.DstColor=8]="DstColor",e[e.OneMinusDstColor=9]="OneMinusDstColor",e[e.SrcAlphaSaturate=10]="SrcAlphaSaturate"})(t.BlendingSrcFactor||(t.BlendingSrcFactor={})),(e=>{e[e.Add=-1]="Add",e[e.Subtract=1]="Subtract",e[e.ReverseSubtract=2]="ReverseSubtract"})(t.BlendingEquations||(t.BlendingEquations={})),(e=>{e[e.NEVER=-1]="NEVER",e[e.LESS=1]="LESS",e[e.EQUAL=2]="EQUAL",e[e.LESS_OR_EQUAL=3]="LESS_OR_EQUAL",e[e.GREATER=4]="GREATER",e[e.NOTEQUAL=5]="NOTEQUAL",e[e.GREATER_OR_EQUAL=6]="GREATER_OR_EQUAL",e[e.ALWAYS=7]="ALWAYS"})(t.DepthFunctions||(t.DepthFunctions={})),(e=>{e[e.NONE=-1]="NONE",e[e.CW=1]="CW",e[e.CCW=2]="CCW",e[e.BOTH=3]="BOTH"})(t.CullSide||(t.CullSide={}))})(n.Material||(n.Material={})),(t=>{(e=>{e[e.LINE_LOOP=0]="LINE_LOOP",e[e.LINE_STRIP=1]="LINE_STRIP",e[e.LINES=2]="LINES",e[e.POINTS=3]="POINTS",e[e.TRIANGLE_FAN=4]="TRIANGLE_FAN",e[e.TRIANGLE_STRIP=5]="TRIANGLE_STRIP",e[e.TRIANGLES=6]="TRIANGLES"})(t.DrawMode||(t.DrawMode={}))})(n.Model||(n.Model={})),(t=>{(e=>{e[e.TEXTURE_2D=0]="TEXTURE_2D",e[e.CUBE_MAP=1]="CUBE_MAP"})(t.TextureBindingTarget||(t.TextureBindingTarget={})),(e=>{e[e.REPEAT=-1]="REPEAT",e[e.CLAMP_TO_EDGE=1]="CLAMP_TO_EDGE",e[e.MIRRORED_REPEAT=2]="MIRRORED_REPEAT"})(t.Wrapping||(t.Wrapping={})),(e=>{e[e.Nearest=-1]="Nearest",e[e.NearestMipMapNearest=1]="NearestMipMapNearest",e[e.NearestMipMapLinear=2]="NearestMipMapLinear",e[e.Linear=3]="Linear",e[e.LinearMipMapNearest=4]="LinearMipMapNearest",e[e.LinearMipMapLinear=5]="LinearMipMapLinear"})(t.TextureMinFilter||(t.TextureMinFilter={})),(e=>{e[e.Nearest=-1]="Nearest",e[e.Linear=1]="Linear"})(t.TextureMagFilter||(t.TextureMagFilter={})),(e=>{e[e.UnsignedByte=-1]="UnsignedByte",e[e.UnsignedShort_5_6_5=1]="UnsignedShort_5_6_5",e[e.UnsignedShort_4_4_4_4=2]="UnsignedShort_4_4_4_4",e[e.UnsignedShort_5_5_5_1=3]="UnsignedShort_5_5_5_1",e[e.UnsignedShort=4]="UnsignedShort",e[e.UnsignedInt=5]="UnsignedInt",e[e.UnsignedInt_24_8=6]="UnsignedInt_24_8",e[e.Byte=7]="Byte",e[e.Short=8]="Short",e[e.Int=9]="Int",e[e.Float=10]="Float",e[e.HalfFloat=11]="HalfFloat",e[e.UnsignedInt_2_10_10_10_REV=12]="UnsignedInt_2_10_10_10_REV",e[e.UnsignedInt_10F_11F_11F_REV=13]="UnsignedInt_10F_11F_11F_REV",e[e.UnsignedInt_5_9_9_9_REV=14]="UnsignedInt_5_9_9_9_REV",e[e.Float32UnsignedInt_24_8_REV=15]="Float32UnsignedInt_24_8_REV"})(t.SourcePixelFormat||(t.SourcePixelFormat={})),(e=>{e[e.Alpha=-1]="Alpha",e[e.DepthComponent=1]="DepthComponent",e[e.DepthStencil=2]="DepthStencil",e[e.Luminance=3]="Luminance",e[e.LuminanceAlpha=4]="LuminanceAlpha",e[e.RGB=5]="RGB",e[e.RGBA=6]="RGBA",e[e.RGBE=7]="RGBE",e[e.R8=8]="R8",e[e.R16F=9]="R16F",e[e.R32F=10]="R32F",e[e.R8UI=11]="R8UI",e[e.RG8=12]="RG8",e[e.RG16F=13]="RG16F",e[e.RG32F=14]="RG32F",e[e.RG8UI=15]="RG8UI",e[e.RG16UI=16]="RG16UI",e[e.RG32UI=17]="RG32UI",e[e.RGB8=18]="RGB8",e[e.SRGB8=19]="SRGB8",e[e.RGB565=20]="RGB565",e[e.R11F_G11F_B10F=21]="R11F_G11F_B10F",e[e.RGB9_E5=22]="RGB9_E5",e[e.RGB16F=23]="RGB16F",e[e.RGB32F=24]="RGB32F",e[e.RGB8UI=25]="RGB8UI",e[e.RGBA8=26]="RGBA8",e[e.SRGB8_ALPHA8=27]="SRGB8_ALPHA8",e[e.RGB5_A1=28]="RGB5_A1",e[e.RGB10_A2=29]="RGB10_A2",e[e.RGBA4=30]="RGBA4",e[e.RGBA16F=31]="RGBA16F",e[e.RGBA32F=32]="RGBA32F",e[e.RGBA8UI=33]="RGBA8UI",e[e.DEPTH_COMPONENT16=34]="DEPTH_COMPONENT16",e[e.DEPTH_COMPONENT24=35]="DEPTH_COMPONENT24",e[e.DEPTH_COMPONENT32F=36]="DEPTH_COMPONENT32F",e[e.RGBA32UI=37]="RGBA32UI",e[e.RGB32UI=38]="RGB32UI",e[e.RGBA16UI=39]="RGBA16UI",e[e.RGB16UI=40]="RGB16UI",e[e.RGBA32I=41]="RGBA32I",e[e.RGB32I=42]="RGB32I",e[e.RGBA16I=43]="RGBA16I",e[e.RGB16I=44]="RGB16I",e[e.RGBA8I=45]="RGBA8I",e[e.RGB8I=46]="RGB8I",e[e.RED_INTEGER=47]="RED_INTEGER",e[e.RG_INTEGER=48]="RG_INTEGER",e[e.RGB_INTEGER=49]="RGB_INTEGER",e[e.RGBA_INTEGER=50]="RGBA_INTEGER"})(t.TexelDataType||(t.TexelDataType={})),(e=>{e[e.ONE=1]="ONE",e[e.TWO=2]="TWO",e[e.FOUR=4]="FOUR",e[e.EIGHT=8]="EIGHT"})(t.PackAlignment||(t.PackAlignment={})),(e=>{e[e.ONE=1]="ONE",e[e.TWO=2]="TWO",e[e.FOUR=4]="FOUR",e[e.EIGHT=8]="EIGHT"})(t.UnpackAlignment||(t.UnpackAlignment={}))})(n.Texture||(n.Texture={})),(t=>{(e=>{e[e.ALPHA=0]="ALPHA",e[e.RGB=1]="RGB",e[e.RGBA=2]="RGBA"})(t.ReadFilter||(t.ReadFilter={})),(e=>{e[e.UNSIGNED_BYTE=0]="UNSIGNED_BYTE",e[e.UNSIGNED_SHORT_5_6_5=1]="UNSIGNED_SHORT_5_6_5",e[e.UNSIGNED_SHORT_4_4_4_4=2]="UNSIGNED_SHORT_4_4_4_4",e[e.UNSIGNED_SHORT_5_5_5_1=3]="UNSIGNED_SHORT_5_5_5_1",e[e.FLOAT=4]="FLOAT"})(t.ReadTargetArrayFormat||(t.ReadTargetArrayFormat={}))})(n.Renderer||(n.Renderer={}))})(h.GLSettings||(h.GLSettings={}));function vp(n,t){const e={attributeCount:0,attributes:[],uniformCount:0,uniforms:[]},i=n.getProgramParameter(t,n.ACTIVE_UNIFORMS),r=n.getProgramParameter(t,n.ACTIVE_ATTRIBUTES),s={35664:"FLOAT_VEC2",35665:"FLOAT_VEC3",35666:"FLOAT_VEC4",35667:"INT_VEC2",35668:"INT_VEC3",35669:"INT_VEC4",35670:"BOOL",35671:"BOOL_VEC2",35672:"BOOL_VEC3",35673:"BOOL_VEC4",35674:"FLOAT_MAT2",35675:"FLOAT_MAT3",35676:"FLOAT_MAT4",35678:"SAMPLER_2D",35680:"SAMPLER_CUBE",5120:"BYTE",5121:"UNSIGNED_BYTE",5122:"SHORT",5123:"UNSIGNED_SHORT",5124:"INT",5125:"UNSIGNED_INT",5126:"FLOAT"},a={35664:1,35665:1,35666:1,35667:1,35668:1,35669:1,35670:1,35671:1,35672:1,35673:1,35674:1,35675:3,35676:4,35678:1,35680:1,5120:1,5121:1,5122:1,5123:1,5124:1,5125:1,5126:1};for(let o=0;o<i;++o){const c=n.getActiveUniform(t,o);c.typeName=s[c.type],e.uniforms.push(c),e.uniformCount+=c.size,c.size=c.size*a[c.type]}for(let o=0;o<r;o++){const c=n.getActiveAttrib(t,o);c.typeName=s[c.type],e.attributes.push(c),e.attributeCount+=c.size}return e}const gl=class{static print(){return Object.assign({},gl)}};let N=gl;f(N,"VAO",!1),f(N,"DEPTH_TEXTURE",!1),f(N,"MAX_VERTEX_UNIFORMS",0),f(N,"MAX_FRAGMENT_UNIFORMS",0),f(N,"MAX_VERTEX_ATTRIBUTES",0),f(N,"WEBGL_SUPPORTED",!1),f(N,"MAX_TEXTURE_SIZE",0),f(N,"HARDWARE_INSTANCING",!1),f(N,"MRT_EXTENSION",!1),f(N,"MRT",!1),f(N,"MAX_COLOR_ATTACHMENTS",0),f(N,"SHADERS_3_0",!1),f(N,"WEBGL_VERSION","none"),f(N,"FLOAT_TEXTURE_READ",{half:!1,full:!1,halfLinearFilter:!1,fullLinearFilter:!1}),f(N,"FLOAT_TEXTURE_WRITE",{half:!1,full:!1});function bp(){function n(){try{const i=document.createElement("canvas");let r;return r=i.getContext("webgl2"),r?(N.WEBGL_VERSION="webgl2",r):(r=i.getContext("webgl"),r?(N.WEBGL_VERSION="webgl",r):(r=i.getContext("experimental-webgl"),r?(N.WEBGL_VERSION="experimental-webgl",r):null))}catch{return null}}function t(i){N.FLOAT_TEXTURE_READ.fullLinearFilter=!!i.getExtension("OES_texture_float_linear"),N.FLOAT_TEXTURE_READ.halfLinearFilter=!!i.getExtension("OES_texture_half_float_linear");const r=i.createTexture();if(i.bindTexture(i.TEXTURE_2D,r),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),i.getError()!==i.NO_ERROR)throw new Error("WebGLStat could not create a texture");const s=i.getExtension("OES_texture_float")||i.getExtension("EXT_color_buffer_float");if(i.getExtension("WEBGL_color_buffer_float"),s){i.texImage2D(i.TEXTURE_2D,0,i instanceof WebGL2RenderingContext?i.RGBA32F:i.RGBA,2,2,0,i.RGBA,i.FLOAT,null),i.getError()===i.NO_ERROR&&(N.FLOAT_TEXTURE_READ.full=!0);const u=i.createFramebuffer();i.bindFramebuffer(i.FRAMEBUFFER,u),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,r,0),i.bindTexture(i.TEXTURE_2D,null),i.checkFramebufferStatus(i.FRAMEBUFFER)===i.FRAMEBUFFER_COMPLETE&&(N.FLOAT_TEXTURE_WRITE.full=!0),i.deleteFramebuffer(u),i.deleteTexture(r)}const a=i.createTexture();if(i.bindTexture(i.TEXTURE_2D,a),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),i.getError()!==i.NO_ERROR)throw new Error("WebGLStat could not create a texture");const o=i.getExtension("OES_texture_half_float")||i.getExtension("EXT_color_buffer_float");if(o){i.texImage2D(i.TEXTURE_2D,0,i instanceof WebGL2RenderingContext?i.RGBA16F:i.RGBA,2,2,0,i.RGBA,i instanceof WebGL2RenderingContext?i.HALF_FLOAT:o.HALF_FLOAT_OES,null),i.getError()===i.NO_ERROR&&(N.FLOAT_TEXTURE_READ.full=!0);const u=i.createFramebuffer();i.bindFramebuffer(i.FRAMEBUFFER,u),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,a,0),i.bindTexture(i.TEXTURE_2D,null),i.checkFramebufferStatus(i.FRAMEBUFFER)===i.FRAMEBUFFER_COMPLETE&&(N.FLOAT_TEXTURE_WRITE.full=!0),i.deleteFramebuffer(u),i.deleteTexture(a)}}const e=n();if(e)if(N.WEBGL_SUPPORTED=!0,N.MAX_VERTEX_UNIFORMS=e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),N.MAX_FRAGMENT_UNIFORMS=e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),N.MAX_VERTEX_ATTRIBUTES=e.getParameter(e.MAX_VERTEX_ATTRIBS),N.MAX_TEXTURE_SIZE=e.getParameter(e.MAX_TEXTURE_SIZE),t(e),e instanceof WebGL2RenderingContext)N.VAO=!0,N.MRT=!0,N.HARDWARE_INSTANCING=!0,N.SHADERS_3_0=!0,N.HARDWARE_INSTANCING=!0,N.DEPTH_TEXTURE=!0,N.MAX_COLOR_ATTACHMENTS=e.getParameter(e.MAX_COLOR_ATTACHMENTS);else{N.VAO=!!e.getExtension("OES_vertex_array_object"),N.HARDWARE_INSTANCING=!!e.getExtension("ANGLE_instanced_arrays");const i=e.getExtension("WEBGL_draw_buffers");N.MRT_EXTENSION=!!i,N.MRT=!!i,N.DEPTH_TEXTURE=!!e.getExtension("WEBGL_depth_texture"),i&&(N.MAX_COLOR_ATTACHMENTS=e.getParameter(i.MAX_COLOR_ATTACHMENTS_WEBGL))}window.WebGLStat=N}bp();function pi(n,t){switch(t){case h.GLSettings.Model.DrawMode.LINES:return n.LINES;case h.GLSettings.Model.DrawMode.LINE_LOOP:return n.LINE_LOOP;case h.GLSettings.Model.DrawMode.LINE_STRIP:return n.LINE_STRIP;case h.GLSettings.Model.DrawMode.POINTS:return n.POINTS;case h.GLSettings.Model.DrawMode.TRIANGLES:return n.TRIANGLES;case h.GLSettings.Model.DrawMode.TRIANGLE_FAN:return n.TRIANGLE_FAN;case h.GLSettings.Model.DrawMode.TRIANGLE_STRIP:return n.TRIANGLE_STRIP;default:return n.TRIANGLES}}function gi(n,t){switch(t){case h.GLSettings.Texture.TexelDataType.Alpha:return n.ALPHA;case h.GLSettings.Texture.TexelDataType.DepthComponent:return n.DEPTH_COMPONENT;case h.GLSettings.Texture.TexelDataType.DepthStencil:return n.DEPTH_STENCIL;case h.GLSettings.Texture.TexelDataType.Luminance:return n.LUMINANCE;case h.GLSettings.Texture.TexelDataType.LuminanceAlpha:return n.LUMINANCE_ALPHA;case h.GLSettings.Texture.TexelDataType.RGB:return n.RGB;case h.GLSettings.Texture.TexelDataType.RGBA:return n.RGBA;default:if(n instanceof WebGL2RenderingContext)switch(t){case h.GLSettings.Texture.TexelDataType.R8:return n.R8;case h.GLSettings.Texture.TexelDataType.R16F:return n.R16F;case h.GLSettings.Texture.TexelDataType.R32F:return n.R32F;case h.GLSettings.Texture.TexelDataType.R8UI:return n.R8UI;case h.GLSettings.Texture.TexelDataType.RG8:return n.RG8;case h.GLSettings.Texture.TexelDataType.RG16F:return n.RG16F;case h.GLSettings.Texture.TexelDataType.RG32F:return n.RG32F;case h.GLSettings.Texture.TexelDataType.RG8UI:return n.RG8UI;case h.GLSettings.Texture.TexelDataType.RG16UI:return n.RG16UI;case h.GLSettings.Texture.TexelDataType.RG32UI:return n.RG32UI;case h.GLSettings.Texture.TexelDataType.RGB8:return n.RGB8;case h.GLSettings.Texture.TexelDataType.SRGB8:return n.SRGB8;case h.GLSettings.Texture.TexelDataType.RGB565:return n.RGB565;case h.GLSettings.Texture.TexelDataType.R11F_G11F_B10F:return n.R11F_G11F_B10F;case h.GLSettings.Texture.TexelDataType.RGB9_E5:return n.RGB9_E5;case h.GLSettings.Texture.TexelDataType.RGB16F:return n.RGB16F;case h.GLSettings.Texture.TexelDataType.RGB32F:return n.RGB32F;case h.GLSettings.Texture.TexelDataType.RGB8UI:return n.RGB8UI;case h.GLSettings.Texture.TexelDataType.RGBA8:return n.RGBA8;case h.GLSettings.Texture.TexelDataType.SRGB8_ALPHA8:return n.SRGB8_ALPHA8;case h.GLSettings.Texture.TexelDataType.RGB5_A1:return n.RGB5_A1;case h.GLSettings.Texture.TexelDataType.RGB10_A2:return n.RGB10_A2;case h.GLSettings.Texture.TexelDataType.RGBA4:return n.RGBA4;case h.GLSettings.Texture.TexelDataType.RGBA16F:return n.RGBA16F;case h.GLSettings.Texture.TexelDataType.RGBA32F:return N.FLOAT_TEXTURE_READ.full&&N.FLOAT_TEXTURE_WRITE.full?n.RGBA32F:n.RGBA16F;case h.GLSettings.Texture.TexelDataType.RGBA8UI:return n.RGBA8UI;case h.GLSettings.Texture.TexelDataType.DEPTH_COMPONENT16:return n.DEPTH_COMPONENT16;case h.GLSettings.Texture.TexelDataType.DEPTH_COMPONENT24:return n.DEPTH_COMPONENT24;case h.GLSettings.Texture.TexelDataType.DEPTH_COMPONENT32F:return n.DEPTH_COMPONENT32F;case h.GLSettings.Texture.TexelDataType.RGBA32UI:return n.RGBA32UI;case h.GLSettings.Texture.TexelDataType.RGB32UI:return n.RGB32UI;case h.GLSettings.Texture.TexelDataType.RGBA16UI:return n.RGBA16UI;case h.GLSettings.Texture.TexelDataType.RGB16UI:return n.RGB16UI;case h.GLSettings.Texture.TexelDataType.RGBA32I:return n.RGBA32I;case h.GLSettings.Texture.TexelDataType.RGB32I:return n.RGB32I;case h.GLSettings.Texture.TexelDataType.RGBA16I:return n.RGBA16I;case h.GLSettings.Texture.TexelDataType.RGB16I:return n.RGB16I;case h.GLSettings.Texture.TexelDataType.RGBA8I:return n.RGBA8I;case h.GLSettings.Texture.TexelDataType.RGB8I:return n.RGB8I;default:return console.warn("An unsupported texel format was provided that is not supported in WebGL 1 or 2"),n.RGBA}return console.warn("An Unsupported texel format was provided. Some formats are only available in WebGL 2",t),n.RGBA}}function xr(n,t){switch(t){case h.GLSettings.Texture.SourcePixelFormat.Byte:return n.BYTE;case h.GLSettings.Texture.SourcePixelFormat.Float:return n.FLOAT;case h.GLSettings.Texture.SourcePixelFormat.HalfFloat:return console.warn("Unsupported HALF_FLOAT"),n.BYTE;case h.GLSettings.Texture.SourcePixelFormat.Int:return n.INT;case h.GLSettings.Texture.SourcePixelFormat.Short:return n.SHORT;case h.GLSettings.Texture.SourcePixelFormat.UnsignedByte:return n.UNSIGNED_BYTE;case h.GLSettings.Texture.SourcePixelFormat.UnsignedInt:return n.UNSIGNED_INT;case h.GLSettings.Texture.SourcePixelFormat.UnsignedShort:return n.UNSIGNED_SHORT;case h.GLSettings.Texture.SourcePixelFormat.UnsignedShort_4_4_4_4:return n.UNSIGNED_SHORT_4_4_4_4;case h.GLSettings.Texture.SourcePixelFormat.UnsignedShort_5_5_5_1:return n.UNSIGNED_SHORT_5_5_5_1;case h.GLSettings.Texture.SourcePixelFormat.UnsignedShort_5_6_5:return n.UNSIGNED_SHORT_5_6_5;default:return console.warn("An Unsupported input image format was provided",t),n.BYTE}}function mi(n,t){switch(t){case h.GLSettings.Texture.TextureMagFilter.Linear:return n.LINEAR;case h.GLSettings.Texture.TextureMagFilter.Nearest:return n.NEAREST}}function In(n,t,e){switch(t){case h.GLSettings.Texture.TextureMinFilter.Linear:return n.LINEAR;case h.GLSettings.Texture.TextureMinFilter.Nearest:return n.NEAREST;case h.GLSettings.Texture.TextureMinFilter.LinearMipMapLinear:return e?n.LINEAR_MIPMAP_LINEAR:n.LINEAR;case h.GLSettings.Texture.TextureMinFilter.LinearMipMapNearest:return e?n.LINEAR_MIPMAP_NEAREST:n.LINEAR;case h.GLSettings.Texture.TextureMinFilter.NearestMipMapLinear:return e?n.NEAREST_MIPMAP_LINEAR:n.NEAREST;case h.GLSettings.Texture.TextureMinFilter.NearestMipMapNearest:return e?n.NEAREST_MIPMAP_NEAREST:n.NEAREST;default:return n.LINEAR}}function Zl(n,t){switch(t){case h.GLSettings.RenderTarget.ColorBufferFormat.RGB565:return n.RGB565;case h.GLSettings.RenderTarget.ColorBufferFormat.RGB5_A1:return n.RGB5_A1;case h.GLSettings.RenderTarget.ColorBufferFormat.RGBA4:return n.RGBA4;default:if(n instanceof WebGL2RenderingContext)switch(t){case h.GLSettings.RenderTarget.ColorBufferFormat.R8:return n.R8;case h.GLSettings.RenderTarget.ColorBufferFormat.R8UI:return n.R8UI;case h.GLSettings.RenderTarget.ColorBufferFormat.R8I:return n.R8I;case h.GLSettings.RenderTarget.ColorBufferFormat.R16UI:return n.R16UI;case h.GLSettings.RenderTarget.ColorBufferFormat.R16I:return n.R16I;case h.GLSettings.RenderTarget.ColorBufferFormat.R32UI:return n.R32UI;case h.GLSettings.RenderTarget.ColorBufferFormat.R32I:return n.R32I;case h.GLSettings.RenderTarget.ColorBufferFormat.RG8:return n.RG8;case h.GLSettings.RenderTarget.ColorBufferFormat.RG8UI:return n.RG8UI;case h.GLSettings.RenderTarget.ColorBufferFormat.RG8I:return n.RG8I;case h.GLSettings.RenderTarget.ColorBufferFormat.RG16UI:return n.RG16UI;case h.GLSettings.RenderTarget.ColorBufferFormat.RG16I:return n.RG16I;case h.GLSettings.RenderTarget.ColorBufferFormat.RG32UI:return n.RG32UI;case h.GLSettings.RenderTarget.ColorBufferFormat.RG32I:return n.RG32I;case h.GLSettings.RenderTarget.ColorBufferFormat.RGB8:return n.RGB8;case h.GLSettings.RenderTarget.ColorBufferFormat.RGBA8:return n.RGBA8;case h.GLSettings.RenderTarget.ColorBufferFormat.SRGB8_ALPHA8:return n.SRGB8_ALPHA8;case h.GLSettings.RenderTarget.ColorBufferFormat.RGB10_A2:return n.RGB10_A2;case h.GLSettings.RenderTarget.ColorBufferFormat.RGBA8UI:return n.RGBA8UI;case h.GLSettings.RenderTarget.ColorBufferFormat.RGBA8I:return n.RGBA8I;case h.GLSettings.RenderTarget.ColorBufferFormat.RGB10_A2UI:return n.RGB10_A2UI;case h.GLSettings.RenderTarget.ColorBufferFormat.RGBA16UI:return n.RGBA16UI;case h.GLSettings.RenderTarget.ColorBufferFormat.RGBA16I:return n.RGBA16I;case h.GLSettings.RenderTarget.ColorBufferFormat.RGBA32I:return n.RGBA32I;case h.GLSettings.RenderTarget.ColorBufferFormat.RGBA32UI:return n.RGBA32UI}return n.RGBA4}}function Jl(n,t){switch(t){case h.GLSettings.RenderTarget.DepthBufferFormat.DEPTH_COMPONENT16:return n.DEPTH_COMPONENT16;case h.GLSettings.RenderTarget.DepthBufferFormat.DEPTH_STENCIL:return n.DEPTH_STENCIL;default:if(n instanceof WebGL2RenderingContext)switch(t){case h.GLSettings.RenderTarget.DepthBufferFormat.DEPTH_COMPONENT24:return n.DEPTH_COMPONENT24;case h.GLSettings.RenderTarget.DepthBufferFormat.DEPTH_COMPONENT32F:return n.DEPTH_COMPONENT32F;case h.GLSettings.RenderTarget.DepthBufferFormat.DEPTH24_STENCIL8:return n.DEPTH24_STENCIL8;case h.GLSettings.RenderTarget.DepthBufferFormat.DEPTH32F_STENCIL8:return n.DEPTH32F_STENCIL8}return n.DEPTH_COMPONENT16}}function eu(n,t){switch(t){case h.GLSettings.RenderTarget.StencilBufferFormat.STENCIL_INDEX8:return n.STENCIL_INDEX8;default:return n.STENCIL_INDEX8}}function Vo(n,t){switch(t){case h.GLSettings.Texture.Wrapping.CLAMP_TO_EDGE:return n.CLAMP_TO_EDGE;case h.GLSettings.Texture.Wrapping.MIRRORED_REPEAT:return n.MIRRORED_REPEAT;case h.GLSettings.Texture.Wrapping.REPEAT:return n.REPEAT}}function Rr(n,t,e,i,r){if(i)return n.COLOR_ATTACHMENT0;const s=t.drawBuffers;if(r){if(s instanceof WebGL2RenderingContext)switch(e){case-2:return n.BACK;case-1:return n.NONE;case 0:return s.DRAW_BUFFER0;case 1:return s.DRAW_BUFFER1;case 2:return s.DRAW_BUFFER2;case 3:return s.DRAW_BUFFER3;case 4:return s.DRAW_BUFFER4;case 5:return s.DRAW_BUFFER5;case 6:return s.DRAW_BUFFER6;case 7:return s.DRAW_BUFFER7;case 8:return s.DRAW_BUFFER8;case 9:return s.DRAW_BUFFER9;case 10:return s.DRAW_BUFFER10;case 11:return s.DRAW_BUFFER11;case 12:return s.DRAW_BUFFER12;case 13:return s.DRAW_BUFFER13;case 14:return s.DRAW_BUFFER14;case 15:return s.DRAW_BUFFER15;default:console.warn("Attachments are only available for -2 - 15")}else if(s)switch(e){case-2:return n.BACK;case-1:return n.NONE;case 0:return s.DRAW_BUFFER0_WEBGL;case 1:return s.DRAW_BUFFER1_WEBGL;case 2:return s.DRAW_BUFFER2_WEBGL;case 3:return s.DRAW_BUFFER3_WEBGL;case 4:return s.DRAW_BUFFER4_WEBGL;case 5:return s.DRAW_BUFFER5_WEBGL;case 6:return s.DRAW_BUFFER6_WEBGL;case 7:return s.DRAW_BUFFER7_WEBGL;case 8:return s.DRAW_BUFFER8_WEBGL;case 9:return s.DRAW_BUFFER9_WEBGL;case 10:return s.DRAW_BUFFER10_WEBGL;case 11:return s.DRAW_BUFFER11_WEBGL;case 12:return s.DRAW_BUFFER12_WEBGL;case 13:return s.DRAW_BUFFER13_WEBGL;case 14:return s.DRAW_BUFFER14_WEBGL;case 15:return s.DRAW_BUFFER15_WEBGL;default:console.warn("Attachments are only available for 0 - 15")}}else if(s instanceof WebGL2RenderingContext)switch(e){case-2:return n.BACK;case-1:return n.NONE;case 0:return s.COLOR_ATTACHMENT0;case 1:return s.COLOR_ATTACHMENT1;case 2:return s.COLOR_ATTACHMENT2;case 3:return s.COLOR_ATTACHMENT3;case 4:return s.COLOR_ATTACHMENT4;case 5:return s.COLOR_ATTACHMENT5;case 6:return s.COLOR_ATTACHMENT6;case 7:return s.COLOR_ATTACHMENT7;case 8:return s.COLOR_ATTACHMENT8;case 9:return s.COLOR_ATTACHMENT9;case 10:return s.COLOR_ATTACHMENT10;case 11:return s.COLOR_ATTACHMENT11;case 12:return s.COLOR_ATTACHMENT12;case 13:return s.COLOR_ATTACHMENT13;case 14:return s.COLOR_ATTACHMENT14;case 15:return s.COLOR_ATTACHMENT15;default:console.warn("Attachments are only available for -2 - 15")}else if(s)switch(e){case-2:return n.BACK;case-1:return n.NONE;case 0:return s.COLOR_ATTACHMENT0_WEBGL;case 1:return s.COLOR_ATTACHMENT1_WEBGL;case 2:return s.COLOR_ATTACHMENT2_WEBGL;case 3:return s.COLOR_ATTACHMENT3_WEBGL;case 4:return s.COLOR_ATTACHMENT4_WEBGL;case 5:return s.COLOR_ATTACHMENT5_WEBGL;case 6:return s.COLOR_ATTACHMENT6_WEBGL;case 7:return s.COLOR_ATTACHMENT7_WEBGL;case 8:return s.COLOR_ATTACHMENT8_WEBGL;case 9:return s.COLOR_ATTACHMENT9_WEBGL;case 10:return s.COLOR_ATTACHMENT10_WEBGL;case 11:return s.COLOR_ATTACHMENT11_WEBGL;case 12:return s.COLOR_ATTACHMENT12_WEBGL;case 13:return s.COLOR_ATTACHMENT13_WEBGL;case 14:return s.COLOR_ATTACHMENT14_WEBGL;case 15:return s.COLOR_ATTACHMENT15_WEBGL;default:console.warn("Attachments are only available for 0 - 15")}return n.COLOR_ATTACHMENT0}function tu(n,t){return n.TEXTURE0+t}function $o(n,t){return t-n.TEXTURE0}function wp(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var Wo={exports:{}},jo={exports:{}},Ar=1e3,Ir=Ar*60,Sr=Ir*60,Mr=Sr*24,Tp=Mr*365.25,yp=function(n,t){t=t||{};var e=typeof n;if(e==="string"&&n.length>0)return Ep(n);if(e==="number"&&isNaN(n)===!1)return t.long?xp(n):_p(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))};function Ep(n){if(n=String(n),!(n.length>100)){var t=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(n);if(t){var e=parseFloat(t[1]),i=(t[2]||"ms").toLowerCase();switch(i){case"years":case"year":case"yrs":case"yr":case"y":return e*Tp;case"days":case"day":case"d":return e*Mr;case"hours":case"hour":case"hrs":case"hr":case"h":return e*Sr;case"minutes":case"minute":case"mins":case"min":case"m":return e*Ir;case"seconds":case"second":case"secs":case"sec":case"s":return e*Ar;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return e;default:return}}}}function _p(n){return n>=Mr?Math.round(n/Mr)+"d":n>=Sr?Math.round(n/Sr)+"h":n>=Ir?Math.round(n/Ir)+"m":n>=Ar?Math.round(n/Ar)+"s":n+"ms"}function xp(n){return Fs(n,Mr,"day")||Fs(n,Sr,"hour")||Fs(n,Ir,"minute")||Fs(n,Ar,"second")||n+" ms"}function Fs(n,t,e){if(!(n<t))return n<t*1.5?Math.floor(n/t)+" "+e:Math.ceil(n/t)+" "+e+"s"}(function(n,t){t=n.exports=i.debug=i.default=i,t.coerce=c,t.disable=a,t.enable=s,t.enabled=o,t.humanize=yp,t.instances=[],t.names=[],t.skips=[],t.formatters={};function e(l){var u=0,d;for(d in l)u=(u<<5)-u+l.charCodeAt(d),u|=0;return t.colors[Math.abs(u)%t.colors.length]}function i(l){var u;function d(){if(d.enabled){var p=d,g=+new Date,m=g-(u||g);p.diff=m,p.prev=u,p.curr=g,u=g;for(var v=new Array(arguments.length),b=0;b<v.length;b++)v[b]=arguments[b];v[0]=t.coerce(v[0]),typeof v[0]!="string"&&v.unshift("%O");var T=0;v[0]=v[0].replace(/%([a-zA-Z%])/g,function(E,x){if(E==="%%")return E;T++;var _=t.formatters[x];if(typeof _=="function"){var I=v[T];E=_.call(p,I),v.splice(T,1),T--}return E}),t.formatArgs.call(p,v);var w=d.log||t.log||console.log.bind(console);w.apply(p,v)}}return d.namespace=l,d.enabled=t.enabled(l),d.useColors=t.useColors(),d.color=e(l),d.destroy=r,typeof t.init=="function"&&t.init(d),t.instances.push(d),d}function r(){var l=t.instances.indexOf(this);return l!==-1?(t.instances.splice(l,1),!0):!1}function s(l){t.save(l),t.names=[],t.skips=[];var u,d=(typeof l=="string"?l:"").split(/[\s,]+/),p=d.length;for(u=0;u<p;u++)d[u]&&(l=d[u].replace(/\*/g,".*?"),l[0]==="-"?t.skips.push(new RegExp("^"+l.substr(1)+"$")):t.names.push(new RegExp("^"+l+"$")));for(u=0;u<t.instances.length;u++){var g=t.instances[u];g.enabled=t.enabled(g.namespace)}}function a(){t.enable("")}function o(l){if(l[l.length-1]==="*")return!0;var u,d;for(u=0,d=t.skips.length;u<d;u++)if(t.skips[u].test(l))return!1;for(u=0,d=t.names.length;u<d;u++)if(t.names[u].test(l))return!0;return!1}function c(l){return l instanceof Error?l.stack||l.message:l}})(jo,jo.exports);var Rp=jo.exports;(function(n,t){t=n.exports=Rp,t.log=r,t.formatArgs=i,t.save=s,t.load=a,t.useColors=e,t.storage=typeof chrome<"u"&&typeof chrome.storage<"u"?chrome.storage.local:o(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function e(){return typeof window<"u"&&window.process&&window.process.type==="renderer"?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}t.formatters.j=function(c){try{return JSON.stringify(c)}catch(l){return"[UnexpectedJSONParseError]: "+l.message}};function i(c){var l=this.useColors;if(c[0]=(l?"%c":"")+this.namespace+(l?" %c":" ")+c[0]+(l?"%c ":" ")+"+"+t.humanize(this.diff),!!l){var u="color: "+this.color;c.splice(1,0,u,"color: inherit");var d=0,p=0;c[0].replace(/%[a-zA-Z%]/g,function(g){g!=="%%"&&(d++,g==="%c"&&(p=d))}),c.splice(p,0,u)}}function r(){return typeof console=="object"&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function s(c){try{c==null?t.storage.removeItem("debug"):t.storage.debug=c}catch{}}function a(){var c;try{c=t.storage.debug}catch{}return!c&&typeof process<"u"&&"env"in process&&(c=process.env.DEBUG),c}t.enable(a());function o(){try{return window.localStorage}catch{}}})(Wo,Wo.exports);var Ap=Wo.exports;const Ie=wp(Ap);class nu{constructor(t){f(this,"_destroyed",!1);f(this,"gl");f(this,"_internalFormat",h.GLSettings.RenderTarget.ColorBufferFormat.RGBA4);f(this,"needsSettingsUpdate",!1);f(this,"_size",[0,0]);this.size=t.size||this.size,this.internalFormat=t.internalFormat??this.internalFormat}get destroyed(){return this._destroyed}get internalFormat(){return this._internalFormat}set internalFormat(t){this.needsSettingsUpdate=!0,this._internalFormat=t}get size(){return this._size}set size(t){this.needsSettingsUpdate=!0,this._size=t}destroy(){this.gl&&this.gl.proxy.disposeColorBuffer(this),this._destroyed=!0}}var Ho=(n=>(n[n.INVALID=0]="INVALID",n[n.ONE=1]="ONE",n[n.TWO=2]="TWO",n[n.THREE=3]="THREE",n[n.FOUR=4]="FOUR",n))(Ho||{}),P=(n=>(n[n.ONE=1]="ONE",n[n.TWO=2]="TWO",n[n.THREE=3]="THREE",n[n.FOUR=4]="FOUR",n[n.MAT4X4=16]="MAT4X4",n[n.ATLAS=99]="ATLAS",n))(P||{});const iu={[1]:1,[2]:2,[3]:3,[4]:4,[16]:16,[99]:4};var R=(n=>(n[n.ONE=1]="ONE",n[n.TWO=2]="TWO",n[n.THREE=3]="THREE",n[n.FOUR=4]="FOUR",n[n.MATRIX3=9]="MATRIX3",n[n.MATRIX4=16]="MATRIX4",n[n.FLOAT_ARRAY=97]="FLOAT_ARRAY",n[n.VEC4_ARRAY=98]="VEC4_ARRAY",n[n.TEXTURE=99]="TEXTURE",n))(R||{}),Ge=(n=>(n[n.ONE=1]="ONE",n[n.TWO=2]="TWO",n[n.THREE=3]="THREE",n[n.FOUR=4]="FOUR",n))(Ge||{}),$i=(n=>(n[n.UINT8=1]="UINT8",n[n.UINT16=2]="UINT16",n[n.UINT32=3]="UINT32",n))($i||{}),ft=(n=>(n[n.SCREEN_256TH=-256]="SCREEN_256TH",n[n.SCREEN_128TH=-128]="SCREEN_128TH",n[n.SCREEN_64TH=-64]="SCREEN_64TH",n[n.SCREEN_32ND=-32]="SCREEN_32ND",n[n.SCREEN_16TH=-16]="SCREEN_16TH",n[n.SCREEN_8TH=-8]="SCREEN_8TH",n[n.SCREEN_QUARTER=-4]="SCREEN_QUARTER",n[n.SCREEN_HALF=-2]="SCREEN_HALF",n[n.SCREEN=-1]="SCREEN",n[n._2=2]="_2",n[n._4=4]="_4",n[n._8=8]="_8",n[n._16=16]="_16",n[n._32=32]="_32",n[n._64=64]="_64",n[n._128=128]="_128",n[n._256=256]="_256",n[n._512=512]="_512",n[n._1024=1024]="_1024",n[n._2048=2048]="_2048",n[n._4096=4096]="_4096",n))(ft||{}),he=(n=>(n[n.ATLAS=0]="ATLAS",n[n.FONT=1]="FONT",n[n.TEXTURE=2]="TEXTURE",n[n.COLOR_BUFFER=3]="COLOR_BUFFER",n))(he||{}),ae=(n=>(n[n.zyx=0]="zyx",n[n.zyz=1]="zyz",n[n.zxy=2]="zxy",n[n.zxz=3]="zxz",n[n.yxz=4]="yxz",n[n.yxy=5]="yxy",n[n.yzx=6]="yzx",n[n.yzy=7]="yzy",n[n.xyz=8]="xyz",n[n.xyx=9]="xyx",n[n.xzy=10]="xzy",n[n.xzx=11]="xzx",n))(ae||{});function Ip(n){return n.size!==void 0&&n.size<=4}function Sp(n){return!!(n&&n.resource)}var S=(n=>(n[n.VERTEX=1]="VERTEX",n[n.FRAGMENT=2]="FRAGMENT",n[n.ALL=3]="ALL",n))(S||{});function ks(){}const Mp=/\s/g,Xo=/\s/,vi=Xo.test.bind(Xo),ru=/\n\r|\n|\r/g,Qo=/\n\r|\n|\r/,Cp=Qo.test.bind(Qo);function Lp(n){return n}var Y=(n=>(n[n.NONE=0]="NONE",n[n.SINGLE=1]="SINGLE",n))(Y||{}),Te=(n=>(n[n.CHANGE=0]="CHANGE",n[n.INSERT=1]="INSERT",n[n.REMOVE=2]="REMOVE",n))(Te||{}),Yo=(n=>(n[n.NO_WEBGL_CONTEXT=0]="NO_WEBGL_CONTEXT",n))(Yo||{}),ce=(n=>(n[n.UNIFORM=1]="UNIFORM",n[n.INSTANCE_ATTRIBUTE=2]="INSTANCE_ATTRIBUTE",n[n.INSTANCE_ATTRIBUTE_PACKING=3]="INSTANCE_ATTRIBUTE_PACKING",n[n.VERTEX_ATTRIBUTE=4]="VERTEX_ATTRIBUTE",n[n.VERTEX_ATTRIBUTE_PACKING=5]="VERTEX_ATTRIBUTE_PACKING",n))(ce||{}),Gs=(n=>(n[n.LINEAR=0]="LINEAR",n))(Gs||{});function Sn(n){return n!==void 0&&n.charCodeAt!==void 0}function qo(n){return n!==void 0&&n.toExponential!==void 0}function Op(n){return n!==void 0&&n.call!==void 0&&n.apply!==void 0}function Qn(n){return n===!0||n===!1}var H=(n=>(n[n.NONE=0]="NONE",n[n.BLANK=1]="BLANK",n[n.COLOR=2]="COLOR",n[n.DEPTH=3]="DEPTH",n[n.NORMAL=4]="NORMAL",n[n.PICKING=5]="PICKING",n[n.POSITION=6]="POSITION",n[n.POSITION_X=7]="POSITION_X",n[n.POSITION_Y=8]="POSITION_Y",n[n.POSITION_Z=9]="POSITION_Z",n[n.LIGHTS=10]="LIGHTS",n[n.LIGHTS2=11]="LIGHTS2",n[n.LIGHTS3=12]="LIGHTS3",n[n.ALPHA=13]="ALPHA",n[n.BETA=14]="BETA",n[n.GAMMA=15]="GAMMA",n[n.DELTA=16]="DELTA",n[n.ACCUMULATION1=17]="ACCUMULATION1",n[n.ACCUMULATION2=18]="ACCUMULATION2",n[n.ACCUMULATION3=19]="ACCUMULATION3",n[n.ACCUMULATION4=20]="ACCUMULATION4",n[n.COEFFICIENT1=21]="COEFFICIENT1",n[n.COEFFICIENT2=22]="COEFFICIENT2",n[n.COEFFICIENT3=23]="COEFFICIENT3",n[n.COEFFICIENT4=24]="COEFFICIENT4",n[n.ANGLE1=25]="ANGLE1",n[n.ANGLE2=26]="ANGLE2",n[n.ANGLE3=27]="ANGLE3",n[n.ANGLE4=28]="ANGLE4",n[n.COLOR2=29]="COLOR2",n[n.COLOR3=30]="COLOR3",n[n.COLOR4=31]="COLOR4",n[n.GLOW=32]="GLOW",n[n.BLUR=33]="BLUR",n))(H||{});let Np=1;function z(){return++Np}let Pp=0;function Dp(){return++Pp%16777215}class se{constructor(t){f(this,"_uid",z());f(this,"_destroyed",!1);f(this,"_anisotropy");f(this,"_data");f(this,"_flipY",!1);f(this,"_format",h.GLSettings.Texture.TexelDataType.RGBA);f(this,"_generateMipmaps",!1);f(this,"gl");f(this,"_internalFormat",h.GLSettings.Texture.TexelDataType.RGBA);f(this,"_magFilter",h.GLSettings.Texture.TextureMagFilter.Linear);f(this,"_minFilter",h.GLSettings.Texture.TextureMinFilter.LinearMipMapLinear);f(this,"needsDataUpload",!1);f(this,"needsPartialDataUpload",!1);f(this,"needsSettingsUpdate",!1);f(this,"_packAlignment",h.GLSettings.Texture.PackAlignment.FOUR);f(this,"_premultiplyAlpha",!1);f(this,"_type",h.GLSettings.Texture.SourcePixelFormat.UnsignedByte);f(this,"_unpackAlignment",h.GLSettings.Texture.UnpackAlignment.FOUR);f(this,"_updateRegions",[]);f(this,"_wrapHorizontal",h.GLSettings.Texture.Wrapping.CLAMP_TO_EDGE);f(this,"_wrapVertical",h.GLSettings.Texture.Wrapping.CLAMP_TO_EDGE);this.anisotropy=t.anisotropy||this.anisotropy,this.data=t.data||this.data,this.flipY=t.flipY||this.flipY,this.format=t.format||this.format,this.internalFormat=t.internalFormat||this.format,this.generateMipMaps=t.generateMipMaps||this.generateMipMaps,this.magFilter=t.magFilter||this.magFilter,this.minFilter=t.minFilter||this.minFilter,this.packAlignment=t.packAlignment||this.packAlignment,this.premultiplyAlpha=t.premultiplyAlpha||this.premultiplyAlpha,this.type=t.type||this.type,this.unpackAlignment=t.unpackAlignment||this.unpackAlignment,this.wrapHorizontal=t.wrapHorizontal||this.wrapHorizontal,this.wrapVertical=t.wrapVertical||this.wrapVertical}static get emptyTexture(){return Bp}get uid(){return this._uid}get destroyed(){return this._destroyed}get anisotropy(){return this._anisotropy}set anisotropy(t){this.needsSettingsUpdate=!0,this._anisotropy=t}get data(){return this._data}set data(t){this.needsDataUpload=!0,this._data=t}get flipY(){return this._flipY}set flipY(t){this.needsDataUpload=!0,this._flipY=t}get format(){return this._format}set format(t){this.needsDataUpload=!0,this._format=t}get generateMipMaps(){return this._generateMipmaps}set generateMipMaps(t){this.needsSettingsUpdate=!0,this._generateMipmaps=t}get internalFormat(){return this._internalFormat}set internalFormat(t){this.needsDataUpload=!0,this._internalFormat=t}get magFilter(){return this._magFilter}set magFilter(t){this.needsSettingsUpdate=!0,this._magFilter=t}get minFilter(){return this._minFilter}set minFilter(t){this.needsSettingsUpdate=!0,this._minFilter=t}get packAlignment(){return this._packAlignment}set packAlignment(t){this.needsSettingsUpdate=!0,this._packAlignment=t}get premultiplyAlpha(){return this._premultiplyAlpha}set premultiplyAlpha(t){this.needsSettingsUpdate=!0,this._premultiplyAlpha=t}get type(){return this._type}set type(t){this.needsDataUpload=!0,this._type=t}get unpackAlignment(){return this._unpackAlignment}set unpackAlignment(t){this.needsSettingsUpdate=!0,this._unpackAlignment=t}get updateRegions(){return this._updateRegions}get wrapHorizontal(){return this._wrapHorizontal}set wrapHorizontal(t){this.needsSettingsUpdate=!0,this._wrapHorizontal=t}get wrapVertical(){return this._wrapVertical}set wrapVertical(t){this.needsSettingsUpdate=!0,this._wrapVertical=t}get isHalfFloatTexture(){switch(this._internalFormat){case h.GLSettings.Texture.TexelDataType.R16F:case h.GLSettings.Texture.TexelDataType.RG16F:case h.GLSettings.Texture.TexelDataType.RGB16F:return!0}switch(this._type){case h.GLSettings.Texture.SourcePixelFormat.HalfFloat:return!0}return!1}get isFloatTexture(){switch(this._internalFormat){case h.GLSettings.Texture.TexelDataType.R11F_G11F_B10F:case h.GLSettings.Texture.TexelDataType.R16F:case h.GLSettings.Texture.TexelDataType.RG16F:case h.GLSettings.Texture.TexelDataType.R32F:case h.GLSettings.Texture.TexelDataType.RG32F:case h.GLSettings.Texture.TexelDataType.RGB16F:case h.GLSettings.Texture.TexelDataType.RGB32F:return!0}switch(this._type){case h.GLSettings.Texture.SourcePixelFormat.Float:case h.GLSettings.Texture.SourcePixelFormat.HalfFloat:return!0}return!1}destroy(){this.gl&&this.gl.proxy.disposeTexture(this),this._destroyed=!0,delete this._data}resolve(){this.needsDataUpload=!1,this.needsPartialDataUpload=!1,this.needsSettingsUpdate=!1,this._updateRegions=[]}update(t,e){this.needsPartialDataUpload=!0,this._updateRegions.push([t,e])}}const Bp=new se({data:{width:2,height:2,buffer:new Uint8Array(16)}}),Mn=Ie("performance");function su(n){return n&&n.buffer&&n.buffer.byteOffset!==void 0&&n.buffer.byteLength||n.buffer===null}function Wi(n){return(n&n-1)===0}function zs(n){return!!(n.gl&&n.gl.textureId&&n.gl.textureUnit>-1)}class Cr{constructor(t,e,i){f(this,"debugContext","");f(this,"gl");f(this,"state");f(this,"extensions");f(this,"fragmentShaders",new Map);f(this,"vertexShaders",new Map);f(this,"programs",new Map);this.gl=t,this.state=e,this.extensions=i}static addExtensions(t){const e=t.getExtension("ANGLE_instanced_arrays"),i=t.getExtension("WEBGL_draw_buffers"),r=t.getExtension("OES_texture_float"),s=t.getExtension("OES_texture_float_linear"),a=t.getExtension("OES_texture_half_float"),o=t.getExtension("OES_texture_half_float_linear"),c=t.getExtension("EXT_texture_filter_anisotropic"),l=t.getExtension("EXT_color_buffer_float"),u=t.getExtension("OES_vertex_array_object"),d={maxAnistropicFilter:0};return!e&&!(t instanceof WebGL2RenderingContext)&&Mn("This device does not have hardware instancing. All buffering strategies will be utilizing compatibility modes."),!i&&!(t instanceof WebGL2RenderingContext)&&Mn("This device does not have hardware multi-render target capabilities. The system will have to fallback to multiple render passes to multiple FBOs to achieve the same result."),c?d.maxAnistropicFilter=t.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT):Mn("This device does not have hardware anisotropic filtering for textures. This property will be ignored when setting texture settings."),!u&&!(t instanceof WebGL2RenderingContext)&&Mn("This device does not support Vertex Array Objects. This could cause performance issues for high numbers of draw calls."),{instancing:(t instanceof WebGL2RenderingContext?t:e)||void 0,drawBuffers:(t instanceof WebGL2RenderingContext?t:i)||void 0,anisotropicFiltering:c?{ext:c,stat:d}:void 0,renderFloatTexture:l||void 0,floatTex:(t instanceof WebGL2RenderingContext?t:r)||void 0,floatTexFilterLinear:(t instanceof WebGL2RenderingContext?t:s)||void 0,halfFloatTex:(t instanceof WebGL2RenderingContext?t:a)||void 0,halfFloatTexFilterLinear:(t instanceof WebGL2RenderingContext?t:o)||void 0,vao:(t instanceof WebGL2RenderingContext?t:u)||void 0}}clear(t,e,i){let r=0;t&&(r=r|this.gl.COLOR_BUFFER_BIT),e&&(r=r|this.gl.DEPTH_BUFFER_BIT),i&&(r=r|this.gl.STENCIL_BUFFER_BIT),this.gl.clear(r)}compileAttribute(t){if(t.gl)return;const e=this.gl,i=e.createBuffer();if(!i){console.warn(this.debugContext,"Could bot create WebGLBuffer. Printing any existing gl errors:"),this.printError();return}return this.state.bindVBO(i),e.bufferData(e.ARRAY_BUFFER,t.data,t.isDynamic?e.DYNAMIC_DRAW:e.STATIC_DRAW),t.gl={bufferId:i,proxy:this},t.resolve(),!0}compileIndexBuffer(t){if(t.gl)return;const e=this.gl,i=e.createBuffer();if(!i){console.warn(this.debugContext,"Could not create WebGLBuffer. Printing any existing gl errors:"),this.printError();return}return this.state.bindElementArrayBuffer(i),e.bufferData(e.ELEMENT_ARRAY_BUFFER,t.data,t.isDynamic?e.DYNAMIC_DRAW:e.STATIC_DRAW),t.gl={bufferId:i,indexType:t.data instanceof Uint8Array?e.UNSIGNED_BYTE:t.data instanceof Uint16Array?e.UNSIGNED_SHORT:e.UNSIGNED_INT,proxy:this},t.resolve(),!0}compileGeometry(t){if(t.gl)return;let e=!0;if(t.gl={proxy:this},this.extensions.vao){let i;this.extensions.vao instanceof WebGL2RenderingContext?i=this.extensions.vao.createVertexArray():i=this.extensions.vao.createVertexArrayOES(),i?(this.state.disableVertexAttributeArray(),this.state.bindVAO(i),t.attributes.forEach((r,s)=>{this.updateAttribute(r)&&this.useAttribute(s,r,t)}),t.indexBuffer&&this.updateIndexBuffer(t.indexBuffer)&&this.useIndexBuffer(t.indexBuffer),t.gl.vao=i,this.state.bindVAO(null)):Mn("WARNING: Could not make VAO for Geometry. This is fine, but this could cause a hit on performance.")}return t.attributes.forEach(i=>{e=!!(this.compileAttribute(i)&&e)}),e}compileMaterial(t){if(t.gl)return;let e=this.vertexShaders.get(t.vertexShader)||null;if(!e){if(e=this.gl.createShader(this.gl.VERTEX_SHADER),!e){console.warn(this.debugContext,"Could not create a Vertex WebGLShader. Printing GL Errors:"),this.printError();return}if(this.gl.shaderSource(e,t.vertexShader),this.gl.compileShader(e),this.gl.isContextLost()&&console.warn("Context was lost during compilation"),!this.gl.getShaderParameter(e,this.gl.COMPILE_STATUS)){console.error(this.debugContext,"VERTEX SHADER COMPILER ERROR",t.name),console.warn("Could not compile provided shader. Printing logs and errors:"),console.warn(this.lineFormatShader(t.vertexShader)),console.warn("LOGS:"),console.warn(this.gl.getShaderInfoLog(e)),this.printError(),this.gl.deleteShader(e);return}}let i=this.programs.get(e);i||(i=new Map,this.programs.set(e,i));const r={vsId:e,fsId:[],programId:[],proxy:this,programByTarget:new WeakMap,outputsByProgram:new WeakMap},s=new Set;if(!t.fragmentShader)return console.warn("A material appears to not have it's fragment shader configuration set."),!1;t.fragmentShader.forEach(o=>{var p,g;if(!i||!e)return;let c=this.fragmentShaders.get(o.source)||null;if(!c){if(c=this.gl.createShader(this.gl.FRAGMENT_SHADER),!c){console.warn(this.debugContext,"Could not create a Fragment WebGLShader. Printing GL Errors:"),this.printError();return}if(this.gl.shaderSource(c,o.source),this.gl.compileShader(c),this.gl.isContextLost()&&console.warn("Context was lost during compilation"),!this.gl.getShaderParameter(c,this.gl.COMPILE_STATUS)){console.error(this.debugContext,"FRAGMENT SHADER COMPILER ERROR:",t.name),console.warn("Could not compile provided shader. Printing logs and errors:"),console.warn(this.lineFormatShader(o.source)),console.warn("LOGS:"),console.warn(this.gl.getShaderInfoLog(c)),this.printError(),this.gl.deleteShader(c);return}}let l=i.get(c)||null;if(l)l.useCount++;else{const m=this.gl.createProgram();if(!m){console.warn(this.debugContext,"Could not create a WebGLProgram. Printing GL Errors:"),this.printError();return}if(l={useCount:1,program:m},this.gl.attachShader(m,e),this.gl.attachShader(m,c),this.gl.linkProgram(m),this.gl.validateProgram(m),!this.gl.getProgramParameter(m,this.gl.LINK_STATUS)||!this.gl.getProgramParameter(m,this.gl.VALIDATE_STATUS)){const v=this.gl.getProgramInfoLog(m);console.warn(this.debugContext,`Could not compile WebGL program. 

`,v),this.printError(),this.gl.deleteProgram(m);return}i.set(c,l)}(p=r.fsId)==null||p.push({id:c,outputTypes:o.outputTypes}),(g=r.programId)==null||g.push({id:l.program,outputTypes:o.outputTypes}),r.outputsByProgram.set(l.program,o.outputTypes),this.state.useProgram(l.program);const u=this.state.currentProgram;if(!u)return!1;const d=this.gl.getProgramParameter(u,this.gl.ACTIVE_UNIFORMS);for(let m=0;m<d;m++){const v=this.gl.getActiveUniform(u,m);v&&s.add(v.name.replace("[0]",""))}}),t.gl=r;const a=new Set;return Object.keys(t.uniforms).forEach(o=>{s.has(o)||a.add(o)}),a.forEach(o=>{delete t.uniforms[o]}),Object.keys(t.uniforms).length!==s.size?(console.warn(this.debugContext,"A program is requesting a set of uniforms:",Array.from(s.values()),"but our material only provides",Object.keys(t.uniforms),"thus the expected rendering will be considered invalid."),!1):!0}compileRenderTarget(t){if(t.isInvalid)return!1;if(t.gl)return!0;const e=this.gl,i=e.createFramebuffer();if(!i)return console.warn(this.debugContext,"Could not generate a frame buffer object. Printing GL errors:"),this.printError(),!1;this.state.bindFBO(i);const r={fboId:i,proxy:this,fboByMaterial:new WeakMap};if(Array.isArray(t.buffers.color)){if(!this.extensions.drawBuffers)return console.warn("Attempted to manage a render target with MRT but the hardware does not support MRT. Use multiple render targets instead."),!1;const l=[];let u=!0;r.colorBufferId=l;const d=t.buffers.color.length<=1;if(t.buffers.color.forEach((p,g)=>{if(u)if(p.buffer instanceof se){const m=Rr(e,this.extensions,g,d,!1);l.push({data:p.buffer,outputType:p.outputType,attachment:m}),zs(p.buffer)?e.framebufferTexture2D(e.FRAMEBUFFER,m,e.TEXTURE_2D,p.buffer.gl.textureId,0):(console.warn(this.debugContext,"Attempted to compile render target whose target texture was not ready for use."),u=!1)}else{const m=this.compileColorBuffer(p.buffer,t.width,t.height);if(m){const v=Rr(e,this.extensions,g,d,!1);l.push({data:m,outputType:p.outputType,attachment:v}),e.framebufferRenderbuffer(e.FRAMEBUFFER,v,e.RENDERBUFFER,m)}}}),!u)return!1}else if(t.buffers.color!==void 0){const l=t.buffers.color;if(l.buffer instanceof se){const u=Rr(e,this.extensions,0,!0,!1);if(r.colorBufferId={data:l.buffer,outputType:l.outputType,attachment:u},zs(l.buffer))e.framebufferTexture2D(e.FRAMEBUFFER,u,e.TEXTURE_2D,l.buffer.gl.textureId,0);else return console.warn(this.debugContext,"Attempted to compile render target whose target texture was not ready for use."),!1}else{const u=this.compileColorBuffer(l.buffer,t.width,t.height);if(u){const d=Rr(e,this.extensions,0,!0,!1);r.colorBufferId={data:u,outputType:l.outputType,attachment:d},e.framebufferRenderbuffer(e.FRAMEBUFFER,d,e.RENDERBUFFER,u)}}}if(t.buffers.depth!==void 0){const l=t.buffers.depth;if(l instanceof se)r.depthBufferId=l,zs(l)&&e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,l.gl.textureId,0);else if(l instanceof nu){const u=this.compileDepthBuffer(l.internalFormat,t.width,t.height);u&&(r.depthBufferId=u,e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,u))}else{const u=this.compileDepthBuffer(l,t.width,t.height);u&&(r.depthBufferId=u,e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,u))}}if(t.buffers.stencil!==void 0){const l=t.buffers.stencil;if(l instanceof se)r.stencilBufferId=l,zs(l)&&e.framebufferTexture2D(e.FRAMEBUFFER,e.STENCIL_ATTACHMENT,e.TEXTURE_2D,l.gl.textureId,0);else{const u=this.compileStencilBuffer(l,t.width,t.height);u&&(r.stencilBufferId=u,e.framebufferRenderbuffer(e.FRAMEBUFFER,e.STENCIL_ATTACHMENT,e.RENDERBUFFER,u))}}t.gl=r;const s=e.checkFramebufferStatus(e.FRAMEBUFFER);let a=!1,o=!1,c="";switch(s){case e.FRAMEBUFFER_COMPLETE:t.setAsValid();break;case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:c="FRAMEBUFFER_INCOMPLETE_ATTACHMENT";break;case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:c="FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";break;case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:c="FRAMEBUFFER_INCOMPLETE_DIMENSIONS";break;case e.FRAMEBUFFER_UNSUPPORTED:c="FRAMEBUFFER_UNSUPPORTED";break;default:a=!0;break}if(e instanceof WebGL2RenderingContext)switch(s){case e.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:c="FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";break;case e.RENDERBUFFER_SAMPLES:c="RENDERBUFFER_SAMPLES";break;default:o=!0;break}return a&&o&&(console.warn(this.debugContext,"A framebuffer check failed to return a known result. This FBO for render target will be assumed failed"),console.warn("Result:",s,"Render Target:",t),c="UNKNOWN"),c?(console.warn(this.debugContext,"When creating a new FrameBuffer Object, the check on the framebuffer failed. Printing Errors:"),console.warn(c),this.printError(),console.warn("FAILED RENDER TARGET:",t),delete t.gl,t.isInvalid=!0,!1):!0}compileDepthBuffer(t,e,i){const r=this.gl,s=r.createRenderbuffer();if(!s){console.warn(this.debugContext,"Could not generate a WebGLRenderBuffer. Printing GL Errors:"),this.printError();return}return this.state.bindRBO(s),r.renderbufferStorage(r.RENDERBUFFER,Jl(r,t),e,i),s}compileStencilBuffer(t,e,i){const r=this.gl,s=r.createRenderbuffer();if(!s){console.warn(this.debugContext,"Could not generate a WebGLRenderBuffer. Printing GL Errors:"),this.printError();return}return this.state.bindRBO(s),r.renderbufferStorage(r.RENDERBUFFER,eu(r,t),e,i),s}compileColorBuffer(t,e,i){const r=this.gl,s=r.createRenderbuffer();if(!s){console.warn(this.debugContext,"Could not generate a WebGLRenderBuffer. Printing GL Errors:"),this.printError();return}return this.state.bindRBO(s),r.renderbufferStorage(r.RENDERBUFFER,Zl(r,t.internalFormat),e,i),t.gl={bufferId:s,proxy:this},s}compileTexture(t){if(!t.gl||t.gl.textureId)return;if(t.gl.textureUnit<0){console.warn(this.debugContext,"A Texture object attempted to be compiled without an established Texture Unit.",t);return}this.state.setActiveTextureUnit(t.gl.textureUnit);const i=this.gl.createTexture();if(!i){console.warn(this.debugContext,"Could not generate a texture object on the GPU. Printing any gl errors:"),this.printError();return}return t.gl.textureId=i,t.needsDataUpload=!0,t.needsSettingsUpdate=!0,this.updateTextureData(t),this.updateTextureSettings(t),!0}draw(t){var r,s,a;let e,i=[0,0];t.vertexDrawRange&&t.vertexDrawRange[0]>=0&&t.vertexDrawRange[1]>=0?i=[t.vertexDrawRange[0],t.vertexDrawRange[1]-t.vertexDrawRange[0]]:i=[0,t.vertexCount],t.drawInstances>=0&&t.geometry.isInstanced&&(e=this.extensions.instancing),!((N.MRT||N.MRT_EXTENSION)&&this.state.renderTarget&&!this.state.drawBuffers.find(o=>o!==this.gl.NONE))&&(e&&e instanceof WebGL2RenderingContext?t.geometry.indexBuffer?e.drawElementsInstanced(pi(this.gl,t.drawMode),i[1],((r=t.geometry.indexBuffer.gl)==null?void 0:r.indexType)??this.gl.UNSIGNED_INT,0,t.drawInstances):e.drawArraysInstanced(pi(this.gl,t.drawMode),i[0],i[1],t.drawInstances):e?t.geometry.indexBuffer?e.drawElementsInstancedANGLE(pi(this.gl,t.drawMode),i[1],((s=t.geometry.indexBuffer.gl)==null?void 0:s.indexType)??this.gl.UNSIGNED_INT,0,t.drawInstances):e.drawArraysInstancedANGLE(pi(this.gl,t.drawMode),i[0],i[1],t.drawInstances):t.geometry.indexBuffer?this.gl.drawElements(pi(this.gl,t.drawMode),i[1],((a=t.geometry.indexBuffer.gl)==null?void 0:a.indexType)??this.gl.UNSIGNED_INT,0):this.gl.drawArrays(pi(this.gl,t.drawMode),i[0],i[1]),this.state.setDrawBuffers([],!0))}disposeAttribute(t){t.gl&&(this.gl.deleteBuffer(t.gl.bufferId),delete t.gl)}disposeIndexBuffer(t){var e;t.gl&&(this.gl.deleteBuffer((e=t.gl)==null?void 0:e.bufferId),delete t.gl)}disposeColorBuffer(t){t.gl&&(t.gl.bufferId&&this.disposeRenderBuffer(t.gl.bufferId),delete t.gl)}disposeGeometry(t){t.gl&&(this.extensions.vao&&t.gl.vao&&(this.extensions.vao instanceof WebGL2RenderingContext?this.extensions.vao.deleteVertexArray(t.gl.vao):this.extensions.vao.deleteVertexArrayOES(t.gl.vao)),delete t.gl)}disposeMaterial(t){if(t.gl){const{vsId:e,fsId:i,programId:r}=t.gl;let s=this.programs.get(e);s||(s=new Map,this.gl.deleteShader(e));for(let a=0,o=i.length;a<o;++a){const c=i[a];let l=s.get(c);l||(l={useCount:0,program:r}),l.useCount--,l.useCount<1&&(this.gl.deleteProgram(l.program),s.delete(c),s.size<=0&&this.gl.deleteShader(e));let u=!1;this.programs.forEach(d=>{d.has(c)&&(u=!0)}),u||this.gl.deleteShader(c)}}delete t.gl}disposeRenderBuffer(t){this.gl.deleteRenderbuffer(t)}disposeRenderTarget(t){t.gl&&(Array.isArray(t.gl.colorBufferId)?t.gl.colorBufferId.forEach(e=>{e.data instanceof se&&!t.retainTextureTargets?this.disposeTexture(e.data):e.data instanceof WebGLRenderbuffer&&this.disposeRenderBuffer(e.data)}):t.gl.colorBufferId&&t.gl.colorBufferId.data instanceof se&&!t.retainTextureTargets?this.disposeTexture(t.gl.colorBufferId.data):t.gl.colorBufferId instanceof WebGLRenderbuffer&&this.disposeRenderBuffer(t.gl.colorBufferId.data),t.gl.depthBufferId instanceof se&&!t.retainTextureTargets?this.disposeTexture(t.gl.depthBufferId):t.gl.depthBufferId instanceof WebGLRenderbuffer&&this.disposeRenderBuffer(t.gl.depthBufferId),t.gl.stencilBufferId instanceof se&&!t.retainTextureTargets?this.disposeTexture(t.gl.stencilBufferId):t.gl.stencilBufferId instanceof WebGLRenderbuffer&&this.disposeRenderBuffer(t.gl.stencilBufferId),this.gl.deleteFramebuffer(t.gl.fboId),delete t.gl)}disposeTexture(t){t.gl&&!t.destroyed&&(this.gl.deleteTexture(t.gl.textureId),this.state.freeTextureUnit(t)),delete t.gl}static getContext(t,e){const i=[N.WEBGL_VERSION,"webgl","webgl2","experimental-webgl"];let r=null,s={};for(let a=0;a<i.length;++a){const o=i[a],c=t.getContext(o,e);if(c&&(c instanceof WebGLRenderingContext||c instanceof WebGL2RenderingContext)){Mn("Generated GL Context of version with attributes:",o,e),r=c,s=Cr.addExtensions(r);break}}return{context:r,extensions:s}}printError(){const t=this.gl.getError();switch(t){case this.gl.NO_ERROR:console.warn("GL Error: No Error");break;case this.gl.INVALID_ENUM:console.warn("GL Error: INVALID ENUM");break;case this.gl.INVALID_VALUE:console.warn("GL Error: INVALID_VALUE");break;case this.gl.INVALID_OPERATION:console.warn("GL Error: INVALID OPERATION");break;case this.gl.INVALID_FRAMEBUFFER_OPERATION:console.warn("GL Error: INVALID FRAMEBUFFER OPERATION");break;case this.gl.OUT_OF_MEMORY:console.warn("GL Error: OUT OF MEMORY");break;case this.gl.CONTEXT_LOST_WEBGL:console.warn("GL Error: CONTEXT LOST WEBGL");break;default:console.warn("GL Error: GL Context output an unrecognized error value:",t);break}}lineFormat(t){const e=t.split(`
`),i=String(e.length).length+1;return`
${e.map((r,s)=>`${Array(i-String(s+1).length).join(" ")}${s+1}: ${r}`).join(`
`)}`}lineFormatShader(t){return t?Sn(t)?this.lineFormat(t):t.forEach(e=>`
SHADER FOR OUTPUT TYPES: ${e.outputTypes} ${this.lineFormat(e.source)}`):"NO SHADER FOUND"}updateTexture(t){if(!t.gl||t.gl.textureUnit<0){console.warn(this.debugContext,"Can not update or compile a texture that does not have an established texture unit.",t);return}this.compileTexture(t),this.updateTextureData(t),this.updateTexturePartialData(t),this.updateTextureSettings(t),t.resolve()}updateTextureData(t){if(!t.needsDataUpload||!t.gl||!t.gl.textureId)return;if(t.gl.textureUnit<0){console.warn(this.debugContext,"A Texture object attempted to update it's data without an established Texture Unit.",t);return}const e=this.gl;if(this.state.setActiveTextureUnit(t.gl.textureUnit),this.state.bindTexture(t,h.GLSettings.Texture.TextureBindingTarget.TEXTURE_2D),t.needsSettingsUpdate=!0,this.updateTextureSettings(t),e instanceof WebGLRenderingContext||e instanceof WebGL2RenderingContext){if(su(t.data)){(!Wi(t.data.width)||!Wi(t.data.height))&&Mn("Created a texture that is not using power of 2 dimensions.");const i=gi(e,t.internalFormat),r=gi(e,t.format);e instanceof WebGLRenderingContext&&i!==r&&console.warn("WebGL 1 requires format and data format to be identical"),e.texImage2D(e.TEXTURE_2D,0,i,t.data.width,t.data.height,0,r,xr(e,t.type),t.data.buffer)}else t.data&&((!Wi(t.data.width)||!Wi(t.data.height))&&Mn("Created a texture that is not using power of 2 dimensions. %o",t),e.texImage2D(e.TEXTURE_2D,0,gi(e,t.internalFormat),gi(e,t.format),xr(e,t.type),t.data));t.generateMipMaps&&e.generateMipmap(e.TEXTURE_2D)}t.data&&(t.data={width:t.data.width,height:t.data.height,buffer:null}),t.needsDataUpload=!1}updateTexturePartialData(t){if(!t.needsPartialDataUpload||!t.gl||!t.gl.textureId)return;if(t.gl.textureUnit<0){console.warn(this.debugContext,"A Texture object attempted to update it's data without an established Texture Unit.",t);return}const e=this.gl;this.state.setActiveTextureUnit(t.gl.textureUnit),this.state.bindTexture(t,h.GLSettings.Texture.TextureBindingTarget.TEXTURE_2D),t.updateRegions.forEach(i=>{const r=i[0],s=i[1];(e instanceof WebGLRenderingContext||e instanceof WebGL2RenderingContext)&&(su(r)?e.texSubImage2D(e.TEXTURE_2D,0,s.x,s.y,r.width,r.height,gi(e,t.format),xr(e,t.type),r.buffer):r&&e.texSubImage2D(e.TEXTURE_2D,0,s.x,s.y,gi(e,t.format),xr(e,t.type),r),t.generateMipMaps&&e.generateMipmap(e.TEXTURE_2D))}),t.needsPartialDataUpload=!1}updateTextureSettings(t){if(!t.needsSettingsUpdate||!t.gl||!t.data||!t.gl.textureId)return;if(t.gl.textureUnit<0){console.warn(this.debugContext,"A Texture object attempted to update it's settings without an established Texture Unit.",t);return}const e=Wi(t.data.width)&&Wi(t.data.height),i=this.gl;this.state.setActiveTextureUnit(t.gl.textureUnit),this.state.bindTexture(t,h.GLSettings.Texture.TextureBindingTarget.TEXTURE_2D);let r,s;if(t.isHalfFloatTexture)if(N.FLOAT_TEXTURE_READ.halfLinearFilter)switch(r=mi(i,t.magFilter),t.minFilter){case h.GLSettings.Texture.TextureMinFilter.Nearest:case h.GLSettings.Texture.TextureMinFilter.NearestMipMapLinear:case h.GLSettings.Texture.TextureMinFilter.NearestMipMapNearest:s=In(i,h.GLSettings.Texture.TextureMinFilter.Nearest,t.generateMipMaps);break;case h.GLSettings.Texture.TextureMinFilter.Linear:case h.GLSettings.Texture.TextureMinFilter.LinearMipMapLinear:case h.GLSettings.Texture.TextureMinFilter.LinearMipMapNearest:s=In(i,h.GLSettings.Texture.TextureMinFilter.Nearest,t.generateMipMaps);break}else r=mi(i,h.GLSettings.Texture.TextureMagFilter.Nearest),s=In(i,h.GLSettings.Texture.TextureMinFilter.Nearest,t.generateMipMaps);else if(t.isFloatTexture)if(N.FLOAT_TEXTURE_READ.fullLinearFilter)switch(r=mi(i,t.magFilter),t.minFilter){case h.GLSettings.Texture.TextureMinFilter.Nearest:case h.GLSettings.Texture.TextureMinFilter.NearestMipMapLinear:case h.GLSettings.Texture.TextureMinFilter.NearestMipMapNearest:s=In(i,h.GLSettings.Texture.TextureMinFilter.Nearest,t.generateMipMaps);break;case h.GLSettings.Texture.TextureMinFilter.Linear:case h.GLSettings.Texture.TextureMinFilter.LinearMipMapLinear:case h.GLSettings.Texture.TextureMinFilter.LinearMipMapNearest:s=In(i,h.GLSettings.Texture.TextureMinFilter.Nearest,t.generateMipMaps);break}else r=mi(i,h.GLSettings.Texture.TextureMagFilter.Nearest),s=In(i,h.GLSettings.Texture.TextureMinFilter.Nearest,t.generateMipMaps);else!e&&i instanceof WebGLRenderingContext?(r=mi(i,h.GLSettings.Texture.TextureMagFilter.Linear),s=In(i,h.GLSettings.Texture.TextureMinFilter.Linear,t.generateMipMaps)):(r=mi(i,t.magFilter),s=In(i,t.minFilter,t.generateMipMaps));if(i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,r),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,s),t.isFloatTexture||(i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,Vo(i,t.wrapHorizontal)),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,Vo(i,t.wrapVertical))),t.isFloatTexture||(i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,t.premultiplyAlpha),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,t.flipY)),this.extensions.anisotropicFiltering){const{ext:a,stat:o}=this.extensions.anisotropicFiltering,c=Math.min(o.maxAnistropicFilter,Math.floor(t.anisotropy||0));!isNaN(c)&&!t.isFloatTexture&&i.texParameterf(i.TEXTURE_2D,a.TEXTURE_MAX_ANISOTROPY_EXT,c)}t.needsSettingsUpdate=!1}updateAttribute(t){if(!t.gl)return this.compileAttribute(t);if(!t.fullUpdate&&!t.needsUpdate)return!0;const e=this.gl;if(t.fullUpdate||t.updateRange.count<0||t.updateRange.offset<0)this.state.bindVBO(t.gl.bufferId),e.bufferData(e.ARRAY_BUFFER,t.data,t.isDynamic?e.DYNAMIC_DRAW:e.STATIC_DRAW);else if(t.updateRange.count>0){this.state.bindVBO(t.gl.bufferId);const i=t.updateRange.offset;e.bufferSubData(e.ARRAY_BUFFER,i*4,t.data.subarray(i,i+t.updateRange.count))}return t.resolve(),!0}updateIndexBuffer(t){if(!t.gl)return this.compileIndexBuffer(t);if(!t.fullUpdate&&!t.needsUpdate)return!0;const e=this.gl;if(t.fullUpdate||t.updateRange.count<0||t.updateRange.offset<0)this.state.bindVBO(t.gl.bufferId),e.bufferData(e.ELEMENT_ARRAY_BUFFER,t.data,t.isDynamic?e.DYNAMIC_DRAW:e.STATIC_DRAW);else if(t.updateRange.count>0){this.state.bindVBO(t.gl.bufferId);const i=t.updateRange.offset;e.bufferSubData(e.ELEMENT_ARRAY_BUFFER,i*t.data.constructor.BYTES_PER_ELEMENT,t.data.subarray(i,i+t.updateRange.count))}return t.resolve(),!0}useIndexBuffer(t){return t.gl?(this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,t.gl.bufferId),!0):!1}useAttribute(t,e,i){if(!this.state.currentProgram||!e.gl)return!1;e.gl.locations=e.gl.locations||new Map;let r=e.gl.locations.get(this.state.currentProgram);if(r===void 0&&(r=this.gl.getAttribLocation(this.state.currentProgram,t),r===-1&&Mn("WARN: An attribute is not being used with the current material: %o",t,e),e.gl.locations.set(this.state.currentProgram,r)),r!==-1){switch(this.state.bindVBO(e.gl.bufferId),e.size){case 1:case 2:case 3:case 4:this.state.willUseVertexAttributeArray(r),this.gl.vertexAttribPointer(r,e.size,this.gl.FLOAT,e.normalize,0,0),i.isInstanced&&e.isInstanced&&this.extensions.instancing?this.state.setVertexAttributeArrayDivisor(r,1):this.state.setVertexAttributeArrayDivisor(r,0);break;default:{const s=Math.ceil(e.size/4);for(let a=0;a<s;++a)this.state.willUseVertexAttributeArray(r+a),this.gl.vertexAttribPointer(r+a,4,this.gl.FLOAT,e.normalize,s*4*4,a*16),i.isInstanced&&e.isInstanced&&this.extensions.instancing?this.state.setVertexAttributeArrayDivisor(r+a,1):this.state.setVertexAttributeArrayDivisor(r+a,0);break}}return!0}}}var Se=(n=>(n[n.FLOAT=0]="FLOAT",n[n.VEC2=1]="VEC2",n[n.VEC3=2]="VEC3",n[n.VEC4=3]="VEC4",n[n.VEC4_ARRAY=4]="VEC4_ARRAY",n[n.FLOAT_ARRAY=5]="FLOAT_ARRAY",n[n.MATRIX3x3=6]="MATRIX3x3",n[n.MATRIX4x4=7]="MATRIX4x4",n[n.TEXTURE=8]="TEXTURE",n))(Se||{});function Up(n){return n.type===1}function Fp(n){return n.type===2}function kp(n){return n.type===3}function au(n){return n.type===4}function Gp(n){return n.type===6}function zp(n){return n.type===7}function Vp(n){return n.type===8}function $p(n){return n.type===0}const Wp=window.OffscreenCanvas||ks;function bi(n){return n instanceof Wp}var Et=(n=>(n[n.INVALID=0]="INVALID",n[n.VALID=1]="VALID",n[n.NO_RENDER_TARGET_MATCHES=2]="NO_RENDER_TARGET_MATCHES",n))(Et||{});class Yn{constructor(t){f(this,"isInvalid",!1);f(this,"_uid",z());f(this,"_buffers");f(this,"_height");f(this,"_width");f(this,"_validFramebuffer",!1);f(this,"_disabledTargets",new Set);f(this,"retainTextureTargets",!1);f(this,"gl");this._buffers={color:Array.isArray(t.buffers.color)?t.buffers.color.slice(0):t.buffers.color,depth:t.buffers.depth,stencil:t.buffers.stencil},this._width=t.width||0,this._height=t.height||0,this.retainTextureTargets=t.retainTextureTargets||!1,this.calculateDimensions()}get uid(){return this._uid}get buffers(){return{color:Array.isArray(this._buffers.color)?this._buffers.color.slice(0):this._buffers.color,depth:this._buffers.depth,stencil:this._buffers.stencil}}get height(){return this._height}get width(){return this._width}get validFramebuffer(){return this._validFramebuffer}get disabledTargets(){return this._disabledTargets}set disabledTargets(t){this._disabledTargets=t}calculateDimensions(){const t=[];if(this._buffers.color instanceof se)t.push(this._buffers.color);else if(Array.isArray(this._buffers.color))for(let e=0,i=this._buffers.color.length;e<i;++e){const r=this._buffers.color[e];r.buffer instanceof se&&t.push(r.buffer)}else this._buffers.color&&this._buffers.color.buffer instanceof se&&t.push(this._buffers.color.buffer);if(this._buffers.depth instanceof se&&t.push(this._buffers.depth),this._buffers.stencil instanceof se&&t.push(this._buffers.stencil),t.length>0&&t[0].data){const{width:e,height:i}=t[0].data;for(let r=0,s=t.length;r<s;++r){const a=t[r];if(!a.data){console.warn("A texture specified for thie RenderTarget did not have any data associated with it.");return}const{width:o,height:c}=a.data;(o!==e||c!==i)&&(console.warn("Texture applied to the render target is invalid as it does not match dimensions of all textures applied:",a,t,"The texture will be removed as a target for the render target"),this.removeTextureFromBuffer(a))}this._width=e,this._height=i}(!this._width||!this._height)&&console.warn("A RenderTarget was not able to establish valid dimensions. This target had no texture buffers and did not specify valid width and height values.",this)}dispose(){this.gl&&this.gl.proxy.disposeRenderTarget(this)}getBuffers(){return Array.isArray(this.buffers.color)?this.buffers.color:this.buffers.color?[this.buffers.color]:[]}getGLBuffers(){return this.gl?Array.isArray(this.gl.colorBufferId)?this.gl.colorBufferId:[this.gl.colorBufferId]:(this.isInvalid||console.warn("Attempted to retrieve gl buffers before the render target was compiled."),[])}getOutputTypes(){return this.getBuffers().map(t=>t.outputType)}getSize(){return[this._width,this._height]}getTextures(){const t=[];return Array.isArray(this.buffers.color)?this.buffers.color.forEach(e=>{e.buffer instanceof se&&t.push(e.buffer)}):this.buffers.color&&this.buffers.color.buffer instanceof se&&t.push(this.buffers.color.buffer),this.buffers.depth instanceof se&&t.push(this.buffers.depth),this.buffers.stencil instanceof se&&t.push(this.buffers.stencil),t}isColorTarget(){var t;if(Array.isArray(this.buffers.color)){if(this.buffers.color.length===1)return this.buffers.color[0].outputType===H.COLOR}else return((t=this.buffers.color)==null?void 0:t.outputType)===H.COLOR;return!1}removeTextureFromBuffer(t){var e;if(Array.isArray(this._buffers.color)){const i=this._buffers.color.find(s=>s.buffer===t);if(!i)return;const r=this._buffers.color.indexOf(i);r>-1&&this._buffers.color.splice(r,1)}else((e=this._buffers.color)==null?void 0:e.buffer)===t&&delete this._buffers.color;this._buffers.depth===t&&delete this._buffers.depth,this._buffers.stencil===t&&delete this._buffers.stencil}setSize(t,e){this.dispose(),this._width=t,this._height=e,this.getTextures().forEach(r=>{r.data={buffer:null,height:e,width:t}})}setAsValid(){this._validFramebuffer=!0}}const ou=Ie("performance");class cu{constructor(t,e){f(this,"debugContext","");f(this,"extensions");f(this,"gl");f(this,"glProxy");f(this,"_textureUnitToTexture",new Map);f(this,"_freeUnits",[]);f(this,"_blendingEnabled",!0);f(this,"_blendDstFactor",h.GLSettings.Material.BlendingDstFactor.One);f(this,"_blendSrcFactor",h.GLSettings.Material.BlendingDstFactor.One);f(this,"_blendEquation",h.GLSettings.Material.BlendingEquations.Add);f(this,"_cullFace",h.GLSettings.Material.CullSide.NONE);f(this,"_colorMask",[!0,!0,!0,!0]);f(this,"_clearColor",[0,0,0,1]);f(this,"_depthFunc",h.GLSettings.Material.DepthFunctions.ALWAYS);f(this,"_depthTestEnabled",!0);f(this,"_depthMask",!0);f(this,"_ditheringEnabled",!0);f(this,"_boundFBO",null);f(this,"_renderTarget",null);f(this,"_boundRBO",null);f(this,"_boundVAO",null);f(this,"_boundVBO",null);f(this,"_boundElementArrayBuffer",null);f(this,"_boundTexture",{id:null,unit:-1});f(this,"_currentProgram",null);f(this,"_scissorTestEnabled",!1);f(this,"_scissorBounds",{x:0,y:0,width:1,height:1});f(this,"_currentUniforms",{});f(this,"_activeTextureUnit",-1);f(this,"_drawBuffers",[]);f(this,"_textureWillBeUsed",new Map);f(this,"_viewport",{x:0,y:0,width:100,height:100});f(this,"_enabledVertexAttributeArray",[]);f(this,"_willUseVertexAttributeArray",[]);f(this,"_vertexAttributeArrayDivisor",new Map);this.gl=t,this.extensions=e;const i=this.gl.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);for(let r=0;r<i;++r)this._freeUnits.push(tu(t,r));this._activeTextureUnit=t.TEXTURE0}get blendingEnabled(){return this._blendingEnabled}get blendDstFactor(){return this._blendDstFactor}get blendSrcFactor(){return this._blendSrcFactor}get blendEquation(){return this._blendEquation}get cullFace(){return this._cullFace}get colorMask(){return this._colorMask}get clearColor(){return this._clearColor}get depthFunc(){return this._depthFunc}get depthTestEnabled(){return this._depthTestEnabled}get depthMask(){return this._depthMask}get ditheringEnabled(){return this._ditheringEnabled}get boundFBO(){return this._boundFBO}get renderTarget(){return this._renderTarget}get boundRBO(){return this._boundRBO}get boundVAO(){return this._boundVAO}get boundVBO(){return this._boundVBO}get boundElementArrayBuffer(){return this._boundElementArrayBuffer}get boundTexture(){return this._boundTexture}get currentProgram(){return this._currentProgram}get scissorTestEnabled(){return this._scissorTestEnabled}get scissorBounds(){return this._scissorBounds}get currentUniforms(){return this._currentUniforms}get activeTextureUnit(){return this._activeTextureUnit}get drawBuffers(){return this._drawBuffers}get textureWillBeUsed(){return this._textureWillBeUsed}get viewport(){return this._viewport}get enabledVertexAttributeArray(){return this._enabledVertexAttributeArray.slice(0).filter(t=>t!==void 0)}bindVAO(t){this._boundVAO!==t&&(this._boundVAO=t,this.extensions.vao&&(this.extensions.vao instanceof WebGL2RenderingContext?this.extensions.vao.bindVertexArray(t):this.extensions.vao.bindVertexArrayOES(t)))}bindVBO(t){this._boundVBO!==t&&(this._boundVBO=t,this.gl.bindBuffer(this.gl.ARRAY_BUFFER,t))}bindElementArrayBuffer(t){this._boundElementArrayBuffer!==t&&(this._boundElementArrayBuffer=t,this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,t))}bindRBO(t){this._boundRBO!==t&&(this._boundRBO=t,this.gl.bindRenderbuffer(this.gl.RENDERBUFFER,t))}bindFBO(t){this._boundFBO!==t&&(this._boundFBO=t,this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,t))}bindTexture(t,e){if(!(!t.gl||!t.gl.textureId)&&(!t||this._boundTexture.id!==t.gl.textureId||this._boundTexture.unit!==this._activeTextureUnit)){switch(this._boundTexture={id:t.gl.textureId,unit:this._activeTextureUnit},e){case h.GLSettings.Texture.TextureBindingTarget.TEXTURE_2D:this.gl.bindTexture(this.gl.TEXTURE_2D,t.gl.textureId);break;case h.GLSettings.Texture.TextureBindingTarget.CUBE_MAP:this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP,t.gl.textureId);break}const i=this._textureUnitToTexture.get(this._activeTextureUnit);i&&i.gl&&(i.gl.textureUnit=-1),this._textureUnitToTexture.set(this._activeTextureUnit,t),t.gl.textureUnit=this._activeTextureUnit}}disableVertexAttributeArray(){for(let t=0,e=this._enabledVertexAttributeArray.length;t<e;++t){const i=this._enabledVertexAttributeArray[t];this.gl.disableVertexAttribArray(i)}this._enabledVertexAttributeArray=[],this._willUseVertexAttributeArray=[],this._vertexAttributeArrayDivisor.clear()}willUseVertexAttributeArray(t){this._willUseVertexAttributeArray[t]=t,this._enabledVertexAttributeArray[t]===void 0&&(this._enabledVertexAttributeArray[t]=t,this.gl.enableVertexAttribArray(t))}applyVertexAttributeArrays(){for(let t=0,e=this._enabledVertexAttributeArray.length;t<e;++t){const i=this._enabledVertexAttributeArray[t];if(i!==void 0){if(this._willUseVertexAttributeArray[i]!==void 0)return;this.gl.disableVertexAttribArray(i),delete this._enabledVertexAttributeArray[i]}}this._willUseVertexAttributeArray=[]}setVertexAttributeArrayDivisor(t,e){this.extensions.instancing&&this._enabledVertexAttributeArray[t]!==void 0&&this._vertexAttributeArrayDivisor.get(t)!==e&&(this.extensions.instancing instanceof WebGL2RenderingContext?this.extensions.instancing.vertexAttribDivisor(t,e):this.extensions.instancing.vertexAttribDivisorANGLE(t,e),this._vertexAttributeArrayDivisor.set(t,e))}freeTextureUnit(t){t.gl&&t.gl.textureUnit>-1&&(this._freeUnits.unshift(t.gl.textureUnit),t.gl.textureUnit=-1)}setActiveTextureUnit(t){this._activeTextureUnit!==t&&(this._activeTextureUnit=t,this.gl.activeTexture(t))}setClearColor(t){Cs(t,this._clearColor)||(this._clearColor=Dt(t),this.applyClearColor())}setDrawBuffers(t,e){let i=t.length!==this._drawBuffers.length;if(!i){for(let r=0,s=t.length;r<s;++r)if(this._drawBuffers[r]!==t[r]){i=!0;break}}if(i){if(this.glProxy.extensions.drawBuffers instanceof WebGL2RenderingContext)e||this.glProxy.extensions.drawBuffers.drawBuffers(t);else if(this.glProxy.extensions.drawBuffers)e||this.glProxy.extensions.drawBuffers.drawBuffersWEBGL(t);else{console.warn("Attempted to use drawBuffers for MRT, but MRT is NOT supported by this hardware. Use multiple render targets instead");return}this._drawBuffers=t}}setProxy(t){this.glProxy=t}setScissor(t){t?(this._scissorTestEnabled||(this._scissorTestEnabled=!0,this.gl.enable(this.gl.SCISSOR_TEST)),(t.x!==this._scissorBounds.x||t.y!==this._scissorBounds.y||t.width!==this._scissorBounds.width||t.height!==this._scissorBounds.height)&&(this._scissorBounds=t,this.applyScissorBounds())):this._scissorTestEnabled&&(this._scissorTestEnabled=!1,this.gl.disable(this.gl.SCISSOR_TEST))}setViewport(t,e,i,r){(t!==this._viewport.x||e!==this._viewport.y||i!==this._viewport.width||r!==this._viewport.height)&&(this._viewport={x:t,y:e,width:i,height:r},this.applyViewport())}useProgram(t){this._currentProgram!==t&&(this._currentProgram=t,this.gl.useProgram(this._currentProgram))}useMaterial(t){if(!t.gl&&(!this.glProxy.compileMaterial(t)||!t.gl)||!t.gl.programId||t.gl.programId.length===0)return Et.INVALID;const e=this.findMaterialProgram(t);if(e===void 0)return console.warn("Could NOT determine a program for the given material that would appropriately match with the current RenderTarget"),Et.NO_RENDER_TARGET_MATCHES;if(this._renderTarget&&(t.gl.programByTarget.set(this._renderTarget,e),this.glProxy.extensions.drawBuffers)){const i=t.gl.outputsByProgram.get(e),r=this._renderTarget.getGLBuffers();if(!i||!r)return console.warn("Could not establish the buffers to utilize for the render target"),Et.NO_RENDER_TARGET_MATCHES;const s=[];for(let a=0,o=r.length;a<o;++a){const c=r[a];i.find(u=>(c==null?void 0:c.outputType)===u)===void 0?s.push(this.gl.NONE):this._renderTarget.disabledTargets.has((c==null?void 0:c.outputType)||0)?s.push(this.gl.NONE):s.push((c==null?void 0:c.attachment)||this.gl.NONE)}this.setDrawBuffers(s)}return this.useProgram(e),this.syncMaterial(t),Et.VALID}findMaterialProgram(t){if(!t.gl)return;if(!this._renderTarget||this._renderTarget.isColorTarget()){let o;if(this._renderTarget&&(o=t.gl.programByTarget.get(this._renderTarget),o!==void 0))return o;let c=Number.MAX_SAFE_INTEGER;for(let l=0,u=t.gl.programId.length;l<u;++l){const d=t.gl.programId[l];d.outputTypes.length<c&&d.outputTypes.indexOf(H.COLOR)>=0&&(o=d.id,c=d.outputTypes.length)}return o||(o=t.gl.programId[t.gl.programId.length-1]),o}let e=t.gl.programByTarget.get(this._renderTarget);if(e!==void 0)return e;const i=new Set,r=this._renderTarget.getBuffers();for(let o=0,c=r.length;o<c;++o){const l=r[o];l&&i.add(l.outputType)}let s=0,a=[];for(let o=0,c=t.gl.programId.length;o<c;++o){const l=t.gl.programId[o];let u=0;for(let d=0,p=l.outputTypes.length;d<p;++d){const g=l.outputTypes[d];i.has(g)&&u++}u>s?(s=u,a=[l]):u===s&&a.push(l)}if(a.length!==0)return a.length===1?e=a[0].id:a.length>1&&(e=a.reduce((o,c)=>c.outputTypes.length<o.outputTypes.length?c:o)),e}useRenderTarget(t){return t?t.gl?(this.bindFBO(t.gl.fboId),this._renderTarget=t,!0):!1:(this.bindFBO(null),this._renderTarget=null,!0)}syncMaterial(t){return this.setDepthMask(t.depthWrite),this.setDepthTest(t.depthTest),this.setDepthFunc(t.depthFunc),this.setBlending(t.blending),this.setCullFace(t.culling),this.setColorMask(t.colorWrite),this.setDithering(t.dithering),this._currentUniforms=t.uniforms,!(!this._currentProgram||(Object.entries(t.uniforms).forEach(([e,i])=>{if(!this._currentProgram)return;i.gl||(i.gl=new Map);let r=i.gl.get(this._currentProgram);if(!r){const s=this.gl.getUniformLocation(this._currentProgram,e);if(!s){r={location:void 0},ou(this.debugContext,`A Material specified a uniform ${e}, but none was found in the current program.`);return}r={location:s},i.gl.set(this._currentProgram,r)}r.location&&this.uploadUniform(r.location,i)}),this._textureWillBeUsed.size>0&&!this.applyUsedTextures()))}setDepthMask(t){this._depthMask!==t&&(this._depthMask=t,this.gl.depthMask(this._depthMask))}setDepthTest(t){this._depthTestEnabled!==t&&(this._depthTestEnabled=t,this._depthTestEnabled?this.gl.enable(this.gl.DEPTH_TEST):this.gl.disable(this.gl.DEPTH_TEST))}setDepthFunc(t){this._depthFunc!==t&&(this._depthFunc=t,this.applyDepthFunc())}setBlending(t){t?(this._blendingEnabled||(this.gl.enable(this.gl.BLEND),this._blendingEnabled=!0),(this._blendDstFactor!==t.blendDst||this._blendSrcFactor!==t.blendSrc||this._blendEquation!==t.blendEquation)&&(this._blendDstFactor=t.blendDst||this._blendDstFactor,this._blendSrcFactor=t.blendSrc||this._blendSrcFactor,this._blendEquation=t.blendEquation||this._blendEquation,this.applyBlendFactors())):this._blendingEnabled&&(this.gl.disable(this.gl.BLEND),this._blendingEnabled=!1)}setDithering(t){this._ditheringEnabled!==t&&(this._ditheringEnabled=t,this._ditheringEnabled?this.gl.enable(this.gl.DITHER):this.gl.disable(this.gl.DITHER))}setColorMask(t){(this._colorMask[0]!==t[0]||this._colorMask[1]!==t[1]||this._colorMask[2]!==t[2]||this._colorMask[3]!==t[3])&&(this._colorMask=t,this.applyColorMask())}setCullFace(t){this._cullFace!==t&&(this._cullFace=t,this.applyCullFace())}uploadUniform(t,e){let i;switch(e.type){case Se.FLOAT:i=e.data,this.gl.uniform1f(t,i);break;case Se.VEC2:i=e.data,this.gl.uniform2f(t,i[0],i[1]);break;case Se.VEC3:i=e.data,this.gl.uniform3f(t,i[0],i[1],i[2]);break;case Se.VEC4:i=e.data,this.gl.uniform4f(t,i[0],i[1],i[2],i[3]);break;case Se.VEC4_ARRAY:i=e.data,this.gl.uniform4fv(t,Ls(i));break;case Se.MATRIX3x3:i=e.data,this.gl.uniformMatrix3fv(t,!1,i);break;case Se.MATRIX4x4:i=e.data,this.gl.uniformMatrix4fv(t,!1,i);break;case Se.FLOAT_ARRAY:i=e.data,this.gl.uniform1fv(t,i);break;case Se.TEXTURE:i=e.data,this.willUseTextureUnit(i,t);break;default:console.warn(this.debugContext,"A uniform specified an unrecognized type. It will not sync with the GPU:",e)}}applyUsedTextures(){const t=this.assignTextureUnits(Array.from(this._textureWillBeUsed.keys()));t.forEach(r=>{r.gl?r.gl.textureUnit=this.gl.TEXTURE0:r.gl={textureId:null,textureUnit:this.gl.TEXTURE0,proxy:this.glProxy}});const e=new Map,i=new Set;return this._textureWillBeUsed.forEach((r,s)=>{r instanceof Yn?i.add(r):e.set(s,r)}),i.forEach(r=>{r.getTextures().some(o=>{if(t.indexOf(o)<0)this.glProxy.updateTexture(o);else return!0;return!1})?console.warn(this.debugContext,"A RenderTarget can not be used because all of it's textures could not be compiled."):this.glProxy.compileRenderTarget(r)}),e.forEach((r,s)=>{t.indexOf(s)<0?(this.glProxy.updateTexture(s),r.forEach(a=>{this.uploadTextureToUniform(a,s)})):r.forEach(a=>{this.gl.uniform1i(a,$o(this.gl,0))})}),this._textureWillBeUsed.clear(),!0}assignTextureUnits(t){const e=[],i=[];for(t.forEach(a=>{!a.gl||a.gl.textureUnit<0?e.push(a):i.push(a)});this._freeUnits.length>0&&e.length>0;){const a=e.shift();if(!a)continue;const o=this._freeUnits.shift();if(o===void 0){e.unshift(a);continue}a.gl?a.gl.textureUnit=o:a.gl={textureId:null,textureUnit:o,proxy:this.glProxy},i.push(a)}if(e.length<=0)return e;ou("WARNING: Too many textures in use are causing texture units to be swapped. Doing this occasionally is fine, but handling this on a frame loop can have serious performance concerns.");const r=new Map;this._textureUnitToTexture.forEach(a=>{a&&r.set(a,!1)}),i.forEach(a=>{r.set(a,!0)});const s=[];if(r.forEach((a,o)=>{a||s.push(o)}),s.length===0)return console.warn(this.debugContext,"There are too many textures being used for a single draw call. These textures will not be utilized on the GPU",e),console.warn("Current GL State:",this),e;for(;s.length>0&&e.length>0;){const a=e.shift();if(!a)continue;const o=s.shift();if(o===void 0||!o.gl||o.gl.textureUnit<0){e.unshift(a);continue}a.gl?a.gl.textureUnit=o.gl.textureUnit:a.gl={textureId:null,textureUnit:o.gl.textureUnit,proxy:this.glProxy},i.push(a)}return e.length>0&&(console.error(this.debugContext,"There are too many textures being used for a single draw call. These textures will not be utilized on the GPU",e),console.warn("Current GL State:",this)),e}uploadTextureToUniform(t,e){e.gl&&e.gl.textureUnit>=0?this.gl.uniform1i(t,$o(this.gl,e.gl.textureUnit)):console.warn(this.debugContext,"Attempted to set a Texture Object to a uniform, but the Texture object did not have a valid texture unit.",e)}willUseTextureUnit(t,e){const i=this._textureWillBeUsed.get(t);e instanceof Yn?i?i instanceof Yn&&i!==e&&console.warn(this.debugContext,"A Texture is attempting to be used by two different render targets in a single draw."):this._textureWillBeUsed.set(t,e):i?i instanceof Yn?console.warn(this.debugContext,"A texture in a single draw is attempting to attach to a uniform AND a render target which is invalid."):i.add(e):this._textureWillBeUsed.set(t,new Set([e]))}syncState(){const t=this.gl;this._blendingEnabled?t.enable(t.BLEND):t.disable(t.BLEND),this._ditheringEnabled?t.enable(t.DITHER):t.disable(t.DITHER),this._depthTestEnabled?t.enable(t.DEPTH_TEST):t.disable(t.DEPTH_TEST),this._scissorTestEnabled?t.enable(t.SCISSOR_TEST):t.disable(t.SCISSOR_TEST),this.setActiveTextureUnit(this._activeTextureUnit),this.applyClearColor(),this.applyCullFace(),this.applyBlendFactors(),this.applyBlendEquation(),this.applyColorMask(),this.applyDepthFunc(),this.applyScissorBounds(),this.applyViewport(),t.depthMask(this._depthMask)}applyClearColor(){this.gl.clearColor(this._clearColor[0],this._clearColor[1],this._clearColor[2],this._clearColor[3])}applyDepthFunc(){const t=this.gl;switch(this._depthFunc){case h.GLSettings.Material.DepthFunctions.ALWAYS:t.depthFunc(t.ALWAYS);break;case h.GLSettings.Material.DepthFunctions.EQUAL:t.depthFunc(t.EQUAL);break;case h.GLSettings.Material.DepthFunctions.GREATER:t.depthFunc(t.GREATER);break;case h.GLSettings.Material.DepthFunctions.GREATER_OR_EQUAL:t.depthFunc(t.GEQUAL);break;case h.GLSettings.Material.DepthFunctions.LESS:t.depthFunc(t.LESS);break;case h.GLSettings.Material.DepthFunctions.LESS_OR_EQUAL:t.depthFunc(t.LEQUAL);break;case h.GLSettings.Material.DepthFunctions.NEVER:t.depthFunc(t.NEVER);break;case h.GLSettings.Material.DepthFunctions.NOTEQUAL:t.depthFunc(t.NOTEQUAL);break;default:t.depthFunc(t.ALWAYS);break}}applyScissorBounds(){this.gl.scissor(this._scissorBounds.x,this._scissorBounds.y,this._scissorBounds.width,this._scissorBounds.height)}applyColorMask(){this.gl.colorMask(this.colorMask[0]||!1,this.colorMask[1]||!1,this.colorMask[2]||!1,this.colorMask[3]||!1)}applyBlendEquation(){const t=this.gl;switch(this._blendEquation){case h.GLSettings.Material.BlendingEquations.Add:t.blendEquation(t.FUNC_ADD);break;case h.GLSettings.Material.BlendingEquations.Subtract:t.blendEquation(t.FUNC_SUBTRACT);break;case h.GLSettings.Material.BlendingEquations.ReverseSubtract:t.blendEquation(t.FUNC_REVERSE_SUBTRACT);break}}applyBlendFactors(){const t=this.gl;let e,i;switch(this._blendDstFactor){case h.GLSettings.Material.BlendingDstFactor.DstAlpha:e=t.BLEND_DST_ALPHA;break;case h.GLSettings.Material.BlendingDstFactor.DstColor:e=t.BLEND_DST_RGB;break;case h.GLSettings.Material.BlendingDstFactor.One:e=t.ONE;break;case h.GLSettings.Material.BlendingDstFactor.OneMinusDstAlpha:e=t.ONE_MINUS_DST_ALPHA;break;case h.GLSettings.Material.BlendingDstFactor.OneMinusDstColor:e=t.ONE_MINUS_DST_COLOR;break;case h.GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha:e=t.ONE_MINUS_SRC_ALPHA;break;case h.GLSettings.Material.BlendingDstFactor.OneMinusSrcColor:e=t.ONE_MINUS_SRC_COLOR;break;case h.GLSettings.Material.BlendingDstFactor.SrcAlpha:e=t.SRC_ALPHA;break;case h.GLSettings.Material.BlendingDstFactor.SrcColor:e=t.SRC_COLOR;break;case h.GLSettings.Material.BlendingDstFactor.Zero:e=t.ZERO;break;default:e=t.ONE;break}switch(this._blendSrcFactor){case h.GLSettings.Material.BlendingDstFactor.DstAlpha:i=t.BLEND_DST_ALPHA;break;case h.GLSettings.Material.BlendingDstFactor.DstColor:i=t.BLEND_DST_RGB;break;case h.GLSettings.Material.BlendingDstFactor.One:i=t.ONE;break;case h.GLSettings.Material.BlendingDstFactor.OneMinusDstAlpha:i=t.ONE_MINUS_DST_ALPHA;break;case h.GLSettings.Material.BlendingDstFactor.OneMinusDstColor:i=t.ONE_MINUS_DST_COLOR;break;case h.GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha:i=t.ONE_MINUS_SRC_ALPHA;break;case h.GLSettings.Material.BlendingDstFactor.OneMinusSrcColor:i=t.ONE_MINUS_SRC_COLOR;break;case h.GLSettings.Material.BlendingDstFactor.SrcAlpha:i=t.SRC_ALPHA;break;case h.GLSettings.Material.BlendingDstFactor.SrcColor:i=t.SRC_COLOR;break;case h.GLSettings.Material.BlendingDstFactor.Zero:i=t.ZERO;break;case h.GLSettings.Material.BlendingSrcFactor.SrcAlphaSaturate:i=t.SRC_ALPHA_SATURATE;break;default:i=t.ONE;break}t.blendFunc(i,e)}applyCullFace(){const t=this.gl;switch(this._cullFace!==h.GLSettings.Material.CullSide.NONE&&t.enable(t.CULL_FACE),this._cullFace){case h.GLSettings.Material.CullSide.CW:t.frontFace(t.CW),t.cullFace(t.FRONT);break;case h.GLSettings.Material.CullSide.CCW:t.frontFace(t.CCW),t.cullFace(t.FRONT);break;case h.GLSettings.Material.CullSide.BOTH:t.frontFace(t.CW),t.cullFace(t.FRONT_AND_BACK);break;default:t.disable(t.CULL_FACE)}}applyViewport(){this.gl.viewport(this._viewport.x,this._viewport.y,this._viewport.width,this._viewport.height)}}class Lr{constructor(t){f(this,"blending",{blendDst:h.GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha,blendEquation:h.GLSettings.Material.BlendingEquations.Add,blendSrc:h.GLSettings.Material.BlendingSrcFactor.SrcAlpha});f(this,"colorWrite",[!0,!0,!0,!0]);f(this,"culling",h.GLSettings.Material.CullSide.CCW);f(this,"depthFunc",h.GLSettings.Material.DepthFunctions.LESS_OR_EQUAL);f(this,"depthTest",!0);f(this,"depthWrite",!0);f(this,"dithering",!0);f(this,"fragmentShader");f(this,"gl");f(this,"name","");f(this,"polygonOffset");f(this,"uniforms",{});f(this,"vertexShader","");Object.assign(this,t),delete this.gl}clone(){const t=new Lr(this);t.blending=Object.assign({},this.blending),t.polygonOffset=Object.assign({},this.polygonOffset),t.uniforms=Object.assign({},this.uniforms);for(const e in t.uniforms){const i=t.uniforms[e];if(i.gl){const r=new Map;i.gl.forEach((s,a)=>{r.set(a,Object.assign({},s))})}}return t}dispose(){this.gl&&this.gl.proxy.disposeMaterial(this)}}class Ko{constructor(t,e,i){f(this,"id");f(this,"drawMode",h.GLSettings.Model.DrawMode.TRIANGLES);f(this,"vertexDrawRange",[-1,-1]);f(this,"drawInstances",-1);f(this,"geometry");f(this,"material");f(this,"vertexCount",0);this.id=t,this.geometry=e,this.material=i}}class Vs{constructor(){f(this,"models",new Set)}add(t){this.models.add(t)}remove(t){this.models.delete(t)}}const lu=Ie("performance");class uu{constructor(t){f(this,"_gl");f(this,"glProxy");f(this,"glState");f(this,"options");f(this,"state",{clearMask:[!1,!1,!1],currentRenderTarget:null,displaySize:[1,1],pixelRatio:1,renderSize:[1,1]});this.options=Object.assign({alpha:!1,antialias:!1,preserveDrawingBuffer:!1},t),this.options.canvas||console.warn("WebGLRenderer ERROR: A canvas is REQUIRED as a parameter."),this.getContext()}set debugContext(t){this.glProxy&&(this.glProxy.debugContext=t),this.glState&&(this.glState.debugContext=t)}get gl(){return this._gl}clear(t,e,i){const r=this.state.clearMask;this.state.clearMask=[r[0]||t||!1,r[1]||e||!1,r[2]||i||!1]}clearColor(t){t&&this.glState.setClearColor(t)}dispose(){}getContext(){if(this._gl)return this._gl;const t=Cr.getContext(this.options.canvas,{alpha:this.options.alpha||!1,antialias:this.options.antialias||!1,premultipliedAlpha:this.options.premultipliedAlpha||!1,preserveDrawingBuffer:this.options.preserveDrawingBuffer||!1});return t.context?(this._gl=t.context,this.glState=new cu(t.context,t.extensions),this.glProxy=new Cr(t.context,this.glState,t.extensions),this.glState.setProxy(this.glProxy),this.glState.syncState()):this.options.onNoContext?this.options.onNoContext():console.warn("No context was able to be produced, and the handler onNoContext was not implemented for such cases."),this._gl}getDisplaySize(){return this.state.displaySize}getPixelRatio(){return this.state.pixelRatio}getRenderSize(){return this.state.renderSize}getFullViewport(){const t=this.state.currentRenderTarget;if(Array.isArray(t))return{x:0,y:0,width:t[0].width,height:t[0].height};if(t)return{x:0,y:0,width:t.width,height:t.height};{const e=this.getRenderSize();return{x:0,y:0,width:e[0],height:e[1]}}}prepareAttribute(t,e,i){if(this.glProxy.updateAttribute(e))(!t.gl||!t.gl.vao)&&this.glProxy.useAttribute(i,e,t);else return console.warn("Could not update attribute",e),!1;return!0}prepareIndexBuffer(t,e){if(this.glProxy.updateIndexBuffer(e)){if(!t.gl||!t.gl.vao)return this.glProxy.useIndexBuffer(e)}else return console.warn("Could not update index buffer",e),!1;return!0}render(t,e=null,i){if(!this.gl)return;this.setRenderTarget(e);const r=[];if(e&&!Array.isArray(e)&&(N.MRT||N.MRT_EXTENSION)){const a=e.getGLBuffers();this.glState.setDrawBuffers(a.map(o=>(o==null?void 0:o.attachment)||0))}const s=this.state.clearMask;if((s[0]||s[1]||s[2])&&(this.glProxy.clear(s[0],s[1],s[2]),this.state.clearMask=[!1,!1,!1]),Array.isArray(e))for(let a=0,o=e.length;a<o;++a){const c=e[a];if(this.glState.useRenderTarget(c),c&&!c.gl)return;t.models.forEach(l=>{this.renderModel(l,r,i)})}else{if(e&&!e.gl)return;t.models.forEach(a=>{this.renderModel(a,r,i)})}r.forEach(a=>{t.remove(a)})}renderModel(t,e,i){var o;const r=t.geometry,s=t.material;switch(this.glState.useMaterial(s)){case Et.VALID:{this.glProxy.compileGeometry(r);let c=!0;const l=(u,d)=>{c=this.prepareAttribute(r,u,d)&&c};r.attributes.forEach(l),r.indexBuffer&&(c=this.prepareIndexBuffer(r,r.indexBuffer)&&c),(o=r.gl)!=null&&o.vao?this.glState.bindVAO(r.gl.vao):this.glState.applyVertexAttributeArrays(),i==null||i(this.glState,t.id),c?this.glProxy.draw(t):(console.warn("Geometry was unable to update correctly, thus we are skipping the drawing of",t),e.push(t)),this.glState.bindVAO(null);break}case Et.INVALID:{console.warn("Could not utilize material. Skipping draw call for:",s,r),e.push(t);break}case Et.NO_RENDER_TARGET_MATCHES:{lu("Skipped draw for material due to no output matches for the current render target");break}default:lu("Skipped draw for material due to unknown reasons");break}}readPixels(t,e,i,r,s,a=0){if(!this.gl)return;const o=this.state.currentRenderTarget;let c=!0,l;if(Array.isArray(o))l=o.find(u=>{var d;return Array.isArray(u.buffers.color)?u.buffers.color.find(p=>p.outputType===a):((d=u.buffers.color)==null?void 0:d.outputType)===a});else if(o&&Array.isArray(o==null?void 0:o.buffers.color)){if(o.buffers.color.length>1){console.warn("It is not yet implemented to read the pixels from a RenderTarget with multiple color buffers");return}l=o}else l=o;if(l&&(c=l.validFramebuffer),!c){console.warn("Framebuffer is incomplete. Can not read pixels at this time.");return}if(t=Math.max(0,t),e=Math.max(0,e),l){t+i>l.width&&(i=l.width-t),e+r>l.height&&(r=l.height-e);const u=l.height;this.gl.readPixels(t,u-e-r,i,r,this.gl.RGBA,this.gl.UNSIGNED_BYTE,s)}else{const u=this.getRenderSize(),d=u[1];t+i>u[0]&&(i=u[0]-t),e+r>u[1]&&(r=u[1]-e),this.gl.readPixels(t,d-e-r,i,r,this.gl.RGBA,this.gl.UNSIGNED_BYTE,s)}}setClearColor(t){this.glState.setClearColor(t)}setPixelRatio(t){const{canvas:e}=this.options,i=this.getDisplaySize();e.width=i[0]*t,e.height=i[1]*t,this.state.pixelRatio=t}setScissor(t,e){if(e=e||this.state.currentRenderTarget||null,Array.isArray(e)){const i=e[0].height;if(t){const{x:r,y:s,width:a,height:o}=t;this.glState.setScissor({x:r,y:i-s-o,width:a,height:o})}else this.glState.setScissor(null)}else if(e){const i=e.height;if(t){const{x:r,y:s,width:a,height:o}=t;this.glState.setScissor({x:r,y:i-s-o,width:a,height:o})}else this.glState.setScissor(null)}else{const{renderSize:i}=this.state,r=i[1];if(t){const{x:s,y:a,width:o,height:c}=t;this.glState.setScissor({x:s,y:r-a-c,width:o,height:c})}else this.glState.setScissor(null)}}setSize(t,e){const{canvas:i}=this.options,{pixelRatio:r}=this.state;i.width=Math.min(t*r,N.MAX_TEXTURE_SIZE),i.height=Math.min(e*r,N.MAX_TEXTURE_SIZE),i.style.width=`${t}px`,i.style.height=`${e}px`,this.state.renderSize=[i.width,i.height],this.state.displaySize=[t,e]}setRenderTarget(t){this.state.currentRenderTarget!==t&&(Array.isArray(t)?t.forEach(e=>{e.gl||this.glProxy.compileRenderTarget(e)}):!this.glState.useRenderTarget(t)&&t&&(t.getTextures().forEach(e=>{this.glState.willUseTextureUnit(e,t)}),this.glState.applyUsedTextures(),this.glProxy.compileRenderTarget(t)&&this.glState.useRenderTarget(t)),this.state.currentRenderTarget=t)}setViewport(t){const e=this.state.currentRenderTarget,{x:i,y:r,width:s,height:a}=t;if(Array.isArray(e)){const o=e[0].height;this.glState.setViewport(i,o-r-a,s,a)}else if(e){const o=e.height;this.glState.setViewport(i,o-r-a,s,a)}else{const{renderSize:o}=this.state,c=o[1];this.glState.setViewport(i,c-r-a,s,a)}}}var $s=!!(typeof window<"u"&&window.document&&window.document.createElement),hu={canUseDOM:$s,canUseWorkers:typeof Worker<"u",canUseEventListeners:$s&&!!(window.addEventListener||window.attachEvent),canUseViewport:$s&&!!window.screen,isInWorker:!$s},du;hu.canUseDOM&&(du=document.implementation&&document.implementation.hasFeature&&document.implementation.hasFeature("","")!==!0);/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */function jp(n,t){if(!hu.canUseDOM||t&&!("addEventListener"in document))return!1;var e="on"+n,i=e in document;if(!i){var r=document.createElement("div");r.setAttribute(e,"return;"),i=typeof r[e]=="function"}return!i&&du&&n==="wheel"&&(i=document.implementation.hasFeature("Events.wheel","3.0")),i}var fu=!1,wi,Zo,Jo,Ws,js,pu,Hs,ec,tc,nc,gu,ic,rc,mu,vu;function Je(){if(!fu){fu=!0;var n=navigator.userAgent,t=/(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(n),e=/(Mac OS X)|(Windows)|(Linux)/.exec(n);if(ic=/\b(iPhone|iP[ao]d)/.exec(n),rc=/\b(iP[ao]d)/.exec(n),nc=/Android/i.exec(n),mu=/FBAN\/\w+;/i.exec(n),vu=/Mobile/i.exec(n),gu=!!/Win64/.exec(n),t){wi=t[1]?parseFloat(t[1]):t[5]?parseFloat(t[5]):NaN,wi&&document&&document.documentMode&&(wi=document.documentMode);var i=/(?:Trident\/(\d+.\d+))/.exec(n);pu=i?parseFloat(i[1])+4:wi,Zo=t[2]?parseFloat(t[2]):NaN,Jo=t[3]?parseFloat(t[3]):NaN,Ws=t[4]?parseFloat(t[4]):NaN,Ws?(t=/(?:Chrome\/(\d+\.\d+))/.exec(n),js=t&&t[1]?parseFloat(t[1]):NaN):js=NaN}else wi=Zo=Jo=js=Ws=NaN;if(e){if(e[1]){var r=/(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(n);Hs=r?parseFloat(r[1].replace("_",".")):!0}else Hs=!1;ec=!!e[2],tc=!!e[3]}else Hs=ec=tc=!1}}var sc={ie:function(){return Je()||wi},ieCompatibilityMode:function(){return Je()||pu>wi},ie64:function(){return sc.ie()&&gu},firefox:function(){return Je()||Zo},opera:function(){return Je()||Jo},webkit:function(){return Je()||Ws},safari:function(){return sc.webkit()},chrome:function(){return Je()||js},windows:function(){return Je()||ec},osx:function(){return Je()||Hs},linux:function(){return Je()||tc},iphone:function(){return Je()||ic},mobile:function(){return Je()||ic||rc||nc||vu},nativeApp:function(){return Je()||mu},android:function(){return Je()||nc},ipad:function(){return Je()||rc}};const bu=10,wu=40,Tu=800;function ac(n){let t=0,e=0,i=0,r=0;return"detail"in n&&(e=n.detail),"wheelDelta"in n&&(e=-n.wheelDelta/120),"wheelDeltaY"in n&&(e=-n.wheelDeltaY/120),"wheelDeltaX"in n&&(t=-n.wheelDeltaX/120),"axis"in n&&n.axis===n.HORIZONTAL_AXIS&&(t=e,e=0),i=t*bu,r=e*bu,"deltaY"in n&&(r=n.deltaY),"deltaX"in n&&(i=n.deltaX),(i||r)&&n.deltaMode&&(n.deltaMode===1?(i*=wu,r*=wu):(i*=Tu,r*=Tu)),i&&!t&&(t=i<1?-1:1),r&&!e&&(e=r<1?-1:1),{spinX:t,spinY:-e,pixelX:i,pixelY:-r}}ac.getEventType=function(){return sc.firefox()?"DOMMouseScroll":jp("wheel")?"wheel":"mousewheel"};function Ft(n,t){let e=0,i=0,r=0,s=0,a=t||n.nativeEvent&&n.nativeEvent.target||n.target;if(n||(n=window.event),n.pageX||n.pageY)e=n.pageX,i=n.pageY;else if(n.clientX||n.clientY){let o=0,c=0;document.documentElement&&(o=document.documentElement.scrollLeft,c=document.documentElement.scrollTop),e=n.clientX+document.body.scrollLeft+o,i=n.clientY+document.body.scrollTop+c}if(a.offsetParent)do r+=a.offsetLeft,s+=a.offsetTop,a=a.offsetParent;while(a);return[e-r,i-s]}function de(n){return n!=null}function yu(n){return Array.isArray(n)?t=>n.indexOf(t.start.view.id)>=0:t=>t.start.view.id===n}function Eu(n){return Array.isArray(n)?t=>t.start.views.find(e=>n.indexOf(e.view.id)>=0):t=>t.start.views.find(e=>e.view.id===n)}class Xs{constructor(){f(this,"_uid",z());f(this,"id","");f(this,"pixelRatio",1);f(this,"viewBounds");f(this,"_screenScale",[1,1]);f(this,"_screenBounds");f(this,"_scaledScreenBounds")}get uid(){return this._uid}get screenBounds(){return this._scaledScreenBounds||(this._scaledScreenBounds=new ie({x:this._screenBounds.x*this._screenScale[0],y:this._screenBounds.y*this._screenScale[1],width:this._screenBounds.width*this._screenScale[0],height:this._screenBounds.height*this._screenScale[1]})),this._scaledScreenBounds}set screenBounds(t){delete this._scaledScreenBounds,this._screenBounds=t}get screenScale(){return this._screenScale}set screenScale(t){_s(t,this._screenScale)||(delete this._scaledScreenBounds,this._screenScale=t)}screenToRenderSpace(t,e){return e=this.screenToView(t,e),ge(e,t[0]*this.pixelRatio,t[1]*this.pixelRatio)}renderSpaceToScreen(t,e){return e=e||[0,0],ge(e,t[0]/this.pixelRatio-this.screenBounds.x,t[1]/this.pixelRatio-this.screenBounds.y)}screenToView(t,e){return e=e||[0,0],ge(e,t[0]-this.screenBounds.x,t[1]-this.screenBounds.y)}viewToScreen(t,e){return e=e||[0,0],ge(e,t[0]+this.screenBounds.x,t[1]+this.screenBounds.y)}}class _u extends Xs{screenToWorld(t,e){return t}screenRay(t){return[[0,0,-1],[0,0,-2]]}worldToScreen(t,e){return t}viewToWorld(t,e){return t}worldToView(t,e){return t}}const{cos:pt,sin:gt,tan:kt}=Math,mt=Math.PI/2,qn=0,Kn=1,Zn=2,Jn=3,Or=0,Nr=1,Pr=2,Dr=3,Br=4,Ur=5,Fr=6,kr=7,Gr=8,Gt=0,zt=1,Vt=2,$t=3,Wt=4,jt=5,Ht=6,Xt=7,Qt=8,Yt=9,qt=10,Kt=11,Zt=12,Jt=13,en=14,tn=15,Ti=new Array(20).fill(0).map(n=>nn()),ze=new Array(20).fill(0).map(n=>fe());function vt(n,t,e,i,r){return n=n||new Array(4),n[0]=t,n[1]=e,n[2]=i,n[3]=r,n}function et(n,t,e,i,r,s,a,o,c,l){return n=n||new Array(9),n[0]=t,n[1]=e,n[2]=i,n[3]=r,n[4]=s,n[5]=a,n[6]=o,n[7]=c,n[8]=l,n}function ye(n,t,e,i,r,s,a,o,c,l,u,d,p,g,m,v,b){return n=n||new Array(16),n[0]=t,n[1]=e,n[2]=i,n[3]=r,n[4]=s,n[5]=a,n[6]=o,n[7]=c,n[8]=l,n[9]=u,n[10]=d,n[11]=p,n[12]=g,n[13]=m,n[14]=v,n[15]=b,n}const xu=nn(),Ru=nn(),oc=nn(),Hp=nn();function be(n){return n[3]*n[0]-n[1]*n[2]}function yi(n){return n[0]*n[4]*n[8]-n[0]*n[5]*n[7]+n[1]*n[5]*n[6]-n[1]*n[3]*n[8]+n[2]*n[3]*n[7]-n[2]*n[4]*n[6]}function cc(n){return et(xu,n[5],n[6],n[7],n[9],n[10],n[11],n[13],n[14],n[15]),et(Ru,n[4],n[6],n[7],n[8],n[10],n[11],n[12],n[14],n[15]),et(oc,n[4],n[5],n[7],n[8],n[9],n[11],n[12],n[13],n[15]),et(oc,n[4],n[5],n[6],n[8],n[9],n[10],n[12],n[13],n[14]),n[0]*yi(xu)-n[1]*yi(Ru)+n[2]*yi(oc)-n[3]*yi(Hp)}function Au(n,t){const e=be(n);return e===0?null:vt(t,n[3]/e,-n[1]/e,-n[2]/e,n[0]/e)}function Iu(n,t){const e=yi(n);if(e===0)return null;const i=be([n[4],n[5],n[7],n[8]]),r=be([n[3],n[5],n[6],n[8]]),s=be([n[3],n[4],n[6],n[7]]),a=be([n[1],n[2],n[7],n[8]]),o=be([n[0],n[2],n[6],n[8]]),c=be([n[0],n[1],n[6],n[7]]),l=be([n[1],n[2],n[4],n[5]]),u=be([n[0],n[2],n[3],n[5]]),d=be([n[0],n[1],n[3],n[4]]);return et(t,i/e,-a/e,l/e,-r/e,o/e,u/e,s/e,-c/e,d/e)}function Su(n,t){const e=cc(n);if(e===0)return null;const i=be([n[0],n[1],n[4],n[5]]),r=be([n[0],n[2],n[4],n[6]]),s=be([n[0],n[3],n[4],n[7]]),a=be([n[1],n[2],n[5],n[6]]),o=be([n[1],n[3],n[5],n[7]]),c=be([n[2],n[3],n[6],n[7]]),l=be([n[10],n[11],n[14],n[15]]),u=be([n[9],n[11],n[13],n[15]]),d=be([n[9],n[10],n[13],n[14]]),p=be([n[8],n[11],n[12],n[15]]),g=be([n[8],n[10],n[12],n[14]]),m=be([n[8],n[9],n[12],n[13]]);return ye(t,(n[5]*l-n[6]*u+n[7]*d)/e,(-n[1]*l+n[2]*u-n[3]*d)/e,(n[12]*c-n[13]*o+n[14]*a)/e,(-n[9]*c+n[10]*o-n[11]*a)/e,(-n[4]*l+n[6]*p-n[7]*g)/e,(n[0]*l-n[2]*p+n[3]*g)/e,(-n[12]*c+n[14]*s-n[15]*r)/e,(n[8]*c-n[10]*s+n[11]*r)/e,(n[4]*u-n[5]*p+n[7]*m)/e,(-n[0]*u+n[1]*p-n[3]*m)/e,(n[12]*o-n[13]*s+n[15]*i)/e,(-n[8]*o+n[9]*s-n[11]*i)/e,(-n[4]*d+n[5]*g-n[6]*m)/e,(n[0]*d-n[1]*g+n[2]*m)/e,(-n[12]*a+n[13]*r-n[14]*i)/e,(n[8]*a-n[9]*r+n[10]*i)/e)}function Mu(n,t,e){return vt(e,n[0]*t,n[1]*t,n[2]*t,n[3]*t)}function Cu(n,t,e){return et(e,n[0]*t,n[1]*t,n[2]*t,n[3]*t,n[4]*t,n[5]*t,n[6]*t,n[7]*t,n[8]*t)}function Lu(n,t,e){return ye(e,n[0]*t,n[1]*t,n[2]*t,n[3]*t,n[4]*t,n[5]*t,n[6]*t,n[7]*t,n[8]*t,n[9]*t,n[10]*t,n[11]*t,n[12]*t,n[13]*t,n[14]*t,n[15]*t)}function zr(n){return vt(n,1,0,0,1)}function nn(n){return et(n,1,0,0,0,1,0,0,0,1)}function fe(n){return ye(n,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}function Ou(n,t,e){return vt(e,t[qn]*n[qn]+t[Kn]*n[Zn],t[qn]*n[Kn]+t[Kn]*n[Jn],t[Zn]*n[qn]+t[Jn]*n[Zn],t[Zn]*n[Kn]+t[Jn]*n[Jn])}function Nu(n,t,e){return et(e,t[0]*n[0]+t[1]*n[3]+t[2]*n[6],t[0]*n[1]+t[1]*n[4]+t[2]*n[7],t[0]*n[2]+t[1]*n[5]+t[2]*n[8],t[3]*n[0]+t[4]*n[3]+t[5]*n[6],t[3]*n[1]+t[4]*n[4]+t[5]*n[7],t[3]*n[2]+t[4]*n[5]+t[5]*n[8],t[6]*n[0]+t[7]*n[3]+t[8]*n[6],t[6]*n[1]+t[7]*n[4]+t[8]*n[7],t[6]*n[2]+t[7]*n[5]+t[8]*n[8])}function ot(n,t,e){return e=e||[],e[0]=t[0]*n[0]+t[1]*n[4]+t[2]*n[8]+t[3]*n[12],e[1]=t[0]*n[1]+t[1]*n[5]+t[2]*n[9]+t[3]*n[13],e[2]=t[0]*n[2]+t[1]*n[6]+t[2]*n[10]+t[3]*n[14],e[3]=t[0]*n[3]+t[1]*n[7]+t[2]*n[11]+t[3]*n[15],e[4]=t[4]*n[0]+t[5]*n[4]+t[6]*n[8]+t[7]*n[12],e[5]=t[4]*n[1]+t[5]*n[5]+t[6]*n[9]+t[7]*n[13],e[6]=t[4]*n[2]+t[5]*n[6]+t[6]*n[10]+t[7]*n[14],e[7]=t[4]*n[3]+t[5]*n[7]+t[6]*n[11]+t[7]*n[15],e[8]=t[8]*n[0]+t[9]*n[4]+t[10]*n[8]+t[11]*n[12],e[9]=t[8]*n[1]+t[9]*n[5]+t[10]*n[9]+t[11]*n[13],e[10]=t[8]*n[2]+t[9]*n[6]+t[10]*n[10]+t[11]*n[14],e[11]=t[8]*n[3]+t[9]*n[7]+t[10]*n[11]+t[11]*n[15],e[12]=t[12]*n[0]+t[13]*n[4]+t[14]*n[8]+t[15]*n[12],e[13]=t[12]*n[1]+t[13]*n[5]+t[14]*n[9]+t[15]*n[13],e[14]=t[12]*n[2]+t[13]*n[6]+t[14]*n[10]+t[15]*n[14],e[15]=t[12]*n[3]+t[13]*n[7]+t[14]*n[11]+t[15]*n[15],e}function Pu(n,...t){if(t.length<=0)return fe();if(n=n||fe(),t.length===1)return ji(t[0],n);let e=t[0],i=ze[ze.length-1],r=ze[ze.length-2];n===i&&(i=ze[ze.length-3]),n===r&&(r=ze[ze.length-3]);let s=i;for(let a=1,o=t.length-1;a<o;++a){const c=t[a];e=ot(e,c,s),s=s===i?r:i}return ot(e,t[t.length-1],n)}function Du(n,t,e){return vt(e,n[0]+t[0],n[1]+t[1],n[2]+t[2],n[3]+t[3])}function Bu(n,t,e){return et(e,n[0]+t[0],n[1]+t[1],n[2]+t[2],n[3]+t[3],n[4]+t[4],n[5]+t[5],n[6]+t[6],n[7]+t[7],n[8]+t[8])}function Uu(n,t,e){return ye(e,n[0]+t[0],n[1]+t[1],n[2]+t[2],n[3]+t[3],n[4]+t[4],n[5]+t[5],n[6]+t[6],n[7]+t[7],n[8]+t[8],n[9]+t[9],n[10]+t[10],n[11]+t[11],n[12]+t[12],n[13]+t[13],n[14]+t[14],n[15]+t[15])}function Fu(n,t,e){return vt(e,n[0]-t[0],n[1]-t[1],n[2]-t[2],n[3]-t[3])}function ku(n,t,e){return et(e,n[0]-t[0],n[1]-t[1],n[2]-t[2],n[3]-t[3],n[4]-t[4],n[5]-t[5],n[6]-t[6],n[7]-t[7],n[8]-t[8])}function Gu(n,t,e){return ye(e,n[0]-t[0],n[1]-t[1],n[2]-t[2],n[3]-t[3],n[4]-t[4],n[5]-t[5],n[6]-t[6],n[7]-t[7],n[8]-t[8],n[9]-t[9],n[10]-t[10],n[11]-t[11],n[12]-t[12],n[13]-t[13],n[14]-t[14],n[15]-t[15])}function zu(n,t,e){return vt(e,n[0]*t[0],n[1]*t[1],n[2]*t[2],n[3]*t[3])}function Vu(n,t,e){return et(e,n[0]*t[0],n[1]*t[1],n[2]*t[2],n[3]*t[3],n[4]*t[4],n[5]*t[5],n[6]*t[6],n[7]*t[7],n[8]*t[8])}function $u(n,t,e){return ye(e,n[0]*t[0],n[1]*t[1],n[2]*t[2],n[3]*t[3],n[4]*t[4],n[5]*t[5],n[6]*t[6],n[7]*t[7],n[8]*t[8],n[9]*t[9],n[10]*t[10],n[11]*t[11],n[12]*t[12],n[13]*t[13],n[14]*t[14],n[15]*t[15])}function Wu(n,t){return vt(t,n[0],n[2],n[1],n[3])}function Vr(n,t){return et(t,n[0],n[3],n[6],n[1],n[4],n[7],n[2],n[5],n[8])}function ju(n,t){return ye(t,n[0],n[4],n[8],n[12],n[1],n[5],n[9],n[13],n[2],n[6],n[10],n[14],n[3],n[7],n[11],n[15])}function Hu(n,t){return(n>=Math.PI/2||n<=-Math.PI/2)&&console.warn("A shear matrix can not have radians >= PI / 2 or <= -PI / 2"),t=t||zr(),vt(t,1,0,kt(n),1)}function Xu(n,t){return(n>=Math.PI/2||n<=-Math.PI/2)&&console.warn("A shear matrix can not have radians >= PI / 2 or <= -PI / 2"),t=t||zr(),vt(t,1,kt(n),0,1)}function Qu(n,t,e){(t>=mt||t<=-mt||n>=mt||n<=-mt)&&console.warn("A shear matrix can not have radians >= PI / 2 or <= -PI / 2"),e=e||fe();const i=kt(t),r=kt(n);return ye(e,1,0,0,0,r,1,0,0,i,0,1,0,0,0,0,1)}function Yu(n,t,e){(t>=mt||t<=-mt||n>=mt||n<=-mt)&&console.warn("A shear matrix can not have radians >= PI / 2 or <= -PI / 2"),e=e||fe();const i=kt(t),r=kt(n);return ye(e,1,r,0,0,0,1,0,0,0,i,1,0,0,0,0,1)}function qu(n,t,e){(t>=mt||t<=-mt||n>=mt||n<=-mt)&&console.warn("A shear matrix can not have radians >= PI / 2 or <= -PI / 2"),e=e||fe();const i=kt(t),r=kt(n);return ye(e,1,0,r,0,0,1,i,0,0,0,1,0,0,0,0,1)}function Ku(n,t,e){return ge(e,n[qn]*t[0]+n[Zn]*t[1],n[Kn]*t[0]+n[Jn]*t[1])}function Zu(n,t,e){return ve(e,n[Or]*t[0]+n[Dr]*t[1]+n[Fr]*t[2],n[Nr]*t[0]+n[Br]*t[1]+n[kr]*t[2],n[Pr]*t[0]+n[Ur]*t[1]+n[Gr]*t[2])}function Ju(n,t,e){return me(e,n[Gt]*t[0]+n[Wt]*t[1]+n[Qt]*t[2]+n[Zt]*1,n[zt]*t[0]+n[jt]*t[1]+n[Yt]*t[2]+n[Jt]*1,n[Vt]*t[0]+n[Ht]*t[1]+n[qt]*t[2]+n[en]*1,n[$t]*t[0]+n[Xt]*t[1]+n[Kt]*t[2]+n[tn]*1)}function $r(n,t,e){return me(e,n[Gt]*t[0]+n[Wt]*t[1]+n[Qt]*t[2]+n[Zt]*t[3],n[zt]*t[0]+n[jt]*t[1]+n[Yt]*t[2]+n[Jt]*t[3],n[Vt]*t[0]+n[Ht]*t[1]+n[qt]*t[2]+n[en]*t[3],n[$t]*t[0]+n[Xt]*t[1]+n[Kt]*t[2]+n[tn]*t[3])}function eh(n){return`Matrix: [
  ${n[0]}, ${n[1]},
  ${n[2]}, ${n[3]},
]`}function th(n){return`Matrix: [
  ${n[0]}, ${n[1]}, ${n[2]},
  ${n[3]}, ${n[4]}, ${n[5]},
  ${n[6]}, ${n[7]}, ${n[8]},
]`}function nh(n){return`Matrix: [
  ${n[0]}, ${n[1]}, ${n[2]}, ${n[3]},
  ${n[4]}, ${n[5]}, ${n[6]}, ${n[7]},
  ${n[8]}, ${n[9]}, ${n[10]}, ${n[11]},
  ${n[12]}, ${n[13]}, ${n[14]}, ${n[15]},
]`}function lc(n,t){t=t||new Array(4);const e=Math.cos(n),i=Math.sin(n);return t[qn]=e,t[Kn]=-i,t[Zn]=i,t[Jn]=e,t}function uc(n,t,e,i){if(n)if(t)if(e){const r=pt(n),s=pt(t),a=pt(e),o=gt(n),c=gt(t),l=gt(e);return ye(i,s*a,s*l,-c,0,o*c*a-r*l,o*c*l+r*a,o*s,0,r*c*a+o*l,r*c*l-o*a,r*s,0,0,0,0,1)}else{const r=pt(n),s=pt(t),a=gt(n),o=gt(t);return ye(i,s,0,-o,0,a*o,r,a*s,0,r*o,-a,r*s,0,0,0,0,1)}else if(e){const r=pt(n),s=pt(e),a=gt(n),o=gt(e);return ye(i,s,o,0,0,-r*o,r*s,a,0,a*o,-a*s,r,0,0,0,0,1)}else{const r=pt(n),s=gt(n);return ye(i,1,0,0,0,0,r,s,0,0,-s,r,0,0,0,0,1)}else if(t)if(e){const r=pt(t),s=pt(e),a=gt(t),o=gt(e);return ye(i,r*s,r*o,-a,0,-o,s,0,0,a*s,a*o,r,0,0,0,0,1)}else{const r=pt(t),s=gt(t);return ye(i,r,0,-s,0,0,1,0,0,s,0,r,0,0,0,0,1)}else if(e){const r=pt(e),s=gt(e);return ye(i,r,s,0,0,-s,r,0,0,0,0,1,0,0,0,0,1)}else return fe(i)}function ih(n,t){return uc(n[0],n[1],n[2],t)}function rh(n,t){return hc(n[0],n[1],n[2],t)}function hc(n,t,e,i){return ye(i,n,0,0,0,0,t,0,0,0,0,e,0,0,0,0,1)}function sh(n,t){return dc(n[0],n[1],n[2],t)}function dc(n,t,e,i){return ye(i,1,0,0,0,0,1,0,0,0,0,1,0,n,t,e,1)}function Qs(n,t,e,i,r,s,a){return a=a||fe(),ye(a,2*n/(i-e),0,0,0,0,2*n/(r-s),0,0,(i+e)/(i-e),(r+s)/(r-s),-(t+n)/(t-n),-1,0,0,-(2*t*n)/(t-n),0)}function fc(n,t,e,i,r,s){const a=e/t,o=kt(n/2)*i,c=-o,l=a*o,u=-l;return Qs(i,r,c,o,l,u,s)}function ah(n,t,e,i,r,s){const a=t/e,o=kt(n/2)*i,c=-o,l=a*o,u=-l;return Qs(i,r,u,l,o,c,s)}function pc(n,t,e,i,r,s,a){return ye(a,2/(t-n),0,0,0,0,2/(i-e),0,0,0,0,-1/(s-r),0,(t+n)/(n-t),(i+e)/(e-i),-r/(r-s),1)}function gc(n,t,e,i,r){return r=r||[0,0,0,0],$r(n,t,r),me(r,(r[0]/r[3]+1)*.5*e,(r[1]/r[3]+1)*.5*i,r[2]/r[3],1)}function Ys(n,t,e,i,r){return gc(n,[t[0],t[1],t[2],1],e,i,r)}function oh(n,t){return Math.abs(n[0]-t[0])<=1e-7&&Math.abs(n[1]-t[1])<=1e-7&&Math.abs(n[2]-t[2])<=1e-7&&Math.abs(n[3]-t[3])<=1e-7}function ch(n,t){return Math.abs(n[0]-t[0])<=1e-7&&Math.abs(n[1]-t[1])<=1e-7&&Math.abs(n[2]-t[2])<=1e-7&&Math.abs(n[3]-t[3])<=1e-7&&Math.abs(n[4]-t[4])<=1e-7&&Math.abs(n[5]-t[5])<=1e-7&&Math.abs(n[6]-t[6])<=1e-7&&Math.abs(n[7]-t[7])<=1e-7&&Math.abs(n[8]-t[8])<=1e-7}function mc(n,t){return Math.abs(n[0]-t[0])<=1e-7&&Math.abs(n[1]-t[1])<=1e-7&&Math.abs(n[2]-t[2])<=1e-7&&Math.abs(n[3]-t[3])<=1e-7&&Math.abs(n[4]-t[4])<=1e-7&&Math.abs(n[5]-t[5])<=1e-7&&Math.abs(n[6]-t[6])<=1e-7&&Math.abs(n[7]-t[7])<=1e-7&&Math.abs(n[8]-t[8])<=1e-7&&Math.abs(n[9]-t[9])<=1e-7&&Math.abs(n[10]-t[10])<=1e-7&&Math.abs(n[11]-t[11])<=1e-7&&Math.abs(n[12]-t[12])<=1e-7&&Math.abs(n[13]-t[13])<=1e-7&&Math.abs(n[14]-t[14])<=1e-7&&Math.abs(n[15]-t[15])<=1e-7}function lh(n){return[n[0],n[1],n[2],n[3]]}function uh(n){return[n[0],n[1],n[2],n[3],n[4],n[5],n[6],n[7],n[8]]}function ji(n,t){return t?(t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t):[n[0],n[1],n[2],n[3],n[4],n[5],n[6],n[7],n[8],n[9],n[10],n[11],n[12],n[13],n[14],n[15]]}function Wr(n,t,e,i){i=i||[];const[r,s,a]=n,[o,c,l]=e,[u,d,p,g,m,v,b,T,w]=t;i[Gt]=u*r,i[zt]=d*s,i[Vt]=p*a,i[$t]=0,i[Wt]=g*r,i[jt]=m*s,i[Ht]=v*a,i[Xt]=0,i[Qt]=b*r,i[Yt]=T*s,i[qt]=w*a,i[Kt]=0,i[Zt]=r*(u*o+g*c+b*l),i[Jt]=s*(d*o+m*c+T*l),i[en]=a*(p*o+v*c+w*l),i[tn]=1}function qs(n,t,e,i){i=i||[];const[r,s,a]=n,[o,c,l]=e,[u,d,p,g,m,v,b,T,w]=t;i[Gt]=u*r,i[zt]=d*r,i[Vt]=p*r,i[$t]=0,i[Wt]=g*s,i[jt]=m*s,i[Ht]=v*s,i[Xt]=0,i[Qt]=b*a,i[Yt]=T*a,i[qt]=w*a,i[Kt]=0,i[Zt]=o,i[Jt]=c,i[en]=l,i[tn]=1}function hh(n,t,e,i){i=i||[];const[r,s]=n,[a,o]=e,[c,l,u,d]=t;i[Gt]=c*r,i[zt]=l*s,i[Vt]=0,i[$t]=0,i[Wt]=u*r,i[jt]=d*s,i[Ht]=0,i[Xt]=0,i[Qt]=0,i[Yt]=0,i[qt]=1,i[Kt]=0,i[Zt]=r*(c*a+u*o),i[Jt]=s*(l*a+d*o),i[en]=0,i[tn]=1}function vc(n,t,e,i){i=i||[];const[r,s]=n,[a,o]=e,[c,l,u,d]=t;i[Gt]=c*r,i[zt]=l*r,i[Vt]=0,i[$t]=0,i[Wt]=u*s,i[jt]=d*s,i[Ht]=0,i[Xt]=0,i[Qt]=0,i[Yt]=0,i[qt]=1,i[Kt]=0,i[Zt]=a,i[Jt]=o,i[en]=0,i[tn]=1}const Xp=Object.freeze(Object.defineProperty({__proto__:null,Hadamard2x2:zu,Hadamard3x3:Vu,Hadamard4x4:$u,M200:qn,M201:Kn,M210:Zn,M211:Jn,M300:Or,M301:Nr,M302:Pr,M310:Dr,M311:Br,M312:Ur,M320:Fr,M321:kr,M322:Gr,M3R:Ti,M400:Gt,M401:zt,M402:Vt,M403:$t,M410:Wt,M411:jt,M412:Ht,M413:Xt,M420:Qt,M421:Yt,M422:qt,M423:Kt,M430:Zt,M431:Jt,M432:en,M433:tn,M4R:ze,SRT4x4:qs,SRT4x4_2D:vc,TRS4x4:Wr,TRS4x4_2D:hh,add2x2:Du,add3x3:Bu,add4x4:Uu,affineInverse2x2:Au,affineInverse3x3:Iu,affineInverse4x4:Su,apply2x2:vt,apply3x3:et,apply4x4:ye,compare2x2:oh,compare3x3:ch,compare4x4:mc,concat4x4:Pu,copy2x2:lh,copy3x3:uh,copy4x4:ji,determinant2x2:be,determinant3x3:yi,determinant4x4:cc,identity2:zr,identity3:nn,identity4:fe,multiply2x2:Ou,multiply3x3:Nu,multiply4x4:ot,multiplyScalar2x2:Mu,multiplyScalar3x3:Cu,multiplyScalar4x4:Lu,orthographic4x4:pc,perspective4x4:fc,perspectiveFOVY4x4:ah,perspectiveFrustum4x4:Qs,project3As4ToScreen:Ys,projectToScreen:gc,rotation2x2:lc,rotation4x4:uc,rotation4x4by3:ih,scale4x4:hc,scale4x4by3:rh,shearX2x2:Hu,shearX4x4:Qu,shearY2x2:Xu,shearY4x4:Yu,shearZ4x4:qu,subtract2x2:Fu,subtract3x3:ku,subtract4x4:Gu,toString2x2:eh,toString3x3:th,toString4x4:nh,transform2:Ku,transform3:Zu,transform3as4:Ju,transform4:$r,translation4x4:dc,translation4x4by3:sh,transpose2x2:Wu,transpose3x3:Vr,transpose4x4:ju},Symbol.toStringTag,{value:"Module"}));function bc(n,t){return!n||!t?n===t:!Object.keys(Object.assign({},n,t)).find(e=>n[e]!==t[e])}const{min:Qp,max:Yp,pow:dh,round:qp,sin:jr,PI:Hi}=Math,Hr=qp(Hi*1e3)/1e3;function ee(n,t,e){return Qp(Yp(n,t),e)}var rn=(n=>(n[n.NONE=1]="NONE",n[n.CONTINUOUS=4]="CONTINUOUS",n[n.REPEAT=2]="REPEAT",n[n.REFLECT=3]="REFLECT",n))(rn||{});const Kp=`
\${easingMethod} {
  return end;
}
`,Zp=`
\${easingMethod} {
  return (end - start) * t + start;
}
`,Jp=`
\${easingMethod} {
  float time = t * t;
  return (end - start) * time + start;
}
`,eg=`
\${easingMethod} {
  float time = t * (2.0 - t);
  return (end - start) * time + start;
}
`,tg=`
\${easingMethod} {
  float time = t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;
  return (end - start) * time + start;
}
`,ng=`
\${easingMethod} {
  float time = t * t * t;
  return (end - start) * time + start;
}
`,ig=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = t1 * t1 * t1 + 1.0;
  return (end - start) * time + start;
}
`,rg=`
\${easingMethod} {
  float time = t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0;
  return (end - start) * time + start;
}
`,sg=`
\${easingMethod} {
  float time = t * t * t * t;
  return (end - start) * time + start;
}
`,ag=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = 1.0 - t1 * t1 * t1 * t1;
  return (end - start) * time + start;
}
`,og=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = t < 0.5 ? 8.0 * t * t * t * t : 1.0 - 8.0 * t1 * t1 * t1 * t1;
  return (end - start) * time + start;
}
`,cg=`
\${easingMethod} {
  float time = t * t * t * t * t;
  return (end - start) * time + start;
}
`,lg=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = 1.0 + t1 * t1 * t1 * t1 * t1;
  return (end - start) * time + start;
}
`,ug=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = t < 0.5 ? 16.0 * t * t * t * t * t : 1.0 + 16.0 * t1 * t1 * t1 * t1 * t1;
  return (end - start) * time + start;
}
`,hg=`
\${easingMethod} {
  float p = 0.3;
  float time = pow(2.0, -10.0 * t) * sin((t - p / 4.0) * (2.0 * ${Hr}) / p) + 1.0;
  return (end - start) * time + start;
}
`,dg=`
\${easingMethod} {
  float time = t * t * t - t * 1.05 * sin(t * ${Hr});
  return (end - start) * time + start;
}
`,fg=`
\${easingMethod} {
  float t1 = t - 1.0;
  float a = 1.7;
  float time = (t1 * t1 * ((a + 1.0) * t1 + a) + 1.0);
  return (end - start) * time + start;
}
`,pg=`
\${easingMethod} {
  float a = 1.4;
  float a1 = a * 1.525;
  float t1 = t / 0.5;
  float t2 = t1 - 2.0;
  float time =
    (t1 < 1.0) ? 0.5 * (t1 * t1 * (a1 + 1.0) * t1 - a1) :
    0.5 * (t2 * t2 * ((a1 + 1.0) * t2 + a1) + 2.0)
  ;

  return (end - start) * time + start;
}
`,gg=`
\${easingMethod} {
  \${T} direction = end - start;
  return start + direction * 0.5 + direction * sin(t * ${Hr} * 2.0) * 0.5;
}
`,mg=`
\${easingMethod} {
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - t, t),
    vec2(sin((1.0 - t) * omega) / sinom, sin(t * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,vg=`
\${easingMethod} {
  float time = t * t;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,bg=`
\${easingMethod} {
  float time = t * (2.0 - t);
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,wg=`
\${easingMethod} {
  float time = t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,Tg=`
\${easingMethod} {
  float time = t * t * t;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,yg=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = t1 * t1 * t1 + 1.0;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,Eg=`
\${easingMethod} {
  float time = t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,_g=`
\${easingMethod} {
  float time = t * t * t * t;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,xg=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = 1.0 - t1 * t1 * t1 * t1;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,Rg=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = t < 0.5 ? 8.0 * t * t * t * t : 1.0 - 8.0 * t1 * t1 * t1 * t1;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,Ag=`
\${easingMethod} {
  float time = t * t * t * t * t;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,Ig=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = 1.0 + t1 * t1 * t1 * t1 * t1;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,Sg=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = t < 0.5 ? 16.0 * t * t * t * t * t : 1.0 + 16.0 * t1 * t1 * t1 * t1 * t1;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,Mg=`
\${easingMethod} {
  float p = 0.3;
  float time = pow(2.0, -10.0 * t) * sin((t - p / 4.0) * (2.0 * ${Hr}) / p) + 1.0;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,Cg=`
\${easingMethod} {
  float time = t * t * t - t * 1.05 * sin(t * ${Hr});
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,Lg=`
\${easingMethod} {
  float t1 = t - 1.0;
  float a = 1.7;
  float time = (t1 * t1 * ((a + 1.0) * t1 + a) + 1.0);
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,Og=`
\${easingMethod} {
  float a = 1.4;
  float a1 = a * 1.525;
  float t1 = t / 0.5;
  float t2 = t1 - 2.0;
  float time =
    (t1 < 1.0) ? 0.5 * (t1 * t1 * (a1 + 1.0) * t1 - a1) :
    0.5 * (t2 * t2 * ((a1 + 1.0) * t2 + a1) + 2.0)
  ;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`;class Ks{constructor(t,e,i,r){f(this,"uid",z());f(this,"cpu");f(this,"delay",0);f(this,"duration",500);f(this,"gpu");f(this,"loop",1);f(this,"methodName");this.cpu=t,this.gpu=e,this.duration=i||500,this.methodName=r||"easingMethod"}static immediate(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{const{copy:c}=G(r);return c(s,o)},delay:e,duration:t,gpu:Kp,loop:i,methodName:"immediate"}}static linear(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{const{add:c,scale:l,subtract:u}=G(r);return a=ee(a,0,1),c(l(u(s,r),a),r,o)},delay:e,duration:t,gpu:Zp,loop:i,methodName:"linear"}}static easeInQuad(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{a=ee(a,0,1);const c=a*a,{add:l,scale:u,subtract:d}=G(r);return l(u(d(s,r),c),r,o)},delay:e,duration:t,gpu:Jp,loop:i,methodName:"easeInQuad"}}static easeOutQuad(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{a=ee(a,0,1);const c=a*(2-a),{add:l,scale:u,subtract:d}=G(r);return l(u(d(s,r),c),r,o)},delay:e,duration:t,gpu:eg,loop:i,methodName:"easeOutQuad"}}static easeInOutQuad(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{a=ee(a,0,1);const c=a<.5?2*a*a:-1+(4-2*a)*a,{add:l,scale:u,subtract:d}=G(r);return l(u(d(s,r),c),r,o)},delay:e,duration:t,gpu:tg,loop:i,methodName:"easeInOutQuad"}}static easeInCubic(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{a=ee(a,0,1);const c=a*a*a,{add:l,scale:u,subtract:d}=G(r);return l(u(d(s,r),c),r,o)},delay:e,duration:t,gpu:ng,loop:i,methodName:"easeInCubic"}}static easeOutCubic(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{a=ee(a,0,1);const c=--a*a*a+1,{add:l,scale:u,subtract:d}=G(r);return l(u(d(s,r),c),r,o)},delay:e,duration:t,gpu:ig,loop:i,methodName:"easeOutCubic"}}static easeInOutCubic(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{a=ee(a,0,1);const c=a<.5?4*a*a*a:(a-1)*(2*a-2)*(2*a-2)+1,{add:l,scale:u,subtract:d}=G(r);return l(u(d(s,r),c),r,o)},delay:e,duration:t,gpu:rg,loop:i,methodName:"easeInOutCubic"}}static easeInQuart(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{a=ee(a,0,1);const c=a*a*a*a,{add:l,scale:u,subtract:d}=G(r);return l(u(d(s,r),c),r,o)},delay:e,duration:t,gpu:sg,loop:i,methodName:"easeInQuart"}}static easeOutQuart(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{a=ee(a,0,1);const c=1- --a*a*a*a,{add:l,scale:u,subtract:d}=G(r);return l(u(d(s,r),c),r,o)},delay:e,duration:t,gpu:ag,loop:i,methodName:"easeOutQuart"}}static easeInOutQuart(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{a=ee(a,0,1);const c=a<.5?8*a*a*a*a:1-8*--a*a*a*a,{add:l,scale:u,subtract:d}=G(r);return l(u(d(s,r),c),r,o)},delay:e,duration:t,gpu:og,loop:i,methodName:"easeInOutQuart"}}static easeInQuint(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{a=ee(a,0,1);const c=a*a*a*a*a,{add:l,scale:u,subtract:d}=G(r);return l(u(d(s,r),c),r,o)},delay:e,duration:t,gpu:cg,loop:i,methodName:"easeInQuint"}}static easeOutQuint(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{a=ee(a,0,1);const c=1+--a*a*a*a*a,{add:l,scale:u,subtract:d}=G(r);return l(u(d(s,r),c),r,o)},delay:e,duration:t,gpu:lg,loop:i,methodName:"easeOutQuint"}}static easeInOutQuint(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{a=ee(a,0,1);const c=a<.5?16*a*a*a*a*a:1+16*--a*a*a*a*a,{add:l,scale:u,subtract:d}=G(r);return l(u(d(s,r),c),r,o)},delay:e,duration:t,gpu:ug,loop:i,methodName:"easeInOutQuint"}}static easeOutElastic(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{a=ee(a,0,1);const c=.3,l=dh(2,-10*a)*jr((a-c/4)*(2*Hi)/c)+1,{add:u,scale:d,subtract:p}=G(r);return u(d(p(s,r),l),r,o)},delay:e,duration:t,gpu:hg,loop:i,methodName:"easeOutElastic"}}static easeBackIn(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{a=ee(a,0,1);const c=1.05,l=a*a*a-a*c*jr(a*Hi),{add:u,scale:d,subtract:p}=G(r);return u(d(p(s,r),l),r,o)},delay:e,duration:t,gpu:dg,loop:i,methodName:"easeBackIn"}}static easeBackOut(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{a=ee(a,0,1);const c=1.7,l=a-1,u=l*l*((c+1)*l+c)+1,{add:d,scale:p,subtract:g}=G(r);return d(p(g(s,r),u),r,o)},delay:e,duration:t,gpu:fg,loop:i,methodName:"easeBackOut"}}static easeBackInOut(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{a=ee(a,0,1);const l=1.7*1.525,u=a/.5,d=u-2,p=u<1?.5*(u*u*(l+1)*u-l):.5*(d*d*((l+1)*d+l)+2),{add:g,scale:m,subtract:v}=G(r);return g(m(v(s,r),p),r,o)},delay:e,duration:t,gpu:pg,loop:i,methodName:"easeBackInOut"}}static continuousSinusoidal(t,e=0,i=4){return{uid:z(),cpu:(r,s,a,o)=>{const{add:c,scale:l,subtract:u}=G(r);a=ee(a,0,1);const d=u(s,r),p=l(d,.5);return c(c(r,p),l(p,jr(a*Hi*2)*1),o)},delay:e,duration:t,gpu:gg,loop:i,methodName:"repeatingSinusoidal",validation:{ignoreEndValueCheck:!0,ignoreOverTimeCheck:!0}}}static slerpQuatLinear(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{if(!V(r)||!V(s)||!V(o)){const{vec:u}=G(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),u(1,0,0,0)}a=ee(a,0,1);const{slerpQuat:c,vec:l}=G(r);return c?c(r,s,a,o):l(1,0,0,0)},delay:e,duration:t,gpu:mg,loop:i,methodName:"slerpQuatLinear"}}static slerpQuatInQuad(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{if(!V(r)||!V(s)||!V(o)){const{vec:d}=G(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),d(1,0,0,0)}a=ee(a,0,1);const c=a*a,{slerpQuat:l,vec:u}=G(r);return l?l(r,s,c,o):u(1,0,0,0)},delay:e,duration:t,gpu:vg,loop:i,methodName:"slerpQuatInQuad"}}static slerpQuatOutQuad(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{if(!V(r)||!V(s)||!V(o)){const{vec:d}=G(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),d(1,0,0,0)}a=ee(a,0,1);const c=a*(2-a),{slerpQuat:l,vec:u}=G(r);return l?l(r,s,c,o):u(1,0,0,0)},delay:e,duration:t,gpu:bg,loop:i,methodName:"slerpQuatOutQuad"}}static slerpQuatInOutQuad(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{if(!V(r)||!V(s)||!V(o)){const{vec:d}=G(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),d(1,0,0,0)}a=ee(a,0,1);const c=a<.5?2*a*a:-1+(4-2*a)*a,{slerpQuat:l,vec:u}=G(r);return l?l(r,s,c,o):u(1,0,0,0)},delay:e,duration:t,gpu:wg,loop:i,methodName:"slerpQuatInOutQuad"}}static slerpQuatInCubic(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{if(!V(r)||!V(s)||!V(o)){const{vec:d}=G(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),d(1,0,0,0)}a=ee(a,0,1);const c=a*a*a,{slerpQuat:l,vec:u}=G(r);return l?l(r,s,c,o):u(1,0,0,0)},delay:e,duration:t,gpu:Tg,loop:i,methodName:"slerpQuatInCubic"}}static slerpQuatOutCubic(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{if(!V(r)||!V(s)||!V(o)){const{vec:d}=G(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),d(1,0,0,0)}a=ee(a,0,1);const c=--a*a*a+1,{slerpQuat:l,vec:u}=G(r);return l?l(r,s,c,o):u(1,0,0,0)},delay:e,duration:t,gpu:yg,loop:i,methodName:"slerpQuatOutCubic"}}static slerpQuatInOutCubic(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{if(!V(r)||!V(s)||!V(o)){const{vec:d}=G(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),d(1,0,0,0)}a=ee(a,0,1);const c=a<.5?4*a*a*a:(a-1)*(2*a-2)*(2*a-2)+1,{slerpQuat:l,vec:u}=G(r);return l?l(r,s,c,o):u(1,0,0,0)},delay:e,duration:t,gpu:Eg,loop:i,methodName:"slerpQuatInOutCubic"}}static slerpQuatInQuart(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{if(!V(r)||!V(s)||!V(o)){const{vec:d}=G(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),d(1,0,0,0)}a=ee(a,0,1);const c=a*a*a*a,{slerpQuat:l,vec:u}=G(r);return l?l(r,s,c,o):u(1,0,0,0)},delay:e,duration:t,gpu:_g,loop:i,methodName:"slerpQuatInQuart"}}static slerpQuatOutQuart(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{if(!V(r)||!V(s)||!V(o)){const{vec:d}=G(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),d(1,0,0,0)}a=ee(a,0,1);const c=1- --a*a*a*a,{slerpQuat:l,vec:u}=G(r);return l?l(r,s,c,o):u(1,0,0,0)},delay:e,duration:t,gpu:xg,loop:i,methodName:"slerpQuatOutQuart"}}static slerpQuatInOutQuart(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{if(!V(r)||!V(s)||!V(o)){const{vec:d}=G(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),d(1,0,0,0)}a=ee(a,0,1);const c=a<.5?8*a*a*a*a:1-8*--a*a*a*a,{slerpQuat:l,vec:u}=G(r);return l?l(r,s,c,o):u(1,0,0,0)},delay:e,duration:t,gpu:Rg,loop:i,methodName:"slerpQuatInOutQuart"}}static slerpQuatInQuint(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{if(!V(r)||!V(s)||!V(o)){const{vec:d}=G(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),d(1,0,0,0)}a=ee(a,0,1);const c=a*a*a*a*a,{slerpQuat:l,vec:u}=G(r);return l?l(r,s,c,o):u(1,0,0,0)},delay:e,duration:t,gpu:Ag,loop:i,methodName:"slerpQuatInQuint"}}static slerpQuatOutQuint(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{if(!V(r)||!V(s)||!V(o)){const{vec:d}=G(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),d(1,0,0,0)}a=ee(a,0,1);const c=1+--a*a*a*a*a,{slerpQuat:l,vec:u}=G(r);return l?l(r,s,c,o):u(1,0,0,0)},delay:e,duration:t,gpu:Ig,loop:i,methodName:"slerpQuatOutQuint"}}static slerpQuatInOutQuint(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{if(!V(r)||!V(s)||!V(o)){const{vec:d}=G(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),d(1,0,0,0)}a=ee(a,0,1);const c=a<.5?16*a*a*a*a*a:1+16*--a*a*a*a*a,{slerpQuat:l,vec:u}=G(r);return l?l(r,s,c,o):u(1,0,0,0)},delay:e,duration:t,gpu:Sg,loop:i,methodName:"slerpQuatInOutQuint"}}static slerpQuatOutElastic(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{if(!V(r)||!V(s)||!V(o)){const{vec:p}=G(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),p(1,0,0,0)}a=ee(a,0,1);const c=.3,l=dh(2,-10*a)*jr((a-c/4)*(2*Hi)/c)+1,{slerpQuat:u,vec:d}=G(r);return u?u(r,s,l,o):d(1,0,0,0)},delay:e,duration:t,gpu:Mg,loop:i,methodName:"slerpQuatOutElastic"}}static slerpQuatBackIn(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{if(!V(r)||!V(s)||!V(o)){const{vec:p}=G(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),p(1,0,0,0)}a=ee(a,0,1);const c=1.05,l=a*a*a-a*c*jr(a*Hi),{slerpQuat:u,vec:d}=G(r);return u?u(r,s,l,o):d(1,0,0,0)},delay:e,duration:t,gpu:Cg,loop:i,methodName:"slerpQuatBackIn"}}static slerpQuatBackOut(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{if(!V(r)||!V(s)||!V(o)){const{vec:g}=G(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),g(1,0,0,0)}a=ee(a,0,1);const c=1.7,l=a-1,u=l*l*((c+1)*l+c)+1,{slerpQuat:d,vec:p}=G(r);return d?d(r,s,u,o):p(1,0,0,0)},delay:e,duration:t,gpu:Lg,loop:i,methodName:"slerpQuatBackOut"}}static slerpQuatBackInOut(t,e=0,i=1){return{uid:z(),cpu:(r,s,a,o)=>{if(!V(r)||!V(s)||!V(o)){const{vec:v}=G(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),v(1,0,0,0)}a=ee(a,0,1);const l=1.7*1.525,u=a/.5,d=u-2,p=u<1?.5*(u*u*(l+1)*u-l):.5*(d*d*((l+1)*d+l)+2),{slerpQuat:g,vec:m}=G(r);return g?g(r,s,p,o):m(1,0,0,0)},delay:e,duration:t,gpu:Og,loop:i,methodName:"slerpQuatBackInOut"}}}const{cos:Xr,sin:ei,sqrt:ct,exp:fh,acos:wc,atan2:ph,PI:gh}=Math;let tt,sn,an,on,Pe,Ve,Xi,cn,nt,Le,Qi,Zs,Js,ti,k,_t,ea,Yi;const mh=Ee(),vh=Ee(),bh=Ee(),wh=Ee(),Th=1,yh=2,Eh=3,_h=0;function it(n,t,e){return n>e?e:n<t?t:n}function Ee(n){return n?(n[0]=0,n[1]=0,n[2]=0,n[3]=0,n):[0,0,0,0]}function xh(n,t,e){return e=e||Ee(),e[0]=n[0]+t[0],e[1]=n[1]+t[1],e[2]=n[2]+t[2],e[3]=n[3]+t[3],e}function Tc(n,t,e){e=e||Ee();const i=n[0],r=t[0],s=n[1],a=t[1],o=n[2],c=t[2],l=n[3],u=t[3];return e[0]=i*r-s*a-o*c-l*u,e[1]=i*a+s*r+o*u-l*c,e[2]=i*c-s*u+o*r+l*a,e[3]=i*u+s*c-o*a+l*r,e}function Rh(n,t,e){e=e||Ee();const i=n[0],r=n[1],s=n[2],a=n[3],o=t[0],c=t[1],l=t[2],u=t[3],d=o*o+c*c+l*l+u*u;if(d===0)e[0]=0,e[1]=0,e[2]=0,e[3]=0;else{const p=1/d;e[0]=(i*o+r*c+s*l+a*u)*p,e[1]=(r*o-i*c-s*u+a*l)*p,e[2]=(s*o-i*l-a*c+r*u)*p,e[3]=(a*o-i*u-r*l+s*c)*p}return e}function Ah(n,t){t=t||Ee();const e=n[0],i=n[1],r=n[2],s=n[3],a=ct(i*i+r*r+s*s),o=fh(e),c=o/a*ei(a);return a===0?(t[0]=fh(e),t[1]=0,t[2]=0,t[3]=0):(t[0]=o*Xr(a),t[1]=i*c,t[2]=r*c,t[3]=s*c),t}function yc(n,t,e){return e=e||Ee(),e[0]=n[0]*t,e[1]=n[1]*t,e[2]=n[2]*t,e[3]=n[3]*t,e}function Ih(n,t,e){return e=e||Ee(),Tc(t,Ec(n),e)}function Ec(n,t){return t=t||Ee(),t[0]=n[0],t[1]=-n[1],t[2]=-n[2],t[3]=-n[3],t}function Sh(n,t){t=t||Ee();const e=n[0],i=n[1],r=n[2],s=n[3],a=e*e+i*i+r*r+s*s;if(a===0)t[0]=0,t[1]=0,t[2]=0,t[3]=0;else{const o=1/a;t[0]=e*o,t[1]=-i*o,t[2]=-r*o,t[3]=-s*o}return t}function _c(n){const t=n[0],e=n[1],i=n[2],r=n[3];return ct(t*t+e*e+i*i+r*r)}function Mh(n,t){t=t||Ee();const e=_c(n);if(e===0)return[0,0,0,0];const i=1/e;return yc(n,i,t)}function Ch(n){return n[0]}function Lh(n){return[n[1],n[2],n[3]]}function Oh(n,t){return Ps(n,t)}function Nh(n,t,e){e=e||Ee();const i=n[0],r=n[1],s=n[2],a=1/ct(i*i+r*r+s*s),o=ei(t/2);return e[0]=Xr(t/2),e[1]=o*i*a,e[2]=o*r*a,e[3]=o*s*a,e}function xc(n,t,e){e=e||Ee();const i=n[0],r=n[1],s=n[2],a=Math.cos,o=Math.sin,c=a(i/2),l=a(r/2),u=a(s/2),d=o(i/2),p=o(r/2),g=o(s/2);switch(t){case ae.xyz:e[1]=d*l*u+c*p*g,e[2]=c*p*u-d*l*g,e[3]=c*l*g+d*p*u,e[0]=c*l*u-d*p*g;break;case ae.yxz:e[0]=c*l*u+d*p*g,e[1]=d*l*u+c*p*g,e[2]=c*p*u-d*l*g,e[3]=c*l*g-d*p*u;break;case ae.zxy:e[0]=c*l*u-d*p*g,e[1]=d*l*u-c*p*g,e[2]=c*p*u+d*l*g,e[3]=c*l*g+d*p*u;break;case ae.zyx:e[0]=c*l*u+d*p*g,e[1]=d*l*u-c*p*g,e[2]=c*p*u+d*l*g,e[3]=c*l*g-d*p*u;break;case ae.yzx:e[0]=c*l*u-d*p*g,e[1]=d*l*u+c*p*g,e[2]=c*p*u+d*l*g,e[3]=c*l*g-d*p*u;break;case ae.xzy:e[0]=c*l*u+d*p*g,e[1]=d*l*u-c*p*g,e[2]=c*p*u-d*l*g,e[3]=c*l*g+d*p*u;break}return e}function Ph(n,t,e){e=e||[0,0,0];const i=xc(n,t);return ta(i,ae.xyz,e),e}function qi(n,t,e,i,r,s){s[0]=ph(n,t),s[1]=wc(e),s[2]=ph(i,r)}function Dh(n,t){return ta(n,ae.zyx,t)}function ta(n,t,e){e=e||[0,0,0];const i=n[0],r=n[1],s=n[2],a=n[3],o=ia(n),c=o[0],l=o[4],u=o[8],d=o[1],p=o[5],g=o[9],m=o[2],v=o[6],b=o[10];switch(t){case ae.zyx:e[1]=Math.asin(-it(m,-1,1)),Math.abs(m)<.99999?(e[0]=Math.atan2(v,b),e[2]=Math.atan2(d,c)):(e[0]=0,e[2]=Math.atan2(-l,p));break;case ae.zyz:qi(2*s*a+2*i*r,2*i*s-2*r*a,a*a-s*s-r*r+i*i,2*s*a-2*i*r,2*r*a+2*i*s,e);break;case ae.zxy:e[0]=Math.asin(it(v,-1,1)),Math.abs(v)<.99999?(e[1]=Math.atan2(-m,b),e[2]=Math.atan2(-l,p)):(e[1]=0,e[2]=Math.atan2(d,c));break;case ae.zxz:qi(2*r*a-2*i*s,2*s*a+2*i*r,a*a-s*s-r*r+i*i,2*r*a+2*i*s,2*i*r-2*s*a,e);break;case ae.yxz:e[0]=Math.asin(-it(g,-1,1)),Math.abs(g)<.9999?(e[1]=Math.atan2(u,b),e[2]=Math.atan2(d,p)):(e[1]=Math.atan2(-m,c),e[2]=0);break;case ae.yxy:qi(2*r*s+2*i*a,2*i*r-2*s*a,s*s-a*a+i*i-r*r,2*r*s-2*i*a,2*s*a+2*i*r,e);break;case ae.yzx:e[2]=Math.asin(it(d,-1,1)),Math.abs(d)<.99999?(e[0]=Math.atan2(-g,p),e[1]=Math.atan2(-m,c)):(e[0]=0,e[1]=Math.atan2(u,b));break;case ae.yzy:qi(2*s*a-2*i*r,2*r*s+2*i*a,s*s-a*a+i*i-r*r,2*s*a+2*i*r,2*i*a-2*r*s,e);break;case ae.xyz:e[1]=Math.asin(it(u,-1,1)),Math.abs(u)<.99999?(e[0]=Math.atan2(-g,b),e[2]=Math.atan2(-l,c)):(e[0]=Math.atan2(v,p),e[2]=0);break;case ae.xyx:qi(2*r*s-2*i*a,2*r*a+2*i*s,r*r+i*i-a*a-s*s,2*r*s+2*i*a,2*i*s-2*r*a,e);break;case ae.xzy:e[2]=Math.asin(-it(l,-1,1)),Math.abs(l)<.99999?(e[0]=Math.atan2(v,p),e[1]=Math.atan2(u,c)):(e[0]=Math.atan2(-g,b),e[1]=0);break;case ae.xzx:qi(2*r*a+2*i*s,2*i*a-2*r*s,r*r+i*i-a*a-s*s,2*r*a-2*i*s,2*r*s+2*i*a,e);break;default:console.warn("Invalid Euler rotation order.");break}return e}function Bh(n,t,e){e=e||[0,0,0];const i=ia(n),r=i[0],s=i[4],a=i[8],o=i[1],c=i[5],l=i[9],u=i[2],d=i[6],p=i[10];switch(t){case ae.xyz:e[1]=Math.asin(it(a,-1,1)),Math.abs(a)<.99999?(e[0]=Math.atan2(-l,p),e[2]=Math.atan2(-s,r)):(e[0]=Math.atan2(d,c),e[2]=0);break;case ae.yxz:e[0]=Math.asin(-it(l,-1,1)),Math.abs(l)<.9999?(e[1]=Math.atan2(a,p),e[2]=Math.atan2(o,c)):(e[1]=Math.atan2(-u,r),e[2]=0);break;case ae.zxy:e[0]=Math.asin(it(d,-1,1)),Math.abs(d)<.99999?(e[1]=Math.atan2(-u,p),e[2]=Math.atan2(-s,c)):(e[1]=0,e[2]=Math.atan2(o,r));break;case ae.zyx:e[1]=Math.asin(-it(u,-1,1)),Math.abs(u)<.99999?(e[0]=Math.atan2(d,p),e[2]=Math.atan2(o,r)):(e[0]=0,e[2]=Math.atan2(-s,c));break;case ae.yzx:e[2]=Math.asin(it(o,-1,1)),Math.abs(o)<.99999?(e[0]=Math.atan2(-l,c),e[1]=Math.atan2(-u,r)):(e[0]=0,e[1]=Math.atan2(a,p));break;case ae.xzy:e[2]=Math.asin(-it(s,-1,1)),Math.abs(s)<.99999?(e[0]=Math.atan2(d,c),e[1]=Math.atan2(a,r)):(e[0]=Math.atan2(-l,p),e[1]=0);break}}function Uh(n){const t=n[0];if(t<-1||t>1)return 0;const e=2*wc(t);return e>gh?e-2*gh:e}function Fh(n){const t=n[1],e=n[2],i=n[3];if(ct(t*t+e*e+i*i)===0)return[0,0,0];const s=1/ct(t*t+e*e+i*i);return[t*s,e*s,i*s]}function na(n,t){t=t||nn();const e=n[1]+n[1],i=n[2]+n[2],r=n[3]+n[3],s=n[1]*e,a=n[1]*i,o=n[1]*r,c=n[2]*i,l=n[2]*r,u=n[3]*r,d=n[0]*e,p=n[0]*i,g=n[0]*r;return t[Or]=1-(c+u),t[Nr]=a-g,t[Pr]=o+p,t[Dr]=a+g,t[Br]=1-(s+u),t[Ur]=l-d,t[Fr]=o-p,t[kr]=l+d,t[Gr]=1-(s+c),t}function kh(n,t){t=t||fe();const e=n[1]+n[1],i=n[2]+n[2],r=n[3]+n[3],s=n[1]*e,a=n[1]*i,o=n[1]*r,c=n[2]*i,l=n[2]*r,u=n[3]*r,d=n[0]*e,p=n[0]*i,g=n[0]*r;return t[Gt]=1-(c+u),t[zt]=a-g,t[Vt]=o+p,t[$t]=0,t[Wt]=a+g,t[jt]=1-(s+u),t[Ht]=l-d,t[Xt]=0,t[Qt]=o-p,t[Yt]=l+d,t[qt]=1-(s+c),t[Kt]=0,t[Zt]=0,t[Jt]=0,t[en]=0,t[tn]=1,t}function Gh(n,t){t=t||nn();const e=n[1]+n[1],i=n[2]+n[2],r=n[3]+n[3],s=n[1]*e,a=n[1]*i,o=n[1]*r,c=n[2]*i,l=n[2]*r,u=n[3]*r,d=n[0]*e,p=n[0]*i,g=n[0]*r;return t[Or]=1-(c+u),t[Dr]=a-g,t[Fr]=o+p,t[Nr]=a+g,t[Br]=1-(s+u),t[kr]=l-d,t[Pr]=o-p,t[Ur]=l+d,t[Gr]=1-(s+c),t}function ia(n,t){t=t||fe();const e=n[1]+n[1],i=n[2]+n[2],r=n[3]+n[3],s=n[1]*e,a=n[1]*i,o=n[1]*r,c=n[2]*i,l=n[2]*r,u=n[3]*r,d=n[0]*e,p=n[0]*i,g=n[0]*r;return t[Gt]=1-(c+u),t[Wt]=a-g,t[Qt]=o+p,t[Zt]=0,t[zt]=a+g,t[jt]=1-(s+u),t[Yt]=l-d,t[Jt]=0,t[Vt]=o-p,t[Ht]=l+d,t[qt]=1-(s+c),t[en]=0,t[$t]=0,t[Xt]=0,t[Kt]=0,t[tn]=1,t}function zh(n,t){t=t||Ee();const[e,i,r]=n,s=Xr(e/2),a=Xr(i/2),o=Xr(r/2),c=ei(e/2),l=ei(i/2),u=ei(r/2),d=a*o,p=l*u,g=a*u,m=l*o;return t[0]=s*d+c*p,t[1]=c*d-s*p,t[2]=s*m+c*g,t[3]=s*g-c*m,t}function Rc(n,t,e){return e=e||Ee(),Yi=dt([-n[0],-n[1],-n[2]],Xe[Xe.length-1]),_t=dt(Ze(t,Yi,Xe[Xe.length-2])),ea=Ze(Yi,_t,Xe[Xe.length-3]),Pe=_t[0],Ve=ea[0],Xi=Yi[0],nt=_t[1],Le=ea[1],Qi=Yi[1],Zs=_t[2],Js=ea[2],ti=Yi[2],k=(1+Pe+Le+ti)*.25,k>0?(k=Math.sqrt(k),e[0]=k,k=1/(4*k),e[1]=(Qi-Js)*k,e[2]=(Zs-Xi)*k,e[3]=(Ve-nt)*k):(e[0]=0,k=-.5*(Le+ti),k>0?(k=Math.sqrt(k),e[1]=k,k*=2,e[2]=Ve/k,e[3]=Xi/k):(e[1]=0,k=.5*(1-ti),k>0?(k=Math.sqrt(k),e[2]=k,e[3]=Qi/(2*k)):(e[2]=0,e[3]=1))),e}function Vh(n,t){if(t=t||Ee(),tt=n[0],sn=n[3],an=n[6],on=n[1],Pe=n[4],Ve=n[7],cn=n[2],nt=n[5],Le=n[8],k=tt+Pe+Le,k>0){const i=ct(k+1)*2;return t[0]=.25*i,t[1]=(nt-Ve)/i,t[2]=(an-cn)/i,t[3]=(on-sn)/i,t}if(tt>Pe&&tt>Le){const i=ct(1+tt-Pe-Le)*2;return t[0]=(nt-Ve)/i,t[1]=.25*i,t[2]=(sn+on)/i,t[3]=(an+cn)/i,t}if(Pe>Le){const i=ct(1+Pe-tt-Le)*2;return t[0]=(an-cn)/i,t[1]=(on+sn)/i,t[2]=.25*i,t[3]=(nt+Ve)/i,t}const e=ct(1+Le-tt-Pe)*2;return t[0]=(on-sn)/e,t[1]=(cn+an)/e,t[2]=(nt+Ve)/e,t[3]=.25*e,t}function $h(n,t){if(t=t||Ee(),tt=n[0],sn=n[4],an=n[8],on=n[1],Pe=n[5],Ve=n[9],cn=n[2],nt=n[6],Le=n[10],k=tt+Pe+Le,k>0){const i=ct(k+1)*2;return t[0]=.25*i,t[1]=(nt-Ve)/i,t[2]=(an-cn)/i,t[3]=(on-sn)/i,t}if(tt>Pe&&tt>Le){const i=ct(1+tt-Pe-Le)*2;return t[0]=(nt-Ve)/i,t[1]=.25*i,t[2]=(sn+on)/i,t[3]=(an+cn)/i,t}if(Pe>Le){const i=ct(1+Pe-tt-Le)*2;return t[0]=(an-cn)/i,t[1]=(on+sn)/i,t[2]=.25*i,t[3]=(nt+Ve)/i,t}const e=ct(1+Le-tt-Pe)*2;return t[0]=(on-sn)/e,t[1]=(cn+an)/e,t[2]=(nt+Ve)/e,t[3]=.25*e,t}function ra(n,t,e,i,r){return r=r||Ee(),Pe=n[0]/t,Ve=n[4]/e,Xi=n[8]/i,nt=n[1]/t,Le=n[5]/e,Qi=n[9]/i,Zs=n[2]/t,Js=n[6]/e,ti=n[10]/i,k=(1+Pe+Le+ti)*.25,k>0?(k=Math.sqrt(k),r[0]=k,k=1/(4*k),r[1]=(Qi-Js)*k,r[2]=(Zs-Xi)*k,r[3]=(Ve-nt)*k):(r[0]=0,k=-.5*(Le+ti),k>0?(k=Math.sqrt(k),r[1]=k,k*=2,r[2]=Ve/k,r[3]=Xi/k):(r[1]=0,k=.5*(1-ti),k>0?(k=Math.sqrt(k),r[2]=k,r[3]=Qi/(2*k)):(r[2]=0,r[3]=1))),r}function Wh(n,t,e){e=e||fe();const i=dt([-n[0],-n[1],-n[2]]),r=dt(Ze(t,i)),s=Ze(i,r);return e[0]=r[0],e[1]=s[0],e[2]=i[0],e[3]=0,e[4]=r[1],e[5]=s[1],e[6]=i[1],e[7]=0,e[8]=r[2],e[9]=s[2],e[10]=i[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function sa(n,t,e){return _t=Xn(t[1],t[2],t[3]),k=t[0],Nt(Nt(at(_t,2*Er(_t,n)),at(n,k*k-Er(_t,_t))),at(Ze(_t,n),2*k),e)}function jh(n,t,e,i){i=i||Ee();const r=[0,0,0,0];let s,a,o,c,l;return a=n[1]*t[1]+n[2]*t[2]+n[3]*t[3]+n[0]*t[0],a<0?(a=-a,r[0]=-t[1],r[1]=-t[2],r[2]=-t[3],r[3]=-t[0]):(r[0]=t[1],r[1]=t[2],r[2]=t[3],r[3]=t[0]),1-a>1e-7?(s=wc(a),o=ei(s),c=ei((1-e)*s)/o,l=ei(e*s)/o):(c=1-e,l=e),i[1]=c*n[1]+l*r[0],i[2]=c*n[2]+l*r[1],i[3]=c*n[3]+l*r[2],i[0]=c*n[0]+l*r[3],i}function Qr(){return[1,0,0,0]}function Hh(){return[0,1,0,0]}function Xh(){return[0,0,1,0]}function Qh(){return[0,0,0,1]}const Ng=Object.freeze(Object.defineProperty({__proto__:null,QR1:mh,QR2:vh,QR3:bh,QR4:wh,QW:_h,QX:Th,QY:yh,QZ:Eh,addQuat:xh,angleQuat:Uh,axisQuat:Fh,clamp:it,conjugateQuat:Ec,decomposeRotation:ra,diffUnitQuat:Ih,divideQuat:Rh,dotQuat:Oh,eulerToQuat:zh,exponentQuat:Ah,fromEulerAxisAngleToQuat:Nh,fromOrderedEulerToQuat:xc,iQuat:Hh,imaginaryQuat:Lh,inverseQuat:Sh,jQuat:Xh,kQuat:Qh,lengthQuat:_c,lookAtMatrix:Wh,lookAtQuat:Rc,matrix3x3FromUnitQuatModel:na,matrix3x3FromUnitQuatView:Gh,matrix3x3ToQuaternion:Vh,matrix4x4FromUnitQuatModel:kh,matrix4x4FromUnitQuatView:ia,matrix4x4ToQuaternion:$h,multiplyQuat:Tc,normalizeQuat:Mh,oneQuat:Qr,realQuat:Ch,rotateVectorByUnitQuat:sa,scaleQuat:yc,slerpUnitQuat:jh,toEulerFromQuat:Dh,toEulerXYZfromOrderedEuler:Ph,toOrderedEulerFromQuat:ta,toOrderedEulerFromQuat2:Bh,zeroQuat:Ee},Symbol.toStringTag,{value:"Module"}));function Ac(n,t){return[n,t]}function Yh(n,t,e){return e=e||[0,0,0],Nt(n[0],at(n[1],t),e)}function Ic(n,t,e){return e=e||[[0,0,0],[0,0,0]],st(n,e[0]),dt(Pt(t,n),e[1]),e}const Pg=Object.freeze(Object.defineProperty({__proto__:null,ray:Ac,rayFromPoints:Ic,rayToLocation:Yh},Symbol.toStringTag,{value:"Module"})),Dg=Xp,Bg=Ng,Ug=Pg,Fg=mp;let $e=class{constructor(){f(this,"resolver");f(this,"rejector");f(this,"promise");this.promise=new Promise((t,e)=>(this.resolver=t,this.rejector=e))}resolve(t){this.resolver(t)}reject(t){this.rejector(t)}},xt=-1,aa=0,oa=[],Yr=[],qr=[];const Ki=new Map,Zi=n=>{aa=n;let t=!1;const e=[];Ki.forEach((r,s)=>{t=!0;let[a,o,c,l,u]=r;if(l!==-1&&(u===-1&&(u=n,r[4]=n),n-u>=l)){e.push(s),a(n,u+l);return}if(o!==-1){if(c===-1&&(r[2]=n,c=n),n-c>=o)for(a(n);n-c>=o;)r[2]+=o,c+=o}else a(n)});for(let r=0,s=e.length;r<s;++r){const a=e[r];Ki.delete(a)}const i=Yr.slice();Yr=[];for(let r=0,s=i.length;r<s;++r){const[a,o,c]=i[r];o<=0?a&&a(n):n-c>o?a(n):(t=!0,Yr.push(i[r]))}for(let r=0,s=qr.length;r<s;++r){const a=qr[r];a&&(t=!0,a(n))}qr=oa.slice(0),oa=[],qr.length>0&&(t=!0),t?xt=requestAnimationFrame(Zi):xt=-1};xt=requestAnimationFrame(Zi);function Kr(n){const t=new $e;return oa.push(e=>{n&&n(e),t.resolve(e)}),xt===-1&&(xt=requestAnimationFrame(Zi)),t.promise}function Cn(n,t){const e=new $e,i=r=>{n&&n(r),e.resolve(r)};return Yr.push([i,t||-1,aa]),xt===-1&&(xt=requestAnimationFrame(Zi)),e.promise}function Sc(n,t,e){const i=new $e,r=(s,a)=>{n(s),e!==void 0&&e>0?a!==void 0&&i.resolve(a):i.resolve(s)};return Ki.set(i.promise,[r,t||-1,-1,e||-1,-1]),xt===-1&&(xt=requestAnimationFrame(Zi)),i.promise}function qh(n){Ki.delete(n),xt===-1&&(xt=requestAnimationFrame(Zi))}function kg(){Ki.forEach(n=>n[0](aa,aa)),Ki.clear(),Yr=[],oa=[],qr=[]}const Ei=new Set,Mc=Ei.add.bind(Ei),Cc=Ei.delete.bind(Ei),Kh=async()=>{await Sc(()=>{Ei.size!==0&&(Ei.forEach(n=>n.update()),Ei.clear())},void 0,Number.POSITIVE_INFINITY),Kh()};Kh();class Lc{constructor(){f(this,"_parent");f(this,"_children",[]);f(this,"_needsUpdate",!1);f(this,"_childUpdate",new Set)}get parent(){return this._parent}set parent(t){this.setParent(t)}get children(){return this._children}get needsUpdate(){return this._needsUpdate}get childUpdate(){return this._childUpdate}addChild(t,e){t.parent!==this&&(e||t.setParent(this,!0),this._children.push(t),this._childUpdate.add(t),t.invalidate())}invalidate(){if(this._needsUpdate)return!1;this._needsUpdate=!0;for(let t=0,e=this._children.length;t<e;++t){const i=this._children[t];this._childUpdate.add(i),i.invalidate()}return!0}processParentUpdates(t){if(!this._parent||!this._parent._needsUpdate)return;const e=[];let i=this._parent;for(;i&&(e.push(i),i._parent&&i._parent.needsUpdate);)i=i._parent;for(let r=e.length-1;r>=0;--r){const s=e[r];t(s),s.resolve()}}removeChild(t,e){t._parent===this&&(t._parent!==void 0&&!e&&t.setParent(void 0,!0),this._children.splice(this._children.indexOf(t),1),this._childUpdate.delete(t))}resolve(){this._needsUpdate&&(this._needsUpdate=!1,this._parent&&this._parent._childUpdate.delete(this))}setParent(t,e){this._parent!==t&&(e||(t!==void 0&&t.addChild(this,!0),this._parent&&this._parent.removeChild(this,!0)),this._parent=t,this.invalidate())}}class ca extends Lc{constructor(e){super();f(this,"isQueuedForUpdate",!1);f(this,"needsWorldOrientation",!1);f(this,"needsWorldDecomposition",!1);f(this,"hasViewMatrix",!1);f(this,"_instance",null);f(this,"_matrix",{value:fe()});f(this,"_localMatrix",{value:this._matrix.value});f(this,"_viewMatrix");f(this,"_localViewMatrix");f(this,"_localTransform");f(this,"_localViewTransform");f(this,"_rotation",{value:Qr()});f(this,"_localRotation",{value:this._rotation.value});f(this,"localRotationMatrix",nn());f(this,"_scale",{value:[1,1,1]});f(this,"_localScale",{value:this._scale.value});f(this,"_position",{value:[0,0,0]});f(this,"_localPosition",{value:this._position.value});f(this,"_forward",{value:fi()});f(this,"_localForward",{value:this._forward.value});f(this,"needsForwardUpdate",!1);e&&(e.localPosition&&(this.localPosition=e.localPosition),e.localRotation&&(this.localRotation=e.localRotation),e.localScale&&(this.localScale=e.localScale),e.parent&&(this.parent=e.parent))}set instance(e){this._instance!==e&&this._instance&&(this._instance.transform.instance=null,e&&(e.transform=this)),this._instance=e}get matrix(){return this.update(),this._matrix.value}get localMatrix(){return this.update(),this._localMatrix.value}get viewMatrix(){return this.hasViewMatrix=!0,this._viewMatrix===void 0&&this.invalidate(),this.update(),this._viewMatrix===void 0?fe():this._viewMatrix.value}get localViewMatrix(){return this.hasViewMatrix=!0,this._localViewMatrix===void 0&&this.invalidate(),this.update(),this._localViewMatrix===void 0?fe():this._localViewMatrix.value}get localTransform(){var e;return(e=this._localTransform)==null?void 0:e.value}set localTransform(e){e?(this._localTransform||(this._localTransform={value:fe()}),ji(e,this._localTransform.value),this._localTransform.didUpdate=!0):delete this._localTransform,this.invalidate()}get localViewTransform(){var e;return(e=this._localViewTransform)==null?void 0:e.value}set localViewTransform(e){e?(this._localViewTransform||(this._localViewTransform={value:fe()}),ji(e,this._localViewTransform.value),this._localViewTransform.didUpdate=!0):delete this._localViewTransform,this.invalidate()}get rotation(){return this.needsWorldOrientation=!0,this.update(),this._rotation.value}set rotation(e){this.parent?console.warn("NOT IMPLEMENTED: Setting world rotation when a parent is present is not supported yet. Use localRotation for now."):this.localRotation=e}get localRotation(){return this._localRotation.value}set localRotation(e){me(this._localRotation.value,e[0],e[1],e[2],e[3]),this._localRotation.didUpdate=!0,this.invalidate(),this.needsForwardUpdate=!0}get scale(){return this.needsWorldOrientation=!0,this.update(),this._scale.value}set scale(e){this.parent?console.warn("NOT IMPLEMENTED: Setting world scale is not supported yet. Use localScale for now."):this.localScale=e}get localScale(){return this._localScale.value}set localScale(e){ve(this._localScale.value,e[0],e[1],e[2]),this._localScale.didUpdate=!0,this.invalidate()}get position(){return this.needsWorldOrientation=!0,this.update(),this._position.value}set position(e){this.parent?console.warn("NOT IMPLEMENTED: Setting world position is not supported yet. Use localPosition for now."):this.localPosition=e}get localPosition(){return this._localPosition.value}set localPosition(e){this._localPosition.value[0]=e[0],this._localPosition.value[1]=e[1],this._localPosition.value[2]=e[2],this._localPosition.didUpdate=!0,this.invalidate()}get forward(){var e;return(this.needsForwardUpdate||(e=this.parent)!=null&&e.childUpdate.has(this))&&(this.needsForwardUpdate=!1,sa(fi(),this._rotation.value,this._forward.value)),this._forward.value}get localForward(){return this.needsForwardUpdate&&(this.needsForwardUpdate=!1,sa(fi(),this._localRotation.value,this._localForward.value)),this._localForward.value}applyLocalSRT(e,i,r){this._localScale.value=e,this._localPosition.value=r,this._localRotation.value=i,this._localScale.didUpdate=!0,this._localPosition.didUpdate=!0,this._localRotation.didUpdate=!0,this.invalidate(),this._instance&&(this._instance.transform=this)}decomposeWorldMatrix(){if(!this.needsWorldDecomposition||!this.parent||!this._matrix.didUpdate||this._matrix.value===this._localMatrix.value)return;if(this._instance){if(!this._instance.needsWorldUpdate||!this.needsWorldOrientation)return}else if(!this.needsWorldOrientation)return;this.needsWorldDecomposition=!1;const e=this._matrix.value,i=this._position.value,r=this._scale.value;this._position.didUpdate=i[0]!==e[12]||i[1]!==e[13]||i[2]!==e[14],this._position.didUpdate&&ve(i,e[12],e[13],e[14]);const s=Rn(e[0],e[1],e[2],e[3]),a=Rn(e[4],e[5],e[6],e[7]),o=Rn(e[8],e[9],e[10],e[11]);this._scale.didUpdate=r[0]!==s||r[1]!==a||r[2]!==o,ve(r,s,a,o),this._scale.didUpdate=!0;const[c,l,u,d]=this._rotation.value;ra(this._matrix.value,s,a,o,this._rotation.value);const p=this._rotation.value;this._rotation.didUpdate=p[0]!==c||p[1]!==l||p[2]!==u||p[3]!==d}lookAtLocal(e,i){Rc(Pt(e,this._localPosition.value,Xe[0]),i||[0,1,0],this._localRotation.value),this._localRotation.didUpdate=!0,this.invalidate(),this.needsForwardUpdate=!0}divideMemory(){this._forward.value=fi(),this._matrix.value=fe(),this._rotation.value=Qr(),this._scale.value=[1,1,1],this._position.value=[0,0,0],this.hasViewMatrix&&this._viewMatrix&&this._localViewMatrix&&(this._viewMatrix.value=fe())}mergeMemory(){this._forward.value=this._localForward.value,this._matrix.value=this._localMatrix.value,this._rotation.value=this._localRotation.value,this._scale.value=this._localScale.value,this._position.value=this._localPosition.value,this.hasViewMatrix&&this._viewMatrix&&this._localViewMatrix&&(this._viewMatrix.value=this._localViewMatrix.value)}setParent(e,i){e!==this.parent&&(e?this.parent||this.divideMemory():this.mergeMemory(),this.invalidate(),this.needsForwardUpdate=!0,this._localScale.didUpdate=!0,this._localRotation.didUpdate=!0,this._localPosition.didUpdate=!0,super.setParent(e,i))}invalidate(){return this.queueForUpdate(),super.invalidate()}optimize(){this.needsWorldOrientation=!1}queueForUpdate(){!this.isQueuedForUpdate&&this._instance&&this._instance.active&&(this.isQueuedForUpdate=!0,Mc(this))}update(e){let i=!1;if(this.isQueuedForUpdate&&(Cc(this),this.isQueuedForUpdate=!1),this.needsUpdate){const r=this.localRotationMatrix;this._localRotation.didUpdate&&na(this._localRotation.value,r),this._localTransform?(qs(this._localScale.value,r,this._localPosition.value,ze[0]),ot(this._localTransform.value,ze[0],this._localMatrix.value)):qs(this._localScale.value,r,this._localPosition.value,this._localMatrix.value),this._localMatrix.didUpdate=!0,i=!0,this.hasViewMatrix&&(this._viewMatrix===void 0&&(this._viewMatrix={value:fe()}),this._localViewMatrix===void 0&&(this.parent?this._localViewMatrix={value:fe()}:this._localViewMatrix={value:this._viewMatrix.value}),this._localViewTransform?(Wr(zi(this._localScale.value,Xe[0]),Vr(r,Ti[1]),at(this._localPosition.value,-1,Xe[1]),ze[0]),ot(this._localViewTransform.value,ze[0],this._localViewMatrix.value)):Wr(zi(this._localScale.value,Xe[0]),Vr(r,Ti[1]),at(this._localPosition.value,-1,Xe[1]),this._localViewMatrix.value),this._localViewMatrix.didUpdate=!0)}this.parent&&(this.parent.needsUpdate?(e||this.processParentUpdates(r=>{r.update(!0)}),i=!0):this.parent.childUpdate.has(this)&&(i=!0),i&&(ot(this.parent._matrix.value,this._localMatrix.value,this._matrix.value),this._matrix.didUpdate=!0,this.needsWorldDecomposition=!0,this.hasViewMatrix&&this._viewMatrix&&this._localViewMatrix&&(this.parent.hasViewMatrix&&this.parent._viewMatrix&&this.parent._localViewMatrix?ot(this.parent._viewMatrix.value,this._localViewMatrix.value,this._viewMatrix.value):(na(this.parent.rotation,Ti[0]),Wr(zi(this.parent._scale.value,Xe[0]),Vr(Ti[0],Ti[1]),at(this.parent._position.value,-1,Xe[1]),ze[0]),ot(this._localViewMatrix.value,ze[0],this._viewMatrix.value)),this._viewMatrix.didUpdate=!0))),this.decomposeWorldMatrix(),this._instance&&this._instance.active&&(this._localMatrix.didUpdate||this._matrix.didUpdate)&&(this._instance.needsLocalUpdate&&(this._localRotation.didUpdate&&(this._instance._localRotation=this._localRotation.value),this._localPosition.didUpdate&&(this._instance._localPosition=this._localPosition.value),this._localScale.didUpdate&&(this._instance._localScale=this._localScale.value)),this._instance.needsWorldUpdate&&(this.parent?(this._rotation.didUpdate&&(this._instance._rotation=this._rotation.value),this._scale.didUpdate&&(this._instance._scale=this._scale.value),this._position.didUpdate&&(this._instance._position=this._position.value)):(this._localRotation.didUpdate&&(this._instance._rotation=this._localRotation.value),this._localPosition.didUpdate&&(this._instance._position=this._localPosition.value),this._localScale.didUpdate&&(this._instance._scale=this._localScale.value))),this._matrix.didUpdate&&(this._instance._matrix=this._matrix.value),this._localMatrix.didUpdate&&(this._instance._localMatrix=this._localMatrix.value,this.parent||(this._instance._matrix=this._matrix.value))),this._localScale.didUpdate=!1,this._localRotation.didUpdate=!1,this._localPosition.didUpdate=!1,this._rotation.didUpdate=!1,this._scale.didUpdate=!1,this._position.didUpdate=!1,this._matrix.didUpdate=!1,this._localMatrix.didUpdate=!1,this.resolve()}}const Zh=new ca;var Ln=(n=>(n[n.PERSPECTIVE=0]="PERSPECTIVE",n[n.ORTHOGRAPHIC=1]="ORTHOGRAPHIC",n))(Ln||{});function Jh(n){return n.projectionOptions.type===1&&"left"in n.projectionOptions}function Oc(n){return n.projectionOptions.type===0&&"fov"in n.projectionOptions}class On{constructor(t){f(this,"_id",z());f(this,"animationEndTime",0);f(this,"needsViewDrawn",!0);f(this,"needsBroadcast",!1);f(this,"viewChangeViewId","");f(this,"transform",new ca);f(this,"_projection",fe());f(this,"_needsUpdate",!0);f(this,"_projectionOptions");f(this,"_viewProjection",fe());this._projectionOptions=t,this._needsUpdate=!0,this.onChange=t.onViewChange,this.update()}get id(){return this._id}broadcast(t){this.onChange&&this.onChange(this,t)}static makeOrthographic(t){return new On(Object.assign({left:-100,right:100,top:-100,bottom:100,near:-100,far:1e5,type:1},t))}static makePerspective(t){return new On(Object.assign({type:0,far:1e4,near:1,fov:90*Math.PI/180,height:1e3,width:1e3},t))}get projectionType(){return this._projectionOptions.type}get projection(){return this.update(!0),this._projection}get view(){return this.transform.viewMatrix}get needsUpdate(){return this._needsUpdate}get position(){return this.transform.position}set position(t){this._needsUpdate=this._needsUpdate||!Tr(t,this.transform.position),this.transform.position=t}lookAt(t,e){const i=ji(this.transform.matrix);this.transform.lookAtLocal(t,e||[0,1,0]),this._needsUpdate=this._needsUpdate||!mc(i,this.transform.matrix)}get scale(){return this.transform.scale}set scale(t){this._needsUpdate=this._needsUpdate||!Tr(t,this.transform.scale),this.transform.scale=t}get projectionOptions(){return this._projectionOptions}set projectionOptions(t){this._needsUpdate=this._needsUpdate||!bc(t,this._projectionOptions),this._projectionOptions=t}get viewProjection(){return this.update(!0),this._viewProjection}setOrthographic(t){this._projectionOptions=Object.assign({left:-100,right:100,top:-100,bottom:100,near:-100,far:1e5,type:1},t)}setPerspective(t){this._projectionOptions=Object.assign({type:0,far:1e4,near:1,fov:90*Math.PI/180,height:1e3,width:1e3},t)}resolve(){this._needsUpdate=!1,this.needsViewDrawn=!1,this.needsBroadcast=!1}update(t){(this._needsUpdate||t)&&(this.updateProjection(),this._needsUpdate=!1,this.needsViewDrawn=!0)}updateProjection(){Jh(this)?pc(this.projectionOptions.left,this.projectionOptions.right,this.projectionOptions.bottom,this.projectionOptions.top,this.projectionOptions.near,this.projectionOptions.far,this._projection):Oc(this)&&fc(this.projectionOptions.fov,this.projectionOptions.width,this.projectionOptions.height,this.projectionOptions.near,this.projectionOptions.far,this._projection),ot(this._projection,this.transform.viewMatrix,this._viewProjection)}}class _i{constructor(t){f(this,"_key");this._key=t.key}get id(){return this._key}get key(){return this._key}}function Gg(n){return{key:"",type:he.COLOR_BUFFER,...n}}function la(n){return n!==void 0&&n.key!==void 0&&n.type===he.COLOR_BUFFER}class ed extends _i{constructor(e,i){super(e);f(this,"type",he.COLOR_BUFFER);f(this,"height");f(this,"width");f(this,"colorBufferSettings");f(this,"colorBuffer");this.height=e.height,this.width=e.width,this.colorBufferSettings=e.colorBufferSettings,this.createColorBuffer(i)}destroy(){this.colorBuffer.destroy()}createColorBuffer(e){if(this.colorBuffer)return;this.colorBufferSettings={...this.colorBufferSettings};let i,r;const s=(e==null?void 0:e.getRenderSize())||[1,1];if(this.width<=ft.SCREEN){if(!e)throw new Error("Can not generate Render Texture with a dynamic width or height when the WebGLRenderer is not available");i=s[0]/-this.width}else i=this.width;if(this.height<=ft.SCREEN){if(!e)throw new Error("Can not generate Render Texture with a dynamic width or height when the WebGLRenderer is not available");r=s[1]/-this.width}else r=this.height;this.colorBuffer=new nu({internalFormat:h.GLSettings.RenderTarget.ColorBufferFormat.RGBA4,size:[i,r],...this.colorBufferSettings})}}class Ji{constructor(){f(this,"router");f(this,"_webGLRenderer")}get webGLRenderer(){return this._webGLRenderer}set webGLRenderer(t){this._webGLRenderer=t}getIOExpansion(){return[]}resize(){}setAttributeContext(t){}}class td extends Ji{constructor(){super(...arguments);f(this,"resources",new Map)}async dequeueRequests(){return!1}destroy(){}destroyResource(e){this.resources.delete(e.key)}getResource(e){return this.resources.get(e)||{key:"",type:-1}}async initResource(e){this.resources.set(e.key,e)}request(e,i,r){return[0,0,0,0]}updateResource(e){}}const nd=new td;class zg extends Ji{constructor(){super(...arguments);f(this,"resources",new Map)}async dequeueRequests(){return!1}destroy(){this.resources.forEach(e=>e.destroy()),this.resources.clear()}getIOExpansion(){return[]}getResource(e){return this.resources.get(e)||null}destroyResource(e){const i=this.resources.get(e.key);i&&(i.destroy(),this.resources.delete(e.key))}async initResource(e){let i=this.resources.get(e.key);if(i){console.warn("Attempted to generate a RenderTexture that already exists for key",e.key);return}i=new ed(e,this.webGLRenderer),this.resources.set(e.key,i)}request(e,i,r,s){const a=this.resources.get(r.key);return a?(r.colorBuffer=a.colorBuffer,[0,0,1,1]):[0,0,0,0]}resize(){const e=new Map;this.resources.forEach((i,r)=>{i.width>ft.SCREEN&&i.height>ft.SCREEN||(i.colorBuffer.destroy(),i=new ed(i,this.webGLRenderer),e.set(r,i))}),e.forEach((i,r)=>this.resources.set(r,i))}updateResource(e){this.resources.get(e.key)&&console.warn("UPDATING AN EXISTING COLOR BUFFER IS NOT SUPPORTED YET")}}function Nc(n){return{type:he.COLOR_BUFFER,...n}}const pr=class{static setObservableMonitor(t){pr.gatherIds=t,pr.observableIds=[]}static getObservableMonitorIds(t){const e=pr.observableIds.slice(0);return t&&(pr.observableIds=[]),e}};let _e=pr;f(_e,"setCycle",!1),f(_e,"gatherIds",!1),f(_e,"observableIds",[]),f(_e,"observableNamesToUID",new Map);const ln=_e,ua=new Map;let Vg=1;const $g={}.constructor;function Wg(n,t){const e=ln.observableNamesToUID.get(t)||0;if(e===0){console.warn("A property with name",t,"for",n,"has not been assigned a UID which is an error in this step of the process.");return}function i(){return ln.gatherIds&&(ln.setCycle||ln.observableIds.push(e)),n.observableStorage[e]}function r(a){ln.gatherIds&&(ln.setCycle=!0),n.observableStorage[e]=a,n.changes[e]=e,n.observer&&n.observer.instanceUpdated(n),ln.gatherIds&&(ln.setCycle=!1)}const s=n[t];Object.defineProperty(n,t,{configurable:!0,enumerable:!0,get:i,set:r}),n[t]=s}function L(n,t,e){e||(e={configurable:!0,enumerable:!0});let i=ua.get(n.constructor),r=ln.observableNamesToUID.get(t)||0;r===0&&(r=++Vg,ln.observableNamesToUID.set(t,r)),i||(i=new Set,ua.set(n.constructor,i)),i.add(t);let s=Object.getPrototypeOf(n),a=0;for(;s.constructor!==$g&&++a<100;){const o=ua.get(s.constructor);o&&o.forEach(c=>i==null?void 0:i.add(c)),s=Object.getPrototypeOf(s)}a>=100&&console.warn("@observable decorator encountered a type that has 100+ levels of inheritance. This is most likely an error, and may be a result of a circular dependency and will not be supported by this decorator."),e.enumerable=!0,e.writable=!0,Object.defineProperty(n,t,e)}function Qe(n,t){if(n.constructor!==t)return;const e=ua.get(t);e&&e.forEach(i=>Wg(n,i))}class pe{constructor(t){f(this,"_uid",z());f(this,"cleanObservation",new Map);f(this,"instanceChanges",new Map);f(this,"allowChanges",!0);f(this,"resolveContext","");if(t)for(let e=0,i=t.length;e<i;++e){const r=t[e];this.add(r)}}get uid(){return this._uid}get changeList(){this.allowChanges=!1;const t=[];return this.instanceChanges.forEach(e=>t.push(e)),t}add(t){if(this.cleanObservation.get(t.uid))return t;if(this.allowChanges){t.observer=this;const e=t.observableDisposer;this.cleanObservation.set(t.uid,[t,e]),this.instanceChanges.set(t.uid,[t,Te.INSERT,t.changes])}return t}has(t){return this.cleanObservation.has(t.uid)}clear(){this.cleanObservation.forEach(t=>{this.remove(t[0])})}destroy(){this.cleanObservation.forEach(t=>{t[1]()}),this.cleanObservation.clear(),this.instanceChanges.clear()}instanceUpdated(t){this.allowChanges&&this.instanceChanges.set(t.uid,[t,Te.CHANGE,t.changes])}remove(t){if(this.allowChanges){const e=this.cleanObservation.get(t.uid);e&&(e[1](),this.cleanObservation.delete(t.uid),this.instanceChanges.set(t.uid,[e[0],Te.REMOVE,{}]))}return!1}resolve(t){if(this.allowChanges=!0,this.instanceChanges.clear(),this.resolveContext&&this.resolveContext!==t)throw new Error("An instance provider has been issued to two layers. This is not a suppported feature yet and can cause issues.");this.resolveContext=t}sync(){const t=[];this.cleanObservation.forEach(e=>{const[i]=e;this.instanceChanges.set(i.uid,[i,Te.INSERT,t])})}}class jg extends pe{constructor(e){super(e);f(this,"_instances",[])}get instances(){return this._instances}add(e){return this._instances.push(e),super.add(e)}clear(){this._instances.length=0,super.clear()}remove(e){const i=this._instances.findIndex(r=>r.uid===e.uid);return i!==-1&&this._instances.splice(i,1),super.remove(e)}destroy(){this._instances.length=0,super.destroy()}}class id{constructor(t){f(this,"delay",0);f(this,"duration");f(this,"end");f(this,"isManualStart",!1);f(this,"isTimeSet",!1);f(this,"start");f(this,"startTime",-1);Object.assign(this,t)}setAutomatic(){this.isManualStart=!1,this.isTimeSet=!1}setStart(t){t&&(this.start.length!==t.length?console.warn("A manual easing adjustment provided an incompatible value for the easing type."):(this.start=t,this.isManualStart=!0))}setTiming(t,e){this.delay=t===void 0?this.delay:t,this.duration=e===void 0?this.duration:e,this.isTimeSet=!0}}var Hg=Object.defineProperty,Xg=Object.getOwnPropertyDescriptor,Qg=(n,t,e,i)=>{for(var r=i>1?void 0:i?Xg(t,e):t,s=n.length-1,a;s>=0;s--)(a=n[s])&&(r=(i?a(t,e,r):a(r))||r);return i&&r&&Hg(t,e,r),r};let rd=0;const Pc=class{constructor(n){f(this,"_active",!1);f(this,"changes",{});f(this,"easingId");f(this,"easing");f(this,"_observer",null);f(this,"observableStorage",[]);f(this,"_uid",Pc.newUID);f(this,"reactivate",!1);Qe(this,Pc),n&&(this.active=n.active||this.active)}static get newUID(){return rd=++rd%16777215}get active(){return this._active}set active(n){this._active=n,this.reactivate=!0}get observableDisposer(){return()=>this._observer=null}get observer(){return this._observer||null}set observer(n){const t=this._observer;t&&t!==n&&(this.easing&&this.easing.clear(),t.remove(this)),this._observer=n}getEasing(n){if(this.easingId){const t=this.easingId[`_${n}_end`];if(t&&this.easing){const e=this.easing.get(t);if(e instanceof id)return e}}}get uid(){return this._uid}resourceTrigger(){console.warn("resourceTrigger called on an instance that did not override resourceTrigger. resourceTrigger MUST be overridden for instances","that utilize a resource. The observable that is tied to committing the resource should be 'triggered' in this method.")}};let Ye=Pc;Qg([L],Ye.prototype,"_active",2);class Yg extends Ye{resourceTrigger(){}}function Dc(n){return{key:"",type:he.TEXTURE,...n}}function xi(n){return n&&n.key!==void 0&&n.type===he.TEXTURE}class Bc extends _i{constructor(e,i){super(e);f(this,"type",he.TEXTURE);f(this,"height");f(this,"width");f(this,"textureSettings");f(this,"texture");this.height=e.height,this.width=e.width,this.textureSettings=e.textureSettings,this.createTexture(i)}destroy(){this.texture.destroy()}createTexture(e){var a;if(this.texture)return;this.textureSettings={generateMipMaps:!0,premultiplyAlpha:!1,...this.textureSettings};let i,r;const s=(e==null?void 0:e.getRenderSize())||[1,1];if(this.width<=ft.SCREEN){if(!e)throw new Error("Can not generate Render Texture with a dynamic width or height when the WebGLRenderer is not available");i=s[0]/-this.width}else i=this.width;if(this.height<=ft.SCREEN){if(!e)throw new Error("Can not generate Render Texture with a dynamic width or height when the WebGLRenderer is not available");r=s[1]/-this.width}else r=this.height;this.texture=new se({data:((a=this.textureSettings)==null?void 0:a.data)||{width:i,height:r,buffer:null},...this.textureSettings})}}const qg=`// This contains the method required to be used on a fragment shader when a layer desires to use
// PickType.SINGLE (color picking).
varying highp vec4 _picking_color_pass_;

void main() {
  \${out: _picking_fragment_} = _picking_color_pass_;
}
`;function sd(n){return n}class qe{constructor(t,e,i,r){f(this,"child",[null,null]);f(this,"isLeaf",!0);f(this,"bounds");f(this,"data",null);this.bounds=new ie({height:r,width:i,x:t,y:e})}destroy(){const t=this.child[0],e=this.child[1];this.data=null,t&&t.destroy(),e&&e.destroy(),this.child[0]=null,this.child[1]=null}hasChild(){const t=this.child[0],e=this.child[1];return t&&!t.data?!t.isLeaf:e&&!e.data?!e.isLeaf:!1}insert(t){let e=this.child[0],i=this.child[1];if(!this.isLeaf&&e&&i){const r=e.insert(t);return r!==null?r:i.insert(t)}else{if(this.data)return null;const r=this.bounds.fits(t.bounds);if(r===0)return null;if(r===1)return this.data=t.data,this;this.isLeaf=!1;const s=t.bounds.width,a=t.bounds.height,o=this.bounds.width-s,c=this.bounds.height-t.bounds.height;o>c?(e=this.child[0]=new qe(this.bounds.x,this.bounds.y,s,this.bounds.height),i=this.child[1]=new qe(this.bounds.x+s,this.bounds.y,o,this.bounds.height)):(e=this.child[0]=new qe(this.bounds.x,this.bounds.y,this.bounds.width,a),i=this.child[1]=new qe(this.bounds.x,this.bounds.y+a,this.bounds.width,c))}return e.insert(t)}remove(t){const e=this.child[0],i=this.child[1];if(i&&e&&!this.isLeaf){let r=e.remove(t);return r?!0:(r=i.remove(t),e.hasChild()||i.hasChild()||(this.child[0]=null,this.child[1]=null),r)}else return this.data===t?(this.data=null,!0):!1}static applyToSubTexture(t,e,i,r,s){if(!i)return;r=r||{top:0,left:0,bottom:0,right:0};const a=e instanceof qe?e.bounds:e,o=(a.x+r.left)/t.bounds.width,c=(a.y+r.top)/t.bounds.height,l=(a.width-r.left-r.right)/t.bounds.width,u=(a.height-r.top-r.bottom)/t.bounds.height;let d;s?d=new ie({bottom:1-c,left:o,right:o+l,top:1-(c+u)}):d=new ie({top:1-c,left:o,right:o+l,bottom:1-(c+u)});const p=d.bottom,g=d.y,m=d.x,v=d.x+d.width;i.atlasTL=[m,g],i.atlasBR=[v,p],i.atlasBL=[m,p],i.atlasTR=[v,g],i.widthOnAtlas=Math.abs(i.atlasTR[0]-i.atlasTL[0]),i.heightOnAtlas=Math.abs(i.atlasTR[1]-i.atlasBR[1]),i.pixelWidth=l*t.bounds.width,i.pixelHeight=u*t.bounds.height}}function ad(n){return n&&n.call!==void 0&&n.apply!==void 0}function ni(n,t,e){let i=n.get(t);return i===void 0&&(ad(e)?i=e():i=e,n.set(t,i)),i}function ha(n,t,e){let i=n.get(t);return i===void 0&&(ad(e)?i=e():i=e),i}class rt{}f(rt,"transparentShapeBlending",{blending:{blendDst:h.GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha,blendEquation:h.GLSettings.Material.BlendingEquations.Add,blendSrc:h.GLSettings.Material.BlendingSrcFactor.SrcAlpha},culling:h.GLSettings.Material.CullSide.NONE,modify(t){return Object.assign({},this,t)}}),f(rt,"transparentImageBlending",{blending:{blendSrc:h.GLSettings.Material.BlendingSrcFactor.One,blendDst:h.GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha,blendEquation:h.GLSettings.Material.BlendingEquations.Add},culling:h.GLSettings.Material.CullSide.NONE,modify(t){return Object.assign({},this,t)}});class Kg{static async modify(t,e,i){for(let r=0,s=e.length;r<s;++r){const a=e[r];for(let o=0,c=t.length;o<c;++o){const l=t[o],u=l.getEasing(a);u&&i(u,l,o,r)}}}static async all(t,e,i,r){let s=ks;const a=new Promise(l=>s=l);let o=0;for(let l=0,u=i.length;l<u;++l){const d=i[l];for(let p=0,g=e.length;p<g;++p){const m=e[p],v=m.getEasing(d);v&&(r&&r(v,m,p,l),o=Math.max((v.delay||0)+v.duration,o))}}const c=l=>{l<o?Cn(c):s()};return t?Cn(l=>{o+=l,c(l)}):s(),a}}const Zg=5,Jg=10;function em(n,t){const e=[];return t.forEach(i=>{n.find(r=>i instanceof r)&&e.push(i)}),e}class od{constructor(t,e){f(this,"TL");f(this,"TR");f(this,"BL");f(this,"BR");const i=t.mid;this.TL=new er(t.x,i[0],t.y,i[1],e),this.TR=new er(i[0],t.right,t.y,i[1],e),this.BL=new er(t.x,i[0],i[1],t.bottom,e),this.BR=new er(i[0],t.right,i[1],t.bottom,e)}destroy(){this.TL.destroy(),this.TR.destroy(),this.BL.destroy(),this.BR.destroy()}}class er{constructor(t,e,i,r,s){f(this,"bounds");f(this,"children",[]);f(this,"depth",0);f(this,"nodes");arguments.length>=4?this.bounds=new ie({left:t,right:e,top:i,bottom:r}):this.bounds=new ie({left:0,right:1,top:0,bottom:1}),this.depth=s||0}destroy(){this.children=[],this.nodes&&(this.nodes.destroy(),delete this.nodes)}add(t,e){return t.isInside(this.bounds)?this.doAdd(t):(this.cover(t),this.add(t,e))}addAll(t){let e=Number.MAX_SAFE_INTEGER,i=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER;const{min:a,max:o}=Math;for(let c=0,l=t.length;c<l;++c){const u=t[c];e=a(e,u.x),r=o(u.right,r),i=a(i,u.y),s=o(s,u.bottom)}this.cover(new ie({left:e,right:r,top:i,bottom:s})),t.forEach(c=>this.doAdd(c))}cover(t){if(t.isInside(this.bounds))return;this.bounds.encapsulate(t),this.bounds.x-=1,this.bounds.y-=1,this.bounds.width+=2,this.bounds.height+=2;const e=this.gatherChildren([]);this.nodes&&(this.nodes.destroy(),delete this.nodes),e.forEach(i=>this.doAdd(i))}doAdd(t){return this.nodes?t.isInside(this.nodes.TL.bounds)?this.nodes.TL.doAdd(t):t.isInside(this.nodes.TR.bounds)?this.nodes.TR.doAdd(t):t.isInside(this.nodes.BL.bounds)?this.nodes.BL.doAdd(t):t.isInside(this.nodes.BR.bounds)?this.nodes.BR.doAdd(t):(this.children.push(t),!0):t.isInside(this.bounds)?(this.children.push(t),this.children.length>Zg&&this.depth<Jg&&this.split(),!0):(isNaN(t.width+t.height+t.x+t.y)?console.error("Child did not fit into bounds because a dimension is NaN",t):t.area===0&&console.error("Child did not fit into bounds because the area is zero",t),!0)}gatherChildren(t,e){e&&e(this);for(let i=0,r=this.children.length;i<r;++i)t.push(this.children[i]);return this.nodes&&(this.nodes.TL.gatherChildren(t,e),this.nodes.TR.gatherChildren(t,e),this.nodes.BL.gatherChildren(t,e),this.nodes.BR.gatherChildren(t,e)),t}query(t,e){return t instanceof ie?t.hitBounds(this.bounds)?this.queryBounds(t,[],e):[]:ka(t)&&this.bounds.containsPoint(t)?this.queryPoint(t,[],e):[]}queryBounds(t,e,i){return this.bounds.isInside(t)?(this.gatherChildren(e,i),e):(this.children.forEach(r=>{r.hitBounds(t)&&e.push(r)}),i&&i(this),this.nodes&&(t.hitBounds(this.nodes.TL.bounds)&&this.nodes.TL.queryBounds(t,e,i),t.hitBounds(this.nodes.TR.bounds)&&this.nodes.TR.queryBounds(t,e,i),t.hitBounds(this.nodes.BL.bounds)&&this.nodes.BL.queryBounds(t,e,i),t.hitBounds(this.nodes.BR.bounds)&&this.nodes.BR.queryBounds(t,e,i)),e)}queryPoint(t,e,i){return this.children.forEach(r=>{r.containsPoint(t)&&e.push(r)}),i&&i(this),this.nodes&&(this.nodes.TL.bounds.containsPoint(t)&&this.nodes.TL.queryPoint(t,e,i),this.nodes.TR.bounds.containsPoint(t)&&this.nodes.TR.queryPoint(t,e,i),this.nodes.BL.bounds.containsPoint(t)&&this.nodes.BL.queryPoint(t,e,i),this.nodes.BR.bounds.containsPoint(t)&&this.nodes.BR.queryPoint(t,e,i)),e}split(){const t=[];this.gatherChildren(t),this.nodes=new od(this.bounds,this.depth+1),this.children=[];for(let e=0,i=t.length;e<i;++e){const r=t[e];r&&this.doAdd(r)}}visit(t){const e=!!t(this);this.nodes&&!e&&(this.nodes.TL.visit(t),this.nodes.TR.visit(t),this.nodes.BL.visit(t),this.nodes.BR.visit(t))}}class cd extends er{}class Zr{constructor(t){f(this,"options");f(this,"willDispose",new Set);f(this,"keyToItem",new Map);f(this,"keyToInitializer",new Map);f(this,"currentInitalizerIndex",0);f(this,"currentInitializers",[]);f(this,"_items",[]);f(this,"currentInitializer");f(this,"currentItem");f(this,"deferredInlining");f(this,"inlineDeferred",t=>{this.deferredInlining=t});f(this,"inlineImmediate",t=>{if(t.length>0&&this.currentInitializers&&this.currentItem){this.currentInitializers.splice(this.currentInitalizerIndex+1,0,...t);for(let e=0,i=t.length;e<i;++e){const r=t[e];r.parent=this.currentItem}}});f(this,"inline",this.inlineImmediate);this.options=t}get items(){return this._items.slice(0)}async destroy(){const t=[];for(let e=0,i=this.currentInitializers.length;e<i;++e){const r=this.currentInitializers[e],s=this.keyToItem.get(r.key);s&&t.push(this.options.destroyItem(r,s))}await Promise.all(t)}async diff(t){const e=t.slice(0);this.currentInitializers=e,this._items=[];let i=0;for(;i<e.length;){const r=e[i];if(this.currentInitalizerIndex=i,this.currentInitializer=r,this.willDispose.has(r.key)){let s=this.keyToItem.get(r.key)||null;s?(this.currentItem=s,await this.options.updateItem(r,s)):s=await this.options.buildItem(r),s&&(this.keyToInitializer.set(r.key,r),this.willDispose.delete(r.key),this._items.push(s))}else{this.inline=this.inlineDeferred;const s=await this.options.buildItem(r);this.inline=this.inlineImmediate,s&&(this.currentItem=s,this.deferredInlining&&(this.inline(this.deferredInlining),delete this.deferredInlining),this.keyToItem.set(r.key,s),this.keyToInitializer.set(r.key,r),this._items.push(s))}delete this.currentItem,i++}this.willDispose.forEach(async r=>{const s=this.keyToItem.get(r),a=this.keyToInitializer.get(r);if(!s||!a)return;await this.options.destroyItem(a,s)&&(this.keyToItem.delete(r),this.keyToInitializer.delete(r))}),this.willDispose.clear(),this.keyToInitializer.forEach(r=>{this.willDispose.add(r.key)}),this.currentInitializers=[],delete this.currentItem,delete this.currentInitializer}getByKey(t){return this.keyToItem.get(t)}async rebuild(){if(!this.currentItem||!this.currentInitializer)return;this.keyToItem.delete(this.currentItem.id),this.keyToInitializer.delete(this.currentItem.id),this.options.destroyItem(this.currentInitializer,this.currentItem);const t=await this.options.buildItem(this.currentInitializer);t&&(this.keyToItem.set(this.currentItem.id,t),this.keyToInitializer.set(this.currentItem.id,this.currentInitializer))}}function ii(n){const{shader:t,options:e={},required:i,onError:r,onToken:s,onMain:a}=n,o=new Map,c=new Map,l=new Map,u=new Map,d=t.replace(/\$\{([^\}]*)\}/g,(g,m)=>{let v="";return u.set(m,(u.get(m)||0)+1),m in e?(o.set(m,(o.get(m)||0)+1),v=e[m]):c.set(m,(c.get(m)||0)+1),s&&(v=s(m,v)),v});Object.keys(e).forEach(g=>{o.get(g)||l.set(g,(l.get(g)||0)+1)});const p={resolvedShaderOptions:o,shader:d,shaderProvidedOptions:u,unresolvedProvidedOptions:l,unresolvedShaderOptions:c};if(i&&i.values.forEach(g=>{if(p.unresolvedProvidedOptions.get(g)){const m=`${i.name}: Could not resolve all the required inputs. Input: ${g}`;r?r(m):console.error(m)}else if(p.unresolvedShaderOptions.get(g)){const m=`${i.name}: A required option was not provided in the options parameter. Option: ${g}`;r?r(m):console.error(m)}else if(!p.resolvedShaderOptions.get(g)){const m=`${i.name}: A required option was not provided in the options parameter. Option: ${g}`;r?r(m):console.error(m)}}),a){const g=p.shader,m=g.match(/void((.+)|\s)(main(\s+)\(\)|main\(\))(((.+)(\s*)\{)|(\s*)\{)/gm);if(m&&m.length>0){const v=g.indexOf(m[0]);if(v<0)a(null);else{const b=g.substr(0,v),T=g.substr(v+m[0].length);let w=!1,E=!1,x=1,_=0,I=-1;for(let M=0,C=T.length;M<C;++M){const F=T[M],Q=T[M+1];switch(F){case"/":switch(Q){case"*":!w&&!E&&(w=!0,M++);break;case"/":!w&&!E&&(E=!0,M++);break}break;case"*":Q==="/"&&(E||(w=!1,M++));break;case`
`:case"\r":w||(E=!1);break;case"{":!w&&!E&&x++;break;case"}":!w&&!E&&_++,x===_&&(I=M);break}if(I!==-1)break}if(I!==-1){const M=T.substr(0,I),C=T.substr(I+1),F=a(M,`${b}
${C}`);typeof F=="string"?p.shader=g.substr(0,v+m[0].length)+F+g.substr(v+m[0].length+I):p.shader=g.substr(0,v)+F.header+g.substr(v,m[0].length)+F.main+g.substr(v+m[0].length+I)}else a(null)}}}return p}function tm(n){return new Promise(t=>setTimeout(t,n))}function nm(n){let t=0,e=[];return Object.assign(async r=>{if(r!==void 0&&r!==n&&(e.forEach(u=>u.resolve(!1)),n=r),!n)return!1;const s=++t,a=new $e;let o=n.getBoundingClientRect(),c;if(e.push(a),o.width===0||o.height===0){let u=!0;const d={attributes:!0};c=new MutationObserver(p=>{if(u){for(const g of p)if(g.type==="attributes"){if(!n)return;o=n.getBoundingClientRect(),o.width!==0&&o.height!==0&&(c&&(c.disconnect(),c=void 0),u=!1,a.resolve(s===t))}}}),c.observe(n,d),await Kr(),o=n.getBoundingClientRect(),u&&o.width!==0&&o.height!==0&&(c.disconnect(),u=!1,a.resolve(s===t))}else await Kr(),a.resolve(s===t);const l=await a.promise;return c&&(c.disconnect(),c=void 0),l&&(e.forEach(u=>u.resolve(!1)),e=[]),l},{cancel:()=>{e.forEach(r=>r.resolve(!1)),e=[]}})}function Ri(n,t){const e=Object.assign(t,{key:t.key||n.defaultProps.key,data:t.data||n.defaultProps.data});return{get key(){return t.key||""},init:[n,e]}}function Ai(n,t){const e=Object.assign(t,{key:t.key||n.defaultProps.key,data:t.data||n.defaultProps.data});return{get key(){return t.key||""},init:[n,e]}}function ld(n){return n}function ud(n){return n}const im={layer:Ri,view:Zc,vertex:ud,uniform:ld,attribute:sd};class rm{constructor(t){f(this,"index",-1);f(this,"pool");f(this,"marker",new Map);f(this,"options");this.pool=new Array(t.firstAlloc);for(let e=0,i=t.firstAlloc;e<i;++e)this.pool[e]=t.create();this.options=t}destroy(){for(let t=0,e=this.pool.length;t<e;++t)this.options.destroy(this.pool[t]);this.pool=[],this.marker.clear()}retrieve(){const t=this.pool[this.index+1];return this.index++,this.marker.set(t,this.index),t}replace(t){const e=this.marker.get(t);e!==void 0&&(this.pool[e]=this.pool[this.index],this.pool[this.index]=t,this.marker.delete(t),this.index--)}}function sm(n,t,e,i){return t<0&&(t=n.length+t,t<0&&(t=0)),n.slice(0,t)+(i||"")+n.slice(t+e)}function Jr(n){let t=!1,e=!1;const i=[];let r={start:-1,stop:-1},s={start:-1,stop:-1};for(let a=0,o=n.length;a<o;++a){const c=n[a],l=n[a+1];switch(c){case"/":switch(l){case"*":!e&&!t&&(r.start=a,t=!0,a++);break;case"/":!t&&!e&&(s.start=a,e=!0,a++);break}break;case"*":l==="/"&&t&&(r.stop=a+2,i.push(r),r={start:-1,stop:-1},t=!1,a++);break;case`
`:case"\r":e&&(s.stop=a,i.push(s),s={start:-1,stop:-1},e=!1);break}}return i.reverse(),i.forEach(a=>{n=sm(n,a.start,a.stop-a.start)}),n}function ri(n){return n?[n.atlasTL[0],n.atlasTL[1],n.atlasBR[0],n.atlasBR[1]]:[0,0,0,0]}class Nn{constructor(t){f(this,"_uid",z());f(this,"aspectRatio",1);f(this,"atlasTL",[0,0]);f(this,"atlasTR",[0,0]);f(this,"atlasBL",[0,0]);f(this,"atlasBR",[0,0]);f(this,"heightOnAtlas",0);f(this,"isValid",!1);f(this,"pixelWidth",0);f(this,"pixelHeight",0);f(this,"atlasRegion");f(this,"source");f(this,"texture",null);f(this,"video");f(this,"widthOnAtlas",0);Object.assign(this,t)}get uid(){return this._uid}static fromRegion(t,e){if(!t.data)return null;const i=e.x/t.data.width,r=e.y/t.data.height,s=e.width/t.data.width,a=e.height/t.data.height,o=new ie({bottom:r+a,left:i,right:i+s,top:r}),c=o.bottom,l=o.y,u=o.x,d=o.x+o.width,p=new Nn;return p.atlasTL=[u,l],p.atlasBR=[d,c],p.atlasBL=[u,c],p.atlasTR=[d,l],p}update(){!this.texture||!this.source||!this.atlasRegion||this.texture.update(this.source,this.atlasRegion)}toString(){return JSON.stringify({atlas:{TL:this.atlasTL,TR:this.atlasTR,BL:this.atlasBL,BR:this.atlasBR},width:this.pixelWidth,height:this.pixelHeight},null,2)}}const am=Ie("performance");function hd(n){return{key:"",type:he.ATLAS,...n}}function Uc(n){return n&&n.type===he.ATLAS}class dd extends _i{constructor(e){super(e);f(this,"height");f(this,"packing");f(this,"resourceReferences",new Map);f(this,"texture");f(this,"textureSettings");f(this,"type",he.ATLAS);f(this,"width");const i=document.createElement("canvas");if(this.width=i.width=e.width,this.height=i.height=e.height,this.textureSettings=e.textureSettings,e.width<0||e.height<0)throw new Error("TextureSize Error: An atlas does NOT support Screen Texture sizing.");this.packing=new qe(0,0,e.width,e.height),this.createTexture(i)}createTexture(e){if(this.texture)return;let i;this.textureSettings?i={generateMipMaps:!0,premultiplyAlpha:!0,...this.textureSettings}:i={generateMipMaps:!0,premultiplyAlpha:!0},this.texture=new se({data:e,...i})}destroy(){var e;(e=this.texture)==null||e.destroy(),this.resourceReferences.forEach(i=>{this.invalidateTexture(i.subtexture)})}invalidateTexture(e){const i=[0,0];e.aspectRatio=1,e.atlasBL=i,e.atlasBR=i,e.atlasTL=i,e.atlasTR=i,e.isValid=!1,e.texture=null,e.pixelHeight=0,e.pixelWidth=0,delete e.source,e.video&&(e.video.monitor.destroy(),delete e.video)}resolveResources(){const e=[];this.resourceReferences.forEach((i,r)=>{i.count<=0&&i.subtexture&&(am("A subtexture on an atlas has been invalidated as it is deemed no longer used: %o",i.subtexture),this.invalidateTexture(i.subtexture),e.push(r))});for(let i=0,r=e.length;i<r;++i)this.resourceReferences.delete(e[i])}stopUsingResource(e){const i=this.resourceReferences.get(e.source)||{subtexture:e.texture||new Nn,count:0};i.count--}useResource(e){const i=this.resourceReferences.get(e.source)||{subtexture:e.texture,count:0};i.count++}}let Fe;class Ii{static async awaitContext(){for(;!Fe;)this.getContext(),await new Promise(t=>setTimeout(t,10))}static getContext(){Fe||(Fe=document.createElement("canvas").getContext("2d"))}static async calculateImageSize(t){if(await this.awaitContext(),!Fe){console.warn("The Image rasterizer was unable to establish a valid canvas context. Please ensure the system supports contexts and ensure the document is ready first.");return}if(t.width===0||t.height===0){console.warn("Images provided shoud have valid dimensions! Please ensure the image is loaded first.");return}return Fe.canvas.width=100,Fe.canvas.height=100,Fe.drawImage(t,0,0,1,1),[t.width,t.height]}static async resizeImage(t,e){if(await this.awaitContext(),!Fe)return console.warn("The Image rasterizer was unable to establish a valid canvas context. Please ensure the system supports contexts and ensure the document is ready first."),t;if(t.width===0||t.height===0)return console.warn("Images provided shoud have valid dimensions! Please ensure the image is loaded first."),t;Fe.canvas.width=Math.floor(t.width*e),Fe.canvas.height=Math.floor(t.height*e),t instanceof ImageData?Fe.putImageData(t,0,0,0,0,Fe.canvas.width,Fe.canvas.height):Fe.drawImage(t,0,0,Fe.canvas.width,Fe.canvas.height);const i=new Image;return i.src=Fe.canvas.toDataURL("image/png"),await Ii.calculateImageSize(i),i}}class om{constructor(t,e){f(this,"isDestroyed",!1);f(this,"renderedTime",-1);f(this,"previousTime",-1);f(this,"playedFrames",0);f(this,"caughtFrames",0);f(this,"timeFrame",0);f(this,"doUpdate",()=>{Math.abs(this.video.currentTime-this.renderedTime)<.015||(this.renderedTime=this.video.currentTime,this.subTexture.update())});f(this,"loop",t=>{this.doUpdate(),this.isDestroyed||Cn(this.loop)});this.video=t,this.subTexture=e,this.addEventListeners()}async addEventListeners(){this.isDestroyed||this.loop(await Cn())}destroy(){this.video.pause(),this.isDestroyed=!0,this.removeEventListeners()}removeEventListeners(){}}const fd=Ie("performance"),cm=new Nn({aspectRatio:0,atlasBL:[0,0],atlasBR:[0,0],texture:null,atlasTL:[0,0],atlasTR:[0,0],heightOnAtlas:0,isValid:!1,pixelHeight:0,pixelWidth:0,widthOnAtlas:0});function lm(n){return!!(n&&n.isValid&&n.pixelWidth&&n.pixelHeight)}class pd{constructor(){f(this,"allAtlas",new Map);f(this,"renderer")}async createAtlas(t){const e=new dd(t);return this.allAtlas.set(e.id,e),fd("Atlas Created-> %o",e),e}destroy(){this.allAtlas.forEach(t=>t.destroy())}destroyAtlas(t){const e=this.allAtlas.get(t);e&&e.destroy()}setDefaultImage(t,e){return t=Object.assign(t,cm,{atlasReferenceID:e}),t}async draw(t,e){var o;const i=t.id;if(e.disposeResource)return!0;const r=t.resourceReferences.get(e.source);if(r)return e.texture=r.subtexture,!0;e.texture=new Nn,e.texture.isValid=!0,t.resourceReferences.set(e.source,{subtexture:e.texture,count:0});const s=await this.loadImage(e),a=e.texture;if(s&&lm(a)){const c=new ie({bottom:a.pixelHeight,left:0,right:a.pixelWidth,top:0}),l={data:a,bounds:c};l.bounds.width+=0,l.bounds.height+=0;let u=t.packing,d=u.insert(l);if(!d){if(!this.repackResources(t))return console.error("Repacking the atlas failed. Some resources may be in an undefined state. Consider making another atlas."),!1;u=t.packing,d=u.insert(l)}return d?(d.data=a,qe.applyToSubTexture(u,d,a,{top:.5,left:.5,right:.5,bottom:.5}),a.texture=t.texture||null,a.source=s,a.atlasRegion={...d.bounds,y:t.height-d.bounds.y-d.bounds.height},(o=t.texture)==null||o.update(s,a.atlasRegion),s instanceof HTMLVideoElement&&(a.video={monitor:new om(s,a)}),!0):(console.error("Could not fit resource into atlas",e),e.texture=this.setDefaultImage(a,i),!1)}else return a&&!a.isValid?fd("Resource was invalidated during load:",e):console.error("Could not load resource:",e),e.texture&&(e.texture=this.setDefaultImage(e.texture,i)),!1}getAtlasTexture(t){return this.allAtlas.get(t)}async loadImage(t){const e=t.texture||new Nn,i=t.source;if(t.texture=e,t.texture.isValid===!1)return null;if(i instanceof HTMLImageElement){let r=await new Promise(s=>{if(!(i instanceof HTMLImageElement))return;const a=i;if(a.width&&a.height){Ii.calculateImageSize(a),e.pixelWidth=a.width,e.pixelHeight=a.height,e.aspectRatio=a.width/a.height,s(a);return}a?(a.onload=function(){e.pixelWidth=a.width,e.pixelHeight=a.height,e.aspectRatio=a.width/a.height,a.onload=null,s(a)},a.onerror=function(){console.error("Error generating Image element for source:",i),a.onload=null,s(null)}):s(null)});return r&&t.rasterizationScale!==void 0&&t.rasterizationScale!==1&&(r=await Ii.resizeImage(r,t.rasterizationScale||1)),r}else{if(i instanceof HTMLVideoElement)return i.videoHeight===0||i.videoWidth===0?(console.warn("Video requests to the atlas manager MUST have the video completely loaded and ready for loading","There are too many caveats to automate video loading at this low of a level to have it prepped properly for","use in the texture for all browsers. Consider handling video resources at the layer level to have them","prepped for use."),null):(e.pixelWidth=i.videoWidth,e.pixelHeight=i.videoHeight,e.aspectRatio=i.videoWidth/i.videoHeight,i);if(Sn(i)){const r=i;let s=await new Promise(a=>{const o=new Image;o.onload=function(){e.pixelWidth=o.width,e.pixelHeight=o.height,e.aspectRatio=o.width/o.height,o.onload=null,a(o)},o.onerror=function(){console.error("Error generating Image element for source:",i),a(null)},o.crossOrigin="anonymous",o.src=r});return s&&t.rasterizationScale!==void 0&&t.rasterizationScale!==1&&(s=await Ii.resizeImage(s,t.rasterizationScale||1)),s}else{let r=i;return r&&t.rasterizationScale!==void 0&&t.rasterizationScale!==1&&(r=await Ii.resizeImage(r,t.rasterizationScale||1)),r}}}repackResources(t){if(!this.renderer)return console.warn("Attempted to repack resources for an atlas, but no renderer has been specified for this manager yet."),!1;const e=[t.packing],i=[];let r=0;const s=new Map;for(;r<e.length;){const E=e[r];r++,E.data&&E.data.texture&&(i.push(E),s.set(E.bounds,new ie(E.bounds))),E.child[0]&&e.push(E.child[0]),E.child[1]&&e.push(E.child[1])}if(i.sort((E,x)=>Math.max(x.bounds.width,x.bounds.height)-Math.max(E.bounds.width,E.bounds.height)),i.length<=0)return t.packing=new qe(0,0,t.width,t.height),!0;if(!t.texture)return console.warn("Attempted to repack resources for an atlas with no texture."),!1;const a=new se(t.texture);a.data={buffer:new Uint8Array(t.width*t.height*4),width:t.width,height:t.height};const o=new qe(0,0,t.width,t.height);let c=!1;for(let E=0,x=i.length;E<x;++E){const _=i[E];if(!_.data){console.warn("Attempted to repack a node with no valid data.");continue}_.bounds.x=0,_.bounds.y=0;const I=o.insert({bounds:_.bounds,data:_.data});if(!I){console.warn("When repacking the atlas, an existing node was unable to be repacked",_),c=!0;continue}qe.applyToSubTexture(o,I,_.data)}if(c)return!1;const l=new Float32Array(i.length*2*6),u=new Float32Array(i.length*2*6),d=new Nn;for(let E=0,x=i.length;E<x;++E){const _=i[E],I=s.get(_.bounds),M=_.data;if(!I||!M){console.warn("While repacking there was an issue finding the previous bounds and the next texture to use",I,M);continue}qe.applyToSubTexture(o,I,d);const C=E*2*6;l[C]=M.atlasTL[0]*2-1,l[C+1]=M.atlasTL[1]*2-1,l[C+2]=M.atlasTR[0]*2-1,l[C+3]=M.atlasTR[1]*2-1,l[C+4]=M.atlasBL[0]*2-1,l[C+5]=M.atlasBL[1]*2-1,l[C+6]=M.atlasTR[0]*2-1,l[C+7]=M.atlasTR[1]*2-1,l[C+8]=M.atlasBR[0]*2-1,l[C+9]=M.atlasBR[1]*2-1,l[C+10]=M.atlasBL[0]*2-1,l[C+11]=M.atlasBL[1]*2-1,u[C]=d.atlasTL[0],u[C+1]=d.atlasTL[1],u[C+2]=d.atlasTR[0],u[C+3]=d.atlasTR[1],u[C+4]=d.atlasBL[0],u[C+5]=d.atlasBL[1],u[C+6]=d.atlasTR[0],u[C+7]=d.atlasTR[1],u[C+8]=d.atlasBR[0],u[C+9]=d.atlasBR[1],u[C+10]=d.atlasBL[0],u[C+11]=d.atlasBL[1],M.texture=a}const p=new An,g=new Ut(l,2),m=new Ut(u,2);p.addAttribute("position",g),p.addAttribute("texCoord",m);const v=new Yn({buffers:{color:{buffer:a,outputType:0}},retainTextureTargets:!0}),b=new Lr({culling:h.GLSettings.Material.CullSide.NONE,uniforms:{texture:{type:Se.TEXTURE,data:t.texture}},fragmentShader:new Map([[v,{outputNames:[],outputTypes:[0],source:`
          precision highp float;

          uniform sampler2D texture;
          varying vec2 _texCoord;

          void main() {
            gl_FragColor = texture2D(texture, _texCoord);
          }
        `}]]),vertexShader:`
        precision highp float;

        attribute vec2 position;
        attribute vec2 texCoord;
        varying vec2 _texCoord;

        void main() {
          _texCoord = texCoord;
          gl_Position = vec4(position, 0.0, 1.0);
        }
      `}),T=new Ko("__atlas_manager__",p,b);T.vertexCount=i.length*6,T.drawMode=h.GLSettings.Model.DrawMode.TRIANGLES;const w=new Vs;return w.add(T),this.renderer.setRenderTarget(v),this.renderer.setViewport(this.renderer.getFullViewport()),this.renderer.setScissor(this.renderer.getFullViewport()),this.renderer.render(w,v),b.dispose(),p.destroy(),v.dispose(),t.texture.destroy(),t.texture=a,t.packing=o,!0}async updateAtlas(t,e){const i=this.allAtlas.get(t);if(i){for(const r of e)r.disposeResource||await this.draw(i,r);for(let r=0,s=e.length;r<s;++r){const a=e[r];a.disposeResource?i.stopUsingResource(a):i.useResource(a)}i.resolveResources()}else console.warn("Can not update non-existing atlas:",t,"These resources will not be loaded:",e);return i}}const um=Ie("performance");class gd{setDeclaration(t,e,i,r){t.has(e)&&um(`%s: Overriding declaration %s
Setting new value: %s`,r||"Expand IO Declarations",e,i),t.set(e,i)}}class es extends gd{expand(t,e,i,r,s){return{instanceAttributes:[],uniforms:[],vertexAttributes:[],indexBuffer:void 0}}validate(t,e,i,r,s){return!0}processHeaderInjection(t,e,i,r,s,a,o){return{injection:""}}processAttributeDestructuring(t,e,i,r,s,a){return""}}const hm="TextureIOExpansion";function dm(n,t,e){return n&&n.resource&&t.getResourceType(n.resource.key())===e&&n.resource.name!==void 0&&n.resource.key!==void 0}class da extends es{constructor(e,i){super();f(this,"manager");f(this,"resourceType");this.manager=i,this.resourceType=e}expand(e,i,r,s){const a=this.manager,o=[],c=new Map;i.forEach(d=>{if(dm(d,this.manager.router,this.resourceType)){d.size===void 0&&(d.size=P.FOUR);const p=d.resource.shaderInjection||S.FRAGMENT,g=c.get(d.resource.name);g?c.set(d.resource.name,[g[0]||p===S.VERTEX||p===S.ALL,g[1]||p===S.FRAGMENT||p===S.ALL]):(o.push(d),c.set(d.resource.name,[p===S.VERTEX||p===S.ALL,p===S.FRAGMENT||p===S.ALL]))}});const l=o.map(d=>{let p=S.FRAGMENT;if(d.resource){const g=c.get(d.resource.name);g&&(p=g[0]&&g[1]&&S.ALL||g[0]&&!g[1]&&S.VERTEX||!g[0]&&g[1]&&S.FRAGMENT||p)}return[{name:d.resource.name,shaderInjection:p,size:R.TEXTURE,update:()=>{const g=a.getResource(d.resource.key());return g&&g.texture||se.emptyTexture}},{name:`${d.resource.name}_size`,shaderInjection:p,size:R.TWO,update:()=>{const g=a.getResource(d.resource.key());if(g){const m=g.texture;if(m&&m.data){const{width:v,height:b}=m.data;return[v||1,b||1]}}return[1,1]}}]}),u=[];return l.forEach(d=>d.forEach(p=>u.push(p))),{instanceAttributes:[],vertexAttributes:[],uniforms:u}}validate(e,i,r,s){let a=!1;return i.forEach(o=>{o.easing&&o.resource&&(console.warn("An instance attribute can not have both easing and resource properties. Undefined behavior will occur."),console.warn(o),a=!0)}),!a}processHeaderInjection(e,i,r,s,a,o,c){const l={injection:""};for(let u=0,d=c.length;u<d;++u){const p=c[u],g=p.shaderInjection||S.VERTEX;p.size===R.TEXTURE&&g===e&&this.setDeclaration(i,p.name,`uniform sampler2D ${p.name};
`,hm)}return l}}class md extends Ji{constructor(e){super();f(this,"resources",new Map);f(this,"atlasManager");f(this,"requestQueue",new Map);f(this,"requestLookup",new Map);this.atlasManager=e&&e.atlasManager||new pd}get webGLRenderer(){return this._webGLRenderer}set webGLRenderer(e){this._webGLRenderer=e,this.atlasManager.renderer=e}async dequeueRequests(){let e=!1;const i=[];this.requestQueue.forEach((r,s)=>{i.push([s,r])}),this.requestQueue.clear();for(const[r,s]of i)if(s.length>0){e=!0;const a=s.slice(0);s.length=0,await this.atlasManager.updateAtlas(r,a);const o=this.requestLookup.get(r);if(o){const c=new Set;a.forEach(l=>{const u=o.get(l);if(o.delete(l),u&&!l.disposeResource)for(let d=0,p=u.length;d<p;++d){const[g,m]=u[d];g.managesInstance(m)&&(m.active=!0),c.add(m)}}),Kr(()=>{c.forEach(l=>{l.active=!0,l.resourceTrigger()})})}}return e}destroy(){this.atlasManager.destroy()}destroyResource(e){this.resources.get(e.key)&&(this.atlasManager.destroyAtlas(e.key),this.resources.delete(e.key))}getAtlasTexture(e){const i=this.atlasManager.getAtlasTexture(e);return i&&i.texture||null}getResource(e){return this.resources.get(e)||null}getIOExpansion(){return[new da(he.ATLAS,this)]}async initResource(e){if(Uc(e)){const i=await this.atlasManager.createAtlas(e);this.resources.set(e.key,i)}}request(e,i,r,s){const a=r.key||"",o=r.texture;if(o)return ri(o);let c=this.requestLookup.get(a);if(c){const u=c.get(r);if(u)return u.push([e,i]),i.active=!1,ri(r.texture)}else c=new Map,this.requestLookup.set(a,c);r.disposeResource||(i.active=!1);let l=this.requestQueue.get(a);return l||(l=[],this.requestQueue.set(a,l)),l.push(r),c.set(r,[[e,i]]),ri(o)}updateResource(e){Uc(e)}}const fm=new Image;function tr(n){return{type:he.ATLAS,source:fm,...n}}class vd extends Ji{constructor(){super(...arguments);f(this,"resources",new Map)}async dequeueRequests(){return!1}destroy(){this.resources.forEach(e=>e.destroy()),this.resources.clear()}getIOExpansion(){return[new da(he.TEXTURE,this)]}getResource(e){return this.resources.get(e)||null}destroyResource(e){const i=this.resources.get(e.key);i&&(i.destroy(),this.resources.delete(e.key))}async initResource(e){let i=this.resources.get(e.key);if(i){console.warn("Attempted to generate a RenderTexture that already exists for key",e.key);return}i=new Bc(e,this.webGLRenderer),this.resources.set(e.key,i)}request(e,i,r,s){const a=this.resources.get(r.key);return a?(r.texture=a.texture,[0,0,1,1]):[0,0,0,0]}resize(){const e=new Map;this.resources.forEach((i,r)=>{i.width>ft.SCREEN&&i.height>ft.SCREEN||(i.texture.destroy(),i=new Bc(i,this.webGLRenderer),e.set(r,i))}),e.forEach((i,r)=>this.resources.set(r,i))}updateResource(e){this.resources.get(e.key)&&console.warn("UPDATING AN EXISTING RENDER TEXTURE IS NOT SUPPORTED YET")}}function ts(n){return{type:he.TEXTURE,...n}}const{ceil:pm,max:bd,log2:gm,pow:mm,sqrt:vm}=Math,lt=[-1,-1];function bm(n,t){const{width:e,height:i}=n;let r;const s=[],a=[];for(let o=0;o<e;++o){s[o]=[],a[o]=[];for(let c=0;c<i;++c){const l=c*(e*4)+o*4;r=t[l+3],r?(s[o][c]=[o,c],a[o][c]=lt):(s[o][c]=lt,a[o][c]=[o,c])}}return{seed:s,inverse:a}}function wm(n){const t=[];for(let e=0,i=n.length;e<i;++e)t[e]=[];return t}function wd(n,t,e=!1){const i=e?-1:1;let r,s,a,o;const c=[];let l=-1;for(let u=0,d=n.length;u<d;++u){const p=n[u];c[u]=[];for(let g=0,m=p.length;g<m;++g)r=p[g],r===t?o=256:(s=[u,g],a=Ae(r,s),o=vm(Gi(a,a))),c[u][g]=o,l=bd(o,l)}for(let u=0,d=n.length;u<d;++u){const p=n[u];for(let g=0,m=p.length;g<m;++g)o=c[u][g],c[u][g]=o/l*255*i}return c}function Tm(n,t,e,i){let r;const s=wd(n,e,!0),a=wd(t,e,!1),o=s.length,c=s;for(let l=0,u=s.length;l<u;++l){const d=s[l],p=a[l];for(let g=0,m=d.length;g<m;++g){const v=d[g],b=p[g];d[g]=v+b}}for(let l=0,u=c.length;l<u;++l){const d=c[l];for(let p=0,g=d.length;p<g;++p){r=d[p];const m=p*(o*4)+l*4;i[m]=r,i[m+1]=r,i[m+2]=r,i[m+3]=255}}}function Td(n,t){const e=n.length,i=n[0].length;let r=wm(n),s=n,a,o,c,l,u,d,p,g,m;for(let v=0;v<t;++v){const b=r;r=s,s=b;const T=mm(2,t-v-1);for(p=0;p<e;++p)for(g=0;g<i;++g){for(a=[p,g],c=[(r[p-T]||[])[g-T]||lt,(r[p]||[])[g-T]||lt,(r[p+T]||[])[g-T]||lt,(r[p-T]||[])[g]||lt,(r[p]||[])[g]||lt,(r[p+T]||[])[g]||lt,(r[p-T]||[])[g+T]||lt,(r[p]||[])[g+T]||lt,(r[p+T]||[])[g+T]||lt],u=0,l=Number.MAX_VALUE,m=0;m<9;++m){const w=c[m];w!==lt&&(o=Ae(w,a),d=Gi(o,o),d<l&&(l=d,u=m))}s[p][g]=c[u]}}return s}function ym(n,t=Tm){const{width:e,height:i}=n,r=n.getContext("2d");if(!r)return;const s=r.getImageData(0,0,e,i).data,a=bd(e,i),o=pm(gm(a)),c=bm(n,s),l=Td(c.seed,o),u=Td(c.inverse,o),d=new ImageData(e,i);t(l,u,lt,d.data),r.putImageData(d,0,0)}function Em(n){}const fa=Ie("performance");var pa=(n=>(n[n.BITMAP=0]="BITMAP",n[n.SDF=1]="SDF",n[n.MSDF=2]="MSDF",n))(pa||{});class yd extends _i{constructor(e){super(e);f(this,"dynamic",!1);f(this,"fontSource");f(this,"glyphCount",0);f(this,"glyphMap",{});f(this,"kerning",{});f(this,"packing");f(this,"spaceWidth",0);f(this,"texture");f(this,"textureSettings");f(this,"type",he.FONT);this.dynamic=e.dynamic||!1,this.fontSource=e.fontSource,e.characters&&e.characters.forEach(r=>{this.doRegisterGlyph(r[0],r[1])});const i=e.fontMapSize?e.fontMapSize:[ft._1024,ft._1024];this.makeGlyphTypeTextureSettings(e.glyphType),this.createTexture(i),this.packing=new qe(0,0,i[0],i[1]),this.addCachedKerning()}get fontString(){return`${this.fontSource.size}px ${this.fontSource.family}`}getKerningCacheName(){return`__deltav_kerning_cache_${this.fontSource.family}__`}addCachedKerning(){if(this.fontSource.localKerningCache){const e=localStorage.getItem(this.getKerningCacheName());if(e){fa("Loading cached kerning items:",this.getKerningCacheName());try{const i=JSON.parse(e);let r=0;for(const s in i){let a=typeof s=="string"&&s.length===1;if(!a)continue;const o=i[s],c=this.kerning[s]||{};this.kerning[s]=c;for(const l in o)a=typeof s=="string"&&s.length===1,a&&(c[l]=o[l],r++)}fa("Found kerning items in the cache!","Count:",r)}catch{}}}}addKerning(e){let i=!1;for(const r in e){const s=e[r],a=this.kerning[r]||{};this.kerning[r]||(i=!0),this.kerning[r]=a;for(const o in s)a[o]||(i=!0),a[o]=s[o]}if(i&&this.fontSource.localKerningCache)try{fa("Storing kerning info in cache...");const r=JSON.stringify(this.kerning);localStorage.setItem(this.getKerningCacheName(),r)}catch{fa("Could not cache kerning info")}}createTexture(e){if(this.texture)return;let i;this.textureSettings?i={generateMipMaps:!0,premultiplyAlpha:!0,...this.textureSettings}:i={generateMipMaps:!0,premultiplyAlpha:!0},this.texture=new se({data:{width:e[0],height:e[1],buffer:null},...i})}destroy(){var e;(e=this.texture)==null||e.destroy()}doRegisterGlyph(e,i){const r=e[0];this.glyphMap[r]?console.warn("A Glyph is already registered with a rendering"):this.glyphMap[r]=i}findMissingCharacters(e){const i=new Set;let r="";for(let s=0,a=e.length;s<a;++s){const o=e[s];!this.glyphMap[o]&&!i.has(o)&&(i.add(o),r+=o)}return r}getGlyphTexture(e){return this.glyphMap[e[0]]||null}getGlyphKerning(e,i){const r=this.kerning[e];return r?r[i]||[0,0]:[0,0]}getGlyphWidth(e,i,r){const s=e.positions[i],a=e.positions[r];if(!i||!r)return 0;const o=this.glyphMap[e.glyphs[r]];return o?a[0]+o.pixelWidth-s[0]:0}async getTruncatedLayout(e,i,r,s,a,o){if(e.size[0]>r){let c="",l=0;for(let v=0,b=i.length;v<b;++v)l+=this.glyphMap[i[v]].pixelWidth;if(l>r)return{fontScale:1,glyphs:"",positions:[],size:[0,0],text:""};let u=0,d=e.positions.length,p=0,g=0,m="";for(;u!==d;){if(p=Math.floor((d-u)/2)+u,m=e.glyphs[p],g=e.positions[p][0]+this.glyphMap[m].pixelWidth+l,g>r)d=p;else if(g<r)u=p;else break;if(Math.abs(u-d)<=1){if(g<r)break;for(;g>r&&p>=0;)p--,g=e.positions[p][0]+this.glyphMap[m].pixelWidth+l;break}}if(g=e.positions[p][0]+this.glyphMap[m].pixelWidth+l,g<r){let v=0,b=0;for(let E=0,x=e.text.length;E<x&&v<=p;++E){const _=e.text[E];b++,vi(_)||v++}const T=e.text[b-1];let w;for(let E=0,x=i.length;E<x;++E)if(!vi(i[E])){w=i[E];break}if(T&&w&&!this.kerning[T][w]){const E=await o.estimateKerning([T+w],this.fontString,this.fontSource.size,this.kerning,!1,this.fontSource.embed);this.addKerning(E.pairs)}c=`${e.text.substr(0,b)}${i}`}else c=i;return this.getStringLayout(c,s,a)}return e}getStringWidth(e,i,r){const s=e.text;let a=0,o=s.length;if(typeof i=="string"){const p=s.indexOf(i);if(p<0)return 0;a=p,o=a+i.length}else a=i;r!==void 0&&(o=r);let c=0;const l=Math.min(s.length,a),u=Math.min(s.length,o);for(;c<l;++c)vi(s[c])&&(a--,o--);for(;c<u;++c)vi(s[c])&&o--;const d=this.glyphMap[e.text[o]||""];return d?(e.positions[o]||[0,0])[0]-(e.positions[a]||[0,0])[0]+d.pixelWidth:0}getStringLayout(e,i,r){const s=[];let a="";const o=i/this.fontSource.size;let c=Number.MAX_SAFE_INTEGER,l=0,u=0,d=[0,0];const p=this.spaceWidth;let g=0,m="",v,b;for(let E=0,x=e.length;E<x;++E){const _=e[E];if(vi(_)){g++;continue}v=[0,0],m&&(v=this.kerning[m][_]||[0,0]),d=xn(xn(d,Ce(v,o)),[g*p*o+(E===0?0:r),0]),s.push([d[0],d[1]]),a+=_,b=this.glyphMap[_],c=Math.min(d[1],c),l=Math.max(d[1]+b.pixelHeight*o,l),m=_,u=d[0]+b.pixelWidth*o,g=0}const T=l-c,w=[u,T];for(let E=0,x=s.length;E<x;++E)d=s[E],d[1]-=c;return{fontScale:o,glyphs:a,positions:s,size:w,text:e}}makeGlyphTypeTextureSettings(e){switch(e){case 0:this.textureSettings={magFilter:h.GLSettings.Texture.TextureMagFilter.Linear,minFilter:h.GLSettings.Texture.TextureMinFilter.LinearMipMapLinear,internalFormat:h.GLSettings.Texture.TexelDataType.LuminanceAlpha,format:h.GLSettings.Texture.TexelDataType.LuminanceAlpha};break;case 1:this.textureSettings={magFilter:h.GLSettings.Texture.TextureMagFilter.Linear,minFilter:h.GLSettings.Texture.TextureMinFilter.Linear,internalFormat:h.GLSettings.Texture.TexelDataType.Luminance,format:h.GLSettings.Texture.TexelDataType.Luminance};break;case 2:this.textureSettings={magFilter:h.GLSettings.Texture.TextureMagFilter.Linear,minFilter:h.GLSettings.Texture.TextureMinFilter.Linear,internalFormat:h.GLSettings.Texture.TexelDataType.RGB,format:h.GLSettings.Texture.TexelDataType.RGB};break}}registerGlyph(e,i){this.dynamic?this.doRegisterGlyph(e,i):console.warn("Attempted to register a new glyph with a non-dynamic FontMap")}supportsKerning(e){for(let i=1,r=e.length;i<r;++i){const s=e[i],a=e[i-1];if(this.kerning[a]){if(!this.kerning[a][s])return!1}else return!1}return!0}}const{min:Ed,max:ga}=Math,Si=document.createElement("canvas");let Pn;function _m(n){const{width:t,height:e}=n.canvas,i=n.getImageData(0,0,t,e).data;let r,s=!1,a=Number.MAX_SAFE_INTEGER,o=Number.MAX_SAFE_INTEGER,c=Number.MIN_SAFE_INTEGER,l=Number.MIN_SAFE_INTEGER;for(let u=0;u<t;++u)for(let d=0;d<e;++d){const p=d*(t*4)+u*4;r=i[p],r>0&&(s=!0,a=Ed(a,d),o=Ed(o,u),c=ga(c,u),l=ga(l,d))}return s?(a-=1,l+=2,c+=2,o-=1,a=ga(a,0),o=ga(o,0),{minX:o,minY:a,maxX:c,maxY:l}):null}function Fc(n,t,e,i){if(n=n[0],(Si.width<t||Si.height<e)&&(Si.width=t,Si.height=e),!Pn){const c=Si.getContext("2d",{willReadFrequently:!0});if(c)Pn=c;else return null}Pn.clearRect(0,0,Si.width,Si.height),Pn.font=i,Pn.fillStyle="white",Pn.fillText(n,t/2,e/2);const r=_m(Pn);if(!r)return{data:Pn.getImageData(0,0,1,1),size:[0,0]};const s=r.maxX-r.minX,a=r.maxY-r.minY;return{data:Pn.getImageData(r.minX,r.minY,s,a),size:[s,a]}}const un=document.createElement("img"),ut=document.createElement("canvas");function xm(n,t,e=400,i="normal",r="woff2"){return`
    @font-face {
      font-family: '${n}';
      src: url('${t}') ${r?`format('${r}')`:""};
      font-weight: ${e};
      font-style: ${i};
    }
  `}async function _d(n,t,e){const i=new $e;if(!un||!ut)return null;if(e&&t){const d=document.createElementNS(t,"style");d.textContent=e.map(p=>xm(p.familyName,p.source,p.weight,p.style,p.fontType)).join(`
`),n.prepend(d)}const r=new XMLSerializer().serializeToString(n),o="data:image/svg+xml;base64,"+btoa(r);let c=!1;const l=async()=>{if(c)return;c=!0,ut.width=un.width*window.devicePixelRatio,ut.height=un.height*window.devicePixelRatio;const d=ut.getContext("2d",{willReadFrequently:!0});if(!d){i.resolve(null);return}d.clearRect(0,0,ut.width,ut.height),d.mozImageSmoothingEnabled=!1,d.webkitImageSmoothingEnabled=!1,d.msImageSmoothingEnabled=!1,d.imageSmoothingEnabled=!1,d.drawImage(un,0,0,un.width*window.devicePixelRatio,un.height*window.devicePixelRatio),i.resolve(d.getImageData(0,0,ut.width,ut.height)),ut.style.position="absolute",ut.style.top="100px",ut.style.left="0px",ut.style.zIndex="9999",ut.id="svg-to-data"};return un.onload=l,un.src=o,un.width>0&&un.height>0&&l(),await i.promise}const ma=Ie("performance"),{floor:kc}=Math;async function Rm(n,t,e,i,r){const s="http://www.w3.org/2000/svg",a=N.MAX_TEXTURE_SIZE/window.devicePixelRatio,o=t*2,c=t*1.3,l=kc(a/o),u=document.createElementNS(s,"svg");u.setAttribute("width",`${a}px`),u.style.font=n,u.style.fontFamily="RedHatDisplay",u.style.position="relative",u.style.left="0px",u.style.top="0px";const d=[],p=Math.floor(a/c);let g=0,m=0,v=0,b,T,w=0;for(;m<e.all.length;){const B=document.createElementNS(s,"g");b=B,g=Math.floor(d.length/p),B.setAttribute("transform",`translate(0, ${(d.length-g*p)*c})`),d.push(B);let O=a;for(v=0;v<l&&m<e.all.length;v++){const X=document.createElementNS(s,"text");X.setAttribute("x",`${v*o}`),X.setAttribute("dy","1em");const W=e.all[m];m++;const q=W[0],ne=W[1],Z=document.createElementNS(s,"tspan"),K=document.createElementNS(s,"tspan");Z.setAttribute("fill","#ff0000"),K.setAttribute("fill","#0000ff"),Z.textContent=q,K.textContent=ne,X.appendChild(Z),X.appendChild(K),B.appendChild(X),O-=o}if(O>=0){const X=document.createElementNS(s,"text");X.setAttribute("width",`${O}px`),B.appendChild(X),T=X}else T=null;w=O}const E=[];for(let B=0;B<e.all.length;B++)E.push([Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER]);let x=0,_=!1;if(i){const B="M",O=document.createElementNS(s,"text");O.setAttribute("dy","1em"),O.style.width=`${o}`,O.style.height=`${c}`,O.setAttribute("x",`${o*v}`),O.style.font=n;const X=await Fc(B,128,128,n);if(X){x=X.size[0];const W=document.createElementNS(s,"tspan"),q=document.createElementNS(s,"tspan"),ne=document.createElementNS(s,"tspan");if(W.setAttribute("fill","#ff0000"),ne.setAttribute("fill","#0000ff"),W.textContent=B,ne.textContent=B,q.textContent=" ",O.appendChild(W),O.appendChild(q),O.appendChild(ne),v<l&&b)b.appendChild(O),w-=o,T&&(T.remove(),w>0&&(b.style.width=`${w}px`,b.appendChild(T)));else{const Z=document.createElement("g");g=Math.floor(d.length/p),Z.setAttribute("transform",`translate(0, ${(d.length-g*p)*c})`),b=Z,b.appendChild(O),d.push(Z),T=document.createElementNS(s,"text"),Z.appendChild(T)}E.push([Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER]),_=!0}}const I=d.length*c,M=Math.ceil(I/a);let C=null;ma("Rendering table canvas batches for font kerning analysis",e,d);for(let B=0;B<M;++B){const O=d.splice(0,p),X=O.length*c;for(u.setAttribute("height",`${X}px`);u.lastElementChild;)u.lastElementChild.remove();for(let W=0,q=O.length;W<q;++W){const ne=O[W];u.appendChild(ne)}if(!C)C=await _d(u,s,r);else{const W=await _d(u,s,r);if(!W){console.warn("Font Renderer: Could not generate image data for analyzing font kerning");continue}const q=new Uint8ClampedArray(C.data.length+W.data.length);q.set(C.data),q.set(W.data,C.data.length),C=new ImageData(q,a*window.devicePixelRatio,C.height+W.height)}}ma("Analyzing rendered data",C);const F=o*window.devicePixelRatio,Q=c*window.devicePixelRatio;if(C){const B=C.data;let O,X,W,q,ne,Z;for(let K=0,Oe=C.height;K<Oe;K++)for(let le=0,we=C.width;le<we;le++)O=(we*K+le)*4,X=B[O+0],W=B[O+1],q=B[O+2],Z=kc(K/Q)*l+kc(le/F),Z<E.length&&(ne=E[Z],X>0&&W===0&&q===0&&(le<ne[0]&&(ne[0]=le),K<ne[1]&&(ne[1]=K)),X===0&&W===0&&q>0&&(le<ne[2]&&(ne[2]=le),K<ne[3]&&(ne[3]=K)));if(_){const K=E.pop();if(K){const Oe=[K[2]-K[0],0],le=Ce(Oe,1/window.devicePixelRatio);e.spaceWidth=Math.ceil(le[0])-x}}for(let K=0,Oe=E.length;K<Oe;K++){const le=e.all[K],we=le[0],He=le[1],Vn=E[K],$n=[Vn[2]-Vn[0],Vn[3]-Vn[1]],_n=e.pairs[we];if(_n){const Wn=Ce($n,1/window.devicePixelRatio);_n[He]=[Math.ceil(Wn[0]),Wn[1]]}}}else console.warn("html2canvas did not produce a valid canvas context to analyze");ma("Kerning rendering analysis complete",e.pairs)}function Am(n,t,e){n=n.replace(/\s/g,"");const i=e&&e.all||[],r=e&&e.pairs||{};for(let s=0;s<n.length-1;s++){const a=n[s],o=n[s+1];let c=r[a];c||(c=r[a]={}),(!t[a]||!t[a][o])&&!c[o]&&(c[o]=[0,0],i.push(`${a}${o}`))}return{all:i,pairs:r,spaceWidth:0}}class xd{makeBitmapGlyphs(t,e,i){const r={},s=new Set;for(let o=0,c=t.length;o<c;++o)s.add(t[o]);const a=Array.from(s.values());for(let o=0,c=a.length;o<c;++o){const l=a[o],u=Fc(l,i*2,i*2,e);u?r[l]={glyph:u.data,glyphIndex:o}:console.warn("Unable to render character",l,"to font map for rendering.")}return r}async estimateKerning(t,e,i,r,s,a){const o={all:[],pairs:{},spaceWidth:0};ma("Estimating Kerning for",t);for(let c=0,l=t.length;c<l;++c){const u=t[c];Am(u,r,o)}return(o.all.length>0||s)&&await Rm(e,i,o,s,a),o}}var Mi=(n=>(n[n.TEXCOORDS=0]="TEXCOORDS",n[n.IMAGE_SIZE=1]="IMAGE_SIZE",n))(Mi||{});function Ci(n){return{type:he.FONT,...n}}function Im(){return".101112131415161718191.202122232425262728292.303132333435363738393.404142434445464748494.505152535455565758595.606162636465666768696.707172737475767778797.808182838485868788898.909192939495969798999.000102030405060708090.$0$1$2$3$4$5$6$7$8$9$%0%1%2%3%4%5%6%7%8%9%-0-1-2-3-4-5-6-7-8-9-+0+1+2+3+4+5+6+7+8+9+)0)1)2)3)4)5)6)7)8)9)(0(1(2(3(4(5(6(7(8(9("}async function Sm(n,t){let e=0,i,r;try{if(!t)return;for(const s of t)i=s,e=0,!document.fonts.check(n)&&(e++,r=new FontFace(s.familyName,`url(${s.source})`,{weight:`${s.weight}`,style:s.style}),e++,await r.load(),e++,document.fonts.add(r));await document.fonts.ready}catch(s){switch(console.error("Font embedding Error:"),e){case 0:console.error("Font embedding failed check:",n);break;case 1:console.error("Font embedding failed to create the font face:",i);break;case 2:console.error("Font embedding failed to load the font face:",{fontFace:r,embedding:i});break;case 3:console.error("Font embedding failed to add the font face",{fontFace:r,embedding:i});break}s instanceof Error&&console.error(s.stack||s.message)}}const Rd=Ie("performance");var Ad=(n=>(n[n._16=16]="_16",n[n._32=32]="_32",n[n._64=64]="_64",n[n._128=128]="_128",n))(Ad||{});function Gc(n){return n&&n.type===he.FONT}function Mm(n){return n&&n.type===void 0}function zc(n){return{key:"",type:he.FONT,...n}}class Id{constructor(){f(this,"fontMaps",new Map);f(this,"fontRenderer",new xd)}async calculateMetrics(t,e){Rd("Calculating metrics for requests");const i=this.fontMaps.get(t);if(i)for(let r=0,s=e.length;r<s;++r){const o=e[r].metrics;o&&(o.layout=i.getStringLayout(o.text,o.fontSize,o.letterSpacing),o.maxWidth&&(Rd("Calculating truncation for",o.text,o.maxWidth),o.layout=await i.getTruncatedLayout(o.layout,o.truncation||"",o.maxWidth,o.fontSize,o.letterSpacing,this.fontRenderer),o.truncatedText=o.layout.text))}}characterFilterToCharacters(t){const e=new Set;let i="";for(let r=0,s=t.length;r<s;++r){const a=t[r];e.has(a)||(e.add(a),i+=a)}return i}async createFontMap(t){const e=this.characterFilterToCharacters(t.characterFilter||""),i=t.fontSource;let r=pa.SDF;i&&(Mm(i)?r=pa.BITMAP:r=i.type||r);const s=new yd({...t,glyphType:r});return await this.updateFontMapCharacters(e,s),this.fontMaps.set(t.key,s),t.fontSource.preload&&this.updateFontMap(t.key,[Ci({key:t.key,character:"",kerningPairs:[t.fontSource.preload],metrics:{fontSize:12,text:t.fontSource.preload,letterSpacing:0}})]),s}destroy(){this.fontMaps.forEach(t=>t.destroy())}destroyFontMap(t){const e=this.fontMaps.get(t);e&&e.destroy()}async updateFontMap(t,e){const i=this.fontMaps.get(t);if(!i)return;let r=[];const s=new Set;for(let o=0,c=e.length;o<c;++o){const l=e[o];if(l.character&&s.add(l.character),l.kerningPairs&&(r=r.concat(l.kerningPairs)),l.metrics&&l.metrics.truncation){const u=l.metrics.truncation.replace(/\s/g,"");r.push(u);for(let d=0,p=l.metrics.truncation.length;d<p;++d)s.add(u)}}for(let o=0,c=r.length;o<c;++o)s.add(r[o]);let a="";s.forEach(o=>a+=o),await Sm(i.fontString,i.fontSource.embed),await this.updateFontMapCharacters(a,i),await this.updateKerningPairs(r,i);for(let o=0,c=e.length;o<c;++o)e[o].fontMap=i}async updateKerningPairs(t,e){if(!e)return;const i=await this.fontRenderer.estimateKerning(t,e.fontString,e.fontSource.size,e.kerning,!e.spaceWidth,e.fontSource.embed);e.addKerning(i.pairs),e.spaceWidth=e.spaceWidth||i.spaceWidth}async updateFontMapCharacters(t,e){if(!e)return;const i=e.texture,r=e.findMissingCharacters(t);if(r.length<=0)return;const s=this.fontRenderer.makeBitmapGlyphs(r,e.fontString,e.fontSource.size);for(const a in s){const o=s[a];if(i!=null&&i.data){const c=new ie({x:0,y:0,width:o.glyph.width,height:o.glyph.height}),l=new Nn,u=e.packing.insert({data:l,bounds:c});if(!u){console.warn("Font map is full and could not pack in any more glyphs");return}qe.applyToSubTexture(e.packing,u,l,void 0,!0),i.update(o.glyph,{...u.bounds,y:e.packing.bounds.height-u.bounds.y-u.bounds.height}),l?e.registerGlyph(a,l):console.warn("Could not generate a subtexture for the font map registration.")}else console.warn("Can not update font map as the maps texture data is not defined.")}}async getPrerenderedImageData(t,e,i){const r=[];return i.forEach(s=>{let a=t.glyphs[s];if(a||(a=t.errorGlyph),!t.errorGlyph)return console.warn("The prerendered source provided did NOT provide a proper glyph for rendering when a glyph could not be located."),[];const o=new Image;let c;const l=new Promise(u=>c=u);return o.onload=function(){const u=document.createElement("canvas"),d=u.getContext("2d");if(!d)return;u.width=e,u.height=e,d.drawImage(o,0,0,e,e);const p=d.getImageData(0,0,e,e);c(p)},o.onerror=function(){console.warn("There was an issue with loading the glyph data for character:",s),c(null)},o.src=t.glyphs[s],r.push(l),[]}),await Promise.all(r)}}const ns=Ie("performance");class Sd extends Ji{constructor(){super(...arguments);f(this,"requestLookup",new Map);f(this,"requestQueue",new Map);f(this,"resourceLookup",new Map);f(this,"fontManager",new Id)}async dequeueRequests(){let e=!1;const i=[];this.requestQueue.forEach((r,s)=>{i.push([s,r])}),this.requestQueue.clear();for(let r=0,s=i.length;r<s;++r){const[a,o]=i[r];if(o.length>0){e=!0;const c=o.slice(0);o.length=0,ns("Processing requests for resource '%s'",a),await this.fontManager.updateFontMap(a,c),await this.fontManager.calculateMetrics(a,c);const l=this.requestLookup.get(a);l?(c.forEach(u=>{const d=l.get(u);if(l.delete(u),d){for(let p=0,g=d.length;p<g;++p){const[m,v]=d[p];m.managesInstance(v)&&(v.active=!0)}Kr(()=>{const p=new Set;for(let g=0,m=d.length;g<m;++g){const v=d[g][1];p.has(v)||(p.add(v),v.resourceTrigger())}})}}),ns("All requests for resource '%s' are processed",a)):ns("There were no Font requests waiting for completion for resource",a)}}return e}destroy(){this.fontManager.destroy()}destroyResource(e){const i=this.resourceLookup.get(e.key);i&&(this.fontManager.destroyFontMap(i.id),this.resourceLookup.delete(e.key))}getResource(e){return this.resourceLookup.get(e)||null}getIOExpansion(){return[new da(he.FONT,this)]}async initResource(e){if(Gc(e)){const i=await this.fontManager.createFontMap(e);i&&this.resourceLookup.set(e.key,i),ns("Font map created->",i)}}request(e,i,r,s){const a=r,o=a.fontMap;let c=null;if(o)return a.character&&(c=o.getGlyphTexture(a.character)),c?a.fetch===Mi.IMAGE_SIZE?[c.pixelWidth,c.pixelHeight]:ri(c):a.fetch===Mi.IMAGE_SIZE?[0,0]:ri(null);const l=r.key;let u=this.requestLookup.get(l);if(u){const p=u.get(a);if(p)return p.push([e,i]),i.active=!1,a.fetch===Mi.IMAGE_SIZE?[0,0]:ri(c)}else u=new Map,this.requestLookup.set(l,u);i.active=!1;let d=this.requestQueue.get(l);return d||(d=[],this.requestQueue.set(l,d)),d.push(a),u.set(a,[[e,i]]),a.fetch?[0,0]:ri(c)}updateResource(e){if(!Gc(e))return;const i=this.resourceLookup.get(e.key);i&&(bc(e.fontSource,i.fontSource)||ns("Font resources currently do not update. To update their properties simply destroy and recreate for now."))}}const Cm=Ie("performance");class Vc{constructor(){f(this,"managers",new Map);f(this,"resourceKeyToType",new Map);f(this,"webGLRenderer")}async dequeueRequests(){let t=!1;const e=Array.from(this.managers.values());for(let i=0,r=e.length;i<r;++i){const a=await e[i].dequeueRequests();t=t||a}return t}destroy(){this.managers.forEach(t=>t.destroy()),this.resourceKeyToType.clear(),this.managers.clear(),delete this.webGLRenderer}async destroyResource(t){const e=this.managers.get(t.type);if(!e){console.warn(`A Resource is trying to be destroyed but has no manager to facilitate the operation: ${t.type}`);return}return this.resourceKeyToType.delete(t.key),await e.destroyResource(t)}getIOExpansion(){let t=[];return this.managers.forEach(e=>{t=t.concat(e.getIOExpansion())}),t}getManager(t){const e=this.managers.get(t);return e||(console.warn(`A manager was requested that does not exist for type ${t}`),nd)}getResourceType(t){return this.resourceKeyToType.get(t)}async initResource(t){const e=this.managers.get(t.type);if(!e){console.warn(`A Resource is trying to be created but has no manager to facilitate the operation: ${t.type}`);return}if(this.resourceKeyToType.has(t.key)){console.warn("Detected two resources with identical keys. The duplicate resource will not be generated:",t.key);return}return this.resourceKeyToType.set(t.key,t.type),await e.initResource(t)}request(t,e,i,r){const s=this.managers.get(i.type);return s?s.request(t,e,i,r):(console.warn(`A Layer is requesting a resource for which there is no manager set. Please make sure a Resource Manager is set for resource of type: ${i.type}`),[-1,-1,-1,-1])}resize(){this.managers.forEach(t=>t.resize())}setManager(t,e){this.managers.get(t)&&Cm(`A manager was assigned to a resource type: ${t} that overrides another manager already set to that type.`),e.router=this,this.managers.set(t,e),e.webGLRenderer=this.webGLRenderer}setWebGLRenderer(t){this.webGLRenderer=t,this.managers.forEach(e=>e.webGLRenderer=t)}async updateResource(t){const e=this.managers.get(t.type);if(!e){console.warn(`A Resource is trying to be updated but has no manager to facilitate the operation: ${t.type}`);return}return await e.updateResource(t)}}const Md=new Vc,Lm={createFont:zc,createAtlas:hd,createTexture:Dc,createColorBuffer:Gg},Om={textureRequest:ts,atlasRequest:tr,fontRequest:Ci,colorBufferRequest:Nc};function Cd(n){const t=n.canvas.height,e=n.canvas.width,r={aspectRatio:e/t,bottom:-t/2,far:1e7,left:-e/2,near:-100,right:e/2,top:t/2,viewSize:t},s=new On({type:Ln.ORTHOGRAPHIC,left:r.left,right:r.right,top:r.top,bottom:r.bottom,near:r.near,far:r.far});return s.scale=[1,-1,1],s.position=[0,0,-300],s.update(),{camera:s,viewport:{bottom:0,left:0,right:0,top:0}}}const Nm={[R.ONE]:Se.FLOAT,[R.TWO]:Se.VEC2,[R.THREE]:Se.VEC3,[R.FOUR]:Se.VEC4,[R.MATRIX3]:Se.MATRIX3x3,[R.MATRIX4]:Se.MATRIX4x4,[R.FLOAT_ARRAY]:Se.FLOAT_ARRAY,[R.TEXTURE]:Se.TEXTURE},Pm={[R.ONE]:[0],[R.TWO]:[0,0],[R.THREE]:[0,0,0],[R.FOUR]:[0,0,0,0],[R.MATRIX3]:[0,0,0,0,0,0,0,0,0],[R.MATRIX4]:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};function Dm(n){return{type:Nm[n.size],data:Pm[n.size]}}function Ld(n,t,e,i,r){const s=n.getMaterialOptions(),a=new Map;e.forEach((c,l)=>{a.set(l.renderTarget||null,c)}),Object.assign(s,n.props.materialOptions||{}),s.vertexShader=t,s.fragmentShader=a,s.name=n.id,s.uniforms={};for(let c=0,l=i.length;c<l;++c){const u=i[c],d=Dm(u);s.uniforms[u.name]=d}for(let c=0,l=r.length;c<l;++c){const u=r[c];s.uniforms[u.name]={type:u.type,data:u.value}}return new Lr(s)}class Bm{constructor(t,e=!1,i=!1){f(this,"data");f(this,"gl");f(this,"_isDynamic");f(this,"_isInstanced",!1);f(this,"_fullUpdate",!1);f(this,"normalize",!1);f(this,"_needsUpdate",!1);f(this,"_updateRange",{count:-1,offset:-1});this.data=t,this._isDynamic=e,this._isInstanced=i}get isDynamic(){return this._isDynamic}get isInstanced(){return this._isInstanced}get fullUpdate(){return this._fullUpdate}get needsUpdate(){return this._needsUpdate}get updateRange(){return this._updateRange}set updateRange(t){this._updateRange=t,this._needsUpdate=!0}destroy(){this.data=new Uint8Array(0),this.gl&&this.gl.proxy.disposeIndexBuffer(this)}rebuild(){this.gl&&this.gl.proxy.disposeIndexBuffer(this)}resize(t,e){if(e>4294967295)throw new Error("Vertex count too high for index buffer");let i;if(e>65535?i=new Uint32Array(t):e>256?i=new Uint16Array(t):i=new Uint8Array(t),i.constructor===this.data.constructor)i.length>=this.data.length?i.set(this.data):i.set(this.data.subarray(0,i.length));else for(let r=0,s=Math.min(t,this.data.length);r<s;r++)i[r]=this.data[r];this.destroy(),this.data=i,this._needsUpdate=!0,this._fullUpdate=!0}repeatInstances(t,e,i,r=1){if(r<1)throw new Error("Can not use repeatInstance on indexBuffer with a startInstance of less than 1");const s=e*t;if(s>4294967296)throw new Error("Vertex count too high for index buffer");const a=this.data.constructor===Uint32Array?4294967296:this.data.constructor===Uint16Array?65536:256;s>a&&this.resize(this.data.length,s);for(let o=r,c=i*(r-1),l=e*r,u=this.data.length;o<t&&c<u;++o,l+=e)for(let d=0;d<i&&c<u;++d,++c)this.data[c]=this.data[d]+l}resolve(){this._needsUpdate=!1,this._fullUpdate=!1}setDynamic(t){this._isDynamic=t,this._needsUpdate=!0,this._fullUpdate=!0}}function Um(n){return qo(n[0])}function Od(n,t,e,i,r){const s=[];for(let p=0,g=e.length;p<g;++p){const m=e[p];s.push(new Float32Array(m.size*i))}const a=e.length;let o,c,l,u=!1;for(let p=0,g=i;p<g;++p)for(let m=0;m<a;++m)if(c=e[m],o=s[m],l=c.update(p),Um(l))for(let v=p*c.size,b=v+c.size,T=0;v<b;++v,++T)o[v]=l[T];else u=!0;u&&console.warn("A vertex buffer updating method should not use arrays of arrays of numbers.");const d=new An;for(let p=0,g=e.length;p<g;++p){const m=e[p],v=new Ut(s[p],m.size);m.materialAttribute=v,d.addAttribute(m.name,v)}if(r){const p=r.indexCount,g=r.update,m=r.size;let v;if(i>4294967296)throw new Error("The maximum number of indices supported by webgl2 is 4294967296. You may have a vertex count or index count that is too large.");switch(m){case $i.UINT8:i>65536?v=new Uint32Array(p):i>256?v=new Uint16Array(p):v=new Uint8Array(p);break;case $i.UINT16:i>65536?v=new Uint32Array(p):v=new Uint16Array(p);break;case $i.UINT32:v=new Uint32Array(p);break}for(let T=0,w=p;T<w;++T)v[T]=g(T);const b=new Bm(v,!1,!1);r.materialIndexBuffer=b,d.setIndexBuffer(b)}return d}function nr(n,t,e,i){const r=new Ko(n,t,e);return r.drawMode=i??h.GLSettings.Model.DrawMode.TRIANGLE_STRIP,r}const si="EasingIOExpansion",{abs:Fm,max:km}=Math,Gm={duration:0,start:[0],end:[0],startTime:0},Nd={1:"float",2:"vec2",3:"vec3",4:"vec4",9:"mat3",16:"mat4",99:"vec4"},$c={easingMethod:"easingMethod",T:"T"};function zm(n){return!!n&&n.easing&&n.size!==void 0&&n.size<=4}function Vm(n){return n}class Pd extends es{constructor(){super(...arguments);f(this,"baseAttributeName",new Map)}expand(e,i,r,s){const a=new Set,o=[],c=[];for(const u of i)zm(u)&&o.push(u);const l={};e.easingId=l;for(let u=0,d=o.length;u<d;++u){const p=o[u],{cpu:g,loop:m,uid:v}=p.easing,{name:b,size:T,update:w}=p,E=v;this.baseAttributeName.set(p,p.name),p.name=`_${p.name}_end`,l[p.name]=E,a.has(E)&&console.error("Undefined behavior occurs if you reuse an IAutoEasingMethod. Please ensure you are using uid() from the util to give the IAutoEasingMethod its uid, or just use the default provided methods"),a.add(E);const x={values:Gm};let _,I,M,C,F,Q,B,O,X,W,q,ne,Z;p.update=we=>{if(X=e.surface.frameMetrics,I=p.easing.delay,M=p.easing.duration,B=w(we),O=X.currentTime,we.easing=ne=we.easing||new Map,W=ne.get(E),!q||!W?(q=G(B),W=new id({duration:M,end:q.copy(B),start:q.copy(B),startTime:O}),ne.set(E,W)):we.reactivate&&(q.copy(B,W.end),q.copy(B,W.end),W.startTime=O),F=W,C=M,_=I,F.isTimeSet&&(C=F.duration||M,_=F.delay||0),!F.isManualStart){switch(Q=1,m){case rn.CONTINUOUS:Q=(O-F.startTime)/C,Z=!0;break;case rn.REPEAT:Q=(O-F.startTime)/C%1,Z=!0;break;case rn.REFLECT:{const He=(O-F.startTime)/C;Q=Fm(He/2%1-.5)*2,Z=!0;break}case rn.NONE:default:Q=(O-F.startTime)/C,Z=!1;break}F.start=g(F.start,F.end,Q,F.start)}return F.startTime=O+_,q.copy(B,F.end),x.values=F,e.animationEndTime=km(e.animationEndTime,F.startTime+C+X.frameDuration),e.alwaysDraw=Z,B},p.childAttributes=p.childAttributes||[];const K={name:`_${b}_start`,parentAttribute:p,size:T,update:we=>x.values.start};p.childAttributes.push(K),c.push(K);const Oe={name:`_${b}_start_time`,parentAttribute:p,size:P.ONE,update:we=>[x.values.startTime]};p.childAttributes.push(Oe),c.push(Oe);const le={name:`_${b}_duration`,parentAttribute:p,size:P.ONE,update:we=>[x.values.duration]};p.childAttributes.push(le),c.push(le)}return{instanceAttributes:c,vertexAttributes:[],uniforms:[]}}validate(e,i,r,s){let a=!1;return i.forEach(o=>{o.easing&&o.resource&&(console.warn("An instance attribute can not have both easing and resource properties. Undefined behavior will occur."),console.warn(o),a=!0),o.easing&&o.size===void 0&&console.warn("An Instance Attribute with easing MUST have a size declared")}),!a}processAttributeDestructuring(e,i,r,s,a,o){const c="";for(let l=0,u=a.length;l<u;++l){const d=a[l];if(!d.easing||!d.size)continue;const p=this.baseAttributeName.get(d);if(!p){console.warn("Could not determine a base name for an easing attribute.");continue}this.baseAttributeName.delete(d);const g=`_${p}_time`,m=`_${p}_duration`,v=`_${p}_start_time`;switch(d.easing.loop){case rn.CONTINUOUS:{this.setDeclaration(i,g,`  float ${g} = (currentTime - ${v}) / ${m};
`,si);break}case rn.REPEAT:{this.setDeclaration(i,g,`  float ${g} = clamp(fract((currentTime - ${v}) / ${m}), 0.0, 1.0);
`,si);break}case rn.REFLECT:{const b=`_${p}_timePassed`,T=`_${p}_pingPong`;this.setDeclaration(i,b,`  float ${b} = (currentTime - ${v}) / ${m};
`,si),this.setDeclaration(i,T,`  float ${T} = abs((fract(${b} / 2.0)) - 0.5) * 2.0;
`,si),this.setDeclaration(i,g,`  float ${g} = clamp(${T}, 0.0, 1.0);
`,si);break}case rn.NONE:default:{this.setDeclaration(i,g,`  float ${g} = clamp((currentTime - ${v}) / ${m}, 0.0, 1.0);
`,si);break}}this.setDeclaration(i,p,`  ${Nd[d.size]} ${p} = ${d.easing.methodName}(_${p}_start, _${p}_end, _${p}_time);
`,si)}return c}processHeaderInjection(e,i,r,s,a,o,c){const l={injection:""};if(e!==S.VERTEX)return l;const u=new Map;if(l.injection=`// Auto Easing Methods specified by the layer
`,o.forEach(p=>{if(p.easing&&p.size){let g=u.get(p.easing.methodName);g||(g=new Map,u.set(p.easing.methodName,g)),g.set(p.size,p.easing.gpu)}}),u.size===0)return l.injection="",l;const d={name:"Easing Method Generation",values:[$c.easingMethod]};return u.forEach((p,g)=>{p.forEach((m,v)=>{const b=Nd[v],T={[$c.easingMethod]:`${b} ${g}(${b} start, ${b} end, float t)`,[$c.T]:`${b}`},w=ii({options:T,required:d,shader:m});this.setDeclaration(i,`${b} ${g}`,`${w.shader}
`,si)})}),l}}const Li="BasicIOExpansion",$m=["x","y","z","w"],Oi={[R.ONE]:"float",[R.TWO]:"vec2",[R.THREE]:"vec3",[R.FOUR]:"vec4",[R.MATRIX3]:"mat3",[R.MATRIX4]:"mat4",[R.FLOAT_ARRAY]:"float",[R.VEC4_ARRAY]:"vec4",[R.TEXTURE]:"vec4"};function Dd(n){return n&&n.length}function Wm(n){const t=n.size;if(t===R.FLOAT_ARRAY||t===R.VEC4_ARRAY){const e=n.update(n);if(Dd(e))return`#define ${n.name}_length ${e.length}
`}return""}function jm(n){const t=n.size;if(t===R.FLOAT_ARRAY||t===R.VEC4_ARRAY){const e=n.update(n);if(Dd(e))return`[${n.name}_length]`}return""}function Hm(n,t){return $m.slice(n,n+t).join("")}class Bd extends es{processAttributeDestructuring(t,e,i,r,s,a){let o="";const c=s.slice(0);switch(t.bufferType){case ce.VERTEX_ATTRIBUTE:case ce.INSTANCE_ATTRIBUTE:o=this.processDestructuringInstanceAttribute(e,c);break;case ce.VERTEX_ATTRIBUTE_PACKING:case ce.INSTANCE_ATTRIBUTE_PACKING:o=this.processDestructuringInstanceAttributePacking(e,c);break}return t.picking.type===Y.SINGLE&&(o+=`
// This portion is where the shader assigns the picking color that gets passed to the fragment shader
_picking_color_pass_ = _pickingColor;
`),o}processDestructuringInstanceAttribute(t,e){return""}processDestructuringInstanceAttributePacking(t,e){let i="";return i+=this.processDestructureBlocks(t,e),i}processDestructureBlocks(t,e){const i="";return e.forEach(r=>{const s=r.block||0;r.size===P.MAT4X4?this.setDeclaration(t,r.name,`  ${Oi[r.size]} ${r.name} = mat4(block${s}, block${s+1}, block${s+2}, block${s+3});
`,Li):r.size===P.FOUR?this.setDeclaration(t,r.name,`  ${Oi[r.size]} ${r.name} = block${s};
`,Li):this.setDeclaration(t,r.name,`  ${Oi[r.size||1]} ${r.name} = block${s}.${Hm(r.blockIndex||0,r.size||1)};
`,Li)}),i}processHeaderInjection(t,e,i,r,s,a,o){let c={injection:""};t===S.VERTEX&&(c=this.processAttributeHeader(e,i,r,s,a));const l=this.processUniformHeader(e,o,t);return{...c,injection:c.injection+l}}processAttributeHeader(t,e,i,r,s){let o=`// Shader input
`;return o+=this.processVertexAttributes(t,r),(e.bufferType===ce.INSTANCE_ATTRIBUTE||e.bufferType===ce.VERTEX_ATTRIBUTE)&&s.length>0&&(o+=this.processInstanceAttributeBufferStrategy(t,s)),(e.bufferType===ce.INSTANCE_ATTRIBUTE_PACKING||e.bufferType===ce.VERTEX_ATTRIBUTE_PACKING)&&s.length>0&&(o+=this.processInstanceAttributePackingBufferStrategy(t,i.instanceMaxBlock)),{injection:o,material:void 0}}processUniformHeader(t,e,i){const r="",s=i||S.VERTEX;return e.forEach(a=>{a.shaderInjection=a.shaderInjection||S.VERTEX,(a.shaderInjection===s||a.shaderInjection===S.ALL)&&this.setDeclaration(t,a.name,`${Wm(a)}uniform ${a.qualifier||""}${a.qualifier?" ":""}${Oi[a.size]} ${a.name}${jm(a)};
`,Li)}),r}processInstanceAttributeBufferStrategy(t,e){let i="attribute";return N.SHADERS_3_0&&(i="in"),e.forEach(r=>{this.setDeclaration(t,r.name,`${i} ${Oi[r.size||1]} ${r.qualifier||""}${r.qualifier&&" "||""} ${r.name};
`,Li)}),""}processInstanceAttributePackingBufferStrategy(t,e){let i="attribute";N.SHADERS_3_0&&(i="in");for(let r=0,s=e+1;r<s;++r)this.setDeclaration(t,`block${r}`,`${i} ${Oi[P.FOUR]} block${r};
`,Li);return""}processVertexAttributes(t,e){let i="attribute";return N.SHADERS_3_0&&(i="in"),e.forEach(r=>{this.setDeclaration(t,r.name,`${i} ${Oi[r.size]} ${r.qualifier||""}${r.qualifier&&" "||""}${r.name};
`,Li)}),""}}const Xm=`
  // This is a special injected instance attribute. It lets the system
  // control specific instances ability to draw, which allows the backend
  // system greater control on how it optimizes draw calls and it's buffers.
  if (_active < 0.5) {
    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);

    // Quick exit to prevent any geometry from arising from the instance
    return;
  }

`,Qm="instanceData",Ym="_active",qm="ActiveIOExpansion";class Ud extends es{processAttributeDestructuring(t,e,i,r,s,a){const o="";return s.find(c=>c.name===Ym)&&this.setDeclaration(e,"__active_attribute_handler__",Xm,qm),o}}function Km(n){return n&&n.buffer&&n.buffer.value}function Wc(n){return n&&n.propertyToBufferLocation}class ir{constructor(t,e){f(this,"changeListContext");f(this,"layer");f(this,"scene");f(this,"add",()=>{});f(this,"remove",t=>t);this.layer=t,this.scene=e}changesProcessed(){delete this.changeListContext}incomingChangeList(t){this.changeListContext=t}makeLayerMaterial(){const t=this.layer.shaderIOInfo;return Ld(this.layer,t.vs,t.fs,t.uniforms,t.materialUniforms)}}let rr={};function De(n,t){const e=rr[n]||[t,-1,0];rr[n]=e,e[2]++,clearTimeout(e[1]),e[1]=window.setTimeout(()=>{t(e[2],n),delete rr[n]},1)}function va(){for(const n in rr){const t=rr[n];clearTimeout(t[1]),t[0](t[2],n)}rr={}}const sr=Ie("performance"),{max:Zm}=Math;function Jm(n){return!!(n&&n.buffer&&n.buffer.data)}function Fd(n){return Wc(n)}class kd extends ir{constructor(e,i){super(e,i);f(this,"availableLocations",[]);f(this,"currentInstancedCount",0);f(this,"instanceToBufferLocation",{});f(this,"maxInstancedCount",0);f(this,"geometry");f(this,"material");f(this,"model");f(this,"attributes");f(this,"attributeToPropertyIds",new Map);f(this,"updateAllPropertyIdList",[]);f(this,"activePropertyId",-1);f(this,"currentAvailableLocation",-1);f(this,"remove",e=>{const i=this.instanceToBufferLocation[e.uid];return i&&(delete this.instanceToBufferLocation[e.uid],this.availableLocations.push(i)),e});this.add=this.doAddWithRegistration}changesProcessed(){super.changesProcessed(),this.availableLocations.splice(0,this.currentAvailableLocation+1),this.currentAvailableLocation=-1}doAddWithRegistration(e){_e.setObservableMonitor(!0),this.layer.shaderIOInfo.instanceAttributes.forEach(r=>{if(r.parentAttribute)return;r.update(e);const s=_e.getObservableMonitorIds(!0);this.attributeToPropertyIds.set(r,[s[s.length-1]]),s.length>1&&sr("Property has multiple observables. Only the last trigger will be retained as the feature is not complete yet"),r===this.layer.shaderIOInfo.activeAttribute&&(this.activePropertyId=s[0])}),_e.setObservableMonitor(!1),this.makeUpdateAllPropertyIdList();const i=this.resizeBuffer();return this.gatherLocationsIntoGroups(i.newLocations,i.growth),this.add=this.doAdd,this.doAdd(e)}doAdd(e){var r;if(this.availableLocations.length<=0||this.currentAvailableLocation>=this.availableLocations.length-1){const s=this.resizeBuffer();this.gatherLocationsIntoGroups(s.newLocations,s.growth)}const i=this.availableLocations[++this.currentAvailableLocation];return i&&this.geometry?(this.instanceToBufferLocation[e.uid]=i,this.currentInstancedCount=this.geometry.maxInstancedCount=Zm(this.currentInstancedCount,i.instanceIndex+1),this.model&&(this.model.vertexDrawRange=[0,((r=this.layer.shaderIOInfo.indexBuffer)==null?void 0:r.indexCount)||this.layer.shaderIOInfo.instanceVertexCount],this.model.drawInstances=this.currentInstancedCount,this.layer.shaderIOInfo.instanceVertexCount===0&&(this.model.vertexDrawRange[1]=this.model.drawInstances))):console.error("Add Error: Instance Attribute Buffer Manager failed to pair an instance with a buffer location"),va(),i}destroy(){this.geometry&&this.geometry.destroy(),this.material&&this.material.dispose(),this.scene&&this.scene.container&&this.model&&this.scene.container.remove(this.model)}getBufferLocations(e){return this.instanceToBufferLocation[e.uid]}getActiveAttributePropertyId(){return this.activePropertyId}getUpdateAllPropertyIdList(){return this.updateAllPropertyIdList}managesInstance(e){return this.instanceToBufferLocation[e.uid]!==void 0}makeUpdateAllPropertyIdList(){const e={};this.attributeToPropertyIds.forEach(i=>{e[i[0]]=i[0]}),this.updateAllPropertyIdList=Object.values(e).filter(Boolean)}removeFromScene(){this.scene&&this.scene.container&&this.model&&this.scene.container.remove(this.model),delete this.scene}resizeBuffer(){var a,o,c,l;sr("Gathering resize growth amount...");const e=this.layer.shaderIOInfo;let i=0;const r=new Map,s=this.maxInstancedCount;if(this.changeListContext){i=this.layer.shaderIOInfo.baseBufferGrowthRate;for(let u=0,d=this.changeListContext.length;u<d;++u){const p=this.changeListContext[u];switch(p[1]){case Te.CHANGE:case Te.INSERT:this.instanceToBufferLocation[p[0].uid]||i++;break}}}if(sr("BEGIN: Resizing unpacked attribute buffer by %d instances",i),this.geometry){this.geometry.rebuild(),this.maxInstancedCount+=i,this.attributes=this.attributes||[];for(const u of this.attributes)u.bufferAttribute.count<this.maxInstancedCount&&((l=(c=this.layer.props.bufferManagement)==null?void 0:c.optimize)!=null&&l.bufferDoubling?u.bufferAttribute.resize(this.maxInstancedCount*2,s):u.bufferAttribute.resize(this.maxInstancedCount,s))}else{i=Math.max(i,((o=(a=this.layer.props.bufferManagement)==null?void 0:a.optimize)==null?void 0:o.expectedInstanceCount)??0),this.maxInstancedCount+=i,this.geometry=new An;for(const u of e.vertexAttributes)u.materialAttribute&&this.geometry.addAttribute(u.name,u.materialAttribute);e.indexBuffer&&e.indexBuffer.materialIndexBuffer&&this.geometry.setIndexBuffer(e.indexBuffer.materialIndexBuffer),this.attributes=[];for(const u of e.instanceAttributes){const d=u.size||0,p=new Ut(new Float32Array(0),d,!0,!0);p.resize(this.maxInstancedCount),this.geometry.addAttribute(u.name,p);const g=Object.assign({},u,{uid:z(),bufferAttribute:p});this.attributes.push(g)}this.geometry.maxInstancedCount=0}for(let u=0,d=this.attributes.length;u<d;++u){const p=this.attributes[u],g=p.bufferAttribute,m=p.size||0,v=this.maxInstancedCount-s;let b=r.get(p.name);b||(b=new Array(v),r.set(p.name,b));let T=0;for(let w=s,E=this.maxInstancedCount;w<E;++w,++T)b[T]={attribute:p,buffer:g,instanceIndex:w,start:w*m,end:w*m+m}}if(this.scene&&this.model&&this.scene.container&&this.scene.container.remove(this.model),!this.material){this.material=this.makeLayerMaterial();for(let u=0,d=e.uniforms.length;u<d;++u){const p=e.uniforms[u];p.materialUniforms.push(this.material.uniforms[p.name])}}return this.model=nr(this.layer.id,this.geometry,this.material,e.drawMode),this.scene&&this.scene.container&&this.model&&this.scene.container.add(this.model),sr("COMPLETE: Resizing unpacked attribute buffer"),{growth:i,newLocations:r}}gatherLocationsIntoGroups(e,i){if(this.attributeToPropertyIds.size===0)return;sr("BEGIN: Unpacked attribute manager grouping new buffer locations");const r=[];this.attributeToPropertyIds.forEach((d,p)=>{r.push({attribute:p,bufferLocationsForAttribute:e.get(p.name)||[],childBufferLocations:(p.childAttributes||[]).map(g=>({location:e.get(g.name)||[],bufferIndex:-1})),ids:d,bufferIndex:-1})});let s,a,o,c,l,u;for(let d=0;d<i;++d){const p={instanceIndex:-1,propertyToBufferLocation:{}};for(let g=0,m=r.length;g<m;++g){if(s=r[g],a=s.attribute,o=s.ids,c=s.bufferLocationsForAttribute,!c){De("Instance Attribute Buffer Error",(v,b)=>{console.warn(`${b}: There is an error in forming buffer location groups in InstanceAttributeBufferManager. Error count: ${v}`)});continue}if(l=c[++s.bufferIndex],!l){De("Instance Attribute Buffer Error",(v,b)=>{console.warn(`${b}: There is an error in forming buffer location groups in InstanceAttributeBufferManager. Error count: ${v}`)});continue}if(p.instanceIndex===-1)p.instanceIndex=l.instanceIndex;else if(l.instanceIndex!==p.instanceIndex){De("Instance Attribute Parallelism Error",(v,b)=>{console.warn(`${b}: A buffer location does not have a matching instance index which means the buffer locations are not in parallel with each other somehow. Error count: ${v}`),console.warn(a.name,l)});continue}if(a.childAttributes){l.childLocations=[];for(let v=0,b=a.childAttributes.length;v<b;++v){const T=s.childBufferLocations[v];if(T){const w=T.location[++T.bufferIndex];w?l.childLocations.push(w):(u=a.childAttributes[v],De("Instance Attribute Child Attribute Error",(E,x)=>{console.warn(`${x}: A child attribute does not have a buffer location available. Error count: ${E}`),console.warn(`Parent Attribute: ${a.name} Child Attribute: ${u.name}`)}))}}}for(let v=0,b=o.length;v<b;++v)p.propertyToBufferLocation[o[v]]=l}this.availableLocations.push(p)}sr("COMPLETE: Unpacked attribute buffer manager buffer location grouping")}getInstanceCount(){return this.maxInstancedCount}}const{max:e0}=Math,ar=Ie("performance");class Gd extends ir{constructor(e,i){super(e,i);f(this,"allBufferLocations",{});f(this,"availableLocations",[]);f(this,"currentInstancedCount",0);f(this,"instanceToBufferLocation",{});f(this,"maxInstancedCount",1e3);f(this,"geometry");f(this,"material");f(this,"model");f(this,"attributes");f(this,"blockAttributes");f(this,"blockSubAttributesLookup",new Map);f(this,"attributeToPropertyIds",new Map);f(this,"updateAllPropertyIdList",[]);f(this,"activePropertyId",-1);f(this,"currentAvailableLocation",-1);f(this,"remove",e=>{const i=this.instanceToBufferLocation[e.uid];return i&&(delete this.instanceToBufferLocation[e.uid],this.availableLocations.push(i)),e});this.add=this.doAddWithRegistration}changesProcessed(){super.changesProcessed(),this.availableLocations.splice(0,this.currentAvailableLocation+1),this.currentAvailableLocation=-1}doAddWithRegistration(e){this.layer.shaderIOInfo.instanceAttributes.forEach(r=>{if(r.parentAttribute)return;_e.setObservableMonitor(!0),r.update(e);const s=_e.getObservableMonitorIds(!0);this.attributeToPropertyIds.set(r,[s[s.length-1]]),s.length>1&&ar("Property has multiple observables. Only the last trigger will be retained as the feature is not complete yet"),r===this.layer.shaderIOInfo.activeAttribute&&(this.activePropertyId=s[0])}),_e.setObservableMonitor(!1),this.makeUpdateAllPropertyIdList();const i=this.resizeBuffer();return this.gatherLocationsIntoGroups(i.newLocations,i.growth),this.add=this.doAdd,this.doAdd(e)}doAdd(e){if(this.availableLocations.length<=0||this.currentAvailableLocation>=this.availableLocations.length-1){const r=this.resizeBuffer();this.gatherLocationsIntoGroups(r.newLocations,r.growth)}const i=this.availableLocations[++this.currentAvailableLocation];return i&&this.geometry?(this.instanceToBufferLocation[e.uid]=i,this.currentInstancedCount=this.geometry.maxInstancedCount=e0(this.currentInstancedCount,i.instanceIndex+1),this.model&&(this.model.vertexDrawRange=[0,this.layer.shaderIOInfo.instanceVertexCount],this.model.drawInstances=this.currentInstancedCount,this.layer.shaderIOInfo.instanceVertexCount===0&&(this.model.vertexDrawRange[1]=this.model.drawInstances))):console.error("Add Error: Instance Attribute Buffer Manager failed to pair an instance with a buffer location"),i}destroy(){this.geometry&&this.geometry.destroy(),this.material&&this.material.dispose(),this.scene&&this.scene.container&&this.model&&this.scene.container.remove(this.model)}getBufferLocations(e){return this.instanceToBufferLocation[e.uid]}getActiveAttributePropertyId(){return this.activePropertyId}getUpdateAllPropertyIdList(){return this.updateAllPropertyIdList}managesInstance(e){return this.instanceToBufferLocation[e.uid]!==void 0}makeUpdateAllPropertyIdList(){const e={};this.attributeToPropertyIds.forEach(i=>{e[i[0]]=i[0]}),this.updateAllPropertyIdList=Object.values(e).filter(Boolean)}removeFromScene(){this.scene&&this.scene.container&&this.model&&this.scene.container.remove(this.model),delete this.scene}resizeBuffer(){var a,o,c,l;const e=this.layer.shaderIOInfo;let i=0;const r=new Map,s=this.maxInstancedCount;if(this.changeListContext){i=this.layer.shaderIOInfo.baseBufferGrowthRate;for(let u=0,d=this.changeListContext.length;u<d;++u){const p=this.changeListContext[u];switch(p[1]){case Te.CHANGE:case Te.INSERT:this.instanceToBufferLocation[p[0].uid]||i++;break}}}if(ar("BEGIN: Resizing packed attribute buffer by %d instances",i),this.geometry){ar(`Info: Vertex packing buffer is being resized for layer ${this.layer.id}`),this.geometry.rebuild();for(const u of e.vertexAttributes)u.materialAttribute&&this.geometry.addAttribute(u.name,u.materialAttribute);e.indexBuffer&&e.indexBuffer.materialIndexBuffer&&this.geometry.setIndexBuffer(e.indexBuffer.materialIndexBuffer),this.maxInstancedCount+=i,this.attributes=this.attributes||[],this.blockAttributes=this.blockAttributes||[];for(let u=0,d=this.blockAttributes.length;u<d;++u){const p=this.blockAttributes[u];p.bufferAttribute.count<this.maxInstancedCount&&((l=(c=this.layer.props.bufferManagement)==null?void 0:c.optimize)!=null&&l.bufferDoubling?p.bufferAttribute.resize(this.maxInstancedCount*2,s):p.bufferAttribute.resize(this.maxInstancedCount,s))}for(let u=0,d=this.blockAttributes.length;u<d;++u){const p=this.blockAttributes[u],g=p.bufferAttribute;if(g.data instanceof Float32Array){const m=this.blockSubAttributesLookup.get(u),v=p.size||0;if(m)for(let b=0,T=m.length;b<T;++b){const w=m[b];let E=r.get(w.name);E||(E=[],r.set(w.name,E));const x=this.allBufferLocations[w.name]||[];this.allBufferLocations[w.name]=x;const _=Object.assign({},w,{uid:z(),packUID:p.packUID,bufferAttribute:g}),I=w.blockIndex||0,M=w.size||1;let C;for(let O=0,X=x.length;O<X;++O)C=x[O],C.attribute=_;let F,Q=E.length;const B=this.maxInstancedCount-s;E.length+=B,x.length+=B;for(let O=s;O<this.maxInstancedCount;++O,++Q)F={attribute:_,block:u,buffer:g,instanceIndex:O,start:O*v+I,end:O*v+I+M},E[Q]=F,x[O]=F}}}}else{i=Math.max(i,((o=(a=this.layer.props.bufferManagement)==null?void 0:a.optimize)==null?void 0:o.expectedInstanceCount)??0),this.maxInstancedCount+=i,this.geometry=new An;for(const p of e.vertexAttributes)p.materialAttribute&&this.geometry.addAttribute(p.name,p.materialAttribute);e.indexBuffer&&e.indexBuffer.materialIndexBuffer&&this.geometry.setIndexBuffer(e.indexBuffer.materialIndexBuffer),this.attributes=[],this.blockAttributes=[];const u=new Map,d=new Map;this.blockSubAttributesLookup=d;for(let p=0,g=e.instanceAttributes.length;p<g;++p){const m=e.instanceAttributes[p],v=m.block||0;let b=u.get(v)||0;b=Math.max(b,(m.blockIndex||0)+(m.size||0)),u.set(v,b);let T=d.get(v);T||(T=[],d.set(v,T)),T.push(m)}d.forEach(p=>p.sort((g,m)=>(g.blockIndex||0)-(m.blockIndex||0)));for(let p=0,g=u.size;p<g;++p){const m=u.get(p)||0,v=z();m||console.warn("Instance Attribute Packing Error: The system tried to build an attribute with a size of zero.","These are the attributes used:",e.instanceAttributes,"These are the block sizes calculated",u,"This is the block to attribute lookup generated",d);const b=new Float32Array(m*this.maxInstancedCount),T=new Ut(b,m,!0,!0);this.geometry.addAttribute(`block${p}`,T);const w=d.get(p);if(w){for(let E=0,x=w.length;E<x;++E){const _=w[E];let I=r.get(_.name);I||(I=[],r.set(_.name,I));const M=this.allBufferLocations[_.name]||[];this.allBufferLocations[_.name]=M;const C=Object.assign({},_,{uid:p,packUID:v,bufferAttribute:T,size:m}),F=_.blockIndex||0,Q=_.size||1;for(let B=0;B<this.maxInstancedCount;++B){const O={attribute:C,block:p,buffer:T,instanceIndex:B,start:B*m+F,end:B*m+F+Q};I.push(O),M.push(O)}this.attributes.push(C)}this.blockAttributes.push({uid:z(),packUID:v,bufferAttribute:T,name:`block${p}`,size:m,update:()=>[0]})}else console.warn("Instance Attribute Packing Buffer Error: Somehow there are no attributes associated with a block.","These are the attributes used:",e.instanceAttributes,"These are the block sizes calculated",u,"This is the block to attribute lookup generated",d)}this.geometry.maxInstancedCount=0,this.material=this.makeLayerMaterial();for(let p=0,g=e.uniforms.length;p<g;++p){const m=e.uniforms[p];m.materialUniforms.push(this.material.uniforms[m.name])}}return this.scene&&this.model&&this.scene.container&&this.scene.container.remove(this.model),this.material=this.material||this.makeLayerMaterial(),this.model=nr(this.layer.id,this.geometry,this.material,this.layer.shaderIOInfo.drawMode),this.scene&&this.scene.container&&this.model&&this.scene.container.add(this.model),ar("COMPLETE: Resizing unpacked attribute buffer"),{growth:i,newLocations:r}}gatherLocationsIntoGroups(e,i){if(this.attributeToPropertyIds.size===0)return;ar("BEGIN: Packed attribute manager grouping new buffer locations");const r=[];this.attributeToPropertyIds.forEach((s,a)=>{r.push({attribute:a,bufferLocationsForAttribute:e.get(a.name)||[],childBufferLocations:(a.childAttributes||[]).map(o=>({location:e.get(o.name)||[],bufferIndex:-1})),ids:s,bufferIndex:-1})});for(let s=0;s<i;++s){const a={instanceIndex:-1,propertyToBufferLocation:{}};for(let o=0,c=r.length;o<c;++o){const l=r[o],u=l.attribute,d=l.ids,p=l.bufferLocationsForAttribute;if(!p){De("Instance Attribute Buffer Error",(m,v)=>{console.warn(`${v}: There is an error in forming buffer location groups in InstanceAttributePackingBufferManager. Error count: ${m}`)});continue}const g=p[++l.bufferIndex];if(!g){De("Instance Attribute Buffer Error",(m,v)=>{console.warn(`${v}: There is an error in forming buffer location groups in InstanceAttributePackingBufferManager. Error count: ${m}`)});continue}if(a.instanceIndex===-1)a.instanceIndex=g.instanceIndex;else if(g.instanceIndex!==a.instanceIndex){De("Instance Attribute Parallelism Error",(m,v)=>{console.warn(`${v}: A buffer location does not have a matching instance index which means the buffer locations are not in parallel with each other somehow. Error count: ${m}`),console.warn(u.name,g)});continue}if(u.childAttributes){const m=[];for(let v=0,b=u.childAttributes.length;v<b;++v){const T=u.childAttributes[v],w=l.childBufferLocations[v];if(w){const E=w.location[++w.bufferIndex];E?m.push(E):De("Instance Attribute Child Attribute Error",(x,_)=>{console.warn(`${_}: A child attribute does not have a buffer location available. Error count: ${x}`),console.warn(`Parent Attribute: ${u.name} Child Attribute: ${T.name}`)})}}g.childLocations=m}for(let m=0,v=d.length;m<v;++m){const b=d[m];a.propertyToBufferLocation[b]=g}}this.availableLocations.push(a)}ar("COMPLETE: Packed attribute buffer manager buffer location grouping"),va()}getInstanceCount(){return this.maxInstancedCount}}function zd(n){return n&&n.buffer&&n.buffer.value&&n.type===Se.VEC4_ARRAY}class Vd extends ir{constructor(e,i){super(e,i);f(this,"uniformBlocksPerInstance");f(this,"buffers",[]);f(this,"availableClusters",[]);f(this,"instanceToCluster",{});f(this,"clusterToBuffer",new Map);f(this,"add",e=>{this.availableClusters.length<=0&&this.makeNewBuffer();const i=this.availableClusters.pop();return i?this.instanceToCluster[e.uid]=i:console.warn("No valid cluster available for instance added to uniform manager."),i});f(this,"remove",e=>{const i=this.instanceToCluster[e.uid];return i&&(delete this.instanceToCluster[e.uid],this.availableClusters.push(i)),e});let r=0;e.shaderIOInfo.instanceAttributes.forEach(s=>{r=Math.max(s.block||0,r)}),this.uniformBlocksPerInstance=r+1}destroy(){this.buffers.forEach(e=>{e.geometry.destroy(),e.material.dispose()})}getBufferLocations(e){return this.instanceToCluster[e.uid]}getActiveAttributePropertyId(){return-1}getInstanceCount(){return-1}getUpdateAllPropertyIdList(){return[]}managesInstance(e){return this.instanceToCluster[e.uid]===void 0}removeFromScene(){const e=this.scene;if(e!=null&&e.container){for(let i=0,r=this.buffers.length;i<r;++i){const s=this.buffers[i];e.container.remove(s.model)}delete this.scene}}setScene(e){if(e.container){for(let i=0,r=this.buffers.length;i<r;++i){const s=this.buffers[i];e.container.add(s.model)}this.scene=e}else console.warn("Can not set a scene that has an undefined container.")}makeNewBuffer(){const e=this.layer.shaderIOInfo,i=new An;e.vertexAttributes.forEach(d=>{d.materialAttribute&&i.addAttribute(d.name,d.materialAttribute)});const r=this.makeLayerMaterial(),s=nr(this.layer.id,i,r,e.drawMode);s.vertexDrawRange=[0,e.maxInstancesPerBuffer*e.instanceVertexCount];const a={activeInstances:[],clusters:[],firstInstance:0,geometry:i,lastInstance:0,material:r,model:s};this.buffers.push(a);let o=0;const c=Qm,l=r.uniforms[c];if(au(l))l.data=l.data.map(()=>[0,0,0,0]);else{console.warn("Material is utilizing an invalid uniform type for Uniform Buffer Management. Buffering will not be possible.");return}const u=Object.assign({},e.instanceAttributes[0],{bufferAttribute:new Ut(new Float32Array(1),1),uid:z()});for(let d=0,p=e.maxInstancesPerBuffer;d<p;++d){const g={attribute:u,buffer:l,instanceIndex:d,start:o,end:0};o+=this.uniformBlocksPerInstance,g.end=o,a.clusters.push(g),this.availableClusters.push(g),this.clusterToBuffer.set(g,a)}for(let d=0,p=e.uniforms.length;d<p;++d){const g=e.uniforms[d];g.materialUniforms.push(r.uniforms[g.name])}this.scene&&this.scene.container&&this.scene.container.add(a.model)}}class jc{constructor(t,e){f(this,"layer");f(this,"bufferManager");this.layer=t,this.bufferManager=e}}const ba=[],{min:Hc,max:Xc}=Math;class t0 extends jc{constructor(){super(...arguments);f(this,"diffMode",0);f(this,"bufferAttributeUpdateRange",{});f(this,"bufferAttributeWillUpdate",{});f(this,"updateInstance",this.updateInstancePartial)}addInstance(e,i,r,s){if(s)e.changeInstance(e,i,ba,s);else{const a=e.layer.bufferManager.add(i);Fd(a)&&(i.active=!0,e.layer.onDiffAdd&&e.layer.onDiffAdd(i),e.updateInstance(e.layer,i,ba,a))}}changeInstance(e,i,r,s){s?e.updateInstance(e.layer,i,r,s):e.addInstance(e,i,ba,s)}removeInstance(e,i,r,s){s&&(i.active=!1,e.layer.onDiffRemove&&e.layer.onDiffRemove(i),e.updateInstance(e.layer,i,ba,s),e.layer.bufferManager.remove(i))}updateInstancePartial(e,i,r,s){const a=s.propertyToBufferLocation,o=this.bufferAttributeUpdateRange;let c,l,u,d,p,g,m,v,b,T,w,E,x;if(i.active){for((r.length===0||i.reactivate)&&(r=this.bufferManager.getUpdateAllPropertyIdList()),m=0,w=r.length;m<w;++m)if(c=a[r[m]],!!c){for(p=c.attribute,g=p.packUID||p.uid,l=p.update(i),b=c.start,E=c.end,v=0;b<E;++b,++v)c.buffer.data[b]=l[v];if(u=o[g]||[null,Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER],u[0]=p,u[1]=Hc(c.start,u[1]),u[2]=Xc(c.end,u[2]),o[g]=u,c.childLocations){for(d=c.childLocations,b=0,E=d.length;b<E;++b)if(c=d[b],!!c){for(g=c.attribute.packUID||c.attribute.uid,l=c.attribute.update(i),T=c.start,x=c.end,v=0;T<x;++T,++v)c.buffer.data[T]=l[v];u=o[g]||[null,Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER],u[0]=c.attribute,u[1]=Hc(c.start,u[1]),u[2]=Xc(c.end,u[2]),o[g]=u}}}}else{for(c=a[this.bufferManager.getActiveAttributePropertyId()],p=c.attribute,g=p.packUID||p.uid,l=p.update(i),T=c.start,x=c.end,v=0;T<x;++T,++v)c.buffer.data[T]=l[v];u=o[g]||[null,Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER],u[0]=p,u[1]=Hc(c.start,u[1]),u[2]=Xc(c.end,u[2]),o[g]=u}i.reactivate=!1}updateInstanceFull(e,i,r,s){const a=s.propertyToBufferLocation,o=this.bufferAttributeWillUpdate;let c,l,u,d,p,g,m,v,b,T,w;if(i.active){for((r.length===0||i.reactivate)&&(r=this.bufferManager.getUpdateAllPropertyIdList()),p=0,w=r.length;p<w;++p)if(c=a[r[p]],!!c){for(d=c.attribute,l=d.update(i),m=c.start,b=c.end,g=0;m<b;++m,++g)c.buffer.data[m]=l[g];if(o[d.packUID||d.uid]=d,c.childLocations){for(u=c.childLocations,m=0,b=u.length;m<b;++m)if(c=u[m],!!c){for(d=c.attribute,l=d.update(i),v=c.start,T=c.end,g=0;v<T;++v,++g)c.buffer.data[v]=l[g];o[d.packUID||d.uid]=d}}}}else{for(c=a[this.bufferManager.getActiveAttributePropertyId()],d=c.attribute,l=d.update(i),v=c.start,T=c.end,g=0;v<T;++v,++g)c.buffer.data[v]=l[g];o[d.packUID||d.uid]=d}i.reactivate=!1}commit(){if(this.diffMode===0){const e=Object.values(this.bufferAttributeUpdateRange);for(let i=0,r=e.length;i<r;++i){const s=e[i],a=s[0].bufferAttribute;a.updateRange={count:s[2]-s[1],offset:s[1]}}}else{const e=Object.values(this.bufferAttributeWillUpdate);for(let i=0,r=e.length;i<r;++i){const s=e[i].bufferAttribute;s.updateRange={count:-1,offset:0}}}this.bufferAttributeUpdateRange={}}incomingChangeList(e){e.length===0?this.diffMode=0:e.length>this.bufferManager.getInstanceCount()*.7?this.diffMode=1:this.diffMode=0,this.diffMode===0?this.updateInstance=this.updateInstancePartial:this.updateInstance=this.updateInstanceFull}}const $d=[];class n0 extends jc{addInstance(t,e,i,r){if(r)t.changeInstance(t,e,$d,r);else{const s=t.layer.bufferManager.add(e);zd(s)&&(e.active=!0,t.layer.onDiffAdd&&t.layer.onDiffAdd(e),t.updateInstance(t.layer,e,s))}}changeInstance(t,e,i,r){r?t.updateInstance(t.layer,e,r):t.addInstance(t,e,$d,r)}removeInstance(t,e,i,r){r&&(e.active=!1,t.layer.onDiffRemove&&t.layer.onDiffRemove(e),t.updateInstance(t.layer,e,r),t.layer.bufferManager.remove(e))}updateInstance(t,e,i){if(e.active){const r=i.buffer,s=i.start,a=r.data;let o,c,l,u,d,p;for(let g=0,m=t.shaderIOInfo.instanceAttributes.length;g<m;++g)if(o=t.shaderIOInfo.instanceAttributes[g],c=o.update(e),l=a[s+(o.block||0)],u=o.blockIndex,u!==void 0)for(d=u,p=c.length+u;d<p;++d)l[d]=c[d-u];r.data=a}else{const r=i.buffer,s=i.start,a=r.data,o=t.shaderIOInfo.activeAttribute,c=o.update(e),l=a[s+(o.block||0)],u=o.blockIndex;if(u!==void 0)for(let d=u,p=c.length+u;d<p;++d)l[d]=c[d-u];r.data=a}}commit(){}incomingChangeList(t){}}const or=Ie("performance"),{max:i0}=Math;function r0(n){return Wc(n)}class s0 extends ir{constructor(e,i){super(e,i);f(this,"allBufferLocations",{});f(this,"availableLocations",[]);f(this,"currentInstancedCount",0);f(this,"instanceToBufferLocation",{});f(this,"maxInstancedCount",0);f(this,"geometry");f(this,"material");f(this,"model");f(this,"attributes");f(this,"attributeToPropertyIds",new Map);f(this,"updateAllPropertyIdList",[]);f(this,"activePropertyId",-1);f(this,"currentAvailableLocation",-1);f(this,"remove",e=>{const i=this.instanceToBufferLocation[e.uid];return i&&(delete this.instanceToBufferLocation[e.uid],this.availableLocations.push(i)),e});this.add=this.doAddWithRegistration}changesProcessed(){super.changesProcessed(),this.availableLocations.splice(0,this.currentAvailableLocation+1),this.currentAvailableLocation=-1}doAddWithRegistration(e){_e.setObservableMonitor(!0),this.layer.shaderIOInfo.instanceAttributes.forEach(r=>{if(r.parentAttribute)return;r.update(e);const s=_e.getObservableMonitorIds(!0);this.attributeToPropertyIds.set(r,[s[s.length-1]]),s.length>1&&or("Property has multiple observables. Only the last trigger will be retained as the feature is not complete yet"),r===this.layer.shaderIOInfo.activeAttribute&&(this.activePropertyId=s[0])}),_e.setObservableMonitor(!1),this.makeUpdateAllPropertyIdList();const i=this.resizeBuffer();return this.gatherLocationsIntoGroups(i.newLocations,i.growth),this.add=this.doAdd,this.doAdd(e)}doAdd(e){if(this.availableLocations.length<=0||this.currentAvailableLocation>=this.availableLocations.length-1){const r=this.resizeBuffer();this.gatherLocationsIntoGroups(r.newLocations,r.growth)}const i=this.availableLocations[++this.currentAvailableLocation];return i&&this.geometry?(this.instanceToBufferLocation[e.uid]=i,this.currentInstancedCount=this.geometry.maxInstancedCount=i0(this.currentInstancedCount,i.instanceIndex+1),this.model&&(this.model.vertexDrawRange=[0,this.layer.shaderIOInfo.instanceVertexCount*this.currentInstancedCount],this.model.drawInstances=this.currentInstancedCount,this.layer.shaderIOInfo.instanceVertexCount===0&&(this.model.vertexDrawRange[1]=this.layer.shaderIOInfo.instanceVertexCount*this.currentInstancedCount))):console.error("Add Error: Instance Attribute Buffer Manager failed to pair an instance with a buffer location"),i}destroy(){this.geometry&&this.geometry.destroy(),this.material&&this.material.dispose(),this.scene&&this.scene.container&&this.model&&this.scene.container.remove(this.model)}getBufferLocations(e){return this.instanceToBufferLocation[e.uid]}getActiveAttributePropertyId(){return this.activePropertyId}getUpdateAllPropertyIdList(){return this.updateAllPropertyIdList}managesInstance(e){return this.instanceToBufferLocation[e.uid]!==void 0}makeUpdateAllPropertyIdList(){const e={};this.attributeToPropertyIds.forEach(i=>{e[i[0]]=i[0]}),this.updateAllPropertyIdList=Object.values(e).filter(Boolean)}removeFromScene(){this.scene&&this.scene.container&&this.model&&this.scene.container.remove(this.model),delete this.scene}resizeBuffer(){var a,o;or("Gathering resize growth amount...");const e=this.layer.shaderIOInfo.instanceVertexCount,i=this.layer.shaderIOInfo;let r=0;const s=new Map;if(this.changeListContext){r=this.layer.shaderIOInfo.baseBufferGrowthRate;for(let c=0,l=this.changeListContext.length;c<l;++c){const u=this.changeListContext[c];switch(u[1]){case Te.CHANGE:case Te.INSERT:this.instanceToBufferLocation[u[0].uid]||r++;break}}}if(or("BEGIN: Resizing unpacked attribute buffer by %d instances",r),this.geometry){this.geometry.rebuild();const c=this.maxInstancedCount;this.maxInstancedCount+=r;for(const l of i.vertexAttributes)l.materialAttribute&&(l.materialAttribute.resize(e*this.maxInstancedCount),l.materialAttribute.repeatInstances(this.maxInstancedCount-c,e,c));if(i.indexBuffer&&this.geometry.indexBuffer){const l=i.indexBuffer.indexCount;this.geometry.indexBuffer.resize(l*this.maxInstancedCount,e*this.maxInstancedCount),this.geometry.indexBuffer.repeatInstances(this.maxInstancedCount-c,e,l,c)}this.attributes=this.attributes||[];for(const l of this.attributes){const u=l.bufferAttribute,d=l.size||0;if(u.data instanceof Float32Array){l.bufferAttribute.resize(this.maxInstancedCount*e);let p=s.get(l.name);const g=this.allBufferLocations[l.name]||[];this.allBufferLocations[l.name]=g;for(let T=0,w=g.length;T<w;++T)g[T].buffer.data=l.bufferAttribute.data;p||(p=[],s.set(l.name,p));let m,v=p.length;const b=this.maxInstancedCount-c;p.length+=b,g.length+=b;for(let T=c,w=this.maxInstancedCount;T<w;++T,++v)m={attribute:l,buffer:{data:l.bufferAttribute.data},instanceIndex:T,start:T*d,end:T*d+d},p[v]=m,g[T]=m}}(o=this.scene)!=null&&o.container&&this.model&&this.scene.container.remove(this.model)}else{this.maxInstancedCount+=r,this.geometry=new An;for(const c of i.vertexAttributes)c.materialAttribute&&(c.materialAttribute.resize(e*this.maxInstancedCount),c.materialAttribute.repeatInstances(this.maxInstancedCount-1,e),c.materialAttribute.setDynamic(!0),this.geometry.addAttribute(c.name,c.materialAttribute));(a=i.indexBuffer)!=null&&a.materialIndexBuffer&&(this.geometry.setIndexBuffer(i.indexBuffer.materialIndexBuffer),i.indexBuffer.materialIndexBuffer.resize(i.indexBuffer.indexCount*this.maxInstancedCount,e*this.maxInstancedCount),i.indexBuffer.materialIndexBuffer.repeatInstances(this.maxInstancedCount-1,e,i.indexBuffer.indexCount,1)),this.attributes=[];for(const c of i.instanceAttributes){const l=c.size||0,u=new Ut(new Float32Array(0),l,!0,!1);u.resize(this.maxInstancedCount*e),this.geometry.addAttribute(c.name,u);let d=s.get(c.name);d||(d=[],s.set(c.name,d));const p=this.allBufferLocations[c.name]||[];this.allBufferLocations[c.name]=p;const g=Object.assign({},c,{uid:z(),bufferAttribute:u});for(let m=0;m<this.maxInstancedCount;++m){const v={attribute:g,buffer:{data:u.data},instanceIndex:m,start:m*l,end:m*l+l};d.push(v),p.push(v)}this.attributes.push(g)}this.geometry.maxInstancedCount=0,this.material=this.makeLayerMaterial();for(let c=0,l=i.uniforms.length;c<l;++c){const u=i.uniforms[c];u.materialUniforms.push(this.material.uniforms[u.name])}}return this.scene&&this.model&&this.scene.container&&this.scene.container.remove(this.model),this.material=this.material||this.makeLayerMaterial(),this.model=nr(this.layer.id,this.geometry,this.material,i.drawMode),this.scene&&this.scene.container&&this.model&&this.scene.container.add(this.model),or("COMPLETE: Resizing unpacked attribute buffer"),{growth:r,newLocations:s}}gatherLocationsIntoGroups(e,i){if(this.attributeToPropertyIds.size===0)return;or("BEGIN: Unpacked attribute manager grouping new buffer locations");const r=[];this.attributeToPropertyIds.forEach((d,p)=>{r.push({attribute:p,bufferLocationsForAttribute:e.get(p.name)||[],childBufferLocations:(p.childAttributes||[]).map(g=>({location:e.get(g.name)||[],bufferIndex:-1})),ids:d,bufferIndex:-1})});let s,a,o,c,l,u;for(let d=0;d<i;++d){const p={instanceIndex:-1,propertyToBufferLocation:{}};for(let g=0,m=r.length;g<m;++g){if(s=r[g],a=s.attribute,o=s.ids,c=s.bufferLocationsForAttribute,!c){De("Instance Attribute Buffer Error",(v,b)=>{console.warn(`${b}: There is an error in forming buffer location groups in VertexAttributeBufferManager. Error count: ${v}`)});continue}if(l=c[++s.bufferIndex],!l){De("Instance Attribute Buffer Error",(v,b)=>{console.warn(`${b}: There is an error in forming buffer location groups in VertexAttributeBufferManager. Error count: ${v}`)});continue}if(p.instanceIndex===-1)p.instanceIndex=l.instanceIndex;else if(l.instanceIndex!==p.instanceIndex){De("Instance Attribute Parallelism Error",(v,b)=>{console.warn(`${b}: A buffer location does not have a matching instance index which means the buffer locations are not in parallel with each other somehow. Error count: ${v}`),console.warn(a.name,l)});continue}if(a.childAttributes){l.childLocations=[];for(let v=0,b=a.childAttributes.length;v<b;++v){const T=s.childBufferLocations[v];if(T){const w=T.location[++T.bufferIndex];w?l.childLocations.push(w):(u=a.childAttributes[v],De("Instance Attribute Child Attribute Error",(E,x)=>{console.warn(`${x}: A child attribute does not have a buffer location available. Error count: ${E}`),console.warn(`Parent Attribute: ${a.name} Child Attribute: ${u.name}`)}))}}}for(let v=0,b=o.length;v<b;++v)p.propertyToBufferLocation[o[v]]=l}this.availableLocations.push(p)}or("COMPLETE: Unpacked attribute buffer manager buffer location grouping"),va()}getInstanceCount(){return this.maxInstancedCount}}const wa=[],{min:Qc,max:Yc}=Math;class a0 extends jc{constructor(){super(...arguments);f(this,"diffMode",0);f(this,"bufferAttributeUpdateRange",{});f(this,"bufferAttributeWillUpdate",{});f(this,"updateInstance",this.updateInstancePartial)}addInstance(e,i,r,s){if(s)e.changeInstance(e,i,wa,s);else{const a=e.layer.bufferManager.add(i);r0(a)&&(i.active=!0,e.layer.onDiffAdd&&e.layer.onDiffAdd(i),e.updateInstance(e.layer,i,wa,a))}}changeInstance(e,i,r,s){s?e.updateInstance(e.layer,i,r,s):e.addInstance(e,i,wa,s)}removeInstance(e,i,r,s){s&&(i.active=!1,e.layer.onDiffRemove&&e.layer.onDiffRemove(i),e.updateInstance(e.layer,i,wa,s),e.layer.bufferManager.remove(i))}updateInstancePartial(e,i,r,s){const a=e.shaderIOInfo.instanceVertexCount,o=s.propertyToBufferLocation,c=this.bufferAttributeUpdateRange;let l,u,d,p,g,m,v=0,b,T,w,E,x,_,I;if(i.active){for((r.length===0||i.reactivate)&&(r=this.bufferManager.getUpdateAllPropertyIdList()),b=0,_=r.length;b<_;++b)if(l=o[r[b]],!!l){for(g=l.attribute,m=g.packUID||g.uid,u=g.update(i),v=g.size||l.end-l.start,T=l.start*a,I=l.end*a;T<I;)for(w=0;w<v;++w,++T)l.buffer.data[T]=u[w];if(d=c[m]||[null,Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER],d[0]=g,d[1]=Qc(l.start*a,d[1]),d[2]=Yc(l.end*a,d[2]),c[m]=d,l.childLocations){for(p=l.childLocations,E=0,x=p.length;E<x;++E)if(l=p[E],!!l){for(m=l.attribute.packUID||l.attribute.uid,u=l.attribute.update(i),v=g.size||l.end-l.start,T=l.start*a,I=l.end*a;T<I;)for(w=0;w<v;++w,++T)l.buffer.data[T]=u[w];d=c[m]||[null,Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER],d[0]=l.attribute,d[1]=Qc(l.start*a,d[1]),d[2]=Yc(l.end*a,d[2]),c[m]=d}}}}else{for(l=o[this.bufferManager.getActiveAttributePropertyId()],g=l.attribute,m=g.packUID||g.uid,u=g.update(i),v=g.size||l.end-l.start,T=l.start*a,I=l.end*a;T<I;)for(w=0;w<v;++w,++T)l.buffer.data[T]=u[w];d=c[m]||[null,Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER],d[0]=g,d[1]=Qc(l.start*a,d[1]),d[2]=Yc(l.end*a,d[2]),c[m]=d}i.reactivate=!1}updateInstanceFull(e,i,r,s){const a=s.propertyToBufferLocation,o=this.bufferAttributeWillUpdate,c=this.layer.shaderIOInfo.instanceVertexCount;let l,u,d,p,g=0,m,v,b,T,w,E,x;if(i.active){for((r.length===0||i.reactivate)&&(r=this.bufferManager.getUpdateAllPropertyIdList()),m=0,E=r.length;m<E;++m)if(l=a[r[m]],!!l){for(p=l.attribute,u=p.update(i),g=p.size||l.end-l.start,b=l.start*c,w=l.end*c;b<w;)for(T=0;T<g;++T,++b)l.buffer.data[b]=u[T];if(o[p.packUID||p.uid]=p,l.childLocations){for(d=l.childLocations,b=0,w=d.length;b<w;++b)if(l=d[b],!!l){for(p=l.attribute,u=p.update(i),g=p.size||l.end-l.start,v=l.start*c,x=l.end*c;v<x;)for(T=0;T<g;++T,++v)l.buffer.data[v]=u[T];o[p.packUID||p.uid]=p}}}}else{for(l=a[this.bufferManager.getActiveAttributePropertyId()],p=l.attribute,g=p.size||l.end-l.start,u=p.update(i),v=l.start*c,x=l.end*c;v<x;)for(T=0;T<g;++T,++v)l.buffer.data[v]=u[T];o[p.packUID||p.uid]=p}i.reactivate=!1}commit(){if(this.diffMode===0){const e=Object.values(this.bufferAttributeUpdateRange);for(let i=0,r=e.length;i<r;++i){const s=e[i],a=s[0].bufferAttribute;a.updateRange={count:s[2]-s[1],offset:s[1]}}}else{const e=Object.values(this.bufferAttributeWillUpdate);for(let i=0,r=e.length;i<r;++i){const s=e[i].bufferAttribute;s.updateRange={count:-1,offset:0}}}this.bufferAttributeUpdateRange={}}incomingChangeList(e){e.length===0?this.diffMode=0:e.length>this.bufferManager.getInstanceCount()*.7?this.diffMode=1:this.diffMode=0,this.diffMode===0?this.updateInstance=this.updateInstancePartial:this.updateInstance=this.updateInstanceFull}}class o0{constructor(){f(this,"processor");f(this,"processing")}makeProcessor(t,e){if(this.processing)return this.processing;if(t.bufferType===ce.INSTANCE_ATTRIBUTE||t.bufferType===ce.INSTANCE_ATTRIBUTE_PACKING?this.processor=new t0(t,e):t.bufferType===ce.VERTEX_ATTRIBUTE||t.bufferType===ce.VERTEX_ATTRIBUTE_PACKING?this.processor=new a0(t,e):this.processor=new n0(t,e),!this.processor)throw new Error("Failed to create a diff processor");return this.processing=[this.processor.changeInstance,this.processor.addInstance,this.processor.removeInstance],this.processing}}class Wd{constructor(t){f(this,"index",0);f(this,"available",4);this.index=t}setAttribute(t){return(t.size||0)<=this.available?(t.block=this.index,t.blockIndex=4-this.available,this.available-=t.size||0,!0):!1}}function c0(n){n.forEach(t=>{if(t.resource&&t.size===void 0&&(t.size=P.FOUR),!t.size)try{const e=t.update(new Ye({}));e.length>0&&e.length<=P.FOUR&&(t.size=e.length)}catch{console.warn("The system could not determine the size of the provided attribute. Please provide the size of the attribute:",t)}})}function jd(n){c0(n);const t=[];n.forEach(e=>{if(e.size&&e.size===P.MAT4X4){e.block=t.length,e.blockIndex=Ho.INVALID;for(let r=0;r<4;++r){const s=new Wd(t.length);s.available=0,s.index=0,t.push(s)}return}if(!t.find(r=>r.setAttribute(e)?!!r:!1)){const r=new Wd(t.length);t.push(r),r.setAttribute(e)||console.warn("There was a problem packing an attribute into a block. No block would accommodate it:",e)}})}function Hd(n){return!!n}function Xd(n){return!!n}function Qd(n){return!!n}function l0(n){return Object.assign({},n,{materialAttribute:null})}function u0(n){return Object.assign({},n,{materialIndexBuffer:null})}function h0(n){return Object.assign({},n,{materialUniforms:[]})}function d0(n,t,e,i){t.forEach(r=>{r.name===void 0&&console.warn("All instance attributes MUST have a name on Layer:",n.id),t.find(s=>s!==r&&s.name===r.name)&&console.warn("An instance attribute can not have the same name used more than once:",r.name),e.find(s=>s.name===r.name)&&console.warn("An instance attribute and a vertex attribute in a layer can not share the same name:",r.name),r.resource||r.size===void 0&&(console.warn("An instance attribute requires the size to be defined."),console.warn(r))})}function f0(n,t,e){if(!e)return;let i=t.instanceAttributes||[],r=t.uniforms||[],s=t.vertexAttributes||[];e.shaderModuleUnits.forEach(l=>{l.instanceAttributes&&(i=i.concat(l.instanceAttributes(n))),l.uniforms&&(r=r.concat(l.uniforms(n))),l.vertexAttributes&&(s=s.concat(l.vertexAttributes(n)))});const a=new Set,o=new Set,c=new Set;r.filter(l=>l?a.has(l.name)?(console.warn("Included shader modules has introduced duplicate uniform names:",l.name,"One will be overridden thus causing a potential crash of the shader."),!1):(a.add(l.name),!0):!1),i.filter(l=>l?o.has(l.name)?(console.warn("Included shader modules has introduced duplicate Instance Attribute names:",l.name,"One will be overridden thus causing a potential crash of the shader."),!1):(o.add(l.name),!0):!1),s.filter(l=>l?c.has(l.name)?(console.warn("Included shader modules has introduced duplicate Vertex Attribute names:",l.name,"One will be overridden thus causing a potential crash of the shader."),!1):(c.add(l.name),!0):!1),t.instanceAttributes=i,t.uniforms=r,t.vertexAttributes=s}function Yd(n,t,e,i,r,s){f0(t,e,s);const a=(e.instanceAttributes||[]).filter(Hd),o=(e.vertexAttributes||[]).filter(Xd),c=(e.uniforms||[]).filter(Qd);let l=de(e.indexBuffer)?e.indexBuffer:void 0;for(let m=0,v=i.length;m<v;++m){const b=i[m];if(b.validate(t,a,o,c)){const T=b.expand(t,a,o,c);T.instanceAttributes.filter(Hd).forEach(w=>a.push(w)),T.vertexAttributes.filter(Xd).forEach(w=>o.push(w)),T.uniforms.filter(Qd).forEach(w=>c.push(w)),de(T.indexBuffer)&&(l=T.indexBuffer)}}d0(t,a,o);const u=a.slice(0),d=(o||[]).map(l0),p=c.map(h0),g=de(l)?u0(l):void 0;return u.sort(r.sortInstanceAttributes),p.sort(r.sortUniforms),d.sort(r.sortVertexAttributes),jd(u),t.getLayerBufferType(n,e,o,u),{instanceAttributes:u,uniforms:p,vertexAttributes:d,indexBuffer:g}}class qc{constructor(){f(this,"instanceMaxBlock");f(this,"blocksPerInstance");f(this,"maxUniforms");f(this,"maxUniformsForInstancing");f(this,"maxInstancesPerUniformBuffer");f(this,"totalInstanceUniformBlocks")}static calculateUniformBlockUseage(t){let e=0;for(let i=0,r=t.length;i<r;++i)e+=Math.ceil(t[i].size/4);return e}process(t,e){this.instanceMaxBlock=0,t.forEach(i=>{this.instanceMaxBlock=Math.max(this.instanceMaxBlock,i.block||0)}),this.blocksPerInstance=this.instanceMaxBlock+1,this.maxUniforms=N.MAX_VERTEX_UNIFORMS,this.maxUniformsForInstancing=this.maxUniforms-qc.calculateUniformBlockUseage(e),this.maxInstancesPerUniformBuffer=Math.floor(this.maxUniformsForInstancing/this.blocksPerInstance),this.totalInstanceUniformBlocks=this.maxInstancesPerUniformBuffer*this.blocksPerInstance}}const is="Once a ShaderModuleUnit has been registered, you CAN NOT modify it! Module ID:";class Ta{constructor(t){f(this,"description");f(this,"_isLocked");f(this,"_content");f(this,"_compatibility");f(this,"_moduleId");f(this,"_dependents",null);f(this,"isFinal");Object.assign(this,t)}get content(){return this._content}set content(t){if(this._isLocked){console.warn(is,this._moduleId);return}this._content=t}get compatibility(){return this._compatibility}set compatibility(t){if(this._isLocked){console.warn(is,this._moduleId);return}this._compatibility=t}get dependents(){return this._dependents}set dependents(t){if(this._isLocked&&this._dependents!==null){console.warn(is,this._moduleId);return}this._dependents=t}isLocked(){return this._isLocked}get moduleId(){return this._moduleId}set moduleId(t){if(this._isLocked){console.warn(is,this._moduleId);return}this._moduleId=t}applyAnalyzedContent(t){if(this._isLocked&&this.dependents!==null){console.warn(is,this._moduleId);return}this._content=t}lock(){this._isLocked=!0}}const qd=Ie("performance"),p0=Ie("shader-module-vs"),g0=Ie("shader-module-fs"),Kd="import",Zd=":";function Jd(n,t){return!!n&&(n.compatibility===t||n.compatibility===S.ALL)}const zn=class{static register(t){if(!(t instanceof Ta)){if(Array.isArray(t)){let o="";return t.forEach(c=>{const l=zn.register(c);l&&(o+=`${l}
`)}),o||null}return zn.register(new Ta(t))}let e=zn.modules.get(t.moduleId);e||(e={},zn.modules.set(t.moduleId,e));const i=e.fs,r=e.vs,s=Jd(t,S.FRAGMENT),a=Jd(t,S.VERTEX);if(i&&s){if(i.isFinal)return`Module ID: ${t.moduleId} Can not override the module's existing Fragment registration as the exisitng module is marked as final`;qd("A Shader Module Unit has overridden an existing module for the Fragment Shader Module ID: %o",t.moduleId)}if(r&&a){if(r.isFinal)return`Module ID: ${t.moduleId} Can not override the module's existing Vertex registration as the exisitng module is marked as final`;qd("A Shader Module Unit has overridden an existing module for the Vertex Shader Module ID: %o",t.moduleId)}return s&&(e.fs=t),a&&(e.vs=t),t.lock(),null}static analyzeDependents(t){if(t.dependents&&t.isLocked())return[];const e=[],i=[],r=new Set,s=t.compatibility,a=t.moduleId,o=ii({options:{},shader:t.content,onToken:c=>{const l=c.trim();if(l.indexOf(Kd)===0){const u=l.substr(Kd.length).trim();if(u[0]===Zd){let d=!1;const p=u.substr(Zd.length).trim().split(",");return p[p.length-1].trim().length===0&&p.pop(),p.forEach(g=>{g=g.trim();const m=zn.modules.get(g);m?((s===S.FRAGMENT||s===S.ALL)&&(m.fs?(d=!0,r.has(g)||i.push(g)):e.push(`Could not find requested target fragment module for Module ID: ${g} requested by module: ${a}`)),(s===S.VERTEX||s===S.ALL)&&(m.vs?(d=!0,r.has(g)||i.push(g)):e.push(`Could not find requested target vertex module for Module ID: ${g} requested by module: ${a}`)),!m.vs&&!m.fs&&e.push("Could not find a vertex or fragment shader within exisitng module"),d||e.push(`Error Processing module Module ID: ${g} requested by module: ${a}`)):e.push(`Could not find requested module: ${g} requested by module: ${a}`)}),""}}return`\${${c}}`}});return t.applyAnalyzedContent(o.shader),t.dependents=i,e}static process(t,e,i,r){const s=new Set,a=new Set,o=[],c=[],l=i===S.VERTEX?p0:g0;l("Processing Shader for context %o:",t);function u(v){const b=v.moduleId;l("%o: %o",b,o.slice(0).reverse().join(" -> "));const T=o.indexOf(b);if(o.unshift(b),T>-1){const w=o.slice(0,T+2).reverse();return c.push(`A Shader has detected a Circular dependency in import requests: ${w.join(" -> ")}`),o.shift(),!1}return!0}function d(v){const b=v.moduleId;if(!u(v))return null;if(b&&a.has(b))return o.shift(),"";let T="";zn.analyzeDependents(v).forEach(x=>c.push(x));const E=v.dependents;if(l("Module dependencies detected %o",E),E&&E.length>0)for(let x=0,_=E.length;x<_;++x){const I=E[x],M=zn.modules.get(I);if(M){let C;(i===S.FRAGMENT||i===S.ALL)&&(M.fs?(s.add(M.fs),C=d(M.fs)):c.push(`Could not find requested target fragment module for Module ID: ${I} requested by module: ${b}`)),(i===S.VERTEX||i===S.ALL)&&(M.vs?(s.add(M.vs),C=d(M.vs)):c.push(`Could not find requested target vertex module for Module ID: ${I} requested by module: ${b}`)),!M.vs&&!M.fs&&c.push("Could not find a vertex or fragment shader within exisitng module"),C===null&&c.push(`Error Processing module Module ID: ${I} requested by module: ${b}`),T+=C||""}else c.push(`Could not find requested module: ${I} requested by module: ${b}`)}return o.shift(),a.add(b||""),`${T.trim()}

${v.content.trim()}`}let p=e;if(r){let v="";r.forEach(b=>{v+=`\${import: ${b}}
`}),p=v+e}const g=new Ta({content:p,compatibility:i,moduleId:`Layer "${t}" ${i===S.ALL?"fs vs":i===S.VERTEX?"vs":"fs"}`});return{errors:c,shader:d(g),shaderModuleUnits:s}}};let xe=zn;f(xe,"modules",new Map);const ef={attributes:"attributes",easingMethod:"easingMethod",extend:"extend",extendHeader:"extendHeader",T:"T"},ya="out",Ea=":";class tf{constructor(){f(this,"metricsProcessing",new qc)}static mergeFragmentOutputsForMRT(t,e,i,r,s,a){let o="",c="",l="";const u=new Set,d=[],p=new Set;return N.MRT||(l=" = gl_FragColor"),i.forEach((g,m)=>{let v=!0,b=!1;if(s&&s.indexOf(g.outputType)<0&&(v=!1),a&&m<i.length-1&&(v=!1),!a&&r.indexOf(g.outputType)<0&&(v=!1),p.has(g.outputType))throw new Error("Can not use the same Output Fragment type multiple times");p.add(g.outputType);const T=r.indexOf(g.outputType);ii({shader:Jr(g.source),onToken(w){const E=w.trim();if(E.indexOf(ya)===0){if(b)throw console.error("Found multiple ${out} tokens in a single fragment shader. This is not supported nor logical","If you need to use the declared output multiple times, use the assigned name","and don't wrap it repeatedly in the shader.","eg-","void main() {","  ${out: myOutput} = value;","  vec4 somethingElse = myOutput;","}"),new Error("Invalid Shader Format");b=!0;const x=E.substr(ya.length).trim();if(x[0]===Ea){const _=x.substr(Ea.length).trim();if(!_)throw new Error("Output in a shader requires an identifier ${out: <name required>}");if(u.has(_))throw new Error("You can not declare the same output name in subsequent fragment shader outputs");if(_==="gl_FragColor")throw new Error("DO not use gl_FragColor as an identifier for an out. Choose something not used by the WebGL spec.");let I="";if(v)if(u.add(_),d.push(g.outputType),N.MRT_EXTENSION)l=` = gl_FragData[${T}]`,I="vec4 ";else if(N.MRT&&N.SHADERS_3_0)e.set(_,`layout(location = ${T}) out vec4 ${_};
`);else throw new Error(`Could not generate a proper output declaration for the fragment shader output: ${_}`);else I="vec4 ";return`${I}${_}${l}`}else throw new Error("Output in a shader requires an identifier ${out: <name required>}")}return`\${${w}}`},onMain(w,E){return!b&&w&&(w.match("gl_FragColor")?(d.push(g.outputType),N.MRT&&(N.SHADERS_3_0?(e.set("_FragColor",`layout(location = ${T}) out vec4 _FragColor;
`),w=w.replace(/gl_FragColor/g,"_FragColor")):(w=w.replace(/gl_FragColor\s+=/,`vec4 _FragColor = gl_FragData[${T}] =`),w=w.replace(/gl_FragColor\s+=/g,`_FragColor = gl_FragData[${T}] =`),w=w.replace(/gl_FragColor/g,"_FragColor"))),u.add("_FragColor")):d.push(H.NONE)),o+=`
${(E||"").trim()}`,c+=`
  ${(w||"").trim()}`,(w||"").trim()}})}),{output:`${o}
void main() {
${c}
}`,outputNames:Array.from(u.values()),outputTypes:d}}static mergeOutputFragmentShaderForColor(t,e){if(e.length>1||e[0]!==H.COLOR)throw new Error("Merging fragment shaders for only COLOR output is only valid when the view has a single COLOR output target.");Sn(t)&&(t=[{outputType:H.COLOR,source:t}]);let i="",r="";const s=new Set,a=[];return t.some(o=>{const c=o.outputType===H.COLOR;let l=!1;return c&&a.push(H.COLOR),ii({shader:Jr(o.source),onToken(u){const d=u.trim();if(d.indexOf(ya)===0){if(l)throw console.error("Found multiple ${out} tokens in a single fragment shader. This is not supported nor logical","If you need to use the declared output multiple times, use the assigned name","and don't wrap it repeatedly in the shader.","eg-","void main() {","  ${out: myOutput} = value;","  vec4 somethingElse = myOutput;","}"),new Error("Invalid Shader Format");l=!0;const p=d.substr(ya.length).trim();if(p[0]===Ea){const g=p.substr(Ea.length).trim();if(!g)throw new Error("Output in a shader requires an identifier ${out: <name required>}");if(s.has(g))throw new Error("You can not declare the same output name in subsequent fragment shader outputs");if(g==="gl_FragColor")throw new Error("DO not use gl_FragColor as an identifier for an out. Choose something not used by the WebGL spec.");return c?(s.add("gl_FragColor"),g!=="gl_FragColor"?`vec4 ${g} = gl_FragColor`:"gl_FragColor"):`vec4 ${g}`}}return`\${${u}}`},onMain(u,d){return r+=`
${(d||"").trim()}`,i+=`
  ${(u||"").trim()}`,(u||"").trim()}}),!!c}),{output:`${r}
void main() {
${i}
}`,outputNames:Array.from(s.values()),outputTypes:a}}static makeOutputFragmentShader(t,e,i,r){if(!i||Sn(i))if(Sn(r)){const s=this.mergeOutputFragmentShaderForColor([{source:r,outputType:H.COLOR}],[H.COLOR]);return{source:s.output,outputTypes:[H.COLOR],outputNames:s.outputNames}}else if(Array.isArray(r)){const s=r.find(c=>c.outputType===H.COLOR);let a=-1;s?a=r.indexOf(s):a=r.length-1;const o=this.mergeOutputFragmentShaderForColor(r.slice(0,a+1),[H.COLOR]);return{source:o.output,outputNames:o.outputNames,outputTypes:[H.COLOR]}}else return null;else if(Array.isArray(i)){if(!N.MRT)throw new Error("Multiple Render Targets were specified, but are not natively supported by user's hardware! MRT also does not have a fallback in deltav yet!");const s=i.map(a=>a.outputType);if(Array.isArray(r)){const a=new Map;for(let o=0,c=i.length;o<c;++o){const l=i[o];for(let u=0,d=r.length;u<d;++u)if(r[u].outputType===l.outputType){a.set(l.outputType,u);break}}if(N.MRT){let o=-1;const c=[];if(a.forEach((u,d)=>{c.push(d),o=Math.max(u,o)}),o===-1)return null;const l=this.mergeFragmentOutputsForMRT(t,e,r.slice(0,o+1),s,c);return{source:l.output,outputNames:l.outputNames,outputTypes:l.outputTypes}}else throw new Error("Fragment shader generation not supported for MRT systems on non MRT hardware...yet")}else if(i.find(o=>o.outputType===H.COLOR)&&r){const o=this.mergeFragmentOutputsForMRT(t,e,[{source:r,outputType:H.COLOR}],s);return{source:o.output,outputNames:o.outputNames,outputTypes:o.outputTypes}}}return null}process(t,e,i,r,s,a,o){try{if(!t.surface.gl)return console.warn("No WebGL context available for layer!"),null;const c=this.processImports(t,e,i);if(!c)return null;const{vertexAttributes:l,instanceAttributes:u,indexBuffer:d,uniforms:p}=Yd(t.surface.gl,t,e,s,o,c);t.getLayerBufferType(t.surface.gl,e,l,u),this.metricsProcessing.process(u,p);let g="",m="",v="";const b={uniforms:[]},T=r.vs||new Map,w=r.fs||new Map,E=r.destructure||new Map;for(let O=0,X=s.length;O<X;++O){const W=s[O],q=W.processHeaderInjection(S.VERTEX,T,t,this.metricsProcessing,l,u,p);g+=q.injection,q.material&&(b.uniforms=b.uniforms.concat(q.material.uniforms||[])),v+=W.processAttributeDestructuring(t,E,this.metricsProcessing,l,u,p)}let x="";T.forEach(O=>{x+=O}),g=x+g,x="",E.forEach(O=>{x+=O}),v=x+v;const _=this.processExtensions(),I=`precision highp float;

`,M=_+I+g+c.vs;let C={[ef.attributes]:v},F=!1;const Q=ii({options:C,required:void 0,shader:M,onToken(O,X){return O===ef.attributes&&(F=!0),X},onMain(O){return F?O||"":O===null?(console.warn("The body of void main() could not be determined."),""):`${v}
${O}`}});return c.fs.forEach((O,X)=>{C={},m="",x="";const W=w.get(X)||new Map;for(let Z=0,K=s.length;Z<K;++Z){const le=s[Z].processHeaderInjection(S.FRAGMENT,W,t,this.metricsProcessing,l,u,p);if(m+=le.injection,le.material){const we=new Set;b.uniforms.forEach(He=>we.add(He.name)),b.uniforms.forEach(He=>{we.has(He.name)||b.uniforms.push(He)})}}W.forEach(Z=>{x+=Z}),m=x+m;const q=_+I+m+O.source,ne=ii({options:C,required:void 0,shader:q});O.source=ne.shader.trim();for(let Z=0,K=a.length;Z<K;++Z){const Oe=a[Z];Q.shader=Oe.vertex(Q.shader),O.source=Oe.fragment(O.source)}}),{fs:c.fs,materialUniforms:b.uniforms,maxInstancesPerBuffer:this.metricsProcessing.maxInstancesPerUniformBuffer,modules:Array.from(c.shaderModuleUnits),vs:Q.shader.trim(),vertexAttributes:l,instanceAttributes:u,uniforms:p,indexBuffer:d}}catch(c){return c instanceof Error&&(console.warn("An unknown error occurred while processing the shaders for layer:",t.id),console.warn("Error:"),console.warn(c&&(c.stack||c.message))),null}}processExtensions(){let t="";return N.SHADERS_3_0&&(t+="#version 300 es"),N.MRT_EXTENSION&&(t+="#extension GL_EXT_draw_buffers : require"),t&&(t+=`

`),t}processImports(t,e,i){const r=new Set;let s=t.baseShaderModules(e);t.props.baseShaderModules&&(s=t.props.baseShaderModules(e,s));const a=xe.process(t.id,e.vs,S.VERTEX,s.vs);if(a.errors.length>0)return console.warn("Error processing imports for the vertex shader of layer:",t.id,"Errors",...a.errors.reverse()),null;const o=new Map;return i.forEach((c,l)=>{const u=xe.process(t.id,c.source,S.FRAGMENT,s.fs);if(u.errors.length>0){console.warn("Error processing imports for the fragment shader of layer:",t.id,"Errors",...u.errors.reverse());return}u.shaderModuleUnits.forEach(p=>r.add(p));const d={source:u.shader||"",outputTypes:c.outputTypes,outputNames:c.outputNames};o.set(l,d)}),a.shaderModuleUnits.forEach(c=>r.add(c)),{fs:o,vs:a.shader||"",shaderModuleUnits:r}}}class nf{constructor(t){f(this,"colorPicking");f(this,"isMouseOver",new Set);f(this,"isMouseDown",new Set);f(this,"layer");f(this,"isTouchOver",new Map);f(this,"isTouchDown",new Map);this.layer=t}getColorPickInstance(t){return this.colorPicking&&this.layer.picking.type===Y.SINGLE&&this.colorPicking.view===t?this.layer.uidToInstance.get(16777215-this.colorPicking.nearestColor):null}handleMouseOver(t,e){}handleTouchOver(t,e,i){}handleMouseDown(t,e){if(this.layer.picking&&this.layer.picking.type!==Y.NONE){const{onMouseDown:i}=this.layer.props;if(i){const r=t.projection.screenToWorld(e.screen.position),s=[];if(this.layer.picking.type===Y.SINGLE){const o=this.getColorPickInstance(t);o&&s.push(o)}const a={interaction:e,instances:s,layer:this.layer.id,projection:t.projection,screen:e.screen.position,world:r};i(a),this.isMouseDown.clear(),s.forEach(o=>this.isMouseDown.add(o))}}}handleTouchDown(t,e,i){const{onTouchDown:r,onTouchOver:s}=this.layer.props;if(!this.layer.picking||this.layer.picking.type===Y.NONE||!r&&!s)return;const a=t.projection.screenToWorld(i.screen.position),o=[];if(this.layer.picking.type===Y.SINGLE){const d=this.getColorPickInstance(t);d&&o.push(d)}const c={interaction:e,touch:i,instances:o,layer:this.layer.id,projection:t.projection,screen:i.screen.position,world:a},l=ni(this.isTouchDown,i.touch.touch.identifier,()=>new Set),u=ni(this.isTouchOver,i.touch.touch.identifier,()=>new Set);o.forEach(d=>{l.add(d),u.add(d)}),s&&s(c),r&&r(c)}handleMouseOut(t,e){if(this.layer.picking&&this.layer.picking.type!==Y.NONE){const{onMouseOut:i}=this.layer.props;if(i){const r=t.projection.screenToWorld(e.screen.position),s={interaction:e,instances:Array.from(this.isMouseOver.keys()),layer:this.layer.id,projection:t.projection,screen:e.screen.position,world:r};i(s)}}this.isMouseOver.clear()}handleTouchOut(t,e,i){const{onTouchOut:r}=this.layer.props;if(!this.layer.picking||this.layer.picking.type===Y.NONE||!r)return;const s=t.projection.screenToWorld(i.screen.position),a={interaction:e,touch:i,instances:Array.from(this.isMouseOver.keys()),layer:this.layer.id,projection:t.projection,screen:i.screen.position,world:s};r(a),this.isTouchOver.delete(i.touch.touch.identifier)}handleMouseUp(t,e){const{onMouseUp:i,onMouseUpOutside:r}=this.layer.props;if(!this.layer.picking||this.layer.picking.type===Y.NONE||!i)return;const s=t.projection.screenToWorld(e.screen.position),a=[];if(this.layer.picking.type===Y.SINGLE){const c=this.getColorPickInstance(t);c&&a.push(c)}let o={interaction:e,instances:a,layer:this.layer.id,projection:t.projection,screen:e.screen.position,world:s};i(o),a.forEach(c=>this.isMouseDown.delete(c)),!(this.isMouseDown.size<=0||!r)&&(o={interaction:e,instances:Array.from(this.isMouseDown.values()),layer:this.layer.id,projection:t.projection,screen:e.screen.position,world:s},r(o))}handleTouchUp(t,e,i){const{onTouchUp:r,onTouchUpOutside:s,onTouchOut:a,onTouchAllEnd:o}=this.layer.props;if(!this.layer.picking||this.layer.picking.type===Y.NONE||!r&&!s&&!a&&!o)return;const c=t.projection.screenToWorld(i.screen.position),l=[];if(this.layer.picking.type===Y.SINGLE){const p=this.getColorPickInstance(t);p&&l.push(p)}let u={interaction:e,touch:i,instances:l,layer:this.layer.id,projection:t.projection,screen:i.screen.position,world:c};a&&a(u),r&&r(u);const d=ha(this.isTouchDown,i.touch.touch.identifier,new Set);l.forEach(p=>d.delete(p)),d.size>0&&s&&(u={interaction:e,touch:i,instances:Array.from(d.values()),layer:this.layer.id,projection:t.projection,screen:i.screen.position,world:c},s(u)),this.isTouchDown.delete(i.touch.touch.identifier),this.isTouchDown.size<=0&&o&&(u={interaction:e,touch:i,instances:[],layer:this.layer.id,projection:t.projection,screen:i.screen.position,world:c},o(u))}handleMouseMove(t,e){const{onMouseOver:i,onMouseMove:r,onMouseOut:s}=this.layer.props;if(this.layer.picking&&this.layer.picking.type!==Y.NONE&&(i||r||s)){let a;const o=t.projection.screenToWorld(e.screen.position),c=[];if(this.layer.picking.type===Y.SINGLE){const u=this.getColorPickInstance(t);u&&c.push(u)}const l=new Set;if(c.forEach(u=>l.add(u)),s){const u=[];this.isMouseOver.forEach(d=>{l.has(d)||u.push(d)}),a={interaction:e,instances:u,layer:this.layer.id,projection:t.projection,screen:e.screen.position,world:o},u.length>0&&s(a)}if(i){const u=c.filter(d=>!this.isMouseOver.has(d));a={interaction:e,instances:u,layer:this.layer.id,projection:t.projection,screen:e.screen.position,world:o},u.length>0&&i(a)}r&&(a={interaction:e,instances:c,layer:this.layer.id,projection:t.projection,screen:e.screen.position,world:o},r(a)),this.isMouseOver=l}}handleTouchMove(t,e,i){const{onTouchOver:r,onTouchMove:s,onTouchOut:a}=this.layer.props;if(this.layer.picking&&this.layer.picking.type!==Y.NONE&&(r||s||a)){let o;const c=t.projection.screenToWorld(i.screen.position),l=[];if(this.layer.picking.type===Y.SINGLE){const p=this.getColorPickInstance(t);p&&l.push(p)}const u=ha(this.isTouchOver,i.touch.touch.identifier,new Set),d=new Set;if(l.forEach(p=>d.add(p)),a){const p=[];u.forEach(g=>{d.has(g)||p.push(g)}),o={interaction:e,touch:i,instances:p,layer:this.layer.id,projection:t.projection,screen:i.screen.position,world:c},p.length>0&&a(o)}if(r){const p=l.filter(g=>!u.has(g));o={interaction:e,touch:i,instances:p,layer:this.layer.id,projection:t.projection,screen:i.screen.position,world:c},p.length>0&&r(o)}s&&(o={interaction:e,touch:i,instances:l,layer:this.layer.id,projection:t.projection,screen:i.screen.position,world:c},s(o)),this.isMouseOver=d}}handleMouseClick(t,e){if(this.layer.picking&&this.layer.picking.type!==Y.NONE){const{onMouseClick:i}=this.layer.props;if(i){const r=t.projection.screenToWorld(e.screen.position),s=[];if(this.layer.picking.type===Y.SINGLE){const o=this.getColorPickInstance(t);o&&s.push(o)}const a={interaction:e,instances:s,layer:this.layer.id,projection:t.projection,screen:e.screen.position,world:r};i(a)}}}handleTap(t,e,i){if(this.layer.picking&&this.layer.picking.type!==Y.NONE){const{onTap:r}=this.layer.props;if(r){const s=t.projection.screenToWorld(i.screen.position),a=[];if(this.layer.picking.type===Y.SINGLE){const c=this.getColorPickInstance(t);c&&a.push(c)}const o={interaction:e,touch:i,instances:a,layer:this.layer.id,projection:t.projection,screen:i.screen.position,world:s};r(o)}}}handleMouseDrag(t,e){}}const{max:m0}=Math,cr=Ie("performance");class v0 extends ir{constructor(e,i){super(e,i);f(this,"allBufferLocations",{});f(this,"availableLocations",[]);f(this,"currentInstancedCount",0);f(this,"instanceToBufferLocation",{});f(this,"maxInstancedCount",1e3);f(this,"geometry");f(this,"material");f(this,"model");f(this,"attributes");f(this,"blockAttributes");f(this,"blockSubAttributesLookup",new Map);f(this,"attributeToPropertyIds",new Map);f(this,"updateAllPropertyIdList",[]);f(this,"activePropertyId",-1);f(this,"currentAvailableLocation",-1);f(this,"remove",e=>{const i=this.instanceToBufferLocation[e.uid];return i&&(delete this.instanceToBufferLocation[e.uid],this.availableLocations.push(i)),e});this.add=this.doAddWithRegistration}changesProcessed(){super.changesProcessed(),this.availableLocations.splice(0,this.currentAvailableLocation+1),this.currentAvailableLocation=-1}doAddWithRegistration(e){this.layer.shaderIOInfo.instanceAttributes.forEach(r=>{if(r.parentAttribute)return;_e.setObservableMonitor(!0),r.update(e);const s=_e.getObservableMonitorIds(!0);this.attributeToPropertyIds.set(r,[s[s.length-1]]),s.length>1&&cr("Property has multiple observables. Only the last trigger will be retained as the feature is not complete yet"),r===this.layer.shaderIOInfo.activeAttribute&&(this.activePropertyId=s[0])}),_e.setObservableMonitor(!1),this.makeUpdateAllPropertyIdList();const i=this.resizeBuffer();return this.gatherLocationsIntoGroups(i.newLocations,i.growth),this.add=this.doAdd,this.doAdd(e)}doAdd(e){if(this.availableLocations.length<=0||this.currentAvailableLocation>=this.availableLocations.length-1){const r=this.resizeBuffer();this.gatherLocationsIntoGroups(r.newLocations,r.growth)}const i=this.availableLocations[++this.currentAvailableLocation];return i&&this.geometry?(this.instanceToBufferLocation[e.uid]=i,this.currentInstancedCount=this.geometry.maxInstancedCount=m0(this.currentInstancedCount,i.instanceIndex+1),this.model&&(this.model.vertexDrawRange=[0,this.layer.shaderIOInfo.instanceVertexCount],this.model.drawInstances=this.currentInstancedCount,this.layer.shaderIOInfo.instanceVertexCount===0&&(this.model.vertexDrawRange[1]=this.model.drawInstances))):console.error("Add Error: Instance Attribute Buffer Manager failed to pair an instance with a buffer location"),i}destroy(){this.geometry&&this.geometry.destroy(),this.material&&this.material.dispose(),this.scene&&this.scene.container&&this.model&&this.scene.container.remove(this.model)}getBufferLocations(e){return this.instanceToBufferLocation[e.uid]}getActiveAttributePropertyId(){return this.activePropertyId}getUpdateAllPropertyIdList(){return this.updateAllPropertyIdList}managesInstance(e){return this.instanceToBufferLocation[e.uid]!==void 0}makeUpdateAllPropertyIdList(){const e={};this.attributeToPropertyIds.forEach(i=>{e[i[0]]=i[0]}),this.updateAllPropertyIdList=Object.values(e).filter(Boolean)}removeFromScene(){this.scene&&this.scene.container&&this.model&&this.scene.container.remove(this.model),delete this.scene}resizeBuffer(){const e=this.layer.shaderIOInfo;let i=0;const r=new Map;if(this.changeListContext){i=this.layer.shaderIOInfo.baseBufferGrowthRate;for(let s=0,a=this.changeListContext.length;s<a;++s){const o=this.changeListContext[s];switch(o[1]){case Te.CHANGE:case Te.INSERT:this.instanceToBufferLocation[o[0].uid]||i++;break}}}if(cr("BEGIN: Resizing packed attribute buffer by %d instances",i),this.geometry){cr(`Info: Vertex packing buffer is being resized for layer ${this.layer.id}`),this.geometry.destroy(),this.geometry=new An;const s=this.maxInstancedCount;for(const a of e.vertexAttributes)a.materialAttribute&&this.geometry.addAttribute(a.name,a.materialAttribute);this.maxInstancedCount+=i,this.attributes=this.attributes||[],this.blockAttributes=this.blockAttributes||[];for(let a=0,o=this.blockAttributes.length;a<o;++a){const c=this.blockAttributes[a];let l=c.bufferAttribute;const u=c.size||0;if(l.data instanceof Float32Array){let d=l.data;d.length<this.maxInstancedCount*u&&(d=new Float32Array(this.maxInstancedCount*u*2),d.set(l.data,0)),d.set(l.data,0);const p=new Ut(d,u,!0,!0);c.bufferAttribute=l=p,this.geometry.addAttribute(c.name,p);const g=this.blockSubAttributesLookup.get(a),m=c.size||0;if(g)for(let v=0,b=g.length;v<b;++v){const T=g[v];let w=r.get(T.name);w||(w=[],r.set(T.name,w));const E=this.allBufferLocations[T.name]||[];this.allBufferLocations[T.name]=E;const x=Object.assign({},T,{uid:z(),packUID:c.packUID,bufferAttribute:l}),_=T.blockIndex||0,I=T.size||1;let M;for(let B=0,O=E.length;B<O;++B)M=E[B],M.attribute=x,M.buffer.data=d;let C,F=w.length;const Q=this.maxInstancedCount-s;w.length+=Q,E.length+=Q;for(let B=s;B<this.maxInstancedCount;++B,++F)C={attribute:x,block:a,buffer:{data:d},instanceIndex:B,start:B*m+_,end:B*m+_+I},w[F]=C,E[B]=C}}}}else{this.maxInstancedCount+=i,this.geometry=new An;for(const o of e.vertexAttributes)o.materialAttribute&&this.geometry.addAttribute(o.name,o.materialAttribute);this.attributes=[],this.blockAttributes=[];const s=new Map,a=new Map;this.blockSubAttributesLookup=a;for(let o=0,c=e.instanceAttributes.length;o<c;++o){const l=e.instanceAttributes[o],u=l.block||0;let d=s.get(u)||0;d=Math.max(d,(l.blockIndex||0)+(l.size||0)),s.set(u,d);let p=a.get(u);p||(p=[],a.set(u,p)),p.push(l)}a.forEach(o=>o.sort((c,l)=>(c.blockIndex||0)-(l.blockIndex||0)));for(let o=0,c=s.size;o<c;++o){const l=s.get(o)||0,u=z();l||console.warn("Instance Attribute Packing Error: The system tried to build an attribute with a size of zero.","These are the attributes used:",e.instanceAttributes,"These are the block sizes calculated",s,"This is the block to attribute lookup generated",a);const d=new Float32Array(l*this.maxInstancedCount),p=new Ut(d,l,!0,!0);this.geometry.addAttribute(`block${o}`,p);const g=a.get(o);if(g){for(let m=0,v=g.length;m<v;++m){const b=g[m];let T=r.get(b.name);T||(T=[],r.set(b.name,T));const w=this.allBufferLocations[b.name]||[];this.allBufferLocations[b.name]=w;const E=Object.assign({},b,{uid:o,packUID:u,bufferAttribute:p,size:l}),x=b.blockIndex||0,_=b.size||1;for(let I=0;I<this.maxInstancedCount;++I){const M={attribute:E,block:o,buffer:{data:d},instanceIndex:I,start:I*l+x,end:I*l+x+_};T.push(M),w.push(M)}this.attributes.push(E)}this.blockAttributes.push({uid:z(),packUID:u,bufferAttribute:p,name:`block${o}`,size:l,update:()=>[0]})}else console.warn("Instance Attribute Packing Buffer Error: Somehow there are no attributes associated with a block.","These are the attributes used:",e.instanceAttributes,"These are the block sizes calculated",s,"This is the block to attribute lookup generated",a)}this.geometry.maxInstancedCount=0,this.material=this.makeLayerMaterial();for(let o=0,c=e.uniforms.length;o<c;++o){const l=e.uniforms[o];l.materialUniforms.push(this.material.uniforms[l.name])}}return this.scene&&this.model&&this.scene.container&&this.scene.container.remove(this.model),this.material=this.material||this.makeLayerMaterial(),this.model=nr(this.layer.id,this.geometry,this.material,this.layer.shaderIOInfo.drawMode),this.scene&&this.scene.container&&this.model&&this.scene.container.add(this.model),cr("COMPLETE: Resizing unpacked attribute buffer"),{growth:i,newLocations:r}}gatherLocationsIntoGroups(e,i){if(this.attributeToPropertyIds.size===0)return;cr("BEGIN: Packed attribute manager grouping new buffer locations");const r=[];this.attributeToPropertyIds.forEach((s,a)=>{r.push({attribute:a,bufferLocationsForAttribute:e.get(a.name)||[],childBufferLocations:(a.childAttributes||[]).map(o=>({location:e.get(o.name)||[],bufferIndex:-1})),ids:s,bufferIndex:-1})});for(let s=0;s<i;++s){const a={instanceIndex:-1,propertyToBufferLocation:{}};for(let o=0,c=r.length;o<c;++o){const l=r[o],u=l.attribute,d=l.ids,p=l.bufferLocationsForAttribute;if(!p){De("Instance Attribute Buffer Error",(m,v)=>{console.warn(`${v}: There is an error in forming buffer location groups in VertexAttributePackingBufferManager. Error count: ${m}`)});continue}const g=p[++l.bufferIndex];if(!g){De("Instance Attribute Buffer Error",(m,v)=>{console.warn(`${v}: There is an error in forming buffer location groups in VertexAttributePackingBufferManager. Error count: ${m}`)});continue}if(a.instanceIndex===-1)a.instanceIndex=g.instanceIndex;else if(g.instanceIndex!==a.instanceIndex){De("Instance Attribute Parallelism Error",(m,v)=>{console.warn(`${v}: A buffer location does not have a matching instance index which means the buffer locations are not in parallel with each other somehow. Error count: ${m}`),console.warn(u.name,g)});continue}if(u.childAttributes){const m=[];for(let v=0,b=u.childAttributes.length;v<b;++v){const T=u.childAttributes[v],w=l.childBufferLocations[v];if(w){const E=w.location[++w.bufferIndex];E?m.push(E):De("Instance Attribute Child Attribute Error",(x,_)=>{console.warn(`${_}: A child attribute does not have a buffer location available. Error count: ${x}`),console.warn(`Parent Attribute: ${u.name} Child Attribute: ${T.name}`)})}}g.childLocations=m}for(let m=0,v=d.length;m<v;++m){const b=d[m];a.propertyToBufferLocation[b]=g}}this.availableLocations.push(a)}cr("COMPLETE: Packed attribute buffer manager buffer location grouping"),va()}getInstanceCount(){return this.maxInstancedCount}}const Kc=Ie("performance"),ml=class extends _i{constructor(e,i,r){super(r);f(this,"animationEndTime",0);f(this,"alwaysDraw",!1);f(this,"_bufferManager");f(this,"_bufferType");f(this,"children");f(this,"depth",0);f(this,"diffManager");f(this,"easingId");f(this,"_easingManager",{easingComplete:new $e,complete:()=>this._easingManager.easingComplete.promise});f(this,"initializer");f(this,"interactions");f(this,"lastFrameTime",0);f(this,"needsViewDrawn",!1);f(this,"order");f(this,"parent");f(this,"picking",{currentPickMode:Y.NONE,type:Y.SINGLE,uidToInstance:new Map});f(this,"props");f(this,"resource",Md);f(this,"scene");f(this,"shaderIOInfo",{});f(this,"streamChanges",{locked:!1,streamIndex:0});f(this,"surface");f(this,"_uid",z());f(this,"uidToInstance",new Map);f(this,"view");f(this,"willRebuildLayer",!1);this.surface=e,this.scene=i,this.props=Object.assign({},ml.defaultProps||{},r)}get bufferManager(){return this._bufferManager}get bufferType(){return this._bufferType||ce.INSTANCE_ATTRIBUTE}get easingManager(){return this._easingManager}get uid(){return this._uid}static createRef(){return{easing:null}}validateShaderIO(e){if(!e)return this.picking&&(this.picking.type=Y.NONE),Kc("Shell layer initialized. Nothing will be rendered for this layer",this.id),!0;if(!e.fs||!e.vs)return console.warn("Layer needs to specify the fragment and vertex shaders:",this.id),!1}cleanShaderIOElements(e){e.instanceAttributes=(e.instanceAttributes||[]).filter(de),e.vertexAttributes=(e.vertexAttributes||[]).filter(de),e.uniforms=(e.uniforms||[]).filter(de)}checkForDuplicateOutputTypes(e){let{mapOutput:i}=this.props;Sn(e.fs)&&(e.fs=[{outputType:H.COLOR,source:e.fs}]),i=i||{};const r=new Set;let s=!1,a=Number.MIN_SAFE_INTEGER;for(let o=0,c=e.fs.length;o<c;++o){const l=e.fs[o],u=i[l.outputType];if(u===void 0){r.has(l.outputType)&&(s=!0),r.add(l.outputType);continue}u===H.NONE?l.outputType=a++:l.outputType=u,r.has(l.outputType)&&(s=!0),r.add(l.outputType)}if(s)return console.warn("Layer has duplicate fragment shader output types"),!1}processFragmentShadersForEachView(e,i){Sn(e.fs)&&(e.fs=[{outputType:H.COLOR,source:e.fs}]);const r=this.picking.type===Y.SINGLE&&!e.fs.find(c=>c.outputType===H.PICKING);if(this.picking.type===Y.SINGLE&&!r)throw new Error("Do NOT specify picking prop on a layer when you have your own Picking output declared.");const s={outputType:H.PICKING,source:qg},a=new Map,o={fs:new Map,vs:new Map,destructure:new Map};for(let c=0,l=i.length;c<l;++c){const u=i[c];if(r){const v=e.fs.findIndex(b=>b.outputType===H.PICKING);v>-1&&e.fs.splice(v,1)}const d=u.getOutputTargets();let p=0;e.fs.forEach((v,b)=>{d!=null&&d.find(T=>T.outputType===v.outputType)&&(p=b)}),r&&e.fs.splice(p+1,0,s);let g=ni(o.fs,u,new Map);g||(g=new Map,o.fs.set(u,g));const m=tf.makeOutputFragmentShader(o.vs,g,d,e.fs);if(!m)return console.warn("Could not generate output fragment shaders for the view specified."),!1;a.set(u,m)}return{outputFragmentShaders:a,declarations:o}}processLayerShaders(e,i,r){let s=null;if(s=new tf().process(this,e,i,r,this.surface.getIOExpanders(),this.surface.getShaderTransforms(),this.surface.getIOSorting()),!s)return console.warn("The shader processor did not produce metrics for the layer."),!1;this.shaderIOInfo=Object.assign({activeAttribute:{name:"active",size:P.ONE,update:a=>[a.active?1:0]},baseBufferGrowthRate:e.baseBufferGrowthRate===void 0?1e3:e.baseBufferGrowthRate,instancing:e.instancing===void 0?!0:e.instancing,instanceAttributes:s.instanceAttributes,instanceVertexCount:e.vertexCount,vs:s.vs,fs:s.fs,materialUniforms:s.materialUniforms,maxInstancesPerBuffer:s.maxInstancesPerBuffer,drawMode:e.drawMode||h.GLSettings.Model.DrawMode.TRIANGLE_STRIP,uniforms:s.uniforms,vertexAttributes:s.vertexAttributes,indexBuffer:s.indexBuffer},this.shaderIOInfo)}processVertexAttributes(e){Od(this,this.shaderIOInfo.maxInstancesPerBuffer,this.shaderIOInfo.vertexAttributes,e.vertexCount,this.shaderIOInfo.indexBuffer)}init(e){if(!this.surface.gl)return console.warn("The layer's surface does not have a valid WebGL context."),!1;const{picking:i=Y.NONE}=this.props;i===Y.SINGLE?this.picking={currentPickMode:Y.NONE,type:Y.SINGLE,uidToInstance:new Map}:this.picking={currentPickMode:Y.NONE,type:Y.NONE},this.resource=this.surface.resourceManager;const r=this.initShader();this.interactions=new nf(this);const s=this.validateShaderIO(r);if(s!==void 0)return s;if(!r)return!1;let a;return this.surface.getShaderTransforms().forEach(c=>{r.vs=c.rawVertex(r.vs),r.fs=c.rawFragment(r.fs)}),a=this.cleanShaderIOElements(r),Qn(a)||(a=this.checkForDuplicateOutputTypes(r),Qn(a))||(a=this.processFragmentShadersForEachView(r,e),Qn(a))||(a=this.processLayerShaders(r,a.outputFragmentShaders,a.declarations),Qn(a))||(a=this.processVertexAttributes(r),Qn(a))||(a=this.makeLayerBufferManager(this.surface.gl,this.scene,r),Qn(a))||(a=this.updateDiffHandlers(),Qn(a))?a:(this.layerShaderDebugging(),this.props.ref&&(this.props.ref.easing=this.easingManager),!0)}layerShaderDebugging(){this.props.printShader&&(console.warn(`Layer: ${this.props.key}`,`
Shader Configuration:`,this.shaderIOInfo),console.warn(`VERTEX SHADER
`),console.warn(`
${this.shaderIOInfo.vs}`),this.shaderIOInfo.fs.forEach((e,i)=>{console.warn(`FRAGMENT SHADER:
`,`view: ${i.id}):
Output Targets${JSON.stringify(e.outputNames)}
${JSON.stringify(e.outputTypes)}
`),console.warn(`
${e.source}`)}))}baseShaderModules(e){const i=[],r=[];return i.push("instancing"),this.picking.type===Y.SINGLE&&i.push("picking"),(e.instanceAttributes||[]).find(a=>!!(a&&a.easing))&&i.push("frame"),{fs:r,vs:i}}childLayers(){return[]}destroy(){this.bufferManager&&(this.bufferManager.scene&&this.bufferManager.scene.removeLayer(this),this.bufferManager.removeFromScene(),this.bufferManager.destroy())}didUpdateProps(){}draw(){this.updateStreamLock();const e=this.getChangeList();e.length>0&&(this.needsViewDrawn=!0);let i,r,s;const a=this.diffManager;if(!a||!this.bufferManager)return;const o=a.processing,c=a.processor;if(!c){console.warn("A layer is atttempting to draw without a diff processor for analyzing changes.");return}c.incomingChangeList(e),this.bufferManager.incomingChangeList(e);for(let l=0,u=e.length;l<u;++l)i=e[l],r=i[0],s=this.bufferManager.getBufferLocations(r),o==null||o[i[1]](c,r,Object.values(i[2]),s),r.changes={};c.commit(),this.bufferManager.changesProcessed(),this.updateEasingManager(),this.updateUniforms()}updateEasingManager(){if(this.props.streamChanges){if(!this.streamChanges.stream||this.streamChanges.stream.length<=0){const e=this._easingManager.easingComplete;this._easingManager.easingComplete=new $e,Cn(()=>{e.resolve()},this.animationEndTime-this.surface.frameMetrics.currentTime)}}else{const e=this._easingManager.easingComplete;this._easingManager.easingComplete=new $e,Cn(()=>{e.resolve()},this.animationEndTime-this.surface.frameMetrics.currentTime)}}getNextStreamChanges(){let e;const{streamChanges:i={count:1e4,strategy:Gs.LINEAR}}=this.props,{stream:r=[],streamIndex:s}=this.streamChanges;switch(i.count===void 0&&(i.count=1e4),i.count<=0&&(i.count=Number.MAX_SAFE_INTEGER),i.strategy){case Gs.LINEAR:default:{e=r.slice(s,s+i.count),this.streamChanges.streamIndex+=i.count;break}}return this.streamChanges.stream&&this.streamChanges.streamIndex>=this.streamChanges.stream.length&&delete this.streamChanges.stream,e}updateStreamLock(){this.streamChanges.locked=!!(this.streamChanges.stream&&this.streamChanges.streamIndex<this.streamChanges.stream.length)}getChangeList(){let e;return this.streamChanges.locked?e=this.getNextStreamChanges():this.props.streamChanges?(this.streamChanges.streamIndex=0,this.streamChanges.locked=!0,this.streamChanges.stream=this.props.data.changeList,e=[],this.props.data.resolve(this.id)):(e=this.props.data.changeList,this.props.data.resolve(this.id)),this.updateStreamLock(),e}getInstanceObservableIds(e,i){const r={};for(let s=0,a=i.length;s<a;++s){_e.setObservableMonitor(!0),e[i[s]];const o=_e.getObservableMonitorIds(!0);o[0]!==void 0&&(r[i[s]]=o[0])}return _e.setObservableMonitor(!1),r}getMaterialOptions(){return{}}initShader(){return{instancing:!0,baseBufferGrowthRate:1e3,fs:"${import: no-op}",instanceAttributes:[],uniforms:[],vertexAttributes:[],vertexCount:0,vs:"${import: no-op}"}}managesInstance(e){return de(this.bufferManager)&&this.bufferManager.managesInstance(e)}getLayerBufferType(e,i,r,s){let a=ce.UNIFORM,o=0;if(this._bufferType!==void 0)return this._bufferType;if(N.HARDWARE_INSTANCING){for(let c=0,l=r.length;c<l;++c){const u=r[c];o+=Math.ceil(u.size/4)}for(let c=0,l=s.length;c<l;++c){const u=s[c];o+=Math.ceil(iu[u.size||1]/4)}if(o>N.MAX_VERTEX_ATTRIBUTES){o=0;for(let c=0,l=s.length;c<l;++c){const u=s[c];o=Math.max(o,u.block||0)}for(let c=0,l=r.length;c<l;++c){const u=r[c];o+=Math.ceil(u.size/4)}o<N.MAX_VERTEX_ATTRIBUTES&&(a=i.instancing===!1?ce.VERTEX_ATTRIBUTE_PACKING:ce.INSTANCE_ATTRIBUTE_PACKING,Kc(`Performance Issue (Moderate):
            Layer %o is utilizing too many vertex attributes and is now using vertex packing.
            Max Vertex units %o
            Used Vertex units %o
            Instance Attributes %o
            Vertex Attributes %o`,this.id,N.MAX_VERTEX_ATTRIBUTES,o,s,r))}else a=i.instancing===!1?ce.VERTEX_ATTRIBUTE:ce.INSTANCE_ATTRIBUTE}return a===ce.UNIFORM&&(Kc(`Performance Issue (High):
        Layer %o is utilizing too many vertex attributes and is now using a uniform buffer.
        Max Vertex units %o
        Used Vertex units %o
        Instance Attributes %o
        Vertex Attributes %o`,this.id,N.MAX_VERTEX_ATTRIBUTES,o,s,r),a=ce.UNIFORM),this.setBufferType(a),a}makeLayerBufferManager(e,i,r){switch(this.getLayerBufferType(e,r,this.shaderIOInfo.vertexAttributes,this.shaderIOInfo.instanceAttributes)){case ce.INSTANCE_ATTRIBUTE:{this.setBufferManager(new kd(this,i));break}case ce.INSTANCE_ATTRIBUTE_PACKING:{this.setBufferManager(new Gd(this,i));break}case ce.VERTEX_ATTRIBUTE:{this.setBufferManager(new s0(this,i));break}case ce.VERTEX_ATTRIBUTE_PACKING:{this.setBufferManager(new v0(this,i));break}default:{this.setBufferManager(new Vd(this,i));break}}}updateDiffHandlers(){(this.shaderIOInfo.instanceAttributes||[]).find(i=>!!(i&&i.easing))?this.picking.type===Y.SINGLE?(this.onDiffAdd=this.handleDiffAddWithPickingAndEasing,this.onDiffRemove=this.handleDiffRemoveWithPickingAndEasing):(this.onDiffAdd=this.handleDiffAddWithEasing,this.onDiffRemove=this.handleDiffRemoveWithEasing):this.picking.type===Y.SINGLE&&(this.onDiffAdd=this.handleDiffAddWithPicking,this.onDiffRemove=this.handleDiffRemoveWithPicking)}handleDiffAddWithEasing(e){e.easingId=this.easingId}handleDiffAddWithPicking(e){this.uidToInstance.set(e.uid,e)}handleDiffAddWithPickingAndEasing(e){this.uidToInstance.set(e.uid,e),e.easingId=this.easingId}handleDiffRemoveWithEasing(e){e.easing&&delete e.easing,delete e.easingId}handleDiffRemoveWithPicking(e){this.uidToInstance.delete(e.uid)}handleDiffRemoveWithPickingAndEasing(e){this.uidToInstance.delete(e.uid),e.easing&&delete e.easing,delete e.easingId}rebuildLayer(){if(this.willRebuildLayer=!0,this.children)for(let e=0,i=this.children.length;e<i;++e)this.children[e].rebuildLayer()}resolveChanges(e){const i=this.props.data.changeList;i.length>0&&(this.needsViewDrawn=!0),e||this.props.data.resolve(this.id);for(let r=0,s=i.length;r<s;++r)i[r][0].changes={};return i}setBufferManager(e){this._bufferManager?console.warn("You can not change a layer's buffer strategy once it has been instantiated."):(this._bufferManager=e,this.diffManager=new o0,this.diffManager.makeProcessor(this,e))}setBufferType(e){this._bufferType===void 0?this._bufferType=e:console.warn("You can not change a layers buffer strategy once it has been instantiated.")}shouldDrawView(e,i){for(const r in i)if(i[r]!==e[r])return!0;return!1}updateUniforms(){let e,i;for(let r=0,s=this.shaderIOInfo.uniforms.length;r<s;++r)e=this.shaderIOInfo.uniforms[r],i=e.update(e),e.materialUniforms.forEach(a=>a.data=i)}willUpdateProps(e){e.picking!==this.props.picking&&this.rebuildLayer(),e.ref!==this.props.ref&&this.props.ref&&(this.props.ref.easing=this.easingManager)}};let bt=ml;f(bt,"defaultProps",{});const rf=Ie("performance");class _a extends _i{constructor(e,i){super(i);f(this,"container",new Vs);f(this,"layerDiffs");f(this,"order");f(this,"surface");f(this,"viewDiffs");this.surface=e,this.init(i)}get layers(){return this.layerDiffs.items}get views(){return this.viewDiffs.items}init(e){if(!this.surface||!this.surface.gl)return;this.container=new Vs;const i=Cd(this.surface.gl);this.layerDiffs=new Zr({buildItem:async r=>{if(rf("Building layer",r.key),!this.surface)return null;const s=r.init[0],a=r.init[1],o=new s(this.surface,this,Object.assign({},s.defaultProps,a));if(o.initializer=r,o.props.data.sync(),o.parent=a.parent,a.parent&&(a.parent.children?a.parent.children.push(o):a.parent.children=[o]),!o.init(this.views))return console.warn("Error initializing layer:",a.key,"A layer was unable to be added to the surface. See previous warnings (if any) to determine why they could not be instantiated"),null;const c=o.childLayers();return this.layerDiffs.inline(c),o},destroyItem:async(r,s)=>(rf("Destroying layer",r.key),s.destroy(),!0),updateItem:async(r,s)=>{const a=r.init[1];if(s.willUpdateProps(a),a.data!==s.props.data&&a.data.sync(),s.shouldDrawView(s.props,a)&&(s.needsViewDrawn=!0),Object.assign(s.props,a),s.initializer.init[1]=s.props,s.didUpdateProps(),a.parent&&s.parent&&s.parent!==a.parent){const o=s.parent.children||[],c=o.indexOf(s)||-1;c>-1&&o.splice(c,1)}s.parent=a.parent,s.willRebuildLayer?(this.layerDiffs.rebuild(),s.willRebuildLayer=!1):this.layerDiffs.inline(s.childLayers())}}),this.viewDiffs=new Zr({buildItem:async r=>{if(!this.surface)return null;const s=new r.init[0](this,r.init[1]);return s.props.camera=s.props.camera||i.camera,s.pixelRatio=this.surface.pixelRatio,s.resource=this.surface.resourceManager,this.surface.userInputManager.waitingForRender=!0,s},destroyItem:async(r,s)=>!0,updateItem:async(r,s)=>{const a=r.init[1];s.willUpdateProps(a),s.shouldDrawView(s.props,a)&&(s.needsDraw=!0),Object.assign(s.props,a),s.didUpdateProps(),this.surface&&(this.surface.userInputManager.waitingForRender=!0)}}),this.update(e)}destroy(){delete this.container,this.layerDiffs.destroy(),this.viewDiffs.destroy()}removeLayer(e){if(this.layers){const i=this.layers.indexOf(e);if(i>=0){this.layers.splice(i,1);return}}}async update(e){this.order=e.order,await this.viewDiffs.diff(e.views),await this.layerDiffs.diff(e.layers),this.views.forEach(i=>i.createRenderTarget())}}f(_a,"DEFAULT_SCENE_ID","__default__");var lr=(n=>(n[n.COLOR=1]="COLOR",n[n.DEPTH=2]="DEPTH",n[n.STENCIL=4]="STENCIL",n))(lr||{});function Zc(n,t){const e=Object.assign(t,{key:t.key||"",viewport:t.viewport||{left:0,right:0,top:0,bottom:0}});return{get key(){return t.key||""},init:[n,e]}}const vl=class extends _i{constructor(e,i){super(i);f(this,"animationEndTime",0);f(this,"depth",0);f(this,"lastFrameTime",0);f(this,"needsDraw",!1);f(this,"optimizeRendering",!1);f(this,"_pixelRatio",1);f(this,"projection");f(this,"props");f(this,"resource");f(this,"renderTarget");f(this,"scene");this.scene=e,this.props=Object.assign({},vl.defaultProps||{},i)}get pixelRatio(){return this.props.pixelRatio??this._pixelRatio}set pixelRatio(e){this._pixelRatio=e}get screenBounds(){return this.projection.screenBounds}set screenBounds(e){this.projection.screenBounds=e}get viewBounds(){return this.projection.viewBounds}set viewBounds(e){this.projection.viewBounds=e}get clearFlags(){return this.props.clearFlags||[]}get order(){return this.props.order||0}getOutputTargets(){const{output:e}=this.props;let i=[];return e?(xi(e.buffers)||la(e.buffers)?i=[{outputType:H.COLOR,resource:e.buffers}]:Object.keys(e.buffers).forEach(r=>{const s=Number.parseFloat(r),a=e.buffers[s];a&&i.push({outputType:s,resource:a})}),i):null}getRenderTargets(){return this.renderTarget?[this.renderTarget]:[]}createRenderTarget(){this.renderTarget&&(Array.isArray(this.renderTarget)?this.renderTarget.forEach(p=>p.dispose()):this.renderTarget.dispose());const{output:e}=this.props,i=this.scene.surface;if(!e||!i)return;const r=new Set;for(let p=0,g=this.scene.layers.length;p<g;++p){const v=this.scene.layers[p].shaderIOInfo.fs.get(this);v&&v.outputTypes.forEach(b=>r.add(b))}const s=new Map,a=new bt(i,this.scene,{key:"",data:new pe}),o=new Ye({}),c=this.getOutputTargets()||[];for(let p=0,g=c.length;p<g;++p){const m=c[p],v=m.resource;if(r.has(m.outputType))if(xi(v)){const b=ts({key:m.resource.key});if(this.resource.request(a,o,b),!b.texture)throw console.warn("A view has a RenderTexture output target with key:",m.resource.key,"however, no RenderTexture was found for the key.","Please ensure you have a 'resource' specified for the Surface with the proper key","Also ensure the resource is made via createTexture()"),new Error(`Output target unable to be constructed for view ${this.id}`);s.set(m.outputType,b.texture)}else{const b=Nc({key:m.resource.key});if(this.resource.request(a,o,b),!b.colorBuffer)throw console.warn("A view has a ColorBuffer output target with key:",m.resource.key,"however, no ColorBuffer was found for the key.","Please ensure you have a 'resource' specified for the Surface with the proper key","Also ensure the resource is made via createColorBuffer()"),new Error(`Output target unable to be constructed for view ${this.id}`);s.set(m.outputType,b.colorBuffer)}}let l,u;s.forEach(p=>{var g,m,v;if(p instanceof se){if((l===void 0||u===void 0)&&(l=((g=p.data)==null?void 0:g.width)||0,u=((m=p.data)==null?void 0:m.height)||0),l===0||u===0)throw new Error("RenderTexture for View can NOT have a width or height of zero.");if(((v=p.data)==null?void 0:v.width)!==l||p.data.height!==u)throw new Error("When a view has multiple output targets: ALL RenderTextures and ColorBuffers that a view references MUST have the same dimensions")}else{if((l===void 0||u===void 0)&&(l=p.size[0]||0,u=p.size[1]||0),l===0||u===0)throw new Error("RenderTexture for View can NOT have a width or height of zero.");if(p.size[0]!==l||p.size[1]!==u)throw new Error("When a view has multiple output targets: ALL RenderTextures and ColorBuffers that a view references MUST have the same dimensions")}});let d;if(e.depth)if(xi(e.depth)){const p=ts({key:e.depth.key});if(this.resource.request(a,o,p),!p.texture)throw console.warn("A view has a depth buffer output target with key:",e.depth,"however, no RenderTexture was found for the key.","Please ensure you have a 'resource' specified for the Surface with the proper key","Also ensure the resource is made via createTexture()"),new Error(`Output target unable to be constructed for view ${this.id}`);d=p.texture}else if(la(e.depth)){const p=Nc({key:e.depth.key});if(this.resource.request(a,o,p),!p.colorBuffer)throw console.warn("A view has a depth buffer output target with key:",e.depth.key,"however, no ColorBuffer was found for the key.","Please ensure you have a 'resource' specified for the Surface with the proper key","Also ensure the resource is made via createColorBuffer()"),new Error(`Output target unable to be constructed for view ${this.id}`);d=p.colorBuffer}else d=h.GLSettings.RenderTarget.DepthBufferFormat.DEPTH_COMPONENT16;if(N.MRT){const p=[];s.forEach((g,m)=>p.push({buffer:g,outputType:m})),this.renderTarget=new Yn({buffers:{color:p,depth:d},retainTextureTargets:!0})}else throw new Error("MRT for non-MRT systems not supported yet.")}willUseView(){const e=this.getRenderTargets();this.props.screenScale&&(this.projection.screenScale=this.props.screenScale),e.some(r=>r.getBuffers().some(s=>!!s.buffer.destroyed))&&this.createRenderTarget()}shouldDrawView(e,i){for(const r in i)if(i[r]!==e[r])return!0;return!1}willUpdateProps(e){}didUpdateProps(){}};let Ni=vl;f(Ni,"defaultProps",{key:"",camera:On.makeOrthographic(),viewport:{left:0,right:0,top:0,bottom:0}});class sf extends Ni{constructor(){super(new _a(void 0,{key:"error",layers:[],views:[]}),{key:"error",viewport:{},camera:On.makeOrthographic()});f(this,"projection",new _u);this.screenBounds=new ie({x:0,y:0,width:100,height:100})}screenToWorld(e,i){return[0,0]}worldToScreen(e,i){return[0,0]}viewToWorld(e,i){return[0,0]}worldToView(e,i){return[0,0]}fitViewtoViewport(e,i){this.screenBounds=e}}const b0=1e3,w0=200,Dn=new sf;Dn.fitViewtoViewport(new ie({x:0,y:0,width:100,height:100}),new ie({x:0,y:0,width:100,height:100}));function T0(n,t){return t.d&&n.d?t.d.depth-n.d.depth:0}function Jc(n,t){return n.touch.identifier-t.touch.identifier}class af{constructor(t,e,i,r){f(this,"context");f(this,"eventManagers",[]);f(this,"quadTree");f(this,"surface");f(this,"eventCleanup",[]);f(this,"currentInteraction");f(this,"_waitingForRender",!0);f(this,"getViewsUnderPosition",t=>{if(!this.quadTree)return[];const e=this.quadTree.query(t);return e.sort(T0),e});f(this,"resize",()=>{this._waitingForRender=!0});this.context=t,this.surface=e,this.setControllers(i),this.addContextListeners(r)}get waitingForRender(){return this._waitingForRender}set waitingForRender(t){if(this._waitingForRender=t,!t){this.quadTree=new cd(0,0,0,0);const e=this.scenes,i=[];for(let r=0,s=e.length;r<s;++r){const a=e[r];for(let o=0,c=a.views.length;o<c;++o){const l=a.views[o];i.push(l.screenBounds)}}this.quadTree.addAll(i)}}get scenes(){return!this.surface||!this.surface.sceneDiffs?[]:this.surface.sceneDiffs.items}addContextListeners(t){this.addMouseContextListeners(t),this.addTouchContextListeners()}addMouseContextListeners(t){const e=this.context;if(bi(e))return;let i,r=!1;if(t){const s=a=>{const o=Ft(a,e),c=this.getViewsUnderPosition(o);if(c.length<=0)return;i={canClick:!1,currentPosition:o,deltaPosition:[0,0],previousPosition:o,start:o,startTime:Date.now(),startView:c[0].d,event:a,wheel:this.makeWheel(a),button:-1};const l=this.makeMouseInteraction(i);this.eventManagers.forEach(u=>{u.handleWheel(l)}),a.stopPropagation(),a.preventDefault()};"onwheel"in e&&(e.onwheel=s),"addEventListener"in e&&(e.addEventListener("DOMMouseScroll",s),this.eventCleanup.push(["DOMMouseScroll",s]))}e.onmouseleave=s=>{if(this.waitingForRender||!i)return;const a=Ft(s,e);i.deltaPosition=Ae(a,i.currentPosition),i.previousPosition=i.currentPosition,i.currentPosition=a;const o=this.makeMouseInteraction(i);this.eventManagers.forEach(c=>{c.handleMouseOut(o)})},e.onmousemove=s=>{if(this.waitingForRender)return;const a=Ft(s,e);if(!i){const c=this.getViewsUnderPosition(a);i={canClick:!1,currentPosition:a,deltaPosition:[0,0],previousPosition:a,start:a,startTime:Date.now(),startView:c[0].d,event:s,wheel:this.makeWheel(),button:-1}}i.deltaPosition=Ae(a,i.currentPosition),i.previousPosition=i.currentPosition,i.currentPosition=a,i.canClick=!1;const o=this.makeMouseInteraction(i);this.eventManagers.forEach(c=>{c.handleMouseMove(o)}),r=!0},e.onmousedown=s=>{if(this.waitingForRender)return;const a=Ft(s,e),o=this.getViewsUnderPosition(a);if(o.length<=0)return;i={canClick:!0,currentPosition:a,deltaPosition:[0,0],previousPosition:a,start:a,startTime:Date.now(),startView:o[0].d,event:s,wheel:this.makeWheel(),button:s.button};const c=this.makeMouseInteraction(i);this.eventManagers.forEach(u=>{u.handleMouseDown(c)}),s.stopPropagation(),document.onmousemove=u=>{if(!i)return;if(!r){const p=Ft(u,e);i.deltaPosition=Ae(p,i.currentPosition),i.previousPosition=i.currentPosition,i.currentPosition=p,i.canClick=!1}const d=this.makeMouseInteraction(i);this.eventManagers.forEach(p=>{p.handleDrag(d)}),u.preventDefault(),u.stopPropagation(),r=!1},document.onmouseup=u=>{document.onmousemove=null,document.onmouseup=null,document.onmouseover=null,i=void 0},document.onmouseover=u=>{if(!i)return;const d=Ft(u,e);i.deltaPosition=Ae(d,i.currentPosition),i.previousPosition=i.currentPosition,i.currentPosition=d;const p=this.makeMouseInteraction(i);this.eventManagers.forEach(g=>{g.handleMouseOver(p)}),u.stopPropagation()},e.onmouseup=u=>{if(!i)return;const d=Ft(u,e);i.deltaPosition=Ae(d,i.currentPosition),i.previousPosition=i.currentPosition,i.currentPosition=d,i.button=u.button;const p=this.makeMouseInteraction(i);this.eventManagers.forEach(g=>{g.handleMouseUp(p)}),i.canClick&&Date.now()-i.startTime<b0&&this.eventManagers.forEach(g=>{g.handleClick(p)}),i=void 0};const l=e;l.onselectstart!==void 0?l.onselectstart=function(){return!1}:e.addEventListener("selectstart",function(){s.preventDefault()})}}addTouchContextListeners(){const t=this.context;if(bi(t))return;const e=new Map,i=new Map;function r(u){return u.map(d=>d.touch)}function s(u){return u.reduce((d,p)=>p.touch.startTime>d.touch.startTime?p:d,u[0])}const a={center:u=>u.length<=0?[0,0]:this.getTouchCenter(r(u)),centerDelta:u=>{if(u.length<=0)return[0,0];const d=r(u),p=this.getTouchCenter(d,m=>m.previousPosition),g=this.getTouchCenter(d);return Ae(g,p)},centerStart:u=>{if(u.length<=0)return[0,0];const d=s(u).touch;return this.getTouchCenter(r(u),p=>p===d?p.start:p.startRelative.get(d)||[0,0])},id:u=>r(u).sort(Jc).map(p=>p.touch.identifier).join("_"),rotation:u=>{if(u.length<=0)return 0;const d=r(u),p=this.getTouchCenter(d);return this.getAverageAngle(d,p)},rotationDelta:u=>{if(u.length<=0)return 0;const d=r(u),p=this.getTouchCenter(d,b=>b.previousPosition),g=this.getAverageAngle(d,p,b=>b.previousPosition),m=this.getTouchCenter(d);return this.getAverageAngle(d,m)-g},rotationStart:u=>{if(u.length<=0)return 0;const d=s(u).touch,p=r(u),g=this.getTouchCenter(p,m=>m===d?m.start:m.startRelative.get(d)||[0,0]);return this.getAverageAngle(p,g,m=>m===d?m.start:m.startRelative.get(d)||[0,0])},spread:u=>{if(u.length<=0)return 0;const d=r(u),p=this.getTouchCenter(d);return this.getAverageDistance(d,p)},spreadDelta:u=>{if(u.length<=0)return 0;const d=r(u),p=this.getTouchCenter(d,b=>b.previousPosition),g=this.getAverageDistance(d,p,b=>b.previousPosition),m=this.getTouchCenter(d);return this.getAverageDistance(d,m)-g},spreadStart:u=>{if(u.length<=0)return 0;const d=s(u).touch,p=r(u),g=this.getTouchCenter(p,m=>m===d?m.start:m.startRelative.get(d)||[0,0]);return this.getAverageDistance(p,g,m=>m===d?m.start:m.startRelative.get(d)||[0,0])}};t.ontouchstart=u=>{u.preventDefault(),u.stopPropagation();const d=this.getTouches(u),p=[],g=[];for(let m=0,v=d.length;m<v;++m){const b=d[m],T=e.get(b.identifier);if(T)p.push(T);else{const w=Ft(b),E=this.getViewsUnderPosition(w);if(E.length<=0)continue;const x=E[0].d,_={canTap:!0,currentPosition:w,deltaPosition:[0,0],startTime:Date.now(),start:w,startView:x,previousPosition:w,startRelative:new Map,touch:b};e.set(b.identifier,_),g.push(_)}}if(g.length>0){const m=g.concat(p),v=[];for(let T=0,w=g.length;T<w;++T){const E=g[T];for(let _=0,I=m.length;_<I;++_){const M=m[_];E!==M&&M.startRelative.set(E,M.currentPosition)}const x=this.makeSingleTouchInteraction(E);v.push(x),i.set(E.touch.identifier,x)}const b={touches:v,allTouches:m.map(T=>i.get(T.touch.identifier)).filter(de),multitouch:a};this.eventManagers.forEach(T=>{T.handleTouchDown(b)})}document.ontouchend=m=>{o.call(document,m),document.ontouchend=null,document.ontouchcancel=null,document.ontouchmove=null},document.ontouchcancel=m=>{l.call(document,m),document.ontouchend=null,document.ontouchcancel=null,document.ontouchmove=null},document.ontouchmove=c};const o=t.ontouchend=u=>{u.stopPropagation(),u.preventDefault();const d=this.getTouches(u,"changed"),p=Array.from(i.values()),g=[];for(let m=0,v=d.length;m<v;++m){const b=d[m],T=e.get(b.identifier);if(T){if(T.canTap&&Date.now()-T.startTime<w0){const E={touches:[this.makeSingleTouchInteraction(T)],allTouches:p,multitouch:a};this.eventManagers.forEach(x=>{x.handleTap(E)})}g.push(T),e.delete(b.identifier),i.delete(b.identifier)}}if(g.length>0){const v={touches:g.map(b=>this.makeSingleTouchInteraction(b)),allTouches:p,multitouch:a};this.eventManagers.forEach(b=>{b.handleTouchUp(v)})}},c=t.ontouchmove=u=>{u.stopPropagation(),u.preventDefault();const d=this.getTouches(u),p=[],g=[];for(let m=0,v=d.length;m<v;++m){const b=d[m],T=e.get(b.identifier);if(T){const w=Ft(b),E=Ae(w,T.currentPosition);if(Hn(E)<=0){g.push(T),Object.assign(T,{currentPosition:w,deltaPosition:E,previousPosition:T.currentPosition,touch:b});continue}p.push(T),Object.assign(T,{canTap:!1,currentPosition:w,deltaPosition:E,previousPosition:T.currentPosition,touch:b})}}if(p.length>0){const m=p.concat(g),b={touches:p.map(T=>this.makeSingleTouchInteraction(T)),allTouches:m.map(T=>i.get(T.touch.identifier)).filter(de),multitouch:a};this.eventManagers.forEach(T=>{T.handleTouchDrag(b)})}},l=t.ontouchcancel=u=>{u.stopPropagation(),u.preventDefault();const d=this.getTouches(u,"changed"),p=Array.from(i.values()),g=[];for(let m=0,v=d.length;m<v;++m){const b=d[m],T=e.get(b.identifier);T&&(g.push(T),e.delete(b.identifier),i.delete(b.identifier))}if(g.length>0){const v={touches:g.map(b=>this.makeSingleTouchInteraction(b)),allTouches:p,multitouch:a};this.eventManagers.forEach(b=>{b.handleTouchCancelled(v)})}}}getAverageDistance(t,e,i){let r=0;if(t.length<=0)return r;i||(i=s=>s.currentPosition);for(let s=0,a=t.length;s<a;++s){const o=t[s];r+=Hn(Ae(i(o),e))}return r/t.length}getAverageAngle(t,e,i){let r=0;if(t.length<=0)return r;i||(i=s=>s.currentPosition);for(let s=0,a=t.length;s<a;++s){const o=t[s],c=Ae(i(o),e);let l=Math.atan2(c[1],c[0]);l<0&&(l+=Math.PI*2),r+=l}return r/t.length}getTouchCenter(t,e){let i=[0,0];if(t.length<=0)return i;e||(e=r=>r.currentPosition);for(let r=0,s=t.length;r<s;++r){const a=t[r],o=e(a);i=xn(i,o)}return Ce(i,1/t.length)}getTouches(t,e){const i=new Map;if(t.touches&&t.touches.length>0&&(!e||e==="touches"))for(let r=0,s=t.touches.length;r<s;++r){const a=t.touches.item(r);a&&i.set(a.identifier,a)}if(t.changedTouches&&t.changedTouches.length>0&&(!e||e==="changed"))for(let r=0,s=t.changedTouches.length;r<s;++r){const a=t.changedTouches.item(r);a&&i.set(a.identifier,a)}if(t.targetTouches&&t.targetTouches.length>0&&(!e||e==="target"))for(let r=0,s=t.targetTouches.length;r<s;++r){const a=t.targetTouches.item(r);a&&i.set(a.identifier,a)}return Array.from(i.values())}getView(t){const e=this.scenes;for(let i=0,r=e.length;i<r;++i){const a=e[i].viewDiffs.getByKey(t);if(a)return a}return null}makeMouseInteraction(t){const e=this.getViewsUnderPosition(t.currentPosition);let i=e[0]&&e[0].d;i||(i=Dn);const r=this.getViewsUnderPosition(t.start);let s=t.startView;s||(s=Dn);const a={canvas:bi(this.context)?void 0:this.context,mouse:t,screen:{position:t.currentPosition},start:{position:s.projection.screenToView(t.start),view:s,views:r.map(o=>(o.d||(o.d=Dn),{position:o.d.projection.screenToView(t.start),view:o.d}))},target:{position:i.projection.screenToView(t.currentPosition),view:i,views:e.map(o=>(o.d||(o.d=Dn),{position:o.d.projection.screenToView(t.currentPosition),view:o.d}))}};return this.currentInteraction=a,a}makeSingleTouchInteraction(t){const e=t.currentPosition,i=this.getViewsUnderPosition(e);let r=i[0]&&i[0].d;r||(r=Dn);let s=t.startView;s||(s=Dn);const a={canvas:bi(this.context)?void 0:this.context,touch:t,screen:{position:e},start:{position:s.projection.screenToView(t.start),view:s,views:this.getViewsUnderPosition(t.start).map(o=>(o.d||(o.d=Dn),{position:o.d.projection.screenToView(t.start),view:o.d}))},target:{position:r.projection.screenToView(e),view:r,views:i.map(o=>(o.d||(o.d=Dn),{position:o.d.projection.screenToView(e),view:o.d}))}};return this.currentInteraction=a,a}makeMultiTouchInteractions(t,e){t.sort(Jc);const i=this.allTouchCombinations(t);for(let r=0,s=i.length;r<s;++r){const a=i[r],o=a.map(l=>l.touch.identifier).join("_");let c=e.get(o);if(!c){const l=this.getTouchCenter(a);c={touches:a,averageSpreadDelta:0,startCenter:l,currentCenter:l,currentRotation:this.getAverageAngle(a,l),centerDelta:[0,0],rotationDelta:0},e.set(o,c)}}}updateMultiTouchInteractions(t,e){t.sort(Jc);const i=this.allTouchCombinations(t);for(let r=0,s=i.length;r<s;++r){const a=i[r],o=a.map(l=>l.touch.identifier).join("_"),c=e.get(o);if(c){const l=this.getTouchCenter(a),u=this.getAverageAngle(a,l);c.centerDelta=Ae(l,c.currentCenter),c.currentCenter=l,c.rotationDelta=u-c.currentRotation,c.currentRotation=u}}}allTouchCombinations(t){const e=[],i=t.length,r=1<<i;for(let s=1;s<r;s++){const a=[];for(let o=0;o<i;o++)s&1<<o&&a.push(t[o]);e.push(a)}return e}makeWheel(t){if(!t)return{delta:[0,0]};const e=ac(t);return{delta:[e.pixelX,e.pixelY]}}setControllers(t){this.eventManagers=t;for(const e of this.eventManagers)e.setUserInputManager(this)}destroy(){delete this.quadTree,bi(this.context)||(this.context.onmousedown=null,this.context.onmousemove=null,this.context.onmouseleave=null);const t=this.context;t.onmousewheel&&(t.onmousewheel=null),this.eventCleanup.forEach(e=>{this.context.removeEventListener(e[0],e[1])})}}class el extends ht{constructor(e,i=!1){super();f(this,"handlers");f(this,"preserveQueueMouse",[]);f(this,"singleQueueMouse",new Map);f(this,"preserveQueueTouch",[]);f(this,"singleQueueTouch",new Map);f(this,"preserveEvents",!1);this.handlers=new bs(e),this.preserveEvents=i}dequeue(){try{this.preserveEvents?(this.preserveQueueMouse.forEach(e=>{e[0](e[1])}),this.preserveQueueTouch.forEach(e=>{e[0](e[1])})):(this.singleQueueMouse.forEach((e,i)=>{i(e)}),this.singleQueueTouch.forEach((e,i)=>{i(e)}))}catch(e){console.error("Queued events had errors. Further events aborted"),e instanceof Error&&console.error(e.stack||e.message)}this.preserveQueueMouse=[],this.singleQueueMouse.clear(),this.preserveQueueTouch=[],this.singleQueueTouch.clear()}handleMouseDown(e){this.preserveEvents?this.preserveQueueMouse.push([this.handlers.handleMouseDown,e]):this.singleQueueMouse.set(this.handlers.handleMouseDown,e)}handleMouseUp(e){this.preserveEvents?this.preserveQueueMouse.push([this.handlers.handleMouseUp,e]):this.singleQueueMouse.set(this.handlers.handleMouseUp,e)}handleMouseOver(e){this.preserveEvents?this.preserveQueueMouse.push([this.handlers.handleMouseOver,e]):this.singleQueueMouse.set(this.handlers.handleMouseOver,e)}handleMouseOut(e){this.preserveEvents?this.preserveQueueMouse.push([this.handlers.handleMouseOut,e]):this.singleQueueMouse.set(this.handlers.handleMouseOut,e)}handleMouseMove(e){this.preserveEvents?this.preserveQueueMouse.push([this.handlers.handleMouseMove,e]):this.singleQueueMouse.set(this.handlers.handleMouseMove,e)}handleClick(e){this.preserveEvents?this.preserveQueueMouse.push([this.handlers.handleClick,e]):this.singleQueueMouse.set(this.handlers.handleClick,e)}handleDrag(e){this.preserveEvents?this.preserveQueueMouse.push([this.handlers.handleDrag,e]):this.singleQueueMouse.set(this.handlers.handleDrag,e)}handleWheel(e){this.preserveEvents?this.preserveQueueMouse.push([this.handlers.handleWheel,e]):this.singleQueueMouse.set(this.handlers.handleWheel,e)}handleTouchCancelled(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleTouchCancelled,e]):this.singleQueueTouch.set(this.handlers.handleTouchCancelled,e)}handleTouchDown(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleTouchDown,e]):this.singleQueueTouch.set(this.handlers.handleTouchDown,e)}handleTouchUp(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleTouchUp,e]):this.singleQueueTouch.set(this.handlers.handleTouchUp,e)}handleTouchOut(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleTouchOut,e]):this.singleQueueTouch.set(this.handlers.handleTouchOut,e)}handleTouchDrag(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleTouchDrag,e]):this.singleQueueTouch.set(this.handlers.handleTouchDrag,e)}handleTap(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleTap,e]):this.singleQueueTouch.set(this.handlers.handleTap,e)}handleDoubleTap(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleDoubleTap,e]):this.singleQueueTouch.set(this.handlers.handleDoubleTap,e)}handleLongTouch(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleLongTouch,e]):this.singleQueueTouch.set(this.handlers.handleLongTouch,e)}handleLongTap(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleLongTap,e]):this.singleQueueTouch.set(this.handlers.handleLongTap,e)}handlePinch(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handlePinch,e]):this.singleQueueTouch.set(this.handlers.handlePinch,e)}handleSpread(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleSpread,e]):this.singleQueueTouch.set(this.handlers.handleSpread,e)}handleTouchRotate(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleTouchRotate,e]):this.singleQueueTouch.set(this.handlers.handleTouchRotate,e)}handleSwipe(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleSwipe,e]):this.singleQueueTouch.set(this.handlers.handleSwipe,e)}}const of=`// These are projection methods utilizing the simpler camera 2d approach.
// This assumes we have a 3D camera projection which should be preferably orthographic layered with simpler 2D camera
// controls for manipulating the 2D world.
vec3 cameraSpace(vec3 world) {
  return (world + cameraOffset) * cameraScale2D;
}

vec3 cameraSpaceSize(vec3 worldSize) {
  return worldSize * cameraScale2D;
}

vec4 clipSpace(vec3 world) {
  return (viewProjection) * vec4(cameraSpace(world), 1.0);
}

vec4 clipSpaceSize(vec3 worldSize) {
  return (viewProjection) * vec4(cameraSpaceSize(worldSize), 0.0);
}
`,y0=Ks.immediate(0);class Bn{constructor(t,e){f(this,"_id",z());f(this,"animation",Ks.immediate(0));f(this,"animationEndTime",0);f(this,"camera");f(this,"offsetBroadcastTime",0);f(this,"scaleBroadcastTime",0);f(this,"_offset",[0,0,0]);f(this,"startOffset",[0,0,0]);f(this,"startOffsetTime",0);f(this,"offsetEndTime",0);f(this,"_scale",[1,1,1]);f(this,"startScale",[1,1,1]);f(this,"startScaleTime",0);f(this,"scaleEndTime",0);f(this,"surface");f(this,"onViewChange");f(this,"needsBroadcast",!1);this.camera=t,e&&(this._offset=st(e.offset||this._offset),this._scale=st(e.scale||this._scale))}get id(){return this._id}broadcast(t){this.offset,this.scale,this.needsBroadcast&&(this.needsBroadcast=!1,this.onViewChange&&this.onViewChange(this.camera,t))}centerOn(t,e){var o;const i=(o=this.surface)==null?void 0:o.getViewSize(t);if(!i)return;const r=[i.width/2,i.height/2,0],s=Pt(e,yr(r,this._scale)),a=this.animation;this.setOffset(st(this.offset)),this.animation=y0,this.setOffset(at(s,-1)),this.animation=a}getCurrentTime(){return this.surface?this.surface.frameMetrics.currentTime:0}getOffset(){return this._offset}getScale(){return this._scale}get offset(){const t=this.getCurrentTime();return this.onViewChange&&this.offsetBroadcastTime<this.offsetEndTime&&(this.offsetBroadcastTime=t,this.needsBroadcast=!0),this.animation.cpu(this.startOffset,this._offset,(t-this.startOffsetTime)/this.animation.duration)}setId(t){this._id=t,this.camera.needsViewDrawn=!0}setOffset(t){this.startOffset=st(this.offset),this._offset=st(t),this.startOffsetTime=this.getCurrentTime(),this.offsetEndTime=this.startOffsetTime+this.animation.duration,this.updateEndTime(),this.camera.needsViewDrawn=!0,this.onViewChange&&(this.offsetBroadcastTime=this.startOffsetTime,this.needsBroadcast=!0)}get scale(){const t=this.getCurrentTime();return this.onViewChange&&this.scaleBroadcastTime<this.scaleEndTime&&(this.scaleBroadcastTime=t,this.needsBroadcast=!0),this.animation.cpu(this.startScale,this._scale,(t-this.startScaleTime)/this.animation.duration)}setViewChangeHandler(t){this.onViewChange=t}setScale(t){this.startScale=st(this.scale),this._scale=st(t),this.startScaleTime=this.getCurrentTime(),this.scaleEndTime=this.startScaleTime+this.animation.duration,this.updateEndTime(),this.camera.needsViewDrawn=!0,this.onViewChange&&(this.scaleBroadcastTime=this.startScaleTime,this.needsBroadcast=!0)}resolve(){this.camera.needsViewDrawn=!1,this.needsBroadcast=!1}update(){this.camera.needsViewDrawn=!0}updateEndTime(){this.animationEndTime=Math.max(this.scaleEndTime,this.offsetEndTime)}}class hn extends On{constructor(e){super({left:-100,right:100,top:-100,bottom:100,near:-100,far:1e5,type:Ln.ORTHOGRAPHIC});f(this,"_control2D");this.control2D=new Bn(this,e)}get control2D(){return this._control2D}set control2D(e){this._control2D=e}get scale2D(){return this.control2D.scale}get offset(){return this.control2D.offset}}class cf{sortInstanceAttributes(t,e){return t.resource&&!e.resource||t.easing&&!e.easing?-1:1}sortVertexAttributes(t,e){return 1}sortUniforms(t,e){return 1}}class lf extends el{constructor(){super({handleClick:async e=>{var i,r;this.enablePicking(),await((i=this.willRenderResolver)==null?void 0:i.promise),this.enablePicking(),await((r=this.didRenderResolver)==null?void 0:r.promise),this.handleInteraction(e,(s,a)=>{var o;(o=s.interactions)==null||o.handleMouseClick(a,e)})},handleTap:async e=>{var i,r;this.enablePicking(),await((i=this.willRenderResolver)==null?void 0:i.promise),this.enablePicking(),await((r=this.didRenderResolver)==null?void 0:r.promise),e.touches.forEach(s=>{this.handleInteraction(s,(a,o)=>{var c;(c=a.interactions)==null||c.handleTap(o,e,s)})})},handleDrag:async e=>{var i;await((i=this.willRenderResolver)==null?void 0:i.promise),this.handleInteraction(e,(r,s)=>{var a;(a=r.interactions)==null||a.handleMouseDrag(s,e)})},handleMouseDown:async e=>{var i;this.enablePicking(),await((i=this.willRenderResolver)==null?void 0:i.promise),this.handleInteraction(e,(r,s)=>{var a;return(a=r.interactions)==null?void 0:a.handleMouseDown(s,e)})},handleTouchDown:async e=>{var i;this.enablePicking(),await((i=this.willRenderResolver)==null?void 0:i.promise),e.touches.forEach(r=>{this.handleInteraction(r,(s,a)=>{var o;return(o=s.interactions)==null?void 0:o.handleTouchDown(a,e,r)})})},handleMouseUp:async e=>{var i;await((i=this.willRenderResolver)==null?void 0:i.promise),this.handleInteraction(e,(r,s)=>{var a;return(a=r.interactions)==null?void 0:a.handleMouseUp(s,e)})},handleTouchUp:async e=>{var i;await((i=this.willRenderResolver)==null?void 0:i.promise),e.touches.forEach(r=>{this.handleInteraction(r,(s,a)=>{var o;return(o=s.interactions)==null?void 0:o.handleTouchUp(a,e,r)})})},handleMouseOut:async e=>{var i;await((i=this.willRenderResolver)==null?void 0:i.promise),this.isOver.forEach(r=>{this.handleView(r,(s,a)=>{var o;return(o=s.interactions)==null?void 0:o.handleMouseOut(a,e)})}),this.isOver.clear()},handleTouchOut:async e=>{var i;await((i=this.willRenderResolver)==null?void 0:i.promise),e.touches.forEach(r=>{ha(this.isTouchOver,r.touch.touch.identifier,new Set).forEach(a=>{this.handleView(a,(o,c)=>{var l;return(l=o.interactions)==null?void 0:l.handleTouchOut(c,e,r)})}),this.isOver.clear()})},handleMouseMove:async e=>{var s;this.enablePicking(),await((s=this.willRenderResolver)==null?void 0:s.promise);const i=this.handleInteraction(e,(a,o)=>{var c;return(c=a.interactions)==null?void 0:c.handleMouseMove(o,e)}),r=new Set;i.forEach(a=>r.add(a)),this.isOver.forEach(a=>{r.has(a)||this.handleView(a,(o,c)=>{var l;return(l=o.interactions)==null?void 0:l.handleMouseOut(c,e)})}),r.forEach(a=>{this.isOver.has(a)||this.handleView(a,(o,c)=>{var l;return(l=o.interactions)==null?void 0:l.handleMouseOver(c,e)})}),this.isOver=r},handleTouchDrag:async e=>{var i;this.enablePicking(),await((i=this.willRenderResolver)==null?void 0:i.promise),e.touches.forEach(r=>{const s=this.handleInteraction(r,(c,l)=>{var u;return(u=c.interactions)==null?void 0:u.handleTouchMove(l,e,r)}),a=new Set;s.forEach(c=>a.add(c));const o=ni(this.isTouchOver,r.touch.touch.identifier,new Set);o.forEach(c=>{a.has(c)||this.handleView(c,(l,u)=>{var d;return(d=l.interactions)==null?void 0:d.handleTouchOut(u,e,r)})}),a.forEach(c=>{o.has(c)||this.handleView(c,(l,u)=>{var d;return(d=l.interactions)==null?void 0:d.handleTouchOver(u,e,r)})}),this.isTouchOver.set(r.touch.touch.identifier,a)})}});f(this,"isOver",new Set);f(this,"isTouchOver",new Map);f(this,"willRenderResolver");f(this,"didRenderResolver")}get scenes(){return!this.surface||!this.surface.sceneDiffs?[]:this.surface.sceneDiffs.items}enablePicking(){this.surface&&this.surface.enableOptimizedOutput(H.PICKING)}willRender(){var e;for(let i=0,r=this.scenes.length;i<r;++i){const s=this.scenes[i];for(let a=0,o=s.layers.length;a<o;++a)(e=s.layers[a].interactions)==null||delete e.colorPicking}this.willRenderResolver&&this.willRenderResolver.resolve(),this.willRenderResolver=new $e,this.dequeue()}async didRender(){this.didRenderResolver&&this.didRenderResolver.resolve(),this.didRenderResolver=new $e}getSceneViewsUnderMouse(e){const i=new Map;for(let r=0,s=this.scenes.length;r<s;++r){const a=this.scenes[r];for(let o=0,c=a.views.length;o<c;++o){const l=a.views[o];i.set(l.id,l)}}return e.target.views.map(r=>i.get(r.view.id)).filter(de)}handleInteraction(e,i){const r=this.getSceneViewsUnderMouse(e);for(let s=0,a=r.length;s<a;++s){const o=r[s];this.handleView(o,i)}return r}handleView(e,i){for(let r=0,s=e.scene.layers.length;r<s;++r){const a=e.scene.layers[r];a.picking&&a.picking.type!==Y.NONE&&i(a,e)}}}class E0{rawVertex(t){return t}rawFragment(t){return t}}class _0 extends E0{vertex(t){let e=Jr(t);return N.SHADERS_3_0?(e=e.replace(/\s+varying\s+/g,`
out `),e=e.replace(/(texture2D(\s+)\(|texture2D\()/g,"texture(")):(e=e.replace(/^#version 300 es/g,""),e=e.replace(/\s+out\s+/g,`
varying `)),e}fragment(t){let e=Jr(t);if(N.SHADERS_3_0){if(e=e.replace(/\s+varying\s+/g,`
in `),e=e.replace(/(texture2D(\s+)\(|texture2D\()/g,"texture("),e.match(/gl_FragColor/g)&&(e=e.replace(/gl_FragColor/g,"_FragColor"),!e.match("out vec4 _FragColor"))){const i=e.split(`
`);i.splice(3,0,"layout(location = 0) out vec4 _FragColor;"),e=i.join(`
`)}}else e=e.replace(/^#version 300 es/g,""),e=e.replace(/\s+in\s+/g,`
varying `);return e}}function x0(n,t,e,i,r){const s={view:n,allColors:[],colorData:e,dataHeight:r,dataWidth:i,mouse:t,nearestColor:0,nearestColorBytes:[0,0,0,0]},a=new Map;let o=0;const c=i/2,l=r/2;let u=0,d=[0,0,0,0],p=Number.MAX_SAFE_INTEGER;for(let g=0;g<r;++g)for(let m=0;m<i;++m){const v=e[o],b=e[o+1],T=e[o+2];o+=4;const w=v<<16|b<<8|T;if(a.set(w,!0),w!==0){const E=m-c,x=g-l,_=E*E+x*x;_<p&&(p=_,u=w,d=[v,b,T,255])}}return s.allColors=Array.from(a.keys()),s.nearestColor=u,s.nearestColorBytes=d,s}class R0{constructor(t){f(this,"surface");f(this,"pickingRenderTargets",new Map);this.surface=t.surface}analyzePickedPixels(t,e){if(e.optimizeRendering)return;const i=wr(Ce(t,this.surface.pixelRatio),e.projection.screenScale),r=5,s=5,a=4,o=new Uint8Array(r*s*a);this.surface.renderer.readPixels(Math.floor(i[0]-r/2),Math.floor(i[1]-s/2),r,s,o);const c=x0(e,[i[0]-e.screenBounds.x,i[1]-e.screenBounds.y],o,r,s);for(let l=0,u=e.scene.layers.length;l<u;++l){const d=e.scene.layers[l];d.picking.type===Y.SINGLE&&(d.interactions.colorPicking=c)}}decodePicking(){const t=this.surface.getCurrentInteraction();if(!t)return;const e=t.screen.position,i=t.target.views.map(s=>s.view),r=new Set;this.pickingRenderTargets.forEach((s,a)=>{const o=s.getBuffers()[0].buffer;o instanceof se&&(!o.gl||o.destroyed)&&(s.dispose(),r.add(a))}),r.forEach(s=>this.pickingRenderTargets.delete(s)),i.forEach(s=>{let a=this.pickingRenderTargets.get(s);if(a||s.getRenderTargets().forEach(l=>{l.gl&&l.getBuffers().forEach(u=>{if(u.outputType===H.PICKING){if(u.buffer instanceof se&&u.buffer.generateMipMaps&&De("decode-picking-error",()=>{console.warn("The Texture you provided as the target for color picking has generateMipMaps enabled. This can cause accuracy issues and may make your picking experience poor.")}),a=new Yn({buffers:{color:u}}),a.width===0||a.height===0){a=void 0;return}this.pickingRenderTargets.set(s,a)}})}),!a)return;const o=this.surface.renderer.state.currentRenderTarget;let c=!1;o?(Array.isArray(o)||o.getBuffers()[0].buffer!==a.getBuffers()[0].buffer)&&(c=!0):c=!0,c&&this.surface.renderer.setRenderTarget(a),this.analyzePickedPixels(e,s)})}}const uf=()=>[new Bd,new Ud,new Pd],hf=()=>[{type:he.COLOR_BUFFER,manager:new zg},{type:he.TEXTURE,manager:new vd},{type:he.ATLAS,manager:new md({})},{type:he.FONT,manager:new Sd}],df=()=>[new _0],A0=[0,0,0,0];function tl(n,t){return(n.order||Number.MAX_SAFE_INTEGER)-(t.order||Number.MAX_SAFE_INTEGER)}class ff{constructor(t){f(this,"context");f(this,"commands",new R0({surface:this}));f(this,"frameMetrics",{currentFrame:0,currentTime:Date.now()|0,frameDuration:1e3/60,previousTime:Date.now()|0});f(this,"isBufferingResources",!1);f(this,"ioExpanders",[]);f(this,"shaderTransforms",[]);f(this,"optimizedOutputs",new Set([H.PICKING]));f(this,"ioSorting",new cf);f(this,"userInputManager");f(this,"pixelRatio",window.devicePixelRatio);f(this,"renderer");f(this,"resourceManager");f(this,"enabledOptimizedOutputs",new Set);f(this,"viewDrawDependencies",new Map);f(this,"ready");f(this,"readyResolver");f(this,"resourceDiffs",new Zr({buildItem:async t=>(await this.resourceManager.initResource(t),{id:t.key}),destroyItem:async(t,e)=>(await this.resourceManager.destroyResource(t),!0),updateItem:async(t,e)=>{await this.resourceManager.updateResource(t)}}));f(this,"sceneDiffs",new Zr({buildItem:async t=>new _a(this,{key:t.key,views:t.views,layers:t.layers}),destroyItem:async(t,e)=>(e.destroy(),!0),updateItem:async(t,e)=>{await e.update(t)}}));this.readyResolver=new $e,this.ready=this.readyResolver.promise,t&&this.init(t)}get gl(){return this.context}get scenes(){return this.sceneDiffs.items}broadcastEventManagerCycle(t){for(let e=0,i=this.userInputManager.eventManagers.length;e<i;++e){const r=this.userInputManager.eventManagers[e];switch(t){case 1:r.didRender();break;case 0:r.willRender();break}}}async commit(t,e,i){if(!this.gl)return;let r=!1;e&&this.frameMetrics.currentFrame++,this.frameMetrics.frameDuration=this.frameMetrics.currentTime-this.frameMetrics.previousTime,this.frameMetrics.previousTime=this.frameMetrics.currentTime,t===void 0?this.frameMetrics.currentTime=Date.now()|0:(this.frameMetrics.previousTime===this.frameMetrics.currentTime&&(this.frameMetrics.previousTime=t),this.frameMetrics.currentTime=t),t=this.frameMetrics.currentTime;const s=this.sceneDiffs.items;s.sort(tl);const a={};for(let c=0,l=s.length;c<l;++c){const u=s[c],d=u.views,p=u.layers;d.sort(tl),p.sort(tl);for(let g=0,m=d.length;g<m;++g){const v=d[g],b={};p.length>0&&v.willUseView();const T=this.renderer.getRenderSize();let w=new ie({width:T[0],height:T[1],x:0,y:0});if(v.renderTarget){const I=(Array.isArray(v.renderTarget)?v.renderTarget[0]:v.renderTarget).getSize();w=new ie({width:I[0],height:I[1],x:0,y:0})}const E=zo(v.props.viewport,w,this.pixelRatio);v.fitViewtoViewport(w,E);for(let _=0,I=p.length;_<I;++_){const M=p[_];M.view=v;try{M.draw(),(M.needsViewDrawn||M.alwaysDraw)&&(v.needsDraw=!0),b[M.id]=M,v.animationEndTime=Math.max(v.animationEndTime,M.animationEndTime,v.props.camera.animationEndTime),M.lastFrameTime=t}catch(C){C instanceof Error&&(a[M.id]||(a[M.id]=[M,C]))}}if(v.needsDraw||t&&t<v.lastFrameTime||t&&t<v.animationEndTime||v.props.camera.needsViewDrawn){v.needsDraw=!0,r=!0;const _=this.viewDrawDependencies.get(v);_&&_.forEach(I=>{I.needsDraw=!0})}const x=Object.values(b);p.length!==x.length&&u.layerDiffs.diff(x.map(_=>_.initializer)),u.container&&i&&i(r,u,v)}}const o=Object.values(a);this.printLayerErrors(o)}destroy(){this.resourceManager.destroy(),this.userInputManager.destroy(),this.sceneDiffs.destroy(),this.renderer.dispose(),delete this.context}async draw(t){if(this.gl){this.broadcastEventManagerCycle(0);for(let e=0,i=this.sceneDiffs.items.length;e<i;++e){const r=this.sceneDiffs.items[e];for(let s=0,a=r.views.length;s<a;++s){const o=r.views[s];o.props.camera.broadcast(o.id)}}if(await this.commit(t,!0,(e,i,r)=>{i.container&&e&&this.drawSceneView(i.container,r)}),this.userInputManager.waitingForRender&&(this.userInputManager.waitingForRender=!1),!this.isBufferingResources){this.isBufferingResources=!0;const e=await this.resourceManager.dequeueRequests();this.isBufferingResources=!1,e&&this.draw(await Cn())}for(let e=0,i=this.sceneDiffs.items.length;e<i;++e){const r=this.sceneDiffs.items[e];for(let s=0,a=r.views.length;s<a;++s){const o=r.views[s];o.needsDraw=!1,o.props.camera.resolve()}for(let s=0,a=r.layers.length;s<a;++s){const o=r.layers[s];o.needsViewDrawn=!1}}this.broadcastEventManagerCycle(1),this.enabledOptimizedOutputs.clear()}}drawSceneView(t,e,i,r){i=i||this.renderer;const s={x:e.viewBounds.left,y:e.viewBounds.top},a=e.viewBounds,o=e.props.background||A0,c=e.clearFlags.indexOf(lr.COLOR)>-1,l=r||e.renderTarget||null;e.renderTarget&&(e.getRenderTargets().forEach(d=>this.optimizedOutputs.forEach(p=>d.disabledTargets.add(p))),this.enabledOptimizedOutputs.size>0&&e.getRenderTargets().forEach(p=>this.enabledOptimizedOutputs.forEach(g=>p.disabledTargets.delete(g)))),i.setRenderTarget(l),i.setScissor({x:s.x,y:s.y,width:a.width,height:a.height},l),c&&i.clearColor([o[0],o[1],o[2],o[3]]),i.setViewport({x:s.x,y:s.y,width:a.width,height:a.height}),e.clearFlags&&e.clearFlags.length>0?i.clear(c,e.clearFlags.indexOf(lr.DEPTH)>-1,e.clearFlags.indexOf(lr.STENCIL)>-1):i.clear(!1),i.render(t,l,e.props.glState),e.lastFrameTime=this.frameMetrics.currentTime}fitContainer(t){if(!this.context||bi(this.context.canvas))return;const e=this.context.canvas.parentElement;if(e){const i=this.context.canvas;i.className="",i.setAttribute("style",""),e.style.position="relative",i.style.position="absolute",i.style.left="0xp",i.style.top="0xp",i.style.width="100%",i.style.height="100%",i.setAttribute("width",""),i.setAttribute("height","");const r=e.getBoundingClientRect(),s=i.getBoundingClientRect();this.resize(s.width||100,r.height||100)}}gatherViewDrawDependencies(){if(!this.sceneDiffs)return;this.viewDrawDependencies.clear();const t=this.sceneDiffs.items,e=this.renderer.getRenderSize();for(let i=0,r=t.length;i<r;i++){const s=t[i];for(let a=0,o=s.views.length;a<o;++a){const c=s.views[a];c.willUseView();let l=new ie({width:e[0],height:e[1],x:0,y:0});if(c.renderTarget){const p=(Array.isArray(c.renderTarget)?c.renderTarget[0]:c.renderTarget).getSize();l=new ie({width:p[0],height:p[1],x:0,y:0})}const u=zo(c.props.viewport,l,this.pixelRatio);c.fitViewtoViewport(l,u),c.props.camera.update(!0)}}for(let i=0,r=t.length;i<r;i++){const s=t[i];for(let a=0,o=s.views.length;a<o;++a){const c=s.views[a],l=[];for(let u=0,d=t.length;u<d;u++)if(u!==i){const p=t[u];for(let g=0,m=p.views.length;g<m;++g){const v=p.views[g];c.viewBounds.hitBounds(v.viewBounds)&&l.push(v)}}this.viewDrawDependencies.set(c,l)}}}getCurrentInteraction(){return this.userInputManager.currentInteraction}getIOExpanders(){return this.ioExpanders}getIOSorting(){return this.ioSorting}getShaderTransforms(){return this.shaderTransforms}getOptimizedOutputs(){return this.enabledOptimizedOutputs}getViewSize(t){for(let e=0,i=this.sceneDiffs.items.length;e<i;++e){const s=this.sceneDiffs.items[e].viewDiffs.getByKey(t);if(s)return s.renderTarget?s.viewBounds:s.screenBounds}return null}getViewWorldBounds(t){for(let e=0,i=this.sceneDiffs.items.length;e<i;++e){const s=this.sceneDiffs.items[e].viewDiffs.getByKey(t);if(s)if(s.screenBounds){const a=s.projection.viewToWorld([0,0]),o=s.projection.screenToWorld([s.screenBounds.right,s.screenBounds.bottom]);return new ie({bottom:o[1],left:a[0],right:o[0],top:a[1]})}else return null}return null}getProjections(t){for(let e=0,i=this.sceneDiffs.items.length;e<i;++e){const s=this.sceneDiffs.items[e].viewDiffs.getByKey(t);if(s)return s.projection}return null}async init(t){var i;if(this.context)return this;this.pixelRatio=t.pixelRatio||this.pixelRatio,this.pixelRatio<1&&(this.pixelRatio=1);const e=this.initGL(t);return e?(this.context=e,this.gl?((i=t.optimizedOutputTargets)==null||i.forEach(r=>this.optimizedOutputs.add(r)),this.initUserInputManager(t),await this.initResources(t),await this.initIOExpanders(t),await this.initShaderTransforms(t)):console.warn("Could not establish a GL context. Layer Surface will be unable to render"),this.readyResolver.resolve(this),this):(this.readyResolver.reject({error:Yo.NO_WEBGL_CONTEXT,message:"Could not establish a webgl context. Surface is being destroyed to free resources."}),this.destroy(),this)}initGL(t){const e=t.context;if(!e)return null;const i=e.width,r=e.height;let s=!0;const a=Object.assign({alpha:!1,antialias:!1,preserveDrawingBuffer:!1,premultiplyAlpha:!1},t.rendererOptions);return this.renderer=new uu({alpha:a.alpha,antialias:a.antialias,canvas:e,preserveDrawingBuffer:a.preserveDrawingBuffer,premultipliedAlpha:a.premultipliedAlpha,onNoContext:()=>{s=!1}}),!s||!this.renderer.gl?null:(this.context=this.renderer.gl,this.resourceManager&&this.resourceManager.setWebGLRenderer(this.renderer),this.setRendererSize(i,r),this.renderer.setPixelRatio(this.pixelRatio),this.renderer.gl)}initIOExpanders(t){const e=uf();Array.isArray(t.ioExpansion)||t.ioExpansion===void 0?this.ioExpanders=t.ioExpansion&&t.ioExpansion.slice(0)||e.slice(0)||[]:t.ioExpansion instanceof Function&&(this.ioExpanders=t.ioExpansion(e));const i=this.resourceManager.getIOExpansion();this.ioExpanders=this.ioExpanders.concat(i)}initShaderTransforms(t){const e=df();Array.isArray(t.shaderTransforms)||t.shaderTransforms===void 0?this.shaderTransforms=t.shaderTransforms&&t.shaderTransforms.slice(0)||e.slice(0)||[]:t.shaderTransforms instanceof Function&&(this.shaderTransforms=t.shaderTransforms(e))}initUserInputManager(t){if(!this.context)return;const e=[new lf].concat(t.eventManagers||[]);this.userInputManager=new af(this.context.canvas,this,e,t.handlesWheelEvents)}async initResources(t){const e=hf();this.resourceManager=new Vc,this.resourceManager.setWebGLRenderer(this.renderer),(t.resourceManagers&&t.resourceManagers.slice(0)||e.slice(0)||[]).forEach(r=>{this.resourceManager.setManager(r.type,r.manager)})}async pipeline(t){t.resources&&await this.resourceDiffs.diff(t.resources),t.scenes&&await this.sceneDiffs.diff(t.scenes),this.gatherViewDrawDependencies()}printLayerErrors(t){t.length>0&&(console.warn("Some layers errored during their draw update. These layers will be removed. They can be re-added if render() is called again:",t.map(e=>e[0].id)),t.forEach(e=>{if(console.warn(`Layer ${e[0].id} removed for the following error:`),e[1]){const i=e[1].stack||e[1].message;if(console.error(i),i.indexOf("RangeError")>-1||i.indexOf("Source is too large")>-1){const r=e[0],s=r.bufferManager.changeListContext||[];let a,o=0;for(let c=0,l=s.length;c<l;++c){const[u]=s[c];r.shaderIOInfo.instanceAttributes.forEach(d=>{d.update(u).length!==d.size&&(a||(a=["Example instance returned the wrong sized value for an attribute:",u,d]),o++)})}a&&(console.error("The following output shows discovered issues related to the specified error"),console.error(`Instances are returning too large IO for an attribute
`,a[0],a[1],a[2],"Total errors for too large IO values",o))}}}))}resize(t,e,i){if(this.pixelRatio=i||this.pixelRatio,this.pixelRatio<1&&(this.pixelRatio=1),this.setRendererSize(t,e),this.renderer.setPixelRatio(this.pixelRatio),this.userInputManager.resize(),this.resourceManager.resize(),this.sceneDiffs){const r=this.sceneDiffs.items;for(let s=0,a=r.length;s<a;++s){const o=r[s];for(let c=0,l=o.views.length;c<l;++c){const u=o.views[c];u.pixelRatio=this.pixelRatio,u.props.camera.update(!0)}}}this.gatherViewDrawDependencies()}redraw(){for(let t=0,e=this.sceneDiffs.items.length;t<e;++t){const i=this.sceneDiffs.items[t];for(let r=0,s=i.views.length;r<s;++r){const a=i.views[r];a.needsDraw=!0}}}setRendererSize(t,e){t=t||100,e=e||100,this.renderer.setSize(t,e)}enableOptimizedOutput(t){this.enabledOptimizedOutputs.add(t)}}class nl extends bt{draw(){this.props.commands(this.surface)}initShader(){return null}}f(nl,"defaultProps",{data:new pe,key:"",commands:()=>{}});class Be extends bt{constructor(t,e,i){super(t,e,i)}baseShaderModules(t){const e=super.baseShaderModules(t);return e.vs.push("world2D"),e}}const I0=`
These are projection methods and camera
related constants associated with a
View2D.

Methods:
vec3 cameraSpace(vec3 world);
vec3 cameraSpaceSize(vec3 worldSize);
vec4 clipSpace(vec3 world);
vec4 clipSpaceSize(vec3 worldSize);

Constants:
mat4 projection;
mat4 view;
mat4 viewProjection;
vec3 cameraOffset;
vec3 cameraPosition;
vec3 cameraScale;
vec3 cameraScale2D;
vec3 cameraRotation;
vec2 viewSize;
float pixelRatio;
`;xe.register([{moduleId:"world2D",description:I0,content:of,compatibility:S.ALL,uniforms:n=>n instanceof Be?[{name:"projection",size:R.MATRIX4,update:()=>n.view.props.camera.projection},{name:"view",size:R.MATRIX4,update:()=>n.view.props.camera.view},{name:"viewProjection",size:R.MATRIX4,update:()=>n.view.props.camera.viewProjection},{name:"cameraOffset",size:R.THREE,update:()=>n.view.props.camera instanceof hn?n.view.props.camera.control2D.offset:[0,0,0]},{name:"cameraPosition",size:R.THREE,update:()=>n.view.props.camera.position},{name:"cameraScale",size:R.THREE,update:()=>n.view.props.camera.scale},{name:"cameraScale2D",size:R.THREE,update:()=>n.view.props.camera instanceof hn?n.view.props.camera.scale2D:[1,1,1]},{name:"cameraRotation",size:R.THREE,update:()=>n.view.props.camera.scale},{name:"viewSize",size:R.TWO,update:()=>[n.view.viewBounds.width,n.view.viewBounds.height]},{name:"pixelRatio",size:R.ONE,update:()=>[n.view.pixelRatio]}]:(console.warn("A shader requested the module world2D; however, the layer the shader comes from is NOT a Layer2D which is","required for the module to work."),[])}]);var U=(n=>(n[n.BottomLeft=0]="BottomLeft",n[n.BottomMiddle=1]="BottomMiddle",n[n.BottomRight=2]="BottomRight",n[n.Custom=3]="Custom",n[n.Middle=4]="Middle",n[n.MiddleLeft=5]="MiddleLeft",n[n.MiddleRight=6]="MiddleRight",n[n.TopLeft=7]="TopLeft",n[n.TopMiddle=8]="TopMiddle",n[n.TopRight=9]="TopRight",n))(U||{}),dn=(n=>(n[n.ALWAYS=1]="ALWAYS",n[n.BOUND_MAX=2]="BOUND_MAX",n[n.NEVER=3]="NEVER",n))(dn||{}),pf=(n=>(n[n.TOP_LEFT=0]="TOP_LEFT",n[n.TOP_MIDDLE=1]="TOP_MIDDLE",n[n.TOP_RIGHT=2]="TOP_RIGHT",n[n.MIDDLE_LEFT=3]="MIDDLE_LEFT",n[n.MIDDLE=4]="MIDDLE",n[n.MIDDLE_RIGHT=5]="MIDDLE_RIGHT",n[n.BOTTOM_LEFT=6]="BOTTOM_LEFT",n[n.BOTTOM_MIDDLE=7]="BOTTOM_MIDDLE",n[n.BOTTOM_RIGHT=8]="BOTTOM_RIGHT",n))(pf||{});class gf extends bs{constructor(e){super({});f(this,"_uid",z());f(this,"bounds");f(this,"_camera");f(this,"ignoreCoverViews");f(this,"isPanning",!1);f(this,"isScaling",!1);f(this,"panFilter",(e,i,r)=>e);f(this,"scaleFactor");f(this,"scaleFilter",(e,i,r)=>e);f(this,"startViews",[]);f(this,"wheelShouldScroll");f(this,"twoFingerPan");f(this,"optimizedViews",new Set);f(this,"cameraImmediateAnimation",Ks.immediate(0));f(this,"targetTouches",new Set);f(this,"coveredStartView");f(this,"onRangeChanged",(e,i)=>{});f(this,"startViewDidStart",!1);f(this,"applyBounds",()=>{if(this.bounds&&this.camera){const e=this.getView(this.bounds.view);this.applyScaleBounds(),e&&(this.camera.control2D.getOffset()[0]=this.boundsHorizontalOffset(e,this.bounds),this.camera.control2D.getOffset()[1]=this.boundsVerticalOffset(e,this.bounds))}});f(this,"applyScaleBounds",()=>{this.camera&&this.bounds&&(this.bounds.scaleMin&&this.camera.control2D.setScale(Is(this.camera.control2D.getScale(),this.bounds.scaleMin)),this.bounds.scaleMax&&this.camera.control2D.setScale(Ss(this.camera.control2D.getScale(),this.bounds.scaleMax)))});f(this,"handleCameraViewChange",(e,i)=>{if(i!==this.startViews[0])return;const r=this.surface.getProjections(i);r&&this.onRangeChanged(e,r)});e.bounds&&this.setBounds(e.bounds),this._camera=e.camera,this.scaleFactor=e.scaleFactor||1e3,this.ignoreCoverViews=e.ignoreCoverViews||!1,this.twoFingerPan=e.twoFingerPan||!1,e.startView&&(Array.isArray(e.startView)?(this.startViews=e.startView,this._camera.control2D.setViewChangeHandler(this.handleCameraViewChange)):(this.startViews=[e.startView],this._camera.control2D.setViewChangeHandler(this.handleCameraViewChange))),this.panFilter=e.panFilter||this.panFilter,this.scaleFilter=e.scaleFilter||this.scaleFilter,this.onRangeChanged=e.onRangeChanged||this.onRangeChanged,e.wheelShouldScroll&&(this.wheelShouldScroll=e.wheelShouldScroll)}get uid(){return this._uid}get camera(){return this._camera}anchoredByBoundsHorizontal(e,i){switch(i.anchor){case 0:case 3:case 6:return-(i.worldBounds.left-i.screenPadding.left/this.camera.control2D.getScale()[0]);case 1:case 4:case 7:return-(i.worldBounds.right-i.worldBounds.width/2-.5*((e.screenBounds.width+i.screenPadding.right)/this.camera.control2D.getScale()[0]));case 2:case 5:case 8:return-(i.worldBounds.right-(e.screenBounds.width-i.screenPadding.right)/this.camera.control2D.getScale()[0])}}anchoredByBoundsVertical(e,i){switch(i.anchor){case 0:case 1:case 2:return-(i.worldBounds.top-i.screenPadding.top/this.camera.control2D.getScale()[1]);case 3:case 4:case 5:return-(i.worldBounds.bottom-i.worldBounds.height/2-.5*((e.screenBounds.height+i.screenPadding.bottom)/this.camera.control2D.getScale()[1]));case 6:case 7:case 8:return-(i.worldBounds.bottom-(e.screenBounds.height-i.screenPadding.bottom)/this.camera.control2D.getScale()[1])}}boundsHorizontalOffset(e,i){const r=e.projection.worldToScreen([i.worldBounds.left,i.worldBounds.top]),s=e.projection.worldToScreen([i.worldBounds.right,i.worldBounds.bottom]);return s[0]-r[0]+i.screenPadding.left+i.screenPadding.right-e.screenBounds.width<0?this.anchoredByBoundsHorizontal(e,i):s[0]<e.screenBounds.right-i.screenPadding.right?-i.worldBounds.right+(e.screenBounds.width-i.screenPadding.right)/this.camera.control2D.getScale()[0]:r[0]>e.screenBounds.left+i.screenPadding.left?-i.worldBounds.left+i.screenPadding.left/this.camera.control2D.getScale()[0]:this.camera.control2D.getOffset()[0]}boundsVerticalOffset(e,i){const r=e.projection.worldToScreen([i.worldBounds.left,i.worldBounds.top]),s=e.projection.worldToScreen([i.worldBounds.right,i.worldBounds.bottom]);return s[1]-r[1]+i.screenPadding.top+i.screenPadding.bottom-e.screenBounds.height<0?this.anchoredByBoundsVertical(e,i):s[1]<e.screenBounds.bottom-i.screenPadding.bottom?-i.worldBounds.bottom+(e.screenBounds.height-i.screenPadding.bottom)/this.camera.control2D.getScale()[1]:r[1]>e.screenBounds.top+i.screenPadding.top?-i.worldBounds.top+i.screenPadding.top/this.camera.control2D.getScale()[0]:this.camera.control2D.getOffset()[1]}canStart(e){return this.startViews.length===0||this.startViews&&this.startViews.indexOf(e)>-1||this.startViewDidStart&&this.ignoreCoverViews}centerOn(e,i){if(!this.camera.control2D.surface)return;const r=this.camera.control2D.surface.getViewSize(e);if(!r)return;const s=[r.width/2,r.height/2,0],a=Pt(i,yr(s,this.camera.control2D.getScale())),o=at(a,-1);this.setOffset(e,o)}doPan(e,i,r){let s=Xn(wr(r,this.camera.control2D.getScale()),0);this.panFilter&&(s=this.panFilter(s,i,e)),this.camera.control2D.getOffset()[0]+=s[0],this.camera.control2D.getOffset()[1]+=s[1],this.applyBounds(),this.onRangeChanged(this.camera,i.projection),this.applyBounds(),this.camera.control2D.update()}doScale(e,i,r,s){const a=i.projection.screenToWorld(e),o=this.camera.control2D.getScale()[0]||1,c=this.camera.control2D.getScale()[1]||1;this.scaleFilter&&(s=this.scaleFilter(s,i,r)),this.camera.control2D.getScale()[0]=o+s[0],this.camera.control2D.getScale()[1]=c+s[1],this.applyScaleBounds();const l=i.projection.screenToWorld(e),u=Ae(a,l);this.camera.control2D.getOffset()[0]-=u[0],this.camera.control2D.getOffset()[1]-=u[1],this.applyBounds(),this.onRangeChanged(this.camera,i.projection),this.applyBounds(),this.camera.control2D.update(),this.camera.control2D.animation=this.cameraImmediateAnimation}filterTouchesByValidStart(e){return this.ignoreCoverViews?e.filter(Eu(this.startViews)):e.filter(yu(this.startViews))}findCoveredStartView(e){const i=e.target.views.find(r=>this.startViews.indexOf(r.view.id)>-1);this.startViewDidStart=!!i,i&&(this.coveredStartView=i.view)}getRange(e){const i=this.getProjection(e),r=this.getViewScreenBounds(e);if(i&&r){const s=i.screenToWorld([r.x,r.y]),a=i.screenToWorld([r.right,r.bottom]);return new ie({height:a[1]-s[1],width:a[0]-s[0],x:s[0],y:s[1]})}return new ie({x:0,y:0,width:1,height:1})}getTargetView(e){return this.startViews&&!this.ignoreCoverViews?e.target.view:this.coveredStartView}handleMouseDown(e){this.startViews&&(this.findCoveredStartView(e),e.start&&(this.isPanning=this.canStart(e.start.view.id)||this.isPanning))}handleTouchDown(e){if(this.startViews){const i=this.filterTouchesByValidStart(e.allTouches);this.twoFingerPan?i.length>1&&(this.isPanning=!0):i.length>0&&(this.isPanning=!0),i.length>1&&(this.isScaling=!0);for(let r=0,s=i.length;r<s;++r){const a=i[r];this.targetTouches.add(a.touch.touch.identifier)}}}handleMouseUp(e){this.startViewDidStart=!1,this.isPanning=!1,this.optimizedViews.forEach(i=>i.optimizeRendering=!1),this.optimizedViews.clear()}handleTouchUp(e){e.touches.forEach(i=>{this.targetTouches.delete(i.touch.touch.identifier),this.targetTouches.size<=0&&(this.startViewDidStart=!1,this.isPanning=!1,this.optimizedViews.forEach(r=>r.optimizeRendering=!1),this.optimizedViews.clear())}),this.isPanning=!1,this.isScaling=!1,this.targetTouches.size>0&&(this.isPanning=!0),this.targetTouches.size>1&&(this.isScaling=!0)}handleTouchCancelled(e){e.touches.forEach(i=>{this.targetTouches.delete(i.touch.touch.identifier),this.targetTouches.size<=0&&(this.startViewDidStart=!1,this.isPanning=!1,this.optimizedViews.forEach(r=>r.optimizeRendering=!1),this.optimizedViews.clear())}),this.isPanning=!1,this.isScaling=!1,this.targetTouches.size>0&&(this.isPanning=!0),this.targetTouches.size>1&&(this.isScaling=!0)}handleDrag(e){e.start&&this.canStart(e.start.view.id)&&(e.target.views.forEach(i=>{i.view.optimizeRendering=!0,this.optimizedViews.add(i.view)}),this.doPan(e.target.views.map(i=>i.view),e.start.view,e.mouse.deltaPosition),this.camera.control2D.animation=this.cameraImmediateAnimation)}handleTouchDrag(e){const i=this.filterTouchesByValidStart(e.allTouches);if(i.length>0&&this.isPanning){for(let o=0,c=i.length;o<c;++o)i[o].target.views.forEach(u=>{u.view.optimizeRendering=!0,this.optimizedViews.add(u.view)});const r=new Set,a=i.reduce((o,c)=>{for(let l=0,u=c.target.views.length;l<u;++l){const d=c.target.views[l];r.add(d.view)}return c.touch.startTime<o.touch.startTime?c:o},i[0]).start.view;if(this.isPanning&&(this.doPan(Array.from(r.values()),a,e.multitouch.centerDelta(i)),this.camera.control2D.animation=this.cameraImmediateAnimation),this.isScaling){const o=e.multitouch.center(i),c=Ae(i[0].touch.currentPosition,o),l=Ae(o,e.multitouch.centerDelta(i)),u=Ae(i[0].touch.previousPosition,l),d=Hn(c)/Hn(u),p=[d*this.camera.scale2D[0]-this.camera.scale2D[0],d*this.camera.scale2D[1]-this.camera.scale2D[1],0];d!==1&&this.doScale(o,a,Array.from(r.values()),p)}}}handleWheel(e){if(this.findCoveredStartView(e),this.canStart(e.target.view.id))if(this.wheelShouldScroll){const i=[-e.mouse.wheel.delta[0],e.mouse.wheel.delta[1]];e.start&&this.doPan(e.target.views.map(r=>r.view),e.start.view,i)}else{const i=this.camera.control2D.getScale()[0]||1,r=this.camera.control2D.getScale()[1]||1,s=this.getTargetView(e),a=[e.mouse.wheel.delta[1]/this.scaleFactor*i,e.mouse.wheel.delta[1]/this.scaleFactor*r,1];if(!s){console.warn("Could not find target view for wheel event");return}this.doScale(e.screen.position,s,e.target.views.map(o=>o.view),a)}}get pan(){return this.camera.control2D.offset}get scale(){return this.camera.control2D.getScale()}setBounds(e){this.bounds=e,this.applyBounds()}setOffset(e,i){const r=st(this.camera.control2D.offset);if(this.camera.control2D.getOffset()[0]=i[0],this.camera.control2D.getOffset()[1]=i[1],this.camera.control2D.getOffset()[2]=i[2],this.applyBounds(),this.camera.control2D.surface){const o=this.camera.control2D.surface.getProjections(e);o&&this.onRangeChanged(this.camera,o)}this.applyBounds();const s=st(this.camera.control2D.getOffset()),a=this.camera.control2D.animation;this.camera.control2D.setOffset(r),this.camera.control2D.animation=this.cameraImmediateAnimation,this.camera.control2D.setOffset(s),this.camera.control2D.animation=a}setRange(e,i){const r=this.getProjection(i),s=this.getViewScreenBounds(i),a=this.getView(i);if(r&&s&&a){const o=Pt([s.width/e.width,s.height/e.height,1],this.camera.control2D.getScale());this.camera.control2D.setScale(Nt(this.camera.control2D.getScale(),this.scaleFilter(o,a,[a])));const c=Pt([-e.x,-e.y,0],this.camera.control2D.offset);this.camera.control2D.setOffset(Nt(this.camera.control2D.offset,this.scaleFilter(c,a,[a]))),this.applyBounds(),this.onRangeChanged(this.camera,a.projection),this.applyBounds()}}setRangeChangeHandler(e){this.onRangeChanged=e}}class S0 extends Bn{constructor(e,i){super(e);f(this,"base");f(this,"offsetFilter",e=>e);f(this,"scaleFilter",e=>e);this.base=i.base,this.offsetFilter=i.offsetFilter||this.offsetFilter,this.scaleFilter=i.scaleFilter||this.scaleFilter}set offset(e){}get offset(){return this.offsetFilter(this.base.offset)}set scale(e){}get scale(){return this.scaleFilter(this.base.scale)}}class M0 extends hn{constructor(e){super();f(this,"base");this.base=e.base,this._control2D=new S0(this.base,{base:this.base.control2D,offsetFilter:e.offsetFilter,scaleFilter:e.scaleFilter})}set control2D(e){}get control2D(){return this._control2D}}const C0=new hn;class L0 extends Xs{constructor(){super(...arguments);f(this,"camera",C0)}screenToWorld(e,i){const r=this.screenToView(e),s=i||[0,0];return s[0]=(r[0]-this.camera.control2D.offset[0]*this.camera.scale2D[0])/this.camera.scale2D[0],s[1]=(r[1]-this.camera.control2D.offset[1]*this.camera.scale2D[1])/this.camera.scale2D[1],s}screenRay(e){const i=this.screenToWorld(e);return[[i[0],i[1],0],[i[0],i[1],-1]]}worldToScreen(e,i){const r=[0,0];return r[0]=(e[0]*this.camera.scale2D[0]+this.camera.control2D.offset[0]*this.camera.scale2D[0])*this.pixelRatio,r[1]=(e[1]*this.camera.scale2D[1]+this.camera.control2D.offset[1]*this.camera.scale2D[1])*this.pixelRatio,this.viewToScreen(r,i)}viewToWorld(e,i){const r=i||[0,0],s=e;return r[0]=(s[0]-this.camera.control2D.offset[0]*this.camera.scale2D[0])/this.camera.scale2D[0],r[1]=(s[1]-this.camera.control2D.offset[1]*this.camera.scale2D[1])/this.camera.scale2D[1],r}worldToView(e,i){const r=i||[0,0];return r[0]=e[0]*this.camera.scale2D[0]+this.camera.control2D.offset[0]*this.camera.scale2D[0],r[1]=e[1]*this.camera.scale2D[1]+this.camera.control2D.offset[1]*this.camera.scale2D[1],r}}function mf(n){return n.projectionType===Ln.ORTHOGRAPHIC}class xa extends Ni{constructor(e,i){super(e,i);f(this,"projection",new L0);this.projection.camera=i.camera||new hn}fitViewtoViewport(e,i){if(mf(this.props.camera)){const r=i.width,s=i.height,a={bottom:-s/2,far:1e7,left:-r/2,near:-100,right:r/2,top:s/2},o=1/this.pixelRatio,c=1/this.pixelRatio,l=this.props.camera;l.projectionOptions=Object.assign(l.projectionOptions,a),l.position=[i.width/(2*this.pixelRatio),i.height/(2*this.pixelRatio),l.position[2]],l.scale=[o,-c,1],l.lookAt(Nt(l.position,[0,0,-1]),[0,1,0]),l.update(),this.projection.viewBounds=i,i.d=this,this.projection.screenBounds=new ie({height:this.viewBounds.height/this.pixelRatio,width:this.viewBounds.width/this.pixelRatio,x:this.viewBounds.x/this.pixelRatio,y:this.viewBounds.y/this.pixelRatio}),this.screenBounds.d=this}else mf(this.props.camera)||console.warn("View2D does not support non-orthographic cameras.")}willUpdateProps(e){this.projection.camera=e.camera}}f(xa,"defaultProps",{key:"",camera:new hn,viewport:{left:0,right:0,bottom:0,top:0}});const O0=`precision highp float;

varying vec4 vertexColor;

void main() {
  gl_FragColor = vertexColor;
}
`,N0=`precision highp float;

/**
  This vertex shader calculates edges whose curve and width is in screen space where the curve is
  bezier curves with 0, 1, and 2 control points.
**/
varying vec4 vertexColor;

vec2 interpolation(float t, vec2 center, float radius, float start, float end) {
  float angle = (end - start) * t + start;
  return center + vec2(cos(angle) * radius, sin(angle) * radius);
}

void main() {
  // Destructure some of the vec injections
  float startAngle = angle.x;
  float endAngle = angle.y;
  float widthStart = thickness.x;
  float widthEnd = thickness.y;

  // Convert world points to screen space
  vec4 centerClip = clipSpace(vec3(center, depth));
  vec2 centerScreen = (centerClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;
  // Destructure position attribute
  float normal = position.x;
  float interpolationTime = position.y;
  float interpolationIncrement = 1.0 / position.z;
  // Get the position of the current vertex
  vec2 currentPosition = interpolation(interpolationTime, centerScreen, radius, startAngle, endAngle);
  // Get normal with currentPosition and center
  vec2 currentNormal = normalize(currentPosition - centerScreen);
  // Get the thickness based on the side we're on
  float lineThickness = mix(widthStart, widthEnd, interpolationTime) / 2.0;
  // Start on the calculated line and push out by the normal's value
  vec2 vertex = currentPosition + currentNormal * (normal * lineThickness);
  // Get the color based on where we are on the line
  vertexColor = mix(colorStart, colorEnd, interpolationTime);
  vertexColor *= vertexColor.a;

  gl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), centerClip.zw);
  gl_PointSize = 5.0;
}
`,P0=`\${import: arc}
precision highp float;

/**
  This vertex shader calculates edges whose curve and width is in screen space where the curve is
  bezier curves with 0, 1, and 2 control points.
**/
varying vec4 vertexColor;

void main() {
  // Destructure some of the vec injections
  float startAngle = angle.x + angleOffset;
  float endAngle = angle.y + angleOffset;
  float widthStart = thickness.x;
  float widthEnd = thickness.y;
  // Destructure vertex attribute
  float normal = vertex.x;
  float interpolationTime = vertex.y;
  float interpolationIncrement = 1.0 / vertex.z;
  // Get the position of the current vertex
  vec2 currentPosition = arc(interpolationTime, center, radius, startAngle, endAngle);
  // Get normal with currentPosition and center
  vec2 currentNormal = normalize(currentPosition - center);
  // Get the thickness based on the side we're on
  float lineThickness = mix(widthStart, widthEnd, interpolationTime) / 2.0;
  // Start on the calculated line and push out by the normal's value
  vec2 vertex = currentPosition + currentNormal * (normal * lineThickness);
  // Get the color based on where we are on the line
  vertexColor = mix(colorStart, colorEnd, interpolationTime);

  gl_Position = clipSpace(vec3(vertex, depth));
}
`;var vf=(n=>(n[n.NONE=0]="NONE",n[n.SCREEN_CURVE=1]="SCREEN_CURVE",n))(vf||{});const yn=class extends Be{initShader(){const{scaleType:t}=this.props,e=this.props.animate||{},{angle:i,angleOffset:r,center:s,radius:a,thickness:o,colorStart:c,colorEnd:l}=e,u=150,d={0:1,[u*2+2]:-1},p={0:0,[u*2+2]:1};let g=1;for(let v=0;v<u*2;++v)d[v+1]=g,p[v+1]=Math.floor(v/2)/(u-1),g*=-1;const m=t===0?P0:N0;return{fs:O0,instanceAttributes:[{easing:s,name:yn.attributeNames.center,size:P.TWO,update:v=>v.center},{easing:a,name:yn.attributeNames.radius,size:P.ONE,update:v=>[v.radius]},{name:yn.attributeNames.depth,size:P.ONE,update:v=>[v.depth]},{easing:o,name:yn.attributeNames.thickness,size:P.TWO,update:v=>v.thickness},{easing:i,name:yn.attributeNames.angle,size:P.TWO,update:v=>v.angle},{easing:r,name:yn.attributeNames.angleOffset,size:P.ONE,update:v=>[v.angleOffset]},{easing:c,name:yn.attributeNames.colorStart,size:P.FOUR,update:v=>v.colorStart},{easing:l,name:yn.attributeNames.colorEnd,size:P.FOUR,update:v=>v.colorEnd}],uniforms:[{name:"scaleFactor",size:R.ONE,update:v=>[1]}],vertexAttributes:[{name:"vertex",size:Ge.THREE,update:v=>[d[v],p[v],u*2]}],vertexCount:u*2+2,vs:m}}getMaterialOptions(){return Object.assign({},rt.transparentShapeBlending,{culling:h.GLSettings.Material.CullSide.NONE})}};let rs=yn;f(rs,"defaultProps",{data:new pe,key:"",scaleType:0}),f(rs,"attributeNames",{angle:"angle",angleOffset:"angleOffset",center:"center",colorEnd:"colorEnd",colorStart:"colorStart",depth:"depth",radius:"radius",thickness:"thickness"});var D0=Object.defineProperty,B0=Object.getOwnPropertyDescriptor,ai=(n,t,e,i)=>{for(var r=i>1?void 0:i?B0(t,e):t,s=n.length-1,a;s>=0;s--)(a=n[s])&&(r=(i?a(t,e,r):a(r))||r);return i&&r&&D0(t,e,r),r};const bf=class extends Ye{constructor(t){super(t);f(this,"angle",[0,Math.PI]);f(this,"colorEnd",[1,1,1,1]);f(this,"colorStart",[1,1,1,1]);f(this,"center",[0,0]);f(this,"depth",0);f(this,"angleOffset",0);f(this,"radius",1);f(this,"thickness",[5,5]);Qe(this,bf),this.angle=t.angle||this.angle,this.colorEnd=t.colorEnd||this.colorEnd,this.colorStart=t.colorStart||this.colorStart,this.center=t.center||this.center,this.depth=t.depth||this.depth,this.radius=t.radius||this.radius,this.thickness=t.thickness||this.thickness}};let Un=bf;ai([L],Un.prototype,"angle",2),ai([L],Un.prototype,"colorEnd",2),ai([L],Un.prototype,"colorStart",2),ai([L],Un.prototype,"center",2),ai([L],Un.prototype,"depth",2),ai([L],Un.prototype,"angleOffset",2),ai([L],Un.prototype,"radius",2),ai([L],Un.prototype,"thickness",2);const U0=`precision highp float;

varying vec4 vertexColor;
varying float edgeSharpness;
varying float edgeSharpnessBase;
varying vec2 pointCoord;

float circle(vec2 coord, float radius){
  vec2 dist = coord - vec2(0.5);

  return 1.0 - smoothstep(
    radius - (radius * edgeSharpness),
    radius + (radius * edgeSharpnessBase),
    dot(dist, dist) * 4.0
  );
}

void main() {
  float step_factor = circle(pointCoord, 1.0);

  // \${out: color} = hey
  \${out: color} = mix(
    vec4(0.0, 0.0, 0.0, 0.0),
    vertexColor,
    step_factor
  );

  if (color.a == 0.0) discard;
}
`,F0=`precision highp float;

varying vec4 vertexColor;
varying float edgeSharpness;
varying float edgeSharpnessBase;

float circle(vec2 coord, float radius){
  vec2 dist = coord - vec2(0.5);

  return 1.0 - smoothstep(
    radius - (radius * edgeSharpness),
    radius + (radius * edgeSharpnessBase),
    dot(dist, dist) * 4.0
  );
}

void main() {
  float step_factor = circle(gl_PointCoord, 1.0);

  // \${out: color} = hey
  \${out: color} = mix(
    vec4(0.0, 0.0, 0.0, 0.0),
    vertexColor,
    step_factor
  );

  if (color.a == 0.0) discard;
}
`,k0=`// This shader renders our circles with POINTS mode. This can perform better for more intensive scenarios but comes at
// the cost of hardware limitations such as max POINT size and potential involuntary hardware culling decisions for the
// viewport.
precision highp float;

varying vec4 vertexColor;
varying float edgeSharpness;
varying float edgeSharpnessBase;

void main() {
  vertexColor = color;
  vertexColor.a *= layerOpacity;
  float size = radius * cameraScale2D.x;
  edgeSharpness = mix(0.8, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));
  edgeSharpnessBase = mix(0.1, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));

  // NOTE: for now we keep depth * vertex where vertex is always one since our gl layer does not
  // support drawing non-instanced data yet.
  gl_Position = clipSpace(vec3(center, depth));
  gl_PointSize = size * 2.0 * pixelRatio;
}
`,G0=`// Shader for rendering simple circles on a quad, using the fragment shader to create the 'roundness' of the shape.
precision highp float;

varying vec4 vertexColor;
varying float edgeSharpness;
varying float edgeSharpnessBase;
varying vec2 pointCoord;

void main() {
  vertexColor = color;
  vertexColor.a *= layerOpacity;
  float size = radius * cameraScale2D.x * pixelRatio;
  edgeSharpness = mix(0.8, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));
  edgeSharpnessBase = mix(0.1, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));
  pointCoord = (normals.xy + vec2(1.0, 1.0)) / 2.0;

  // Center within clip space
  vec4 clipCenter = clipSpace(vec3(center, depth));
  // Center in screen space
  vec2 screenCenter = (clipCenter.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;
  // Position in screen space
  vec2 vertex = (normals.xy * size) + screenCenter;
  // Position back to clip space
  gl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), clipCenter.zw);
}
`,gr=class extends Be{initShader(){var p,g;const{animate:t={},usePoints:e=!1,opacity:i=()=>1}=this.props,{center:r,radius:s,color:a}=t,o=[1,1,-1,-1],c=[-1,1,-1,1],l=[0,1,2,1,3,2],u=[{name:"normals",size:Ge.TWO,update:m=>[o[m],c[m]]}],d=o.length;return{instancing:(p=this.props.bufferManagement)==null?void 0:p.instancing,baseBufferGrowthRate:(g=this.props.bufferManagement)==null?void 0:g.baseBufferGrowthRate,drawMode:e?h.GLSettings.Model.DrawMode.POINTS:h.GLSettings.Model.DrawMode.TRIANGLES,vs:e?k0:G0,fs:e?[{outputType:H.COLOR,source:F0},{outputType:H.GLOW,source:`
              void main() {
                \${out: glow} = color;
              }
              `}]:[{outputType:H.COLOR,source:U0},{outputType:H.GLOW,source:`
              void main() {
                \${out: glow} = color;
              }
              `}],instanceAttributes:[{easing:r,name:gr.attributeNames.center,size:P.TWO,update:m=>m.center},{easing:s,name:gr.attributeNames.radius,size:P.ONE,update:m=>[m.radius]},{name:gr.attributeNames.depth,size:P.ONE,update:m=>[m.depth]},{easing:a,name:gr.attributeNames.color,size:P.FOUR,update:m=>m.color}],uniforms:[{name:"layerOpacity",size:R.ONE,shaderInjection:S.ALL,update:m=>[i()]}],vertexAttributes:u,vertexCount:e?1:d,indexBuffer:{size:$i.UINT8,indexCount:6,update:m=>l[m]}}}getMaterialOptions(){return rt.transparentShapeBlending}};let ss=gr;f(ss,"defaultProps",{data:new pe,key:""}),f(ss,"attributeNames",{center:"center",color:"color",depth:"depth",radius:"radius"});var z0=Object.defineProperty,V0=Object.getOwnPropertyDescriptor,Ra=(n,t,e,i)=>{for(var r=i>1?void 0:i?V0(t,e):t,s=n.length-1,a;s>=0;s--)(a=n[s])&&(r=(i?a(t,e,r):a(r))||r);return i&&r&&z0(t,e,r),r};const wf=class extends Ye{constructor(t){super(t);f(this,"color",[1,1,1,1]);f(this,"depth",0);f(this,"radius",0);f(this,"center",[0,0]);Qe(this,wf),this.color=t.color||this.color,this.radius=t.radius||this.radius,this.center=t.center||this.center,this.depth=t.depth||this.depth}get width(){return this.radius*2}get height(){return this.radius*2}};let as=wf;Ra([L],as.prototype,"color",2),Ra([L],as.prototype,"depth",2),Ra([L],as.prototype,"radius",2),Ra([L],as.prototype,"center",2);var os=(n=>(n[n.NONE=0]="NONE",n[n.SCREEN_CURVE=1]="SCREEN_CURVE",n))(os||{}),fn=(n=>(n[n.LINE=0]="LINE",n[n.BEZIER=1]="BEZIER",n[n.BEZIER2=2]="BEZIER2",n))(fn||{}),il=(n=>(n[n.ALL=0]="ALL",n[n.PASS_Y=1]="PASS_Y",n[n.PASS_X=2]="PASS_X",n))(il||{});const $0=`

precision highp float;

/**
  This vertex shader calculates edges whose curve and width is in screen space where the curve is
  bezier curves with 0, 1, and 2 control points.
**/
varying vec4 vertexColor;

// Interpolation type injection
\${interpolation}

void main() {
  // Destructure vertex attribute
  float normal = vertex.x;
  float interpolationTime = vertex.y;
  float interpolationIncrement = 1.0 / vertex.z;
  // Get the position of the current vertex
  vec2 currentPosition = interpolation(interpolationTime, start, end, control.xy, control.zw);
  // Calculate the next and previous segment's location on the line
  vec2 prePosition = interpolation(interpolationTime - interpolationIncrement, start, end, control.xy, control.zw);
  vec2 nextPosition = interpolation(interpolationTime + interpolationIncrement, start, end, control.xy, control.zw);

  vec2 preLine = prePosition - currentPosition;
  vec2 nextLine = nextPosition - currentPosition;

  // Get a spliced nromal at the joining of two segments to make a crisper curve
  vec2 currentNormal = mix(
    // Pick this value if we're at the beginning of the line
    normalize(vec2(preLine.y, -preLine.x)),
    mix(
      // Pick this value when we're between the ends
      normalize(vec2(preLine.y, -preLine.x) + vec2(-nextLine.y, nextLine.x)),
      // Pick this value if we're at the end of the line
      normalize(vec2(-nextLine.y, nextLine.x)),
      float(vertex.x >= 1.0)
    ),
    float(vertex.x > 0.0)
  );

  // Get the thickness based on the side we're on
  float lineThickness = mix(thickness.x, thickness.y, interpolationTime) / 2.0;
  // Start on the calculated line and push out by the normal's value
  vec2 vertexPos = currentPosition + currentNormal * (normal * lineThickness);
  // Get the color based on where we are on the line
  vertexColor = mix(startColor, endColor, interpolationTime);

  gl_Position = clipSpace(vec3(vertexPos, depth));
  gl_PointSize = 5.0;

  // gl_Position = clipSpace(vec3(0., 0., 0.));
}
`,W0=`/**
 * Makes a linear interpolation between two points
 *
 * @param {vec2} s The start point
 * @param {vec2} e The end point
 * @param {vec2} c The bezier control point
 * @param {float} t The interpolation value [0, 1]
 *
 * @returns {vec2} A point interpolated between the two provided points
 */
vec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {
  float t1 = 1.0 - t;
  return pow(t1, 3.0) * p1 + 3.0 * t * pow(t1, 2.0) * c1 + 3.0 * pow(t, 2.0) * t1 * c2 + pow(t, 3.0) * p2;
}
`,j0=`/**
 * Makes a linear interpolation between two points
 *
 * @param {vec2} s The start point
 * @param {vec2} e The end point
 * @param {vec2} c The bezier control point
 * @param {float} t The interpolation value [0, 1]
 *
 * @returns {vec2} A point interpolated between the two provided points
 */
vec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {
  return (1.0 - t) * (1.0 - t) * p1 + 2.0 * t * (1.0 - t) * c1 + t * t * p2;
}
`,H0=`precision highp float;

varying vec4 vertexColor;

void main() {
  gl_FragColor = vertexColor;
}
`,X0=`/**
 * Makes a linear interpolation between two points
 *
 * @param {vec2} s The start point
 * @param {vec2} e The end point
 * @param {vec2} c The bezier control point
 * @param {float} t The interpolation value [0, 1]
 *
 * @returns {vec2} A point interpolated between the two provided points
 */
vec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {
  return p1 + (p2 - p1) * t;
}
`,Q0=`/**
  This vertex shader calculates edges based in world space to make an edge based on
  bezier curves with 0, 1, and 2 control points.
**/
precision highp float;



varying vec4 vertexColor;

// Interpolation type injection
\${interpolation}

void main() {
  // Destructure vertex attribute
  float normal = vertex.x;
  float interpolationTime = vertex.y;
  float interpolationIncrement = 1.0 / vertex.z;

  // Convert our world points to screen space
  vec4 startClip = clipSpace(vec3(start, depth));
  vec4 endClip = clipSpace(vec3(end, depth));
  vec2 startScreen = (startClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;
  vec2 endScreen = (endClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;
  // Controls for this mode are screen space deltas from the end points
  vec2 control1 = startScreen + vec2(control.x, -control.y) * scaleFactor;
  vec2 control2 = endScreen + vec2(control.z, -control.w) * scaleFactor;

  // Get the position of the current vertex
  vec2 currentPosition = interpolation(interpolationTime, startScreen, endScreen, control1, control2);
  // Calculate the next and previous segment's location on the line
  vec2 prePosition = interpolation(interpolationTime - interpolationIncrement, startScreen, endScreen, control1, control2);
  vec2 nextPosition = interpolation(interpolationTime + interpolationIncrement, startScreen, endScreen, control1, control2);

  vec2 preLine = prePosition - currentPosition;
  vec2 nextLine = nextPosition - currentPosition;

  // Get a spliced nromal at the joining of two segments to make a crisper curve
  vec2 currentNormal = mix(
    // Pick this value if we're at the beginning of the line
    normalize(vec2(preLine.y, -preLine.x)),
    mix(
      // Pick this value when we're between the ends
      normalize(vec2(preLine.y, -preLine.x) + vec2(-nextLine.y, nextLine.x)),
      // Pick this value if we're at the end of the line
      normalize(vec2(-nextLine.y, nextLine.x)),
      float(vertex.x >= 1.0)
    ),
    float(vertex.x > 0.0)
  );

  // Get the thickness based on the side we're on
  float lineThickness = mix(thickness.x, thickness.y, interpolationTime) / 2.0;
  // Start on the calculated line and push out by the normal's value
  vec2 vertexPos = currentPosition + currentNormal * (-normal * lineThickness * scaleFactor);
  // Get the color based on where we are on the line
  vertexColor = mix(startColor, endColor, interpolationTime);

  gl_Position = vec4((vertexPos / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), startClip.zw);
  gl_PointSize = 5.0;
}
`;function Y0(n){return[n[0][0],n[0][1],n[1][0],n[1][1]]}const q0={[fn.LINE]:X0,[fn.BEZIER]:j0,[fn.BEZIER2]:W0},At=class extends Be{initShader(){const{animate:t={},scaleFactor:e=()=>1,type:i,scaleType:r=os.NONE,smoothness:s=50}=this.props,{end:a,start:o,startColor:c,endColor:l,control:u,thickness:d}=t,p=i===fn.LINE?2:s,g={0:1,[p*2+2]:-1},m={0:0,[p*2+2]:1};let v=1;for(let w=0;w<p*2;++w)g[w+1]=v,m[w+1]=Math.floor(w/2)/(p-1),v*=-1;const b={interpolation:q0[i]},T=ii({options:b,required:{name:"Edge Layer",values:["interpolation"]},shader:r===os.NONE?$0:Q0,onToken:(w,E)=>w in b?E:`\${${w}}`});return{fs:H0,instanceAttributes:[{easing:c,name:At.attributeNames.startColor,size:P.FOUR,update:w=>w.startColor},{easing:l,name:At.attributeNames.endColor,size:P.FOUR,update:w=>w.endColor},{easing:o,name:At.attributeNames.start,size:P.TWO,update:w=>w.start},{easing:a,name:At.attributeNames.end,size:P.TWO,update:w=>w.end},{easing:d,name:At.attributeNames.thickness,size:P.TWO,update:w=>w.thickness},{name:At.attributeNames.depth,size:P.ONE,update:w=>[w.depth]},i===fn.LINE?{easing:u,name:At.attributeNames.control,size:P.FOUR,update:w=>[0,0,0,0]}:null,i===fn.BEZIER?{easing:u,name:At.attributeNames.control,size:P.FOUR,update:w=>[w.control[0][0],w.control[0][1],0,0]}:null,i===fn.BEZIER2?{easing:u,name:At.attributeNames.control,size:P.FOUR,update:w=>Y0(w.control)}:null],uniforms:[{name:"scaleFactor",size:R.ONE,update:w=>[e()]},{name:"layerOpacity",size:R.ONE,update:w=>[this.props.opacity===void 0?1:this.props.opacity]}],vertexAttributes:[{name:"vertex",size:Ge.THREE,update:w=>[g[w],m[w],p*2]}],vertexCount:p*2+2,vs:T.shader}}getMaterialOptions(){return rt.transparentShapeBlending}};let cs=At;f(cs,"defaultProps",{broadphase:il.ALL,data:new pe,key:"none",scaleType:os.NONE,type:fn.LINE}),f(cs,"attributeNames",{control:"control",depth:"depth",end:"end",endColor:"endColor",start:"start",startColor:"startColor",thickness:"thickness"});var K0=Object.defineProperty,Z0=Object.getOwnPropertyDescriptor,Pi=(n,t,e,i)=>{for(var r=i>1?void 0:i?Z0(t,e):t,s=n.length-1,a;s>=0;s--)(a=n[s])&&(r=(i?a(t,e,r):a(r))||r);return i&&r&&K0(t,e,r),r};const Tf=class extends Ye{constructor(t){super(t);f(this,"control",[[0,0],[0,0]]);f(this,"depth",0);f(this,"end",[0,0]);f(this,"endColor",[1,1,1,1]);f(this,"start",[0,0]);f(this,"startColor",[1,1,1,1]);f(this,"thickness",[1,1]);Qe(this,Tf),this.startColor=t.startColor||this.startColor,this.endColor=t.endColor||this.endColor,this.control=t.control||this.control,this.depth=t.depth||this.depth,this.end=t.end||this.end,this.thickness=t.thickness||this.thickness,this.start=t.start||this.start}get length(){const t=[this.end[0]-this.start[0],this.end[1]-this.start[1]];return Math.sqrt(t[0]*t[0]+t[1]*t[1])}get midpoint(){return 0}get perpendicular(){const t=this.length;return[(this.end[1]-this.start[1])/t,-(this.end[0]-this.start[0])/t]}setEdgeThickness(t){this.thickness=[t,t]}setColor(t){this.startColor=Dt(t),this.endColor=Dt(t)}};let oi=Tf;Pi([L],oi.prototype,"control",2),Pi([L],oi.prototype,"depth",2),Pi([L],oi.prototype,"end",2),Pi([L],oi.prototype,"endColor",2),Pi([L],oi.prototype,"start",2),Pi([L],oi.prototype,"startColor",2),Pi([L],oi.prototype,"thickness",2);const Re=Ie("video");function J0(n){Re.enabled&&(n.addEventListener("abort",()=>Re("abort")),n.addEventListener("canplay",()=>Re("canplay")),n.addEventListener("canplaythrough",()=>Re("canplaythrough")),n.addEventListener("durationchange",()=>Re("durationchange")),n.addEventListener("emptied",()=>Re("emptied")),n.addEventListener("ended",()=>Re("ended")),n.addEventListener("error",()=>Re("error")),n.addEventListener("loadeddata",()=>Re("loadeddata")),n.addEventListener("loadedmetadata",()=>Re("loadedmetadata")),n.addEventListener("loadstart",()=>Re("loadstart")),n.addEventListener("pause",()=>Re("pause")),n.addEventListener("play",()=>Re("play")),n.addEventListener("playing",()=>Re("playing")),n.addEventListener("progress",()=>Re("progress")),n.addEventListener("ratechange",()=>Re("ratechange")),n.addEventListener("seeked",()=>Re("seeked")),n.addEventListener("seeking",()=>Re("seeking")),n.addEventListener("stalled",()=>Re("stalled")),n.addEventListener("suspend",()=>Re("suspend")),n.addEventListener("timeupdate",()=>Re("timeupdate")),n.addEventListener("volumechange",()=>Re("volumechange")),n.addEventListener("waiting",()=>Re("waiting")))}const ev=`precision highp float;

varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  gl_FragColor = texture2D(imageAtlas, texCoord) * vertexColor;
  gl_FragColor = gl_FragColor * gl_FragColor.a;
}
`,tv=`precision highp float;

varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  // Destructure the normal information
  float normal = normals.x;
  float side = normals.y;
  // Calculate the vertex before moving it to it's position
  vec2 vertex = vec2(side, float(normal == 1.0f)) * size - anchor;
  // Rotate the vertex by the rotation
  float crotation = cos(rotation);
  float srotation = sin(rotation);
  vertex = vec2(crotation * vertex.x - srotation * vertex.y, srotation * vertex.x + crotation * vertex.y);
  // Now move the vertex to the correct location (this should place the anchor
  // point of the image ON the location specified)
  vertex += location;

  // Finalize the projection of the vertex
  gl_Position = clipSpace(vec3(vertex, depth));
  // Outputs: Make sure our information for the fragment shader is ready
  // Get the tex coord from our inject texture info
  texCoord = texture.xy + ((texture.zw - texture.xy) * vec2(side, float(normal == -1.0f)));
  // Apply the image's tint as a tint to the image
  vertexColor = tint;
}
`,nv=`precision highp float;



varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  // Figure out the size of the image as it'd show on the screen
  vec3 screenSize = cameraSpaceSize(vec3(size, 1.0));
  // Do the test for when the image is larger on the screen than the font size
  bool largerOnScreen = screenSize.y > size.y;

  // Determines if a scale mode should be used or not for the vertex
  float useScaleMode = float(
    (
      scaling == 3.0 ||                  // NEVER mode - keep the image the same size always
      (largerOnScreen && scaling == 2.0) // BOUND_MAX mode - only if we're larger than the font size do we scale down
    ) &&
    scaling != 1.0                       // ALWAYS mode - the image stays completely in world space allowing it to scale freely
  );
  // If zooms are unequal, assume one is filtered to be 1.0
  float unequalZooms = float(cameraScale2D.x != cameraScale2D.y);

  // Destructure the normal information
  float normal = normals.x;
  float side = normals.y;

  // Get the location of the anchor in world space
  vec2 worldAnchor = location + anchor;

  // Get the tex coord from our inject texture info
  texCoord = texture.xy + ((texture.zw - texture.xy) * vec2(side, float(normal == -1.0)));
  // Apply the image's tint as a tint to the image
  vertexColor = tint;

  // Correct aspect ratio.
  vec2 adjustedSize = mix(
    size,
    (size * cameraScale2D.yx),
    unequalZooms
  );

  vec2 adjustedAnchor = mix(
    anchor,
    (anchor * cameraScale2D.yx),
    unequalZooms
  );

  vec2 vertex = vec2(side, float(normal == 1.0)) * adjustedSize + location - adjustedAnchor;

  // See how scaled the size on screen will be from the actual height of the image
  float imageScreenScale = mix(
    screenSize.y / adjustedSize.y,
    screenSize.x / adjustedSize.x,
    float((cameraScale2D.x < 1.0) || (cameraScale2D.x > 1.0))
  );

  // If our screen rendering is larger than the size the image is supposed to be, then we automagically
  // scale down our image to stay the correct size, centered on the anchor point
  vec2 anchorToVertex = vertex - location;

  // We now choose between keeping the same image size or keeping it in world space
  vertex = mix(
    // This option keeps the image size in world space
    vertex,
    // This option counters the scaling of the image on the screen keeping it a static size
    (anchorToVertex / imageScreenScale) + location,
    // This is the flag determining if a scale mode should be applied to the vertex
    useScaleMode
  );

  gl_Position = clipSpace(vec3(vertex, depth));
}
`,En=class extends Be{constructor(t,e,i){super(t,e,i)}initShader(){const t=this.props.animate||{},{tint:e,location:i,size:r,rotation:s}=t,a={0:1,1:1,2:-1,3:1,4:-1,5:-1},o={0:0,1:0,2:0,3:1,4:1,5:1};return{fs:ev,instanceAttributes:[this.props.enableRotation?{easing:s,name:En.attributeNames.rotation,size:P.ONE,update:c=>[c.rotation]}:null,{easing:i,name:En.attributeNames.location,size:P.TWO,update:c=>c.origin},{name:En.attributeNames.anchor,size:P.TWO,update:c=>[c.anchor.x||0,c.anchor.y||0]},{easing:r,name:En.attributeNames.size,size:P.TWO,update:c=>[c.width,c.height]},{name:En.attributeNames.depth,size:P.ONE,update:c=>[c.depth]},{name:En.attributeNames.scaling,size:P.ONE,update:c=>[c.scaling]},{name:En.attributeNames.texture,resource:{key:()=>this.props.atlas||"",name:"imageAtlas"},update:c=>(c.source,c.request?this.resource.request(this,c,c.request):(console.warn("An image utilizing the image-render-layer does not have its request specified yet.","The image-render-layer does NOT manage requests and should be handled before this layer deals with the instance"),[0,0,0,0]))},{easing:e,name:En.attributeNames.tint,size:P.FOUR,update:c=>c.tint}],uniforms:[{name:"scaleFactor",size:R.ONE,update:c=>[1]}],vertexAttributes:[{name:"normals",size:Ge.TWO,update:c=>[a[c],o[c]]}],vertexCount:6,vs:this.props.enableRotation?tv:nv}}getMaterialOptions(){return rt.transparentImageBlending}};let ls=En;f(ls,"defaultProps",{key:"",data:new pe}),f(ls,"attributeNames",{location:"location",anchor:"anchor",size:"size",depth:"depth",scaling:"scaling",texture:"texture",tint:"tint",rotation:"rotation"});function us(n){return n&&n.videoSrc}const Aa=new Image;Aa.src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=";class yf extends Be{constructor(){super(...arguments);f(this,"childProvider",new pe);f(this,"imageToResource",new Map);f(this,"propertyIds");f(this,"sourceToRequest",new Map);f(this,"sourceToVideo",new Map);f(this,"usingVideo",new Map);f(this,"waitingForVideo",new Map);f(this,"waitForVideoSource",new Map);f(this,"originalOnReadyCallbacks",new Map)}childLayers(){return[Ai(ls,{...this.props,key:`${this.props.key}.image-render-layer`})]}destroy(){super.destroy(),this.sourceToVideo.forEach(e=>{e.pause(),this.sourceToVideo.clear(),this.waitingForVideo.clear(),this.waitForVideoSource.clear()})}draw(){const e=this.resolveChanges(!0);if(this.updateAnimationState(),e.length<=0)return;this.propertyIds||(this.propertyIds=this.getInstanceObservableIds(e[0][0],["source"]));const{source:i}=this.propertyIds;for(let s=0,a=e.length;s<a;++s){const[o,c,l]=e[s];switch(c){case Te.CHANGE:if(l[i]!==void 0){const u=this.imageToResource.get(o);let d=this.getAtlasSource(o);if(d===u)break;if(u instanceof HTMLVideoElement){const p=this.waitForVideoSource.get(o);if(p){this.waitForVideoSource.delete(o);const m=this.waitingForVideo.get(p);m&&m.delete(o)}let g=this.usingVideo.get(u.getAttribute("data-source")||"");g||(g=new Set),g.delete(o),g.size<=0&&this.sourceToVideo.delete(u.getAttribute("data-source")||""),o.onReady=this.originalOnReadyCallbacks.get(o)}if(us(o.source)&&(this.prepareVideo(o,o.source),d=this.getAtlasSource(o),ni(this.usingVideo,o.source.videoSrc,new Set).add(o)),this.imageToResource.set(o,d),this.resource.request(this,o,tr({key:this.props.atlas||"",disposeResource:!0,source:u})),d){let p=this.sourceToRequest.get(d);(!p||p.texture&&!p.texture.isValid)&&(p=tr({key:this.props.atlas||"",source:d,rasterizationScale:this.props.rasterizationScale}),this.sourceToRequest.set(d,p)),o.request=p,this.resource.request(this,o,p)}}break;case Te.INSERT:if(o.source){let u=this.getAtlasSource(o);us(o.source)&&(this.prepareVideo(o,o.source),u=this.getAtlasSource(o),ni(this.usingVideo,o.source.videoSrc,new Set).add(o));let d=this.sourceToRequest.get(u);(!d||d.texture&&!d.texture.isValid)&&(d=tr({key:this.props.atlas||"",source:u,rasterizationScale:this.props.rasterizationScale}),this.sourceToRequest.set(u,d)),o.request=d}break;case Te.REMOVE:{const u=this.getAtlasSource(o);if(this.imageToResource.delete(o),us(o.source)){const d=this.waitForVideoSource.get(o);if(d){this.waitForVideoSource.delete(o);const g=this.waitingForVideo.get(d);g&&g.delete(o)}let p=this.usingVideo.get(o.source.videoSrc);p||(p=new Set),p.delete(o),p.size<=0&&this.sourceToVideo.delete(o.source.videoSrc),this.originalOnReadyCallbacks.delete(o)}this.resource.request(this,o,tr({key:this.props.atlas||"",disposeResource:!0,source:u}));break}}}const r=[];this.usingVideo.forEach((s,a)=>{s.size<=0&&r.push(a)});for(let s=0,a=r.length;s<a;++s){const o=r[s];this.usingVideo.delete(o),this.sourceToVideo.delete(o)}}getAtlasSource(e){return us(e.source)?this.sourceToVideo.get(e.source.videoSrc)||Aa:e.source}prepareVideo(e,i){const r=this.sourceToVideo.get(i.videoSrc);if(this.originalOnReadyCallbacks.get(e)||this.originalOnReadyCallbacks.set(e,e.onReady),r){const m=this.waitingForVideo.get(i.videoSrc);if(m)m.add(e),this.waitForVideoSource.set(e,i.videoSrc),e.onReady=void 0,e.source=Aa,e.videoLoad=()=>{r.load(),i.autoPlay&&r.play()};else{const v=this.originalOnReadyCallbacks.get(e)||e.onReady;if(!v)return;e.onReady=b=>{v(b,r)}}return}const a=document.createElement("video");this.sourceToVideo.set(i.videoSrc,a),a.setAttribute("data-source",i.videoSrc),J0(a);const o=new $e,c=new $e,l=()=>{a.removeEventListener("loadedmetadata",d),a.removeEventListener("loadeddata",u),a.removeEventListener("error",p),this.waitingForVideo.delete(i.videoSrc),this.waitForVideoSource.delete(e)},u=()=>{c.resolve()},d=()=>{o.resolve()},p=m=>{let v;m.path&&m.path[0]&&(v=m.path[0].error),m.originalTarget&&(v=m.originalTarget.error),console.warn("There was an error loading the video resource to the atlas texture context"),console.warn(v),o.reject({}),c.reject({})};a.addEventListener("loadedmetadata",d),a.addEventListener("loadeddata",u),a.addEventListener("error",p),e.onReady=void 0,ni(this.waitingForVideo,i.videoSrc,new Set).add(e),this.waitForVideoSource.set(e,i.videoSrc),e.source=Aa,e.videoLoad=()=>{a.load(),i.autoPlay&&a.play()},a.muted=!0,a.src=i.videoSrc,Promise.all([o.promise,c.promise]).then(()=>{a.currentTime=0,i.autoPlay&&a.play();const m=this.waitingForVideo.get(i.videoSrc);m&&m.forEach(v=>{v.source=i,v.onReady=this.originalOnReadyCallbacks.get(v)}),l()}).catch(()=>{l()})}updateAnimationState(){let e=!1;this.sourceToVideo.forEach(i=>{i.paused||(e=!0)}),this.alwaysDraw=this.usingVideo.size>0&&e}initShader(){return null}}f(yf,"defaultProps",{atlas:"default",key:"",data:new pe});var iv=Object.defineProperty,rv=Object.getOwnPropertyDescriptor,Fn=(n,t,e,i)=>{for(var r=i>1?void 0:i?rv(t,e):t,s=n.length-1,a;s>=0;s--)(a=n[s])&&(r=(i?a(t,e,r):a(r))||r);return i&&r&&iv(t,e,r),r};const{max:sv}=Math,av={[U.TopLeft]:(n,t)=>{n.x=-n.padding,n.y=-n.padding},[U.TopMiddle]:(n,t)=>{n.x=t.width/2,n.y=-n.padding},[U.TopRight]:(n,t)=>{n.x=t.width+n.padding,n.y=-n.padding},[U.MiddleLeft]:(n,t)=>{n.x=-n.padding,n.y=t.height/2},[U.Middle]:(n,t)=>{n.x=t.width/2,n.y=t.height/2},[U.MiddleRight]:(n,t)=>{n.x=t.width+n.padding,n.y=t.height/2},[U.BottomLeft]:(n,t)=>{n.x=-n.padding,n.y=t.height+n.padding},[U.BottomMiddle]:(n,t)=>{n.x=t.width/2,n.y=t.height+n.padding},[U.BottomRight]:(n,t)=>{n.x=t.width+n.padding,n.y=t.height+n.padding},[U.Custom]:(n,t)=>{n.x=n.x||0,n.y=n.y||0}},Ef=class extends Ye{constructor(t){super(t);f(this,"tint",[0,0,0,1]);f(this,"depth",0);f(this,"height",1);f(this,"origin",[0,0]);f(this,"scaling",dn.BOUND_MAX);f(this,"source");f(this,"width",1);f(this,"rotation",0);f(this,"onError");f(this,"onReady");f(this,"request");f(this,"sourceWidth",0);f(this,"sourceHeight",0);f(this,"_anchor",{padding:0,type:U.TopLeft,x:0,y:0});f(this,"videoLoad",ks);Qe(this,Ef),this.depth=t.depth||this.depth,this.tint=t.tint||this.tint,this.scaling=t.scaling||this.scaling,this.origin=t.origin||this.origin,this.width=t.width||1,this.height=t.height||1,this.source=t.source,this.rotation=t.rotation||0,this.onReady=t.onReady,t.anchor&&this.setAnchor(t.anchor)}get maxSize(){return sv(this.width,this.height)}set maxSize(t){const e=this.width/this.height;this.width=t*e,this.height=t}get anchor(){return this._anchor}resourceTrigger(){this.source=this.source,this.request&&this.request.texture&&(this.sourceWidth=this.request.texture.pixelWidth,this.sourceHeight=this.request.texture.pixelHeight),this.onReady&&this.onReady(this)}setAnchor(t){const e={padding:t.padding||0,type:t.type,x:t.x||0,y:t.y||0};av[e.type](e,this),this._anchor=e}};let pn=Ef;Fn([L],pn.prototype,"tint",2),Fn([L],pn.prototype,"depth",2),Fn([L],pn.prototype,"height",2),Fn([L],pn.prototype,"origin",2),Fn([L],pn.prototype,"scaling",2),Fn([L],pn.prototype,"source",2),Fn([L],pn.prototype,"width",2),Fn([L],pn.prototype,"rotation",2),Fn([L],pn.prototype,"_anchor",2);var ov=Object.defineProperty,cv=Object.getOwnPropertyDescriptor,kn=(n,t,e,i)=>{for(var r=i>1?void 0:i?cv(t,e):t,s=n.length-1,a;s>=0;s--)(a=n[s])&&(r=(i?a(t,e,r):a(r))||r);return i&&r&&ov(t,e,r),r};const rl=class extends Ye{constructor(t){super(t);f(this,"anchor",[0,0]);f(this,"character","a");f(this,"color",[1,1,1,1]);f(this,"depth",0);f(this,"fontScale",1);f(this,"maxScale",1);f(this,"offset",[0,0]);f(this,"origin",[0,0]);f(this,"padding",[0,0]);f(this,"parentLabel");f(this,"onReady");f(this,"request");Qe(this,rl),this.origin=t.origin||this.origin,this.offset=t.offset||this.offset,this.character=t.character||this.character,this.color=t.color||this.color,this.maxScale=t.maxScale||this.maxScale,this.padding=t.padding||this.padding,this.anchor=t.anchor||this.anchor,this.onReady=t.onReady}clone(){const t=new rl(this);t.onReady=this.onReady,t.request=this.request}resourceTrigger(){this.offset=this.offset,this.origin=this.origin,this.character=this.character,this.color=this.color,this.onReady&&this.onReady(this)}};let Rt=rl;kn([L],Rt.prototype,"anchor",2),kn([L],Rt.prototype,"character",2),kn([L],Rt.prototype,"color",2),kn([L],Rt.prototype,"depth",2),kn([L],Rt.prototype,"fontScale",2),kn([L],Rt.prototype,"maxScale",2),kn([L],Rt.prototype,"offset",2),kn([L],Rt.prototype,"origin",2),kn([L],Rt.prototype,"padding",2);const _f=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  vec4 texColor = texture2D(fontMap, texCoord);
  if (texColor.r <= 0.0) discard;
  texColor.a = texColor.r;
  gl_FragColor = texColor * vertexColor;
}
`,xf=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  // Calculate in the anchor, the origin, glyph offset, and the quad pushout to make our quad geometry
  vec2 pushOut = normals * glyphSize * fontScale;
  vec3 position = vec3(origin + padding - anchor + offset + pushOut, depth);
  gl_Position = clipSpace(position);

  // Get the atlas position of the texture information
  texCoord = texture.xy + (texture.zw - texture.xy) * normals;
  // Apply the color of the glyph
  vertexColor = color * color.a;
}
`,lv=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  vec4 texColor = texture2D(fontMap, texCoord);
  if (texColor.r <= 0.0) discard;
  texColor.a = texColor.r;
  gl_FragColor = texColor * vertexColor;
}
`,uv=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  vec2 scale = fontScale * cameraScale2D.xy;
  float scaleBy = max(scale.x, scale.y) / maxScale;
  vec2 pushOut = normals * glyphSize * fontScale;

  float vx = mix(
    (-anchor.x + offset.x + pushOut.x),
    (-anchor.x + offset.x + pushOut.x) / scaleBy,
    float(scale.x >= maxScale)
  );

  float vy = mix(
    (-anchor.y + offset.y + pushOut.y),
    (-anchor.y + offset.y + pushOut.y) / scaleBy,
    float(scale.y >= maxScale)
  );

  // Calculate in the anchor, the origin, glyph offset, and the quad pushout to make our quad geometry
  vec3 position = vec3(origin + padding + vec2(vx, vy), depth);
  gl_Position = clipSpace(position);

  // Get the atlas position of the texture information
  texCoord = texture.xy + (texture.zw - texture.xy) * normals;
  // Apply the color of the glyph
  vertexColor = color * color.a;
}
`,hv=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  vec4 texColor = texture2D(fontMap, texCoord);
  if (texColor.r <= 0.0) discard;
  texColor.a = texColor.r;
  gl_FragColor = texColor * vertexColor;
}
`,dv=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  // Calculate in the anchor, the origin, glyph offset, and the quad pushout to make our quad geometry
  vec2 pushOut = normals * glyphSize * fontScale;
  vec3 position = vec3(origin + padding + (-anchor + offset + pushOut) / cameraScale2D.xy, depth);
  gl_Position = clipSpace(position);

  // Get the atlas position of the texture information
  texCoord = texture.xy + (texture.zw - texture.xy) * normals;
  // Apply the color of the glyph
  vertexColor = color * color.a;
}
`,fv=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  vec4 texColor = texture2D(fontMap, texCoord);
  if (texColor.r <= 0.0) discard;
  texColor.a = texColor.r;
  gl_FragColor = texColor * vertexColor;
}
`,pv=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  // Calculate in the anchor, the origin, glyph offset, and the quad pushout to make our quad geometry
  vec2 pushOut = normals * glyphSize * fontScale;
  vec3 position = vec3(origin + padding + offset + pushOut, depth);
  gl_Position = clipSpace(position);

  // Get the atlas position of the texture information
  texCoord = texture.xy + (texture.zw - texture.xy) * normals;
  // Apply the color of the glyph
  vertexColor = color * color.a;
}
`,gv=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  vec4 texColor = texture2D(fontMap, texCoord);
  if (texColor.r <= 0.0) discard;
  texColor.a = texColor.r;
  gl_FragColor = texColor * vertexColor;
}
`,mv=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  vec2 scale = fontScale * cameraScale2D.xy;
  float scaleBy = max(scale.x, scale.y) / maxScale;
  vec2 pushOut = normals * glyphSize * fontScale;

  float vx = mix(
    (origin.x + padding.x + offset.x + pushOut.x),
    origin.x + anchor.x + (padding.x - anchor.x + offset.x + pushOut.x) / scaleBy,
    float(scale.x >= maxScale)
  );

  float vy = mix(
    (origin.y + padding.y + offset.y + pushOut.y),
    origin.y + anchor.y + (padding.y - anchor.y + offset.y + pushOut.y) / scaleBy,
    float(scale.y >= maxScale)
  );

  // Calculate in the anchor, the origin, glyph offset, and the quad pushout to make our quad geometry
  vec3 position = vec3(vec2(vx, vy), depth);
  gl_Position = clipSpace(position);

  // Get the atlas position of the texture information
  texCoord = texture.xy + (texture.zw - texture.xy) * normals;
  // Apply the color of the glyph
  vertexColor = color * color.a;
}
`,vv=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  vec4 texColor = texture2D(fontMap, texCoord);
  if (texColor.r <= 0.0) discard;
  texColor.a = texColor.r;
  gl_FragColor = texColor * vertexColor;
}
`,bv=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  // Calculate in the anchor, the origin, glyph offset, and the quad pushout to make our quad geometry
  vec2 pushOut = normals * glyphSize * fontScale;
  vec3 position = vec3(origin + anchor + (padding - anchor + offset + pushOut) / cameraScale2D.xy , depth);
  gl_Position = clipSpace(position);

  // Get the atlas position of the texture information
  texCoord = texture.xy + (texture.zw - texture.xy) * normals;
  // Apply the color of the glyph
  vertexColor = color * color.a;
}
`,Ui=class extends Be{constructor(){super(...arguments);f(this,"glyphRequests",{})}initShader(){const e=this.props.animate||{},{anchor:i,color:r,offset:s,origin:a}=e,o={0:[0,0],1:[0,0],2:[1,0],3:[0,1],4:[1,1],5:[1,1]},c={name:"texture",resource:{key:()=>this.props.resourceKey||"",name:"fontMap"},update:g=>{const m=g.character;return(!g.request||g.character!==g.request.character)&&(this.glyphRequests[g.character]?g.request=this.glyphRequests[g.character]:(g.request=Ci({key:this.props.resourceKey||"",character:m}),this.glyphRequests[g.character]=g.request),g.request.fontMap&&g.onReady&&g.onReady(g)),g.request.fetch=Mi.TEXCOORDS,this.resource.request(this,g,g.request)}},l={name:"glyphSize",parentAttribute:c,resource:{key:()=>this.props.resourceKey||"",name:"fontMap"},size:P.TWO,update:g=>{const m=g.character;return(!g.request||g.character!==g.request.character)&&(this.glyphRequests[g.character]?g.request=this.glyphRequests[g.character]:(g.request=Ci({key:this.props.resourceKey||"",character:m}),this.glyphRequests[g.character]=g.request),g.request.fontMap&&g.onReady&&g.onReady(g)),g.request.fetch=Mi.IMAGE_SIZE,this.resource.request(this,g,g.request)}};c.childAttributes=[l];let u,d;switch(this.props.scaleMode||dn.ALWAYS){case dn.BOUND_MAX:{u=this.props.inTextArea?gv:lv,d=this.props.inTextArea?mv:uv;break}case dn.NEVER:{u=this.props.inTextArea?hv:vv,d=this.props.inTextArea?bv:dv;break}case dn.ALWAYS:{u=this.props.inTextArea?fv:_f,d=this.props.inTextArea?pv:xf;break}default:{u=_f,d=xf;break}}return{fs:u,instanceAttributes:[{easing:r,name:Ui.attributeNames.color,size:P.FOUR,update:g=>g.color},{name:Ui.attributeNames.depth,size:P.ONE,update:g=>[g.depth]},{name:"fontScale",size:P.ONE,update:g=>[g.fontScale]},{easing:i,name:Ui.attributeNames.anchor,size:P.TWO,update:g=>g.anchor},{easing:a,name:Ui.attributeNames.origin,size:P.TWO,update:g=>g.origin},{easing:s,name:Ui.attributeNames.offset,size:P.TWO,update:g=>g.offset},{name:"padding",size:P.TWO,update:g=>g.padding},{name:"maxScale",size:P.ONE,update:g=>[g.maxScale]},l,c],uniforms:[],vertexAttributes:[{name:"normals",size:Ge.TWO,update:g=>o[g]}],vertexCount:6,vs:d}}draw(){super.draw()}getMaterialOptions(){return Object.assign({},rt.transparentImageBlending,{depthTest:!1})}willUpdateProps(e){e.resourceKey!==this.props.resourceKey&&(Object.values(this.glyphRequests).forEach(i=>{delete i.fontMap,i.key=e.resourceKey||""}),this.rebuildLayer())}};let ur=Ui;f(ur,"defaultProps",{key:"",data:new pe,resourceKey:"No resource specified"}),f(ur,"attributeNames",{color:"color",depth:"depth",anchor:"anchor",origin:"origin",offset:"offset"});const wv="...",Rf={[U.TopLeft]:(n,t)=>{n.x=0,n.y=0},[U.TopMiddle]:(n,t)=>{n.x=t.size[0]/2,n.y=0},[U.TopRight]:(n,t)=>{n.x=t.size[0],n.y=0},[U.MiddleLeft]:(n,t)=>{n.x=0,n.y=t.size[1]/2},[U.Middle]:(n,t)=>{n.x=t.size[0]/2,n.y=t.size[1]/2},[U.MiddleRight]:(n,t)=>{n.x=t.size[0],n.y=t.size[1]/2},[U.BottomLeft]:(n,t)=>{n.x=0,n.y=t.size[1]},[U.BottomMiddle]:(n,t)=>{n.x=t.size[0]/2,n.y=t.size[1]},[U.BottomRight]:(n,t)=>{n.x=t.size[0],n.y=t.size[1]},[U.Custom]:(n,t)=>{n.x=n.x||0,n.y=n.y||0}},ci=[[-1,-1],[0,-1],[1,-1],[-1,0],[0,0],[1,0],[-1,1],[0,1],[1,1]].map(n=>{const t=Math.sqrt(Gi(n,n));return Ce(n,1/-t)}),Af={[U.TopLeft]:n=>{n.paddingDirection=Ce(ci[0],n.padding)},[U.TopMiddle]:n=>{n.paddingDirection=Ce(ci[1],n.padding)},[U.TopRight]:n=>{n.paddingDirection=Ce(ci[2],n.padding)},[U.MiddleLeft]:n=>{n.paddingDirection=Ce(ci[3],n.padding)},[U.Middle]:n=>{n.paddingDirection=[0,0]},[U.MiddleRight]:n=>{n.paddingDirection=Ce(ci[5],n.padding)},[U.BottomLeft]:n=>{n.paddingDirection=Ce(ci[6],n.padding)},[U.BottomMiddle]:n=>{n.paddingDirection=Ce(ci[7],n.padding)},[U.BottomRight]:n=>{n.paddingDirection=Ce(ci[8],n.padding)},[U.Custom]:n=>{n.paddingDirection=n.paddingDirection}};function We(n){if(n)return t=>{n({...t,instances:t.instances.map(e=>e.parentLabel).filter(de)})}}class sl extends Be{constructor(){super(...arguments);f(this,"fullUpdate",!1);f(this,"glyphProvider",new pe);f(this,"labelToGlyphs",new Map);f(this,"labelToKerningRequest",new Map);f(this,"labelWaitingOnGlyph",new Map);f(this,"propertyIds");f(this,"truncationKerningRequest");f(this,"truncationWidth",-1);f(this,"handleGlyphReady",e=>{if(!e.parentLabel){delete e.onReady;return}const i=e.parentLabel,r=this.labelWaitingOnGlyph.get(e.parentLabel);if(r&&r.has(e)&&(r.delete(e),r.size<=0)){const s=i.onReady;s&&s(i)}})}childLayers(){return[Ai(this.props.customGlyphLayer||ur,{animate:this.props.animate,data:this.glyphProvider,key:`${this.id}.glyphs`,resourceKey:this.props.resourceKey,scaleMode:this.props.scaleMode||dn.BOUND_MAX,inTextArea:this.props.inTextArea,picking:this.props.picking,onMouseClick:We(this.props.onMouseClick),onMouseUp:We(this.props.onMouseUp),onMouseDown:We(this.props.onMouseDown),onMouseOut:We(this.props.onMouseOut),onMouseOver:We(this.props.onMouseOver),onMouseMove:We(this.props.onMouseMove),onMouseUpOutside:We(this.props.onMouseUpOutside),onTap:We(this.props.onTap),onTouchDown:We(this.props.onTouchDown),onTouchUp:We(this.props.onTouchUp),onTouchUpOutside:We(this.props.onTouchUpOutside),onTouchMove:We(this.props.onTouchMove),onTouchOut:We(this.props.onTouchOut),onTouchOver:We(this.props.onTouchOver),onTouchAllEnd:We(this.props.onTouchAllEnd),onTouchAllOut:We(this.props.onTouchAllOut)})]}draw(){const e=this.resolveChanges();if(e.length<=0)return;if(!this.propertyIds){const p=e[0][0];this.propertyIds=this.getInstanceObservableIds(p,["text","active","anchor","color","origin","fontSize","maxWidth","maxScale","letterSpacing"])}const{text:i,active:r,anchor:s,color:a,origin:o,fontSize:c,maxWidth:l,maxScale:u,letterSpacing:d}=this.propertyIds;for(let p=0,g=e.length;p<g;++p){const[m,v,b]=e[p];switch(v){case Te.CHANGE:if(!this.labelToGlyphs.get(m)){this.insert(m);continue}b[i]!==void 0?(this.invalidateRequest(m),this.layoutGlyphs(m)):b[r]!==void 0&&(m.active?(this.layoutGlyphs(m),this.showGlyphs(m)):this.hideGlyphs(m)),b[s]&&this.updateAnchor(m),b[a]!==void 0&&this.updateGlyphColors(m),b[o]!==void 0&&this.updateGlyphOrigins(m),b[u]!==void 0&&this.updateGlyphMaxScales(m),b[c]!==void 0&&(this.invalidateRequest(m),this.layoutGlyphs(m)),b[l]!==void 0&&(this.invalidateRequest(m),this.layoutGlyphs(m)),b[d]!==void 0&&(this.invalidateRequest(m),this.layoutGlyphs(m));break;case Te.INSERT:this.insert(m);break;case Te.REMOVE:{const T=this.labelToGlyphs.get(m);if(T){for(let w=0,E=T.length;w<E;++w)this.glyphProvider.remove(T[w]);this.labelToGlyphs.delete(m),this.labelToKerningRequest.delete(m),this.labelWaitingOnGlyph.delete(m)}break}}}}insert(e){e.preload?this.props.data.remove(e):this.labelToGlyphs.get(e)||this.labelToGlyphs.set(e,[]),this.layoutGlyphs(e)}hideGlyphs(e){const i=this.labelToGlyphs.get(e);if(i)for(let r=0,s=i.length;r<s;++r)this.glyphProvider.remove(i[r])}initShader(){return null}invalidateRequest(e){this.labelToKerningRequest.delete(e)}layoutGlyphs(e){if(!this.updateKerning(e)||!e.active)return;const i=this.labelToKerningRequest.get(e);if(!i||!i.fontMap)return;const r=i.metrics;if(!r||!r.layout)return;const s=r.layout;this.updateGlyphs(e,s);const a=e.glyphs;e.size=s.size,Rf[e.anchor.type](e.anchor,e),Af[e.anchor.type](e.anchor);const o=e.anchor,c=e.anchor.paddingDirection;for(let l=0,u=Math.min(s.positions.length,a.length);l<u;++l){const d=s.positions[l],p=a[l];p.offset=d,p.fontScale=s.fontScale,p.anchor=[o.x||0,o.y||0],p.origin=Es(e.origin),p.padding=c||[0,0],p.maxScale=e.maxScale}}managesInstance(e){return!!this.labelToGlyphs.get(e)}showGlyphs(e){const i=this.labelToGlyphs.get(e);if(i)for(let r=0,s=i.length;r<s;++r)this.glyphProvider.add(i[r])}updateAnchor(e){const i=e.glyphs;if(!i)return;Rf[e.anchor.type](e.anchor,e),Af[e.anchor.type](e.anchor);const r=e.anchor,s=e.anchor.paddingDirection;for(let a=0,o=i.length;a<o;++a)i[a].anchor=[r.x||0,r.y||0],i[a].padding=s||[0,0]}updateGlyphs(e,i){let r=this.labelToGlyphs.get(e);r||(r=[],this.labelToGlyphs.set(e,r));let s=this.labelWaitingOnGlyph.get(e);s||(s=new Set,this.labelWaitingOnGlyph.set(e,s));for(let a=0,o=Math.min(r.length,i.glyphs.length);a<o;++a){const c=r[a];c.character!==i.glyphs[a]&&(c.character=i.glyphs[a],(!c.request||!c.request.fontMap||!c.request.fontMap.glyphMap[c.character])&&s.add(c))}if(r.length<i.glyphs.length){let a=0;for(let o=r.length,c=i.glyphs.length;o<c;++o,++a){const l=i.glyphs[o],u=new Rt({character:l,color:e.color,origin:e.origin,maxScale:e.maxScale,onReady:this.handleGlyphReady});u.parentLabel=e,r.push(u),e.active&&this.glyphProvider.add(u),s.add(u)}}else if(r.length>i.glyphs.length){for(let a=i.glyphs.length,o=r.length;a<o;++a){const c=r[a];this.glyphProvider.remove(c)}for(;r.length>i.glyphs.length;)r.pop()}e.glyphs=r}updateGlyphColors(e){const i=e.glyphs;if(i)for(let r=0,s=i.length;r<s;++r)i[r].color=Dt(e.color)}updateGlyphOrigins(e){const i=e.glyphs;if(!i)return;const r=e.origin;for(let s=0,a=i.length;s<a;++s)i[s].origin=[r[0],r[1]]}updateGlyphMaxScales(e){const i=e.glyphs;if(!i)return;const r=e.maxScale;for(let s=0,a=i.length;s<a;++s)i[s].maxScale=r}updateKerning(e){let i=this.labelToKerningRequest.get(e);const r=e.text;if(i){if(i.kerningPairs&&i.kerningPairs.indexOf(r)>-1)return!!i.fontMap;if(i.fontMap&&!i.fontMap.supportsKerning(r.replace(/\s/g,"")))this.labelToKerningRequest.delete(e),i=void 0;else return!0}if(!i){const s={fontSize:e.fontSize,text:e.text,letterSpacing:e.letterSpacing};return e.maxWidth>0&&(s.maxWidth=e.maxWidth,s.truncation=this.props.truncation||wv),i=Ci({key:this.props.resourceKey||"",character:"",kerningPairs:[r],metrics:s}),e.preload?(e.resourceTrigger=()=>{e.onReady&&e.onReady(e)},this.resource.request(this,e,i)):(this.resource.request(this,e,i,{resource:{type:he.FONT,key:this.props.resourceKey||""}}),this.labelToKerningRequest.set(e,i)),!1}return!0}willUpdateProps(e){e.data!==this.props.data&&delete this.propertyIds,e.scaleMode!==this.props.scaleMode&&this.rebuildLayer(),e.resourceKey!==this.props.resourceKey&&(this.fullUpdate=!0)}}f(sl,"defaultProps",{key:"",data:new pe});var Tv=Object.defineProperty,yv=Object.getOwnPropertyDescriptor,gn=(n,t,e,i)=>{for(var r=i>1?void 0:i?yv(t,e):t,s=n.length-1,a;s>=0;s--)(a=n[s])&&(r=(i?a(t,e,r):a(r))||r);return i&&r&&Tv(t,e,r),r};const If=class extends Ye{constructor(t){super(t);f(this,"color",[0,0,0,1]);f(this,"depth",0);f(this,"fontSize",12);f(this,"maxScale",1);f(this,"maxWidth",0);f(this,"origin",[0,0]);f(this,"scale",1);f(this,"text","");f(this,"letterSpacing",0);f(this,"onReady");f(this,"parentTextArea");f(this,"preload",!1);f(this,"glyphs",[]);f(this,"size",[0,0]);f(this,"truncatedText","");f(this,"anchor",{padding:0,paddingDirection:[0,0],type:U.TopLeft,x:0,y:0});Qe(this,If),this.anchor=t.anchor||this.anchor,this.color=t.color||this.color,this.depth=t.depth||this.depth,this.fontSize=t.fontSize||this.fontSize,this.maxScale=t.maxScale||this.maxScale,this.maxWidth=t.maxWidth||0,this.onReady=t.onReady,this.origin=t.origin,this.preload=t.preload||!1,this.scale=t.scale||this.scale,this.text=t.text||this.text,this.letterSpacing=t.letterSpacing||this.letterSpacing,t.anchor&&this.setAnchor(t.anchor)}getWidth(){return this.size[0]}setAnchor(t){const e={padding:t.padding||0,paddingDirection:t.paddingDirection,type:t.type,x:t.x||0,y:t.y||0};this.anchor=e}subTextGlyphs(t){const e=[],i=this.text.indexOf(t);if(i<0)return e;let r=0;for(let s=0,a=Math.min(this.text.length,i+t.length);s<a;++s)vi(this.text[s])||(r++,s>=i&&e.push(this.glyphs[r]));return e}resourceTrigger(){}};let oe=If;gn([L],oe.prototype,"color",2),gn([L],oe.prototype,"depth",2),gn([L],oe.prototype,"fontSize",2),gn([L],oe.prototype,"maxScale",2),gn([L],oe.prototype,"maxWidth",2),gn([L],oe.prototype,"origin",2),gn([L],oe.prototype,"scale",2),gn([L],oe.prototype,"text",2),gn([L],oe.prototype,"letterSpacing",2),gn([L],oe.prototype,"anchor",2);var Ev=Object.defineProperty,_v=Object.getOwnPropertyDescriptor,Di=(n,t,e,i)=>{for(var r=i>1?void 0:i?_v(t,e):t,s=n.length-1,a;s>=0;s--)(a=n[s])&&(r=(i?a(t,e,r):a(r))||r);return i&&r&&Ev(t,e,r),r},Ia=(n=>(n[n.LEFT=0]="LEFT",n[n.RIGHT=1]="RIGHT",n[n.CENTERED=2]="CENTERED",n))(Ia||{}),mn=(n=>(n[n.NONE=0]="NONE",n[n.CHARACTER=1]="CHARACTER",n[n.WORD=2]="WORD",n))(mn||{}),hr=(n=>(n[n.NEWLINE=0]="NEWLINE",n))(hr||{});const Sf=class extends oe{constructor(t){super(t);f(this,"maxHeight",0);f(this,"lineHeight",0);f(this,"wordWrap",0);f(this,"alignment",0);f(this,"labels",[]);f(this,"newLabels",[]);f(this,"borders",[]);f(this,"oldOrigin");f(this,"padding",[0,0,0,0]);f(this,"borderWidth",6);f(this,"hasBorder",!0);f(this,"spaceWidth",0);Qe(this,Sf),this.color=t.color,this.origin=t.origin,this.oldOrigin=t.origin,this.text=t.text,this.fontSize=t.fontSize||this.fontSize,this.maxWidth=t.maxWidth||this.maxWidth,this.maxHeight=t.maxHeight||this.maxHeight,this.lineHeight=t.lineHeight||this.lineHeight,this.wordWrap=t.wordWrap||this.wordWrap,this.alignment=t.alignment||this.alignment,this.padding=t.padding||this.padding,this.borderWidth=t.borderWidth||this.borderWidth,this.hasBorder=t.hasBorder!==void 0?t.hasBorder:this.hasBorder,this.letterSpacing=t.letterSpacing||this.letterSpacing}};let li=Sf;Di([L],li.prototype,"maxHeight",2),Di([L],li.prototype,"lineHeight",2),Di([L],li.prototype,"wordWrap",2),Di([L],li.prototype,"alignment",2),Di([L],li.prototype,"padding",2),Di([L],li.prototype,"borderWidth",2),Di([L],li.prototype,"hasBorder",2);var xv=Object.defineProperty,Rv=Object.getOwnPropertyDescriptor,vn=(n,t,e,i)=>{for(var r=i>1?void 0:i?Rv(t,e):t,s=n.length-1,a;s>=0;s--)(a=n[s])&&(r=(i?a(t,e,r):a(r))||r);return i&&r&&xv(t,e,r),r};const Av={[U.TopLeft]:(n,t)=>{n.x=-n.padding,n.y=-n.padding},[U.TopMiddle]:(n,t)=>{n.x=t.size[0]/2,n.y=-n.padding},[U.TopRight]:(n,t)=>{n.x=t.size[0]+n.padding,n.y=-n.padding},[U.MiddleLeft]:(n,t)=>{n.x=-n.padding,n.y=t.size[1]/2},[U.Middle]:(n,t)=>{n.x=t.size[0]/2,n.y=t.size[1]/2},[U.MiddleRight]:(n,t)=>{n.x=t.size[0]+n.padding,n.y=t.size[1]/2},[U.BottomLeft]:(n,t)=>{n.x=-n.padding,n.y=t.size[1]+n.padding},[U.BottomMiddle]:(n,t)=>{n.x=t.size[0]/2,n.y=t.size[1]+n.padding},[U.BottomRight]:(n,t)=>{n.x=t.size[0]+n.padding,n.y=t.size[1]+n.padding},[U.Custom]:(n,t)=>{n.x=n.x||0,n.y=n.y||0}},Mf=class extends Ye{constructor(t){super(t);f(this,"color",[0,0,0,1]);f(this,"depth",0);f(this,"maxScale",1);f(this,"scale",1);f(this,"scaling",dn.BOUND_MAX);f(this,"size",[1,1]);f(this,"position",[0,0]);f(this,"outline",0);f(this,"outlineColor",[0,0,0,1]);f(this,"_anchor",{padding:0,type:U.TopLeft,x:0,y:0});Qe(this,Mf),this.depth=t.depth||this.depth,this.color=t.color||this.color,this.scaling=t.scaling||this.scaling,this.position=t.position||this.position,this.size=t.size||this.size,this.outline=t.outline||this.outline,this.outlineColor=t.outlineColor||this.outlineColor,t.anchor&&this.setAnchor(t.anchor)}get anchor(){return this._anchor}setAnchor(t){const e={padding:t.padding||0,type:t.type,x:t.x||0,y:t.y||0};Av[e.type](e,this),this._anchor=e}};let wt=Mf;vn([L],wt.prototype,"color",2),vn([L],wt.prototype,"depth",2),vn([L],wt.prototype,"maxScale",2),vn([L],wt.prototype,"scale",2),vn([L],wt.prototype,"scaling",2),vn([L],wt.prototype,"size",2),vn([L],wt.prototype,"position",2),vn([L],wt.prototype,"outline",2),vn([L],wt.prototype,"outlineColor",2),vn([L],wt.prototype,"_anchor",2);var Iv=Object.defineProperty,Sv=Object.getOwnPropertyDescriptor,al=(n,t,e,i)=>{for(var r=i>1?void 0:i?Sv(t,e):t,s=n.length-1,a;s>=0;s--)(a=n[s])&&(r=(i?a(t,e,r):a(r))||r);return i&&r&&Iv(t,e,r),r};const Cf=class extends wt{constructor(t){super(t);f(this,"fontScale",1);f(this,"textAreaOrigin",[0,0]);f(this,"textAreaAnchor",[0,0]);Qe(this,Cf),this.fontScale=t.fontScale||this.fontScale,this.textAreaOrigin=t.textAreaOrigin||this.textAreaOrigin,this.textAreaAnchor=t.textAreaAnchor||this.textAreaAnchor}};let Bi=Cf;al([L],Bi.prototype,"fontScale",2),al([L],Bi.prototype,"textAreaOrigin",2),al([L],Bi.prototype,"textAreaAnchor",2);const Mv=`precision highp float;

varying vec4 vertexColor;

void main() {
  gl_FragColor = vertexColor;
}
`,Cv=`precision highp float;

varying vec4 vertexColor;

void main() {
  float borderScale = mix(fontScale, 1.0, float(scaling == 3.0));

  // Determine final screen size of label
  vec3 screenSize = cameraSpaceSize(vec3(size * scale * borderScale / scaleFactor / maxScale, 1.0));

  // Test whether the label is larger on the screen than the font size
  bool largerOnScreen = screenSize.y > size.y || screenSize.x > size.x;

  // Determines if a scale mode should be used or not for the vertex
  float useScaleMode = float(
    (
      scaling == 3.0 ||                  // NEVER mode - keep the image the same size always
      (largerOnScreen && scaling == 2.0) // BOUND_MAX mode - only if we're larger than the font size do we scale down
    ) &&
    scaling != 1.0                       // ALWAYS mode - the image stays completely in world space allowing it to scale freely
  );

  // Correct aspect ratio. Sufficient fix for most applications.
  // Will need another solution in the case of:
  // (cameraScale2D y != cameraScale2D.x) && (cameraScale2D.x != 1 && cameraScale2D.y != 1)

  // If zooms are unequal, assume one is filtered to be 1.0
  float unequalZooms = float(cameraScale2D.x != cameraScale2D.y);

  vec2 adjustedSize = mix(
    size,
    (size * cameraScale2D.yx),
    unequalZooms
  );

  // Destructure the normals attribute
  float normal = normals.x;
  float side = normals.y;

  vec2 scaledAnchor = anchor * scale;

  // Get the location of the anchor in world space
  vec2 worldAnchor = location + scaledAnchor;

  vec2 adjustedAnchor = mix(
    scaledAnchor,
    (scaledAnchor * cameraScale2D.yx),
    unequalZooms
  );

  // Get the position of the current vertex
  vec2 vertex = vec2(side, float(normal == 1.0)) * scale * adjustedSize + location - adjustedAnchor;

  // See how scaled the size on screen will be from the actual height of the label
  float labelScreenScale = mix(
    screenSize.y / adjustedSize.y,
    screenSize.x / adjustedSize.x,
    float((cameraScale2D.x != 1.0))
  );

  float currentScale = labelScreenScale * scale;

  // If our screen rendering is larger than the size the label is supposed to be, then we automagically
  // scale down our label to stay the correct size, centered on the anchor point
  vec2 anchorToVertex = vertex - location;

  // We now choose between keeping the same image size or keeping it in world space
  vertex = mix(
    // This option keeps the image size in world space
    vertex + textAreaOrigin,
    // This option counters the scaling of the image on the screen keeping it a static size
    (anchorToVertex + location - textAreaAnchor) / labelScreenScale + textAreaOrigin + textAreaAnchor,
    // This is the flag determining if a scale mode should be applied to the vertex
    useScaleMode
  );

  // --Texture and Color
  // Apply the label's color as a tint to the label (all labels are rendered white to the base texture)
  vertexColor = color;

  gl_Position = clipSpace(vec3(vertex, depth));
}
`,It=class extends Be{initShader(){const t=this.props.animate||{},e={0:1,1:1,2:-1,3:1,4:-1,5:-1},i={0:0,1:0,2:0,3:1,4:1,5:1},{scaleFactor:r=()=>1}=this.props;return{fs:Mv,instanceAttributes:[{easing:t.location,name:It.attributeNames.location,size:P.TWO,update:s=>s.position},{name:It.attributeNames.anchor,size:P.TWO,update:s=>[s.anchor.x||0,s.anchor.y||0]},{name:It.attributeNames.size,size:P.TWO,update:s=>s.size},{name:It.attributeNames.depth,size:P.ONE,update:s=>[s.depth]},{name:It.attributeNames.scaling,size:P.ONE,update:s=>[s.scaling]},{easing:t.color,name:It.attributeNames.color,size:P.FOUR,update:s=>s.color},{name:It.attributeNames.scale,size:P.ONE,update:s=>[s.scale]},{name:It.attributeNames.maxScale,size:P.ONE,update:s=>[s.maxScale]},{name:It.attributeNames.fontScale,size:P.ONE,update:s=>[s.fontScale]},{name:"textAreaOrigin",size:P.TWO,update:s=>s.textAreaOrigin},{name:"textAreaAnchor",size:P.TWO,update:s=>s.textAreaAnchor}],uniforms:[{name:"scaleFactor",size:R.ONE,update:s=>[r()]}],vertexAttributes:[{name:"normals",size:Ge.TWO,update:s=>[e[s],i[s]]}],vertexCount:6,vs:Cv}}getMaterialOptions(){return rt.transparentShapeBlending}};let hs=It;f(hs,"defaultProps",{key:"",data:new pe}),f(hs,"attributeNames",{anchor:"anchor",color:"color",depth:"depth",fontScale:"fontScale",location:"location",maxScale:"maxScale",scale:"scale",scaling:"scaling",size:"size"});const ui={[U.TopLeft]:n=>[0,0],[U.TopMiddle]:n=>[n.maxWidth/2,0],[U.TopRight]:n=>[n.maxWidth,0],[U.MiddleLeft]:n=>[0,n.maxHeight/2],[U.Middle]:n=>[n.maxWidth/2,n.maxHeight/2],[U.MiddleRight]:n=>[n.maxWidth,n.maxHeight/2],[U.BottomLeft]:n=>[0,n.maxHeight],[U.BottomMiddle]:n=>[n.maxWidth/2,n.maxHeight],[U.BottomRight]:n=>[n.maxWidth,n.maxHeight],[U.Custom]:n=>[n.anchor.x||0,n.anchor.y||0]};function Sa(n,t){let e=Number.MAX_SAFE_INTEGER;for(let i=0,r=n.length;i<r;i++){const s=n[i],a=t.get(s);a===0?e=0:a&&a<e&&(e=a)}return e===Number.MAX_SAFE_INTEGER?0:e}function Lv(n){const t=[],e=n.split(ru);for(let s=0,a=e.length-1;s<a;s++)e[s].split(" ").forEach(l=>{l!==""&&t.push(l)}),t.push(`
`);return e[e.length-1].split(" ").forEach(s=>{s!==""&&t.push(s)}),t}function Ov(n,t){const e=new Map;if(t.fontMap){const i=t.fontMap.fontSource.size,r=n.fontSize/i,s=t.fontMap,a=n.text.replace(/\s/g,"");let o=Number.MAX_SAFE_INTEGER,c=0,l,u="";for(let d=0,p=a.length;d<p;++d){const g=a[d];l=0,u&&(l=s.kerning[u][g][1]||0),c=c+l*r,e.set(g,c),o=Math.min(c,o),u=g}e.forEach((d,p)=>{e.set(p,d-o)})}return e}function Nv(n,t,e){const i=[],r=e.fontMap?e.fontMap.fontSource.size:t.fontSize,s=t.fontSize/r;let a="",o=0,c=[0,0];for(let l=0,u=n.text.length;l<u;l++){const d=n.text[l];if(e.fontMap){let p=[0,0];a&&(p=e.fontMap.kerning[a][d]||[0,0]),c=xn(c,Ce(p,s)),l!==0&&(c=xn(c,[t.letterSpacing,0]));const g=e.fontMap.glyphMap[d];o=c[0]+g.pixelWidth*s,i.push(o),a=d}}return i}class Lf extends Be{constructor(){super(...arguments);f(this,"providers",{labels:new pe,borders:new pe});f(this,"propertyIds");f(this,"fullUpdate",!1);f(this,"areaToLabels",new Map);f(this,"areaToLines",new Map);f(this,"areaWaitingOnLabel",new Map);f(this,"areaTokerningRequest",new Map);f(this,"areaToWords",new Map);f(this,"labelsInLine",[]);f(this,"handleLabelReady",e=>{if(!e.parentTextArea){delete e.onReady;return}const i=e.parentTextArea,r=this.areaWaitingOnLabel.get(i);if(r&&r.has(e)&&(r.delete(e),r.size<=0)){i.active=!0;const s=i.onReady;s&&s(i)}})}childLayers(){const e=this.props.animateLabel||{},i=this.props.animateBorder||{},r=this.props.scaling;return[Ai(sl,{animate:e,customGlyphLayer:this.props.customGlyphLayer,data:this.providers.labels,key:`${this.id}.labels`,resourceKey:this.props.resourceKey,scaleMode:r,inTextArea:!0}),Ai(hs,{animate:{color:i.color,location:i.location},data:this.providers.borders,key:`${this.id}.border`})]}draw(){const e=this.resolveChanges();if(e.length<=0)return;if(!this.propertyIds){const T=e[0][0];this.propertyIds=this.getInstanceObservableIds(T,["active","alignment","borderWidth","color","fontSize","hasBorder","letterSpacing","lineHeight","maxHeight","maxWidth","origin","padding","text","wordWrap"])}const{active:i,alignment:r,borderWidth:s,color:a,fontSize:o,hasBorder:c,letterSpacing:l,lineHeight:u,maxHeight:d,maxWidth:p,origin:g,padding:m,text:v,wordWrap:b}=this.propertyIds;for(let T=0,w=e.length;T<w;++T){const[E,x,_]=e[T];switch(x){case Te.CHANGE:if(!this.areaToLabels.get(E)){this.insert(E);continue}_[v]!==void 0?(this.clear(E),this.updateLabels(E),this.layout(E)):_[i]!==void 0&&(E.active?(this.layout(E),this.showLabels(E)):this.hideLabels(E)),_[r]!==void 0&&(this.clear(E),this.updateLabels(E),this.layoutLabels(E)),_[a]!==void 0&&this.updateLabelColors(E),_[g]!==void 0&&this.updateLabelOrigins(E),_[o]!==void 0&&this.updateLabelFontSizes(E),_[b]!==void 0&&this.updateLabelLineWrap(E),_[u]!==void 0&&this.updateLabelLineHeight(E),_[p]!==void 0&&this.updateTextAreaSize(E),_[d]!==void 0&&this.updateTextAreaSize(E),_[m]!==void 0&&this.updateTextAreaSize(E),_[s]!==void 0&&this.updateBorderWidth(E),_[c]!==void 0&&this.updateBorder(E),_[l]!==void 0&&this.updateLetterSpacing(E);break;case Te.INSERT:this.insert(E);break;case Te.REMOVE:{const I=this.areaToLabels.get(E);if(I){for(let M=0,C=I.length;M<C;++M){const F=I[M];F instanceof oe&&this.providers.labels.remove(F)}this.areaToLabels.delete(E),this.areaWaitingOnLabel.delete(E)}break}}}}insert(e){this.layout(e),this.updateLabels(e)}hideLabels(e){const i=this.areaToLabels.get(e);if(i)for(let r=0,s=i.length;r<s;++r){const a=i[r];a instanceof oe&&this.providers.labels.remove(a)}}initShader(){return null}clear(e){const i=e.labels;for(let s=0,a=i.length;s<a;s++){const o=i[s];o instanceof oe&&this.providers.labels.remove(o)}e.labels=[];const r=e.newLabels;for(let s=0,a=r.length;s<a;s++){const o=r[s];o instanceof oe&&this.providers.labels.remove(o)}e.newLabels=[],this.areaToLabels.delete(e),this.areaWaitingOnLabel.delete(e),this.areaToWords.delete(e)}seperateLabel(e,i,r,s,a,o,c,l,u){const d=e.padding[0],p=e.padding[1]||0,g=e.padding[2]||0,m=e.padding[3]||0,v=e.maxWidth-m-p,b=e.maxHeight-d-g,T=e.origin[0],w=e.origin[1];i.active=!1;const E=s.substring(0,a+1),x=Sa(E,r),_=ui[e.anchor.type](e),I=new oe({anchor:{padding:0,type:U.Custom,paddingDirection:[o+m,c+d+x],x:_[0],y:_[1]},color:e.color,fontSize:e.fontSize,letterSpacing:e.letterSpacing,origin:[T,w],text:E});if(I.size=[u[a],i.size[1]],this.providers.labels.add(I),e.newLabels.push(I),this.labelsInLine.push(I),o+=I.getWidth()+l,e.wordWrap===mn.CHARACTER||e.wordWrap===mn.WORD){if(this.setTextAlignment(o,c,l,v,e.alignment),o=0,c+=e.lineHeight,c+e.lineHeight<=b){let M=u[u.length-1]-u[a];for(;M>v&&c+e.lineHeight<=b;){let C=u.length-1;for(;u[C]-u[a]>v;)C--;const F=s.substring(a+1,C+1),Q=Sa(F,r),B=new oe({anchor:{padding:0,type:U.Custom,paddingDirection:[o+m,c+d+Q],x:_[0],y:_[1]},color:e.color,fontSize:e.fontSize,letterSpacing:e.letterSpacing,origin:[T,w],text:F});B.size=[u[C]-u[a],i.size[1]],o+=B.getWidth()+l,this.labelsInLine.push(B),this.providers.labels.add(B),e.newLabels.push(B),this.setTextAlignment(o,c,l,v,e.alignment),o=0,c+=e.lineHeight,a=C,M=u[u.length-1]-u[a]}if(c+e.lineHeight<=b){const C=s.substring(a+1),F=Sa(C,r),Q=new oe({anchor:{padding:0,type:U.Custom,paddingDirection:[o+m,c+d+F],x:_[0],y:_[1]},color:e.color,fontSize:e.fontSize,letterSpacing:e.letterSpacing,origin:[T,w],text:C});Q.size=[u[u.length-1]-u[a],i.size[1]],this.labelsInLine.push(Q);const B=[];for(let O=a+1;O<u.length;O++)B.push(u[O]-u[a]);this.providers.labels.add(Q),e.newLabels.push(Q),o+=Q.getWidth()+l}}}else e.wordWrap===mn.NONE&&(o+=I.getWidth()+l);return[o,c]}updateLabelLineWrap(e){const i=this.areaToLabels.get(e);if(i){for(let r=0,s=i.length;r<s;++r){const a=i[r];a instanceof oe&&(a.active=!0)}for(let r=0,s=e.newLabels.length;r<s;++r){const a=e.newLabels[r];this.providers.labels.remove(a)}e.newLabels=[],this.layoutLabels(e)}}updateLabelLineHeight(e){const i=this.areaToLabels.get(e);if(i){for(let r=0,s=i.length;r<s;++r){const a=i[r];a instanceof oe&&(a.active=!0)}for(let r=0,s=e.newLabels.length;r<s;++r){const a=e.newLabels[r];this.providers.labels.remove(a)}e.newLabels=[],this.layoutLabels(e)}}updateTextAreaSize(e){const i=this.areaToLabels.get(e);if(i){for(let r=0,s=i.length;r<s;++r){const a=i[r];a instanceof oe&&(a.active=!0)}for(let r=0,s=e.newLabels.length;r<s;++r){const a=e.newLabels[r];this.providers.labels.remove(a)}e.newLabels=[];for(let r=0,s=e.borders.length;r<s;++r){const a=e.borders[r];this.providers.borders.remove(a)}e.borders=[],this.layoutBorder(e),this.layoutLabels(e)}}updateBorderWidth(e){for(let i=0,r=e.borders.length;i<r;++i){const s=e.borders[i];this.providers.borders.remove(s)}e.borders=[],this.layoutBorder(e)}updateBorder(e){if(e.hasBorder)this.layoutBorder(e);else{for(let i=0,r=e.borders.length;i<r;++i){const s=e.borders[i];this.providers.borders.remove(s)}e.borders=[]}}updateLetterSpacing(e){this.clear(e),this.updateLabels(e),this.layout(e)}setTextAlignment(e,i,r,s,a){if(e-r<s&&a!==Ia.LEFT){const o=s-e+r,c=a===Ia.RIGHT?o:o/2;this.labelsInLine.forEach(l=>{const u=l.anchor;l.anchor={padding:u.padding,type:U.Custom,paddingDirection:[(u.paddingDirection?u.paddingDirection[0]:0)+c,u.paddingDirection?u.paddingDirection[1]:i],x:u.x,y:u.y}})}this.labelsInLine=[]}layoutBorder(e){if(e.hasBorder){const i=this.areaTokerningRequest.get(e);if(!i)return;const r=i.fontMap?i.fontMap.fontSource.size:e.fontSize,s=e.fontSize/r,a=this.props.scaling,o=e.borderWidth,c=new Bi({color:e.color,fontScale:s,scaling:a,size:[e.maxWidth+2*o,o],textAreaOrigin:e.origin,textAreaAnchor:ui[e.anchor.type](e),position:[-o,-o]}),l=new Bi({color:e.color,fontScale:s,scaling:a,size:[o,e.maxHeight+2*o],textAreaOrigin:e.origin,textAreaAnchor:ui[e.anchor.type](e),position:[-o,-o]}),u=new Bi({color:e.color,fontScale:s,scaling:a,size:[o,e.maxHeight+2*o],textAreaOrigin:e.origin,textAreaAnchor:ui[e.anchor.type](e),position:[e.maxWidth,-o]}),d=new Bi({color:e.color,fontScale:s,scaling:a,size:[e.maxWidth+2*o,o],textAreaOrigin:e.origin,textAreaAnchor:ui[e.anchor.type](e),position:[-o,e.maxHeight]});this.providers.borders.add(c),this.providers.borders.add(l),this.providers.borders.add(u),this.providers.borders.add(d),e.borders.push(c),e.borders.push(l),e.borders.push(u),e.borders.push(d)}}layoutLabels(e){const i=this.areaTokerningRequest.get(e);if(!i)return;const r=e.padding[0],s=e.padding[1]||0,a=e.padding[2]||0,o=e.padding[3]||0,c=e.maxWidth-o-s,l=e.maxHeight-r-a,u=e.origin[0],d=e.origin[1];let p=0;if(e.spaceWidth)p=e.spaceWidth;else{if(i.fontMap){const b=i.fontMap.fontSource.size,T=e.fontSize/b;p=i.fontMap.spaceWidth*T}else p=this.props.whiteSpaceKerning||e.fontSize/2;e.spaceWidth=p}const g=Ov(e,i);let m=0,v=0;this.labelsInLine=[];for(let b=0,T=e.labels.length;b<T;++b){const w=e.labels[b];if(w instanceof oe){const E=w.getWidth(),x=Sa(w.text,g),_=Nv(w,e,i);if(v+e.lineHeight<=l&&_[0]<=c)if(m+E<=c){w.origin=[u,d];const I=ui[e.anchor.type](e);w.anchor={padding:0,paddingDirection:[m+o,v+r+x],type:U.Custom,x:I[0],y:I[1]},m+=E+p,this.labelsInLine.push(w),m>=c&&e.wordWrap===mn.CHARACTER&&b+1<T&&e.labels[b+1]!==hr.NEWLINE&&(this.setTextAlignment(m,v,p,c,e.alignment),m=0,v+=e.lineHeight)}else if(e.wordWrap===mn.WORD&&w.getWidth()<=e.maxWidth)if(this.setTextAlignment(m,v,p,c,e.alignment),m=0,v+=e.lineHeight,v+e.lineHeight<=l){w.origin=[u,d];const I=ui[e.anchor.type](e);w.anchor={padding:0,paddingDirection:[m+o,v+r+x],type:U.Custom,x:I[0],y:I[1]},this.labelsInLine.push(w),m+=w.getWidth()+p}else w.active=!1;else{const I=c-m;let M=_.length-1;const C=w.text;for(;_[M]>I;)M--;if(M>=0){const F=this.seperateLabel(e,w,g,C,M,m,v,p,_);m=F[0],v=F[1]}else if(e.wordWrap===mn.CHARACTER||e.wordWrap===mn.WORD)if(this.setTextAlignment(m,v,p,c,e.alignment),v+=e.lineHeight,m=0,v+e.lineHeight<l)if(m+w.getWidth()<=c){w.origin=[u,d];const F=ui[e.anchor.type](e);w.anchor={padding:0,paddingDirection:[m+o,v+r+x],type:U.Custom,x:F[0],y:F[1]},this.labelsInLine.push(w),m+=w.getWidth()+p,m>=c&&b+1<T&&e.labels[b+1]!==hr.NEWLINE&&(this.setTextAlignment(m,v,p,c,e.alignment),m=0,v+=e.lineHeight)}else{const F=c-m;let Q=_.length-1;const B=w.text;for(;_[Q]>F;)Q--;if(Q>=0){const O=this.seperateLabel(e,w,g,B,Q,m,v,p,_);m=O[0],v=O[1]}}else w.active=!1;else e.wordWrap===mn.NONE&&(w.active=!1)}else w.active=!1}else w===hr.NEWLINE&&(this.setTextAlignment(m,v,p,c,e.alignment),m=0,v+=e.lineHeight)}this.setTextAlignment(m,v,p,c,e.alignment)}layout(e){this.updateKerning(e);const i=this.areaTokerningRequest.get(e);if(!i||!i.fontMap)return;const r=this.areaWaitingOnLabel.get(e);if(r&&r.size>0||!e.active)return;const s=this.areaToLabels.get(e);!s||s.length===0||(this.updateLabels(e),this.layoutBorder(e),this.layoutLabels(e))}updateKerning(e){let i=this.areaTokerningRequest.get(e);const r=e.text;if(i){if(i.kerningPairs&&i.kerningPairs.indexOf(r)>-1)return!!i.fontMap;if(i.fontMap&&!i.fontMap.supportsKerning(r))this.areaTokerningRequest.delete(e),i=void 0;else return!1}else{const s={fontSize:e.fontSize,text:e.text,letterSpacing:e.letterSpacing};return i=Ci({character:"",key:this.props.resourceKey||"",kerningPairs:[r],metrics:s}),e.preload?(e.resourceTrigger=()=>{e.onReady&&e.onReady(e)},this.resource.request(this,e,i)):(this.resource.request(this,e,i),this.areaTokerningRequest.set(e,i)),!1}return!0}managesInstance(e){return!!this.areaToLabels.get(e)}showLabels(e){const i=this.areaToLabels.get(e);if(i)for(let r=0,s=i.length;r<s;++r){const a=i[r];a instanceof oe&&this.providers.labels.add(a)}}updateLabels(e){let i=this.areaToLabels.get(e);const r=e.padding[0],s=e.padding[3]||0,a=e.origin[0]+s,o=e.origin[1]+r;i||(i=[],this.areaToLabels.set(e,i));let c=this.areaWaitingOnLabel.get(e);c||(c=new Set,this.areaWaitingOnLabel.set(e,c));let l=this.areaToWords.get(e);if(l||(l=Lv(e.text)),i.length<l.length)for(let u=i.length,d=l.length;u<d;++u){const p=l[u];if(p===`
`)i.push(hr.NEWLINE);else{const g=new oe({active:!1,color:e.color,fontSize:e.fontSize,letterSpacing:e.letterSpacing,text:p,origin:[a,o],onReady:this.handleLabelReady});g.parentTextArea=e,i.push(g),this.providers.labels.add(g),c.add(g)}}e.labels=i}updateLabelColors(e){const i=this.areaToLabels.get(e);if(i){for(let r=0,s=i.length;r<s;++r){const a=i[r];a instanceof oe&&(a.color=Dt(e.color))}for(let r=0,s=e.newLabels.length;r<s;++r)e.newLabels[r].color=Dt(e.color);for(let r=0,s=e.borders.length;r<s;++r)e.borders[r].color=Dt(e.color)}}updateLabelFontSizes(e){this.clear(e),this.updateLabels(e),this.areaTokerningRequest.delete(e),this.layout(e)}updateLabelOrigins(e){const i=this.areaToLabels.get(e);if(!i)return;const r=e.origin,s=e.oldOrigin;for(let a=0,o=i.length;a<o;++a){const c=i[a];if(c instanceof oe){const l=c.origin;c.origin=[l[0]+r[0]-s[0],l[1]+r[1]-s[1]]}}for(let a=0,o=e.newLabels.length;a<o;++a){const c=e.newLabels[a];if(c instanceof oe){const l=c.origin;c.origin=[l[0]+r[0]-s[0],l[1]+r[1]-s[1]]}}for(let a=0,o=e.borders.length;a<o;++a){const c=e.borders[a];c.position=[c.position[0]+r[0]-s[0],c.position[1]+r[1]-s[1]]}e.oldOrigin=e.origin}willUpdateProps(e){e.data!==this.props.data&&delete this.propertyIds,e.resourceKey!==this.props.resourceKey&&(this.fullUpdate=!0)}}f(Lf,"defaultProps",{key:"",data:new pe,scaling:dn.ALWAYS});const Pv=`precision highp float;

varying vec4 vertexColor;
varying vec4 _outlineColor;
varying vec2 _texCoord;
varying vec2 _boxSize;
varying float _outline;

void main() {
  // Get rid of tiny float errors
  if (_outline < 0.0000001) \${out: color} = vertexColor;
  else {
    _FragColor = mix(vertexColor, _outlineColor, float(_texCoord.x < _outline ||
      _texCoord.x > (_boxSize.x - _outline) ||
      _texCoord.y < _outline ||
      _texCoord.y > (_boxSize.y - _outline)));
  }
}
`,Dv=`precision highp float;

varying vec4 vertexColor;
varying vec4 _outlineColor;
varying float _outline;
varying vec2 _texCoord;
// How large the rectangle is in normalized window space (0 - 1 space not -1 - 1)
varying vec2 _boxSize;

void main() {
  // Determine final screen size of label
  vec3 screenSize = cameraSpaceSize(vec3(size * scale / scaleFactor / maxScale, 1.0f));

  // Test whether the label is larger on the screen than the font size
  bool largerOnScreen = screenSize.y > size.y || screenSize.x > size.x;

  // Determines if a scale mode should be used or not for the vertex
  float useScaleMode = float((scaling == 3.0f ||                  // NEVER mode - keep the image the same size always
    (largerOnScreen && scaling == 2.0f) // BOUND_MAX mode - only if we're larger than the font size do we scale down
  ) &&
    scaling != 1.0f                       // ALWAYS mode - the image stays completely in world space allowing it to scale freely
  );

  // TODO: Correct aspect ratio. Sufficient fix for most applications.
  // Will need another solution in the case of:
  // (cameraScale2D.y != cameraScale2D.x) && (cameraScale2D.x != 1 && cameraScale2D.y != 1)

  // If zooms are unequal, assume one is filtered to be 1.0
  float unequalZooms = float(cameraScale2D.x != cameraScale2D.y);

  vec2 adjustedSize = mix(size, (size * cameraScale2D.yx), unequalZooms);

  // Destructure normals attribute
  float normal = normals.x;
  float side = normals.y;

  vec2 scaledAnchor = anchor * scale;

  // Get the location of the anchor in world space
  vec2 worldAnchor = location + scaledAnchor;

  vec2 adjustedAnchor = mix(scaledAnchor, (scaledAnchor * cameraScale2D.yx), unequalZooms);

  // Get the position of the current vertex
  vec2 vertex = vec2(side, float(normal == 1.0f)) * scale * adjustedSize + location - adjustedAnchor;

  // See how scaled the size on screen will be from the actual height of the label
  float labelScreenScale = mix(screenSize.y / adjustedSize.y, screenSize.x / adjustedSize.x, float((cameraScale2D.x != 1.0f)));

  float currentScale = labelScreenScale * scale;

  // If our screen rendering is larger than the size the label is supposed to be, then we automagically
  // scale down our label to stay the correct size, centered on the anchor point
  vec2 anchorToVertex = vertex - location;

  float usedScaling = mix(
    1.,
    1. / labelScreenScale,
    useScaleMode
  );

  // We now choose between keeping the same image size or keeping it in world space
  vertex = mix(
    // This option keeps the image size in world space
  vertex,
    // This option counters the scaling of the image on the screen keeping it a static size
  (anchorToVertex * usedScaling) + location,
    // This is the flag determining if a scale mode should be applied to the vertex
  useScaleMode);

  // --Texture and Color
  // Apply the label's color as a tint to the label (all labels are rendered white to the base texture)
  vertexColor = color;

  gl_Position = clipSpace(vec3(vertex, depth));

  vec2 clipSize = (cameraScale2D.xy * scale * adjustedSize * usedScaling);
  _outlineColor = outlineColor;
  _outline = outline;
  _boxSize = clipSize;
  // Send the tex coords in screen space which is 0 - width in normalized clip space
  _texCoord = vec2(side, (normal + 1.) * 0.5) * clipSize;
}
`,Tt=class extends Be{initShader(){const t=this.props.animate||{},e={0:1,1:1,2:-1,3:1,4:-1,5:-1},i={0:0,1:0,2:0,3:1,4:1,5:1},{scaleFactor:r=()=>1}=this.props;return{fs:Pv,instanceAttributes:[{easing:t.location,name:Tt.attributeNames.location,size:P.TWO,update:s=>s.position},{name:Tt.attributeNames.anchor,size:P.TWO,update:s=>[s.anchor.x||0,s.anchor.y||0]},{easing:t.size,name:Tt.attributeNames.size,size:P.TWO,update:s=>s.size},{name:Tt.attributeNames.depth,size:P.ONE,update:s=>[s.depth]},{name:Tt.attributeNames.scaling,size:P.ONE,update:s=>[s.scaling]},{easing:t.color,name:Tt.attributeNames.color,size:P.FOUR,update:s=>s.color},{name:Tt.attributeNames.scale,size:P.ONE,update:s=>[s.scale]},{name:Tt.attributeNames.maxScale,size:P.ONE,update:s=>[s.maxScale]},{easing:t.outline,name:Tt.attributeNames.outline,size:P.ONE,update:s=>[s.outline]},{easing:t.outlineColor,name:Tt.attributeNames.outlineColor,size:P.FOUR,update:s=>s.outlineColor}],uniforms:[{name:"scaleFactor",size:R.ONE,update:s=>[r()]}],vertexAttributes:[{name:"normals",size:Ge.TWO,update:s=>[e[s],i[s]]}],vertexCount:6,vs:Dv}}getMaterialOptions(){return rt.transparentShapeBlending}};let ds=Tt;f(ds,"defaultProps",{key:"",data:new pe}),f(ds,"attributeNames",{anchor:"anchor",color:"color",depth:"depth",location:"location",maxScale:"maxScale",scale:"scale",scaling:"scaling",size:"size",outline:"outline",outlineColor:"outlineColor"});var Bv=Object.defineProperty,Uv=Object.getOwnPropertyDescriptor,fs=(n,t,e,i)=>{for(var r=i>1?void 0:i?Uv(t,e):t,s=n.length-1,a;s>=0;s--)(a=n[s])&&(r=(i?a(t,e,r):a(r))||r);return i&&r&&Bv(t,e,r),r};const Of=class extends Ye{constructor(t){super(t);f(this,"color",[1,1,1,1]);f(this,"depth",0);f(this,"radius",0);f(this,"thickness",1);f(this,"center",[0,0]);Qe(this,Of),this.color=t.color||this.color,this.depth=t.depth||this.depth,this.radius=t.radius||this.radius,this.thickness=t.thickness||this.thickness,this.center=t.center||this.center}get width(){return this.radius*2}get height(){return this.radius*2}get innerRadius(){return this.radius-this.thickness}};let dr=Of;fs([L],dr.prototype,"color",2),fs([L],dr.prototype,"depth",2),fs([L],dr.prototype,"radius",2),fs([L],dr.prototype,"thickness",2),fs([L],dr.prototype,"center",2);const Fv=`precision highp float;

/** This is the color of the ring */
varying vec4 vertexColor;
/**
 * This is how sharp the ring renders. For tiny rings, it's best to have
 * less sharpness to better convey the shape of a circle. A good starter setting:
 * edgeSharpness = mix(0.8, 0.01, min(gl_PointSize / 45.0, 1.0));
 */
varying float edgeSharpness;
/**
 * This should be a value that sets the thickness of the ring in normal space
 * relative to the PointSize
 */
varying float borderSize;
/**
 * Since this is now a quad instead of a point sprite, this provides what
 *gl_PointCoord used to provide.
 */
varying vec2 pointCoord;

varying float scale;

float circle(vec2 coord, float radius) {
  vec2 dist = coord - vec2(0.5f);

  return 1.0f - smoothstep(radius - (radius * edgeSharpness), radius, dot(dist, dist) * 4.0f);
}

void main() {
  float outer_step_factor = circle(pointCoord, 1.0f);
  float inner_step_factor = circle(pointCoord, 1.0f - borderSize * scale);

  gl_FragColor = mix(mix(                        // Select the outer color outside of the inner radius
  vec4(0.0f, 0.0f, 0.0f, 0.0f),    // Select invisible outside of inner and outer radius
  vertexColor,                  // Select outer color outside of inner, but inside outer
  outer_step_factor), vec4(0.0f, 0.0f, 0.0f, 0.0f),                 // Select inner color inside inner
  inner_step_factor);
}
`,kv=`precision highp float;

varying vec4 vertexColor;
varying float edgeSharpness;
varying float borderSize;
varying vec2 pointCoord;

varying float scale;

void main() {
  scale = scaleFactor;

  vertexColor = color;
  float size = radius * scaleFactor * pixelRatio;

  float ringWidth = mix(2.0 , thickness, float(thickness > 2.0));

  borderSize = mix(
    (ringWidth) / size,
    ((ringWidth * pixelRatio) / size),
    float(pixelRatio > 1.0)
  );

  edgeSharpness = min(0.2 / (ringWidth * scale),  0.1);

  pointCoord = (normals.xy + vec2(1.0, 1.0)) / 2.0;

  // Center within clip space
  vec4 clipCenter = clipSpace(vec3(center, depth));
  // Center in screen space
  vec2 screenCenter = (clipCenter.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;
  // Position in screen space
  vec2 vertex = (normals.xy * size) + screenCenter;
  // Position back to clip space
  gl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), clipCenter.zw);
}
`,Fi=class extends Be{initShader(){const t=this.props.scaleFactor||(()=>1),e=this.props.animate||{},{color:i,center:r,radius:s}=e,a={0:1,1:1,2:-1,3:1,4:-1,5:-1},o={0:-1,1:-1,2:-1,3:1,4:1,5:1};return{fs:Fv,instanceAttributes:[{easing:r,name:Fi.attributeNames.center,size:P.TWO,update:c=>c.center},{easing:s,name:Fi.attributeNames.radius,size:P.ONE,update:c=>[c.radius]},{name:Fi.attributeNames.depth,size:P.ONE,update:c=>[c.depth]},{easing:i,name:Fi.attributeNames.color,size:P.FOUR,update:c=>c.color},{name:Fi.attributeNames.thickness,size:P.ONE,update:c=>[c.thickness]}],uniforms:[{name:"scaleFactor",size:R.ONE,update:c=>[t()]}],vertexAttributes:[{name:"normals",size:Ge.TWO,update:c=>[a[c],o[c]]}],vertexCount:6,vs:kv}}getMaterialOptions(){return rt.transparentShapeBlending}};let ps=Fi;f(ps,"defaultProps",{key:"",data:new pe}),f(ps,"attributeNames",{center:"center",radius:"radius",depth:"depth",color:"color",thickness:"thickness"});const Gv=`// These are projection methods for basic camera operations
\${import: camera}

vec3 cameraSpace(vec3 world) {
  return (view * vec4(world, 1.0)).xyz;
}

vec3 cameraSpace(vec4 world) {
  return (view * world).xyz;
}

vec3 cameraSpaceDirection(vec3 world) {
  return (view * vec4(world, 0.0)).xyz;
}

vec3 cameraSpaceDirection(vec4 world) {
  return (view * world).xyz;
}

vec3 cameraSpaceSize(vec3 worldSize) {
  return (view * vec4(worldSize, 0.0)).xyz;
}

vec4 clipSpace(vec3 world) {
  return (viewProjection) * vec4(world, 1.0);
}

vec4 clipSpace(vec4 world) {
  return (viewProjection) * world;
}

vec4 clipSpaceDirection(vec3 worldSize) {
  return (viewProjection) * vec4(worldSize, 0.0);
}

vec4 clipSpaceDirection(vec4 worldSize) {
  return (viewProjection) * worldSize;
}

vec4 clipSpaceSize(vec3 worldSize) {
  return (viewProjection) * vec4(worldSize, 0.0);
}
`,zv=`
These are properties injected from the
current camera applied to the view.

Constants:
mat4 projection;
mat4 view;
mat4 viewProjection;
vec3 cameraOffset;
vec3 cameraPosition;
vec3 cameraScale;
vec3 cameraRotation;
vec2 viewSize;
float pixelRatio;
`;xe.register([{moduleId:"camera",description:zv,content:"",compatibility:S.ALL,uniforms:n=>[{name:"projection",size:R.MATRIX4,update:()=>n.view.props.camera.projection},{name:"viewProjection",size:R.MATRIX4,update:()=>n.view.props.camera.viewProjection},{name:"view",size:R.MATRIX4,update:()=>n.view.props.camera.view},{name:"cameraPosition",size:R.THREE,update:()=>n.view.props.camera.position},{name:"cameraScale",size:R.THREE,update:()=>n.view.props.camera.scale},{name:"cameraRotation",size:R.THREE,update:()=>n.view.props.camera.scale},{shaderInjection:S.ALL,name:"viewSize",size:R.TWO,update:()=>[n.view.viewBounds.width,n.view.viewBounds.height]},{shaderInjection:S.ALL,name:"pixelRatio",size:R.ONE,update:()=>[n.view.pixelRatio]}]},{moduleId:"projection",content:Gv,compatibility:S.ALL}]);const Nf=`
This provides frame timing information
or how many frames have been rendered.

Constants:
float currentTime;
float currentFrame;
`;xe.register({moduleId:"frame",description:Nf,content:"",compatibility:S.ALL,uniforms:n=>[{name:"currentTime",size:R.ONE,shaderInjection:S.ALL,update:()=>[n.surface.frameMetrics.currentTime]},{name:"currentFrame",size:R.ONE,shaderInjection:S.ALL,update:()=>[n.surface.frameMetrics.currentFrame]}]}),xe.register({moduleId:"time",description:Nf,content:"",compatibility:S.ALL,uniforms:n=>[{name:"time",size:R.ONE,shaderInjection:S.ALL,update:()=>[n.surface.frameMetrics.currentTime]}]});const Vv=`vec3 rgb2hsv(vec3 c) {
  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

  float d = q.x - min(q.w, q.y);
  float e = 1.0e-10;
  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c) {
  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
`,$v=`
Provides methods that converts colors to
HSV values and back. This makes it
easier to deal with hue saturation and
lightness levels.

Methods:
vec3 rgb2hsv(vec3 c);
vec3 hsv2rgb(vec3 c);
`;xe.register({moduleId:"hsv",description:$v,content:Vv,compatibility:S.ALL});const Wv=`
This is an internal shader module that
helps establish the instancing system.
Not recommended for use unless you
really know how to utilize it properly.

Attributes:
float _active;
float instance;
`;xe.register({moduleId:"instancing",description:Wv,content:"",compatibility:S.ALL,instanceAttributes:n=>{const t={name:"_active",size:P.ONE,update:e=>[e.active?1:0]};return n.shaderIOInfo.activeAttribute=t,[t]},vertexAttributes:n=>n.bufferType===ce.UNIFORM?[{name:"instance",size:Ge.ONE,update:()=>[0]}]:[]});const jv=`\${import: PI, PI2, fsin, fcos, wrap}

/**
 * A circular arc interpolator
 */
vec2 arc(float t, vec2 center, float radius, float start, float end) {
  float angle = wrap((end - start) * t + start, 0.0, PI2);
  return center + vec2(fcos(angle), fsin(angle)) * radius;
}
`,Hv=`/**
 * Single control point bezier curve
 */
vec2 bezier1(float t, vec2 p1, vec2 p2, vec2 c1) {
  return (1.0 - t) * (1.0 - t) * p1 + 2.0 * t * (1.0 - t) * c1 + t * t * p2;
}
`,Xv=`/**
 * Two control point bezier curve
 */
vec2 bezier2(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {
  float t1 = 1.0 - t;
  return pow(t1, 3.0) * p1 + 3.0 * t * pow(t1, 2.0) * c1 + 3.0 * pow(t, 2.0) * t1 * c2 + pow(t, 3.0) * p2;
}`,Qv=`\${import: PI, PI2, PI_2}

/**
 * This is an approximation of cos that allows us to bypass hardware precision
 * limitations for cos.
 *
 * http://lab.polygonal.de/2007/07/18/fast-and-accurate-sinecosine-approximation/
 * This is a GPU adaptation of this method to provide optimal GPU performance for the operation
 */
float fcos(float x) {
  float sine;
  // Cos is the same as sine but
  x += PI_2;

  // Always wrap input angle to -PI..PI
  x += mix(
    mix(
      0.0,
      -PI2, float(x > PI)
    ),
    PI2, float(x < -PI)
  );

  // Compute sine
  sine = 1.27323954 * x;
  sine += mix(-1.0, 1.0, float(x < 0.0)) * 0.405284735 * x * x;
  sine = 0.225 * (sine * (mix(1.0, -1.0, float(sine < 0.0)) * sine) - sine) + sine;

  return sine;
}
`,Yv=`float fmod(float x, float m, float m_inv) {
  return x - m * floor(x * m_inv);
}
`,qv=`\${import: PI, PI2}

/**
 * This is an approximation of sin that allows us to bypass hardware precision
 * limitations for sin.
 *
 * http://lab.polygonal.de/2007/07/18/fast-and-accurate-sinecosine-approximation/
 * This is a GPU adaptation of this method to provide optimal GPU performance for the operation
 */
float fsin(float x) {
  float sine;

  // Always wrap input angle to -PI..PI
  x += mix(
    mix(
      0.0,
      -PI2, float(x > PI)
    ),
    PI2, float(x < -PI)
  );

  // Compute sine
  sine = 1.27323954 * x;
  sine += mix(-1.0, 1.0, float(x < 0.0)) * 0.405284735 * x * x;
  sine = 0.225 * (sine * (mix(1.0, -1.0, float(sine < 0.0)) * sine) - sine) + sine;

  return sine;
}
`,Kv=`float PI = 3.14159265;
`,Zv=`float PI2 = 6.2831853;
`,Jv=`// This is 1 / (pi * 2.0)
float PI2_INV = 0.1591549431;
`,eb=`float PI_2 = 1.5707963268;
`,tb=`float PI_4 = 0.7853981634;
`,nb=`// This is 1 / pi
float PI_INV = 0.3183098862;
`,ib=`float toDegrees = 57.2957795131;
`,rb=`float toRadians = 0.01745329252;
`,sb=`float wrap(float value, float start, float end) {
  float width = end - start;
  float offsetValue = value - start;

  return (offsetValue - (floor(offsetValue / width) * width)) + start;
}
`,ol=[{moduleId:"PI_INV",description:"Provides: float PI_INV = 1.0 / pi",content:nb,compatibility:S.ALL},{moduleId:"PI2_INV",description:`Provides:
float PI2_INV = 1.0 / (pi * 2.0)`,content:Jv,compatibility:S.ALL},{moduleId:"PI_2",description:"Provides: float PI_2 = pi / 2.0",content:eb,compatibility:S.ALL},{moduleId:"PI_4",description:"Provides: float PI_4 = pi / 4.0",content:tb,compatibility:S.ALL},{moduleId:"PI",description:"Provides: float PI = pi",content:Kv,compatibility:S.ALL},{moduleId:"PI2",description:"Provides: float PI2 = pi * 2.0",content:Zv,compatibility:S.ALL},{moduleId:"toDegrees",description:`Provides: float toDegrees;
Can be used to convert radians to degrees:
radians * toDegrees`,content:ib,compatibility:S.ALL},{moduleId:"toRadians",description:`Provides: float toRadians;
Can be used to convert degrees to radians:
degress * toRadians`,content:rb,compatibility:S.ALL}],ab={moduleId:"constants",description:`
Provides all the math constants you may
need as convenience. It's probably
better to include them individually, but
convenience sometimes beats practicality

Constants:
${ol.map(n=>n.moduleId).join(`
`)}
`,content:`\${import: ${ol.map(n=>n.moduleId).join(", ")}}`,compatibility:S.ALL},ob=[{moduleId:"bezier1",description:`Provides the 2D single control
point bezier method:
vec2 bezier1(float t, vec2 p1, vec2 p2, vec2 c1)`,content:Hv,compatibility:S.ALL},{moduleId:"bezier2",description:`Provides the 2D single control
point bezier method:
vec2 bezier2(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2)`,content:Xv,compatibility:S.ALL},{moduleId:"arc",description:`Provides the 2D
arc interpolation method:
vec2 arc(float t,
	vec2 center,
	float radius,
	float start,
	float end
)`,content:jv,compatibility:S.ALL},{moduleId:"fmod",description:`Provides the floating point
modulus method:
float fmod(float x, float m, float m_inv)`,content:Yv,compatibility:S.ALL},{moduleId:"wrap",description:`Provides a method that wraps
value overflows:
float wrap(float value, float start, float end)`,content:sb,compatibility:S.ALL},{moduleId:"fcos",description:`Provides a fcos method that also
has a higher precision than
some hardware cos implementations:
float fcos(float x)`,content:Qv,compatibility:S.ALL},{moduleId:"fsin",description:`Provides a fsin method that also
has a higher precision than
some hardware sin implementations:
float fsin(float x)`,content:qv,compatibility:S.ALL}];xe.register([...ob,...ol,ab]);const cb=`mat4 rotationFromQuaternion(vec4 q) {
  float x2 = q.y + q.y;
  float y2 = q.z + q.z;
  float z2 = q.w + q.w;
  float xx = q.y * x2;
  float xy = q.y * y2;
  float xz = q.y * z2;
  float yy = q.z * y2;
  float yz = q.z * z2;
  float zz = q.w * z2;
  float wx = q.x * x2;
  float wy = q.x * y2;
  float wz = q.x * z2;

  return mat4(
    1.0 - (yy + zz), xy - wz, xz + wy, 0.0,
    xy + wz, 1.0 - (xx + zz), yz - wx, 0.0,
    xz - wy, yz + wx, 1.0 - (xx + yy), 0.0,
    0, 0, 0, 1
  );
}
`,lb=`mat4 scale(vec3 s) {
  return mat4(
    s.x, 0, 0, 0,
    0, s.y, 0, 0,
    0, 0, s.z, 0,
    0, 0, 0, 1
  );
}
`,ub=`\${import: translation, rotation, scale}

mat4 transform(vec3 s, vec4 r, vec3 t) {
  return translation(t) * rotationFromQuaternion(r) * scale(s);
}
`,hb=`mat4 translation(vec3 t) {
  return mat4(
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    t.x, t.y, t.z, 1
  );
}
`;xe.register([{moduleId:"translation",description:`Generates a translation matrix
from a vec3:
mat4 transform(vec3 s, vec4 r, vec3 t)`,compatibility:S.ALL,content:hb},{moduleId:"rotation",description:`Generates a rotation matrix
from a quaternion:
mat4 rotationFromQuaternion(vec4 q)`,compatibility:S.ALL,content:cb},{moduleId:"scale",description:`Generates a scale matrix
from a vec3:
mat4 scale(vec3 s)`,compatibility:S.ALL,content:lb},{moduleId:"transform",description:`Generates a full transform matrix
from a scale, quaternion, translation:
mat4 transform(vec3 s, vec4 r, vec3 t)`,compatibility:S.ALL,content:ub}]);const db=`//
// Description : Array and textureless GLSL 2D simplex noise function.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : stegu
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//               https://github.com/stegu/webgl-noise
//

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0f / 289.0f)) * 289.0f;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0f / 289.0f)) * 289.0f;
}

vec3 permute(vec3 x) {
  return mod289(((x * 34.0f) + 10.0f) * x);
}

float simplexNoise2D(vec2 v) {
  // (3.0-sqrt(3.0))/6.0
  const vec4 C = vec4(0.211324865405187f,
  // 0.5*(sqrt(3.0)-1.0)
  0.366025403784439f,
  // -1.0 + 2.0 * C.x
  -0.577350269189626f,
  // 1.0 / 41.0
  0.024390243902439f);
  // First corner
  vec2 i = floor(v + dot(v, C.yy));
  vec2 x0 = v - i + dot(i, C.xx);

  // Other corners
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0f, 0.0f) : vec2(0.0f, 1.0f);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;

  // Permutations
  // Avoid truncation effects in permutation
  i = mod289(i);
  vec3 p = permute(permute(i.y + vec3(0.0f, i1.y, 1.0f)) + i.x + vec3(0.0f, i1.x, 1.0f));

  vec3 m = max(0.5f - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0f);
  // m ^ 4
  m = m * m;
  m = m * m;

  // Gradients: 41 points uniformly over a line, mapped onto a diamond.
  // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)
  vec3 x = 2.0f * fract(p * C.www) - 1.0f;
  vec3 h = abs(x) - 0.5f;
  vec3 ox = floor(x + 0.5f);
  vec3 a0 = x - ox;

  // Normalise gradients implicitly by scaling m
  // Approximation of: m *= inversesqrt( a0*a0 + h*h );
  m *= 1.79284291400159f - 0.85373472095314f * (a0 * a0 + h * h);

  // Compute final noise value at P
  vec3 g;
  g.x = a0.x * x0.x + h.x * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;

  return 130.0f * dot(m, g);
}
`,fb=`//
// Description : Array and textureless GLSL 2D/3D/4D simplex
//               noise functions.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : stegu
//     Lastmod : 20201014 (stegu)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//               https://github.com/stegu/webgl-noise
//
vec3 mod289(vec3 x) {
  return x - floor(x * (1.0f / 289.0f)) * 289.0f;
}

vec4 mod289(vec4 x) {
  return x - floor(x * (1.0f / 289.0f)) * 289.0f;
}

vec4 permute(vec4 x) {
  return mod289(((x * 34.0f) + 10.0f) * x);
}

vec4 taylorInvSqrt(vec4 r) {
  return 1.79284291400159f - 0.85373472095314f * r;
}

float simplexNoise3D(vec3 v) {
  const vec2 C = vec2(1.0f / 6.0f, 1.0f / 3.0f);
  const vec4 D = vec4(0.0f, 0.5f, 1.0f, 2.0f);

  // First corner
  vec3 i = floor(v + dot(v, C.yyy));
  vec3 x0 = v - i + dot(i, C.xxx);

  // Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0f - g;
  vec3 i1 = min(g.xyz, l.zxy);
  vec3 i2 = max(g.xyz, l.zxy);

  // x0 = x0 - 0.0 + 0.0 * C.xxx;
  // x1 = x0 - i1  + 1.0 * C.xxx;
  // x2 = x0 - i2  + 2.0 * C.xxx;
  // x3 = x0 - 1.0 + 3.0 * C.xxx;
  vec3 x1 = x0 - i1 + C.xxx;
  // 2.0*C.x = 1/3 = C.y
  vec3 x2 = x0 - i2 + C.yyy;
  // -1.0+3.0*C.x = -0.5 = -D.y
  vec3 x3 = x0 - D.yyy;

  // Permutations
  i = mod289(i);
  vec4 p = permute(permute(permute(i.z + vec4(0.0f, i1.z, i2.z, 1.0f)) + i.y + vec4(0.0f, i1.y, i2.y, 1.0f)) + i.x + vec4(0.0f, i1.x, i2.x, 1.0f));

  // Gradients: 7x7 points over a square, mapped onto an octahedron.
  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
  float n_ = 0.142857142857f; // 1.0/7.0
  vec3 ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0f * floor(p * ns.z * ns.z);  //  mod(p,7*7)

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0f * x_);    // mod(j,N)

  vec4 x = x_ * ns.x + ns.yyyy;
  vec4 y = y_ * ns.x + ns.yyyy;
  vec4 h = 1.0f - abs(x) - abs(y);

  vec4 b0 = vec4(x.xy, y.xy);
  vec4 b1 = vec4(x.zw, y.zw);

  vec4 s0 = floor(b0) * 2.0f + 1.0f;
  vec4 s1 = floor(b1) * 2.0f + 1.0f;
  vec4 sh = -step(h, vec4(0.0f));

  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

  vec3 p0 = vec3(a0.xy, h.x);
  vec3 p1 = vec3(a0.zw, h.y);
  vec3 p2 = vec3(a1.xy, h.z);
  vec3 p3 = vec3(a1.zw, h.w);

  // Normalise gradients
  vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

  // Mix final noise value
  vec4 m = max(0.5f - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0f);
  m = m * m;
  return 105.0f * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
}
`;xe.register({moduleId:"simplexNoise3D",content:fb,compatibility:S.ALL,description:"Provides the simplex noise function for 3D coordinates."}),xe.register({moduleId:"simplexNoise2D",content:db,compatibility:S.ALL,description:"Provides the simplex noise function for 2D coordinates."});const pb=`vec4 bitSh = vec4(16777216., 65536., 256., 1.);
vec4 bitMsk = vec4(0., vec3(1. / 256.0));
vec4 bitShifts = vec4(1.) / vec4(16777216., 65536., 256., 1.);

vec4 packFloat(float value, float range) {
  value = (value + range) / (range * 2.);
  vec4 comp = fract(value * bitSh);
  comp -= comp.xxyz * bitMsk;
  return comp;
}

float unpackFloat(vec4 color, float range) {
  return dot(color , bitShifts) * (range * 2.) - range;
}
`,gb=`
This provides the ability to pack
a float value into a color RGBA
value. This is used to bypass the
lack of support for float textures.

Constants:
float currentTime;
float currentFrame;
`;xe.register({moduleId:"packFloat",description:gb,content:pb,compatibility:S.ALL});const mb=`// This is the varying auto generated for the fragment shader that is needed in the vertex shader to pass the
// color for the instance through to the fragment shader
varying highp vec4 _picking_color_pass_;
`;xe.register([{moduleId:"picking",description:`Internal use only. Provides methods
and constants to make the picking processes work.`,content:mb,compatibility:S.VERTEX,instanceAttributes:n=>[{name:"_pickingColor",size:P.FOUR,shaderInjection:S.VERTEX,update:t=>{const e=16777215-t.uid;return[((e&16711680)>>16)/255,((e&65280)>>8)/255,(e&255)/255,1]}}]}]);const vb=`void main() {
  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
}
`,bb=`void main() {
  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
}
`,Pf=`
Makes a no-op shader where gl_Position
is [0, 0, 0, 0] and gl_FragColor is
[0, 0, 0, 0].

You can not import this if you specify
your own main() method.
`;xe.register([{moduleId:"no-op",description:Pf,content:bb,compatibility:S.VERTEX},{moduleId:"no-op",description:Pf,content:vb,compatibility:S.FRAGMENT}]);const wb=`
This is a special helper module used by
the system to map View2D content into
a 3D world space. The system utilizes
this module automatically for you when
you utilize createLayer2Din3D.
`;xe.register([{moduleId:"world2DXY",description:wb,content:of,compatibility:S.ALL,uniforms:n=>n instanceof Be?n.props.control2D?[{name:"projection",size:R.MATRIX4,update:()=>n.view.props.camera.projection},{name:"view",size:R.MATRIX4,update:()=>n.view.props.camera.view},{name:"cameraOffset",size:R.THREE,update:()=>n.props.control2D instanceof Bn?n.props.control2D.offset:[0,0,0]},{name:"cameraPosition",size:R.THREE,update:()=>n.view.props.camera.position},{name:"cameraScale",size:R.THREE,update:()=>n.view.props.camera.scale},{name:"cameraScale2D",size:R.THREE,update:()=>n.props.control2D instanceof Bn?n.props.control2D.scale:[1,1,1]},{name:"cameraRotation",size:R.FOUR,update:()=>n.view.props.camera.transform.rotation},{name:"viewSize",size:R.TWO,update:()=>[n.view.viewBounds.width,n.view.viewBounds.height]},{name:"pixelRatio",size:R.ONE,update:()=>[n.view.pixelRatio]}]:(console.warn("For a layer 2D to be compatible with a 3D View, the layer requires an additional prop of control2D"),[]):(console.warn("A shader requested the module world2DXZ; however, the layer the shader comes from is NOT a Layer2D which is","required for the module to work."),[])}]);const Tb=`// These are projection methods utilizing the simpler camera 2d approach.
// This assumes we have a 3D camera projection which should be preferably orthographic layered with simpler 2D camera
// controls for manipulating the 2D world.
vec3 cameraSpace(vec3 world) {
  return (world + cameraOffset) * cameraScale2D;
}

vec3 cameraSpaceSize(vec3 worldSize) {
  return worldSize * cameraScale2D;
}

vec4 clipSpace(vec3 world) {
  return ((projection * view) * vec4(cameraSpace(world.xzy), 1.0));
}

vec4 clipSpaceSize(vec3 worldSize) {
  return ((projection * view) * vec4(cameraSpaceSize(worldSize.xzy), 0.0));
}
`,yb=`
This is a special helper module used by
the system to map View2D content into
a 3D world space. The system utilizes
this module automatically for you when
you utilize createLayer2Din3D.
`;xe.register([{moduleId:"world2DXZ",description:yb,content:Tb,compatibility:S.ALL,uniforms:n=>n instanceof Be?n.props.control2D?[{name:"projection",size:R.MATRIX4,update:()=>n.view.props.camera.projection},{name:"view",size:R.MATRIX4,update:()=>n.view.props.camera.view},{name:"cameraOffset",size:R.THREE,update:()=>n.props.control2D instanceof Bn?n.props.control2D.offset:[0,0,0]},{name:"cameraPosition",size:R.THREE,update:()=>n.view.props.camera.position},{name:"cameraScale",size:R.THREE,update:()=>n.view.props.camera.scale},{name:"cameraScale2D",size:R.THREE,update:()=>n.props.control2D instanceof Bn?n.props.control2D.scale:[1,1,1]},{name:"cameraRotation",size:R.THREE,update:()=>n.view.props.camera.scale},{name:"viewSize",size:R.TWO,update:()=>[n.view.viewBounds.width,n.view.viewBounds.height]},{name:"pixelRatio",size:R.ONE,update:()=>[n.view.pixelRatio]}]:(console.warn("For a layer 2D to be compatible with a 3D View, the layer requires an additional prop of control2D"),[]):(console.warn("A shader requesed the module world2DXZ; however, the layer the shader comes from is NOT a Layer2D which is","required for the module to work."),[])}]);const Eb=`// These are projection methods utilizing the simpler camera 2d approach.
// This assumes we have a 3D camera projection which should be preferably orthographic layered with simpler 2D camera
// controls for manipulating the 2D world.
vec3 cameraSpace(vec3 world) {
  return (world + cameraOffset) * cameraScale2D;
}

vec3 cameraSpaceSize(vec3 worldSize) {
  return worldSize * cameraScale2D;
}

vec4 clipSpace(vec3 world) {
  return ((projection * view) * vec4(cameraSpace(world.zyx), 1.0));
}

vec4 clipSpaceSize(vec3 worldSize) {
  return ((projection * view) * vec4(cameraSpaceSize(worldSize.zyx), 0.0));
}
`,_b=`
This is a special helper module used by
the system to map View2D content into
a 3D world space. The system utilizes
this module automatically for you when
you utilize createLayer2Din3D.
`;xe.register([{moduleId:"world2DYZ",description:_b,content:Eb,compatibility:S.ALL,uniforms:n=>n instanceof Be?n.props.control2D?[{name:"projection",size:R.MATRIX4,update:()=>n.view.props.camera.projection},{name:"view",size:R.MATRIX4,update:()=>n.view.props.camera.view},{name:"cameraOffset",size:R.THREE,update:()=>n.props.control2D instanceof Bn?n.props.control2D.offset:[0,0,0]},{name:"cameraPosition",size:R.THREE,update:()=>n.view.props.camera.position},{name:"cameraScale",size:R.THREE,update:()=>n.view.props.camera.scale},{name:"cameraScale2D",size:R.THREE,update:()=>n.props.control2D instanceof Bn?n.props.control2D.scale:[1,1,1]},{name:"cameraRotation",size:R.THREE,update:()=>n.view.props.camera.scale},{name:"viewSize",size:R.TWO,update:()=>[n.view.viewBounds.width,n.view.viewBounds.height]},{name:"pixelRatio",size:R.ONE,update:()=>[n.view.pixelRatio]}]:(console.warn("For a layer 2D to be compatible with a 3D View, the layer requires an additional prop of control2D"),[]):(console.warn("A shader requesed the module world2DYZ; however, the layer the shader comes from is NOT a Layer2D which is","required for the module to work."),[])}]);class Df extends Xs{constructor(){super(...arguments);f(this,"camera")}screenToWorld(e,i){return i=i||[0,0,0],this.viewToWorld(this.screenToView(e),i),i}screenRay(e){if(this.camera.projectionType===Ln.ORTHOGRAPHIC){const i=Xn(this.screenToWorld(e));return Ac(i,this.camera.transform.forward)}else{const i=Xn(this.screenToWorld(e));return Ic(Xn(this.camera.transform.position),i)}}worldToScreen(e,i){i=i||[0,0];const r=ot(this.camera.projection,this.camera.view),s=Ys(r,e,this.viewBounds.width,this.viewBounds.height);return ge(i,s[0]/this.pixelRatio,s[1]/this.pixelRatio)}viewToWorld(e,i){i=i||[0,0,0];const{width:r,height:s}=this.viewBounds,{projectionOptions:a}=this.camera,o=Ce(e,this.pixelRatio),{tan:c}=Math;if(a.type===Ln.PERSPECTIVE){const{fov:l,near:u}=a,d=s/r,p=c(l/2)*u,g=(2*((o[0]+.5)/r)-1)*p,m=(1-2*((o[1]+.5)/s))*p*d,v=[g,m,-1],b=$r(this.camera.transform.matrix,_r(v,1));ve(i,b[0],b[1],b[2])}else{const l=Ae(o,[r/2,s/2]),u=$r(this.camera.transform.viewMatrix,_r(l,-a.near));ve(i,u[0],-u[1],u[2])}return i}worldToView(e,i){i=i||[0,0];const r=ot(this.camera.projection,this.camera.view),s=Ys(r,e,this.viewBounds.width,this.viewBounds.height);return ge(i,s[0]/this.pixelRatio,s[1]/this.pixelRatio)}}function xb(n){return n.projectionType===Ln.ORTHOGRAPHIC}class Bf extends Ni{constructor(e,i){super(e,i);f(this,"projection");this.projection=new Df,this.projection.camera=i.camera,this.projection.pixelRatio=this.pixelRatio}fitViewtoViewport(e,i){if(Oc(this.props.camera)){const r=i.width,s=i.height,a=this.props.camera,o={near:a.projectionOptions.near,far:a.projectionOptions.far,width:r,height:s};this.props.preventCameraAdjustment||(a.projectionOptions=Object.assign(a.projectionOptions,o),a.update()),this.projection.pixelRatio=this.pixelRatio,this.projection.viewBounds=i,this.projection.viewBounds.d=this,this.projection.screenBounds=new ie({height:this.projection.viewBounds.height/this.pixelRatio,width:this.projection.viewBounds.width/this.pixelRatio,x:this.projection.viewBounds.x/this.pixelRatio,y:this.projection.viewBounds.y/this.pixelRatio}),this.projection.screenBounds.d=this}else if(xb(this.props.camera)){const r=i.width,s=i.height,a=this.props.camera,o={near:a.projectionOptions.near,far:a.projectionOptions.far,left:-r/2,right:r/2,top:s/2,bottom:-s/2};this.props.preventCameraAdjustment||(a.projectionOptions=Object.assign(a.projectionOptions,o),a.update()),this.projection.pixelRatio=this.pixelRatio,this.projection.viewBounds=i,this.projection.viewBounds.d=this,this.projection.screenBounds=new ie({height:this.projection.viewBounds.height/this.pixelRatio,width:this.projection.viewBounds.width/this.pixelRatio,x:this.projection.viewBounds.x/this.pixelRatio,y:this.projection.viewBounds.y/this.pixelRatio}),this.projection.screenBounds.d=this}}willUpdateProps(e){this.projection.camera=e.camera}}f(Bf,"defaultProps",{key:"",camera:new On({type:Ln.PERSPECTIVE,width:100,height:100,fov:Math.PI/2,far:1e5,near:1}),viewport:{left:0,right:0,bottom:0,top:0}});var Uf=(n=>(n[n.XY=0]="XY",n[n.XZ=1]="XZ",n[n.YZ=2]="YZ",n))(Uf||{});function Rb(n,t,e){if(!(t===Be||t.prototype instanceof Be))return console.warn("A Layer type was specified for createLayer2din3D that is NOT a Layer2D type, which is invalid.","The layer will be used without being modified."),Ri(t,e);let r;switch(n){case 0:r="world2DXY";break;case 1:r="world2DXZ";break;case 2:r="world2DYZ";break;default:return Ri(t,e)}const s=Object.assign({},e,{baseShaderModules:(a,o)=>{let c=o.vs.indexOf("world2D");return c>=0&&o.vs.splice(c,1,r),c=o.fs.indexOf("world2D"),c>=0&&o.fs.splice(c,1,r),o}});return Ri(t,s)}class Ff extends bt{baseShaderModules(t){const e=super.baseShaderModules(t);return e.vs.push("parent-transform"),e}}const Ab=`
When working with SceneGraphLayers, the
layer can have a transform applied to
the layer. This makes that transform
available in the parentTransform
constant.

mat4 parentTransform;
`;xe.register({moduleId:"parent-transform",description:Ab,compatibility:S.VERTEX,content:"",uniforms:n=>{const t=n;if(!(t instanceof Ff))return console.warn("A shader requested the module parent-transform; however, the layer the","shader is generated from is NOT a SceneGraphLayer which is","required for the module to work."),[];const e=fe();return[{name:"parentTransform",size:R.MATRIX4,update:()=>{var i;return((i=t.props.parent)==null?void 0:i.matrix)||e}}]}});var Ib=Object.defineProperty,Sb=Object.getOwnPropertyDescriptor,hi=(n,t,e,i)=>{for(var r=i>1?void 0:i?Sb(t,e):t,s=n.length-1,a;s>=0;s--)(a=n[s])&&(r=(i?a(t,e,r):a(r))||r);return i&&r&&Ib(t,e,r),r};const cl=class extends Ye{constructor(t){super(t);f(this,"needsLocalUpdate",!1);f(this,"needsWorldUpdate",!1);f(this,"_transform");f(this,"_matrix");f(this,"_localMatrix");f(this,"_localPosition");f(this,"_localRotation");f(this,"_localScale");f(this,"_position");f(this,"_rotation");f(this,"_scale");Qe(this,cl);const e=t.transform||new ca;this.transform=e,t.parent&&(t.parent instanceof cl?this.parent=t.parent:this.transform.parent=t.parent)}get transform(){return this._transform}set transform(t){this._transform||(this._position=t.position,this._rotation=t.rotation,this._scale=t.scale,this._localPosition=t.localPosition,this._localRotation=t.localRotation,this._localScale=t.localScale,this._matrix=t.matrix,this._localMatrix=t.localMatrix),t.instance=this,this._transform=t}get matrix(){return this._transform.update(),this._matrix}get localMatrix(){return this._transform.update(),this._localMatrix}get localPosition(){return this.needsLocalUpdate=!0,this._localPosition}set localPosition(t){this.transform.localPosition=t}get localRotation(){return this.needsLocalUpdate=!0,this._localRotation}set localRotation(t){this.transform.localRotation=t}get localScale(){return this.needsLocalUpdate=!0,this._localScale}set localScale(t){this.transform.localScale=t}get position(){return this.needsWorldUpdate=!0,this.transform.update(),this._position}set position(t){this.transform.position=t}get rotation(){return this.needsWorldUpdate=!0,this.transform.update(),this._rotation}set rotation(t){this.transform.rotation=t}get scale(){return this.needsWorldUpdate=!0,this.transform.update(),this._scale}set scale(t){this.transform.scale=t}set parent(t){this.transform.parent=t.transform}optimize(){this.needsWorldUpdate=!1,this.needsLocalUpdate=!1,this.transform.optimize()}};let bn=cl;hi([L],bn.prototype,"_matrix",2),hi([L],bn.prototype,"_localMatrix",2),hi([L],bn.prototype,"_localPosition",2),hi([L],bn.prototype,"_localRotation",2),hi([L],bn.prototype,"_localScale",2),hi([L],bn.prototype,"_position",2),hi([L],bn.prototype,"_rotation",2),hi([L],bn.prototype,"_scale",2);class Mb extends Lc{constructor(){super(...arguments);f(this,"isQueuedForUpdate",!1);f(this,"needsWorldOrientation",!1);f(this,"needsWorldDecomposition",!1);f(this,"_instance",null);f(this,"_matrix",{value:fe()});f(this,"_localMatrix",{value:this._matrix.value});f(this,"_position",{value:[0,0,0]});f(this,"_localPosition",{value:this._position.value});f(this,"_rotation",{value:Qr()});f(this,"_localRotation",{value:0});f(this,"localRotationMatrix",zr());f(this,"_scale",{value:[1,1,1]});f(this,"_localScale",{value:this._scale.value})}set instance(e){this._instance!==e&&this._instance&&(this._instance.transform.instance=null,e&&(e.transform=this)),this._instance=e}get matrix(){return this.update(),this._matrix.value}get position(){return this.needsWorldOrientation=!0,this.update(),this._position.value}set position(e){this.parent?console.warn("NOT IMPLEMENTED: Setting world position is not supported yet. Use localPosition for now."):this.localPosition=e}get localPosition(){return this._localPosition.value}set localPosition(e){this._localPosition.value[0]=e[0],this._localPosition.value[1]=e[1],this._localPosition.didUpdate=!0,this.invalidate()}get rotation(){return this.needsWorldOrientation=!0,this.update(),this._rotation.value}set rotation(e){console.warn("NOT IMPLEMENTED: Setting world rotation for a 2D transform is not supported yet.")}get localRotation(){return this._localRotation.value}set localRotation(e){this._localRotation.value=e,this._localRotation.didUpdate=!0,this.invalidate()}get scale(){return this.needsWorldOrientation=!0,this.update(),this._scale.value}set scale(e){this.parent?console.warn("NOT IMPLEMENTED: Setting world scale is not supported yet. Use localScale for now."):this.localScale=e}get localScale(){return this._localScale.value}set localScale(e){ge(this._localScale.value,e[0],e[1]),this._localScale.didUpdate=!0,this.invalidate()}decomposeWorldMatrix(){if(!this.parent||!this.needsWorldDecomposition||!this.needsWorldOrientation)return;this.needsWorldDecomposition=!1;const e=this._matrix.value,i=this._position.value,r=this._scale.value;this._position.didUpdate=i[0]!==e[12]||i[1]!==e[13]||i[2]!==e[14],this._position.didUpdate&&ve(i,e[12],e[13],e[14]);const s=Rn(e[0],e[1],e[2],e[3]),a=Rn(e[4],e[5],e[6],e[7]),o=Rn(e[8],e[9],e[10],e[11]);this._scale.didUpdate=r[0]!==s||r[1]!==a||r[2]!==o,ve(r,s,a,o),this._scale.didUpdate=!0;const[c,l,u,d]=this._rotation.value;ra(this._matrix.value,s,a,o,this._rotation.value);const p=this._rotation.value;this._rotation.didUpdate=p[0]!==c||p[1]!==l||p[2]!==u||p[3]!==d}queueForUpdate(){!this.isQueuedForUpdate&&this._instance&&this._instance.active&&(this.isQueuedForUpdate=!0,Mc(this))}update(e){let i=!1;if(this.isQueuedForUpdate&&(Cc(this),this.isQueuedForUpdate=!1),this.needsUpdate){const r=this.localRotationMatrix;this._localRotation.didUpdate&&lc(this._localRotation.value,r),vc(this._localScale.value,r,this._localPosition.value,this._localMatrix.value),this._localMatrix.didUpdate=!0,i=!0}this.parent&&(this.parent.needsUpdate?(e||this.processParentUpdates(r=>{r.update(!0)}),i=!0):this.parent.childUpdate.has(this)&&(i=!0),i&&(ot(this.parent._matrix.value,this._localMatrix.value,this._matrix.value),this._matrix.didUpdate=!0,this.needsWorldDecomposition=!0)),this.decomposeWorldMatrix(),this._instance&&this._instance.active&&(this._localRotation.didUpdate&&(this._instance._localRotation=this._localRotation.value),this._localPosition.didUpdate&&(this._instance._localPosition=this._localPosition.value),this._localScale.didUpdate&&(this._instance._localScale=this._localScale.value),this.parent?(this._rotation.didUpdate&&(this._instance._rotation=this._rotation.value),this._scale.didUpdate&&(this._instance._scale=this._scale.value),this._position.didUpdate&&(this._instance._position=this._position.value)):(this._localRotation.didUpdate&&(this._instance._rotation=this._localRotation.value),this._localPosition.didUpdate&&(this._instance._position=this._localPosition.value),this._localScale.didUpdate&&(this._instance._scale=this._localScale.value)),(this._matrix.didUpdate||this._localMatrix.didUpdate)&&(this._instance.transform=this)),this._localScale.didUpdate=!1,this._localRotation.didUpdate=!1,this._localPosition.didUpdate=!1,this._rotation.didUpdate=!1,this._scale.didUpdate=!1,this._position.didUpdate=!1,this._matrix.didUpdate=!1,this._localMatrix.didUpdate=!1,this.resolve()}}const Cb=`varying vec2 _texCoord;

void main() {
  gl_FragColor = mix(
    vec4(1.0, 0.0, 0.0, 1.0),
    vec4(0.0, 0.0, 0.0, 1.0),
    float(_texCoord.x <= 0.01 || _texCoord.x > 0.99 || _texCoord.y < 0.01 || _texCoord.y > 0.99)
  );
}
`,Lb=`\${import: projection}

varying vec2 _texCoord;

void main() {
  vec4 pos = vec4(position * size, 1.0);
  vec4 world = transform * pos;
  _texCoord = texCoord;

  gl_Position = clipSpace(world.xyz);
}
`;class kf extends bt{initShader(){const t=[1,1,1],e=[1,1,-1],i=[1,-1,-1],r=[1,-1,1],s=[-1,1,1],a=[-1,1,-1],o=[-1,-1,-1],c=[-1,-1,1],l=[t,e,i,t,i,r,s,t,r,s,r,c,s,o,a,s,c,o,a,i,e,a,o,i,s,e,t,s,a,e,c,r,i,c,i,o],u=[1,0,0],d=[0,0,1],p=[-1,0,0],g=[0,0,-1],m=[0,1,0],v=[0,-1,0],b=[u,u,u,u,u,u,d,d,d,d,d,d,p,p,p,p,p,p,g,g,g,g,g,g,m,m,m,m,m,m,v,v,v,v,v,v],T=[[0,0],[1,0],[1,1],[0,0],[1,1],[0,1],[0,0],[1,0],[1,1],[0,0],[1,1],[0,1],[0,0],[1,1],[1,0],[0,0],[0,1],[1,1],[0,0],[1,1],[1,0],[0,0],[0,1],[1,1],[0,0],[1,1],[1,0],[0,0],[0,1],[1,1],[0,0],[1,0],[1,1],[0,0],[1,1],[0,1]];return{drawMode:h.GLSettings.Model.DrawMode.TRIANGLES,fs:[{outputType:H.COLOR,source:Cb}],instanceAttributes:[{name:"transform",size:P.MAT4X4,update:w=>(w.transform||Zh).matrix},{name:"size",size:P.THREE,update:w=>w.size}],uniforms:[],vertexAttributes:[{name:"position",size:Ge.THREE,update:w=>l[w]},{name:"normal",size:Ge.THREE,update:w=>b[w]},{name:"texCoord",size:Ge.TWO,update:w=>T[w]}],vertexCount:36,vs:Lb}}getMaterialOptions(){return Object.assign({},rt.transparentShapeBlending,{cullSide:h.GLSettings.Material.CullSide.CCW})}}f(kf,"defaultProps",{data:new pe,key:"",materialOptions:rt.transparentShapeBlending});var Ob=Object.defineProperty,Nb=Object.getOwnPropertyDescriptor,Gf=(n,t,e,i)=>{for(var r=i>1?void 0:i?Nb(t,e):t,s=n.length-1,a;s>=0;s--)(a=n[s])&&(r=(i?a(t,e,r):a(r))||r);return i&&r&&Ob(t,e,r),r};const zf=class extends bn{constructor(t){super(t);f(this,"size",[1,1,1]);f(this,"color",[1,1,1,1]);Qe(this,zf),this.size=t.size||this.size,this.color=t.color||this.color}};let ll=zf;Gf([L],ll.prototype,"size",2),Gf([L],ll.prototype,"color",2);var ul={exports:{}},gs={};/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Vf;function Pb(){if(Vf)return gs;Vf=1;var n=j,t=Symbol.for("react.element"),e=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,r=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,s={key:!0,ref:!0,__self:!0,__source:!0};function a(o,c,l){var u,d={},p=null,g=null;l!==void 0&&(p=""+l),c.key!==void 0&&(p=""+c.key),c.ref!==void 0&&(g=c.ref);for(u in c)i.call(c,u)&&!s.hasOwnProperty(u)&&(d[u]=c[u]);if(o&&o.defaultProps)for(u in c=o.defaultProps,c)d[u]===void 0&&(d[u]=c[u]);return{$$typeof:t,type:o,key:p,ref:g,props:d,_owner:r.current}}return gs.Fragment=e,gs.jsx=a,gs.jsxs=a,gs}var ms={};/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var $f;function Db(){return $f||($f=1,process.env.NODE_ENV!=="production"&&function(){var n=j,t=Symbol.for("react.element"),e=Symbol.for("react.portal"),i=Symbol.for("react.fragment"),r=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),a=Symbol.for("react.provider"),o=Symbol.for("react.context"),c=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),u=Symbol.for("react.suspense_list"),d=Symbol.for("react.memo"),p=Symbol.for("react.lazy"),g=Symbol.for("react.offscreen"),m=Symbol.iterator,v="@@iterator";function b(y){if(y===null||typeof y!="object")return null;var A=m&&y[m]||y[v];return typeof A=="function"?A:null}var T=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;function w(y){{for(var A=arguments.length,D=new Array(A>1?A-1:0),$=1;$<A;$++)D[$-1]=arguments[$];E("error",y,D)}}function E(y,A,D){{var $=T.ReactDebugCurrentFrame,re=$.getStackAddendum();re!==""&&(A+="%s",D=D.concat([re]));var ue=D.map(function(te){return String(te)});ue.unshift("Warning: "+A),Function.prototype.apply.call(console[y],console,ue)}}var x=!1,_=!1,I=!1,M=!1,C=!1,F;F=Symbol.for("react.module.reference");function Q(y){return!!(typeof y=="string"||typeof y=="function"||y===i||y===s||C||y===r||y===l||y===u||M||y===g||x||_||I||typeof y=="object"&&y!==null&&(y.$$typeof===p||y.$$typeof===d||y.$$typeof===a||y.$$typeof===o||y.$$typeof===c||y.$$typeof===F||y.getModuleId!==void 0))}function B(y,A,D){var $=y.displayName;if($)return $;var re=A.displayName||A.name||"";return re!==""?D+"("+re+")":D}function O(y){return y.displayName||"Context"}function X(y){if(y==null)return null;if(typeof y.tag=="number"&&w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."),typeof y=="function")return y.displayName||y.name||null;if(typeof y=="string")return y;switch(y){case i:return"Fragment";case e:return"Portal";case s:return"Profiler";case r:return"StrictMode";case l:return"Suspense";case u:return"SuspenseList"}if(typeof y=="object")switch(y.$$typeof){case o:var A=y;return O(A)+".Consumer";case a:var D=y;return O(D._context)+".Provider";case c:return B(y,y.render,"ForwardRef");case d:var $=y.displayName||null;return $!==null?$:X(y.type)||"Memo";case p:{var re=y,ue=re._payload,te=re._init;try{return X(te(ue))}catch{return null}}}return null}var W=Object.assign,q=0,ne,Z,K,Oe,le,we,He;function Vn(){}Vn.__reactDisabledLog=!0;function $n(){{if(q===0){ne=console.log,Z=console.info,K=console.warn,Oe=console.error,le=console.group,we=console.groupCollapsed,He=console.groupEnd;var y={configurable:!0,enumerable:!0,value:Vn,writable:!0};Object.defineProperties(console,{info:y,log:y,warn:y,error:y,group:y,groupCollapsed:y,groupEnd:y})}q++}}function _n(){{if(q--,q===0){var y={configurable:!0,enumerable:!0,writable:!0};Object.defineProperties(console,{log:W({},y,{value:ne}),info:W({},y,{value:Z}),warn:W({},y,{value:K}),error:W({},y,{value:Oe}),group:W({},y,{value:le}),groupCollapsed:W({},y,{value:we}),groupEnd:W({},y,{value:He})})}q<0&&w("disabledDepth fell below zero. This is a bug in React. Please file an issue.")}}var Wn=T.ReactCurrentDispatcher,mr;function ki(y,A,D){{if(mr===void 0)try{throw Error()}catch(re){var $=re.stack.trim().match(/\n( *(at )?)/);mr=$&&$[1]||""}return`
`+mr+y}}var bl=!1,Na;{var Jb=typeof WeakMap=="function"?WeakMap:Map;Na=new Jb}function tp(y,A){if(!y||bl)return"";{var D=Na.get(y);if(D!==void 0)return D}var $;bl=!0;var re=Error.prepareStackTrace;Error.prepareStackTrace=void 0;var ue;ue=Wn.current,Wn.current=null,$n();try{if(A){var te=function(){throw Error()};if(Object.defineProperty(te.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(te,[])}catch(jn){$=jn}Reflect.construct(y,[],te)}else{try{te.call()}catch(jn){$=jn}y.call(te.prototype)}}else{try{throw Error()}catch(jn){$=jn}y()}}catch(jn){if(jn&&$&&typeof jn.stack=="string"){for(var J=jn.stack.split(`
`),Ke=$.stack.split(`
`),Me=J.length-1,Ne=Ke.length-1;Me>=1&&Ne>=0&&J[Me]!==Ke[Ne];)Ne--;for(;Me>=1&&Ne>=0;Me--,Ne--)if(J[Me]!==Ke[Ne]){if(Me!==1||Ne!==1)do if(Me--,Ne--,Ne<0||J[Me]!==Ke[Ne]){var yt=`
`+J[Me].replace(" at new "," at ");return y.displayName&&yt.includes("<anonymous>")&&(yt=yt.replace("<anonymous>",y.displayName)),typeof y=="function"&&Na.set(y,yt),yt}while(Me>=1&&Ne>=0);break}}}finally{bl=!1,Wn.current=ue,_n(),Error.prepareStackTrace=re}var br=y?y.displayName||y.name:"",pp=br?ki(br):"";return typeof y=="function"&&Na.set(y,pp),pp}function ew(y,A,D){return tp(y,!1)}function tw(y){var A=y.prototype;return!!(A&&A.isReactComponent)}function Pa(y,A,D){if(y==null)return"";if(typeof y=="function")return tp(y,tw(y));if(typeof y=="string")return ki(y);switch(y){case l:return ki("Suspense");case u:return ki("SuspenseList")}if(typeof y=="object")switch(y.$$typeof){case c:return ew(y.render);case d:return Pa(y.type,A,D);case p:{var $=y,re=$._payload,ue=$._init;try{return Pa(ue(re),A,D)}catch{}}}return""}var Da=Object.prototype.hasOwnProperty,np={},ip=T.ReactDebugCurrentFrame;function Ba(y){if(y){var A=y._owner,D=Pa(y.type,y._source,A?A.type:null);ip.setExtraStackFrame(D)}else ip.setExtraStackFrame(null)}function nw(y,A,D,$,re){{var ue=Function.call.bind(Da);for(var te in y)if(ue(y,te)){var J=void 0;try{if(typeof y[te]!="function"){var Ke=Error(($||"React class")+": "+D+" type `"+te+"` is invalid; it must be a function, usually from the `prop-types` package, but received `"+typeof y[te]+"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");throw Ke.name="Invariant Violation",Ke}J=y[te](A,te,$,D,null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")}catch(Me){J=Me}J&&!(J instanceof Error)&&(Ba(re),w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).",$||"React class",D,te,typeof J),Ba(null)),J instanceof Error&&!(J.message in np)&&(np[J.message]=!0,Ba(re),w("Failed %s type: %s",D,J.message),Ba(null))}}}var iw=Array.isArray;function wl(y){return iw(y)}function rw(y){{var A=typeof Symbol=="function"&&Symbol.toStringTag,D=A&&y[Symbol.toStringTag]||y.constructor.name||"Object";return D}}function sw(y){try{return rp(y),!1}catch{return!0}}function rp(y){return""+y}function sp(y){if(sw(y))return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.",rw(y)),rp(y)}var vs=T.ReactCurrentOwner,aw={key:!0,ref:!0,__self:!0,__source:!0},ap,op,Tl;Tl={};function ow(y){if(Da.call(y,"ref")){var A=Object.getOwnPropertyDescriptor(y,"ref").get;if(A&&A.isReactWarning)return!1}return y.ref!==void 0}function cw(y){if(Da.call(y,"key")){var A=Object.getOwnPropertyDescriptor(y,"key").get;if(A&&A.isReactWarning)return!1}return y.key!==void 0}function lw(y,A){if(typeof y.ref=="string"&&vs.current&&A&&vs.current.stateNode!==A){var D=X(vs.current.type);Tl[D]||(w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',X(vs.current.type),y.ref),Tl[D]=!0)}}function uw(y,A){{var D=function(){ap||(ap=!0,w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)",A))};D.isReactWarning=!0,Object.defineProperty(y,"key",{get:D,configurable:!0})}}function hw(y,A){{var D=function(){op||(op=!0,w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)",A))};D.isReactWarning=!0,Object.defineProperty(y,"ref",{get:D,configurable:!0})}}var dw=function(y,A,D,$,re,ue,te){var J={$$typeof:t,type:y,key:A,ref:D,props:te,_owner:ue};return J._store={},Object.defineProperty(J._store,"validated",{configurable:!1,enumerable:!1,writable:!0,value:!1}),Object.defineProperty(J,"_self",{configurable:!1,enumerable:!1,writable:!1,value:$}),Object.defineProperty(J,"_source",{configurable:!1,enumerable:!1,writable:!1,value:re}),Object.freeze&&(Object.freeze(J.props),Object.freeze(J)),J};function fw(y,A,D,$,re){{var ue,te={},J=null,Ke=null;D!==void 0&&(sp(D),J=""+D),cw(A)&&(sp(A.key),J=""+A.key),ow(A)&&(Ke=A.ref,lw(A,re));for(ue in A)Da.call(A,ue)&&!aw.hasOwnProperty(ue)&&(te[ue]=A[ue]);if(y&&y.defaultProps){var Me=y.defaultProps;for(ue in Me)te[ue]===void 0&&(te[ue]=Me[ue])}if(J||Ke){var Ne=typeof y=="function"?y.displayName||y.name||"Unknown":y;J&&uw(te,Ne),Ke&&hw(te,Ne)}return dw(y,J,Ke,re,$,vs.current,te)}}var yl=T.ReactCurrentOwner,cp=T.ReactDebugCurrentFrame;function vr(y){if(y){var A=y._owner,D=Pa(y.type,y._source,A?A.type:null);cp.setExtraStackFrame(D)}else cp.setExtraStackFrame(null)}var El;El=!1;function _l(y){return typeof y=="object"&&y!==null&&y.$$typeof===t}function lp(){{if(yl.current){var y=X(yl.current.type);if(y)return`

Check the render method of \``+y+"`."}return""}}function pw(y){{if(y!==void 0){var A=y.fileName.replace(/^.*[\\\/]/,""),D=y.lineNumber;return`

Check your code at `+A+":"+D+"."}return""}}var up={};function gw(y){{var A=lp();if(!A){var D=typeof y=="string"?y:y.displayName||y.name;D&&(A=`

Check the top-level render call using <`+D+">.")}return A}}function hp(y,A){{if(!y._store||y._store.validated||y.key!=null)return;y._store.validated=!0;var D=gw(A);if(up[D])return;up[D]=!0;var $="";y&&y._owner&&y._owner!==yl.current&&($=" It was passed a child from "+X(y._owner.type)+"."),vr(y),w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.',D,$),vr(null)}}function dp(y,A){{if(typeof y!="object")return;if(wl(y))for(var D=0;D<y.length;D++){var $=y[D];_l($)&&hp($,A)}else if(_l(y))y._store&&(y._store.validated=!0);else if(y){var re=b(y);if(typeof re=="function"&&re!==y.entries)for(var ue=re.call(y),te;!(te=ue.next()).done;)_l(te.value)&&hp(te.value,A)}}}function mw(y){{var A=y.type;if(A==null||typeof A=="string")return;var D;if(typeof A=="function")D=A.propTypes;else if(typeof A=="object"&&(A.$$typeof===c||A.$$typeof===d))D=A.propTypes;else return;if(D){var $=X(A);nw(D,y.props,"prop",$,y)}else if(A.PropTypes!==void 0&&!El){El=!0;var re=X(A);w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?",re||"Unknown")}typeof A.getDefaultProps=="function"&&!A.getDefaultProps.isReactClassApproved&&w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.")}}function vw(y){{for(var A=Object.keys(y.props),D=0;D<A.length;D++){var $=A[D];if($!=="children"&&$!=="key"){vr(y),w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",$),vr(null);break}}y.ref!==null&&(vr(y),w("Invalid attribute `ref` supplied to `React.Fragment`."),vr(null))}}function fp(y,A,D,$,re,ue){{var te=Q(y);if(!te){var J="";(y===void 0||typeof y=="object"&&y!==null&&Object.keys(y).length===0)&&(J+=" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");var Ke=pw(re);Ke?J+=Ke:J+=lp();var Me;y===null?Me="null":wl(y)?Me="array":y!==void 0&&y.$$typeof===t?(Me="<"+(X(y.type)||"Unknown")+" />",J=" Did you accidentally export a JSX literal instead of a component?"):Me=typeof y,w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",Me,J)}var Ne=fw(y,A,D,re,ue);if(Ne==null)return Ne;if(te){var yt=A.children;if(yt!==void 0)if($)if(wl(yt)){for(var br=0;br<yt.length;br++)dp(yt[br],y);Object.freeze&&Object.freeze(yt)}else w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");else dp(yt,y)}return y===i?vw(Ne):mw(Ne),Ne}}function bw(y,A,D){return fp(y,A,D,!0)}function ww(y,A,D){return fp(y,A,D,!1)}var Tw=ww,yw=bw;ms.Fragment=i,ms.jsx=Tw,ms.jsxs=yw}()),ms}process.env.NODE_ENV==="production"?ul.exports=Pb():ul.exports=Db();var Ue=ul.exports;function di(n,t,e,i={current:0},r=""){const s=t.get(e),a=new Set,o=j.useRef([]),c=new Set;o.current=[],r=r?`${r}.`:"";let l=[];return s&&(l=j.Children.map(s,u=>{if(j.isValidElement(u)){const d=u.key||i.current++,p=`${r}${u.props.name||`${d}`}`,g=n.get(p)||new $e;n.set(p,g),o.current.push(g),u.props.share&&(u.props.share.current=g);const m={key:d,name:p,resolver:g};return a.has(m.name)?c.add(m.name):a.add(m.name),j.cloneElement(u,m)}})),[l,Promise.all(o.current.map(u=>u==null?void 0:u.promise)),{resolvers:o,nameConflict:c}]}function hl(...n){return n.filter(de).reduce((t,e)=>t.concat(e),[])}function Bb(n){const{children:t,tagName:e,...i}=n,r=Object.keys(i).reduce((s,a)=>{try{Sn(a)&&(s[a.toLowerCase()]=JSON.stringify(i[a]))}catch{}return s},{});return{tagName:e,attributes:r,children:t}}const wn=n=>{const{tagName:t="",attributes:e,children:i}=Bb(n),{writeToDom:r}=j.useContext(fr)||{};return r?j.createElement(t,e,i):n.children};var je=(n=>(n[n.EVENT_MANAGER=1]="EVENT_MANAGER",n[n.LAYER=2]="LAYER",n[n.CAMERA=3]="CAMERA",n[n.PROVIDER=4]="PROVIDER",n[n.RESOURCE=5]="RESOURCE",n[n.VIEW=6]="VIEW",n[n.SCENE=7]="SCENE",n))(je||{});function Wf(n,t,e){var s,a,o;const i=new Map,r=[];for(t&&t.forEach(c=>{i.set(c,[])}),j.Children.forEach(n,(c,l)=>{r.push(c)}),r.reverse();r.length>0;){const c=r.pop();if(!j.isValidElement(c))continue;const l=(s=c.type)==null?void 0:s.surfaceJSXType;if(c!==void 0&&((c==null?void 0:c.type)===j.Fragment||l===void 0)){if(!((a=c==null?void 0:c.props)!=null&&a.children)){e&&e.push(c);continue}const u=[];j.Children.forEach(((o=c==null?void 0:c.props)==null?void 0:o.children)||[],d=>{u.push(d)});for(let d=u.length-1;d>=0;--d)r.push(u[d]);continue}else if(c!==void 0){if(l===void 0){e&&e.push(c);continue}if(t){const u=i.get(l);if(!u){e&&e.push(c);continue}u.push(c)}else{let u=i.get(l);u||(u=[],i.set(l,u)),u.push(c)}}}return i}function Ub(n){return n&&n.charCodeAt!==void 0}function Fb(n){return n!=null}const jf=()=>{};class kb{constructor(t){f(this,"resolver",jf);f(this,"rejector",jf);f(this,"promise");f(this,"children");f(this,"childResolutions");f(this,"childResolvers");this.promise=new Promise((e,i)=>(this.resolver=e,this.rejector=i))}resolve(t){this.resolver(t)}reject(t){this.rejector(t)}hijack(t){this.children=this.children||[],this.children.push(t),this.childResolvers=this.childResolvers||new Map,this.childResolvers.set(t,t.resolver),t.resolver=async e=>{this.childResolutions=this.childResolutions||new Map,this.childResolutions.set(t,e)}}}function Gn(n,t){var o,c;const[e,i]=j.useState(!0),[r,s]=j.useState(!1),a={store:n,shouldMount:e};if(!r&&Fb(n.willMount)&&(a.shouldMount=!!((o=n.willMount)!=null&&o.call(n))),r){const l=(c=n.willUpdate)==null?void 0:c.call(n);l&&(async()=>await l())()}return j.useEffect(()=>{const l=new kb;s(!0),i(a.shouldMount);let u;return(async()=>{var d;u=await((d=n.didMount)==null?void 0:d.call(n)),l.resolve(!0)})(),()=>{(async()=>(await l.promise,u==null||u()))()}},[]),j.useEffect(()=>{var l;r&&(a.shouldMount=!!((l=n.willMount)!=null&&l.call(n)))},t||[0]),a}const Rw="",fr=j.createContext(void 0),Gb=n=>{const t=j.useRef(null),e=j.useRef(null),i=j.useRef(0),r=j.useRef(null),s=j.useRef(null),a=j.useRef(-1),o=j.useRef(new Map),c=j.useRef(new Map),l=j.useRef(new Map),u=j.useRef(new Map),d=j.useRef(new Map),p=j.useRef(new $e),g={current:0},m=[],v=Wf(n.children,void 0,m);m.length&&console.warn("Surface found unsupported children",m);const[b,T]=di(o.current,v,je.EVENT_MANAGER,g),[w,E]=di(c.current,v,je.RESOURCE,g),[x,_,{nameConflict:I}]=di(d.current,v,je.SCENE,g),[M,C,{nameConflict:F}]=di(u.current,v,je.LAYER,g),[Q,B,{nameConflict:O}]=di(l.current,v,je.VIEW,g);if(I.size>0){console.warn("Root Scene name conflict:",I);return}if(F.size>0){console.warn("Root Scene Layer name conflict:",F);return}if(O.size>0){console.warn("Root Scene View name conflict:",O);return}const X=async ne=>{r.current&&(i.current=ne,r.current.draw(ne))},W=ne=>{var Z,K,Oe,le,we,He;(Z=e.current)==null||Z.remove(),(le=r.current)==null||le.resize(((K=t.current)==null?void 0:K.offsetWidth)||0,((Oe=t.current)==null?void 0:Oe.offsetHeight)||0),e.current&&((we=t.current)==null||we.appendChild(e.current)),ne||(He=r.current)==null||He.draw(i.current)},q=()=>{window.clearTimeout(a.current),a.current=window.setTimeout(()=>{W(!0)})};return Gn({async didMount(){var mr;if(!e.current||!t.current)return;const[ne,Z,K,Oe,le]=await Promise.all([T,E,_,C,B]),we=K.filter(de),He=ne.filter(de),Vn=Z.filter(de),$n=Oe.filter(de),_n=le.filter(de);if(K.length<=0&&(!($n!=null&&$n.length)||!(_n!=null&&_n.length))){console.error("No scenes or root level Layers+Views provided to surface");return}_n.length&&$n.length&&we.unshift({key:"root",layers:$n,views:_n});const Wn=await new ff({context:e.current,handlesWheelEvents:n.handlesWheelEvents!==void 0?n.handlesWheelEvents:!0,pixelRatio:n.pixelRatio||window.devicePixelRatio,eventManagers:He,ioExpansion:n.ioExpansion,shaderTransforms:n.shaderTransforms,resourceManagers:n.resourceManagers,rendererOptions:Object.assign({alpha:!0,antialias:!1},n.options)}).ready;return s.current=Sc(X),Wn.pipeline({resources:Vn,scenes:we}),r.current=Wn,await Cn(),W(!0),(mr=n.ready)==null||mr.resolve(r.current),window.addEventListener("resize",q),()=>{var ki;window.removeEventListener("resize",q),qh(s.current),(ki=r.current)==null||ki.destroy()}}}),Ue.jsx("div",{ref:t,"data-deltav-version":"4.2.4",className:`SurfaceJSX ${n.className||""}`,...n.containerProps,children:Ue.jsx("canvas",{ref:e,children:Ue.jsx(fr.Provider,{value:{writeToDom:n.writeToDom,eventResolvers:o.current,resourceResolvers:c.current,viewResolvers:l.current,layerResolvers:u.current,sceneResolvers:d.current,resolversReady:p.current},children:Ue.jsx(wn,{tagName:"Surface",...n,children:hl(b,w,Q,M,x)})})})})},Hf=n=>(Gn({didMount(){var t;(t=n.resolver)==null||t.resolve(new el(n.handlers,n.preserveEvents))}}),Ue.jsx(wn,{tagName:"QueuedEventHandler",...n}));Hf.surfaceJSXType=je.EVENT_MANAGER;const Xf=n=>(Gn({didMount(){var t;(t=n.resolver)==null||t.resolve(new bs(n.handlers))}}),Ue.jsx(wn,{tagName:"SimpleEventHandler",...n}));Xf.surfaceJSXType=je.EVENT_MANAGER;const Qf=n=>(Gn({didMount(){var t;(t=n.resolver)==null||t.resolve(new gf(n.config))}}),Ue.jsx(wn,{tagName:"BasicCamera2DController",...n}));Qf.surfaceJSXType=je.EVENT_MANAGER;const Yf=n=>(Gn({didMount(){var t;(t=n.resolver)==null||t.resolve(Dc({key:n.name,height:n.height,width:n.width,textureSettings:n.textureSettings}))}}),Ue.jsx(wn,{tagName:"Texture",...n}));Yf.surfaceJSXType=je.RESOURCE;const qf=n=>(Gn({didMount(){var t;(t=n.resolver)==null||t.resolve(zc({key:n.name,fontSource:n.fontSource,characterFilter:n.characterFilter,dynamic:n.dynamic,fontMap:n.fontMap,fontMapSize:n.fontMapSize}))}}),Ue.jsx(wn,{tagName:"Font",...n}));qf.surfaceJSXType=je.RESOURCE;const Ma=n=>{const t=j.useContext(fr);return Gn({async didMount(){var a,o;let e=n.config;const i=n.uses;if(i){await(t==null?void 0:t.resolversReady);const c={},l=i.names.map(async u=>{var g,m;const d=(g=t==null?void 0:t.resourceResolvers)==null?void 0:g.get(u);if(!d)return console.error(`A layer requested a resource: ${u} but the name identifier was not found in the available resources`),console.warn("Available resources:",Array.from(((m=t==null?void 0:t.resourceResolvers)==null?void 0:m.keys())||[])),null;const p=await d.promise;if(!p)return console.error(`The Layer requested a resource "${u}", but the resource did not resolve a value`),null;if(!xi(p))return console.error(`The Layer requested a resource "${u}", but the resource resolved to a value that is not a render texture resource`),null;c[u]=p}).filter(de);await Promise.all(l),e=i.apply(c,{...n.config})}const r=Ri(n.type,{key:n.name,...e});let s=((a=n.providerRef)==null?void 0:a.current)||r.init[1].data;s===r.init[0].defaultProps.data&&(s=new pe),r.init[1].data=s,n.providerRef&&s instanceof pe&&(n.providerRef.current=s),(o=n.resolver)==null||o.resolve(r)}}),Ue.jsx(wn,{tagName:"Layer",...n})};Ma.surfaceJSXType=je.LAYER;function Kf(n,t,e){var r,s;const i=(r=t==null?void 0:t.resourceResolvers)==null?void 0:r.get(e);return i||(console.error(`A View "${n}" requested a resource: ${e} but the name identifier was not found in the available resources`),console.warn("Available resources:",Array.from(((s=t==null?void 0:t.resourceResolvers)==null?void 0:s.keys())||[])),null)}const Ca=n=>{const t=j.useContext(fr);return Gn({async didMount(){var c,l,u;n.config.output&&!n.output&&console.warn("Do NOT use the output property in the config. Use the output property on the props of the JSX element"),await(t==null?void 0:t.resolversReady);const e=((c=n.output)==null?void 0:c.buffers)||{},i=Object.entries(e).map(([d,p])=>{const g=Kf(n.name,t,p);return g?[Number.parseInt(d),g,p]:(console.warn("View props",n),null)}).filter(de),r={};await Promise.all(i.map(async d=>{const p=await d[1].promise;xi(p)||la(p)?r[d[0]]=p:(console.error(`A View "${n.name}" requested an output buffer for the resource with name: ${d[2]} but the resource indicated is not a valid output target type.`,"Ensure the resource is a RenderTextureResource or ColorBufferResource"),console.warn("View props",n))}));let s=!0;const a=(l=n.output)==null?void 0:l.depth;if(Ub(a)){const d=Kf(n.name,t,a);if(!d)console.warn("View props",n),s=!1;else{const p=await d.promise;xi(p)||la(p)?s=p:(console.error(`A View "${n.name}" requested a depth buffer for the resource with name: ${a} but the resource indicated is not a valid output target type.`,"Ensure the resource is a RenderTextureResource or ColorBufferResource"),console.warn("View props",n))}}else de(a)&&(s=a);const o=Zc(n.type,{key:n.name,...n.config,output:n.output?{buffers:r,depth:s}:void 0});(u=n.resolver)==null||u.resolve(o)}}),Ue.jsx(wn,{tagName:"View",...n})};Ca.surfaceJSXType=je.VIEW;const La=n=>{var u,d,p,g;const t=j.useContext(fr),e={current:0},i=Wf(n.children),[r,s,{nameConflict:a}]=di((t==null?void 0:t.layerResolvers)||new Map,i,je.LAYER,e,n.name),[o,c,{nameConflict:l}]=di((t==null?void 0:t.viewResolvers)||new Map,i,je.VIEW,e,n.name);if(a.size>0){console.warn(`Scene ${n.name} Layer name conflict:`,a),(u=n.resolver)==null||u.resolve(null);return}if(l.size>0){console.warn(`Scene ${n.name} View name conflict:`,l),(d=n.resolver)==null||d.resolve(null);return}if(!r){console.warn("A Scene had no Layers:",n.name),(p=n.resolver)==null||p.resolve(null);return}if(!o){console.warn("A Scene had no Views:",n.name),(g=n.resolver)==null||g.resolve(null);return}return Gn({async didMount(){var b;const[m,v]=await Promise.all([s,c]);(b=n.resolver)==null||b.resolve({key:n.name,layers:m.filter(de),views:v.filter(de)})}}),Ue.jsx(wn,{tagName:"Scene",...n,children:hl(o,r)})};La.surfaceJSXType=je.SCENE;function zb(n){const t=[];for(let e=0,i=n.length;e<i;++e){const r=n[e];for(let s=0,a=r.length;s<a;++s)t.push(r[s])}return t}var Vb=Object.defineProperty,$b=Object.getOwnPropertyDescriptor,Wb=(n,t,e,i)=>{for(var r=i>1?void 0:i?$b(t,e):t,s=n.length-1,a;s>=0;s--)(a=n[s])&&(r=(i?a(t,e,r):a(r))||r);return i&&r&&Vb(t,e,r),r};const Zf=class extends Ye{constructor(){super();f(this,"tint",[1,1,1,1]);Qe(this,Zf)}};let dl=Zf;Wb([L],dl.prototype,"tint",2);const Jf=new se({data:{width:2,height:2,buffer:new Uint8Array(16)}});class fl extends bt{initShader(){const{buffers:t,fs:e,data:i}=this.props,r=new dl;i instanceof pe&&i.add(r),this.alwaysDraw=!0;const s=[[-1,-1],[1,-1],[-1,1],[1,1]],a=s.map(l=>[l[0]===1?1:0,l[1]===1?1:0]),o=zb(Object.keys(t).map(l=>{const u=t[l];if(!u)return;const d=u.key,p=ts({key:d});return[{name:l,shaderInjection:S.FRAGMENT,size:R.TEXTURE,update:()=>(this.resource.request(this,r,p),p.texture||Jf)},{name:`${l}_size`,shaderInjection:S.FRAGMENT,size:R.TWO,update:()=>{this.props,this.resource.request(this,r,p);const g=(p.texture||Jf).data;return[(g==null?void 0:g.width)||1,(g==null?void 0:g.height)||1]}}]}).filter(de));let c=this.props.uniforms||[];return Array.isArray(c)||(c=c(this)),{drawMode:h.GLSettings.Model.DrawMode.TRIANGLE_STRIP,vs:`
        varying vec2 texCoord;

        void main() {
          gl_Position = vec4(vertex, 0.0, 1.0);
          texCoord = tex;
        }
      `,fs:e,instanceAttributes:[{name:"dummy",size:P.ONE,update:l=>[0]}],uniforms:o.concat(c),vertexAttributes:[{name:"vertex",size:Ge.TWO,update:l=>s[l]},{name:"tex",size:Ge.TWO,update:l=>a[l]}],vertexCount:4}}shouldDrawView(){return!this.props.preventDraw}getMaterialOptions(){return rt.transparentImageBlending.modify({depthTest:!1})}}f(fl,"defaultProps",{key:"",data:new pe,buffers:{},baseShaderModules:()=>({fs:[],vs:[]}),fs:"void main() { gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);"});const Tn=n=>{var t;return Ue.jsxs(La,{name:n.name,children:[Ue.jsx(Ca,{name:"fullscreen",type:xa,...n.view,config:{camera:new hn,viewport:{left:0,top:0,width:"100%",height:"100%"},...(t=n.view)==null?void 0:t.config}}),Ue.jsx(Ma,{name:"postprocess",type:fl,uses:{names:Object.values(n.buffers),apply:(e,i)=>{var r;return i.buffers={},Object.keys(n.buffers).map(s=>{i.buffers[s]=e[n.buffers[s]]}),(r=n.onResources)==null||r.call(n,e),i}},config:{printShader:n.printShader,buffers:{},fs:n.shader,uniforms:n.uniforms,materialOptions:n.material,preventDraw:n.preventDraw}})]},n.name)},jb=n=>Ue.jsxs(La,{name:n.name,children:[Ue.jsx(Ca,{type:xa,config:{camera:new hn}}),Ue.jsx(Ma,{type:nl,config:{commands:n.callback}})]}),Hb=`\${import: camera}
varying vec2 texCoord;

void main() {
  vec2 texelSize = 1.0 / viewSize;
  vec4 o = texelSize.xyxy * vec2(-delta, delta).xxyy;

  vec4 s =
    texture2D(color, texCoord + o.xy) + texture2D(color, texCoord + o.zy) +
    texture2D(color, texCoord + o.xw) + texture2D(color, texCoord + o.zw);

  gl_FragColor = s * 0.25;
}
`;var Oa=(n=>(n[n.DOWN=0]="DOWN",n[n.UP=1]="UP",n))(Oa||{});function pl(n){const{output:t,input:e}=n;return Tn({name:n.name,printShader:n.printShader,view:Object.assign(t?{output:{buffers:{[H.COLOR]:t},depth:!1}}:{},n.view),buffers:{color:e},shader:Hb,material:n.material,uniforms:[{name:"delta",size:R.ONE,shaderInjection:S.FRAGMENT,update:()=>n.direction===0?1:.5}]})}function Xb(n){const{compose:t,output:e,resources:i,view:r}=n,s={blending:{blendDst:h.GLSettings.Material.BlendingDstFactor.One,blendSrc:h.GLSettings.Material.BlendingSrcFactor.One,blendEquation:h.GLSettings.Material.BlendingEquations.Add}},a=[];for(let o=0,c=n.samples;o<c;++o){const l=pl({name:`${n.name}.box-down${o}`,printShader:n.printShader,input:i[o],output:i[o+1],direction:Oa.DOWN,material:{blending:void 0}});a.push(l)}for(let o=n.samples-1;o>0;--o){const c=pl({name:`${n.name}.box-up${o}`,printShader:n.printShader,input:i[o+1],output:i[o],direction:Oa.UP,material:s});a.push(c)}return t&&a.push(Tn({name:`${n.name}.compose`,printShader:n.printShader,buffers:{color:t,glow:i[1]},material:s,view:{...e?{output:{buffers:{[H.COLOR]:e},depth:!1}}:void 0,...r},uniforms:[{name:"gamma",size:R.ONE,shaderInjection:S.ALL,update:()=>[n.gammaCorrection||1]}],shader:`
          varying vec2 texCoord;

          void main() {
            vec3 base = texture2D(color, texCoord).rgb;
            vec3 glow = texture2D(glow, texCoord).rgb;

            ${n.gammaCorrection!==void 0?`
              vec3 result = mix(
                base,
                glow + base,
                ((glow.r + glow.g + glow.b) * gamma)
              );
            `:`
              vec3 result = base + glow;
            `}

            gl_FragColor = vec4(result, 1.0);
          }
        `})),a}function Qb(n){return Array.isArray(n[0])}const Yb=n=>{const t=n.scale||Rs(1,1),i=(Qb(t)?t:[n.scale]).map(s=>xs(s)),r=1/i.length;if(de(n.drift)){const s=n.drift;return Tn({name:n.name,buffers:{},view:{output:{buffers:{[H.COLOR]:n.output},depth:!1}},uniforms:[{name:"drift",size:R.THREE,shaderInjection:S.FRAGMENT,update:()=>s}],shader:`
        \${import: time, simplexNoise3D}

        void main() {
          float value = 0.;
          ${i.map(a=>`value += simplexNoise3D(vec3(gl_FragCoord.xy * vec2(${a[0]}f, ${a[1]}f), 0.) + (drift * time));`).join(`
`)}
          value *= ${r.toFixed(1)}f;
          \${out: color} = vec4(value, value, value, 1.);
        }
      `})}else if(de(n.zOffset)){const s=n.zOffset;return Tn({name:n.name,buffers:{},view:{output:{buffers:{[H.COLOR]:n.output},depth:!1}},uniforms:[{name:"zOffset",size:R.ONE,update:qo(s)?()=>[s]:()=>[s()]}],shader:`
        \${import: simplexNoise3D}

        void main() {
          float value = 0.;
          ${i.map(a=>`
            value += simplexNoise3D(vec3(gl_FragCoord.xy * vec2(${a[0]}f, ${a[1]}f), zOffset));
          `).join(`
`)}
          value *= ${r.toFixed(1)}f;
          \${out: color} = vec4(value, value, value, 1.);
        }
      `})}else return Tn({name:n.name,buffers:{},view:{output:{buffers:{[H.COLOR]:n.output},depth:!1}},shader:`
        \${import: simplexNoise2D}

        void main() {
          float value = 0.;
          ${i.map(s=>`
            value += simplexNoise2D(gl_FragCoord.xy * vec2(${s[0]}f, ${s[1]}f));
          `).join(`
`)}
          value *= ${r.toFixed(1)}f;
          \${out: color} = vec4(value, value, value, 1.);
        }
      `})};function qb(n){var s;const{output:t,input:e,channel:i,grayScale:r}=n;return Tn({name:n.name,printShader:n.printShader,view:{output:t?{buffers:{[H.COLOR]:t||""},depth:!1}:void 0,...n.view,config:{camera:new hn,...(s=n.view)==null?void 0:s.config}},buffers:{color:e},shader:r&&i?`
      varying vec2 texCoord;

      void main() {
        gl_FragColor = vec4(texture2D(color, texCoord).${i}${i}${i}, 1.);
      }
    `:i?`
      varying vec2 texCoord;

      void main() {
        gl_FragColor = vec4(texture2D(color, texCoord).${i}, 0., 0., 1.);
      }
    `:`
      varying vec2 texCoord;

      void main() {
        gl_FragColor = texture2D(color, texCoord);
      }
    `,material:n.material,onResources:a=>{Object.values(a).forEach(o=>{(!o.textureSettings||o.textureSettings.generateMipMaps===void 0||o.textureSettings.generateMipMaps===!0)&&De("drawjsx-resource-error",()=>{console.warn("POSSIBLE ERROR: for the draw post effect,","it is a common mistake to leave mipmaps enabled on the input texture.","Often the mipmaps are not available in the target resource and thus","you will get a blank output when rendering in certain scenarios.")})})}})}function Kb(n){const{output:t,input:e,view:i}=n,r=[];return r.push(Tn({name:`${n.name}_base`,printShader:n.printShader,buffers:{trailTex:e.trail,addTex:e.add},material:{blending:null},view:{config:{clearFlags:[lr.COLOR]},output:{buffers:{[H.COLOR]:t},depth:!1},...i},shader:`
          varying vec2 texCoord;

          void main() {
            // Add the trailTex and addTex but fade out the trailTex slightly
            vec4 addT = texture2D(addTex, texCoord);
            vec4 trailT = texture2D(trailTex, texCoord);

            // Blend the textures
            float alpha = addT.a + trailT.a * (1.0 - addT.a); // Compute final alpha
            vec3 color;
            if (alpha > 0.0) { // Avoid division by zero
              color = (addT.rgb * addT.a + trailT.rgb * trailT.a * (1.0 - addT.a)) / alpha;
            } else {
              color = vec3(0.0); // Fallback to black (or any other fallback color)
            }

            gl_FragColor = vec4(color, alpha);
          }
        `})),n.drift?n.drift&&r.push(Tn({name:n.name,printShader:n.printShader,buffers:{tex:t},material:{blending:null},view:{output:{buffers:{[H.COLOR]:e.trail},depth:!1},...i},uniforms:[{name:"drift",size:R.TWO,shaderInjection:S.FRAGMENT,update:()=>{var s;return((s=n.drift)==null?void 0:s.direction)||[0,0]}}],shader:`
          varying vec2 texCoord;

          void main() {
            vec4 fade = texture2D(tex, texCoord + (drift / tex_size));
            fade.rgba *= ${n.intensity||.7};
            \${out: color} = fade;
          }
        `})):r.push(Tn({name:n.name,printShader:n.printShader,buffers:{tex:t},material:{blending:null},view:{output:{buffers:{[H.COLOR]:e.trail},depth:!1},...i},shader:`
          varying vec2 texCoord;

          void main() {
            vec4 fade = texture2D(tex, texCoord);
            fade.rgba *= ${n.intensity||.7};
            \${out: color} = fade;
          }
        `})),r}class ep extends bt{constructor(t,e,i){super(t,e,i),console.warn("Please ensure all debugLayer calls are removed for production:",i.key)}childLayers(){return this.props.wrap?(this.props.wrap.init[1].key=`debug-wrapper.${this.props.key}`,[this.props.wrap]):[]}draw(){if(!this.props.wrap)return;const t=this.resolveChanges(!0);if(t.length===0)return;const{messageHeader:e=()=>""}=this.props;console.warn(`${e()}
`,{totalChanges:t.length,changes:t})}initShader(){if(!this.props.wrap)return null;const t=new this.props.wrap.init[0](this.surface,this.scene,this.props.wrap.init[1]),e=t.childLayers(),i={};for(;e.length>0;){const r=e.pop();if(!r)continue;const s=new r.init[0](this.surface,this.scene,r.init[1]);i[s.id]={shaderIO:s.initShader()},s.childLayers().forEach(a=>e.push(a))}return console.warn(`Shader IO: ${this.id}
`,{shaderIO:t.initShader(),childLayers:i}),null}}f(ep,"defaultProps",{data:new pe,key:"default",messageHeader:()=>"",wrap:Ri(bt,{data:new pe})});function Zb(n,t){const e=Ai(ep,{messageHeader:()=>`CHANGES FOR: ${e.init[1].key}`,wrap:Ai(n,t),data:t.data});return e}h.ActiveIOExpansion=Ud,h.AnchorType=U,h.ArcInstance=Un,h.ArcLayer=rs,h.ArcScaleType=vf,h.Atlas=dd,h.AtlasManager=pd,h.AtlasResourceManager=md,h.Attribute=Ut,h.AutoEasingLoopStyle=rn,h.AutoEasingMethod=Ks,h.Axis2D=Uf,h.BaseIOExpansion=es,h.BaseIOSorting=cf,h.BaseProjection=Xs,h.BaseResourceManager=Ji,h.BaseShaderIOInjection=gd,h.BasicCamera2DController=gf,h.BasicCamera2DControllerJSX=Qf,h.BasicIOExpansion=Bd,h.BasicInstance=Yg,h.BloomJSX=Xb,h.Bounds=ie,h.BoxSampleJSX=pl,h.BoxSampleJSXDirection=Oa,h.BufferManagerBase=ir,h.Camera=On,h.Camera2D=hn,h.CameraBoundsAnchor=pf,h.CameraProjectionType=Ln,h.CircleInstance=as,h.CircleLayer=ss,h.ClearFlags=lr,h.CommandLayer=nl,h.CommandsJSX=jb,h.CommonMaterialOptions=rt,h.Control2D=Bn,h.CubeInstance=ll,h.CubeLayer=kf,h.CustomTag=wn,h.DEFAULT_IO_EXPANSION=uf,h.DEFAULT_RESOURCE_MANAGEMENT=hf,h.DEFAULT_RESOURCE_ROUTER=Md,h.DEFAULT_SHADER_TRANSFORM=df,h.DrawJSX=qb,h.EasingIOExpansion=Pd,h.EasingUtil=Kg,h.EdgeBroadphase=il,h.EdgeInstance=oi,h.EdgeLayer=cs,h.EdgeScaleType=os,h.EdgeType=fn,h.EulerOrder=ae,h.EventManager=ht,h.FontGlyphRenderSize=Ad,h.FontJSX=qf,h.FontManager=Id,h.FontMap=yd,h.FontMapGlyphType=pa,h.FontRenderer=xd,h.FontResourceManager=Sd,h.FontResourceRequestFetch=Mi,h.FragmentOutputType=H,h.GLProxy=Cr,h.GLState=cu,h.Geometry=An,h.GlyphInstance=Rt,h.GlyphLayer=ur,h.Hadamard2x2=zu,h.Hadamard3x3=Vu,h.Hadamard4x4=$u,h.INVALID_RESOURCE_MANAGER=nd,h.IdentityTransform=Zh,h.ImageInstance=pn,h.ImageLayer=yf,h.ImageRasterizer=Ii,h.IndexBufferSize=$i,h.Instance=Ye,h.Instance3D=bn,h.InstanceAttributeBufferManager=kd,h.InstanceAttributePackingBufferManager=Gd,h.InstanceAttributeSize=P,h.InstanceBlockIndex=Ho,h.InstanceDiffType=Te,h.InstanceProvider=pe,h.InstanceProviderWithList=jg,h.InvalidResourceManager=td,h.LabelInstance=oe,h.LabelLayer=sl,h.Layer=bt,h.Layer2D=Be,h.LayerBufferType=ce,h.LayerInteractionHandler=nf,h.LayerJSX=Ma,h.LayerMouseEvents=lf,h.LayerScene=_a,h.M200=qn,h.M201=Kn,h.M210=Zn,h.M211=Jn,h.M300=Or,h.M301=Nr,h.M302=Pr,h.M310=Dr,h.M311=Br,h.M312=Ur,h.M320=Fr,h.M321=kr,h.M322=Gr,h.M3R=Ti,h.M400=Gt,h.M401=zt,h.M402=Vt,h.M403=$t,h.M410=Wt,h.M411=jt,h.M412=Ht,h.M413=Xt,h.M420=Qt,h.M421=Yt,h.M422=qt,h.M423=Kt,h.M430=Zt,h.M431=Jt,h.M432=en,h.M433=tn,h.M4R=ze,h.Material=Lr,h.MaterialUniformType=Se,h.MatrixMath=Dg,h.Model=Ko,h.MouseButton=xl,h.NOOP=ks,h.NewLineCharacterMode=hr,h.NoView=sf,h.ObservableMonitoring=_e,h.PackNode=qe,h.PickType=Y,h.PostProcessInstance=dl,h.PostProcessJSX=Tn,h.PostProcessLayer=fl,h.Projection3D=Df,h.PromiseResolver=$e,h.QR1=mh,h.QR2=vh,h.QR3=bh,h.QR4=wh,h.QW=_h,h.QX=Th,h.QY=yh,h.QZ=Eh,h.QuadTree=cd,h.QuadTreeNode=er,h.QuadTreeQuadrants=od,h.QuaternionMath=Bg,h.QueuedEventHandler=el,h.QueuedEventHandlerJSX=Hf,h.REQUEST=Om,h.RESOURCE=Lm,h.RayMath=Ug,h.ReactiveDiff=Zr,h.RectangleInstance=wt,h.RectangleLayer=ds,h.ReferenceCamera2D=M0,h.RenderTarget=Yn,h.RenderTexture=Bc,h.RenderTextureResourceManager=vd,h.ResourcePool=rm,h.ResourceRouter=Vc,h.ResourceType=he,h.RingInstance=dr,h.RingLayer=ps,h.SRT4x4=qs,h.SRT4x4_2D=vc,h.ScaleMode=dn,h.Scene=Vs,h.SceneGraphLayer=Ff,h.SceneJSX=La,h.ShaderInjectionTarget=S,h.ShaderModule=xe,h.ShaderModuleUnit=Ta,h.SimpleEventHandler=bs,h.SimpleEventHandlerJSX=Xf,h.SimpleProjection=_u,h.SimplexNoiseJSX=Yb,h.StreamChangeStrategy=Gs,h.SubTexture=Nn,h.Surface=ff,h.SurfaceContext=fr,h.SurfaceErrorType=Yo,h.SurfaceJSX=Gb,h.TRS4x4=Wr,h.TRS4x4_2D=hh,h.TextAlignment=Ia,h.TextAreaInstance=li,h.TextAreaLayer=Lf,h.Texture=se,h.TextureIOExpansion=da,h.TextureJSX=Yf,h.TextureSize=ft,h.TrailJSX=Kb,h.Transform=ca,h.Transform2D=Mb,h.TreeNode=Lc,h.UniformBufferManager=Vd,h.UniformSize=R,h.UseMaterialStatus=Et,h.UserInputEventManager=af,h.V3R=Xe,h.V4R=Rl,h.VecMath=G,h.VectorMath=Fg,h.VertexAttributeSize=Ge,h.View=Ni,h.View2D=xa,h.View3D=Bf,h.ViewJSX=Ca,h.WebGLRenderer=uu,h.WebGLStat=N,h.WordWrap=mn,h.add1=ws,h.add2=xn,h.add2x2=Du,h.add3=Nt,h.add3x3=Bu,h.add4=Ms,h.add4by3=Vl,h.add4x4=Uu,h.addQuat=xh,h.affineInverse2x2=Au,h.affineInverse3x3=Iu,h.affineInverse4x4=Su,h.angleQuat=Uh,h.apply1=ke,h.apply2=ge,h.apply2x2=vt,h.apply3=ve,h.apply3x3=et,h.apply4=me,h.apply4x4=ye,h.atlasRequest=tr,h.axisQuat=Fh,h.ceil1=Ga,h.ceil2=ro,h.ceil3=vo,h.ceil4=xo,h.clamp=it,h.color4FromHex3=Hl,h.color4FromHex4=Xl,h.colorBufferFormat=Zl,h.colorUID=Dp,h.compare1=za,h.compare2=_s,h.compare2x2=oh,h.compare3=Tr,h.compare3x3=ch,h.compare4=Cs,h.compare4x4=mc,h.concat4x4=Pu,h.concatChildren=hl,h.conjugateQuat=Ec,h.convertToSDF=ym,h.copy1=Va,h.copy2=Es,h.copy2x2=lh,h.copy3=st,h.copy3x3=uh,h.copy4=Dt,h.copy4x4=ji,h.create=im,h.createAtlas=hd,h.createAttribute=sd,h.createChildLayer=Ai,h.createEasingAttribute=Vm,h.createFont=zc,h.createLayer=Ri,h.createLayer2Din3D=Rb,h.createMaterialOptions=Lp,h.createTexture=Dc,h.createUniform=ld,h.createVertex=ud,h.createView=Zc,h.cross1=Wa,h.cross2=ao,h.cross3=Ze,h.cross4=Ao,h.debugLayer=Zb,h.decomposeRotation=ra,h.depthBufferFormat=Jl,h.determinant2x2=be,h.determinant3x3=yi,h.determinant4x4=cc,h.diffUnitQuat=Ih,h.divide1=ja,h.divide2=wr,h.divide3=yr,h.divide4=Io,h.divideQuat=Rh,h.dot1=eo,h.dot2=Gi,h.dot3=Er,h.dot4=Ps,h.dotQuat=Oh,h.down3=zl,h.drawMode=pi,h.empty1=Ha,h.empty2=oo,h.empty3=bo,h.empty4=So,h.eulerToQuat=zh,h.eventElementPosition=Ft,h.exponentQuat=Ah,h.filterQuery=em,h.flatten1=Xa,h.flatten2=co,h.flatten3=wo,h.flatten4=Ls,h.floor1=Qa,h.floor2=lo,h.floor3=To,h.floor4=Mo,h.fontRequest=Ci,h.forward1=$a,h.forward2=so,h.forward3=fi,h.forward4=Ro,h.fromEulerAxisAngleToQuat=Nh,h.fromOrderedEulerToQuat=xc,h.fuzzyCompare1=Sl,h.fuzzyCompare2=Ll,h.fuzzyCompare3=Dl,h.fuzzyCompare4=$l,h.generateDefaultScene=Cd,h.generateLayerGeometry=Od,h.generateLayerMaterial=Ld,h.generateLayerModel=nr,h.getAbsolutePositionBounds=zo,h.getProgramInfo=vp,h.iQuat=Hh,h.identity2=zr,h.identity3=nn,h.identity4=fe,h.imaginaryQuat=Lh,h.indexToColorAttachment=Rr,h.indexToTextureUnit=tu,h.injectShaderIO=Yd,h.inputImageFormat=xr,h.instanceAttributeSizeFloatCount=iu,h.inverse1=Ya,h.inverse2=xs,h.inverse3=zi,h.inverse4=Co,h.inverseQuat=Sh,h.isAtlasResource=Uc,h.isBoolean=Qn,h.isBufferLocation=Km,h.isBufferLocationGroup=Wc,h.isDefined=de,h.isFontResource=Gc,h.isFunction=Op,h.isInstanceAttributeBufferLocation=Jm,h.isInstanceAttributeBufferLocationGroup=Fd,h.isInstanceAttributeVector=Ip,h.isNewline=Cp,h.isNumber=qo,h.isOffscreenCanvas=bi,h.isOrthographic=Jh,h.isPerspective=Oc,h.isRenderTextureResource=xi,h.isResourceAttribute=Sp,h.isString=Sn,h.isUniformBufferLocation=zd,h.isUniformFloat=$p,h.isUniformMat3=Gp,h.isUniformMat4=zp,h.isUniformTexture=Vp,h.isUniformVec2=Up,h.isUniformVec3=Fp,h.isUniformVec4=kp,h.isUniformVec4Array=au,h.isVec1=Al,h.isVec2=ka,h.isVec3=Il,h.isVec4=V,h.isVideoResource=us,h.isWhiteSpace=vi,h.jQuat=Xh,h.kQuat=Qh,h.left3=Gl,h.length1=no,h.length1Components=Cl,h.length2=Hn,h.length2Components=mo,h.length3=As,h.length3Components=_o,h.length4=Ds,h.length4Components=Rn,h.lengthQuat=_c,h.linear1=to,h.linear2=go,h.linear3=Eo,h.linear4=Oo,h.lookAtMatrix=Wh,h.lookAtQuat=Rc,h.magFilter=mi,h.makeFontSDF=Em,h.makeObservable=Qe,h.mapGetWithDefault=ha,h.mapInjectDefault=ni,h.matrix3x3FromUnitQuatModel=na,h.matrix3x3FromUnitQuatView=Gh,h.matrix3x3ToQuaternion=Vh,h.matrix4x4FromUnitQuatModel=kh,h.matrix4x4FromUnitQuatView=ia,h.matrix4x4ToQuaternion=$h,h.max1=qa,h.max2=uo,h.max3=Is,h.max4=No,h.min1=Ka,h.min2=ho,h.min3=Ss,h.min4=Po,h.minFilter=In,h.multiply1=Za,h.multiply2=fo,h.multiply2x2=Ou,h.multiply3=yo,h.multiply3x3=Nu,h.multiply4=Lo,h.multiply4x4=ot,h.multiplyQuat=Tc,h.multiplyScalar2x2=Mu,h.multiplyScalar3x3=Cu,h.multiplyScalar4x4=Lu,h.newLineCharRegEx=Qo,h.newLineRegEx=ru,h.nextFrame=Kr,h.normalize1=Ja,h.normalize2=po,h.normalize3=dt,h.normalize4=Do,h.normalizeQuat=Mh,h.normalizeWheel=ac,h.observable=L,h.onAnimationLoop=Sc,h.onFrame=Cn,h.oneQuat=Qr,h.orthographic4x4=pc,h.packAttributes=jd,h.perspective4x4=fc,h.perspectiveFOVY4x4=ah,h.perspectiveFrustum4x4=Qs,h.preloadNumber=Im,h.project3As4ToScreen=Ys,h.projectToScreen=gc,h.ray=Ac,h.rayFromPoints=Ic,h.rayToLocation=Yh,h.realQuat=Ch,h.removeComments=Jr,h.renderGlyph=Fc,h.resolveUpdate=Cc,h.reverse2=Pl,h.reverse3=Ul,h.reverse4=jl,h.right3=kl,h.rotateVectorByUnitQuat=sa,h.rotation2x2=lc,h.rotation4x4=uc,h.rotation4x4by3=ih,h.scale1=Ts,h.scale2=Ce,h.scale3=at,h.scale4=Os,h.scale4x4=hc,h.scale4x4by3=rh,h.scaleQuat=yc,h.scheduleUpdate=Mc,h.shaderTemplate=ii,h.shallowCompare=bc,h.shearX2x2=Hu,h.shearX4x4=Qu,h.shearY2x2=Xu,h.shearY4x4=Yu,h.shearZ4x4=qu,h.slerpQuat=Bo,h.slerpUnitQuat=jh,h.stencilBufferFormat=eu,h.stopAllFrameCommands=kg,h.stopAnimationLoop=qh,h.subTextureIOValue=ri,h.subtract1=ys,h.subtract2=Ae,h.subtract2x2=Fu,h.subtract3=Pt,h.subtract3x3=ku,h.subtract4=Ns,h.subtract4x4=Gu,h.texelFormat=gi,h.textureRequest=ts,h.textureUnitToIndex=$o,h.toEulerFromQuat=Dh,h.toEulerXYZfromOrderedEuler=Ph,h.toOrderedEulerFromQuat=ta,h.toOrderedEulerFromQuat2=Bh,h.toString1=Ql,h.toString2=Yl,h.toString2x2=eh,h.toString3=ql,h.toString3x3=th,h.toString4=Kl,h.toString4x4=nh,h.tod1=Ml,h.tod2=Ol,h.tod3=Bl,h.tod4=Wl,h.tod_flip2=Nl,h.touchesContainsStartView=Eu,h.touchesHasStartView=yu,h.transform2=Ku,h.transform3=Zu,h.transform3as4=Ju,h.transform4=$r,h.translation4x4=dc,h.translation4x4by3=sh,h.transpose2x2=Wu,h.transpose3x3=Vr,h.transpose4x4=ju,h.uid=z,h.up3=Fl,h.useChildResolvers=di,h.vec1=io,h.vec1Methods=Uo,h.vec2=Rs,h.vec2Methods=Fo,h.vec3=Xn,h.vec3Methods=ko,h.vec4=_r,h.vec4Methods=Go,h.wait=tm,h.waitForValidDimensions=nm,h.whiteSpaceCharRegEx=Xo,h.whiteSpaceRegEx=Mp,h.wrapMode=Vo,h.zeroQuat=Ee,Object.defineProperty(h,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=index.js.map
