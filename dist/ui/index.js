(function(){"use strict";try{if(typeof document<"u"){var e=document.createElement("style");e.appendChild(document.createTextNode(".SurfaceJSX{flex:1 1 auto;display:flex;flex-direction:column;width:100%;height:100%;overflow:hidden}")),document.head.appendChild(e)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}})();
(function(d,q){var Pi=document.createElement("style");Pi.textContent=`.SurfaceJSX{flex:1 1 auto;display:flex;flex-direction:column;width:100%;height:100%;overflow:hidden}
`,document.head.appendChild(Pi),typeof exports=="object"&&typeof module<"u"?q(exports,require("react")):typeof define=="function"&&define.amd?define(["exports","react"],q):(d=typeof globalThis<"u"?globalThis:d||self,q(d.deltav={},d.React))})(this,function(d,q){"use strict";window.WebGL2RenderingContext=window.WebGL2RenderingContext||function(){};class Pi{get surface(){return this.userInputManager.surface}getProjection(e){const n=this.userInputManager.getView(e);return n?n.projection:null}getView(e){return this.userInputManager&&this.userInputManager.getView(e)||null}getViewScreenBounds(e){const n=this.userInputManager.getView(e);return n?n.screenBounds:null}setUserInputManager(e){this.userInputManager=e}willRender(){}didRender(){}}class is extends Pi{constructor(e){super(),Object.assign(this,e)}handleMouseDown(e){}handleMouseUp(e){}handleMouseOver(e){}handleMouseOut(e){}handleMouseMove(e){}handleClick(e){}handleDrag(e){}handleWheel(e){}handleTouchCancelled(e){}handleTouchDown(e){}handleTouchUp(e){}handleTouchOut(e){}handleTouchDrag(e){}handleTap(e){}handleDoubleTap(e){}handleLongTouch(e){}handleLongTap(e){}handlePinch(e){}handleSpread(e){}handleTouchRotate(e){}handleSwipe(e){}}var ul=(t=>(t[t.NONE=-1]="NONE",t[t.LEFT=0]="LEFT",t[t.AUX=1]="AUX",t[t.RIGHT=2]="RIGHT",t[t.FOURTH=3]="FOURTH",t[t.FIFTH=4]="FIFTH",t))(ul||{});const{sqrt:Ra,max:bt,min:Et,floor:_t,ceil:Rt,abs:xt,acos:lp,sin:xa}=Math,$e=new Array(20).fill(0).map(t=>[0,0,0]),hl=new Array(20).fill(0).map(t=>[0,0,0,0]);function dl(t){return t&&Array.isArray(t)&&t.length===1}function Aa(t){return t&&Array.isArray(t)&&t.length===2}function fl(t){return t&&Array.isArray(t)&&t.length===3}function U(t){return t&&Array.isArray(t)&&t.length===4}function Fe(t,e){return t=t||[],t[0]=e,t}function rs(t,e,n){return Fe(n,t[0]+e[0])}function Sa(t,e){return Fe(e,Rt(t[0]))}function Ma(t,e){return t[0]===e[0]}function pl(t,e,n){return xt(t[0]-e[0])<=n}function Ia(t,e){return Fe(e,t[0])}function Ca(){return[0]}function La(t,e,n){return Fe(n,0)}function Oa(t,e,n){return Fe(n,t[0]/e[0])}function Na(t){return Fe(t,0)}function Pa(t,e){e=e||[];for(let n=0,i=t.length;n<i;++n)e.push(t[n][0]);return e}function Da(t,e){return Fe(e,_t(t[0]))}function Fa(t,e){return Fe(e,1/t[0])}function ss(t,e,n){return Fe(n,t[0]*e)}function as(t,e,n){return Fe(n,t[0]-e[0])}function Ba(t,e,n){return Fe(n,bt(t[0],e[0]))}function Ua(t,e,n){return Fe(n,Et(t[0],e[0]))}function Ga(t,e,n){return Fe(n,t[0]*e[0])}function ka(t,e){return Fe(e,1)}function za(t,e){return t[0]*e[0]}function gl(t,e){return t[0]*e[0]}function Va(t,e,n,i){return rs(ss(as(e,t),n),t,i)}function Wa(t){return t[0]}function ml(t){return t}function $a(t,...e){let n;if(e=e||[],Array.isArray(t)?n=t.slice(0,1):n=[t],n.length<1)for(let i=0,r=e.length;i<r&&n.length<1;++i){const s=e[i];Array.isArray(s)?n.push(...s.slice(0,1-n.length)):n.push(s)}for(;n.length<1;)n.push(0);return n}function de(t,e,n){return t=t||new Array(2),t[0]=e,t[1]=n,t}function wn(t,e,n){return de(n,t[0]+e[0],t[1]+e[1])}function ja(t,e){return de(e,Rt(t[0]),Rt(t[1]))}function os(t,e){return de(e,t[0],t[1])}function Ha(t){return de(t,1,0)}function Qa(t,e,n){return de(n,0,0)}function cs(t,e){return t[0]===e[0]&&t[1]===e[1]}function vl(t,e,n){return xt(t[0]-e[0])<=n&&xt(t[1]-e[1])<=n}function cr(t,e,n){return de(n,t[0]/e[0],t[1]/e[1])}function Xa(t){return de(t,0,0)}function Ya(t,e){e=e||new Array(t.length*2);for(let n=0,i=0,r=t.length;n<r;++n,i+=2){const s=t[n];e[i]=s[0],e[i+1]=s[1]}return e}function qa(t,e){return de(e,_t(t[0]),_t(t[1]))}function ls(t,e){return de(e,1/t[0],1/t[1])}function Ka(t,e,n){return de(n,bt(t[0],e[0]),bt(t[1],e[1]))}function Za(t,e,n){return de(n,Et(t[0],e[0]),Et(t[1],e[1]))}function Re(t,e,n){return de(n,t[0]*e,t[1]*e)}function ye(t,e,n){const i=n||new Array(2);return i[0]=t[0]-e[0],i[1]=t[1]-e[1],i}function Ja(t,e,n){return de(n,t[0]*e[0],t[1]*e[1])}function eo(t,e){const n=Vn(t);return de(e,t[0]/n,t[1]/n)}function Di(t,e){return t[0]*e[0]+t[1]*e[1]}function wl(t,e){return t[0]*e[0]-t[1]*e[1]}function Tl(t,e){return t[0]*e[1]-t[1]*e[0]}function yl(t,e){return de(e,t[1],t[0])}function to(t,e,n,i){return wn(Re(ye(e,t),n),t,i)}function Vn(t){return no(t[0],t[1])}function no(t,e){return Ra(t*t+e*e)}function us(t,...e){let n;if(e=e||[],Array.isArray(t)?n=t.slice(0,2):n=[t],n.length<2)for(let i=0,r=e.length;i<r&&n.length<2;++i){const s=e[i];Array.isArray(s)?n.push(...s.slice(0,2-n.length)):n.push(s)}for(;n.length<2;)n.push(0);return n}function pe(t,e,n,i){return t=t||new Array(3),t[0]=e,t[1]=n,t[2]=i,t}function At(t,e,n){return pe(n,t[0]+e[0],t[1]+e[1],t[2]+e[2])}function io(t,e){return pe(e,Rt(t[0]),Rt(t[1]),Rt(t[2]))}function nt(t,e){return pe(e,t[0],t[1],t[2])}function lr(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]}function bl(t,e,n){return xt(t[0]-e[0])<=n&&xt(t[1]-e[1])<=n&&xt(t[2]-e[2])<=n}function hi(t){return pe(t,0,0,-1)}function Ye(t,e,n){return n=n||new Array(3),n[0]=t[1]*e[2]-t[2]*e[1],n[1]=t[2]*e[0]-t[0]*e[2],n[2]=t[0]*e[1]-t[1]*e[0],n}function ur(t,e,n){return pe(n,t[0]/e[0],t[1]/e[1],t[2]/e[2])}function ro(t){return pe(t,0,0,0)}function so(t,e){e=e||new Array(t.length*3);for(let n=0,i=0,r=t.length;n<r;++n,i+=3){const s=t[n];e[i]=s[0],e[i+1]=s[1],e[i+2]=s[2]}return e}function ao(t,e){return pe(e,_t(t[0]),_t(t[1]),_t(t[2]))}function Fi(t,e){return pe(e,1/t[0],1/t[1],1/t[2])}function it(t,e,n){return pe(n,t[0]*e,t[1]*e,t[2]*e)}function St(t,e,n){return pe(n,t[0]-e[0],t[1]-e[1],t[2]-e[2])}function oo(t,e,n){return pe(n,t[0]*e[0],t[1]*e[1],t[2]*e[2])}function co(t,e,n,i){return At(it(St(e,t),n),t,i)}function hs(t){return lo(t[0],t[1],t[2])}function lo(t,e,n){return Ra(t*t+e*e+n*n)}function ds(t,e,n){return pe(n,bt(t[0],e[0]),bt(t[1],e[1]),bt(t[2],e[2]))}function fs(t,e,n){return pe(n,Et(t[0],e[0]),Et(t[1],e[1]),Et(t[2],e[2]))}function ct(t,e){e=e||new Array(3);const n=hs(t);return e[0]=t[0]/n,e[1]=t[1]/n,e[2]=t[2]/n,e}function hr(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function El(t,e){return t[0]*e[0]-t[1]*e[1]-t[2]*e[2]}function _l(t,e){return pe(e,t[2],t[1],t[0])}function Wn(t,...e){let n;if(e=e||[],Array.isArray(t)?n=t.slice(0,3):n=[t],n.length<3)for(let i=0,r=e.length;i<r&&n.length<3;++i){const s=e[i];Array.isArray(s)?n.push(...s.slice(0,3-n.length)):n.push(s)}for(;n.length<3;)n.push(0);return n}function Rl(t,e,n){return n=n||[0,0,0],ct(Ye(Ye(t,e),t),n)}function xl(t,e,n){return n=n||[0,0,0],ct(Ye(t,e),n)}function Al(t,e,n){return n=n||[0,0,0],ct(Ye(e,t),n)}function Sl(t,e,n){return n=n||[0,0,0],ct(Ye(t,Ye(t,e)),n)}function fe(t,e,n,i,r){return t=t||new Array(4),t[0]=e,t[1]=n,t[2]=i,t[3]=r,t}function ps(t,e,n){return fe(n,t[0]+e[0],t[1]+e[1],t[2]+e[2],t[3]+e[3])}function Ml(t,e,n){return fe(n,t[0]+e[0],t[1]+e[1],t[2]+e[2],t[3])}function uo(t,e){return fe(e,Rt(t[0]),Rt(t[1]),Rt(t[2]),Rt(t[3]))}function Mt(t,e){return fe(e,t[0],t[1],t[2],t[3])}function gs(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]}function Il(t,e,n){return xt(t[0]-e[0])<=n&&xt(t[1]-e[1])<=n&&xt(t[2]-e[2])<=n&&xt(t[3]-e[3])<=n}function ho(t){return fe(t,0,0,-1,0)}function fo(t,e,n){return fe(n,0,0,0,1)}function po(t,e,n){return fe(n,t[0]/e[0],t[1]/e[1],t[2]/e[2],t[3]/e[3])}function go(t){return fe(t,0,0,0,0)}function ms(t,e){e=e||new Array(4);for(let n=0,i=0,r=t.length;n<r;++n,i+=4){const s=t[n];e[i]=s[0],e[i+1]=s[1],e[i+2]=s[2],e[i+3]=s[3]}return e}function mo(t,e){return fe(e,_t(t[0]),_t(t[1]),_t(t[2]),_t(t[3]))}function vo(t,e){return fe(e,1/t[0],1/t[1],1/t[2],1/t[3])}function vs(t,e,n){return fe(n,t[0]*e,t[1]*e,t[2]*e,t[3]*e)}function ws(t,e,n){return fe(n,t[0]-e[0],t[1]-e[1],t[2]-e[2],t[3]-e[3])}function wo(t,e,n){return fe(n,t[0]*e[0],t[1]*e[1],t[2]*e[2],t[3]*e[3])}function Ts(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3]}function Cl(t,e){return t[0]*e[0]-t[1]*e[1]-t[2]*e[2]-t[3]*e[3]}function Ll(t,e){return fe(e,t[3],t[2],t[1],t[0])}function To(t,e,n,i){return ps(vs(ws(e,t),n),t,i)}function ys(t){return Tn(t[0],t[1],t[2],t[3])}function Tn(t,e,n,i){return Ra(t*t+e*e+n*n+i*i)}function yo(t,e,n){return fe(n,bt(t[0],e[0]),bt(t[1],e[1]),bt(t[2],e[2]),bt(t[3],e[3]))}function bo(t,e,n){return fe(n,Et(t[0],e[0]),Et(t[1],e[1]),Et(t[2],e[2]),Et(t[3],e[3]))}function Eo(t,e){const n=ys(t);return fe(e,t[0]/n,t[1]/n,t[2]/n,t[3]/n)}function dr(t,...e){let n;if(e=e||[],Array.isArray(t)?n=t.slice(0,4):n=[t],n.length<4)for(let i=0,r=e.length;i<r&&n.length<4;++i){const s=e[i];Array.isArray(s)?n.push(...s.slice(0,4-n.length)):n.push(s)}for(;n.length<4;)n.push(0);return n}function Ol(t,e){return e=e||[0,0,0,0],fe(e,((t&16711680)>>16)/255,((t&65280)>>8)/255,(t&255)/255,1)}function Nl(t,e){return e=e||[0,0,0,0],fe(e,((t&4278190080)>>24)/255,((t&16711680)>>16)/255,((t&65280)>>8)/255,(t&255)/255)}function _o(t,e,n,i){i=i||[0,0,0,0];const r=[0,0,0,0];let s,a,o,c,u;return a=t[1]*e[1]+t[2]*e[2]+t[3]*e[3]+t[0]*e[0],a<0?(a=-a,r[0]=-e[0],r[1]=-e[1],r[2]=-e[2],r[3]=-e[3]):(r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3]),1-a>1e-7?(s=lp(a),o=xa(s),c=xa((1-n)*s)/o,u=xa(n*s)/o):(c=1-n,u=n),i[1]=c*t[1]+u*r[1],i[2]=c*t[2]+u*r[2],i[3]=c*t[3]+u*r[3],i[0]=c*t[0]+u*r[0],i}const Ro={add:rs,ceil:Sa,copy:Ia,compare:Ma,cross:La,divide:Oa,dot:za,empty:Na,flatten:Pa,floor:Da,forward:Ca,inverse:Fa,length:Wa,linear:Va,max:Ba,min:Ua,multiply:Ga,normalize:ka,scale:ss,subtract:as,vec:$a},xo={add:wn,ceil:ja,copy:os,compare:cs,cross:Qa,divide:cr,dot:Di,empty:Xa,flatten:Ya,floor:qa,forward:Ha,inverse:ls,length:Vn,linear:to,max:Ka,min:Za,multiply:Ja,normalize:eo,scale:Re,subtract:ye,vec:us},Ao={add:At,ceil:io,copy:nt,compare:lr,cross:Ye,divide:ur,dot:hr,empty:ro,flatten:so,floor:ao,forward:hi,inverse:Fi,length:hs,linear:co,max:ds,min:fs,multiply:oo,normalize:ct,scale:it,subtract:St,vec:Wn},So={add:ps,ceil:uo,copy:Mt,compare:gs,cross:fo,divide:po,dot:Ts,empty:go,flatten:ms,floor:mo,forward:ho,inverse:vo,length:ys,linear:To,max:yo,min:bo,multiply:wo,normalize:Eo,scale:vs,subtract:ws,vec:dr,slerpQuat:_o};function B(t){let e;return t.length===1?(e=Ro,e):t.length===2?(e=xo,e):t.length===3?(e=Ao,e):(e=So,e)}function Pl(t){return`[${t[0]}]`}function Dl(t){return`[${t[0]}, ${t[1]}]`}function Fl(t){return`[${t[0]}, ${t[1]}, ${t[2]}]`}function Bl(t){return`[${t[0]}, ${t[1]}, ${t[2]}, ${t[3]}]`}const up=Object.freeze(Object.defineProperty({__proto__:null,V3R:$e,V4R:hl,VecMath:B,add1:rs,add2:wn,add3:At,add4:ps,add4by3:Ml,apply1:Fe,apply2:de,apply3:pe,apply4:fe,ceil1:Sa,ceil2:ja,ceil3:io,ceil4:uo,color4FromHex3:Ol,color4FromHex4:Nl,compare1:Ma,compare2:cs,compare3:lr,compare4:gs,copy1:Ia,copy2:os,copy3:nt,copy4:Mt,cross1:La,cross2:Qa,cross3:Ye,cross4:fo,divide1:Oa,divide2:cr,divide3:ur,divide4:po,dot1:za,dot2:Di,dot3:hr,dot4:Ts,down3:Sl,empty1:Na,empty2:Xa,empty3:ro,empty4:go,flatten1:Pa,flatten2:Ya,flatten3:so,flatten4:ms,floor1:Da,floor2:qa,floor3:ao,floor4:mo,forward1:Ca,forward2:Ha,forward3:hi,forward4:ho,fuzzyCompare1:pl,fuzzyCompare2:vl,fuzzyCompare3:bl,fuzzyCompare4:Il,inverse1:Fa,inverse2:ls,inverse3:Fi,inverse4:vo,isVec1:dl,isVec2:Aa,isVec3:fl,isVec4:U,left3:Al,length1:Wa,length1Components:ml,length2:Vn,length2Components:no,length3:hs,length3Components:lo,length4:ys,length4Components:Tn,linear1:Va,linear2:to,linear3:co,linear4:To,max1:Ba,max2:Ka,max3:ds,max4:yo,min1:Ua,min2:Za,min3:fs,min4:bo,multiply1:Ga,multiply2:Ja,multiply3:oo,multiply4:wo,normalize1:ka,normalize2:eo,normalize3:ct,normalize4:Eo,reverse2:yl,reverse3:_l,reverse4:Ll,right3:xl,scale1:ss,scale2:Re,scale3:it,scale4:vs,slerpQuat:_o,subtract1:as,subtract2:ye,subtract3:St,subtract4:ws,toString1:Pl,toString2:Dl,toString3:Fl,toString4:Bl,tod1:gl,tod2:wl,tod3:El,tod4:Cl,tod_flip2:Tl,up3:Rl,vec1:$a,vec1Methods:Ro,vec2:us,vec2Methods:xo,vec3:Wn,vec3Methods:Ao,vec4:dr,vec4Methods:So},Symbol.toStringTag,{value:"Module"})),{min:bs,max:Es}=Math;class te{constructor(e){this.x=0,this.y=0,this.width=0,this.height=0,this.x=e.x||e.left||0,this.y=e.y||e.top||0,this.height=e.height||(e.bottom||0)-this.y||0,this.width=e.width||(e.right||0)-this.x||0}get area(){return this.width*this.height}get bottom(){return this.y+this.height}get left(){return this.x}get mid(){return[this.x+this.width/2,this.y+this.height/2]}get right(){return this.x+this.width}get top(){return this.y}static emptyBounds(){return new te({height:0,width:0,x:0,y:0})}containsPoint(e){return!(e[0]<this.x||e[1]<this.y||e[0]>this.right||e[1]>this.bottom)}encapsulate(e){return e instanceof te?(e.x<this.x&&(this.width+=Math.abs(e.x-this.x),this.x=e.x),e.y<this.y&&(this.height+=Math.abs(e.y-this.y),this.y=e.y),this.right<e.right&&(this.width+=e.right-this.right),this.bottom<e.bottom&&(this.height+=e.bottom-this.bottom),!0):(e[0]<this.x&&(this.width+=this.x-e[0],this.x=e[0]),e[0]>this.right&&(this.width+=e[0]-this.x),e[1]<this.y&&(this.height+=this.y-e[1],this.y=e[1]),e[1]>this.bottom&&(this.height+=e[1]-this.y),!0)}encapsulateAll(e){if(e.length<=0)return;let n=Number.MAX_SAFE_INTEGER,i=Number.MIN_SAFE_INTEGER,r=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER;if(e[0]instanceof te){const a=e;for(let o=0,c=a.length;o<c;++o){const u=a[o];n=bs(n,u.left),i=Es(i,u.right),r=bs(r,u.top),s=Es(s,u.bottom)}}else{const a=e;for(let o=0,c=a.length;o<c;++o){const[u,l]=a[o];n=bs(n,u),i=Es(i,u),r=bs(r,l),s=Es(s,l)}}this.x=Math.min(this.x,n),this.y=Math.min(this.y,r),this.width=Math.max(this.width,i-n),this.height=Math.max(this.height,s-r)}fits(e){return this.width===e.width&&this.height===e.height?1:this.width>=e.width&&this.height>=e.height?2:0}hitBounds(e){return!(this.right<e.x||this.x>e.right||this.bottom<e.y||this.y>e.bottom)}isInside(e){return this.x>=e.x&&this.right<=e.right&&this.y>=e.y&&this.bottom<=e.bottom}get location(){return[this.x,this.y]}toString(){return`{x: ${this.x} y:${this.y} w:${this.width} h:${this.height}}`}}function It(t,e,n){const i=`${t}`,r=parseFloat(i);return isNaN(r)?0:i.indexOf("%")>-1?r/100*e:r*n}const Bi=new WeakSet;function Mo(t,e,n){(e.width===0||e.height===0)&&(Bi.has(t)||(console.warn("An AbsolutePosition evaluated to invalid dimensions.","Please ensure that the object provided and the reference has valid dimensions","to produce dimensions with width and height that are non-zero.","item:",t,"reference:",e.toString()),Bi.add(t)));const i=te.emptyBounds();let r,s;if(t.width)i.width=It(t.width,e.width,n),t.left!==void 0?i.x=It(t.left,e.width,n):t.right!==void 0&&(i.x=e.width-It(t.right,e.width,n)-i.width);else{const a=It(t.left||0,e.width,n);r=e.width-It(t.right||0,e.width,n)-a,r<0&&(Bi.has(t)||(console.warn("An AbsolutePosition evaluated to invalid dimensions.","Please ensure that the object provided and the reference has valid dimensions","to produce dimensions with width and height that are greater than zero.","item:",t,"reference:",e.toString()),Bi.add(t))),i.x=a,i.width=r}if(t.height)i.height=It(t.height,e.height,n),t.top!==void 0?i.y=It(t.top,e.height,n):t.bottom!==void 0&&(i.y=e.height-It(t.bottom,e.height,n)-i.height);else{const a=It(t.top||0,e.height,n);s=e.height-It(t.bottom||0,e.height,n)-a,(s===void 0||s<0)&&(Bi.has(t)||(console.warn("An AbsolutePosition evaluated to invalid dimensions.","Please ensure that the object provided and the reference has valid dimensions","to produce dimensions with width and height that are greater than zero.","item:",t,"reference:",e.toString()),Bi.add(t))),i.y=a,i.height=s}return(i.width===0||i.height===0||isNaN(i.x+i.y+i.width+i.height))&&(i.x=0,i.y=0,i.width=e.width,i.height=e.height),i}class yn{constructor(e,n,i=!1,r=!1){this._isInstanced=!1,this._fullUpdate=!1,this.normalize=!1,this._needsUpdate=!1,this._updateRange={count:-1,offset:-1},this.data=e,this.size=n,this._isDynamic=i,this._isInstanced=r}get isDynamic(){return this._isDynamic}get isInstanced(){return this._isInstanced}get fullUpdate(){return this._fullUpdate}get needsUpdate(){return this._needsUpdate}get updateRange(){return this._updateRange}set updateRange(e){this._updateRange=e,this._needsUpdate=!0}destroy(){this.gl&&this.gl.proxy.disposeAttribute(this)}resolve(){this._needsUpdate=!1,this._fullUpdate=!1}setDynamic(e){this._isDynamic=e,this._needsUpdate=!0,this._fullUpdate=!0}}class $n{constructor(){this._attributes={},this.maxInstancedCount=0,this.isInstanced=!1}get attributes(){return new Map(Object.entries(this._attributes))}addAttribute(e,n){this._attributes[e]=n,this.isInstanced=!1;let i;Object.values(this._attributes).forEach(r=>{const s=r.isInstanced?1:0;i===void 0&&(i=s),(i^s)===1&&(this.isInstanced=!0)})}removeAttribute(e){delete this._attributes[e]}destroy(){this.attributes.forEach(e=>e.destroy()),this.gl&&this.gl.proxy.disposeGeometry(this)}}d.GLSettings=void 0,(t=>{(e=>{(n=>{n[n.RGBA4=0]="RGBA4",n[n.RGB565=1]="RGB565",n[n.RGB5_A1=2]="RGB5_A1",n[n.R8=3]="R8",n[n.R8UI=4]="R8UI",n[n.R8I=5]="R8I",n[n.R16UI=6]="R16UI",n[n.R16I=7]="R16I",n[n.R32UI=8]="R32UI",n[n.R32I=9]="R32I",n[n.RG8=10]="RG8",n[n.RG8UI=11]="RG8UI",n[n.RG8I=12]="RG8I",n[n.RG16UI=13]="RG16UI",n[n.RG16I=14]="RG16I",n[n.RG32UI=15]="RG32UI",n[n.RG32I=16]="RG32I",n[n.RGB8=17]="RGB8",n[n.RGBA8=18]="RGBA8",n[n.SRGB8_ALPHA8=19]="SRGB8_ALPHA8",n[n.RGB10_A2=20]="RGB10_A2",n[n.RGBA8UI=21]="RGBA8UI",n[n.RGBA8I=22]="RGBA8I",n[n.RGB10_A2UI=23]="RGB10_A2UI",n[n.RGBA16UI=24]="RGBA16UI",n[n.RGBA16I=25]="RGBA16I",n[n.RGBA32I=26]="RGBA32I",n[n.RGBA32UI=27]="RGBA32UI"})(e.ColorBufferFormat||(e.ColorBufferFormat={})),(n=>{n[n.DEPTH_COMPONENT16=0]="DEPTH_COMPONENT16",n[n.DEPTH_STENCIL=1]="DEPTH_STENCIL",n[n.DEPTH_COMPONENT24=2]="DEPTH_COMPONENT24",n[n.DEPTH_COMPONENT32F=3]="DEPTH_COMPONENT32F",n[n.DEPTH24_STENCIL8=4]="DEPTH24_STENCIL8",n[n.DEPTH32F_STENCIL8=5]="DEPTH32F_STENCIL8"})(e.DepthBufferFormat||(e.DepthBufferFormat={})),(n=>{n[n.STENCIL_INDEX8=0]="STENCIL_INDEX8"})(e.StencilBufferFormat||(e.StencilBufferFormat={}))})(t.RenderTarget||(t.RenderTarget={})),(e=>{(n=>{n[n.NoBlending=-1]="NoBlending",n[n.NormalBlending=1]="NormalBlending",n[n.AdditiveBlending=2]="AdditiveBlending",n[n.SubtractiveBlending=3]="SubtractiveBlending",n[n.MultiplyBlending=4]="MultiplyBlending"})(e.Blending||(e.Blending={})),(n=>{n[n.Zero=-1]="Zero",n[n.One=1]="One",n[n.SrcColor=2]="SrcColor",n[n.OneMinusSrcColor=3]="OneMinusSrcColor",n[n.SrcAlpha=4]="SrcAlpha",n[n.OneMinusSrcAlpha=5]="OneMinusSrcAlpha",n[n.DstAlpha=6]="DstAlpha",n[n.OneMinusDstAlpha=7]="OneMinusDstAlpha",n[n.DstColor=8]="DstColor",n[n.OneMinusDstColor=9]="OneMinusDstColor"})(e.BlendingDstFactor||(e.BlendingDstFactor={})),(n=>{n[n.Zero=-1]="Zero",n[n.One=1]="One",n[n.SrcColor=2]="SrcColor",n[n.OneMinusSrcColor=3]="OneMinusSrcColor",n[n.SrcAlpha=4]="SrcAlpha",n[n.OneMinusSrcAlpha=5]="OneMinusSrcAlpha",n[n.DstAlpha=6]="DstAlpha",n[n.OneMinusDstAlpha=7]="OneMinusDstAlpha",n[n.DstColor=8]="DstColor",n[n.OneMinusDstColor=9]="OneMinusDstColor",n[n.SrcAlphaSaturate=10]="SrcAlphaSaturate"})(e.BlendingSrcFactor||(e.BlendingSrcFactor={})),(n=>{n[n.Add=-1]="Add",n[n.Subtract=1]="Subtract",n[n.ReverseSubtract=2]="ReverseSubtract"})(e.BlendingEquations||(e.BlendingEquations={})),(n=>{n[n.NEVER=-1]="NEVER",n[n.LESS=1]="LESS",n[n.EQUAL=2]="EQUAL",n[n.LESS_OR_EQUAL=3]="LESS_OR_EQUAL",n[n.GREATER=4]="GREATER",n[n.NOTEQUAL=5]="NOTEQUAL",n[n.GREATER_OR_EQUAL=6]="GREATER_OR_EQUAL",n[n.ALWAYS=7]="ALWAYS"})(e.DepthFunctions||(e.DepthFunctions={})),(n=>{n[n.NONE=-1]="NONE",n[n.CW=1]="CW",n[n.CCW=2]="CCW",n[n.BOTH=3]="BOTH"})(e.CullSide||(e.CullSide={}))})(t.Material||(t.Material={})),(e=>{(n=>{n[n.LINE_LOOP=0]="LINE_LOOP",n[n.LINE_STRIP=1]="LINE_STRIP",n[n.LINES=2]="LINES",n[n.POINTS=3]="POINTS",n[n.TRIANGLE_FAN=4]="TRIANGLE_FAN",n[n.TRIANGLE_STRIP=5]="TRIANGLE_STRIP",n[n.TRIANGLES=6]="TRIANGLES"})(e.DrawMode||(e.DrawMode={}))})(t.Model||(t.Model={})),(e=>{(n=>{n[n.TEXTURE_2D=0]="TEXTURE_2D",n[n.CUBE_MAP=1]="CUBE_MAP"})(e.TextureBindingTarget||(e.TextureBindingTarget={})),(n=>{n[n.REPEAT=-1]="REPEAT",n[n.CLAMP_TO_EDGE=1]="CLAMP_TO_EDGE",n[n.MIRRORED_REPEAT=2]="MIRRORED_REPEAT"})(e.Wrapping||(e.Wrapping={})),(n=>{n[n.Nearest=-1]="Nearest",n[n.NearestMipMapNearest=1]="NearestMipMapNearest",n[n.NearestMipMapLinear=2]="NearestMipMapLinear",n[n.Linear=3]="Linear",n[n.LinearMipMapNearest=4]="LinearMipMapNearest",n[n.LinearMipMapLinear=5]="LinearMipMapLinear"})(e.TextureMinFilter||(e.TextureMinFilter={})),(n=>{n[n.Nearest=-1]="Nearest",n[n.Linear=1]="Linear"})(e.TextureMagFilter||(e.TextureMagFilter={})),(n=>{n[n.UnsignedByte=-1]="UnsignedByte",n[n.UnsignedShort_5_6_5=1]="UnsignedShort_5_6_5",n[n.UnsignedShort_4_4_4_4=2]="UnsignedShort_4_4_4_4",n[n.UnsignedShort_5_5_5_1=3]="UnsignedShort_5_5_5_1",n[n.UnsignedShort=4]="UnsignedShort",n[n.UnsignedInt=5]="UnsignedInt",n[n.UnsignedInt_24_8=6]="UnsignedInt_24_8",n[n.Byte=7]="Byte",n[n.Short=8]="Short",n[n.Int=9]="Int",n[n.Float=10]="Float",n[n.HalfFloat=11]="HalfFloat",n[n.UnsignedInt_2_10_10_10_REV=12]="UnsignedInt_2_10_10_10_REV",n[n.UnsignedInt_10F_11F_11F_REV=13]="UnsignedInt_10F_11F_11F_REV",n[n.UnsignedInt_5_9_9_9_REV=14]="UnsignedInt_5_9_9_9_REV",n[n.Float32UnsignedInt_24_8_REV=15]="Float32UnsignedInt_24_8_REV"})(e.SourcePixelFormat||(e.SourcePixelFormat={})),(n=>{n[n.Alpha=-1]="Alpha",n[n.DepthComponent=1]="DepthComponent",n[n.DepthStencil=2]="DepthStencil",n[n.Luminance=3]="Luminance",n[n.LuminanceAlpha=4]="LuminanceAlpha",n[n.RGB=5]="RGB",n[n.RGBA=6]="RGBA",n[n.RGBE=7]="RGBE",n[n.R8=8]="R8",n[n.R16F=9]="R16F",n[n.R32F=10]="R32F",n[n.R8UI=11]="R8UI",n[n.RG8=12]="RG8",n[n.RG16F=13]="RG16F",n[n.RG32F=14]="RG32F",n[n.RG8UI=15]="RG8UI",n[n.RG16UI=16]="RG16UI",n[n.RG32UI=17]="RG32UI",n[n.RGB8=18]="RGB8",n[n.SRGB8=19]="SRGB8",n[n.RGB565=20]="RGB565",n[n.R11F_G11F_B10F=21]="R11F_G11F_B10F",n[n.RGB9_E5=22]="RGB9_E5",n[n.RGB16F=23]="RGB16F",n[n.RGB32F=24]="RGB32F",n[n.RGB8UI=25]="RGB8UI",n[n.RGBA8=26]="RGBA8",n[n.SRGB8_ALPHA8=27]="SRGB8_ALPHA8",n[n.RGB5_A1=28]="RGB5_A1",n[n.RGB10_A2=29]="RGB10_A2",n[n.RGBA4=30]="RGBA4",n[n.RGBA16F=31]="RGBA16F",n[n.RGBA32F=32]="RGBA32F",n[n.RGBA8UI=33]="RGBA8UI",n[n.DEPTH_COMPONENT16=34]="DEPTH_COMPONENT16",n[n.DEPTH_COMPONENT24=35]="DEPTH_COMPONENT24",n[n.DEPTH_COMPONENT32F=36]="DEPTH_COMPONENT32F",n[n.RGBA32UI=37]="RGBA32UI",n[n.RGB32UI=38]="RGB32UI",n[n.RGBA16UI=39]="RGBA16UI",n[n.RGB16UI=40]="RGB16UI",n[n.RGBA32I=41]="RGBA32I",n[n.RGB32I=42]="RGB32I",n[n.RGBA16I=43]="RGBA16I",n[n.RGB16I=44]="RGB16I",n[n.RGBA8I=45]="RGBA8I",n[n.RGB8I=46]="RGB8I",n[n.RED_INTEGER=47]="RED_INTEGER",n[n.RG_INTEGER=48]="RG_INTEGER",n[n.RGB_INTEGER=49]="RGB_INTEGER",n[n.RGBA_INTEGER=50]="RGBA_INTEGER"})(e.TexelDataType||(e.TexelDataType={})),(n=>{n[n.ONE=1]="ONE",n[n.TWO=2]="TWO",n[n.FOUR=4]="FOUR",n[n.EIGHT=8]="EIGHT"})(e.PackAlignment||(e.PackAlignment={})),(n=>{n[n.ONE=1]="ONE",n[n.TWO=2]="TWO",n[n.FOUR=4]="FOUR",n[n.EIGHT=8]="EIGHT"})(e.UnpackAlignment||(e.UnpackAlignment={}))})(t.Texture||(t.Texture={})),(e=>{(n=>{n[n.ALPHA=0]="ALPHA",n[n.RGB=1]="RGB",n[n.RGBA=2]="RGBA"})(e.ReadFilter||(e.ReadFilter={})),(n=>{n[n.UNSIGNED_BYTE=0]="UNSIGNED_BYTE",n[n.UNSIGNED_SHORT_5_6_5=1]="UNSIGNED_SHORT_5_6_5",n[n.UNSIGNED_SHORT_4_4_4_4=2]="UNSIGNED_SHORT_4_4_4_4",n[n.UNSIGNED_SHORT_5_5_5_1=3]="UNSIGNED_SHORT_5_5_5_1",n[n.FLOAT=4]="FLOAT"})(e.ReadTargetArrayFormat||(e.ReadTargetArrayFormat={}))})(t.Renderer||(t.Renderer={}))})(d.GLSettings||(d.GLSettings={}));function hp(t,e){const n={attributeCount:0,attributes:[],uniformCount:0,uniforms:[]},i=t.getProgramParameter(e,t.ACTIVE_UNIFORMS),r=t.getProgramParameter(e,t.ACTIVE_ATTRIBUTES),s={35664:"FLOAT_VEC2",35665:"FLOAT_VEC3",35666:"FLOAT_VEC4",35667:"INT_VEC2",35668:"INT_VEC3",35669:"INT_VEC4",35670:"BOOL",35671:"BOOL_VEC2",35672:"BOOL_VEC3",35673:"BOOL_VEC4",35674:"FLOAT_MAT2",35675:"FLOAT_MAT3",35676:"FLOAT_MAT4",35678:"SAMPLER_2D",35680:"SAMPLER_CUBE",5120:"BYTE",5121:"UNSIGNED_BYTE",5122:"SHORT",5123:"UNSIGNED_SHORT",5124:"INT",5125:"UNSIGNED_INT",5126:"FLOAT"},a={35664:1,35665:1,35666:1,35667:1,35668:1,35669:1,35670:1,35671:1,35672:1,35673:1,35674:1,35675:3,35676:4,35678:1,35680:1,5120:1,5121:1,5122:1,5123:1,5124:1,5125:1,5126:1};for(let o=0;o<i;++o){const c=t.getActiveUniform(e,o);c.typeName=s[c.type],n.uniforms.push(c),n.uniformCount+=c.size,c.size=c.size*a[c.type]}for(let o=0;o<r;o++){const c=t.getActiveAttrib(e,o);c.typeName=s[c.type],n.attributes.push(c),n.attributeCount+=c.size}return n}const Ul=class{static print(){return Object.assign({},Ul)}};let L=Ul;L.VAO=!1,L.DEPTH_TEXTURE=!1,L.MAX_VERTEX_UNIFORMS=0,L.MAX_FRAGMENT_UNIFORMS=0,L.MAX_VERTEX_ATTRIBUTES=0,L.WEBGL_SUPPORTED=!1,L.MAX_TEXTURE_SIZE=0,L.HARDWARE_INSTANCING=!1,L.MRT_EXTENSION=!1,L.MRT=!1,L.MAX_COLOR_ATTACHMENTS=0,L.SHADERS_3_0=!1,L.WEBGL_VERSION="none",L.FLOAT_TEXTURE_READ={half:!1,full:!1,halfLinearFilter:!1,fullLinearFilter:!1},L.FLOAT_TEXTURE_WRITE={half:!1,full:!1};function dp(){function t(){try{const i=document.createElement("canvas");let r;return r=i.getContext("webgl2"),r?(L.WEBGL_VERSION="webgl2",r):(r=i.getContext("webgl"),r?(L.WEBGL_VERSION="webgl",r):(r=i.getContext("experimental-webgl"),r?(L.WEBGL_VERSION="experimental-webgl",r):null))}catch{return null}}function e(i){L.FLOAT_TEXTURE_READ.fullLinearFilter=!!i.getExtension("OES_texture_float_linear"),L.FLOAT_TEXTURE_READ.halfLinearFilter=!!i.getExtension("OES_texture_half_float_linear");const r=i.createTexture();if(i.bindTexture(i.TEXTURE_2D,r),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),i.getError()!==i.NO_ERROR)throw new Error("WebGLStat could not create a texture");const s=i.getExtension("OES_texture_float")||i.getExtension("EXT_color_buffer_float");if(i.getExtension("WEBGL_color_buffer_float"),s){i.texImage2D(i.TEXTURE_2D,0,i instanceof WebGL2RenderingContext?i.RGBA32F:i.RGBA,2,2,0,i.RGBA,i.FLOAT,null),i.getError()===i.NO_ERROR&&(L.FLOAT_TEXTURE_READ.full=!0);const l=i.createFramebuffer();i.bindFramebuffer(i.FRAMEBUFFER,l),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,r,0),i.bindTexture(i.TEXTURE_2D,null),i.checkFramebufferStatus(i.FRAMEBUFFER)===i.FRAMEBUFFER_COMPLETE&&(L.FLOAT_TEXTURE_WRITE.full=!0),i.deleteFramebuffer(l),i.deleteTexture(r)}const a=i.createTexture();if(i.bindTexture(i.TEXTURE_2D,a),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),i.getError()!==i.NO_ERROR)throw new Error("WebGLStat could not create a texture");const o=i.getExtension("OES_texture_half_float")||i.getExtension("EXT_color_buffer_float");if(o){i.texImage2D(i.TEXTURE_2D,0,i instanceof WebGL2RenderingContext?i.RGBA16F:i.RGBA,2,2,0,i.RGBA,i instanceof WebGL2RenderingContext?i.HALF_FLOAT:o.HALF_FLOAT_OES,null),i.getError()===i.NO_ERROR&&(L.FLOAT_TEXTURE_READ.full=!0);const l=i.createFramebuffer();i.bindFramebuffer(i.FRAMEBUFFER,l),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,a,0),i.bindTexture(i.TEXTURE_2D,null),i.checkFramebufferStatus(i.FRAMEBUFFER)===i.FRAMEBUFFER_COMPLETE&&(L.FLOAT_TEXTURE_WRITE.full=!0),i.deleteFramebuffer(l),i.deleteTexture(a)}}const n=t();if(n)if(L.WEBGL_SUPPORTED=!0,L.MAX_VERTEX_UNIFORMS=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),L.MAX_FRAGMENT_UNIFORMS=n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),L.MAX_VERTEX_ATTRIBUTES=n.getParameter(n.MAX_VERTEX_ATTRIBS),L.MAX_TEXTURE_SIZE=n.getParameter(n.MAX_TEXTURE_SIZE),e(n),n instanceof WebGL2RenderingContext)L.VAO=!0,L.MRT=!0,L.HARDWARE_INSTANCING=!0,L.SHADERS_3_0=!0,L.HARDWARE_INSTANCING=!0,L.DEPTH_TEXTURE=!0,L.MAX_COLOR_ATTACHMENTS=n.getParameter(n.MAX_COLOR_ATTACHMENTS);else{L.VAO=!!n.getExtension("OES_vertex_array_object"),L.HARDWARE_INSTANCING=!!n.getExtension("ANGLE_instanced_arrays");const i=n.getExtension("WEBGL_draw_buffers");L.MRT_EXTENSION=!!i,L.MRT=!!i,L.DEPTH_TEXTURE=!!n.getExtension("WEBGL_depth_texture"),i&&(L.MAX_COLOR_ATTACHMENTS=n.getParameter(i.MAX_COLOR_ATTACHMENTS_WEBGL))}window.WebGLStat=L}dp();function _s(t,e){switch(e){case d.GLSettings.Model.DrawMode.LINES:return t.LINES;case d.GLSettings.Model.DrawMode.LINE_LOOP:return t.LINE_LOOP;case d.GLSettings.Model.DrawMode.LINE_STRIP:return t.LINE_STRIP;case d.GLSettings.Model.DrawMode.POINTS:return t.POINTS;case d.GLSettings.Model.DrawMode.TRIANGLES:return t.TRIANGLES;case d.GLSettings.Model.DrawMode.TRIANGLE_FAN:return t.TRIANGLE_FAN;case d.GLSettings.Model.DrawMode.TRIANGLE_STRIP:return t.TRIANGLE_STRIP;default:return t.TRIANGLES}}function di(t,e){switch(e){case d.GLSettings.Texture.TexelDataType.Alpha:return t.ALPHA;case d.GLSettings.Texture.TexelDataType.DepthComponent:return t.DEPTH_COMPONENT;case d.GLSettings.Texture.TexelDataType.DepthStencil:return t.DEPTH_STENCIL;case d.GLSettings.Texture.TexelDataType.Luminance:return t.LUMINANCE;case d.GLSettings.Texture.TexelDataType.LuminanceAlpha:return t.LUMINANCE_ALPHA;case d.GLSettings.Texture.TexelDataType.RGB:return t.RGB;case d.GLSettings.Texture.TexelDataType.RGBA:return t.RGBA;default:if(t instanceof WebGL2RenderingContext)switch(e){case d.GLSettings.Texture.TexelDataType.R8:return t.R8;case d.GLSettings.Texture.TexelDataType.R16F:return t.R16F;case d.GLSettings.Texture.TexelDataType.R32F:return t.R32F;case d.GLSettings.Texture.TexelDataType.R8UI:return t.R8UI;case d.GLSettings.Texture.TexelDataType.RG8:return t.RG8;case d.GLSettings.Texture.TexelDataType.RG16F:return t.RG16F;case d.GLSettings.Texture.TexelDataType.RG32F:return t.RG32F;case d.GLSettings.Texture.TexelDataType.RG8UI:return t.RG8UI;case d.GLSettings.Texture.TexelDataType.RG16UI:return t.RG16UI;case d.GLSettings.Texture.TexelDataType.RG32UI:return t.RG32UI;case d.GLSettings.Texture.TexelDataType.RGB8:return t.RGB8;case d.GLSettings.Texture.TexelDataType.SRGB8:return t.SRGB8;case d.GLSettings.Texture.TexelDataType.RGB565:return t.RGB565;case d.GLSettings.Texture.TexelDataType.R11F_G11F_B10F:return t.R11F_G11F_B10F;case d.GLSettings.Texture.TexelDataType.RGB9_E5:return t.RGB9_E5;case d.GLSettings.Texture.TexelDataType.RGB16F:return t.RGB16F;case d.GLSettings.Texture.TexelDataType.RGB32F:return t.RGB32F;case d.GLSettings.Texture.TexelDataType.RGB8UI:return t.RGB8UI;case d.GLSettings.Texture.TexelDataType.RGBA8:return t.RGBA8;case d.GLSettings.Texture.TexelDataType.SRGB8_ALPHA8:return t.SRGB8_ALPHA8;case d.GLSettings.Texture.TexelDataType.RGB5_A1:return t.RGB5_A1;case d.GLSettings.Texture.TexelDataType.RGB10_A2:return t.RGB10_A2;case d.GLSettings.Texture.TexelDataType.RGBA4:return t.RGBA4;case d.GLSettings.Texture.TexelDataType.RGBA16F:return t.RGBA16F;case d.GLSettings.Texture.TexelDataType.RGBA32F:return L.FLOAT_TEXTURE_READ.full&&L.FLOAT_TEXTURE_WRITE.full?t.RGBA32F:t.RGBA16F;case d.GLSettings.Texture.TexelDataType.RGBA8UI:return t.RGBA8UI;case d.GLSettings.Texture.TexelDataType.DEPTH_COMPONENT16:return t.DEPTH_COMPONENT16;case d.GLSettings.Texture.TexelDataType.DEPTH_COMPONENT24:return t.DEPTH_COMPONENT24;case d.GLSettings.Texture.TexelDataType.DEPTH_COMPONENT32F:return t.DEPTH_COMPONENT32F;case d.GLSettings.Texture.TexelDataType.RGBA32UI:return t.RGBA32UI;case d.GLSettings.Texture.TexelDataType.RGB32UI:return t.RGB32UI;case d.GLSettings.Texture.TexelDataType.RGBA16UI:return t.RGBA16UI;case d.GLSettings.Texture.TexelDataType.RGB16UI:return t.RGB16UI;case d.GLSettings.Texture.TexelDataType.RGBA32I:return t.RGBA32I;case d.GLSettings.Texture.TexelDataType.RGB32I:return t.RGB32I;case d.GLSettings.Texture.TexelDataType.RGBA16I:return t.RGBA16I;case d.GLSettings.Texture.TexelDataType.RGB16I:return t.RGB16I;case d.GLSettings.Texture.TexelDataType.RGBA8I:return t.RGBA8I;case d.GLSettings.Texture.TexelDataType.RGB8I:return t.RGB8I;default:return console.warn("An unsupported texel format was provided that is not supported in WebGL 1 or 2"),t.RGBA}return console.warn("An Unsupported texel format was provided. Some formats are only available in WebGL 2",e),t.RGBA}}function fr(t,e){switch(e){case d.GLSettings.Texture.SourcePixelFormat.Byte:return t.BYTE;case d.GLSettings.Texture.SourcePixelFormat.Float:return t.FLOAT;case d.GLSettings.Texture.SourcePixelFormat.HalfFloat:return console.warn("Unsupported HALF_FLOAT"),t.BYTE;case d.GLSettings.Texture.SourcePixelFormat.Int:return t.INT;case d.GLSettings.Texture.SourcePixelFormat.Short:return t.SHORT;case d.GLSettings.Texture.SourcePixelFormat.UnsignedByte:return t.UNSIGNED_BYTE;case d.GLSettings.Texture.SourcePixelFormat.UnsignedInt:return t.UNSIGNED_INT;case d.GLSettings.Texture.SourcePixelFormat.UnsignedShort:return t.UNSIGNED_SHORT;case d.GLSettings.Texture.SourcePixelFormat.UnsignedShort_4_4_4_4:return t.UNSIGNED_SHORT_4_4_4_4;case d.GLSettings.Texture.SourcePixelFormat.UnsignedShort_5_5_5_1:return t.UNSIGNED_SHORT_5_5_5_1;case d.GLSettings.Texture.SourcePixelFormat.UnsignedShort_5_6_5:return t.UNSIGNED_SHORT_5_6_5;default:return console.warn("An Unsupported input image format was provided",e),t.BYTE}}function fi(t,e){switch(e){case d.GLSettings.Texture.TextureMagFilter.Linear:return t.LINEAR;case d.GLSettings.Texture.TextureMagFilter.Nearest:return t.NEAREST}}function bn(t,e,n){switch(e){case d.GLSettings.Texture.TextureMinFilter.Linear:return t.LINEAR;case d.GLSettings.Texture.TextureMinFilter.Nearest:return t.NEAREST;case d.GLSettings.Texture.TextureMinFilter.LinearMipMapLinear:return n?t.LINEAR_MIPMAP_LINEAR:t.LINEAR;case d.GLSettings.Texture.TextureMinFilter.LinearMipMapNearest:return n?t.LINEAR_MIPMAP_NEAREST:t.LINEAR;case d.GLSettings.Texture.TextureMinFilter.NearestMipMapLinear:return n?t.NEAREST_MIPMAP_LINEAR:t.NEAREST;case d.GLSettings.Texture.TextureMinFilter.NearestMipMapNearest:return n?t.NEAREST_MIPMAP_NEAREST:t.NEAREST;default:return t.LINEAR}}function Gl(t,e){switch(e){case d.GLSettings.RenderTarget.ColorBufferFormat.RGB565:return t.RGB565;case d.GLSettings.RenderTarget.ColorBufferFormat.RGB5_A1:return t.RGB5_A1;case d.GLSettings.RenderTarget.ColorBufferFormat.RGBA4:return t.RGBA4;default:if(t instanceof WebGL2RenderingContext)switch(e){case d.GLSettings.RenderTarget.ColorBufferFormat.R8:return t.R8;case d.GLSettings.RenderTarget.ColorBufferFormat.R8UI:return t.R8UI;case d.GLSettings.RenderTarget.ColorBufferFormat.R8I:return t.R8I;case d.GLSettings.RenderTarget.ColorBufferFormat.R16UI:return t.R16UI;case d.GLSettings.RenderTarget.ColorBufferFormat.R16I:return t.R16I;case d.GLSettings.RenderTarget.ColorBufferFormat.R32UI:return t.R32UI;case d.GLSettings.RenderTarget.ColorBufferFormat.R32I:return t.R32I;case d.GLSettings.RenderTarget.ColorBufferFormat.RG8:return t.RG8;case d.GLSettings.RenderTarget.ColorBufferFormat.RG8UI:return t.RG8UI;case d.GLSettings.RenderTarget.ColorBufferFormat.RG8I:return t.RG8I;case d.GLSettings.RenderTarget.ColorBufferFormat.RG16UI:return t.RG16UI;case d.GLSettings.RenderTarget.ColorBufferFormat.RG16I:return t.RG16I;case d.GLSettings.RenderTarget.ColorBufferFormat.RG32UI:return t.RG32UI;case d.GLSettings.RenderTarget.ColorBufferFormat.RG32I:return t.RG32I;case d.GLSettings.RenderTarget.ColorBufferFormat.RGB8:return t.RGB8;case d.GLSettings.RenderTarget.ColorBufferFormat.RGBA8:return t.RGBA8;case d.GLSettings.RenderTarget.ColorBufferFormat.SRGB8_ALPHA8:return t.SRGB8_ALPHA8;case d.GLSettings.RenderTarget.ColorBufferFormat.RGB10_A2:return t.RGB10_A2;case d.GLSettings.RenderTarget.ColorBufferFormat.RGBA8UI:return t.RGBA8UI;case d.GLSettings.RenderTarget.ColorBufferFormat.RGBA8I:return t.RGBA8I;case d.GLSettings.RenderTarget.ColorBufferFormat.RGB10_A2UI:return t.RGB10_A2UI;case d.GLSettings.RenderTarget.ColorBufferFormat.RGBA16UI:return t.RGBA16UI;case d.GLSettings.RenderTarget.ColorBufferFormat.RGBA16I:return t.RGBA16I;case d.GLSettings.RenderTarget.ColorBufferFormat.RGBA32I:return t.RGBA32I;case d.GLSettings.RenderTarget.ColorBufferFormat.RGBA32UI:return t.RGBA32UI}return t.RGBA4}}function kl(t,e){switch(e){case d.GLSettings.RenderTarget.DepthBufferFormat.DEPTH_COMPONENT16:return t.DEPTH_COMPONENT16;case d.GLSettings.RenderTarget.DepthBufferFormat.DEPTH_STENCIL:return t.DEPTH_STENCIL;default:if(t instanceof WebGL2RenderingContext)switch(e){case d.GLSettings.RenderTarget.DepthBufferFormat.DEPTH_COMPONENT24:return t.DEPTH_COMPONENT24;case d.GLSettings.RenderTarget.DepthBufferFormat.DEPTH_COMPONENT32F:return t.DEPTH_COMPONENT32F;case d.GLSettings.RenderTarget.DepthBufferFormat.DEPTH24_STENCIL8:return t.DEPTH24_STENCIL8;case d.GLSettings.RenderTarget.DepthBufferFormat.DEPTH32F_STENCIL8:return t.DEPTH32F_STENCIL8}return t.DEPTH_COMPONENT16}}function zl(t,e){switch(e){case d.GLSettings.RenderTarget.StencilBufferFormat.STENCIL_INDEX8:return t.STENCIL_INDEX8;default:return t.STENCIL_INDEX8}}function Io(t,e){switch(e){case d.GLSettings.Texture.Wrapping.CLAMP_TO_EDGE:return t.CLAMP_TO_EDGE;case d.GLSettings.Texture.Wrapping.MIRRORED_REPEAT:return t.MIRRORED_REPEAT;case d.GLSettings.Texture.Wrapping.REPEAT:return t.REPEAT}}function pr(t,e,n,i,r){if(i)return t.COLOR_ATTACHMENT0;const s=e.drawBuffers;if(r){if(s instanceof WebGL2RenderingContext)switch(n){case-2:return t.BACK;case-1:return t.NONE;case 0:return s.DRAW_BUFFER0;case 1:return s.DRAW_BUFFER1;case 2:return s.DRAW_BUFFER2;case 3:return s.DRAW_BUFFER3;case 4:return s.DRAW_BUFFER4;case 5:return s.DRAW_BUFFER5;case 6:return s.DRAW_BUFFER6;case 7:return s.DRAW_BUFFER7;case 8:return s.DRAW_BUFFER8;case 9:return s.DRAW_BUFFER9;case 10:return s.DRAW_BUFFER10;case 11:return s.DRAW_BUFFER11;case 12:return s.DRAW_BUFFER12;case 13:return s.DRAW_BUFFER13;case 14:return s.DRAW_BUFFER14;case 15:return s.DRAW_BUFFER15;default:console.warn("Attachments are only available for -2 - 15")}else if(s)switch(n){case-2:return t.BACK;case-1:return t.NONE;case 0:return s.DRAW_BUFFER0_WEBGL;case 1:return s.DRAW_BUFFER1_WEBGL;case 2:return s.DRAW_BUFFER2_WEBGL;case 3:return s.DRAW_BUFFER3_WEBGL;case 4:return s.DRAW_BUFFER4_WEBGL;case 5:return s.DRAW_BUFFER5_WEBGL;case 6:return s.DRAW_BUFFER6_WEBGL;case 7:return s.DRAW_BUFFER7_WEBGL;case 8:return s.DRAW_BUFFER8_WEBGL;case 9:return s.DRAW_BUFFER9_WEBGL;case 10:return s.DRAW_BUFFER10_WEBGL;case 11:return s.DRAW_BUFFER11_WEBGL;case 12:return s.DRAW_BUFFER12_WEBGL;case 13:return s.DRAW_BUFFER13_WEBGL;case 14:return s.DRAW_BUFFER14_WEBGL;case 15:return s.DRAW_BUFFER15_WEBGL;default:console.warn("Attachments are only available for 0 - 15")}}else if(s instanceof WebGL2RenderingContext)switch(n){case-2:return t.BACK;case-1:return t.NONE;case 0:return s.COLOR_ATTACHMENT0;case 1:return s.COLOR_ATTACHMENT1;case 2:return s.COLOR_ATTACHMENT2;case 3:return s.COLOR_ATTACHMENT3;case 4:return s.COLOR_ATTACHMENT4;case 5:return s.COLOR_ATTACHMENT5;case 6:return s.COLOR_ATTACHMENT6;case 7:return s.COLOR_ATTACHMENT7;case 8:return s.COLOR_ATTACHMENT8;case 9:return s.COLOR_ATTACHMENT9;case 10:return s.COLOR_ATTACHMENT10;case 11:return s.COLOR_ATTACHMENT11;case 12:return s.COLOR_ATTACHMENT12;case 13:return s.COLOR_ATTACHMENT13;case 14:return s.COLOR_ATTACHMENT14;case 15:return s.COLOR_ATTACHMENT15;default:console.warn("Attachments are only available for -2 - 15")}else if(s)switch(n){case-2:return t.BACK;case-1:return t.NONE;case 0:return s.COLOR_ATTACHMENT0_WEBGL;case 1:return s.COLOR_ATTACHMENT1_WEBGL;case 2:return s.COLOR_ATTACHMENT2_WEBGL;case 3:return s.COLOR_ATTACHMENT3_WEBGL;case 4:return s.COLOR_ATTACHMENT4_WEBGL;case 5:return s.COLOR_ATTACHMENT5_WEBGL;case 6:return s.COLOR_ATTACHMENT6_WEBGL;case 7:return s.COLOR_ATTACHMENT7_WEBGL;case 8:return s.COLOR_ATTACHMENT8_WEBGL;case 9:return s.COLOR_ATTACHMENT9_WEBGL;case 10:return s.COLOR_ATTACHMENT10_WEBGL;case 11:return s.COLOR_ATTACHMENT11_WEBGL;case 12:return s.COLOR_ATTACHMENT12_WEBGL;case 13:return s.COLOR_ATTACHMENT13_WEBGL;case 14:return s.COLOR_ATTACHMENT14_WEBGL;case 15:return s.COLOR_ATTACHMENT15_WEBGL;default:console.warn("Attachments are only available for 0 - 15")}return t.COLOR_ATTACHMENT0}function Vl(t,e){return t.TEXTURE0+e}function Co(t,e){return e-t.TEXTURE0}function fp(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var Lo={exports:{}},Oo={exports:{}},gr=1e3,mr=gr*60,vr=mr*60,wr=vr*24,pp=wr*365.25,gp=function(t,e){e=e||{};var n=typeof t;if(n==="string"&&t.length>0)return mp(t);if(n==="number"&&isNaN(t)===!1)return e.long?wp(t):vp(t);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(t))};function mp(t){if(t=String(t),!(t.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(t);if(e){var n=parseFloat(e[1]),i=(e[2]||"ms").toLowerCase();switch(i){case"years":case"year":case"yrs":case"yr":case"y":return n*pp;case"days":case"day":case"d":return n*wr;case"hours":case"hour":case"hrs":case"hr":case"h":return n*vr;case"minutes":case"minute":case"mins":case"min":case"m":return n*mr;case"seconds":case"second":case"secs":case"sec":case"s":return n*gr;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return n;default:return}}}}function vp(t){return t>=wr?Math.round(t/wr)+"d":t>=vr?Math.round(t/vr)+"h":t>=mr?Math.round(t/mr)+"m":t>=gr?Math.round(t/gr)+"s":t+"ms"}function wp(t){return Rs(t,wr,"day")||Rs(t,vr,"hour")||Rs(t,mr,"minute")||Rs(t,gr,"second")||t+" ms"}function Rs(t,e,n){if(!(t<e))return t<e*1.5?Math.floor(t/e)+" "+n:Math.ceil(t/e)+" "+n+"s"}(function(t,e){e=t.exports=i.debug=i.default=i,e.coerce=c,e.disable=a,e.enable=s,e.enabled=o,e.humanize=gp,e.instances=[],e.names=[],e.skips=[],e.formatters={};function n(u){var l=0,h;for(h in u)l=(l<<5)-l+u.charCodeAt(h),l|=0;return e.colors[Math.abs(l)%e.colors.length]}function i(u){var l;function h(){if(h.enabled){var f=h,p=+new Date,g=p-(l||p);f.diff=g,f.prev=l,f.curr=p,l=p;for(var m=new Array(arguments.length),T=0;T<m.length;T++)m[T]=arguments[T];m[0]=e.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");var w=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,function(b,A){if(b==="%%")return b;w++;var R=e.formatters[A];if(typeof R=="function"){var N=m[w];b=R.call(f,N),m.splice(w,1),w--}return b}),e.formatArgs.call(f,m);var y=h.log||e.log||console.log.bind(console);y.apply(f,m)}}return h.namespace=u,h.enabled=e.enabled(u),h.useColors=e.useColors(),h.color=n(u),h.destroy=r,typeof e.init=="function"&&e.init(h),e.instances.push(h),h}function r(){var u=e.instances.indexOf(this);return u!==-1?(e.instances.splice(u,1),!0):!1}function s(u){e.save(u),e.names=[],e.skips=[];var l,h=(typeof u=="string"?u:"").split(/[\s,]+/),f=h.length;for(l=0;l<f;l++)h[l]&&(u=h[l].replace(/\*/g,".*?"),u[0]==="-"?e.skips.push(new RegExp("^"+u.substr(1)+"$")):e.names.push(new RegExp("^"+u+"$")));for(l=0;l<e.instances.length;l++){var p=e.instances[l];p.enabled=e.enabled(p.namespace)}}function a(){e.enable("")}function o(u){if(u[u.length-1]==="*")return!0;var l,h;for(l=0,h=e.skips.length;l<h;l++)if(e.skips[l].test(u))return!1;for(l=0,h=e.names.length;l<h;l++)if(e.names[l].test(u))return!0;return!1}function c(u){return u instanceof Error?u.stack||u.message:u}})(Oo,Oo.exports);var Tp=Oo.exports;(function(t,e){e=t.exports=Tp,e.log=r,e.formatArgs=i,e.save=s,e.load=a,e.useColors=n,e.storage=typeof chrome<"u"&&typeof chrome.storage<"u"?chrome.storage.local:o(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function n(){return typeof window<"u"&&window.process&&window.process.type==="renderer"?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}e.formatters.j=function(c){try{return JSON.stringify(c)}catch(u){return"[UnexpectedJSONParseError]: "+u.message}};function i(c){var u=this.useColors;if(c[0]=(u?"%c":"")+this.namespace+(u?" %c":" ")+c[0]+(u?"%c ":" ")+"+"+e.humanize(this.diff),!!u){var l="color: "+this.color;c.splice(1,0,l,"color: inherit");var h=0,f=0;c[0].replace(/%[a-zA-Z%]/g,function(p){p!=="%%"&&(h++,p==="%c"&&(f=h))}),c.splice(f,0,l)}}function r(){return typeof console=="object"&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function s(c){try{c==null?e.storage.removeItem("debug"):e.storage.debug=c}catch{}}function a(){var c;try{c=e.storage.debug}catch{}return!c&&typeof process<"u"&&"env"in process&&(c=process.env.DEBUG),c}e.enable(a());function o(){try{return window.localStorage}catch{}}})(Lo,Lo.exports);var yp=Lo.exports;const Ie=fp(yp);class Wl{constructor(e){this._destroyed=!1,this._internalFormat=d.GLSettings.RenderTarget.ColorBufferFormat.RGBA4,this.needsSettingsUpdate=!1,this._size=[0,0],this.size=e.size||this.size,this.internalFormat=e.internalFormat??this.internalFormat}get destroyed(){return this._destroyed}get internalFormat(){return this._internalFormat}set internalFormat(e){this.needsSettingsUpdate=!0,this._internalFormat=e}get size(){return this._size}set size(e){this.needsSettingsUpdate=!0,this._size=e}destroy(){this.gl&&this.gl.proxy.disposeColorBuffer(this),this._destroyed=!0}}var No=(t=>(t[t.INVALID=0]="INVALID",t[t.ONE=1]="ONE",t[t.TWO=2]="TWO",t[t.THREE=3]="THREE",t[t.FOUR=4]="FOUR",t))(No||{}),C=(t=>(t[t.ONE=1]="ONE",t[t.TWO=2]="TWO",t[t.THREE=3]="THREE",t[t.FOUR=4]="FOUR",t[t.MAT4X4=16]="MAT4X4",t[t.ATLAS=99]="ATLAS",t))(C||{});const $l={[1]:1,[2]:2,[3]:3,[4]:4,[16]:16,[99]:4};var E=(t=>(t[t.ONE=1]="ONE",t[t.TWO=2]="TWO",t[t.THREE=3]="THREE",t[t.FOUR=4]="FOUR",t[t.MATRIX3=9]="MATRIX3",t[t.MATRIX4=16]="MATRIX4",t[t.FLOAT_ARRAY=97]="FLOAT_ARRAY",t[t.VEC4_ARRAY=98]="VEC4_ARRAY",t[t.TEXTURE=99]="TEXTURE",t))(E||{}),Be=(t=>(t[t.ONE=1]="ONE",t[t.TWO=2]="TWO",t[t.THREE=3]="THREE",t[t.FOUR=4]="FOUR",t))(Be||{}),lt=(t=>(t[t.SCREEN_256TH=-256]="SCREEN_256TH",t[t.SCREEN_128TH=-128]="SCREEN_128TH",t[t.SCREEN_64TH=-64]="SCREEN_64TH",t[t.SCREEN_32ND=-32]="SCREEN_32ND",t[t.SCREEN_16TH=-16]="SCREEN_16TH",t[t.SCREEN_8TH=-8]="SCREEN_8TH",t[t.SCREEN_QUARTER=-4]="SCREEN_QUARTER",t[t.SCREEN_HALF=-2]="SCREEN_HALF",t[t.SCREEN=-1]="SCREEN",t[t._2=2]="_2",t[t._4=4]="_4",t[t._8=8]="_8",t[t._16=16]="_16",t[t._32=32]="_32",t[t._64=64]="_64",t[t._128=128]="_128",t[t._256=256]="_256",t[t._512=512]="_512",t[t._1024=1024]="_1024",t[t._2048=2048]="_2048",t[t._4096=4096]="_4096",t))(lt||{}),le=(t=>(t[t.ATLAS=0]="ATLAS",t[t.FONT=1]="FONT",t[t.TEXTURE=2]="TEXTURE",t[t.COLOR_BUFFER=3]="COLOR_BUFFER",t))(le||{}),se=(t=>(t[t.zyx=0]="zyx",t[t.zyz=1]="zyz",t[t.zxy=2]="zxy",t[t.zxz=3]="zxz",t[t.yxz=4]="yxz",t[t.yxy=5]="yxy",t[t.yzx=6]="yzx",t[t.yzy=7]="yzy",t[t.xyz=8]="xyz",t[t.xyx=9]="xyx",t[t.xzy=10]="xzy",t[t.xzx=11]="xzx",t))(se||{});function bp(t){return t.size!==void 0&&t.size<=4}function Ep(t){return!!(t&&t.resource)}var x=(t=>(t[t.VERTEX=1]="VERTEX",t[t.FRAGMENT=2]="FRAGMENT",t[t.ALL=3]="ALL",t))(x||{});function xs(){}const _p=/\s/g,Po=/\s/,pi=Po.test.bind(Po),jl=/\n\r|\n|\r/g,Do=/\n\r|\n|\r/,Rp=Do.test.bind(Do);function xp(t){return t}var X=(t=>(t[t.NONE=0]="NONE",t[t.SINGLE=1]="SINGLE",t))(X||{}),Ce=(t=>(t[t.CHANGE=0]="CHANGE",t[t.INSERT=1]="INSERT",t[t.REMOVE=2]="REMOVE",t))(Ce||{}),Fo=(t=>(t[t.NO_WEBGL_CONTEXT=0]="NO_WEBGL_CONTEXT",t))(Fo||{}),xe=(t=>(t[t.UNIFORM=1]="UNIFORM",t[t.INSTANCE_ATTRIBUTE=2]="INSTANCE_ATTRIBUTE",t[t.INSTANCE_ATTRIBUTE_PACKING=3]="INSTANCE_ATTRIBUTE_PACKING",t))(xe||{}),As=(t=>(t[t.LINEAR=0]="LINEAR",t))(As||{});function En(t){return t!==void 0&&t.charCodeAt!==void 0}function Hl(t){return t!==void 0&&t.toExponential!==void 0}function Ap(t){return t!==void 0&&t.call!==void 0&&t.apply!==void 0}function jn(t){return t===!0||t===!1}var $=(t=>(t[t.NONE=0]="NONE",t[t.BLANK=1]="BLANK",t[t.COLOR=2]="COLOR",t[t.DEPTH=3]="DEPTH",t[t.NORMAL=4]="NORMAL",t[t.PICKING=5]="PICKING",t[t.POSITION=6]="POSITION",t[t.POSITION_X=7]="POSITION_X",t[t.POSITION_Y=8]="POSITION_Y",t[t.POSITION_Z=9]="POSITION_Z",t[t.LIGHTS=10]="LIGHTS",t[t.LIGHTS2=11]="LIGHTS2",t[t.LIGHTS3=12]="LIGHTS3",t[t.ALPHA=13]="ALPHA",t[t.BETA=14]="BETA",t[t.GAMMA=15]="GAMMA",t[t.DELTA=16]="DELTA",t[t.ACCUMULATION1=17]="ACCUMULATION1",t[t.ACCUMULATION2=18]="ACCUMULATION2",t[t.ACCUMULATION3=19]="ACCUMULATION3",t[t.ACCUMULATION4=20]="ACCUMULATION4",t[t.COEFFICIENT1=21]="COEFFICIENT1",t[t.COEFFICIENT2=22]="COEFFICIENT2",t[t.COEFFICIENT3=23]="COEFFICIENT3",t[t.COEFFICIENT4=24]="COEFFICIENT4",t[t.ANGLE1=25]="ANGLE1",t[t.ANGLE2=26]="ANGLE2",t[t.ANGLE3=27]="ANGLE3",t[t.ANGLE4=28]="ANGLE4",t[t.COLOR2=29]="COLOR2",t[t.COLOR3=30]="COLOR3",t[t.COLOR4=31]="COLOR4",t[t.GLOW=32]="GLOW",t[t.BLUR=33]="BLUR",t))($||{});let Sp=1;function G(){return++Sp}let Mp=0;function Ip(){return++Mp%16777215}class ie{constructor(e){this._uid=G(),this._destroyed=!1,this._flipY=!1,this._format=d.GLSettings.Texture.TexelDataType.RGBA,this._generateMipmaps=!1,this._internalFormat=d.GLSettings.Texture.TexelDataType.RGBA,this._magFilter=d.GLSettings.Texture.TextureMagFilter.Linear,this._minFilter=d.GLSettings.Texture.TextureMinFilter.LinearMipMapLinear,this.needsDataUpload=!1,this.needsPartialDataUpload=!1,this.needsSettingsUpdate=!1,this._packAlignment=d.GLSettings.Texture.PackAlignment.FOUR,this._premultiplyAlpha=!1,this._type=d.GLSettings.Texture.SourcePixelFormat.UnsignedByte,this._unpackAlignment=d.GLSettings.Texture.UnpackAlignment.FOUR,this._updateRegions=[],this._wrapHorizontal=d.GLSettings.Texture.Wrapping.CLAMP_TO_EDGE,this._wrapVertical=d.GLSettings.Texture.Wrapping.CLAMP_TO_EDGE,this.anisotropy=e.anisotropy||this.anisotropy,this.data=e.data||this.data,this.flipY=e.flipY||this.flipY,this.format=e.format||this.format,this.internalFormat=e.internalFormat||this.format,this.generateMipMaps=e.generateMipMaps||this.generateMipMaps,this.magFilter=e.magFilter||this.magFilter,this.minFilter=e.minFilter||this.minFilter,this.packAlignment=e.packAlignment||this.packAlignment,this.premultiplyAlpha=e.premultiplyAlpha||this.premultiplyAlpha,this.type=e.type||this.type,this.unpackAlignment=e.unpackAlignment||this.unpackAlignment,this.wrapHorizontal=e.wrapHorizontal||this.wrapHorizontal,this.wrapVertical=e.wrapVertical||this.wrapVertical}static get emptyTexture(){return Cp}get uid(){return this._uid}get destroyed(){return this._destroyed}get anisotropy(){return this._anisotropy}set anisotropy(e){this.needsSettingsUpdate=!0,this._anisotropy=e}get data(){return this._data}set data(e){this.needsDataUpload=!0,this._data=e}get flipY(){return this._flipY}set flipY(e){this.needsDataUpload=!0,this._flipY=e}get format(){return this._format}set format(e){this.needsDataUpload=!0,this._format=e}get generateMipMaps(){return this._generateMipmaps}set generateMipMaps(e){this.needsSettingsUpdate=!0,this._generateMipmaps=e}get internalFormat(){return this._internalFormat}set internalFormat(e){this.needsDataUpload=!0,this._internalFormat=e}get magFilter(){return this._magFilter}set magFilter(e){this.needsSettingsUpdate=!0,this._magFilter=e}get minFilter(){return this._minFilter}set minFilter(e){this.needsSettingsUpdate=!0,this._minFilter=e}get packAlignment(){return this._packAlignment}set packAlignment(e){this.needsSettingsUpdate=!0,this._packAlignment=e}get premultiplyAlpha(){return this._premultiplyAlpha}set premultiplyAlpha(e){this.needsSettingsUpdate=!0,this._premultiplyAlpha=e}get type(){return this._type}set type(e){this.needsDataUpload=!0,this._type=e}get unpackAlignment(){return this._unpackAlignment}set unpackAlignment(e){this.needsSettingsUpdate=!0,this._unpackAlignment=e}get updateRegions(){return this._updateRegions}get wrapHorizontal(){return this._wrapHorizontal}set wrapHorizontal(e){this.needsSettingsUpdate=!0,this._wrapHorizontal=e}get wrapVertical(){return this._wrapVertical}set wrapVertical(e){this.needsSettingsUpdate=!0,this._wrapVertical=e}get isHalfFloatTexture(){switch(this._internalFormat){case d.GLSettings.Texture.TexelDataType.R16F:case d.GLSettings.Texture.TexelDataType.RG16F:case d.GLSettings.Texture.TexelDataType.RGB16F:return!0}switch(this._type){case d.GLSettings.Texture.SourcePixelFormat.HalfFloat:return!0}return!1}get isFloatTexture(){switch(this._internalFormat){case d.GLSettings.Texture.TexelDataType.R11F_G11F_B10F:case d.GLSettings.Texture.TexelDataType.R16F:case d.GLSettings.Texture.TexelDataType.RG16F:case d.GLSettings.Texture.TexelDataType.R32F:case d.GLSettings.Texture.TexelDataType.RG32F:case d.GLSettings.Texture.TexelDataType.RGB16F:case d.GLSettings.Texture.TexelDataType.RGB32F:return!0}switch(this._type){case d.GLSettings.Texture.SourcePixelFormat.Float:case d.GLSettings.Texture.SourcePixelFormat.HalfFloat:return!0}return!1}destroy(){this.gl&&this.gl.proxy.disposeTexture(this),this._destroyed=!0,delete this._data}resolve(){this.needsDataUpload=!1,this.needsPartialDataUpload=!1,this.needsSettingsUpdate=!1,this._updateRegions=[]}update(e,n){this.needsPartialDataUpload=!0,this._updateRegions.push([e,n])}}const Cp=new ie({data:{width:2,height:2,buffer:new Uint8Array(16)}}),_n=Ie("performance");function Ql(t){return t&&t.buffer&&t.buffer.byteOffset!==void 0&&t.buffer.byteLength||t.buffer===null}function Ui(t){return(t&t-1)===0}function Ss(t){return!!(t.gl&&t.gl.textureId&&t.gl.textureUnit>-1)}class Tr{constructor(e,n,i){this.debugContext="",this.fragmentShaders=new Map,this.vertexShaders=new Map,this.programs=new Map,this.gl=e,this.state=n,this.extensions=i}static addExtensions(e){const n=e.getExtension("ANGLE_instanced_arrays"),i=e.getExtension("WEBGL_draw_buffers"),r=e.getExtension("OES_texture_float"),s=e.getExtension("OES_texture_float_linear"),a=e.getExtension("OES_texture_half_float"),o=e.getExtension("OES_texture_half_float_linear"),c=e.getExtension("EXT_texture_filter_anisotropic"),u=e.getExtension("EXT_color_buffer_float"),l=e.getExtension("OES_vertex_array_object"),h={maxAnistropicFilter:0};return!n&&!(e instanceof WebGL2RenderingContext)&&_n("This device does not have hardware instancing. All buffering strategies will be utilizing compatibility modes."),!i&&!(e instanceof WebGL2RenderingContext)&&_n("This device does not have hardware multi-render target capabilities. The system will have to fallback to multiple render passes to multiple FBOs to achieve the same result."),c?h.maxAnistropicFilter=e.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT):_n("This device does not have hardware anisotropic filtering for textures. This property will be ignored when setting texture settings."),!l&&!(e instanceof WebGL2RenderingContext)&&_n("This device does not support Vertex Array Objects. This could cause performance issues for high numbers of draw calls."),{instancing:(e instanceof WebGL2RenderingContext?e:n)||void 0,drawBuffers:(e instanceof WebGL2RenderingContext?e:i)||void 0,anisotropicFiltering:c?{ext:c,stat:h}:void 0,renderFloatTexture:u||void 0,floatTex:(e instanceof WebGL2RenderingContext?e:r)||void 0,floatTexFilterLinear:(e instanceof WebGL2RenderingContext?e:s)||void 0,halfFloatTex:(e instanceof WebGL2RenderingContext?e:a)||void 0,halfFloatTexFilterLinear:(e instanceof WebGL2RenderingContext?e:o)||void 0,vao:(e instanceof WebGL2RenderingContext?e:l)||void 0}}clear(e,n,i){let r=0;e&&(r=r|this.gl.COLOR_BUFFER_BIT),n&&(r=r|this.gl.DEPTH_BUFFER_BIT),i&&(r=r|this.gl.STENCIL_BUFFER_BIT),this.gl.clear(r)}compileAttribute(e){if(e.gl)return;const n=this.gl,i=n.createBuffer();if(!i){console.warn(this.debugContext,"Could bot create WebGLBuffer. Printing any existing gl errors:"),this.printError();return}return this.state.bindVBO(i),n.bufferData(n.ARRAY_BUFFER,e.data,e.isDynamic?n.DYNAMIC_DRAW:n.STATIC_DRAW),e.gl={bufferId:i,type:n.ARRAY_BUFFER,proxy:this},e.resolve(),!0}compileGeometry(e){if(e.gl)return;let n=!0;if(e.gl={proxy:this},this.extensions.vao){let i;this.extensions.vao instanceof WebGL2RenderingContext?i=this.extensions.vao.createVertexArray():i=this.extensions.vao.createVertexArrayOES(),i?(this.state.disableVertexAttributeArray(),this.state.bindVAO(i),e.attributes.forEach((r,s)=>{this.updateAttribute(r)&&this.useAttribute(s,r,e)}),e.gl.vao=i,this.state.bindVAO(null)):_n("WARNING: Could not make VAO for Geometry. This is fine, but this could cause a hit on performance.")}return e.attributes.forEach(i=>{n=!!(this.compileAttribute(i)&&n)}),n}compileMaterial(e){if(e.gl)return;let n=this.vertexShaders.get(e.vertexShader)||null;if(!n){if(n=this.gl.createShader(this.gl.VERTEX_SHADER),!n){console.warn(this.debugContext,"Could not create a Vertex WebGLShader. Printing GL Errors:"),this.printError();return}if(this.gl.shaderSource(n,e.vertexShader),this.gl.compileShader(n),this.gl.isContextLost()&&console.warn("Context was lost during compilation"),!this.gl.getShaderParameter(n,this.gl.COMPILE_STATUS)){console.error(this.debugContext,"VERTEX SHADER COMPILER ERROR",e.name),console.warn("Could not compile provided shader. Printing logs and errors:"),console.warn(this.lineFormatShader(e.vertexShader)),console.warn("LOGS:"),console.warn(this.gl.getShaderInfoLog(n)),this.printError(),this.gl.deleteShader(n);return}}let i=this.programs.get(n);i||(i=new Map,this.programs.set(n,i));const r={vsId:n,fsId:[],programId:[],proxy:this,programByTarget:new WeakMap,outputsByProgram:new WeakMap},s=new Set;if(!e.fragmentShader)return console.warn("A material appears to not have it's fragment shader configuration set."),!1;e.fragmentShader.forEach(o=>{var f,p;if(!i||!n)return;let c=this.fragmentShaders.get(o.source)||null;if(!c){if(c=this.gl.createShader(this.gl.FRAGMENT_SHADER),!c){console.warn(this.debugContext,"Could not create a Fragment WebGLShader. Printing GL Errors:"),this.printError();return}if(this.gl.shaderSource(c,o.source),this.gl.compileShader(c),this.gl.isContextLost()&&console.warn("Context was lost during compilation"),!this.gl.getShaderParameter(c,this.gl.COMPILE_STATUS)){console.error(this.debugContext,"FRAGMENT SHADER COMPILER ERROR:",e.name),console.warn("Could not compile provided shader. Printing logs and errors:"),console.warn(this.lineFormatShader(o.source)),console.warn("LOGS:"),console.warn(this.gl.getShaderInfoLog(c)),this.printError(),this.gl.deleteShader(c);return}}let u=i.get(c)||null;if(u)u.useCount++;else{const g=this.gl.createProgram();if(!g){console.warn(this.debugContext,"Could not create a WebGLProgram. Printing GL Errors:"),this.printError();return}if(u={useCount:1,program:g},this.gl.attachShader(g,n),this.gl.attachShader(g,c),this.gl.linkProgram(g),this.gl.validateProgram(g),!this.gl.getProgramParameter(g,this.gl.LINK_STATUS)||!this.gl.getProgramParameter(g,this.gl.VALIDATE_STATUS)){const m=this.gl.getProgramInfoLog(g);console.warn(this.debugContext,`Could not compile WebGL program. 

`,m),this.printError(),this.gl.deleteProgram(g);return}i.set(c,u)}(f=r.fsId)==null||f.push({id:c,outputTypes:o.outputTypes}),(p=r.programId)==null||p.push({id:u.program,outputTypes:o.outputTypes}),r.outputsByProgram.set(u.program,o.outputTypes),this.state.useProgram(u.program);const l=this.state.currentProgram;if(!l)return!1;const h=this.gl.getProgramParameter(l,this.gl.ACTIVE_UNIFORMS);for(let g=0;g<h;g++){const m=this.gl.getActiveUniform(l,g);m&&s.add(m.name.replace("[0]",""))}}),e.gl=r;const a=new Set;return Object.keys(e.uniforms).forEach(o=>{s.has(o)||a.add(o)}),a.forEach(o=>{delete e.uniforms[o]}),Object.keys(e.uniforms).length!==s.size?(console.warn(this.debugContext,"A program is requesting a set of uniforms:",Array.from(s.values()),"but our material only provides",Object.keys(e.uniforms),"thus the expected rendering will be considered invalid."),!1):!0}compileRenderTarget(e){if(e.isInvalid)return!1;if(e.gl)return!0;const n=this.gl,i=n.createFramebuffer();if(!i)return console.warn(this.debugContext,"Could not generate a frame buffer object. Printing GL errors:"),this.printError(),!1;this.state.bindFBO(i);const r={fboId:i,proxy:this,fboByMaterial:new WeakMap};if(Array.isArray(e.buffers.color)){if(!this.extensions.drawBuffers)return console.warn("Attempted to manage a render target with MRT but the hardware does not support MRT. Use multiple render targets instead."),!1;const u=[];let l=!0;r.colorBufferId=u;const h=e.buffers.color.length<=1;if(e.buffers.color.forEach((f,p)=>{if(l)if(f.buffer instanceof ie){const g=pr(n,this.extensions,p,h,!1);u.push({data:f.buffer,outputType:f.outputType,attachment:g}),Ss(f.buffer)?n.framebufferTexture2D(n.FRAMEBUFFER,g,n.TEXTURE_2D,f.buffer.gl.textureId,0):(console.warn(this.debugContext,"Attempted to compile render target whose target texture was not ready for use."),l=!1)}else{const g=this.compileColorBuffer(f.buffer,e.width,e.height);if(g){const m=pr(n,this.extensions,p,h,!1);u.push({data:g,outputType:f.outputType,attachment:m}),n.framebufferRenderbuffer(n.FRAMEBUFFER,m,n.RENDERBUFFER,g)}}}),!l)return!1}else if(e.buffers.color!==void 0){const u=e.buffers.color;if(u.buffer instanceof ie){const l=pr(n,this.extensions,0,!0,!1);if(r.colorBufferId={data:u.buffer,outputType:u.outputType,attachment:l},Ss(u.buffer))n.framebufferTexture2D(n.FRAMEBUFFER,l,n.TEXTURE_2D,u.buffer.gl.textureId,0);else return console.warn(this.debugContext,"Attempted to compile render target whose target texture was not ready for use."),!1}else{const l=this.compileColorBuffer(u.buffer,e.width,e.height);if(l){const h=pr(n,this.extensions,0,!0,!1);r.colorBufferId={data:l,outputType:u.outputType,attachment:h},n.framebufferRenderbuffer(n.FRAMEBUFFER,h,n.RENDERBUFFER,l)}}}if(e.buffers.depth!==void 0){const u=e.buffers.depth;if(u instanceof ie)r.depthBufferId=u,Ss(u)&&n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,u.gl.textureId,0);else if(u instanceof Wl){const l=this.compileDepthBuffer(u.internalFormat,e.width,e.height);l&&(r.depthBufferId=l,n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,l))}else{const l=this.compileDepthBuffer(u,e.width,e.height);l&&(r.depthBufferId=l,n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,l))}}if(e.buffers.stencil!==void 0){const u=e.buffers.stencil;if(u instanceof ie)r.stencilBufferId=u,Ss(u)&&n.framebufferTexture2D(n.FRAMEBUFFER,n.STENCIL_ATTACHMENT,n.TEXTURE_2D,u.gl.textureId,0);else{const l=this.compileStencilBuffer(u,e.width,e.height);l&&(r.stencilBufferId=l,n.framebufferRenderbuffer(n.FRAMEBUFFER,n.STENCIL_ATTACHMENT,n.RENDERBUFFER,l))}}e.gl=r;const s=n.checkFramebufferStatus(n.FRAMEBUFFER);let a=!1,o=!1,c="";switch(s){case n.FRAMEBUFFER_COMPLETE:e.setAsValid();break;case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:c="FRAMEBUFFER_INCOMPLETE_ATTACHMENT";break;case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:c="FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";break;case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:c="FRAMEBUFFER_INCOMPLETE_DIMENSIONS";break;case n.FRAMEBUFFER_UNSUPPORTED:c="FRAMEBUFFER_UNSUPPORTED";break;default:a=!0;break}if(n instanceof WebGL2RenderingContext)switch(s){case n.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:c="FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";break;case n.RENDERBUFFER_SAMPLES:c="RENDERBUFFER_SAMPLES";break;default:o=!0;break}return a&&o&&(console.warn(this.debugContext,"A framebuffer check failed to return a known result. This FBO for render target will be assumed failed"),console.warn("Result:",s,"Render Target:",e),c="UNKNOWN"),c?(console.warn(this.debugContext,"When creating a new FrameBuffer Object, the check on the framebuffer failed. Printing Errors:"),console.warn(c),this.printError(),console.warn("FAILED RENDER TARGET:",e),delete e.gl,e.isInvalid=!0,!1):!0}compileDepthBuffer(e,n,i){const r=this.gl,s=r.createRenderbuffer();if(!s){console.warn(this.debugContext,"Could not generate a WebGLRenderBuffer. Printing GL Errors:"),this.printError();return}return this.state.bindRBO(s),r.renderbufferStorage(r.RENDERBUFFER,kl(r,e),n,i),s}compileStencilBuffer(e,n,i){const r=this.gl,s=r.createRenderbuffer();if(!s){console.warn(this.debugContext,"Could not generate a WebGLRenderBuffer. Printing GL Errors:"),this.printError();return}return this.state.bindRBO(s),r.renderbufferStorage(r.RENDERBUFFER,zl(r,e),n,i),s}compileColorBuffer(e,n,i){const r=this.gl,s=r.createRenderbuffer();if(!s){console.warn(this.debugContext,"Could not generate a WebGLRenderBuffer. Printing GL Errors:"),this.printError();return}return this.state.bindRBO(s),r.renderbufferStorage(r.RENDERBUFFER,Gl(r,e.internalFormat),n,i),e.gl={bufferId:s,proxy:this},s}compileTexture(e){if(!e.gl||e.gl.textureId)return;if(e.gl.textureUnit<0){console.warn(this.debugContext,"A Texture object attempted to be compiled without an established Texture Unit.",e);return}this.state.setActiveTextureUnit(e.gl.textureUnit);const i=this.gl.createTexture();if(!i){console.warn(this.debugContext,"Could not generate a texture object on the GPU. Printing any gl errors:"),this.printError();return}return e.gl.textureId=i,e.needsDataUpload=!0,e.needsSettingsUpdate=!0,this.updateTextureData(e),this.updateTextureSettings(e),!0}draw(e){let n,i=[0,0];e.vertexDrawRange&&e.vertexDrawRange[0]>=0&&e.vertexDrawRange[1]>=0?i=[e.vertexDrawRange[0],e.vertexDrawRange[1]-e.vertexDrawRange[0]]:i=[0,e.vertexCount],e.drawInstances>=0&&e.geometry.isInstanced&&(n=this.extensions.instancing),!((L.MRT||L.MRT_EXTENSION)&&this.state.renderTarget&&!this.state.drawBuffers.find(r=>r!==this.gl.NONE))&&(n&&n instanceof WebGL2RenderingContext?n.drawArraysInstanced(_s(this.gl,e.drawMode),i[0],i[1],e.drawInstances):n?n.drawArraysInstancedANGLE(_s(this.gl,e.drawMode),i[0],i[1],e.drawInstances):this.gl.drawArrays(_s(this.gl,e.drawMode),i[0],i[1]),this.state.setDrawBuffers([],!0))}disposeAttribute(e){e.gl&&(this.gl.deleteBuffer(e.gl.bufferId),delete e.gl)}disposeColorBuffer(e){e.gl&&(e.gl.bufferId&&this.disposeRenderBuffer(e.gl.bufferId),delete e.gl)}disposeGeometry(e){e.gl&&this.extensions.vao&&e.gl.vao&&(this.extensions.vao instanceof WebGL2RenderingContext?this.extensions.vao.deleteVertexArray(e.gl.vao):this.extensions.vao.deleteVertexArrayOES(e.gl.vao))}disposeMaterial(e){if(e.gl){const{vsId:n,fsId:i,programId:r}=e.gl;let s=this.programs.get(n);s||(s=new Map,this.gl.deleteShader(n));for(let a=0,o=i.length;a<o;++a){const c=i[a];let u=s.get(c);u||(u={useCount:0,program:r}),u.useCount--,u.useCount<1&&(this.gl.deleteProgram(u.program),s.delete(c),s.size<=0&&this.gl.deleteShader(n));let l=!1;this.programs.forEach(h=>{h.has(c)&&(l=!0)}),l||this.gl.deleteShader(c)}}delete e.gl}disposeRenderBuffer(e){this.gl.deleteRenderbuffer(e)}disposeRenderTarget(e){e.gl&&(Array.isArray(e.gl.colorBufferId)?e.gl.colorBufferId.forEach(n=>{n.data instanceof ie&&!e.retainTextureTargets?this.disposeTexture(n.data):n.data instanceof WebGLRenderbuffer&&this.disposeRenderBuffer(n.data)}):e.gl.colorBufferId&&e.gl.colorBufferId.data instanceof ie&&!e.retainTextureTargets?this.disposeTexture(e.gl.colorBufferId.data):e.gl.colorBufferId instanceof WebGLRenderbuffer&&this.disposeRenderBuffer(e.gl.colorBufferId.data),e.gl.depthBufferId instanceof ie&&!e.retainTextureTargets?this.disposeTexture(e.gl.depthBufferId):e.gl.depthBufferId instanceof WebGLRenderbuffer&&this.disposeRenderBuffer(e.gl.depthBufferId),e.gl.stencilBufferId instanceof ie&&!e.retainTextureTargets?this.disposeTexture(e.gl.stencilBufferId):e.gl.stencilBufferId instanceof WebGLRenderbuffer&&this.disposeRenderBuffer(e.gl.stencilBufferId),this.gl.deleteFramebuffer(e.gl.fboId),delete e.gl)}disposeTexture(e){e.gl&&!e.destroyed&&(this.gl.deleteTexture(e.gl.textureId),this.state.freeTextureUnit(e)),delete e.gl}static getContext(e,n){const i=[L.WEBGL_VERSION,"webgl","webgl2","experimental-webgl"];let r=null,s={};for(let a=0;a<i.length;++a){const o=i[a],c=e.getContext(o,n);if(c&&(c instanceof WebGLRenderingContext||c instanceof WebGL2RenderingContext)){_n("Generated GL Context of version with attributes:",o,n),r=c,s=Tr.addExtensions(r);break}}return{context:r,extensions:s}}printError(){const e=this.gl.getError();switch(e){case this.gl.NO_ERROR:console.warn("GL Error: No Error");break;case this.gl.INVALID_ENUM:console.warn("GL Error: INVALID ENUM");break;case this.gl.INVALID_VALUE:console.warn("GL Error: INVALID_VALUE");break;case this.gl.INVALID_OPERATION:console.warn("GL Error: INVALID OPERATION");break;case this.gl.INVALID_FRAMEBUFFER_OPERATION:console.warn("GL Error: INVALID FRAMEBUFFER OPERATION");break;case this.gl.OUT_OF_MEMORY:console.warn("GL Error: OUT OF MEMORY");break;case this.gl.CONTEXT_LOST_WEBGL:console.warn("GL Error: CONTEXT LOST WEBGL");break;default:console.warn("GL Error: GL Context output an unrecognized error value:",e);break}}lineFormat(e){const n=e.split(`
`),i=String(n.length).length+1;return`
${n.map((r,s)=>`${Array(i-String(s+1).length).join(" ")}${s+1}: ${r}`).join(`
`)}`}lineFormatShader(e){return e?En(e)?this.lineFormat(e):e.forEach(n=>`
SHADER FOR OUTPUT TYPES: ${n.outputTypes} ${this.lineFormat(n.source)}`):"NO SHADER FOUND"}updateTexture(e){if(!e.gl||e.gl.textureUnit<0){console.warn(this.debugContext,"Can not update or compile a texture that does not have an established texture unit.",e);return}this.compileTexture(e),this.updateTextureData(e),this.updateTexturePartialData(e),this.updateTextureSettings(e),e.resolve()}updateTextureData(e){if(!e.needsDataUpload||!e.gl||!e.gl.textureId)return;if(e.gl.textureUnit<0){console.warn(this.debugContext,"A Texture object attempted to update it's data without an established Texture Unit.",e);return}const n=this.gl;if(this.state.setActiveTextureUnit(e.gl.textureUnit),this.state.bindTexture(e,d.GLSettings.Texture.TextureBindingTarget.TEXTURE_2D),e.needsSettingsUpdate=!0,this.updateTextureSettings(e),n instanceof WebGLRenderingContext||n instanceof WebGL2RenderingContext){if(Ql(e.data)){(!Ui(e.data.width)||!Ui(e.data.height))&&_n("Created a texture that is not using power of 2 dimensions.");const i=di(n,e.internalFormat),r=di(n,e.format);n instanceof WebGLRenderingContext&&i!==r&&console.warn("WebGL 1 requires format and data format to be identical"),n.texImage2D(n.TEXTURE_2D,0,i,e.data.width,e.data.height,0,r,fr(n,e.type),e.data.buffer)}else e.data&&((!Ui(e.data.width)||!Ui(e.data.height))&&_n("Created a texture that is not using power of 2 dimensions. %o",e),n.texImage2D(n.TEXTURE_2D,0,di(n,e.internalFormat),di(n,e.format),fr(n,e.type),e.data));e.generateMipMaps&&n.generateMipmap(n.TEXTURE_2D)}e.data&&(e.data={width:e.data.width,height:e.data.height,buffer:null}),e.needsDataUpload=!1}updateTexturePartialData(e){if(!e.needsPartialDataUpload||!e.gl||!e.gl.textureId)return;if(e.gl.textureUnit<0){console.warn(this.debugContext,"A Texture object attempted to update it's data without an established Texture Unit.",e);return}const n=this.gl;this.state.setActiveTextureUnit(e.gl.textureUnit),this.state.bindTexture(e,d.GLSettings.Texture.TextureBindingTarget.TEXTURE_2D),e.updateRegions.forEach(i=>{const r=i[0],s=i[1];(n instanceof WebGLRenderingContext||n instanceof WebGL2RenderingContext)&&(Ql(r)?n.texSubImage2D(n.TEXTURE_2D,0,s.x,s.y,r.width,r.height,di(n,e.format),fr(n,e.type),r.buffer):r&&n.texSubImage2D(n.TEXTURE_2D,0,s.x,s.y,di(n,e.format),fr(n,e.type),r),e.generateMipMaps&&n.generateMipmap(n.TEXTURE_2D))}),e.needsPartialDataUpload=!1}updateTextureSettings(e){if(!e.needsSettingsUpdate||!e.gl||!e.data||!e.gl.textureId)return;if(e.gl.textureUnit<0){console.warn(this.debugContext,"A Texture object attempted to update it's settings without an established Texture Unit.",e);return}const n=Ui(e.data.width)&&Ui(e.data.height),i=this.gl;this.state.setActiveTextureUnit(e.gl.textureUnit),this.state.bindTexture(e,d.GLSettings.Texture.TextureBindingTarget.TEXTURE_2D);let r,s;if(e.isHalfFloatTexture)if(L.FLOAT_TEXTURE_READ.halfLinearFilter)switch(r=fi(i,e.magFilter),e.minFilter){case d.GLSettings.Texture.TextureMinFilter.Nearest:case d.GLSettings.Texture.TextureMinFilter.NearestMipMapLinear:case d.GLSettings.Texture.TextureMinFilter.NearestMipMapNearest:s=bn(i,d.GLSettings.Texture.TextureMinFilter.Nearest,e.generateMipMaps);break;case d.GLSettings.Texture.TextureMinFilter.Linear:case d.GLSettings.Texture.TextureMinFilter.LinearMipMapLinear:case d.GLSettings.Texture.TextureMinFilter.LinearMipMapNearest:s=bn(i,d.GLSettings.Texture.TextureMinFilter.Nearest,e.generateMipMaps);break}else r=fi(i,d.GLSettings.Texture.TextureMagFilter.Nearest),s=bn(i,d.GLSettings.Texture.TextureMinFilter.Nearest,e.generateMipMaps);else if(e.isFloatTexture)if(L.FLOAT_TEXTURE_READ.fullLinearFilter)switch(r=fi(i,e.magFilter),e.minFilter){case d.GLSettings.Texture.TextureMinFilter.Nearest:case d.GLSettings.Texture.TextureMinFilter.NearestMipMapLinear:case d.GLSettings.Texture.TextureMinFilter.NearestMipMapNearest:s=bn(i,d.GLSettings.Texture.TextureMinFilter.Nearest,e.generateMipMaps);break;case d.GLSettings.Texture.TextureMinFilter.Linear:case d.GLSettings.Texture.TextureMinFilter.LinearMipMapLinear:case d.GLSettings.Texture.TextureMinFilter.LinearMipMapNearest:s=bn(i,d.GLSettings.Texture.TextureMinFilter.Nearest,e.generateMipMaps);break}else r=fi(i,d.GLSettings.Texture.TextureMagFilter.Nearest),s=bn(i,d.GLSettings.Texture.TextureMinFilter.Nearest,e.generateMipMaps);else!n&&i instanceof WebGLRenderingContext?(r=fi(i,d.GLSettings.Texture.TextureMagFilter.Linear),s=bn(i,d.GLSettings.Texture.TextureMinFilter.Linear,e.generateMipMaps)):(r=fi(i,e.magFilter),s=bn(i,e.minFilter,e.generateMipMaps));if(i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,r),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,s),e.isFloatTexture||(i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,Io(i,e.wrapHorizontal)),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,Io(i,e.wrapVertical))),e.isFloatTexture||(i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.premultiplyAlpha),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,e.flipY)),this.extensions.anisotropicFiltering){const{ext:a,stat:o}=this.extensions.anisotropicFiltering,c=Math.min(o.maxAnistropicFilter,Math.floor(e.anisotropy||0));!isNaN(c)&&!e.isFloatTexture&&i.texParameterf(i.TEXTURE_2D,a.TEXTURE_MAX_ANISOTROPY_EXT,c)}e.needsSettingsUpdate=!1}updateAttribute(e){if(!e.gl)return this.compileAttribute(e);if(!e.fullUpdate&&!e.needsUpdate)return!0;const n=this.gl;if(e.fullUpdate||e.updateRange.count<0||e.updateRange.offset<0)this.state.bindVBO(e.gl.bufferId),n.bufferData(n.ARRAY_BUFFER,e.data,e.isDynamic?n.DYNAMIC_DRAW:n.STATIC_DRAW);else if(e.updateRange.count>0){this.state.bindVBO(e.gl.bufferId);const i=e.updateRange.offset;n.bufferSubData(n.ARRAY_BUFFER,i*4,e.data.subarray(i,i+e.updateRange.count))}return e.resolve(),!0}useAttribute(e,n,i){if(!this.state.currentProgram||!n.gl)return!1;n.gl.locations=n.gl.locations||new Map;let r=n.gl.locations.get(this.state.currentProgram);if(r===void 0&&(r=this.gl.getAttribLocation(this.state.currentProgram,e),r===-1&&_n("WARN: An attribute is not being used with the current material: %o",e,n),n.gl.locations.set(this.state.currentProgram,r)),r!==-1){switch(this.state.bindVBO(n.gl.bufferId),n.size){case 1:case 2:case 3:case 4:this.state.willUseVertexAttributeArray(r),this.gl.vertexAttribPointer(r,n.size,this.gl.FLOAT,n.normalize,0,0),i.isInstanced&&n.isInstanced&&this.extensions.instancing?this.state.setVertexAttributeArrayDivisor(r,1):this.state.setVertexAttributeArrayDivisor(r,0);break;default:{const s=Math.ceil(n.size/4);for(let a=0;a<s;++a)this.state.willUseVertexAttributeArray(r+a),this.gl.vertexAttribPointer(r+a,4,this.gl.FLOAT,n.normalize,s*4*4,a*16),i.isInstanced&&n.isInstanced&&this.extensions.instancing?this.state.setVertexAttributeArrayDivisor(r+a,1):this.state.setVertexAttributeArrayDivisor(r+a,0);break}}return!0}}}var be=(t=>(t[t.FLOAT=0]="FLOAT",t[t.VEC2=1]="VEC2",t[t.VEC3=2]="VEC3",t[t.VEC4=3]="VEC4",t[t.VEC4_ARRAY=4]="VEC4_ARRAY",t[t.FLOAT_ARRAY=5]="FLOAT_ARRAY",t[t.MATRIX3x3=6]="MATRIX3x3",t[t.MATRIX4x4=7]="MATRIX4x4",t[t.TEXTURE=8]="TEXTURE",t))(be||{});function Lp(t){return t.type===1}function Op(t){return t.type===2}function Np(t){return t.type===3}function Xl(t){return t.type===4}function Pp(t){return t.type===6}function Dp(t){return t.type===7}function Fp(t){return t.type===8}function Bp(t){return t.type===0}const Up=window.OffscreenCanvas||xs;function gi(t){return t instanceof Up}var mt=(t=>(t[t.INVALID=0]="INVALID",t[t.VALID=1]="VALID",t[t.NO_RENDER_TARGET_MATCHES=2]="NO_RENDER_TARGET_MATCHES",t))(mt||{});class Hn{constructor(e){this.isInvalid=!1,this._uid=G(),this._validFramebuffer=!1,this._disabledTargets=new Set,this.retainTextureTargets=!1,this._buffers={color:Array.isArray(e.buffers.color)?e.buffers.color.slice(0):e.buffers.color,depth:e.buffers.depth,stencil:e.buffers.stencil},this._width=e.width||0,this._height=e.height||0,this.retainTextureTargets=e.retainTextureTargets||!1,this.calculateDimensions()}get uid(){return this._uid}get buffers(){return{color:Array.isArray(this._buffers.color)?this._buffers.color.slice(0):this._buffers.color,depth:this._buffers.depth,stencil:this._buffers.stencil}}get height(){return this._height}get width(){return this._width}get validFramebuffer(){return this._validFramebuffer}get disabledTargets(){return this._disabledTargets}set disabledTargets(e){this._disabledTargets=e}calculateDimensions(){const e=[];if(this._buffers.color instanceof ie)e.push(this._buffers.color);else if(Array.isArray(this._buffers.color))for(let n=0,i=this._buffers.color.length;n<i;++n){const r=this._buffers.color[n];r.buffer instanceof ie&&e.push(r.buffer)}else this._buffers.color&&this._buffers.color.buffer instanceof ie&&e.push(this._buffers.color.buffer);if(this._buffers.depth instanceof ie&&e.push(this._buffers.depth),this._buffers.stencil instanceof ie&&e.push(this._buffers.stencil),e.length>0&&e[0].data){const{width:n,height:i}=e[0].data;for(let r=0,s=e.length;r<s;++r){const a=e[r];if(!a.data){console.warn("A texture specified for thie RenderTarget did not have any data associated with it.");return}const{width:o,height:c}=a.data;(o!==n||c!==i)&&(console.warn("Texture applied to the render target is invalid as it does not match dimensions of all textures applied:",a,e,"The texture will be removed as a target for the render target"),this.removeTextureFromBuffer(a))}this._width=n,this._height=i}(!this._width||!this._height)&&console.warn("A RenderTarget was not able to establish valid dimensions. This target had no texture buffers and did not specify valid width and height values.",this)}dispose(){this.gl&&this.gl.proxy.disposeRenderTarget(this)}getBuffers(){return Array.isArray(this.buffers.color)?this.buffers.color:this.buffers.color?[this.buffers.color]:[]}getGLBuffers(){return this.gl?Array.isArray(this.gl.colorBufferId)?this.gl.colorBufferId:[this.gl.colorBufferId]:(this.isInvalid||console.warn("Attempted to retrieve gl buffers before the render target was compiled."),[])}getOutputTypes(){return this.getBuffers().map(e=>e.outputType)}getSize(){return[this._width,this._height]}getTextures(){const e=[];return Array.isArray(this.buffers.color)?this.buffers.color.forEach(n=>{n.buffer instanceof ie&&e.push(n.buffer)}):this.buffers.color&&this.buffers.color.buffer instanceof ie&&e.push(this.buffers.color.buffer),this.buffers.depth instanceof ie&&e.push(this.buffers.depth),this.buffers.stencil instanceof ie&&e.push(this.buffers.stencil),e}isColorTarget(){var e;if(Array.isArray(this.buffers.color)){if(this.buffers.color.length===1)return this.buffers.color[0].outputType===$.COLOR}else return((e=this.buffers.color)==null?void 0:e.outputType)===$.COLOR;return!1}removeTextureFromBuffer(e){var n;if(Array.isArray(this._buffers.color)){const i=this._buffers.color.find(s=>s.buffer===e);if(!i)return;const r=this._buffers.color.indexOf(i);r>-1&&this._buffers.color.splice(r,1)}else((n=this._buffers.color)==null?void 0:n.buffer)===e&&delete this._buffers.color;this._buffers.depth===e&&delete this._buffers.depth,this._buffers.stencil===e&&delete this._buffers.stencil}setSize(e,n){this.dispose(),this._width=e,this._height=n,this.getTextures().forEach(r=>{r.data={buffer:null,height:n,width:e}})}setAsValid(){this._validFramebuffer=!0}}const Yl=Ie("performance");class ql{constructor(e,n){this.debugContext="",this._textureUnitToTexture=new Map,this._freeUnits=[],this._blendingEnabled=!0,this._blendDstFactor=d.GLSettings.Material.BlendingDstFactor.One,this._blendSrcFactor=d.GLSettings.Material.BlendingDstFactor.One,this._blendEquation=d.GLSettings.Material.BlendingEquations.Add,this._cullFace=d.GLSettings.Material.CullSide.NONE,this._colorMask=[!0,!0,!0,!0],this._clearColor=[0,0,0,1],this._depthFunc=d.GLSettings.Material.DepthFunctions.ALWAYS,this._depthTestEnabled=!0,this._depthMask=!0,this._ditheringEnabled=!0,this._boundFBO=null,this._renderTarget=null,this._boundRBO=null,this._boundVAO=null,this._boundVBO=null,this._boundTexture={id:null,unit:-1},this._currentProgram=null,this._scissorTestEnabled=!1,this._scissorBounds={x:0,y:0,width:1,height:1},this._currentUniforms={},this._activeTextureUnit=-1,this._drawBuffers=[],this._textureWillBeUsed=new Map,this._viewport={x:0,y:0,width:100,height:100},this._enabledVertexAttributeArray=[],this._willUseVertexAttributeArray=[],this._vertexAttributeArrayDivisor=new Map,this.gl=e,this.extensions=n;const i=this.gl.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);for(let r=0;r<i;++r)this._freeUnits.push(Vl(e,r));this._activeTextureUnit=e.TEXTURE0}get blendingEnabled(){return this._blendingEnabled}get blendDstFactor(){return this._blendDstFactor}get blendSrcFactor(){return this._blendSrcFactor}get blendEquation(){return this._blendEquation}get cullFace(){return this._cullFace}get colorMask(){return this._colorMask}get clearColor(){return this._clearColor}get depthFunc(){return this._depthFunc}get depthTestEnabled(){return this._depthTestEnabled}get depthMask(){return this._depthMask}get ditheringEnabled(){return this._ditheringEnabled}get boundFBO(){return this._boundFBO}get renderTarget(){return this._renderTarget}get boundRBO(){return this._boundRBO}get boundVAO(){return this._boundVAO}get boundVBO(){return this._boundVBO}get boundTexture(){return this._boundTexture}get currentProgram(){return this._currentProgram}get scissorTestEnabled(){return this._scissorTestEnabled}get scissorBounds(){return this._scissorBounds}get currentUniforms(){return this._currentUniforms}get activeTextureUnit(){return this._activeTextureUnit}get drawBuffers(){return this._drawBuffers}get textureWillBeUsed(){return this._textureWillBeUsed}get viewport(){return this._viewport}get enabledVertexAttributeArray(){return this._enabledVertexAttributeArray.slice(0).filter(e=>e!==void 0)}bindVAO(e){this._boundVAO!==e&&(this._boundVAO=e,this.extensions.vao&&(this.extensions.vao instanceof WebGL2RenderingContext?this.extensions.vao.bindVertexArray(e):this.extensions.vao.bindVertexArrayOES(e)))}bindVBO(e){this._boundVBO!==e&&(this._boundVBO=e,this.gl.bindBuffer(this.gl.ARRAY_BUFFER,e))}bindRBO(e){this._boundRBO!==e&&(this._boundRBO=e,this.gl.bindRenderbuffer(this.gl.RENDERBUFFER,e))}bindFBO(e){this._boundFBO!==e&&(this._boundFBO=e,this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,e))}bindTexture(e,n){if(!(!e.gl||!e.gl.textureId)&&(!e||this._boundTexture.id!==e.gl.textureId||this._boundTexture.unit!==this._activeTextureUnit)){switch(this._boundTexture={id:e.gl.textureId,unit:this._activeTextureUnit},n){case d.GLSettings.Texture.TextureBindingTarget.TEXTURE_2D:this.gl.bindTexture(this.gl.TEXTURE_2D,e.gl.textureId);break;case d.GLSettings.Texture.TextureBindingTarget.CUBE_MAP:this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP,e.gl.textureId);break}const i=this._textureUnitToTexture.get(this._activeTextureUnit);i&&i.gl&&(i.gl.textureUnit=-1),this._textureUnitToTexture.set(this._activeTextureUnit,e),e.gl.textureUnit=this._activeTextureUnit}}disableVertexAttributeArray(){for(let e=0,n=this._enabledVertexAttributeArray.length;e<n;++e){const i=this._enabledVertexAttributeArray[e];this.gl.disableVertexAttribArray(i)}this._enabledVertexAttributeArray=[],this._willUseVertexAttributeArray=[],this._vertexAttributeArrayDivisor.clear()}willUseVertexAttributeArray(e){this._willUseVertexAttributeArray[e]=e,this._enabledVertexAttributeArray[e]===void 0&&(this._enabledVertexAttributeArray[e]=e,this.gl.enableVertexAttribArray(e))}applyVertexAttributeArrays(){for(let e=0,n=this._enabledVertexAttributeArray.length;e<n;++e){const i=this._enabledVertexAttributeArray[e];if(i!==void 0){if(this._willUseVertexAttributeArray[i]!==void 0)return;this.gl.disableVertexAttribArray(i),delete this._enabledVertexAttributeArray[i]}}this._willUseVertexAttributeArray=[]}setVertexAttributeArrayDivisor(e,n){this.extensions.instancing&&this._enabledVertexAttributeArray[e]!==void 0&&this._vertexAttributeArrayDivisor.get(e)!==n&&(this.extensions.instancing instanceof WebGL2RenderingContext?this.extensions.instancing.vertexAttribDivisor(e,n):this.extensions.instancing.vertexAttribDivisorANGLE(e,n),this._vertexAttributeArrayDivisor.set(e,n))}freeTextureUnit(e){e.gl&&e.gl.textureUnit>-1&&(this._freeUnits.unshift(e.gl.textureUnit),e.gl.textureUnit=-1)}setActiveTextureUnit(e){this._activeTextureUnit!==e&&(this._activeTextureUnit=e,this.gl.activeTexture(e))}setClearColor(e){gs(e,this._clearColor)||(this._clearColor=Mt(e),this.applyClearColor())}setDrawBuffers(e,n){let i=e.length!==this._drawBuffers.length;if(!i){for(let r=0,s=e.length;r<s;++r)if(this._drawBuffers[r]!==e[r]){i=!0;break}}if(i){if(this.glProxy.extensions.drawBuffers instanceof WebGL2RenderingContext)n||this.glProxy.extensions.drawBuffers.drawBuffers(e);else if(this.glProxy.extensions.drawBuffers)n||this.glProxy.extensions.drawBuffers.drawBuffersWEBGL(e);else{console.warn("Attempted to use drawBuffers for MRT, but MRT is NOT supported by this hardware. Use multiple render targets instead");return}this._drawBuffers=e}}setProxy(e){this.glProxy=e}setScissor(e){e?(this._scissorTestEnabled||(this._scissorTestEnabled=!0,this.gl.enable(this.gl.SCISSOR_TEST)),(e.x!==this._scissorBounds.x||e.y!==this._scissorBounds.y||e.width!==this._scissorBounds.width||e.height!==this._scissorBounds.height)&&(this._scissorBounds=e,this.applyScissorBounds())):this._scissorTestEnabled&&(this._scissorTestEnabled=!1,this.gl.disable(this.gl.SCISSOR_TEST))}setViewport(e,n,i,r){(e!==this._viewport.x||n!==this._viewport.y||i!==this._viewport.width||r!==this._viewport.height)&&(this._viewport={x:e,y:n,width:i,height:r},this.applyViewport())}useProgram(e){this._currentProgram!==e&&(this._currentProgram=e,this.gl.useProgram(this._currentProgram))}useMaterial(e){if(!e.gl&&(!this.glProxy.compileMaterial(e)||!e.gl)||!e.gl.programId||e.gl.programId.length===0)return mt.INVALID;const n=this.findMaterialProgram(e);if(n===void 0)return console.warn("Could NOT determine a program for the given material that would appropriately match with the current RenderTarget"),mt.NO_RENDER_TARGET_MATCHES;if(this._renderTarget&&(e.gl.programByTarget.set(this._renderTarget,n),this.glProxy.extensions.drawBuffers)){const i=e.gl.outputsByProgram.get(n),r=this._renderTarget.getGLBuffers();if(!i||!r)return console.warn("Could not establish the buffers to utilize for the render target"),mt.NO_RENDER_TARGET_MATCHES;const s=[];for(let a=0,o=r.length;a<o;++a){const c=r[a];i.find(l=>(c==null?void 0:c.outputType)===l)===void 0?s.push(this.gl.NONE):this._renderTarget.disabledTargets.has((c==null?void 0:c.outputType)||0)?s.push(this.gl.NONE):s.push((c==null?void 0:c.attachment)||this.gl.NONE)}this.setDrawBuffers(s)}return this.useProgram(n),this.syncMaterial(e),mt.VALID}findMaterialProgram(e){if(!e.gl)return;if(!this._renderTarget||this._renderTarget.isColorTarget()){let o;if(this._renderTarget&&(o=e.gl.programByTarget.get(this._renderTarget),o!==void 0))return o;let c=Number.MAX_SAFE_INTEGER;for(let u=0,l=e.gl.programId.length;u<l;++u){const h=e.gl.programId[u];h.outputTypes.length<c&&h.outputTypes.indexOf($.COLOR)>=0&&(o=h.id,c=h.outputTypes.length)}return o||(o=e.gl.programId[e.gl.programId.length-1]),o}let n=e.gl.programByTarget.get(this._renderTarget);if(n!==void 0)return n;const i=new Set,r=this._renderTarget.getBuffers();for(let o=0,c=r.length;o<c;++o){const u=r[o];u&&i.add(u.outputType)}let s=0,a=[];for(let o=0,c=e.gl.programId.length;o<c;++o){const u=e.gl.programId[o];let l=0;for(let h=0,f=u.outputTypes.length;h<f;++h){const p=u.outputTypes[h];i.has(p)&&l++}l>s?(s=l,a=[u]):l===s&&a.push(u)}if(a.length!==0)return a.length===1?n=a[0].id:a.length>1&&(n=a.reduce((o,c)=>c.outputTypes.length<o.outputTypes.length?c:o)),n}useRenderTarget(e){return e?e.gl?(this.bindFBO(e.gl.fboId),this._renderTarget=e,!0):!1:(this.bindFBO(null),this._renderTarget=null,!0)}syncMaterial(e){return this.setDepthMask(e.depthWrite),this.setDepthTest(e.depthTest),this.setDepthFunc(e.depthFunc),this.setBlending(e.blending),this.setCullFace(e.culling),this.setColorMask(e.colorWrite),this.setDithering(e.dithering),this._currentUniforms=e.uniforms,!(!this._currentProgram||(Object.entries(e.uniforms).forEach(([n,i])=>{if(!this._currentProgram)return;i.gl||(i.gl=new Map);let r=i.gl.get(this._currentProgram);if(!r){const s=this.gl.getUniformLocation(this._currentProgram,n);if(!s){r={location:void 0},Yl(this.debugContext,`A Material specified a uniform ${n}, but none was found in the current program.`);return}r={location:s},i.gl.set(this._currentProgram,r)}r.location&&this.uploadUniform(r.location,i)}),this._textureWillBeUsed.size>0&&!this.applyUsedTextures()))}setDepthMask(e){this._depthMask!==e&&(this._depthMask=e,this.gl.depthMask(this._depthMask))}setDepthTest(e){this._depthTestEnabled!==e&&(this._depthTestEnabled=e,this._depthTestEnabled?this.gl.enable(this.gl.DEPTH_TEST):this.gl.disable(this.gl.DEPTH_TEST))}setDepthFunc(e){this._depthFunc!==e&&(this._depthFunc=e,this.applyDepthFunc())}setBlending(e){e?(this._blendingEnabled||(this.gl.enable(this.gl.BLEND),this._blendingEnabled=!0),(this._blendDstFactor!==e.blendDst||this._blendSrcFactor!==e.blendSrc||this._blendEquation!==e.blendEquation)&&(this._blendDstFactor=e.blendDst||this._blendDstFactor,this._blendSrcFactor=e.blendSrc||this._blendSrcFactor,this._blendEquation=e.blendEquation||this._blendEquation,this.applyBlendFactors())):this._blendingEnabled&&(this.gl.disable(this.gl.BLEND),this._blendingEnabled=!1)}setDithering(e){this._ditheringEnabled!==e&&(this._ditheringEnabled=e,this._ditheringEnabled?this.gl.enable(this.gl.DITHER):this.gl.disable(this.gl.DITHER))}setColorMask(e){(this._colorMask[0]!==e[0]||this._colorMask[1]!==e[1]||this._colorMask[2]!==e[2]||this._colorMask[3]!==e[3])&&(this._colorMask=e,this.applyColorMask())}setCullFace(e){this._cullFace!==e&&(this._cullFace=e,this.applyCullFace())}uploadUniform(e,n){let i;switch(n.type){case be.FLOAT:i=n.value,this.gl.uniform1f(e,i);break;case be.VEC2:i=n.value,this.gl.uniform2f(e,i[0],i[1]);break;case be.VEC3:i=n.value,this.gl.uniform3f(e,i[0],i[1],i[2]);break;case be.VEC4:i=n.value,this.gl.uniform4f(e,i[0],i[1],i[2],i[3]);break;case be.VEC4_ARRAY:i=n.value,this.gl.uniform4fv(e,ms(i));break;case be.MATRIX3x3:i=n.value,this.gl.uniformMatrix3fv(e,!1,i);break;case be.MATRIX4x4:i=n.value,this.gl.uniformMatrix4fv(e,!1,i);break;case be.FLOAT_ARRAY:i=n.value,this.gl.uniform1fv(e,i);break;case be.TEXTURE:i=n.value,this.willUseTextureUnit(i,e);break;default:console.warn(this.debugContext,"A uniform specified an unrecognized type. It will not sync with the GPU:",n)}}applyUsedTextures(){const e=this.assignTextureUnits(Array.from(this._textureWillBeUsed.keys()));e.forEach(r=>{r.gl?r.gl.textureUnit=this.gl.TEXTURE0:r.gl={textureId:null,textureUnit:this.gl.TEXTURE0,proxy:this.glProxy}});const n=new Map,i=new Set;return this._textureWillBeUsed.forEach((r,s)=>{r instanceof Hn?i.add(r):n.set(s,r)}),i.forEach(r=>{r.getTextures().some(o=>{if(e.indexOf(o)<0)this.glProxy.updateTexture(o);else return!0;return!1})?console.warn(this.debugContext,"A RenderTarget can not be used because all of it's textures could not be compiled."):this.glProxy.compileRenderTarget(r)}),n.forEach((r,s)=>{e.indexOf(s)<0?(this.glProxy.updateTexture(s),r.forEach(a=>{this.uploadTextureToUniform(a,s)})):r.forEach(a=>{this.gl.uniform1i(a,Co(this.gl,0))})}),this._textureWillBeUsed.clear(),!0}assignTextureUnits(e){const n=[],i=[];for(e.forEach(a=>{!a.gl||a.gl.textureUnit<0?n.push(a):i.push(a)});this._freeUnits.length>0&&n.length>0;){const a=n.shift();if(!a)continue;const o=this._freeUnits.shift();if(o===void 0){n.unshift(a);continue}a.gl?a.gl.textureUnit=o:a.gl={textureId:null,textureUnit:o,proxy:this.glProxy},i.push(a)}if(n.length<=0)return n;Yl("WARNING: Too many textures in use are causing texture units to be swapped. Doing this occasionally is fine, but handling this on a frame loop can have serious performance concerns.");const r=new Map;this._textureUnitToTexture.forEach(a=>{a&&r.set(a,!1)}),i.forEach(a=>{r.set(a,!0)});const s=[];if(r.forEach((a,o)=>{a||s.push(o)}),s.length===0)return console.warn(this.debugContext,"There are too many textures being used for a single draw call. These textures will not be utilized on the GPU",n),console.warn("Current GL State:",this),n;for(;s.length>0&&n.length>0;){const a=n.shift();if(!a)continue;const o=s.shift();if(o===void 0||!o.gl||o.gl.textureUnit<0){n.unshift(a);continue}a.gl?a.gl.textureUnit=o.gl.textureUnit:a.gl={textureId:null,textureUnit:o.gl.textureUnit,proxy:this.glProxy},i.push(a)}return n.length>0&&(console.error(this.debugContext,"There are too many textures being used for a single draw call. These textures will not be utilized on the GPU",n),console.warn("Current GL State:",this)),n}uploadTextureToUniform(e,n){n.gl&&n.gl.textureUnit>=0?this.gl.uniform1i(e,Co(this.gl,n.gl.textureUnit)):console.warn(this.debugContext,"Attempted to set a Texture Object to a uniform, but the Texture object did not have a valid texture unit.",n)}willUseTextureUnit(e,n){const i=this._textureWillBeUsed.get(e);n instanceof Hn?i?i instanceof Hn&&i!==n&&console.warn(this.debugContext,"A Texture is attempting to be used by two different render targets in a single draw."):this._textureWillBeUsed.set(e,n):i?i instanceof Hn?console.warn(this.debugContext,"A texture in a single draw is attempting to attach to a uniform AND a render target which is invalid."):i.add(n):this._textureWillBeUsed.set(e,new Set([n]))}syncState(){const e=this.gl;this._blendingEnabled?e.enable(e.BLEND):e.disable(e.BLEND),this._ditheringEnabled?e.enable(e.DITHER):e.disable(e.DITHER),this._depthTestEnabled?e.enable(e.DEPTH_TEST):e.disable(e.DEPTH_TEST),this._scissorTestEnabled?e.enable(e.SCISSOR_TEST):e.disable(e.SCISSOR_TEST),this.setActiveTextureUnit(this._activeTextureUnit),this.applyClearColor(),this.applyCullFace(),this.applyBlendFactors(),this.applyBlendEquation(),this.applyColorMask(),this.applyDepthFunc(),this.applyScissorBounds(),this.applyViewport(),e.depthMask(this._depthMask)}applyClearColor(){this.gl.clearColor(this._clearColor[0],this._clearColor[1],this._clearColor[2],this._clearColor[3])}applyDepthFunc(){const e=this.gl;switch(this._depthFunc){case d.GLSettings.Material.DepthFunctions.ALWAYS:e.depthFunc(e.ALWAYS);break;case d.GLSettings.Material.DepthFunctions.EQUAL:e.depthFunc(e.EQUAL);break;case d.GLSettings.Material.DepthFunctions.GREATER:e.depthFunc(e.GREATER);break;case d.GLSettings.Material.DepthFunctions.GREATER_OR_EQUAL:e.depthFunc(e.GEQUAL);break;case d.GLSettings.Material.DepthFunctions.LESS:e.depthFunc(e.LESS);break;case d.GLSettings.Material.DepthFunctions.LESS_OR_EQUAL:e.depthFunc(e.LEQUAL);break;case d.GLSettings.Material.DepthFunctions.NEVER:e.depthFunc(e.NEVER);break;case d.GLSettings.Material.DepthFunctions.NOTEQUAL:e.depthFunc(e.NOTEQUAL);break;default:e.depthFunc(e.ALWAYS);break}}applyScissorBounds(){this.gl.scissor(this._scissorBounds.x,this._scissorBounds.y,this._scissorBounds.width,this._scissorBounds.height)}applyColorMask(){this.gl.colorMask(this.colorMask[0]||!1,this.colorMask[1]||!1,this.colorMask[2]||!1,this.colorMask[3]||!1)}applyBlendEquation(){const e=this.gl;switch(this._blendEquation){case d.GLSettings.Material.BlendingEquations.Add:e.blendEquation(e.FUNC_ADD);break;case d.GLSettings.Material.BlendingEquations.Subtract:e.blendEquation(e.FUNC_SUBTRACT);break;case d.GLSettings.Material.BlendingEquations.ReverseSubtract:e.blendEquation(e.FUNC_REVERSE_SUBTRACT);break}}applyBlendFactors(){const e=this.gl;let n,i;switch(this._blendDstFactor){case d.GLSettings.Material.BlendingDstFactor.DstAlpha:n=e.BLEND_DST_ALPHA;break;case d.GLSettings.Material.BlendingDstFactor.DstColor:n=e.BLEND_DST_RGB;break;case d.GLSettings.Material.BlendingDstFactor.One:n=e.ONE;break;case d.GLSettings.Material.BlendingDstFactor.OneMinusDstAlpha:n=e.ONE_MINUS_DST_ALPHA;break;case d.GLSettings.Material.BlendingDstFactor.OneMinusDstColor:n=e.ONE_MINUS_DST_COLOR;break;case d.GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha:n=e.ONE_MINUS_SRC_ALPHA;break;case d.GLSettings.Material.BlendingDstFactor.OneMinusSrcColor:n=e.ONE_MINUS_SRC_COLOR;break;case d.GLSettings.Material.BlendingDstFactor.SrcAlpha:n=e.SRC_ALPHA;break;case d.GLSettings.Material.BlendingDstFactor.SrcColor:n=e.SRC_COLOR;break;case d.GLSettings.Material.BlendingDstFactor.Zero:n=e.ZERO;break;default:n=e.ONE;break}switch(this._blendSrcFactor){case d.GLSettings.Material.BlendingDstFactor.DstAlpha:i=e.BLEND_DST_ALPHA;break;case d.GLSettings.Material.BlendingDstFactor.DstColor:i=e.BLEND_DST_RGB;break;case d.GLSettings.Material.BlendingDstFactor.One:i=e.ONE;break;case d.GLSettings.Material.BlendingDstFactor.OneMinusDstAlpha:i=e.ONE_MINUS_DST_ALPHA;break;case d.GLSettings.Material.BlendingDstFactor.OneMinusDstColor:i=e.ONE_MINUS_DST_COLOR;break;case d.GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha:i=e.ONE_MINUS_SRC_ALPHA;break;case d.GLSettings.Material.BlendingDstFactor.OneMinusSrcColor:i=e.ONE_MINUS_SRC_COLOR;break;case d.GLSettings.Material.BlendingDstFactor.SrcAlpha:i=e.SRC_ALPHA;break;case d.GLSettings.Material.BlendingDstFactor.SrcColor:i=e.SRC_COLOR;break;case d.GLSettings.Material.BlendingDstFactor.Zero:i=e.ZERO;break;case d.GLSettings.Material.BlendingSrcFactor.SrcAlphaSaturate:i=e.SRC_ALPHA_SATURATE;break;default:i=e.ONE;break}e.blendFunc(i,n)}applyCullFace(){const e=this.gl;switch(this._cullFace!==d.GLSettings.Material.CullSide.NONE&&e.enable(e.CULL_FACE),this._cullFace){case d.GLSettings.Material.CullSide.CW:e.frontFace(e.CW),e.cullFace(e.FRONT);break;case d.GLSettings.Material.CullSide.CCW:e.frontFace(e.CCW),e.cullFace(e.FRONT);break;case d.GLSettings.Material.CullSide.BOTH:e.frontFace(e.CW),e.cullFace(e.FRONT_AND_BACK);break;default:e.disable(e.CULL_FACE)}}applyViewport(){this.gl.viewport(this._viewport.x,this._viewport.y,this._viewport.width,this._viewport.height)}}class yr{constructor(e){this.blending={blendDst:d.GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha,blendEquation:d.GLSettings.Material.BlendingEquations.Add,blendSrc:d.GLSettings.Material.BlendingSrcFactor.SrcAlpha},this.colorWrite=[!0,!0,!0,!0],this.culling=d.GLSettings.Material.CullSide.CCW,this.depthFunc=d.GLSettings.Material.DepthFunctions.LESS_OR_EQUAL,this.depthTest=!0,this.depthWrite=!0,this.dithering=!0,this.name="",this.uniforms={},this.vertexShader="",Object.assign(this,e),delete this.gl}clone(){const e=new yr(this);e.blending=Object.assign({},this.blending),e.polygonOffset=Object.assign({},this.polygonOffset),e.uniforms=Object.assign({},this.uniforms);for(const n in e.uniforms){const i=e.uniforms[n];if(i.gl){const r=new Map;i.gl.forEach((s,a)=>{r.set(a,Object.assign({},s))})}}return e}dispose(){this.gl&&this.gl.proxy.disposeMaterial(this)}}class Bo{constructor(e,n,i){this.drawMode=d.GLSettings.Model.DrawMode.TRIANGLES,this.vertexDrawRange=[-1,-1],this.drawInstances=-1,this.vertexCount=0,this.id=e,this.geometry=n,this.material=i}}class Ms{constructor(){this.models=new Set}add(e){this.models.add(e)}remove(e){this.models.delete(e)}}const Kl=Ie("performance");class Zl{constructor(e){this.state={clearMask:[!1,!1,!1],currentRenderTarget:null,displaySize:[1,1],pixelRatio:1,renderSize:[1,1]},this.options=Object.assign({alpha:!1,antialias:!1,preserveDrawingBuffer:!1},e),this.options.canvas||console.warn("WebGLRenderer ERROR: A canvas is REQUIRED as a parameter."),this.getContext()}set debugContext(e){this.glProxy&&(this.glProxy.debugContext=e),this.glState&&(this.glState.debugContext=e)}get gl(){return this._gl}clear(e,n,i){const r=this.state.clearMask;this.state.clearMask=[r[0]||e||!1,r[1]||n||!1,r[2]||i||!1]}clearColor(e){e&&this.glState.setClearColor(e)}dispose(){}getContext(){if(this._gl)return this._gl;const e=Tr.getContext(this.options.canvas,{alpha:this.options.alpha||!1,antialias:this.options.antialias||!1,premultipliedAlpha:this.options.premultipliedAlpha||!1,preserveDrawingBuffer:this.options.preserveDrawingBuffer||!1});return e.context?(this._gl=e.context,this.glState=new ql(e.context,e.extensions),this.glProxy=new Tr(e.context,this.glState,e.extensions),this.glState.setProxy(this.glProxy),this.glState.syncState()):this.options.onNoContext?this.options.onNoContext():console.warn("No context was able to be produced, and the handler onNoContext was not implemented for such cases."),this._gl}getDisplaySize(){return this.state.displaySize}getPixelRatio(){return this.state.pixelRatio}getRenderSize(){return this.state.renderSize}getFullViewport(){const e=this.state.currentRenderTarget;if(Array.isArray(e))return{x:0,y:0,width:e[0].width,height:e[0].height};if(e)return{x:0,y:0,width:e.width,height:e.height};{const n=this.getRenderSize();return{x:0,y:0,width:n[0],height:n[1]}}}prepareAttribute(e,n,i){if(this.glProxy.updateAttribute(n))(!e.gl||!e.gl.vao)&&this.glProxy.useAttribute(i,n,e);else return console.warn("Could not update attribute",n),!1;return!0}render(e,n=null,i){if(!this.gl)return;this.setRenderTarget(n);const r=[];if(n&&!Array.isArray(n)&&(L.MRT||L.MRT_EXTENSION)){const a=n.getGLBuffers();this.glState.setDrawBuffers(a.map(o=>(o==null?void 0:o.attachment)||0))}const s=this.state.clearMask;if((s[0]||s[1]||s[2])&&(this.glProxy.clear(s[0],s[1],s[2]),this.state.clearMask=[!1,!1,!1]),Array.isArray(n))for(let a=0,o=n.length;a<o;++a){const c=n[a];if(this.glState.useRenderTarget(c),c&&!c.gl)return;e.models.forEach(u=>{this.renderModel(u,r,i)})}else{if(n&&!n.gl)return;e.models.forEach(a=>{this.renderModel(a,r,i)})}r.forEach(a=>{e.remove(a)})}renderModel(e,n,i){var o;const r=e.geometry,s=e.material;switch(this.glState.useMaterial(s)){case mt.VALID:{this.glProxy.compileGeometry(r);let c=!0;const u=(l,h)=>{c=this.prepareAttribute(r,l,h)&&c};r.attributes.forEach(u),(o=r.gl)!=null&&o.vao?this.glState.bindVAO(r.gl.vao):this.glState.applyVertexAttributeArrays(),i==null||i(this.glState,e.id),c?this.glProxy.draw(e):(console.warn("Geometry was unable to update correctly, thus we are skipping the drawing of",e),n.push(e)),this.glState.bindVAO(null);break}case mt.INVALID:{console.warn("Could not utilize material. Skipping draw call for:",s,r),n.push(e);break}case mt.NO_RENDER_TARGET_MATCHES:{Kl("Skipped draw for material due to no output matches for the current render target");break}default:Kl("Skipped draw for material due to unknown reasons");break}}readPixels(e,n,i,r,s,a=0){if(!this.gl)return;const o=this.state.currentRenderTarget;let c=!0,u;if(Array.isArray(o))u=o.find(l=>{var h;return Array.isArray(l.buffers.color)?l.buffers.color.find(f=>f.outputType===a):((h=l.buffers.color)==null?void 0:h.outputType)===a});else if(o&&Array.isArray(o==null?void 0:o.buffers.color)){if(o.buffers.color.length>1){console.warn("It is not yet implemented to read the pixels from a RenderTarget with multiple color buffers");return}u=o}else u=o;if(u&&(c=u.validFramebuffer),!c){console.warn("Framebuffer is incomplete. Can not read pixels at this time.");return}if(e=Math.max(0,e),n=Math.max(0,n),u){e+i>u.width&&(i=u.width-e),n+r>u.height&&(r=u.height-n);const l=u.height;this.gl.readPixels(e,l-n-r,i,r,this.gl.RGBA,this.gl.UNSIGNED_BYTE,s)}else{const l=this.getRenderSize(),h=l[1];e+i>l[0]&&(i=l[0]-e),n+r>l[1]&&(r=l[1]-n),this.gl.readPixels(e,h-n-r,i,r,this.gl.RGBA,this.gl.UNSIGNED_BYTE,s)}}setClearColor(e){this.glState.setClearColor(e)}setPixelRatio(e){const{canvas:n}=this.options,i=this.getDisplaySize();n.width=i[0]*e,n.height=i[1]*e,this.state.pixelRatio=e}setScissor(e,n){if(n=n||this.state.currentRenderTarget||null,Array.isArray(n)){const i=n[0].height;if(e){const{x:r,y:s,width:a,height:o}=e;this.glState.setScissor({x:r,y:i-s-o,width:a,height:o})}else this.glState.setScissor(null)}else if(n){const i=n.height;if(e){const{x:r,y:s,width:a,height:o}=e;this.glState.setScissor({x:r,y:i-s-o,width:a,height:o})}else this.glState.setScissor(null)}else{const{renderSize:i}=this.state,r=i[1];if(e){const{x:s,y:a,width:o,height:c}=e;this.glState.setScissor({x:s,y:r-a-c,width:o,height:c})}else this.glState.setScissor(null)}}setSize(e,n){const{canvas:i}=this.options,{pixelRatio:r}=this.state;i.width=Math.min(e*r,L.MAX_TEXTURE_SIZE),i.height=Math.min(n*r,L.MAX_TEXTURE_SIZE),i.style.width=`${e}px`,i.style.height=`${n}px`,this.state.renderSize=[i.width,i.height],this.state.displaySize=[e,n]}setRenderTarget(e){this.state.currentRenderTarget!==e&&(Array.isArray(e)?e.forEach(n=>{n.gl||this.glProxy.compileRenderTarget(n)}):!this.glState.useRenderTarget(e)&&e&&(e.getTextures().forEach(n=>{this.glState.willUseTextureUnit(n,e)}),this.glState.applyUsedTextures(),this.glProxy.compileRenderTarget(e)&&this.glState.useRenderTarget(e)),this.state.currentRenderTarget=e)}setViewport(e){const n=this.state.currentRenderTarget,{x:i,y:r,width:s,height:a}=e;if(Array.isArray(n)){const o=n[0].height;this.glState.setViewport(i,o-r-a,s,a)}else if(n){const o=n.height;this.glState.setViewport(i,o-r-a,s,a)}else{const{renderSize:o}=this.state,c=o[1];this.glState.setViewport(i,c-r-a,s,a)}}}var Is=!!(typeof window<"u"&&window.document&&window.document.createElement),Jl={canUseDOM:Is,canUseWorkers:typeof Worker<"u",canUseEventListeners:Is&&!!(window.addEventListener||window.attachEvent),canUseViewport:Is&&!!window.screen,isInWorker:!Is},eu;Jl.canUseDOM&&(eu=document.implementation&&document.implementation.hasFeature&&document.implementation.hasFeature("","")!==!0);/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */function Gp(t,e){if(!Jl.canUseDOM||e&&!("addEventListener"in document))return!1;var n="on"+t,i=n in document;if(!i){var r=document.createElement("div");r.setAttribute(n,"return;"),i=typeof r[n]=="function"}return!i&&eu&&t==="wheel"&&(i=document.implementation.hasFeature("Events.wheel","3.0")),i}var tu=!1,mi,Uo,Go,Cs,Ls,nu,Os,ko,zo,Vo,iu,Wo,$o,ru,su;function qe(){if(!tu){tu=!0;var t=navigator.userAgent,e=/(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(t),n=/(Mac OS X)|(Windows)|(Linux)/.exec(t);if(Wo=/\b(iPhone|iP[ao]d)/.exec(t),$o=/\b(iP[ao]d)/.exec(t),Vo=/Android/i.exec(t),ru=/FBAN\/\w+;/i.exec(t),su=/Mobile/i.exec(t),iu=!!/Win64/.exec(t),e){mi=e[1]?parseFloat(e[1]):e[5]?parseFloat(e[5]):NaN,mi&&document&&document.documentMode&&(mi=document.documentMode);var i=/(?:Trident\/(\d+.\d+))/.exec(t);nu=i?parseFloat(i[1])+4:mi,Uo=e[2]?parseFloat(e[2]):NaN,Go=e[3]?parseFloat(e[3]):NaN,Cs=e[4]?parseFloat(e[4]):NaN,Cs?(e=/(?:Chrome\/(\d+\.\d+))/.exec(t),Ls=e&&e[1]?parseFloat(e[1]):NaN):Ls=NaN}else mi=Uo=Go=Ls=Cs=NaN;if(n){if(n[1]){var r=/(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(t);Os=r?parseFloat(r[1].replace("_",".")):!0}else Os=!1;ko=!!n[2],zo=!!n[3]}else Os=ko=zo=!1}}var jo={ie:function(){return qe()||mi},ieCompatibilityMode:function(){return qe()||nu>mi},ie64:function(){return jo.ie()&&iu},firefox:function(){return qe()||Uo},opera:function(){return qe()||Go},webkit:function(){return qe()||Cs},safari:function(){return jo.webkit()},chrome:function(){return qe()||Ls},windows:function(){return qe()||ko},osx:function(){return qe()||Os},linux:function(){return qe()||zo},iphone:function(){return qe()||Wo},mobile:function(){return qe()||Wo||$o||Vo||su},nativeApp:function(){return qe()||ru},android:function(){return qe()||Vo},ipad:function(){return qe()||$o}};const au=10,ou=40,cu=800;function Ho(t){let e=0,n=0,i=0,r=0;return"detail"in t&&(n=t.detail),"wheelDelta"in t&&(n=-t.wheelDelta/120),"wheelDeltaY"in t&&(n=-t.wheelDeltaY/120),"wheelDeltaX"in t&&(e=-t.wheelDeltaX/120),"axis"in t&&t.axis===t.HORIZONTAL_AXIS&&(e=n,n=0),i=e*au,r=n*au,"deltaY"in t&&(r=t.deltaY),"deltaX"in t&&(i=t.deltaX),(i||r)&&t.deltaMode&&(t.deltaMode===1?(i*=ou,r*=ou):(i*=cu,r*=cu)),i&&!e&&(e=i<1?-1:1),r&&!n&&(n=r<1?-1:1),{spinX:e,spinY:-n,pixelX:i,pixelY:-r}}Ho.getEventType=function(){return jo.firefox()?"DOMMouseScroll":Gp("wheel")?"wheel":"mousewheel"};function Ct(t,e){let n=0,i=0,r=0,s=0,a=e||t.nativeEvent&&t.nativeEvent.target||t.target;if(t||(t=window.event),t.pageX||t.pageY)n=t.pageX,i=t.pageY;else if(t.clientX||t.clientY){let o=0,c=0;document.documentElement&&(o=document.documentElement.scrollLeft,c=document.documentElement.scrollTop),n=t.clientX+document.body.scrollLeft+o,i=t.clientY+document.body.scrollTop+c}if(a.offsetParent)do r+=a.offsetLeft,s+=a.offsetTop,a=a.offsetParent;while(a);return[n-r,i-s]}function me(t){return t!=null}function lu(t){return Array.isArray(t)?e=>t.indexOf(e.start.view.id)>=0:e=>e.start.view.id===t}function uu(t){return Array.isArray(t)?e=>e.start.views.find(n=>t.indexOf(n.view.id)>=0):e=>e.start.views.find(n=>n.view.id===t)}class Ns{constructor(){this._uid=G(),this.id="",this.pixelRatio=1,this._screenScale=[1,1]}get uid(){return this._uid}get screenBounds(){return this._scaledScreenBounds||(this._scaledScreenBounds=new te({x:this._screenBounds.x*this._screenScale[0],y:this._screenBounds.y*this._screenScale[1],width:this._screenBounds.width*this._screenScale[0],height:this._screenBounds.height*this._screenScale[1]})),this._scaledScreenBounds}set screenBounds(e){delete this._scaledScreenBounds,this._screenBounds=e}get screenScale(){return this._screenScale}set screenScale(e){cs(e,this._screenScale)||(delete this._scaledScreenBounds,this._screenScale=e)}screenToRenderSpace(e,n){return n=this.screenToView(e,n),de(n,e[0]*this.pixelRatio,e[1]*this.pixelRatio)}renderSpaceToScreen(e,n){return n=n||[0,0],de(n,e[0]/this.pixelRatio-this.screenBounds.x,e[1]/this.pixelRatio-this.screenBounds.y)}screenToView(e,n){return n=n||[0,0],de(n,e[0]-this.screenBounds.x,e[1]-this.screenBounds.y)}viewToScreen(e,n){return n=n||[0,0],de(n,e[0]+this.screenBounds.x,e[1]+this.screenBounds.y)}}class hu extends Ns{screenToWorld(e,n){return e}screenRay(e){return[[0,0,-1],[0,0,-2]]}worldToScreen(e,n){return e}viewToWorld(e,n){return e}worldToView(e,n){return e}}const{cos:ut,sin:ht,tan:Lt}=Math,dt=Math.PI/2,Qn=0,Xn=1,Yn=2,qn=3,br=0,Er=1,_r=2,Rr=3,xr=4,Ar=5,Sr=6,Mr=7,Ir=8,Ot=0,Nt=1,Pt=2,Dt=3,Ft=4,Bt=5,Ut=6,Gt=7,kt=8,zt=9,Vt=10,Wt=11,$t=12,jt=13,Ht=14,Qt=15,vi=new Array(20).fill(0).map(t=>Xt()),Ue=new Array(20).fill(0).map(t=>ue());function ft(t,e,n,i,r){return t=t||new Array(4),t[0]=e,t[1]=n,t[2]=i,t[3]=r,t}function Ke(t,e,n,i,r,s,a,o,c,u){return t=t||new Array(9),t[0]=e,t[1]=n,t[2]=i,t[3]=r,t[4]=s,t[5]=a,t[6]=o,t[7]=c,t[8]=u,t}function ve(t,e,n,i,r,s,a,o,c,u,l,h,f,p,g,m,T){return t=t||new Array(16),t[0]=e,t[1]=n,t[2]=i,t[3]=r,t[4]=s,t[5]=a,t[6]=o,t[7]=c,t[8]=u,t[9]=l,t[10]=h,t[11]=f,t[12]=p,t[13]=g,t[14]=m,t[15]=T,t}const du=Xt(),fu=Xt(),Qo=Xt(),kp=Xt();function ge(t){return t[3]*t[0]-t[1]*t[2]}function wi(t){return t[0]*t[4]*t[8]-t[0]*t[5]*t[7]+t[1]*t[5]*t[6]-t[1]*t[3]*t[8]+t[2]*t[3]*t[7]-t[2]*t[4]*t[6]}function Xo(t){return Ke(du,t[5],t[6],t[7],t[9],t[10],t[11],t[13],t[14],t[15]),Ke(fu,t[4],t[6],t[7],t[8],t[10],t[11],t[12],t[14],t[15]),Ke(Qo,t[4],t[5],t[7],t[8],t[9],t[11],t[12],t[13],t[15]),Ke(Qo,t[4],t[5],t[6],t[8],t[9],t[10],t[12],t[13],t[14]),t[0]*wi(du)-t[1]*wi(fu)+t[2]*wi(Qo)-t[3]*wi(kp)}function pu(t,e){const n=ge(t);return n===0?null:ft(e,t[3]/n,-t[1]/n,-t[2]/n,t[0]/n)}function gu(t,e){const n=wi(t);if(n===0)return null;const i=ge([t[4],t[5],t[7],t[8]]),r=ge([t[3],t[5],t[6],t[8]]),s=ge([t[3],t[4],t[6],t[7]]),a=ge([t[1],t[2],t[7],t[8]]),o=ge([t[0],t[2],t[6],t[8]]),c=ge([t[0],t[1],t[6],t[7]]),u=ge([t[1],t[2],t[4],t[5]]),l=ge([t[0],t[2],t[3],t[5]]),h=ge([t[0],t[1],t[3],t[4]]);return Ke(e,i/n,-a/n,u/n,-r/n,o/n,l/n,s/n,-c/n,h/n)}function mu(t,e){const n=Xo(t);if(n===0)return null;const i=ge([t[0],t[1],t[4],t[5]]),r=ge([t[0],t[2],t[4],t[6]]),s=ge([t[0],t[3],t[4],t[7]]),a=ge([t[1],t[2],t[5],t[6]]),o=ge([t[1],t[3],t[5],t[7]]),c=ge([t[2],t[3],t[6],t[7]]),u=ge([t[10],t[11],t[14],t[15]]),l=ge([t[9],t[11],t[13],t[15]]),h=ge([t[9],t[10],t[13],t[14]]),f=ge([t[8],t[11],t[12],t[15]]),p=ge([t[8],t[10],t[12],t[14]]),g=ge([t[8],t[9],t[12],t[13]]);return ve(e,(t[5]*u-t[6]*l+t[7]*h)/n,(-t[1]*u+t[2]*l-t[3]*h)/n,(t[12]*c-t[13]*o+t[14]*a)/n,(-t[9]*c+t[10]*o-t[11]*a)/n,(-t[4]*u+t[6]*f-t[7]*p)/n,(t[0]*u-t[2]*f+t[3]*p)/n,(-t[12]*c+t[14]*s-t[15]*r)/n,(t[8]*c-t[10]*s+t[11]*r)/n,(t[4]*l-t[5]*f+t[7]*g)/n,(-t[0]*l+t[1]*f-t[3]*g)/n,(t[12]*o-t[13]*s+t[15]*i)/n,(-t[8]*o+t[9]*s-t[11]*i)/n,(-t[4]*h+t[5]*p-t[6]*g)/n,(t[0]*h-t[1]*p+t[2]*g)/n,(-t[12]*a+t[13]*r-t[14]*i)/n,(t[8]*a-t[9]*r+t[10]*i)/n)}function vu(t,e,n){return ft(n,t[0]*e,t[1]*e,t[2]*e,t[3]*e)}function wu(t,e,n){return Ke(n,t[0]*e,t[1]*e,t[2]*e,t[3]*e,t[4]*e,t[5]*e,t[6]*e,t[7]*e,t[8]*e)}function Tu(t,e,n){return ve(n,t[0]*e,t[1]*e,t[2]*e,t[3]*e,t[4]*e,t[5]*e,t[6]*e,t[7]*e,t[8]*e,t[9]*e,t[10]*e,t[11]*e,t[12]*e,t[13]*e,t[14]*e,t[15]*e)}function Cr(t){return ft(t,1,0,0,1)}function Xt(t){return Ke(t,1,0,0,0,1,0,0,0,1)}function ue(t){return ve(t,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}function yu(t,e,n){return ft(n,e[Qn]*t[Qn]+e[Xn]*t[Yn],e[Qn]*t[Xn]+e[Xn]*t[qn],e[Yn]*t[Qn]+e[qn]*t[Yn],e[Yn]*t[Xn]+e[qn]*t[qn])}function bu(t,e,n){return Ke(n,e[0]*t[0]+e[1]*t[3]+e[2]*t[6],e[0]*t[1]+e[1]*t[4]+e[2]*t[7],e[0]*t[2]+e[1]*t[5]+e[2]*t[8],e[3]*t[0]+e[4]*t[3]+e[5]*t[6],e[3]*t[1]+e[4]*t[4]+e[5]*t[7],e[3]*t[2]+e[4]*t[5]+e[5]*t[8],e[6]*t[0]+e[7]*t[3]+e[8]*t[6],e[6]*t[1]+e[7]*t[4]+e[8]*t[7],e[6]*t[2]+e[7]*t[5]+e[8]*t[8])}function rt(t,e,n){return n=n||[],n[0]=e[0]*t[0]+e[1]*t[4]+e[2]*t[8]+e[3]*t[12],n[1]=e[0]*t[1]+e[1]*t[5]+e[2]*t[9]+e[3]*t[13],n[2]=e[0]*t[2]+e[1]*t[6]+e[2]*t[10]+e[3]*t[14],n[3]=e[0]*t[3]+e[1]*t[7]+e[2]*t[11]+e[3]*t[15],n[4]=e[4]*t[0]+e[5]*t[4]+e[6]*t[8]+e[7]*t[12],n[5]=e[4]*t[1]+e[5]*t[5]+e[6]*t[9]+e[7]*t[13],n[6]=e[4]*t[2]+e[5]*t[6]+e[6]*t[10]+e[7]*t[14],n[7]=e[4]*t[3]+e[5]*t[7]+e[6]*t[11]+e[7]*t[15],n[8]=e[8]*t[0]+e[9]*t[4]+e[10]*t[8]+e[11]*t[12],n[9]=e[8]*t[1]+e[9]*t[5]+e[10]*t[9]+e[11]*t[13],n[10]=e[8]*t[2]+e[9]*t[6]+e[10]*t[10]+e[11]*t[14],n[11]=e[8]*t[3]+e[9]*t[7]+e[10]*t[11]+e[11]*t[15],n[12]=e[12]*t[0]+e[13]*t[4]+e[14]*t[8]+e[15]*t[12],n[13]=e[12]*t[1]+e[13]*t[5]+e[14]*t[9]+e[15]*t[13],n[14]=e[12]*t[2]+e[13]*t[6]+e[14]*t[10]+e[15]*t[14],n[15]=e[12]*t[3]+e[13]*t[7]+e[14]*t[11]+e[15]*t[15],n}function Eu(t,...e){if(e.length<=0)return ue();if(t=t||ue(),e.length===1)return Gi(e[0],t);let n=e[0],i=Ue[Ue.length-1],r=Ue[Ue.length-2];t===i&&(i=Ue[Ue.length-3]),t===r&&(r=Ue[Ue.length-3]);let s=i;for(let a=1,o=e.length-1;a<o;++a){const c=e[a];n=rt(n,c,s),s=s===i?r:i}return rt(n,e[e.length-1],t)}function _u(t,e,n){return ft(n,t[0]+e[0],t[1]+e[1],t[2]+e[2],t[3]+e[3])}function Ru(t,e,n){return Ke(n,t[0]+e[0],t[1]+e[1],t[2]+e[2],t[3]+e[3],t[4]+e[4],t[5]+e[5],t[6]+e[6],t[7]+e[7],t[8]+e[8])}function xu(t,e,n){return ve(n,t[0]+e[0],t[1]+e[1],t[2]+e[2],t[3]+e[3],t[4]+e[4],t[5]+e[5],t[6]+e[6],t[7]+e[7],t[8]+e[8],t[9]+e[9],t[10]+e[10],t[11]+e[11],t[12]+e[12],t[13]+e[13],t[14]+e[14],t[15]+e[15])}function Au(t,e,n){return ft(n,t[0]-e[0],t[1]-e[1],t[2]-e[2],t[3]-e[3])}function Su(t,e,n){return Ke(n,t[0]-e[0],t[1]-e[1],t[2]-e[2],t[3]-e[3],t[4]-e[4],t[5]-e[5],t[6]-e[6],t[7]-e[7],t[8]-e[8])}function Mu(t,e,n){return ve(n,t[0]-e[0],t[1]-e[1],t[2]-e[2],t[3]-e[3],t[4]-e[4],t[5]-e[5],t[6]-e[6],t[7]-e[7],t[8]-e[8],t[9]-e[9],t[10]-e[10],t[11]-e[11],t[12]-e[12],t[13]-e[13],t[14]-e[14],t[15]-e[15])}function Iu(t,e,n){return ft(n,t[0]*e[0],t[1]*e[1],t[2]*e[2],t[3]*e[3])}function Cu(t,e,n){return Ke(n,t[0]*e[0],t[1]*e[1],t[2]*e[2],t[3]*e[3],t[4]*e[4],t[5]*e[5],t[6]*e[6],t[7]*e[7],t[8]*e[8])}function Lu(t,e,n){return ve(n,t[0]*e[0],t[1]*e[1],t[2]*e[2],t[3]*e[3],t[4]*e[4],t[5]*e[5],t[6]*e[6],t[7]*e[7],t[8]*e[8],t[9]*e[9],t[10]*e[10],t[11]*e[11],t[12]*e[12],t[13]*e[13],t[14]*e[14],t[15]*e[15])}function Ou(t,e){return ft(e,t[0],t[2],t[1],t[3])}function Lr(t,e){return Ke(e,t[0],t[3],t[6],t[1],t[4],t[7],t[2],t[5],t[8])}function Nu(t,e){return ve(e,t[0],t[4],t[8],t[12],t[1],t[5],t[9],t[13],t[2],t[6],t[10],t[14],t[3],t[7],t[11],t[15])}function Pu(t,e){return(t>=Math.PI/2||t<=-Math.PI/2)&&console.warn("A shear matrix can not have radians >= PI / 2 or <= -PI / 2"),e=e||Cr(),ft(e,1,0,Lt(t),1)}function Du(t,e){return(t>=Math.PI/2||t<=-Math.PI/2)&&console.warn("A shear matrix can not have radians >= PI / 2 or <= -PI / 2"),e=e||Cr(),ft(e,1,Lt(t),0,1)}function Fu(t,e,n){(e>=dt||e<=-dt||t>=dt||t<=-dt)&&console.warn("A shear matrix can not have radians >= PI / 2 or <= -PI / 2"),n=n||ue();const i=Lt(e),r=Lt(t);return ve(n,1,0,0,0,r,1,0,0,i,0,1,0,0,0,0,1)}function Bu(t,e,n){(e>=dt||e<=-dt||t>=dt||t<=-dt)&&console.warn("A shear matrix can not have radians >= PI / 2 or <= -PI / 2"),n=n||ue();const i=Lt(e),r=Lt(t);return ve(n,1,r,0,0,0,1,0,0,0,i,1,0,0,0,0,1)}function Uu(t,e,n){(e>=dt||e<=-dt||t>=dt||t<=-dt)&&console.warn("A shear matrix can not have radians >= PI / 2 or <= -PI / 2"),n=n||ue();const i=Lt(e),r=Lt(t);return ve(n,1,0,r,0,0,1,i,0,0,0,1,0,0,0,0,1)}function Gu(t,e,n){return de(n,t[Qn]*e[0]+t[Yn]*e[1],t[Xn]*e[0]+t[qn]*e[1])}function ku(t,e,n){return pe(n,t[br]*e[0]+t[Rr]*e[1]+t[Sr]*e[2],t[Er]*e[0]+t[xr]*e[1]+t[Mr]*e[2],t[_r]*e[0]+t[Ar]*e[1]+t[Ir]*e[2])}function zu(t,e,n){return fe(n,t[Ot]*e[0]+t[Ft]*e[1]+t[kt]*e[2]+t[$t]*1,t[Nt]*e[0]+t[Bt]*e[1]+t[zt]*e[2]+t[jt]*1,t[Pt]*e[0]+t[Ut]*e[1]+t[Vt]*e[2]+t[Ht]*1,t[Dt]*e[0]+t[Gt]*e[1]+t[Wt]*e[2]+t[Qt]*1)}function Or(t,e,n){return fe(n,t[Ot]*e[0]+t[Ft]*e[1]+t[kt]*e[2]+t[$t]*e[3],t[Nt]*e[0]+t[Bt]*e[1]+t[zt]*e[2]+t[jt]*e[3],t[Pt]*e[0]+t[Ut]*e[1]+t[Vt]*e[2]+t[Ht]*e[3],t[Dt]*e[0]+t[Gt]*e[1]+t[Wt]*e[2]+t[Qt]*e[3])}function Vu(t){return`Matrix: [
  ${t[0]}, ${t[1]},
  ${t[2]}, ${t[3]},
]`}function Wu(t){return`Matrix: [
  ${t[0]}, ${t[1]}, ${t[2]},
  ${t[3]}, ${t[4]}, ${t[5]},
  ${t[6]}, ${t[7]}, ${t[8]},
]`}function $u(t){return`Matrix: [
  ${t[0]}, ${t[1]}, ${t[2]}, ${t[3]},
  ${t[4]}, ${t[5]}, ${t[6]}, ${t[7]},
  ${t[8]}, ${t[9]}, ${t[10]}, ${t[11]},
  ${t[12]}, ${t[13]}, ${t[14]}, ${t[15]},
]`}function Yo(t,e){e=e||new Array(4);const n=Math.cos(t),i=Math.sin(t);return e[Qn]=n,e[Xn]=-i,e[Yn]=i,e[qn]=n,e}function qo(t,e,n,i){if(t)if(e)if(n){const r=ut(t),s=ut(e),a=ut(n),o=ht(t),c=ht(e),u=ht(n);return ve(i,s*a,s*u,-c,0,o*c*a-r*u,o*c*u+r*a,o*s,0,r*c*a+o*u,r*c*u-o*a,r*s,0,0,0,0,1)}else{const r=ut(t),s=ut(e),a=ht(t),o=ht(e);return ve(i,s,0,-o,0,a*o,r,a*s,0,r*o,-a,r*s,0,0,0,0,1)}else if(n){const r=ut(t),s=ut(n),a=ht(t),o=ht(n);return ve(i,s,o,0,0,-r*o,r*s,a,0,a*o,-a*s,r,0,0,0,0,1)}else{const r=ut(t),s=ht(t);return ve(i,1,0,0,0,0,r,s,0,0,-s,r,0,0,0,0,1)}else if(e)if(n){const r=ut(e),s=ut(n),a=ht(e),o=ht(n);return ve(i,r*s,r*o,-a,0,-o,s,0,0,a*s,a*o,r,0,0,0,0,1)}else{const r=ut(e),s=ht(e);return ve(i,r,0,-s,0,0,1,0,0,s,0,r,0,0,0,0,1)}else if(n){const r=ut(n),s=ht(n);return ve(i,r,s,0,0,-s,r,0,0,0,0,1,0,0,0,0,1)}else return ue(i)}function ju(t,e){return qo(t[0],t[1],t[2],e)}function Hu(t,e){return Ko(t[0],t[1],t[2],e)}function Ko(t,e,n,i){return ve(i,t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1)}function Qu(t,e){return Zo(t[0],t[1],t[2],e)}function Zo(t,e,n,i){return ve(i,1,0,0,0,0,1,0,0,0,0,1,0,t,e,n,1)}function Ps(t,e,n,i,r,s,a){return a=a||ue(),ve(a,2*t/(i-n),0,0,0,0,2*t/(r-s),0,0,(i+n)/(i-n),(r+s)/(r-s),-(e+t)/(e-t),-1,0,0,-(2*e*t)/(e-t),0)}function Jo(t,e,n,i,r,s){const a=n/e,o=Lt(t/2)*i,c=-o,u=a*o,l=-u;return Ps(i,r,c,o,u,l,s)}function Xu(t,e,n,i,r,s){const a=e/n,o=Lt(t/2)*i,c=-o,u=a*o,l=-u;return Ps(i,r,l,u,o,c,s)}function ec(t,e,n,i,r,s,a){return ve(a,2/(e-t),0,0,0,0,2/(i-n),0,0,0,0,-1/(s-r),0,(e+t)/(t-e),(i+n)/(n-i),-r/(r-s),1)}function tc(t,e,n,i,r){return r=r||[0,0,0,0],Or(t,e,r),fe(r,(r[0]/r[3]+1)*.5*n,(r[1]/r[3]+1)*.5*i,r[2]/r[3],1)}function Ds(t,e,n,i,r){return tc(t,[e[0],e[1],e[2],1],n,i,r)}function Yu(t,e){return Math.abs(t[0]-e[0])<=1e-7&&Math.abs(t[1]-e[1])<=1e-7&&Math.abs(t[2]-e[2])<=1e-7&&Math.abs(t[3]-e[3])<=1e-7}function qu(t,e){return Math.abs(t[0]-e[0])<=1e-7&&Math.abs(t[1]-e[1])<=1e-7&&Math.abs(t[2]-e[2])<=1e-7&&Math.abs(t[3]-e[3])<=1e-7&&Math.abs(t[4]-e[4])<=1e-7&&Math.abs(t[5]-e[5])<=1e-7&&Math.abs(t[6]-e[6])<=1e-7&&Math.abs(t[7]-e[7])<=1e-7&&Math.abs(t[8]-e[8])<=1e-7}function nc(t,e){return Math.abs(t[0]-e[0])<=1e-7&&Math.abs(t[1]-e[1])<=1e-7&&Math.abs(t[2]-e[2])<=1e-7&&Math.abs(t[3]-e[3])<=1e-7&&Math.abs(t[4]-e[4])<=1e-7&&Math.abs(t[5]-e[5])<=1e-7&&Math.abs(t[6]-e[6])<=1e-7&&Math.abs(t[7]-e[7])<=1e-7&&Math.abs(t[8]-e[8])<=1e-7&&Math.abs(t[9]-e[9])<=1e-7&&Math.abs(t[10]-e[10])<=1e-7&&Math.abs(t[11]-e[11])<=1e-7&&Math.abs(t[12]-e[12])<=1e-7&&Math.abs(t[13]-e[13])<=1e-7&&Math.abs(t[14]-e[14])<=1e-7&&Math.abs(t[15]-e[15])<=1e-7}function Ku(t){return[t[0],t[1],t[2],t[3]]}function Zu(t){return[t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8]]}function Gi(t,e){return e?(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e):[t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8],t[9],t[10],t[11],t[12],t[13],t[14],t[15]]}function Nr(t,e,n,i){i=i||[];const[r,s,a]=t,[o,c,u]=n,[l,h,f,p,g,m,T,w,y]=e;i[Ot]=l*r,i[Nt]=h*s,i[Pt]=f*a,i[Dt]=0,i[Ft]=p*r,i[Bt]=g*s,i[Ut]=m*a,i[Gt]=0,i[kt]=T*r,i[zt]=w*s,i[Vt]=y*a,i[Wt]=0,i[$t]=r*(l*o+p*c+T*u),i[jt]=s*(h*o+g*c+w*u),i[Ht]=a*(f*o+m*c+y*u),i[Qt]=1}function Fs(t,e,n,i){i=i||[];const[r,s,a]=t,[o,c,u]=n,[l,h,f,p,g,m,T,w,y]=e;i[Ot]=l*r,i[Nt]=h*r,i[Pt]=f*r,i[Dt]=0,i[Ft]=p*s,i[Bt]=g*s,i[Ut]=m*s,i[Gt]=0,i[kt]=T*a,i[zt]=w*a,i[Vt]=y*a,i[Wt]=0,i[$t]=o,i[jt]=c,i[Ht]=u,i[Qt]=1}function Ju(t,e,n,i){i=i||[];const[r,s]=t,[a,o]=n,[c,u,l,h]=e;i[Ot]=c*r,i[Nt]=u*s,i[Pt]=0,i[Dt]=0,i[Ft]=l*r,i[Bt]=h*s,i[Ut]=0,i[Gt]=0,i[kt]=0,i[zt]=0,i[Vt]=1,i[Wt]=0,i[$t]=r*(c*a+l*o),i[jt]=s*(u*a+h*o),i[Ht]=0,i[Qt]=1}function ic(t,e,n,i){i=i||[];const[r,s]=t,[a,o]=n,[c,u,l,h]=e;i[Ot]=c*r,i[Nt]=u*r,i[Pt]=0,i[Dt]=0,i[Ft]=l*s,i[Bt]=h*s,i[Ut]=0,i[Gt]=0,i[kt]=0,i[zt]=0,i[Vt]=1,i[Wt]=0,i[$t]=a,i[jt]=o,i[Ht]=0,i[Qt]=1}const zp=Object.freeze(Object.defineProperty({__proto__:null,Hadamard2x2:Iu,Hadamard3x3:Cu,Hadamard4x4:Lu,M200:Qn,M201:Xn,M210:Yn,M211:qn,M300:br,M301:Er,M302:_r,M310:Rr,M311:xr,M312:Ar,M320:Sr,M321:Mr,M322:Ir,M3R:vi,M400:Ot,M401:Nt,M402:Pt,M403:Dt,M410:Ft,M411:Bt,M412:Ut,M413:Gt,M420:kt,M421:zt,M422:Vt,M423:Wt,M430:$t,M431:jt,M432:Ht,M433:Qt,M4R:Ue,SRT4x4:Fs,SRT4x4_2D:ic,TRS4x4:Nr,TRS4x4_2D:Ju,add2x2:_u,add3x3:Ru,add4x4:xu,affineInverse2x2:pu,affineInverse3x3:gu,affineInverse4x4:mu,apply2x2:ft,apply3x3:Ke,apply4x4:ve,compare2x2:Yu,compare3x3:qu,compare4x4:nc,concat4x4:Eu,copy2x2:Ku,copy3x3:Zu,copy4x4:Gi,determinant2x2:ge,determinant3x3:wi,determinant4x4:Xo,identity2:Cr,identity3:Xt,identity4:ue,multiply2x2:yu,multiply3x3:bu,multiply4x4:rt,multiplyScalar2x2:vu,multiplyScalar3x3:wu,multiplyScalar4x4:Tu,orthographic4x4:ec,perspective4x4:Jo,perspectiveFOVY4x4:Xu,perspectiveFrustum4x4:Ps,project3As4ToScreen:Ds,projectToScreen:tc,rotation2x2:Yo,rotation4x4:qo,rotation4x4by3:ju,scale4x4:Ko,scale4x4by3:Hu,shearX2x2:Pu,shearX4x4:Fu,shearY2x2:Du,shearY4x4:Bu,shearZ4x4:Uu,subtract2x2:Au,subtract3x3:Su,subtract4x4:Mu,toString2x2:Vu,toString3x3:Wu,toString4x4:$u,transform2:Gu,transform3:ku,transform3as4:zu,transform4:Or,translation4x4:Zo,translation4x4by3:Qu,transpose2x2:Ou,transpose3x3:Lr,transpose4x4:Nu},Symbol.toStringTag,{value:"Module"}));function rc(t,e){return!t||!e?t===e:!Object.keys(Object.assign({},t,e)).find(n=>t[n]!==e[n])}const{min:Vp,max:Wp,pow:eh,round:$p,sin:Pr,PI:ki}=Math,Dr=$p(ki*1e3)/1e3;function Z(t,e,n){return Vp(Wp(t,e),n)}var Yt=(t=>(t[t.NONE=1]="NONE",t[t.CONTINUOUS=4]="CONTINUOUS",t[t.REPEAT=2]="REPEAT",t[t.REFLECT=3]="REFLECT",t))(Yt||{});const jp=`
\${easingMethod} {
  return end;
}
`,Hp=`
\${easingMethod} {
  return (end - start) * t + start;
}
`,Qp=`
\${easingMethod} {
  float time = t * t;
  return (end - start) * time + start;
}
`,Xp=`
\${easingMethod} {
  float time = t * (2.0 - t);
  return (end - start) * time + start;
}
`,Yp=`
\${easingMethod} {
  float time = t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;
  return (end - start) * time + start;
}
`,qp=`
\${easingMethod} {
  float time = t * t * t;
  return (end - start) * time + start;
}
`,Kp=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = t1 * t1 * t1 + 1.0;
  return (end - start) * time + start;
}
`,Zp=`
\${easingMethod} {
  float time = t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0;
  return (end - start) * time + start;
}
`,Jp=`
\${easingMethod} {
  float time = t * t * t * t;
  return (end - start) * time + start;
}
`,eg=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = 1.0 - t1 * t1 * t1 * t1;
  return (end - start) * time + start;
}
`,tg=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = t < 0.5 ? 8.0 * t * t * t * t : 1.0 - 8.0 * t1 * t1 * t1 * t1;
  return (end - start) * time + start;
}
`,ng=`
\${easingMethod} {
  float time = t * t * t * t * t;
  return (end - start) * time + start;
}
`,ig=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = 1.0 + t1 * t1 * t1 * t1 * t1;
  return (end - start) * time + start;
}
`,rg=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = t < 0.5 ? 16.0 * t * t * t * t * t : 1.0 + 16.0 * t1 * t1 * t1 * t1 * t1;
  return (end - start) * time + start;
}
`,sg=`
\${easingMethod} {
  float p = 0.3;
  float time = pow(2.0, -10.0 * t) * sin((t - p / 4.0) * (2.0 * ${Dr}) / p) + 1.0;
  return (end - start) * time + start;
}
`,ag=`
\${easingMethod} {
  float time = t * t * t - t * 1.05 * sin(t * ${Dr});
  return (end - start) * time + start;
}
`,og=`
\${easingMethod} {
  float t1 = t - 1.0;
  float a = 1.7;
  float time = (t1 * t1 * ((a + 1.0) * t1 + a) + 1.0);
  return (end - start) * time + start;
}
`,cg=`
\${easingMethod} {
  float a = 1.4;
  float a1 = a * 1.525;
  float t1 = t / 0.5;
  float t2 = t1 - 2.0;
  float time =
    (t1 < 1.0) ? 0.5 * (t1 * t1 * (a1 + 1.0) * t1 - a1) :
    0.5 * (t2 * t2 * ((a1 + 1.0) * t2 + a1) + 2.0)
  ;

  return (end - start) * time + start;
}
`,lg=`
\${easingMethod} {
  \${T} direction = end - start;
  return start + direction * 0.5 + direction * sin(t * ${Dr} * 2.0) * 0.5;
}
`,ug=`
\${easingMethod} {
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - t, t),
    vec2(sin((1.0 - t) * omega) / sinom, sin(t * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,hg=`
\${easingMethod} {
  float time = t * t;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,dg=`
\${easingMethod} {
  float time = t * (2.0 - t);
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,fg=`
\${easingMethod} {
  float time = t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,pg=`
\${easingMethod} {
  float time = t * t * t;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,gg=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = t1 * t1 * t1 + 1.0;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,mg=`
\${easingMethod} {
  float time = t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,vg=`
\${easingMethod} {
  float time = t * t * t * t;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,wg=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = 1.0 - t1 * t1 * t1 * t1;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,Tg=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = t < 0.5 ? 8.0 * t * t * t * t : 1.0 - 8.0 * t1 * t1 * t1 * t1;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,yg=`
\${easingMethod} {
  float time = t * t * t * t * t;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,bg=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = 1.0 + t1 * t1 * t1 * t1 * t1;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,Eg=`
\${easingMethod} {
  float t1 = t - 1.0;
  float time = t < 0.5 ? 16.0 * t * t * t * t * t : 1.0 + 16.0 * t1 * t1 * t1 * t1 * t1;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,_g=`
\${easingMethod} {
  float p = 0.3;
  float time = pow(2.0, -10.0 * t) * sin((t - p / 4.0) * (2.0 * ${Dr}) / p) + 1.0;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,Rg=`
\${easingMethod} {
  float time = t * t * t - t * 1.05 * sin(t * ${Dr});
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,xg=`
\${easingMethod} {
  float t1 = t - 1.0;
  float a = 1.7;
  float time = (t1 * t1 * ((a + 1.0) * t1 + a) + 1.0);
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`,Ag=`
\${easingMethod} {
  float a = 1.4;
  float a1 = a * 1.525;
  float t1 = t / 0.5;
  float t2 = t1 - 2.0;
  float time =
    (t1 < 1.0) ? 0.5 * (t1 * t1 * (a1 + 1.0) * t1 - a1) :
    0.5 * (t2 * t2 * ((a1 + 1.0) * t2 + a1) + 2.0)
  ;
  float cosom = dot(start, end);
  \${T} end1 = mix(end, -end, float(cosom < 0.0));
  cosom = mix(cosom, -cosom, float(cosom < 0.0));

  float omega = acos(cosom);
  float sinom = sin(omega);

  vec2 scale = mix(
    vec2(1.0 - time, time),
    vec2(sin((1.0 - time) * omega) / sinom, sin(time * omega) / sinom),
    float(1.0 - cosom > 0.0000001)
  );

  return scale.x * start + scale.y * end1;
}
`;class Bs{constructor(e,n,i,r){this.uid=G(),this.delay=0,this.duration=500,this.loop=1,this.cpu=e,this.gpu=n,this.duration=i||500,this.methodName=r||"easingMethod"}static immediate(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{const{copy:c}=B(r);return c(s,o)},delay:n,duration:e,gpu:jp,loop:i,methodName:"immediate"}}static linear(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{const{add:c,scale:u,subtract:l}=B(r);return a=Z(a,0,1),c(u(l(s,r),a),r,o)},delay:n,duration:e,gpu:Hp,loop:i,methodName:"linear"}}static easeInQuad(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{a=Z(a,0,1);const c=a*a,{add:u,scale:l,subtract:h}=B(r);return u(l(h(s,r),c),r,o)},delay:n,duration:e,gpu:Qp,loop:i,methodName:"easeInQuad"}}static easeOutQuad(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{a=Z(a,0,1);const c=a*(2-a),{add:u,scale:l,subtract:h}=B(r);return u(l(h(s,r),c),r,o)},delay:n,duration:e,gpu:Xp,loop:i,methodName:"easeOutQuad"}}static easeInOutQuad(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{a=Z(a,0,1);const c=a<.5?2*a*a:-1+(4-2*a)*a,{add:u,scale:l,subtract:h}=B(r);return u(l(h(s,r),c),r,o)},delay:n,duration:e,gpu:Yp,loop:i,methodName:"easeInOutQuad"}}static easeInCubic(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{a=Z(a,0,1);const c=a*a*a,{add:u,scale:l,subtract:h}=B(r);return u(l(h(s,r),c),r,o)},delay:n,duration:e,gpu:qp,loop:i,methodName:"easeInCubic"}}static easeOutCubic(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{a=Z(a,0,1);const c=--a*a*a+1,{add:u,scale:l,subtract:h}=B(r);return u(l(h(s,r),c),r,o)},delay:n,duration:e,gpu:Kp,loop:i,methodName:"easeOutCubic"}}static easeInOutCubic(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{a=Z(a,0,1);const c=a<.5?4*a*a*a:(a-1)*(2*a-2)*(2*a-2)+1,{add:u,scale:l,subtract:h}=B(r);return u(l(h(s,r),c),r,o)},delay:n,duration:e,gpu:Zp,loop:i,methodName:"easeInOutCubic"}}static easeInQuart(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{a=Z(a,0,1);const c=a*a*a*a,{add:u,scale:l,subtract:h}=B(r);return u(l(h(s,r),c),r,o)},delay:n,duration:e,gpu:Jp,loop:i,methodName:"easeInQuart"}}static easeOutQuart(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{a=Z(a,0,1);const c=1- --a*a*a*a,{add:u,scale:l,subtract:h}=B(r);return u(l(h(s,r),c),r,o)},delay:n,duration:e,gpu:eg,loop:i,methodName:"easeOutQuart"}}static easeInOutQuart(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{a=Z(a,0,1);const c=a<.5?8*a*a*a*a:1-8*--a*a*a*a,{add:u,scale:l,subtract:h}=B(r);return u(l(h(s,r),c),r,o)},delay:n,duration:e,gpu:tg,loop:i,methodName:"easeInOutQuart"}}static easeInQuint(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{a=Z(a,0,1);const c=a*a*a*a*a,{add:u,scale:l,subtract:h}=B(r);return u(l(h(s,r),c),r,o)},delay:n,duration:e,gpu:ng,loop:i,methodName:"easeInQuint"}}static easeOutQuint(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{a=Z(a,0,1);const c=1+--a*a*a*a*a,{add:u,scale:l,subtract:h}=B(r);return u(l(h(s,r),c),r,o)},delay:n,duration:e,gpu:ig,loop:i,methodName:"easeOutQuint"}}static easeInOutQuint(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{a=Z(a,0,1);const c=a<.5?16*a*a*a*a*a:1+16*--a*a*a*a*a,{add:u,scale:l,subtract:h}=B(r);return u(l(h(s,r),c),r,o)},delay:n,duration:e,gpu:rg,loop:i,methodName:"easeInOutQuint"}}static easeOutElastic(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{a=Z(a,0,1);const c=.3,u=eh(2,-10*a)*Pr((a-c/4)*(2*ki)/c)+1,{add:l,scale:h,subtract:f}=B(r);return l(h(f(s,r),u),r,o)},delay:n,duration:e,gpu:sg,loop:i,methodName:"easeOutElastic"}}static easeBackIn(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{a=Z(a,0,1);const c=1.05,u=a*a*a-a*c*Pr(a*ki),{add:l,scale:h,subtract:f}=B(r);return l(h(f(s,r),u),r,o)},delay:n,duration:e,gpu:ag,loop:i,methodName:"easeBackIn"}}static easeBackOut(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{a=Z(a,0,1);const c=1.7,u=a-1,l=u*u*((c+1)*u+c)+1,{add:h,scale:f,subtract:p}=B(r);return h(f(p(s,r),l),r,o)},delay:n,duration:e,gpu:og,loop:i,methodName:"easeBackOut"}}static easeBackInOut(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{a=Z(a,0,1);const u=1.7*1.525,l=a/.5,h=l-2,f=l<1?.5*(l*l*(u+1)*l-u):.5*(h*h*((u+1)*h+u)+2),{add:p,scale:g,subtract:m}=B(r);return p(g(m(s,r),f),r,o)},delay:n,duration:e,gpu:cg,loop:i,methodName:"easeBackInOut"}}static continuousSinusoidal(e,n=0,i=4){return{uid:G(),cpu:(r,s,a,o)=>{const{add:c,scale:u,subtract:l}=B(r);a=Z(a,0,1);const h=l(s,r),f=u(h,.5);return c(c(r,f),u(f,Pr(a*ki*2)*1),o)},delay:n,duration:e,gpu:lg,loop:i,methodName:"repeatingSinusoidal",validation:{ignoreEndValueCheck:!0,ignoreOverTimeCheck:!0}}}static slerpQuatLinear(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{if(!U(r)||!U(s)||!U(o)){const{vec:l}=B(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),l(1,0,0,0)}a=Z(a,0,1);const{slerpQuat:c,vec:u}=B(r);return c?c(r,s,a,o):u(1,0,0,0)},delay:n,duration:e,gpu:ug,loop:i,methodName:"slerpQuatLinear"}}static slerpQuatInQuad(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{if(!U(r)||!U(s)||!U(o)){const{vec:h}=B(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),h(1,0,0,0)}a=Z(a,0,1);const c=a*a,{slerpQuat:u,vec:l}=B(r);return u?u(r,s,c,o):l(1,0,0,0)},delay:n,duration:e,gpu:hg,loop:i,methodName:"slerpQuatInQuad"}}static slerpQuatOutQuad(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{if(!U(r)||!U(s)||!U(o)){const{vec:h}=B(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),h(1,0,0,0)}a=Z(a,0,1);const c=a*(2-a),{slerpQuat:u,vec:l}=B(r);return u?u(r,s,c,o):l(1,0,0,0)},delay:n,duration:e,gpu:dg,loop:i,methodName:"slerpQuatOutQuad"}}static slerpQuatInOutQuad(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{if(!U(r)||!U(s)||!U(o)){const{vec:h}=B(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),h(1,0,0,0)}a=Z(a,0,1);const c=a<.5?2*a*a:-1+(4-2*a)*a,{slerpQuat:u,vec:l}=B(r);return u?u(r,s,c,o):l(1,0,0,0)},delay:n,duration:e,gpu:fg,loop:i,methodName:"slerpQuatInOutQuad"}}static slerpQuatInCubic(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{if(!U(r)||!U(s)||!U(o)){const{vec:h}=B(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),h(1,0,0,0)}a=Z(a,0,1);const c=a*a*a,{slerpQuat:u,vec:l}=B(r);return u?u(r,s,c,o):l(1,0,0,0)},delay:n,duration:e,gpu:pg,loop:i,methodName:"slerpQuatInCubic"}}static slerpQuatOutCubic(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{if(!U(r)||!U(s)||!U(o)){const{vec:h}=B(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),h(1,0,0,0)}a=Z(a,0,1);const c=--a*a*a+1,{slerpQuat:u,vec:l}=B(r);return u?u(r,s,c,o):l(1,0,0,0)},delay:n,duration:e,gpu:gg,loop:i,methodName:"slerpQuatOutCubic"}}static slerpQuatInOutCubic(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{if(!U(r)||!U(s)||!U(o)){const{vec:h}=B(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),h(1,0,0,0)}a=Z(a,0,1);const c=a<.5?4*a*a*a:(a-1)*(2*a-2)*(2*a-2)+1,{slerpQuat:u,vec:l}=B(r);return u?u(r,s,c,o):l(1,0,0,0)},delay:n,duration:e,gpu:mg,loop:i,methodName:"slerpQuatInOutCubic"}}static slerpQuatInQuart(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{if(!U(r)||!U(s)||!U(o)){const{vec:h}=B(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),h(1,0,0,0)}a=Z(a,0,1);const c=a*a*a*a,{slerpQuat:u,vec:l}=B(r);return u?u(r,s,c,o):l(1,0,0,0)},delay:n,duration:e,gpu:vg,loop:i,methodName:"slerpQuatInQuart"}}static slerpQuatOutQuart(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{if(!U(r)||!U(s)||!U(o)){const{vec:h}=B(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),h(1,0,0,0)}a=Z(a,0,1);const c=1- --a*a*a*a,{slerpQuat:u,vec:l}=B(r);return u?u(r,s,c,o):l(1,0,0,0)},delay:n,duration:e,gpu:wg,loop:i,methodName:"slerpQuatOutQuart"}}static slerpQuatInOutQuart(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{if(!U(r)||!U(s)||!U(o)){const{vec:h}=B(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),h(1,0,0,0)}a=Z(a,0,1);const c=a<.5?8*a*a*a*a:1-8*--a*a*a*a,{slerpQuat:u,vec:l}=B(r);return u?u(r,s,c,o):l(1,0,0,0)},delay:n,duration:e,gpu:Tg,loop:i,methodName:"slerpQuatInOutQuart"}}static slerpQuatInQuint(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{if(!U(r)||!U(s)||!U(o)){const{vec:h}=B(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),h(1,0,0,0)}a=Z(a,0,1);const c=a*a*a*a*a,{slerpQuat:u,vec:l}=B(r);return u?u(r,s,c,o):l(1,0,0,0)},delay:n,duration:e,gpu:yg,loop:i,methodName:"slerpQuatInQuint"}}static slerpQuatOutQuint(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{if(!U(r)||!U(s)||!U(o)){const{vec:h}=B(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),h(1,0,0,0)}a=Z(a,0,1);const c=1+--a*a*a*a*a,{slerpQuat:u,vec:l}=B(r);return u?u(r,s,c,o):l(1,0,0,0)},delay:n,duration:e,gpu:bg,loop:i,methodName:"slerpQuatOutQuint"}}static slerpQuatInOutQuint(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{if(!U(r)||!U(s)||!U(o)){const{vec:h}=B(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),h(1,0,0,0)}a=Z(a,0,1);const c=a<.5?16*a*a*a*a*a:1+16*--a*a*a*a*a,{slerpQuat:u,vec:l}=B(r);return u?u(r,s,c,o):l(1,0,0,0)},delay:n,duration:e,gpu:Eg,loop:i,methodName:"slerpQuatInOutQuint"}}static slerpQuatOutElastic(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{if(!U(r)||!U(s)||!U(o)){const{vec:f}=B(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),f(1,0,0,0)}a=Z(a,0,1);const c=.3,u=eh(2,-10*a)*Pr((a-c/4)*(2*ki)/c)+1,{slerpQuat:l,vec:h}=B(r);return l?l(r,s,u,o):h(1,0,0,0)},delay:n,duration:e,gpu:_g,loop:i,methodName:"slerpQuatOutElastic"}}static slerpQuatBackIn(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{if(!U(r)||!U(s)||!U(o)){const{vec:f}=B(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),f(1,0,0,0)}a=Z(a,0,1);const c=1.05,u=a*a*a-a*c*Pr(a*ki),{slerpQuat:l,vec:h}=B(r);return l?l(r,s,u,o):h(1,0,0,0)},delay:n,duration:e,gpu:Rg,loop:i,methodName:"slerpQuatBackIn"}}static slerpQuatBackOut(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{if(!U(r)||!U(s)||!U(o)){const{vec:p}=B(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),p(1,0,0,0)}a=Z(a,0,1);const c=1.7,u=a-1,l=u*u*((c+1)*u+c)+1,{slerpQuat:h,vec:f}=B(r);return h?h(r,s,l,o):f(1,0,0,0)},delay:n,duration:e,gpu:xg,loop:i,methodName:"slerpQuatBackOut"}}static slerpQuatBackInOut(e,n=0,i=1){return{uid:G(),cpu:(r,s,a,o)=>{if(!U(r)||!U(s)||!U(o)){const{vec:m}=B(s);return console.warn("SLERP QUAT AutoEasingMethod was specified on a non Vec4/Quaternion type which is invalid. This AutoEasingMethod will ONLY work on tuples that have 4 or more elements."),m(1,0,0,0)}a=Z(a,0,1);const u=1.7*1.525,l=a/.5,h=l-2,f=l<1?.5*(l*l*(u+1)*l-u):.5*(h*h*((u+1)*h+u)+2),{slerpQuat:p,vec:g}=B(r);return p?p(r,s,f,o):g(1,0,0,0)},delay:n,duration:e,gpu:Ag,loop:i,methodName:"slerpQuatBackInOut"}}}const{cos:Fr,sin:Kn,sqrt:st,exp:th,acos:sc,atan2:nh,PI:ih}=Math;let Ze,qt,Kt,Zt,Oe,Ge,zi,Jt,Je,Ae,Vi,Us,Gs,Zn,F,vt,ks,Wi;const rh=we(),sh=we(),ah=we(),oh=we(),ch=1,lh=2,uh=3,hh=0;function et(t,e,n){return t>n?n:t<e?e:t}function we(t){return t?(t[0]=0,t[1]=0,t[2]=0,t[3]=0,t):[0,0,0,0]}function dh(t,e,n){return n=n||we(),n[0]=t[0]+e[0],n[1]=t[1]+e[1],n[2]=t[2]+e[2],n[3]=t[3]+e[3],n}function ac(t,e,n){n=n||we();const i=t[0],r=e[0],s=t[1],a=e[1],o=t[2],c=e[2],u=t[3],l=e[3];return n[0]=i*r-s*a-o*c-u*l,n[1]=i*a+s*r+o*l-u*c,n[2]=i*c-s*l+o*r+u*a,n[3]=i*l+s*c-o*a+u*r,n}function fh(t,e,n){n=n||we();const i=t[0],r=t[1],s=t[2],a=t[3],o=e[0],c=e[1],u=e[2],l=e[3],h=o*o+c*c+u*u+l*l;if(h===0)n[0]=0,n[1]=0,n[2]=0,n[3]=0;else{const f=1/h;n[0]=(i*o+r*c+s*u+a*l)*f,n[1]=(r*o-i*c-s*l+a*u)*f,n[2]=(s*o-i*u-a*c+r*l)*f,n[3]=(a*o-i*l-r*u+s*c)*f}return n}function ph(t,e){e=e||we();const n=t[0],i=t[1],r=t[2],s=t[3],a=st(i*i+r*r+s*s),o=th(n),c=o/a*Kn(a);return a===0?(e[0]=th(n),e[1]=0,e[2]=0,e[3]=0):(e[0]=o*Fr(a),e[1]=i*c,e[2]=r*c,e[3]=s*c),e}function oc(t,e,n){return n=n||we(),n[0]=t[0]*e,n[1]=t[1]*e,n[2]=t[2]*e,n[3]=t[3]*e,n}function gh(t,e,n){return n=n||we(),ac(e,cc(t),n)}function cc(t,e){return e=e||we(),e[0]=t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e}function mh(t,e){e=e||we();const n=t[0],i=t[1],r=t[2],s=t[3],a=n*n+i*i+r*r+s*s;if(a===0)e[0]=0,e[1]=0,e[2]=0,e[3]=0;else{const o=1/a;e[0]=n*o,e[1]=-i*o,e[2]=-r*o,e[3]=-s*o}return e}function lc(t){const e=t[0],n=t[1],i=t[2],r=t[3];return st(e*e+n*n+i*i+r*r)}function vh(t,e){e=e||we();const n=lc(t);if(n===0)return[0,0,0,0];const i=1/n;return oc(t,i,e)}function wh(t){return t[0]}function Th(t){return[t[1],t[2],t[3]]}function yh(t,e){return Ts(t,e)}function bh(t,e,n){n=n||we();const i=t[0],r=t[1],s=t[2],a=1/st(i*i+r*r+s*s),o=Kn(e/2);return n[0]=Fr(e/2),n[1]=o*i*a,n[2]=o*r*a,n[3]=o*s*a,n}function uc(t,e,n){n=n||we();const i=t[0],r=t[1],s=t[2],a=Math.cos,o=Math.sin,c=a(i/2),u=a(r/2),l=a(s/2),h=o(i/2),f=o(r/2),p=o(s/2);switch(e){case se.xyz:n[1]=h*u*l+c*f*p,n[2]=c*f*l-h*u*p,n[3]=c*u*p+h*f*l,n[0]=c*u*l-h*f*p;break;case se.yxz:n[0]=c*u*l+h*f*p,n[1]=h*u*l+c*f*p,n[2]=c*f*l-h*u*p,n[3]=c*u*p-h*f*l;break;case se.zxy:n[0]=c*u*l-h*f*p,n[1]=h*u*l-c*f*p,n[2]=c*f*l+h*u*p,n[3]=c*u*p+h*f*l;break;case se.zyx:n[0]=c*u*l+h*f*p,n[1]=h*u*l-c*f*p,n[2]=c*f*l+h*u*p,n[3]=c*u*p-h*f*l;break;case se.yzx:n[0]=c*u*l-h*f*p,n[1]=h*u*l+c*f*p,n[2]=c*f*l+h*u*p,n[3]=c*u*p-h*f*l;break;case se.xzy:n[0]=c*u*l+h*f*p,n[1]=h*u*l-c*f*p,n[2]=c*f*l-h*u*p,n[3]=c*u*p+h*f*l;break}return n}function Eh(t,e,n){n=n||[0,0,0];const i=uc(t,e);return zs(i,se.xyz,n),n}function $i(t,e,n,i,r,s){s[0]=nh(t,e),s[1]=sc(n),s[2]=nh(i,r)}function _h(t,e){return zs(t,se.zyx,e)}function zs(t,e,n){n=n||[0,0,0];const i=t[0],r=t[1],s=t[2],a=t[3],o=Ws(t),c=o[0],u=o[4],l=o[8],h=o[1],f=o[5],p=o[9],g=o[2],m=o[6],T=o[10];switch(e){case se.zyx:n[1]=Math.asin(-et(g,-1,1)),Math.abs(g)<.99999?(n[0]=Math.atan2(m,T),n[2]=Math.atan2(h,c)):(n[0]=0,n[2]=Math.atan2(-u,f));break;case se.zyz:$i(2*s*a+2*i*r,2*i*s-2*r*a,a*a-s*s-r*r+i*i,2*s*a-2*i*r,2*r*a+2*i*s,n);break;case se.zxy:n[0]=Math.asin(et(m,-1,1)),Math.abs(m)<.99999?(n[1]=Math.atan2(-g,T),n[2]=Math.atan2(-u,f)):(n[1]=0,n[2]=Math.atan2(h,c));break;case se.zxz:$i(2*r*a-2*i*s,2*s*a+2*i*r,a*a-s*s-r*r+i*i,2*r*a+2*i*s,2*i*r-2*s*a,n);break;case se.yxz:n[0]=Math.asin(-et(p,-1,1)),Math.abs(p)<.9999?(n[1]=Math.atan2(l,T),n[2]=Math.atan2(h,f)):(n[1]=Math.atan2(-g,c),n[2]=0);break;case se.yxy:$i(2*r*s+2*i*a,2*i*r-2*s*a,s*s-a*a+i*i-r*r,2*r*s-2*i*a,2*s*a+2*i*r,n);break;case se.yzx:n[2]=Math.asin(et(h,-1,1)),Math.abs(h)<.99999?(n[0]=Math.atan2(-p,f),n[1]=Math.atan2(-g,c)):(n[0]=0,n[1]=Math.atan2(l,T));break;case se.yzy:$i(2*s*a-2*i*r,2*r*s+2*i*a,s*s-a*a+i*i-r*r,2*s*a+2*i*r,2*i*a-2*r*s,n);break;case se.xyz:n[1]=Math.asin(et(l,-1,1)),Math.abs(l)<.99999?(n[0]=Math.atan2(-p,T),n[2]=Math.atan2(-u,c)):(n[0]=Math.atan2(m,f),n[2]=0);break;case se.xyx:$i(2*r*s-2*i*a,2*r*a+2*i*s,r*r+i*i-a*a-s*s,2*r*s+2*i*a,2*i*s-2*r*a,n);break;case se.xzy:n[2]=Math.asin(-et(u,-1,1)),Math.abs(u)<.99999?(n[0]=Math.atan2(m,f),n[1]=Math.atan2(l,c)):(n[0]=Math.atan2(-p,T),n[1]=0);break;case se.xzx:$i(2*r*a+2*i*s,2*i*a-2*r*s,r*r+i*i-a*a-s*s,2*r*a-2*i*s,2*r*s+2*i*a,n);break;default:console.warn("Invalid Euler rotation order.");break}return n}function Rh(t,e,n){n=n||[0,0,0];const i=Ws(t),r=i[0],s=i[4],a=i[8],o=i[1],c=i[5],u=i[9],l=i[2],h=i[6],f=i[10];switch(e){case se.xyz:n[1]=Math.asin(et(a,-1,1)),Math.abs(a)<.99999?(n[0]=Math.atan2(-u,f),n[2]=Math.atan2(-s,r)):(n[0]=Math.atan2(h,c),n[2]=0);break;case se.yxz:n[0]=Math.asin(-et(u,-1,1)),Math.abs(u)<.9999?(n[1]=Math.atan2(a,f),n[2]=Math.atan2(o,c)):(n[1]=Math.atan2(-l,r),n[2]=0);break;case se.zxy:n[0]=Math.asin(et(h,-1,1)),Math.abs(h)<.99999?(n[1]=Math.atan2(-l,f),n[2]=Math.atan2(-s,c)):(n[1]=0,n[2]=Math.atan2(o,r));break;case se.zyx:n[1]=Math.asin(-et(l,-1,1)),Math.abs(l)<.99999?(n[0]=Math.atan2(h,f),n[2]=Math.atan2(o,r)):(n[0]=0,n[2]=Math.atan2(-s,c));break;case se.yzx:n[2]=Math.asin(et(o,-1,1)),Math.abs(o)<.99999?(n[0]=Math.atan2(-u,c),n[1]=Math.atan2(-l,r)):(n[0]=0,n[1]=Math.atan2(a,f));break;case se.xzy:n[2]=Math.asin(-et(s,-1,1)),Math.abs(s)<.99999?(n[0]=Math.atan2(h,c),n[1]=Math.atan2(a,r)):(n[0]=Math.atan2(-u,f),n[1]=0);break}}function xh(t){const e=t[0];if(e<-1||e>1)return 0;const n=2*sc(e);return n>ih?n-2*ih:n}function Ah(t){const e=t[1],n=t[2],i=t[3];if(st(e*e+n*n+i*i)===0)return[0,0,0];const s=1/st(e*e+n*n+i*i);return[e*s,n*s,i*s]}function Vs(t,e){e=e||Xt();const n=t[1]+t[1],i=t[2]+t[2],r=t[3]+t[3],s=t[1]*n,a=t[1]*i,o=t[1]*r,c=t[2]*i,u=t[2]*r,l=t[3]*r,h=t[0]*n,f=t[0]*i,p=t[0]*r;return e[br]=1-(c+l),e[Er]=a-p,e[_r]=o+f,e[Rr]=a+p,e[xr]=1-(s+l),e[Ar]=u-h,e[Sr]=o-f,e[Mr]=u+h,e[Ir]=1-(s+c),e}function Sh(t,e){e=e||ue();const n=t[1]+t[1],i=t[2]+t[2],r=t[3]+t[3],s=t[1]*n,a=t[1]*i,o=t[1]*r,c=t[2]*i,u=t[2]*r,l=t[3]*r,h=t[0]*n,f=t[0]*i,p=t[0]*r;return e[Ot]=1-(c+l),e[Nt]=a-p,e[Pt]=o+f,e[Dt]=0,e[Ft]=a+p,e[Bt]=1-(s+l),e[Ut]=u-h,e[Gt]=0,e[kt]=o-f,e[zt]=u+h,e[Vt]=1-(s+c),e[Wt]=0,e[$t]=0,e[jt]=0,e[Ht]=0,e[Qt]=1,e}function Mh(t,e){e=e||Xt();const n=t[1]+t[1],i=t[2]+t[2],r=t[3]+t[3],s=t[1]*n,a=t[1]*i,o=t[1]*r,c=t[2]*i,u=t[2]*r,l=t[3]*r,h=t[0]*n,f=t[0]*i,p=t[0]*r;return e[br]=1-(c+l),e[Rr]=a-p,e[Sr]=o+f,e[Er]=a+p,e[xr]=1-(s+l),e[Mr]=u-h,e[_r]=o-f,e[Ar]=u+h,e[Ir]=1-(s+c),e}function Ws(t,e){e=e||ue();const n=t[1]+t[1],i=t[2]+t[2],r=t[3]+t[3],s=t[1]*n,a=t[1]*i,o=t[1]*r,c=t[2]*i,u=t[2]*r,l=t[3]*r,h=t[0]*n,f=t[0]*i,p=t[0]*r;return e[Ot]=1-(c+l),e[Ft]=a-p,e[kt]=o+f,e[$t]=0,e[Nt]=a+p,e[Bt]=1-(s+l),e[zt]=u-h,e[jt]=0,e[Pt]=o-f,e[Ut]=u+h,e[Vt]=1-(s+c),e[Ht]=0,e[Dt]=0,e[Gt]=0,e[Wt]=0,e[Qt]=1,e}function Ih(t,e){e=e||we();const[n,i,r]=t,s=Fr(n/2),a=Fr(i/2),o=Fr(r/2),c=Kn(n/2),u=Kn(i/2),l=Kn(r/2),h=a*o,f=u*l,p=a*l,g=u*o;return e[0]=s*h+c*f,e[1]=c*h-s*f,e[2]=s*g+c*p,e[3]=s*p-c*g,e}function hc(t,e,n){return n=n||we(),Wi=ct([-t[0],-t[1],-t[2]],$e[$e.length-1]),vt=ct(Ye(e,Wi,$e[$e.length-2])),ks=Ye(Wi,vt,$e[$e.length-3]),Oe=vt[0],Ge=ks[0],zi=Wi[0],Je=vt[1],Ae=ks[1],Vi=Wi[1],Us=vt[2],Gs=ks[2],Zn=Wi[2],F=(1+Oe+Ae+Zn)*.25,F>0?(F=Math.sqrt(F),n[0]=F,F=1/(4*F),n[1]=(Vi-Gs)*F,n[2]=(Us-zi)*F,n[3]=(Ge-Je)*F):(n[0]=0,F=-.5*(Ae+Zn),F>0?(F=Math.sqrt(F),n[1]=F,F*=2,n[2]=Ge/F,n[3]=zi/F):(n[1]=0,F=.5*(1-Zn),F>0?(F=Math.sqrt(F),n[2]=F,n[3]=Vi/(2*F)):(n[2]=0,n[3]=1))),n}function Ch(t,e){if(e=e||we(),Ze=t[0],qt=t[3],Kt=t[6],Zt=t[1],Oe=t[4],Ge=t[7],Jt=t[2],Je=t[5],Ae=t[8],F=Ze+Oe+Ae,F>0){const i=st(F+1)*2;return e[0]=.25*i,e[1]=(Je-Ge)/i,e[2]=(Kt-Jt)/i,e[3]=(Zt-qt)/i,e}if(Ze>Oe&&Ze>Ae){const i=st(1+Ze-Oe-Ae)*2;return e[0]=(Je-Ge)/i,e[1]=.25*i,e[2]=(qt+Zt)/i,e[3]=(Kt+Jt)/i,e}if(Oe>Ae){const i=st(1+Oe-Ze-Ae)*2;return e[0]=(Kt-Jt)/i,e[1]=(Zt+qt)/i,e[2]=.25*i,e[3]=(Je+Ge)/i,e}const n=st(1+Ae-Ze-Oe)*2;return e[0]=(Zt-qt)/n,e[1]=(Jt+Kt)/n,e[2]=(Je+Ge)/n,e[3]=.25*n,e}function Lh(t,e){if(e=e||we(),Ze=t[0],qt=t[4],Kt=t[8],Zt=t[1],Oe=t[5],Ge=t[9],Jt=t[2],Je=t[6],Ae=t[10],F=Ze+Oe+Ae,F>0){const i=st(F+1)*2;return e[0]=.25*i,e[1]=(Je-Ge)/i,e[2]=(Kt-Jt)/i,e[3]=(Zt-qt)/i,e}if(Ze>Oe&&Ze>Ae){const i=st(1+Ze-Oe-Ae)*2;return e[0]=(Je-Ge)/i,e[1]=.25*i,e[2]=(qt+Zt)/i,e[3]=(Kt+Jt)/i,e}if(Oe>Ae){const i=st(1+Oe-Ze-Ae)*2;return e[0]=(Kt-Jt)/i,e[1]=(Zt+qt)/i,e[2]=.25*i,e[3]=(Je+Ge)/i,e}const n=st(1+Ae-Ze-Oe)*2;return e[0]=(Zt-qt)/n,e[1]=(Jt+Kt)/n,e[2]=(Je+Ge)/n,e[3]=.25*n,e}function $s(t,e,n,i,r){return r=r||we(),Oe=t[0]/e,Ge=t[4]/n,zi=t[8]/i,Je=t[1]/e,Ae=t[5]/n,Vi=t[9]/i,Us=t[2]/e,Gs=t[6]/n,Zn=t[10]/i,F=(1+Oe+Ae+Zn)*.25,F>0?(F=Math.sqrt(F),r[0]=F,F=1/(4*F),r[1]=(Vi-Gs)*F,r[2]=(Us-zi)*F,r[3]=(Ge-Je)*F):(r[0]=0,F=-.5*(Ae+Zn),F>0?(F=Math.sqrt(F),r[1]=F,F*=2,r[2]=Ge/F,r[3]=zi/F):(r[1]=0,F=.5*(1-Zn),F>0?(F=Math.sqrt(F),r[2]=F,r[3]=Vi/(2*F)):(r[2]=0,r[3]=1))),r}function Oh(t,e,n){n=n||ue();const i=ct([-t[0],-t[1],-t[2]]),r=ct(Ye(e,i)),s=Ye(i,r);return n[0]=r[0],n[1]=s[0],n[2]=i[0],n[3]=0,n[4]=r[1],n[5]=s[1],n[6]=i[1],n[7]=0,n[8]=r[2],n[9]=s[2],n[10]=i[2],n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}function js(t,e,n){return vt=Wn(e[1],e[2],e[3]),F=e[0],At(At(it(vt,2*hr(vt,t)),it(t,F*F-hr(vt,vt))),it(Ye(vt,t),2*F),n)}function Nh(t,e,n,i){i=i||we();const r=[0,0,0,0];let s,a,o,c,u;return a=t[1]*e[1]+t[2]*e[2]+t[3]*e[3]+t[0]*e[0],a<0?(a=-a,r[0]=-e[1],r[1]=-e[2],r[2]=-e[3],r[3]=-e[0]):(r[0]=e[1],r[1]=e[2],r[2]=e[3],r[3]=e[0]),1-a>1e-7?(s=sc(a),o=Kn(s),c=Kn((1-n)*s)/o,u=Kn(n*s)/o):(c=1-n,u=n),i[1]=c*t[1]+u*r[0],i[2]=c*t[2]+u*r[1],i[3]=c*t[3]+u*r[2],i[0]=c*t[0]+u*r[3],i}function Br(){return[1,0,0,0]}function Ph(){return[0,1,0,0]}function Dh(){return[0,0,1,0]}function Fh(){return[0,0,0,1]}const Sg=Object.freeze(Object.defineProperty({__proto__:null,QR1:rh,QR2:sh,QR3:ah,QR4:oh,QW:hh,QX:ch,QY:lh,QZ:uh,addQuat:dh,angleQuat:xh,axisQuat:Ah,clamp:et,conjugateQuat:cc,decomposeRotation:$s,diffUnitQuat:gh,divideQuat:fh,dotQuat:yh,eulerToQuat:Ih,exponentQuat:ph,fromEulerAxisAngleToQuat:bh,fromOrderedEulerToQuat:uc,iQuat:Ph,imaginaryQuat:Th,inverseQuat:mh,jQuat:Dh,kQuat:Fh,lengthQuat:lc,lookAtMatrix:Oh,lookAtQuat:hc,matrix3x3FromUnitQuatModel:Vs,matrix3x3FromUnitQuatView:Mh,matrix3x3ToQuaternion:Ch,matrix4x4FromUnitQuatModel:Sh,matrix4x4FromUnitQuatView:Ws,matrix4x4ToQuaternion:Lh,multiplyQuat:ac,normalizeQuat:vh,oneQuat:Br,realQuat:wh,rotateVectorByUnitQuat:js,scaleQuat:oc,slerpUnitQuat:Nh,toEulerFromQuat:_h,toEulerXYZfromOrderedEuler:Eh,toOrderedEulerFromQuat:zs,toOrderedEulerFromQuat2:Rh,zeroQuat:we},Symbol.toStringTag,{value:"Module"}));function dc(t,e){return[t,e]}function Bh(t,e,n){return n=n||[0,0,0],At(t[0],it(t[1],e),n)}function fc(t,e,n){return n=n||[[0,0,0],[0,0,0]],nt(t,n[0]),ct(St(e,t),n[1]),n}const Mg=Object.freeze(Object.defineProperty({__proto__:null,ray:dc,rayFromPoints:fc,rayToLocation:Bh},Symbol.toStringTag,{value:"Module"})),Ig=zp,Cg=Sg,Lg=Mg,Og=up;let ke=class{constructor(){this.promise=new Promise((e,n)=>(this.resolver=e,this.rejector=n))}resolve(e){this.resolver(e)}reject(e){this.rejector(e)}},wt=-1,Hs=0,Qs=[],Ur=[],Gr=[];const ji=new Map,Hi=t=>{Hs=t;let e=!1;const n=[];ji.forEach((r,s)=>{e=!0;let[a,o,c,u,l]=r;if(u!==-1&&(l===-1&&(l=t,r[4]=t),t-l>=u)){n.push(s),a(t,l+u);return}if(o!==-1){if(c===-1&&(r[2]=t,c=t),t-c>=o)for(a(t);t-c>=o;)r[2]+=o,c+=o}else a(t)});for(let r=0,s=n.length;r<s;++r){const a=n[r];ji.delete(a)}const i=Ur.slice();Ur=[];for(let r=0,s=i.length;r<s;++r){const[a,o,c]=i[r];o<=0?a&&a(t):t-c>o?a(t):(e=!0,Ur.push(i[r]))}for(let r=0,s=Gr.length;r<s;++r){const a=Gr[r];a&&(e=!0,a(t))}Gr=Qs.slice(0),Qs=[],Gr.length>0&&(e=!0),e?wt=requestAnimationFrame(Hi):wt=-1};wt=requestAnimationFrame(Hi);function kr(t){const e=new ke;return Qs.push(n=>{t&&t(n),e.resolve(n)}),wt===-1&&(wt=requestAnimationFrame(Hi)),e.promise}function Rn(t,e){const n=new ke,i=r=>{t&&t(r),n.resolve(r)};return Ur.push([i,e||-1,Hs]),wt===-1&&(wt=requestAnimationFrame(Hi)),n.promise}function pc(t,e,n){const i=new ke,r=(s,a)=>{t(s),n!==void 0&&n>0?a!==void 0&&i.resolve(a):i.resolve(s)};return ji.set(i.promise,[r,e||-1,-1,n||-1,-1]),wt===-1&&(wt=requestAnimationFrame(Hi)),i.promise}function Uh(t){ji.delete(t),wt===-1&&(wt=requestAnimationFrame(Hi))}function Ng(){ji.forEach(t=>t[0](Hs,Hs)),ji.clear(),Ur=[],Qs=[],Gr=[]}const Ti=new Set,gc=Ti.add.bind(Ti),mc=Ti.delete.bind(Ti),Gh=async()=>{await pc(()=>{Ti.size!==0&&(Ti.forEach(t=>t.update()),Ti.clear())},void 0,Number.POSITIVE_INFINITY),Gh()};Gh();class vc{constructor(){this._children=[],this._needsUpdate=!1,this._childUpdate=new Set}get parent(){return this._parent}set parent(e){this.setParent(e)}get children(){return this._children}get needsUpdate(){return this._needsUpdate}get childUpdate(){return this._childUpdate}addChild(e,n){e.parent!==this&&(n||e.setParent(this,!0),this._children.push(e),this._childUpdate.add(e),e.invalidate())}invalidate(){if(this._needsUpdate)return!1;this._needsUpdate=!0;for(let e=0,n=this._children.length;e<n;++e){const i=this._children[e];this._childUpdate.add(i),i.invalidate()}return!0}processParentUpdates(e){if(!this._parent||!this._parent._needsUpdate)return;const n=[];let i=this._parent;for(;i&&(n.push(i),i._parent&&i._parent.needsUpdate);)i=i._parent;for(let r=n.length-1;r>=0;--r){const s=n[r];e(s),s.resolve()}}removeChild(e,n){e._parent===this&&(e._parent!==void 0&&!n&&e.setParent(void 0,!0),this._children.splice(this._children.indexOf(e),1),this._childUpdate.delete(e))}resolve(){this._needsUpdate&&(this._needsUpdate=!1,this._parent&&this._parent._childUpdate.delete(this))}setParent(e,n){this._parent!==e&&(n||(e!==void 0&&e.addChild(this,!0),this._parent&&this._parent.removeChild(this,!0)),this._parent=e,this.invalidate())}}class Xs extends vc{constructor(e){super(),this.isQueuedForUpdate=!1,this.needsWorldOrientation=!1,this.needsWorldDecomposition=!1,this.hasViewMatrix=!1,this._instance=null,this._matrix={value:ue()},this._localMatrix={value:this._matrix.value},this._rotation={value:Br()},this._localRotation={value:this._rotation.value},this.localRotationMatrix=Xt(),this._scale={value:[1,1,1]},this._localScale={value:this._scale.value},this._position={value:[0,0,0]},this._localPosition={value:this._position.value},this._forward={value:hi()},this._localForward={value:this._forward.value},this.needsForwardUpdate=!1,e&&(e.localPosition&&(this.localPosition=e.localPosition),e.localRotation&&(this.localRotation=e.localRotation),e.localScale&&(this.localScale=e.localScale),e.parent&&(this.parent=e.parent))}set instance(e){this._instance!==e&&this._instance&&(this._instance.transform.instance=null,e&&(e.transform=this)),this._instance=e}get matrix(){return this.update(),this._matrix.value}get localMatrix(){return this.update(),this._localMatrix.value}get viewMatrix(){return this.hasViewMatrix=!0,this._viewMatrix===void 0&&this.invalidate(),this.update(),this._viewMatrix===void 0?ue():this._viewMatrix.value}get localViewMatrix(){return this.hasViewMatrix=!0,this._localViewMatrix===void 0&&this.invalidate(),this.update(),this._localViewMatrix===void 0?ue():this._localViewMatrix.value}get localTransform(){var e;return(e=this._localTransform)==null?void 0:e.value}set localTransform(e){e?(this._localTransform||(this._localTransform={value:ue()}),Gi(e,this._localTransform.value),this._localTransform.didUpdate=!0):delete this._localTransform,this.invalidate()}get localViewTransform(){var e;return(e=this._localViewTransform)==null?void 0:e.value}set localViewTransform(e){e?(this._localViewTransform||(this._localViewTransform={value:ue()}),Gi(e,this._localViewTransform.value),this._localViewTransform.didUpdate=!0):delete this._localViewTransform,this.invalidate()}get rotation(){return this.needsWorldOrientation=!0,this.update(),this._rotation.value}set rotation(e){this.parent?console.warn("NOT IMPLEMENTED: Setting world rotation when a parent is present is not supported yet. Use localRotation for now."):this.localRotation=e}get localRotation(){return this._localRotation.value}set localRotation(e){fe(this._localRotation.value,e[0],e[1],e[2],e[3]),this._localRotation.didUpdate=!0,this.invalidate(),this.needsForwardUpdate=!0}get scale(){return this.needsWorldOrientation=!0,this.update(),this._scale.value}set scale(e){this.parent?console.warn("NOT IMPLEMENTED: Setting world scale is not supported yet. Use localScale for now."):this.localScale=e}get localScale(){return this._localScale.value}set localScale(e){pe(this._localScale.value,e[0],e[1],e[2]),this._localScale.didUpdate=!0,this.invalidate()}get position(){return this.needsWorldOrientation=!0,this.update(),this._position.value}set position(e){this.parent?console.warn("NOT IMPLEMENTED: Setting world position is not supported yet. Use localPosition for now."):this.localPosition=e}get localPosition(){return this._localPosition.value}set localPosition(e){this._localPosition.value[0]=e[0],this._localPosition.value[1]=e[1],this._localPosition.value[2]=e[2],this._localPosition.didUpdate=!0,this.invalidate()}get forward(){var e;return(this.needsForwardUpdate||(e=this.parent)!=null&&e.childUpdate.has(this))&&(this.needsForwardUpdate=!1,js(hi(),this._rotation.value,this._forward.value)),this._forward.value}get localForward(){return this.needsForwardUpdate&&(this.needsForwardUpdate=!1,js(hi(),this._localRotation.value,this._localForward.value)),this._localForward.value}applyLocalSRT(e,n,i){this._localScale.value=e,this._localPosition.value=i,this._localRotation.value=n,this._localScale.didUpdate=!0,this._localPosition.didUpdate=!0,this._localRotation.didUpdate=!0,this.invalidate(),this._instance&&(this._instance.transform=this)}decomposeWorldMatrix(){if(!this.needsWorldDecomposition||!this.parent||!this._matrix.didUpdate||this._matrix.value===this._localMatrix.value)return;if(this._instance){if(!this._instance.needsWorldUpdate||!this.needsWorldOrientation)return}else if(!this.needsWorldOrientation)return;this.needsWorldDecomposition=!1;const e=this._matrix.value,n=this._position.value,i=this._scale.value;this._position.didUpdate=n[0]!==e[12]||n[1]!==e[13]||n[2]!==e[14],this._position.didUpdate&&pe(n,e[12],e[13],e[14]);const r=Tn(e[0],e[1],e[2],e[3]),s=Tn(e[4],e[5],e[6],e[7]),a=Tn(e[8],e[9],e[10],e[11]);this._scale.didUpdate=i[0]!==r||i[1]!==s||i[2]!==a,pe(i,r,s,a),this._scale.didUpdate=!0;const[o,c,u,l]=this._rotation.value;$s(this._matrix.value,r,s,a,this._rotation.value);const h=this._rotation.value;this._rotation.didUpdate=h[0]!==o||h[1]!==c||h[2]!==u||h[3]!==l}lookAtLocal(e,n){hc(St(e,this._localPosition.value,$e[0]),n||[0,1,0],this._localRotation.value),this._localRotation.didUpdate=!0,this.invalidate(),this.needsForwardUpdate=!0}divideMemory(){this._forward.value=hi(),this._matrix.value=ue(),this._rotation.value=Br(),this._scale.value=[1,1,1],this._position.value=[0,0,0],this.hasViewMatrix&&this._viewMatrix&&this._localViewMatrix&&(this._viewMatrix.value=ue())}mergeMemory(){this._forward.value=this._localForward.value,this._matrix.value=this._localMatrix.value,this._rotation.value=this._localRotation.value,this._scale.value=this._localScale.value,this._position.value=this._localPosition.value,this.hasViewMatrix&&this._viewMatrix&&this._localViewMatrix&&(this._viewMatrix.value=this._localViewMatrix.value)}setParent(e,n){e!==this.parent&&(e?this.parent||this.divideMemory():this.mergeMemory(),this.invalidate(),this.needsForwardUpdate=!0,this._localScale.didUpdate=!0,this._localRotation.didUpdate=!0,this._localPosition.didUpdate=!0,super.setParent(e,n))}invalidate(){return this.queueForUpdate(),super.invalidate()}optimize(){this.needsWorldOrientation=!1}queueForUpdate(){!this.isQueuedForUpdate&&this._instance&&this._instance.active&&(this.isQueuedForUpdate=!0,gc(this))}update(e){let n=!1;if(this.isQueuedForUpdate&&(mc(this),this.isQueuedForUpdate=!1),this.needsUpdate){const i=this.localRotationMatrix;this._localRotation.didUpdate&&Vs(this._localRotation.value,i),this._localTransform?(Fs(this._localScale.value,i,this._localPosition.value,Ue[0]),rt(this._localTransform.value,Ue[0],this._localMatrix.value)):Fs(this._localScale.value,i,this._localPosition.value,this._localMatrix.value),this._localMatrix.didUpdate=!0,n=!0,this.hasViewMatrix&&(this._viewMatrix===void 0&&(this._viewMatrix={value:ue()}),this._localViewMatrix===void 0&&(this.parent?this._localViewMatrix={value:ue()}:this._localViewMatrix={value:this._viewMatrix.value}),this._localViewTransform?(Nr(Fi(this._localScale.value,$e[0]),Lr(i,vi[1]),it(this._localPosition.value,-1,$e[1]),Ue[0]),rt(this._localViewTransform.value,Ue[0],this._localViewMatrix.value)):Nr(Fi(this._localScale.value,$e[0]),Lr(i,vi[1]),it(this._localPosition.value,-1,$e[1]),this._localViewMatrix.value),this._localViewMatrix.didUpdate=!0)}this.parent&&(this.parent.needsUpdate?(e||this.processParentUpdates(i=>{i.update(!0)}),n=!0):this.parent.childUpdate.has(this)&&(n=!0),n&&(rt(this.parent._matrix.value,this._localMatrix.value,this._matrix.value),this._matrix.didUpdate=!0,this.needsWorldDecomposition=!0,this.hasViewMatrix&&this._viewMatrix&&this._localViewMatrix&&(this.parent.hasViewMatrix&&this.parent._viewMatrix&&this.parent._localViewMatrix?rt(this.parent._viewMatrix.value,this._localViewMatrix.value,this._viewMatrix.value):(Vs(this.parent.rotation,vi[0]),Nr(Fi(this.parent._scale.value,$e[0]),Lr(vi[0],vi[1]),it(this.parent._position.value,-1,$e[1]),Ue[0]),rt(this._localViewMatrix.value,Ue[0],this._viewMatrix.value)),this._viewMatrix.didUpdate=!0))),this.decomposeWorldMatrix(),this._instance&&this._instance.active&&(this._localMatrix.didUpdate||this._matrix.didUpdate)&&(this._instance.needsLocalUpdate&&(this._localRotation.didUpdate&&(this._instance._localRotation=this._localRotation.value),this._localPosition.didUpdate&&(this._instance._localPosition=this._localPosition.value),this._localScale.didUpdate&&(this._instance._localScale=this._localScale.value)),this._instance.needsWorldUpdate&&(this.parent?(this._rotation.didUpdate&&(this._instance._rotation=this._rotation.value),this._scale.didUpdate&&(this._instance._scale=this._scale.value),this._position.didUpdate&&(this._instance._position=this._position.value)):(this._localRotation.didUpdate&&(this._instance._rotation=this._localRotation.value),this._localPosition.didUpdate&&(this._instance._position=this._localPosition.value),this._localScale.didUpdate&&(this._instance._scale=this._localScale.value))),this._matrix.didUpdate&&(this._instance._matrix=this._matrix.value),this._localMatrix.didUpdate&&(this._instance._localMatrix=this._localMatrix.value,this.parent||(this._instance._matrix=this._matrix.value))),this._localScale.didUpdate=!1,this._localRotation.didUpdate=!1,this._localPosition.didUpdate=!1,this._rotation.didUpdate=!1,this._scale.didUpdate=!1,this._position.didUpdate=!1,this._matrix.didUpdate=!1,this._localMatrix.didUpdate=!1,this.resolve()}}const kh=new Xs;var xn=(t=>(t[t.PERSPECTIVE=0]="PERSPECTIVE",t[t.ORTHOGRAPHIC=1]="ORTHOGRAPHIC",t))(xn||{});function zh(t){return t.projectionOptions.type===1&&"left"in t.projectionOptions}function wc(t){return t.projectionOptions.type===0&&"fov"in t.projectionOptions}class An{constructor(e){this._id=G(),this.animationEndTime=0,this.needsViewDrawn=!0,this.needsBroadcast=!1,this.viewChangeViewId="",this.transform=new Xs,this._projection=ue(),this._needsUpdate=!0,this._viewProjection=ue(),this._projectionOptions=e,this._needsUpdate=!0,this.onChange=e.onViewChange,this.update()}get id(){return this._id}broadcast(e){this.onChange&&this.onChange(this,e)}static makeOrthographic(e){return new An(Object.assign({left:-100,right:100,top:-100,bottom:100,near:-100,far:1e5,type:1},e))}static makePerspective(e){return new An(Object.assign({type:0,far:1e4,near:1,fov:90*Math.PI/180,height:1e3,width:1e3},e))}get projectionType(){return this._projectionOptions.type}get projection(){return this.update(!0),this._projection}get view(){return this.transform.viewMatrix}get needsUpdate(){return this._needsUpdate}get position(){return this.transform.position}set position(e){this._needsUpdate=this._needsUpdate||!lr(e,this.transform.position),this.transform.position=e}lookAt(e,n){const i=Gi(this.transform.matrix);this.transform.lookAtLocal(e,n||[0,1,0]),this._needsUpdate=this._needsUpdate||!nc(i,this.transform.matrix)}get scale(){return this.transform.scale}set scale(e){this._needsUpdate=this._needsUpdate||!lr(e,this.transform.scale),this.transform.scale=e}get projectionOptions(){return this._projectionOptions}set projectionOptions(e){this._needsUpdate=this._needsUpdate||!rc(e,this._projectionOptions),this._projectionOptions=e}get viewProjection(){return this.update(!0),this._viewProjection}setOrthographic(e){this._projectionOptions=Object.assign({left:-100,right:100,top:-100,bottom:100,near:-100,far:1e5,type:1},e)}setPerspective(e){this._projectionOptions=Object.assign({type:0,far:1e4,near:1,fov:90*Math.PI/180,height:1e3,width:1e3},e)}resolve(){this._needsUpdate=!1,this.needsViewDrawn=!1,this.needsBroadcast=!1}update(e){(this._needsUpdate||e)&&(this.updateProjection(),this._needsUpdate=!1,this.needsViewDrawn=!0)}updateProjection(){zh(this)?ec(this.projectionOptions.left,this.projectionOptions.right,this.projectionOptions.bottom,this.projectionOptions.top,this.projectionOptions.near,this.projectionOptions.far,this._projection):wc(this)&&Jo(this.projectionOptions.fov,this.projectionOptions.width,this.projectionOptions.height,this.projectionOptions.near,this.projectionOptions.far,this._projection),rt(this._projection,this.transform.viewMatrix,this._viewProjection)}}class yi{get id(){return this._key}get key(){return this._key}constructor(e){this._key=e.key}}function Pg(t){return{key:"",type:le.COLOR_BUFFER,...t}}function Ys(t){return t!==void 0&&t.key!==void 0&&t.type===le.COLOR_BUFFER}class Vh extends yi{constructor(e,n){super(e),this.type=le.COLOR_BUFFER,this.height=e.height,this.width=e.width,this.colorBufferSettings=e.colorBufferSettings,this.createColorBuffer(n)}destroy(){this.colorBuffer.destroy()}createColorBuffer(e){if(this.colorBuffer)return;this.colorBufferSettings={...this.colorBufferSettings};let n,i;const r=(e==null?void 0:e.getRenderSize())||[1,1];if(this.width<=lt.SCREEN){if(!e)throw new Error("Can not generate Render Texture with a dynamic width or height when the WebGLRenderer is not available");n=r[0]/-this.width}else n=this.width;if(this.height<=lt.SCREEN){if(!e)throw new Error("Can not generate Render Texture with a dynamic width or height when the WebGLRenderer is not available");i=r[1]/-this.width}else i=this.height;this.colorBuffer=new Wl({internalFormat:d.GLSettings.RenderTarget.ColorBufferFormat.RGBA4,size:[n,i],...this.colorBufferSettings})}}class Qi{get webGLRenderer(){return this._webGLRenderer}set webGLRenderer(e){this._webGLRenderer=e}getIOExpansion(){return[]}resize(){}setAttributeContext(e){}}class Wh extends Qi{constructor(){super(...arguments),this.resources=new Map}async dequeueRequests(){return!1}destroy(){}destroyResource(e){this.resources.delete(e.key)}getResource(e){return this.resources.get(e)||{key:"",type:-1}}async initResource(e){this.resources.set(e.key,e)}request(e,n,i){return[0,0,0,0]}updateResource(e){}}const $h=new Wh;class Dg extends Qi{constructor(){super(...arguments),this.resources=new Map}async dequeueRequests(){return!1}destroy(){this.resources.forEach(e=>e.destroy()),this.resources.clear()}getIOExpansion(){return[]}getResource(e){return this.resources.get(e)||null}destroyResource(e){const n=this.resources.get(e.key);n&&(n.destroy(),this.resources.delete(e.key))}async initResource(e){let n=this.resources.get(e.key);if(n){console.warn("Attempted to generate a RenderTexture that already exists for key",e.key);return}n=new Vh(e,this.webGLRenderer),this.resources.set(e.key,n)}request(e,n,i,r){const s=this.resources.get(i.key);return s?(i.colorBuffer=s.colorBuffer,[0,0,1,1]):[0,0,0,0]}resize(){const e=new Map;this.resources.forEach((n,i)=>{n.width>lt.SCREEN&&n.height>lt.SCREEN||(n.colorBuffer.destroy(),n=new Vh(n,this.webGLRenderer),e.set(i,n))}),e.forEach((n,i)=>this.resources.set(i,n))}updateResource(e){this.resources.get(e.key)&&console.warn("UPDATING AN EXISTING COLOR BUFFER IS NOT SUPPORTED YET")}}function Tc(t){return{type:le.COLOR_BUFFER,...t}}const zr=class{static setObservableMonitor(t){zr.gatherIds=t,zr.observableIds=[]}static getObservableMonitorIds(t){const e=zr.observableIds.slice(0);return t&&(zr.observableIds=[]),e}};let je=zr;je.setCycle=!1,je.gatherIds=!1,je.observableIds=[],je.observableNamesToUID=new Map;const en=je,qs=new Map;let Fg=1;const Bg={}.constructor;function Ug(t,e){const n=en.observableNamesToUID.get(e)||0;if(n===0){console.warn("A property with name",e,"for",t,"has not been assigned a UID which is an error in this step of the process.");return}function i(){return en.gatherIds&&(en.setCycle||en.observableIds.push(n)),t.observableStorage[n]}function r(a){en.gatherIds&&(en.setCycle=!0),t.observableStorage[n]=a,t.changes[n]=n,t.observer&&t.observer.instanceUpdated(t),en.gatherIds&&(en.setCycle=!1)}const s=t[e];Object.defineProperty(t,e,{configurable:!0,enumerable:!0,get:i,set:r}),t[e]=s}function M(t,e,n){n||(n={configurable:!0,enumerable:!0});let i=qs.get(t.constructor),r=en.observableNamesToUID.get(e)||0;r===0&&(r=++Fg,en.observableNamesToUID.set(e,r)),i||(i=new Set,qs.set(t.constructor,i)),i.add(e);let s=Object.getPrototypeOf(t),a=0;for(;s.constructor!==Bg&&++a<100;){const o=qs.get(s.constructor);o&&o.forEach(c=>i==null?void 0:i.add(c)),s=Object.getPrototypeOf(s)}a>=100&&console.warn("@observable decorator encountered a type that has 100+ levels of inheritance. This is most likely an error, and may be a result of a circular dependency and will not be supported by this decorator."),n.enumerable=!0,n.writable=!0,Object.defineProperty(t,e,n)}function He(t,e){if(t.constructor!==e)return;const n=qs.get(e);n&&n.forEach(i=>Ug(t,i))}class he{constructor(e){if(this._uid=G(),this.cleanObservation=new Map,this.instanceChanges=new Map,this.allowChanges=!0,this.resolveContext="",e)for(let n=0,i=e.length;n<i;++n){const r=e[n];this.add(r)}}get uid(){return this._uid}get changeList(){this.allowChanges=!1;const e=[];return this.instanceChanges.forEach(n=>e.push(n)),e}add(e){if(this.cleanObservation.get(e.uid))return e;if(this.allowChanges){e.observer=this;const n=e.observableDisposer;this.cleanObservation.set(e.uid,[e,n]),this.instanceChanges.set(e.uid,[e,Ce.INSERT,e.changes])}return e}has(e){return this.cleanObservation.has(e.uid)}clear(){this.cleanObservation.forEach(e=>{this.remove(e[0])})}destroy(){this.cleanObservation.forEach(e=>{e[1]()}),this.cleanObservation.clear(),this.instanceChanges.clear()}instanceUpdated(e){this.allowChanges&&this.instanceChanges.set(e.uid,[e,Ce.CHANGE,e.changes])}remove(e){if(this.allowChanges){const n=this.cleanObservation.get(e.uid);n&&(n[1](),this.cleanObservation.delete(e.uid),this.instanceChanges.set(e.uid,[n[0],Ce.REMOVE,{}]))}return!1}resolve(e){if(this.allowChanges=!0,this.instanceChanges.clear(),this.resolveContext&&this.resolveContext!==e)throw new Error("An instance provider has been issued to two layers. This is not a suppported feature yet and can cause issues.");this.resolveContext=e}sync(){const e=[];this.cleanObservation.forEach(n=>{const[i]=n;this.instanceChanges.set(i.uid,[i,Ce.INSERT,e])})}}class Gg extends he{constructor(e){super(e),this._instances=[]}get instances(){return this._instances}add(e){return this._instances.push(e),super.add(e)}clear(){this._instances.length=0,super.clear()}remove(e){const n=this._instances.findIndex(i=>i.uid===e.uid);return n!==-1&&this._instances.splice(n,1),super.remove(e)}destroy(){this._instances.length=0,super.destroy()}}class jh{constructor(e){this.delay=0,this.isManualStart=!1,this.isTimeSet=!1,this.startTime=-1,Object.assign(this,e)}setAutomatic(){this.isManualStart=!1,this.isTimeSet=!1}setStart(e){e&&(this.start.length!==e.length?console.warn("A manual easing adjustment provided an incompatible value for the easing type."):(this.start=e,this.isManualStart=!0))}setTiming(e,n){this.delay=e===void 0?this.delay:e,this.duration=n===void 0?this.duration:n,this.isTimeSet=!0}}var kg=Object.defineProperty,zg=Object.getOwnPropertyDescriptor,Hh=(t,e,n,i)=>{for(var r=i>1?void 0:i?zg(e,n):e,s=t.length-1,a;s>=0;s--)(a=t[s])&&(r=(i?a(e,n,r):a(r))||r);return i&&r&&kg(e,n,r),r};let Qh=0;const yc=class{constructor(t){this._active=!1,this.changes={},this._observer=null,this.observableStorage=[],this._uid=yc.newUID,this.reactivate=!1,He(this,yc),t&&(this.active=t.active||this.active)}static get newUID(){return Qh=++Qh%16777215}get active(){return this._active}set active(t){this._active=t,this.reactivate=!0}get observableDisposer(){return()=>this._observer=null}get observer(){return this._observer||null}set observer(t){const e=this._observer;e&&e!==t&&(this.easing&&this.easing.clear(),e.remove(this)),this._observer=t}getEasing(t){if(this.easingId){const e=this.easingId[`_${t}_end`];if(e&&this.easing){const n=this.easing.get(e);if(n instanceof jh)return n}}}get uid(){return this._uid}resourceTrigger(){console.warn("resourceTrigger called on an instance that did not override resourceTrigger. resourceTrigger MUST be overridden for instances","that utilize a resource. The observable that is tied to committing the resource should be 'triggered' in this method.")}};let ze=yc;Hh([M],ze.prototype,"_active",2),Hh([M],ze.prototype,"_uid",2);class Vg extends ze{resourceTrigger(){}}function bc(t){return{key:"",type:le.TEXTURE,...t}}function bi(t){return t&&t.key!==void 0&&t.type===le.TEXTURE}class Ec extends yi{constructor(e,n){super(e),this.type=le.TEXTURE,this.height=e.height,this.width=e.width,this.textureSettings=e.textureSettings,this.createTexture(n)}destroy(){this.texture.destroy()}createTexture(e){var s;if(this.texture)return;this.textureSettings={generateMipMaps:!0,premultiplyAlpha:!1,...this.textureSettings};let n,i;const r=(e==null?void 0:e.getRenderSize())||[1,1];if(this.width<=lt.SCREEN){if(!e)throw new Error("Can not generate Render Texture with a dynamic width or height when the WebGLRenderer is not available");n=r[0]/-this.width}else n=this.width;if(this.height<=lt.SCREEN){if(!e)throw new Error("Can not generate Render Texture with a dynamic width or height when the WebGLRenderer is not available");i=r[1]/-this.width}else i=this.height;this.texture=new ie({data:((s=this.textureSettings)==null?void 0:s.data)||{width:n,height:i,buffer:null},...this.textureSettings})}}const Wg=`// This contains the method required to be used on a fragment shader when a layer desires to use
// PickType.SINGLE (color picking).
varying highp vec4 _picking_color_pass_;

void main() {
  \${out: _picking_fragment_} = _picking_color_pass_;
}
`;function Xh(t){return t}class Qe{constructor(e,n,i,r){this.child=[null,null],this.isLeaf=!0,this.data=null,this.bounds=new te({height:r,width:i,x:e,y:n})}destroy(){const e=this.child[0],n=this.child[1];this.data=null,e&&e.destroy(),n&&n.destroy(),this.child[0]=null,this.child[1]=null}hasChild(){const e=this.child[0],n=this.child[1];return e&&!e.data?!e.isLeaf:n&&!n.data?!n.isLeaf:!1}insert(e){let n=this.child[0],i=this.child[1];if(!this.isLeaf&&n&&i){const r=n.insert(e);return r!==null?r:i.insert(e)}else{if(this.data)return null;const r=this.bounds.fits(e.bounds);if(r===0)return null;if(r===1)return this.data=e.data,this;this.isLeaf=!1;const s=e.bounds.width,a=e.bounds.height,o=this.bounds.width-s,c=this.bounds.height-e.bounds.height;o>c?(n=this.child[0]=new Qe(this.bounds.x,this.bounds.y,s,this.bounds.height),i=this.child[1]=new Qe(this.bounds.x+s,this.bounds.y,o,this.bounds.height)):(n=this.child[0]=new Qe(this.bounds.x,this.bounds.y,this.bounds.width,a),i=this.child[1]=new Qe(this.bounds.x,this.bounds.y+a,this.bounds.width,c))}return n.insert(e)}remove(e){const n=this.child[0],i=this.child[1];if(i&&n&&!this.isLeaf){let r=n.remove(e);return r?!0:(r=i.remove(e),n.hasChild()||i.hasChild()||(this.child[0]=null,this.child[1]=null),r)}else return this.data===e?(this.data=null,!0):!1}static applyToSubTexture(e,n,i,r,s){if(!i)return;r=r||{top:0,left:0,bottom:0,right:0};const a=n instanceof Qe?n.bounds:n,o=(a.x+r.left)/e.bounds.width,c=(a.y+r.top)/e.bounds.height,u=(a.width-r.left-r.right)/e.bounds.width,l=(a.height-r.top-r.bottom)/e.bounds.height;let h;s?h=new te({bottom:1-c,left:o,right:o+u,top:1-(c+l)}):h=new te({top:1-c,left:o,right:o+u,bottom:1-(c+l)});const f=h.bottom,p=h.y,g=h.x,m=h.x+h.width;i.atlasTL=[g,p],i.atlasBR=[m,f],i.atlasBL=[g,f],i.atlasTR=[m,p],i.widthOnAtlas=Math.abs(i.atlasTR[0]-i.atlasTL[0]),i.heightOnAtlas=Math.abs(i.atlasTR[1]-i.atlasBR[1]),i.pixelWidth=u*e.bounds.width,i.pixelHeight=l*e.bounds.height}}function Yh(t){return t&&t.call!==void 0&&t.apply!==void 0}function Jn(t,e,n){let i=t.get(e);return i===void 0&&(Yh(n)?i=n():i=n,t.set(e,i)),i}function Ks(t,e,n){let i=t.get(e);return i===void 0&&(Yh(n)?i=n():i=n),i}class tt{}tt.transparentShapeBlending={blending:{blendDst:d.GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha,blendEquation:d.GLSettings.Material.BlendingEquations.Add,blendSrc:d.GLSettings.Material.BlendingSrcFactor.SrcAlpha},culling:d.GLSettings.Material.CullSide.NONE,modify(t){return Object.assign({},this,t)}},tt.transparentImageBlending={blending:{blendSrc:d.GLSettings.Material.BlendingSrcFactor.One,blendDst:d.GLSettings.Material.BlendingDstFactor.OneMinusSrcAlpha,blendEquation:d.GLSettings.Material.BlendingEquations.Add},culling:d.GLSettings.Material.CullSide.NONE,modify(t){return Object.assign({},this,t)}};class $g{static async modify(e,n,i){for(let r=0,s=n.length;r<s;++r){const a=n[r];for(let o=0,c=e.length;o<c;++o){const u=e[o],l=u.getEasing(a);l&&i(l,u,o,r)}}}static async all(e,n,i,r){let s=xs;const a=new Promise(u=>s=u);let o=0;for(let u=0,l=i.length;u<l;++u){const h=i[u];for(let f=0,p=n.length;f<p;++f){const g=n[f],m=g.getEasing(h);m&&(r&&r(m,g,f,u),o=Math.max((m.delay||0)+m.duration,o))}}const c=u=>{u<o?Rn(c):s()};return e?Rn(u=>{o+=u,c(u)}):s(),a}}const jg=5,Hg=10;function Qg(t,e){const n=[];return e.forEach(i=>{t.find(r=>i instanceof r)&&n.push(i)}),n}class qh{destroy(){this.TL.destroy(),this.TR.destroy(),this.BL.destroy(),this.BR.destroy()}constructor(e,n){const i=e.mid;this.TL=new Xi(e.x,i[0],e.y,i[1],n),this.TR=new Xi(i[0],e.right,e.y,i[1],n),this.BL=new Xi(e.x,i[0],i[1],e.bottom,n),this.BR=new Xi(i[0],e.right,i[1],e.bottom,n)}}class Xi{constructor(e,n,i,r,s){this.children=[],this.depth=0,arguments.length>=4?this.bounds=new te({left:e,right:n,top:i,bottom:r}):this.bounds=new te({left:0,right:1,top:0,bottom:1}),this.depth=s||0}destroy(){this.children=[],this.nodes&&(this.nodes.destroy(),delete this.nodes)}add(e,n){return e.isInside(this.bounds)?this.doAdd(e):(this.cover(e),this.add(e,n))}addAll(e){let n=Number.MAX_SAFE_INTEGER,i=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER;const{min:a,max:o}=Math;for(let c=0,u=e.length;c<u;++c){const l=e[c];n=a(n,l.x),r=o(l.right,r),i=a(i,l.y),s=o(s,l.bottom)}this.cover(new te({left:n,right:r,top:i,bottom:s})),e.forEach(c=>this.doAdd(c))}cover(e){if(e.isInside(this.bounds))return;this.bounds.encapsulate(e),this.bounds.x-=1,this.bounds.y-=1,this.bounds.width+=2,this.bounds.height+=2;const n=this.gatherChildren([]);this.nodes&&(this.nodes.destroy(),delete this.nodes),n.forEach(i=>this.doAdd(i))}doAdd(e){return this.nodes?e.isInside(this.nodes.TL.bounds)?this.nodes.TL.doAdd(e):e.isInside(this.nodes.TR.bounds)?this.nodes.TR.doAdd(e):e.isInside(this.nodes.BL.bounds)?this.nodes.BL.doAdd(e):e.isInside(this.nodes.BR.bounds)?this.nodes.BR.doAdd(e):(this.children.push(e),!0):e.isInside(this.bounds)?(this.children.push(e),this.children.length>jg&&this.depth<Hg&&this.split(),!0):(isNaN(e.width+e.height+e.x+e.y)?console.error("Child did not fit into bounds because a dimension is NaN",e):e.area===0&&console.error("Child did not fit into bounds because the area is zero",e),!0)}gatherChildren(e,n){n&&n(this);for(let i=0,r=this.children.length;i<r;++i)e.push(this.children[i]);return this.nodes&&(this.nodes.TL.gatherChildren(e,n),this.nodes.TR.gatherChildren(e,n),this.nodes.BL.gatherChildren(e,n),this.nodes.BR.gatherChildren(e,n)),e}query(e,n){return e instanceof te?e.hitBounds(this.bounds)?this.queryBounds(e,[],n):[]:Aa(e)&&this.bounds.containsPoint(e)?this.queryPoint(e,[],n):[]}queryBounds(e,n,i){return this.bounds.isInside(e)?(this.gatherChildren(n,i),n):(this.children.forEach(r=>{r.hitBounds(e)&&n.push(r)}),i&&i(this),this.nodes&&(e.hitBounds(this.nodes.TL.bounds)&&this.nodes.TL.queryBounds(e,n,i),e.hitBounds(this.nodes.TR.bounds)&&this.nodes.TR.queryBounds(e,n,i),e.hitBounds(this.nodes.BL.bounds)&&this.nodes.BL.queryBounds(e,n,i),e.hitBounds(this.nodes.BR.bounds)&&this.nodes.BR.queryBounds(e,n,i)),n)}queryPoint(e,n,i){return this.children.forEach(r=>{r.containsPoint(e)&&n.push(r)}),i&&i(this),this.nodes&&(this.nodes.TL.bounds.containsPoint(e)&&this.nodes.TL.queryPoint(e,n,i),this.nodes.TR.bounds.containsPoint(e)&&this.nodes.TR.queryPoint(e,n,i),this.nodes.BL.bounds.containsPoint(e)&&this.nodes.BL.queryPoint(e,n,i),this.nodes.BR.bounds.containsPoint(e)&&this.nodes.BR.queryPoint(e,n,i)),n}split(){const e=[];this.gatherChildren(e),this.nodes=new qh(this.bounds,this.depth+1),this.children=[];for(let n=0,i=e.length;n<i;++n){const r=e[n];r&&this.doAdd(r)}}visit(e){const n=!!e(this);this.nodes&&!n&&(this.nodes.TL.visit(e),this.nodes.TR.visit(e),this.nodes.BL.visit(e),this.nodes.BR.visit(e))}}class Kh extends Xi{}class Vr{constructor(e){this.willDispose=new Set,this.keyToItem=new Map,this.keyToInitializer=new Map,this.currentInitalizerIndex=0,this.currentInitializers=[],this._items=[],this.inlineDeferred=n=>{this.deferredInlining=n},this.inlineImmediate=n=>{if(n.length>0&&this.currentInitializers&&this.currentItem){this.currentInitializers.splice(this.currentInitalizerIndex+1,0,...n);for(let i=0,r=n.length;i<r;++i){const s=n[i];s.parent=this.currentItem}}},this.inline=this.inlineImmediate,this.options=e}get items(){return this._items.slice(0)}async destroy(){const e=[];for(let n=0,i=this.currentInitializers.length;n<i;++n){const r=this.currentInitializers[n],s=this.keyToItem.get(r.key);s&&e.push(this.options.destroyItem(r,s))}await Promise.all(e)}async diff(e){const n=e.slice(0);this.currentInitializers=n,this._items=[];let i=0;for(;i<n.length;){const r=n[i];if(this.currentInitalizerIndex=i,this.currentInitializer=r,this.willDispose.has(r.key)){let s=this.keyToItem.get(r.key)||null;s?(this.currentItem=s,await this.options.updateItem(r,s)):s=await this.options.buildItem(r),s&&(this.keyToInitializer.set(r.key,r),this.willDispose.delete(r.key),this._items.push(s))}else{this.inline=this.inlineDeferred;const s=await this.options.buildItem(r);this.inline=this.inlineImmediate,s&&(this.currentItem=s,this.deferredInlining&&(this.inline(this.deferredInlining),delete this.deferredInlining),this.keyToItem.set(r.key,s),this.keyToInitializer.set(r.key,r),this._items.push(s))}delete this.currentItem,i++}this.willDispose.forEach(async r=>{const s=this.keyToItem.get(r),a=this.keyToInitializer.get(r);if(!s||!a)return;await this.options.destroyItem(a,s)&&(this.keyToItem.delete(r),this.keyToInitializer.delete(r))}),this.willDispose.clear(),this.keyToInitializer.forEach(r=>{this.willDispose.add(r.key)}),this.currentInitializers=[],delete this.currentItem,delete this.currentInitializer}getByKey(e){return this.keyToItem.get(e)}async rebuild(){if(!this.currentItem||!this.currentInitializer)return;this.keyToItem.delete(this.currentItem.id),this.keyToInitializer.delete(this.currentItem.id),this.options.destroyItem(this.currentInitializer,this.currentItem);const e=await this.options.buildItem(this.currentInitializer);e&&(this.keyToItem.set(this.currentItem.id,e),this.keyToInitializer.set(this.currentItem.id,this.currentInitializer))}}function ei(t){const{shader:e,options:n={},required:i,onError:r,onToken:s,onMain:a}=t,o=new Map,c=new Map,u=new Map,l=new Map,h=e.replace(/\$\{([^\}]*)\}/g,(p,g)=>{let m="";return l.set(g,(l.get(g)||0)+1),g in n?(o.set(g,(o.get(g)||0)+1),m=n[g]):c.set(g,(c.get(g)||0)+1),s&&(m=s(g,m)),m});Object.keys(n).forEach(p=>{o.get(p)||u.set(p,(u.get(p)||0)+1)});const f={resolvedShaderOptions:o,shader:h,shaderProvidedOptions:l,unresolvedProvidedOptions:u,unresolvedShaderOptions:c};if(i&&i.values.forEach(p=>{if(f.unresolvedProvidedOptions.get(p)){const g=`${i.name}: Could not resolve all the required inputs. Input: ${p}`;r?r(g):console.error(g)}else if(f.unresolvedShaderOptions.get(p)){const g=`${i.name}: A required option was not provided in the options parameter. Option: ${p}`;r?r(g):console.error(g)}else if(!f.resolvedShaderOptions.get(p)){const g=`${i.name}: A required option was not provided in the options parameter. Option: ${p}`;r?r(g):console.error(g)}}),a){const p=f.shader,g=p.match(/void((.+)|\s)(main(\s+)\(\)|main\(\))(((.+)(\s*)\{)|(\s*)\{)/gm);if(g&&g.length>0){const m=p.indexOf(g[0]);if(m<0)a(null);else{const T=p.substr(0,m),w=p.substr(m+g[0].length);let y=!1,b=!1,A=1,R=0,N=-1;for(let I=0,S=w.length;I<S;++I){const j=w[I],Q=w[I+1];switch(j){case"/":switch(Q){case"*":!y&&!b&&(y=!0,I++);break;case"/":!y&&!b&&(b=!0,I++);break}break;case"*":Q==="/"&&(b||(y=!1,I++));break;case`
`:case"\r":y||(b=!1);break;case"{":!y&&!b&&A++;break;case"}":!y&&!b&&R++,A===R&&(N=I);break}if(N!==-1)break}if(N!==-1){const I=w.substr(0,N),S=w.substr(N+1),j=a(I,`${T}
${S}`);typeof j=="string"?f.shader=p.substr(0,m+g[0].length)+j+p.substr(m+g[0].length+N):f.shader=p.substr(0,m)+j.header+p.substr(m,g[0].length)+j.main+p.substr(m+g[0].length+N)}else a(null)}}}return f}function Xg(t){return new Promise(e=>setTimeout(e,t))}function Yg(t){let e=0,n=[];return Object.assign(async r=>{if(r!==void 0&&r!==t&&(n.forEach(l=>l.resolve(!1)),t=r),!t)return!1;const s=++e,a=new ke;let o=t.getBoundingClientRect(),c;if(n.push(a),o.width===0||o.height===0){let l=!0;const h={attributes:!0};c=new MutationObserver(f=>{if(l){for(const p of f)if(p.type==="attributes"){if(!t)return;o=t.getBoundingClientRect(),o.width!==0&&o.height!==0&&(c&&(c.disconnect(),c=void 0),l=!1,a.resolve(s===e))}}}),c.observe(t,h),await kr(),o=t.getBoundingClientRect(),l&&o.width!==0&&o.height!==0&&(c.disconnect(),l=!1,a.resolve(s===e))}else await kr(),a.resolve(s===e);const u=await a.promise;return c&&(c.disconnect(),c=void 0),u&&(n.forEach(l=>l.resolve(!1)),n=[]),u},{cancel:()=>{n.forEach(r=>r.resolve(!1)),n=[]}})}function Ei(t,e){const n=Object.assign(e,{key:e.key||t.defaultProps.key,data:e.data||t.defaultProps.data});return{get key(){return e.key||""},init:[t,n]}}function _i(t,e){const n=Object.assign(e,{key:e.key||t.defaultProps.key,data:e.data||t.defaultProps.data});return{get key(){return e.key||""},init:[t,n]}}function Zh(t){return t}function Jh(t){return t}const qg={layer:Ei,view:Pc,vertex:Jh,uniform:Zh,attribute:Xh};class Kg{constructor(e){this.index=-1,this.marker=new Map,this.pool=new Array(e.firstAlloc);for(let n=0,i=e.firstAlloc;n<i;++n)this.pool[n]=e.create();this.options=e}destroy(){for(let e=0,n=this.pool.length;e<n;++e)this.options.destroy(this.pool[e]);this.pool=[],this.marker.clear()}retrieve(){const e=this.pool[this.index+1];return this.index++,this.marker.set(e,this.index),e}replace(e){const n=this.marker.get(e);n!==void 0&&(this.pool[n]=this.pool[this.index],this.pool[this.index]=e,this.marker.delete(e),this.index--)}}function Zg(t,e,n,i){return e<0&&(e=t.length+e,e<0&&(e=0)),t.slice(0,e)+(i||"")+t.slice(e+n)}function Wr(t){let e=!1,n=!1;const i=[];let r={start:-1,stop:-1},s={start:-1,stop:-1};for(let a=0,o=t.length;a<o;++a){const c=t[a],u=t[a+1];switch(c){case"/":switch(u){case"*":!n&&!e&&(r.start=a,e=!0,a++);break;case"/":!e&&!n&&(s.start=a,n=!0,a++);break}break;case"*":u==="/"&&e&&(r.stop=a+2,i.push(r),r={start:-1,stop:-1},e=!1,a++);break;case`
`:case"\r":n&&(s.stop=a,i.push(s),s={start:-1,stop:-1},n=!1);break}}return i.reverse(),i.forEach(a=>{t=Zg(t,a.start,a.stop-a.start)}),t}function ti(t){return t?[t.atlasTL[0],t.atlasTL[1],t.atlasBR[0],t.atlasBR[1]]:[0,0,0,0]}class Sn{constructor(e){this._uid=G(),this.aspectRatio=1,this.atlasTL=[0,0],this.atlasTR=[0,0],this.atlasBL=[0,0],this.atlasBR=[0,0],this.heightOnAtlas=0,this.isValid=!1,this.pixelWidth=0,this.pixelHeight=0,this.texture=null,this.widthOnAtlas=0,Object.assign(this,e)}get uid(){return this._uid}static fromRegion(e,n){if(!e.data)return null;const i=n.x/e.data.width,r=n.y/e.data.height,s=n.width/e.data.width,a=n.height/e.data.height,o=new te({bottom:r+a,left:i,right:i+s,top:r}),c=o.bottom,u=o.y,l=o.x,h=o.x+o.width,f=new Sn;return f.atlasTL=[l,u],f.atlasBR=[h,c],f.atlasBL=[l,c],f.atlasTR=[h,u],f}update(){!this.texture||!this.source||!this.atlasRegion||this.texture.update(this.source,this.atlasRegion)}toString(){return JSON.stringify({atlas:{TL:this.atlasTL,TR:this.atlasTR,BL:this.atlasBL,BR:this.atlasBR},width:this.pixelWidth,height:this.pixelHeight},null,2)}}const Jg=Ie("performance");function ed(t){return{key:"",type:le.ATLAS,...t}}function _c(t){return t&&t.type===le.ATLAS}class td extends yi{constructor(e){super(e),this.resourceReferences=new Map,this.type=le.ATLAS;const n=document.createElement("canvas");if(this.width=n.width=e.width,this.height=n.height=e.height,this.textureSettings=e.textureSettings,e.width<0||e.height<0)throw new Error("TextureSize Error: An atlas does NOT support Screen Texture sizing.");this.packing=new Qe(0,0,e.width,e.height),this.createTexture(n)}createTexture(e){if(this.texture)return;let n;this.textureSettings?n={generateMipMaps:!0,premultiplyAlpha:!0,...this.textureSettings}:n={generateMipMaps:!0,premultiplyAlpha:!0},this.texture=new ie({data:e,...n})}destroy(){var e;(e=this.texture)==null||e.destroy(),this.resourceReferences.forEach(n=>{this.invalidateTexture(n.subtexture)})}invalidateTexture(e){const n=[0,0];e.aspectRatio=1,e.atlasBL=n,e.atlasBR=n,e.atlasTL=n,e.atlasTR=n,e.isValid=!1,e.texture=null,e.pixelHeight=0,e.pixelWidth=0,delete e.source,e.video&&(e.video.monitor.destroy(),delete e.video)}resolveResources(){const e=[];this.resourceReferences.forEach((n,i)=>{n.count<=0&&n.subtexture&&(Jg("A subtexture on an atlas has been invalidated as it is deemed no longer used: %o",n.subtexture),this.invalidateTexture(n.subtexture),e.push(i))});for(let n=0,i=e.length;n<i;++n)this.resourceReferences.delete(e[n])}stopUsingResource(e){const n=this.resourceReferences.get(e.source)||{subtexture:e.texture||new Sn,count:0};n.count--}useResource(e){const n=this.resourceReferences.get(e.source)||{subtexture:e.texture,count:0};n.count++}}let De;class Ri{static async awaitContext(){for(;!De;)this.getContext(),await new Promise(e=>setTimeout(e,10))}static getContext(){De||(De=document.createElement("canvas").getContext("2d"))}static async calculateImageSize(e){if(await this.awaitContext(),!De){console.warn("The Image rasterizer was unable to establish a valid canvas context. Please ensure the system supports contexts and ensure the document is ready first.");return}if(e.width===0||e.height===0){console.warn("Images provided shoud have valid dimensions! Please ensure the image is loaded first.");return}return De.canvas.width=100,De.canvas.height=100,De.drawImage(e,0,0,1,1),[e.width,e.height]}static async resizeImage(e,n){if(await this.awaitContext(),!De)return console.warn("The Image rasterizer was unable to establish a valid canvas context. Please ensure the system supports contexts and ensure the document is ready first."),e;if(e.width===0||e.height===0)return console.warn("Images provided shoud have valid dimensions! Please ensure the image is loaded first."),e;De.canvas.width=Math.floor(e.width*n),De.canvas.height=Math.floor(e.height*n),e instanceof ImageData?De.putImageData(e,0,0,0,0,De.canvas.width,De.canvas.height):De.drawImage(e,0,0,De.canvas.width,De.canvas.height);const i=new Image;return i.src=De.canvas.toDataURL("image/png"),await Ri.calculateImageSize(i),i}}class em{constructor(e,n){this.video=e,this.subTexture=n,this.isDestroyed=!1,this.renderedTime=-1,this.previousTime=-1,this.playedFrames=0,this.caughtFrames=0,this.timeFrame=0,this.doUpdate=()=>{Math.abs(this.video.currentTime-this.renderedTime)<.015||(this.renderedTime=this.video.currentTime,this.subTexture.update())},this.loop=i=>{this.doUpdate(),this.isDestroyed||Rn(this.loop)},this.addEventListeners()}async addEventListeners(){this.isDestroyed||this.loop(await Rn())}destroy(){this.video.pause(),this.isDestroyed=!0,this.removeEventListeners()}removeEventListeners(){}}const nd=Ie("performance"),tm=new Sn({aspectRatio:0,atlasBL:[0,0],atlasBR:[0,0],texture:null,atlasTL:[0,0],atlasTR:[0,0],heightOnAtlas:0,isValid:!1,pixelHeight:0,pixelWidth:0,widthOnAtlas:0});function nm(t){return!!(t&&t.isValid&&t.pixelWidth&&t.pixelHeight)}class id{constructor(){this.allAtlas=new Map}async createAtlas(e){const n=new td(e);return this.allAtlas.set(n.id,n),nd("Atlas Created-> %o",n),n}destroy(){this.allAtlas.forEach(e=>e.destroy())}destroyAtlas(e){const n=this.allAtlas.get(e);n&&n.destroy()}setDefaultImage(e,n){return e=Object.assign(e,tm,{atlasReferenceID:n}),e}async draw(e,n){var o;const i=e.id;if(n.disposeResource)return!0;const r=e.resourceReferences.get(n.source);if(r)return n.texture=r.subtexture,!0;n.texture=new Sn,n.texture.isValid=!0,e.resourceReferences.set(n.source,{subtexture:n.texture,count:0});const s=await this.loadImage(n),a=n.texture;if(s&&nm(a)){const c=new te({bottom:a.pixelHeight,left:0,right:a.pixelWidth,top:0}),u={data:a,bounds:c};u.bounds.width+=0,u.bounds.height+=0;let l=e.packing,h=l.insert(u);if(!h){if(!this.repackResources(e))return console.error("Repacking the atlas failed. Some resources may be in an undefined state. Consider making another atlas."),!1;l=e.packing,h=l.insert(u)}return h?(h.data=a,Qe.applyToSubTexture(l,h,a,{top:.5,left:.5,right:.5,bottom:.5}),a.texture=e.texture||null,a.source=s,a.atlasRegion={...h.bounds,y:e.height-h.bounds.y-h.bounds.height},(o=e.texture)==null||o.update(s,a.atlasRegion),s instanceof HTMLVideoElement&&(a.video={monitor:new em(s,a)}),!0):(console.error("Could not fit resource into atlas",n),n.texture=this.setDefaultImage(a,i),!1)}else return a&&!a.isValid?nd("Resource was invalidated during load:",n):console.error("Could not load resource:",n),n.texture&&(n.texture=this.setDefaultImage(n.texture,i)),!1}getAtlasTexture(e){return this.allAtlas.get(e)}async loadImage(e){const n=e.texture||new Sn,i=e.source;if(e.texture=n,e.texture.isValid===!1)return null;if(i instanceof HTMLImageElement){let r=await new Promise(s=>{if(!(i instanceof HTMLImageElement))return;const a=i;if(a.width&&a.height){Ri.calculateImageSize(a),n.pixelWidth=a.width,n.pixelHeight=a.height,n.aspectRatio=a.width/a.height,s(a);return}a?(a.onload=function(){n.pixelWidth=a.width,n.pixelHeight=a.height,n.aspectRatio=a.width/a.height,a.onload=null,s(a)},a.onerror=function(){console.error("Error generating Image element for source:",i),a.onload=null,s(null)}):s(null)});return r&&e.rasterizationScale!==void 0&&e.rasterizationScale!==1&&(r=await Ri.resizeImage(r,e.rasterizationScale||1)),r}else{if(i instanceof HTMLVideoElement)return i.videoHeight===0||i.videoWidth===0?(console.warn("Video requests to the atlas manager MUST have the video completely loaded and ready for loading","There are too many caveats to automate video loading at this low of a level to have it prepped properly for","use in the texture for all browsers. Consider handling video resources at the layer level to have them","prepped for use."),null):(n.pixelWidth=i.videoWidth,n.pixelHeight=i.videoHeight,n.aspectRatio=i.videoWidth/i.videoHeight,i);if(En(i)){const r=i;let s=await new Promise(a=>{const o=new Image;o.onload=function(){n.pixelWidth=o.width,n.pixelHeight=o.height,n.aspectRatio=o.width/o.height,o.onload=null,a(o)},o.onerror=function(){console.error("Error generating Image element for source:",i),a(null)},o.crossOrigin="anonymous",o.src=r});return s&&e.rasterizationScale!==void 0&&e.rasterizationScale!==1&&(s=await Ri.resizeImage(s,e.rasterizationScale||1)),s}else{let r=i;return r&&e.rasterizationScale!==void 0&&e.rasterizationScale!==1&&(r=await Ri.resizeImage(r,e.rasterizationScale||1)),r}}}repackResources(e){if(!this.renderer)return console.warn("Attempted to repack resources for an atlas, but no renderer has been specified for this manager yet."),!1;const n=[e.packing],i=[];let r=0;const s=new Map;for(;r<n.length;){const b=n[r];r++,b.data&&b.data.texture&&(i.push(b),s.set(b.bounds,new te(b.bounds))),b.child[0]&&n.push(b.child[0]),b.child[1]&&n.push(b.child[1])}if(i.sort((b,A)=>Math.max(A.bounds.width,A.bounds.height)-Math.max(b.bounds.width,b.bounds.height)),i.length<=0)return e.packing=new Qe(0,0,e.width,e.height),!0;if(!e.texture)return console.warn("Attempted to repack resources for an atlas with no texture."),!1;const a=new ie(e.texture);a.data={buffer:new Uint8Array(e.width*e.height*4),width:e.width,height:e.height};const o=new Qe(0,0,e.width,e.height);let c=!1;for(let b=0,A=i.length;b<A;++b){const R=i[b];if(!R.data){console.warn("Attempted to repack a node with no valid data.");continue}R.bounds.x=0,R.bounds.y=0;const N=o.insert({bounds:R.bounds,data:R.data});if(!N){console.warn("When repacking the atlas, an existing node was unable to be repacked",R),c=!0;continue}Qe.applyToSubTexture(o,N,R.data)}if(c)return!1;const u=new Float32Array(i.length*2*6),l=new Float32Array(i.length*2*6),h=new Sn;for(let b=0,A=i.length;b<A;++b){const R=i[b],N=s.get(R.bounds),I=R.data;if(!N||!I){console.warn("While repacking there was an issue finding the previous bounds and the next texture to use",N,I);continue}Qe.applyToSubTexture(o,N,h);const S=b*2*6;u[S]=I.atlasTL[0]*2-1,u[S+1]=I.atlasTL[1]*2-1,u[S+2]=I.atlasTR[0]*2-1,u[S+3]=I.atlasTR[1]*2-1,u[S+4]=I.atlasBL[0]*2-1,u[S+5]=I.atlasBL[1]*2-1,u[S+6]=I.atlasTR[0]*2-1,u[S+7]=I.atlasTR[1]*2-1,u[S+8]=I.atlasBR[0]*2-1,u[S+9]=I.atlasBR[1]*2-1,u[S+10]=I.atlasBL[0]*2-1,u[S+11]=I.atlasBL[1]*2-1,l[S]=h.atlasTL[0],l[S+1]=h.atlasTL[1],l[S+2]=h.atlasTR[0],l[S+3]=h.atlasTR[1],l[S+4]=h.atlasBL[0],l[S+5]=h.atlasBL[1],l[S+6]=h.atlasTR[0],l[S+7]=h.atlasTR[1],l[S+8]=h.atlasBR[0],l[S+9]=h.atlasBR[1],l[S+10]=h.atlasBL[0],l[S+11]=h.atlasBL[1],I.texture=a}const f=new $n,p=new yn(u,2),g=new yn(l,2);f.addAttribute("position",p),f.addAttribute("texCoord",g);const m=new Hn({buffers:{color:{buffer:a,outputType:0}},retainTextureTargets:!0}),T=new yr({culling:d.GLSettings.Material.CullSide.NONE,uniforms:{texture:{type:be.TEXTURE,value:e.texture}},fragmentShader:new Map([[m,{outputNames:[],outputTypes:[0],source:`
          precision highp float;

          uniform sampler2D texture;
          varying vec2 _texCoord;

          void main() {
            gl_FragColor = texture2D(texture, _texCoord);
          }
        `}]]),vertexShader:`
        precision highp float;

        attribute vec2 position;
        attribute vec2 texCoord;
        varying vec2 _texCoord;

        void main() {
          _texCoord = texCoord;
          gl_Position = vec4(position, 0.0, 1.0);
        }
      `}),w=new Bo("__atlas_manager__",f,T);w.vertexCount=i.length*6,w.drawMode=d.GLSettings.Model.DrawMode.TRIANGLES;const y=new Ms;return y.add(w),this.renderer.setRenderTarget(m),this.renderer.setViewport(this.renderer.getFullViewport()),this.renderer.setScissor(this.renderer.getFullViewport()),this.renderer.render(y,m),T.dispose(),f.destroy(),m.dispose(),e.texture.destroy(),e.texture=a,e.packing=o,!0}async updateAtlas(e,n){const i=this.allAtlas.get(e);if(i){for(const r of n)r.disposeResource||await this.draw(i,r);for(let r=0,s=n.length;r<s;++r){const a=n[r];a.disposeResource?i.stopUsingResource(a):i.useResource(a)}i.resolveResources()}else console.warn("Can not update non-existing atlas:",e,"These resources will not be loaded:",n);return i}}const im=Ie("performance");class rd{setDeclaration(e,n,i,r){e.has(n)&&im(`%s: Overriding declaration %s
Setting new value: %s`,r||"Expand IO Declarations",n,i),e.set(n,i)}}class $r extends rd{expand(e,n,i,r){return{instanceAttributes:[],uniforms:[],vertexAttributes:[]}}validate(e,n,i,r){return!0}processHeaderInjection(e,n,i,r,s,a,o){return{injection:""}}processAttributeDestructuring(e,n,i,r,s,a){return""}}const rm="TextureIOExpansion";function sm(t,e,n){return t&&t.resource&&e.getResourceType(t.resource.key())===n&&t.resource.name!==void 0&&t.resource.key!==void 0}class Zs extends $r{constructor(e,n){super(),this.manager=n,this.resourceType=e}expand(e,n,i,r){const s=this.manager,a=[],o=new Map;n.forEach(l=>{if(sm(l,this.manager.router,this.resourceType)){l.size===void 0&&(l.size=C.FOUR);const h=l.resource.shaderInjection||x.FRAGMENT,f=o.get(l.resource.name);f?o.set(l.resource.name,[f[0]||h===x.VERTEX||h===x.ALL,f[1]||h===x.FRAGMENT||h===x.ALL]):(a.push(l),o.set(l.resource.name,[h===x.VERTEX||h===x.ALL,h===x.FRAGMENT||h===x.ALL]))}});const c=a.map(l=>{let h=x.FRAGMENT;if(l.resource){const f=o.get(l.resource.name);f&&(h=f[0]&&f[1]&&x.ALL||f[0]&&!f[1]&&x.VERTEX||!f[0]&&f[1]&&x.FRAGMENT||h)}return[{name:l.resource.name,shaderInjection:h,size:E.TEXTURE,update:()=>{const f=s.getResource(l.resource.key());return f&&f.texture||ie.emptyTexture}},{name:`${l.resource.name}_size`,shaderInjection:h,size:E.TWO,update:()=>{const f=s.getResource(l.resource.key());if(f){const p=f.texture;if(p&&p.data){const{width:g,height:m}=p.data;return[g||1,m||1]}}return[1,1]}}]}),u=[];return c.forEach(l=>l.forEach(h=>u.push(h))),{instanceAttributes:[],vertexAttributes:[],uniforms:u}}validate(e,n,i,r){let s=!1;return n.forEach(a=>{a.easing&&a.resource&&(console.warn("An instance attribute can not have both easing and resource properties. Undefined behavior will occur."),console.warn(a),s=!0)}),!s}processHeaderInjection(e,n,i,r,s,a,o){const c={injection:""};for(let u=0,l=o.length;u<l;++u){const h=o[u],f=h.shaderInjection||x.VERTEX;h.size===E.TEXTURE&&f===e&&this.setDeclaration(n,h.name,`uniform sampler2D ${h.name};
`,rm)}return c}}class sd extends Qi{constructor(e){super(),this.resources=new Map,this.requestQueue=new Map,this.requestLookup=new Map,this.atlasManager=e&&e.atlasManager||new id}get webGLRenderer(){return this._webGLRenderer}set webGLRenderer(e){this._webGLRenderer=e,this.atlasManager.renderer=e}async dequeueRequests(){let e=!1;const n=[];this.requestQueue.forEach((i,r)=>{n.push([r,i])}),this.requestQueue.clear();for(const[i,r]of n)if(r.length>0){e=!0;const s=r.slice(0);r.length=0,await this.atlasManager.updateAtlas(i,s);const a=this.requestLookup.get(i);if(a){const o=new Set;s.forEach(c=>{const u=a.get(c);if(a.delete(c),u&&!c.disposeResource)for(let l=0,h=u.length;l<h;++l){const[f,p]=u[l];f.managesInstance(p)&&(p.active=!0),o.add(p)}}),kr(()=>{o.forEach(c=>{c.active=!0,c.resourceTrigger()})})}}return e}destroy(){this.atlasManager.destroy()}destroyResource(e){this.resources.get(e.key)&&(this.atlasManager.destroyAtlas(e.key),this.resources.delete(e.key))}getAtlasTexture(e){const n=this.atlasManager.getAtlasTexture(e);return n&&n.texture||null}getResource(e){return this.resources.get(e)||null}getIOExpansion(){return[new Zs(le.ATLAS,this)]}async initResource(e){if(_c(e)){const n=await this.atlasManager.createAtlas(e);this.resources.set(e.key,n)}}request(e,n,i,r){const s=i.key||"",a=i.texture;if(a)return ti(a);let o=this.requestLookup.get(s);if(o){const u=o.get(i);if(u)return u.push([e,n]),n.active=!1,ti(i.texture)}else o=new Map,this.requestLookup.set(s,o);i.disposeResource||(n.active=!1);let c=this.requestQueue.get(s);return c||(c=[],this.requestQueue.set(s,c)),c.push(i),o.set(i,[[e,n]]),ti(a)}updateResource(e){_c(e)}}const am=new Image;function Yi(t){return{type:le.ATLAS,source:am,...t}}class ad extends Qi{constructor(){super(...arguments),this.resources=new Map}async dequeueRequests(){return!1}destroy(){this.resources.forEach(e=>e.destroy()),this.resources.clear()}getIOExpansion(){return[new Zs(le.TEXTURE,this)]}getResource(e){return this.resources.get(e)||null}destroyResource(e){const n=this.resources.get(e.key);n&&(n.destroy(),this.resources.delete(e.key))}async initResource(e){let n=this.resources.get(e.key);if(n){console.warn("Attempted to generate a RenderTexture that already exists for key",e.key);return}n=new Ec(e,this.webGLRenderer),this.resources.set(e.key,n)}request(e,n,i,r){const s=this.resources.get(i.key);return s?(i.texture=s.texture,[0,0,1,1]):[0,0,0,0]}resize(){const e=new Map;this.resources.forEach((n,i)=>{n.width>lt.SCREEN&&n.height>lt.SCREEN||(n.texture.destroy(),n=new Ec(n,this.webGLRenderer),e.set(i,n))}),e.forEach((n,i)=>this.resources.set(i,n))}updateResource(e){this.resources.get(e.key)&&console.warn("UPDATING AN EXISTING RENDER TEXTURE IS NOT SUPPORTED YET")}}function jr(t){return{type:le.TEXTURE,...t}}const{ceil:om,max:od,log2:cm,pow:lm,sqrt:um}=Math,at=[-1,-1];function hm(t,e){const{width:n,height:i}=t;let r;const s=[],a=[];for(let o=0;o<n;++o){s[o]=[],a[o]=[];for(let c=0;c<i;++c){const u=c*(n*4)+o*4;r=e[u+3],r?(s[o][c]=[o,c],a[o][c]=at):(s[o][c]=at,a[o][c]=[o,c])}}return{seed:s,inverse:a}}function dm(t){const e=[];for(let n=0,i=t.length;n<i;++n)e[n]=[];return e}function cd(t,e,n=!1){const i=n?-1:1;let r,s,a,o;const c=[];let u=-1;for(let l=0,h=t.length;l<h;++l){const f=t[l];c[l]=[];for(let p=0,g=f.length;p<g;++p)r=f[p],r===e?o=256:(s=[l,p],a=ye(r,s),o=um(Di(a,a))),c[l][p]=o,u=od(o,u)}for(let l=0,h=t.length;l<h;++l){const f=t[l];for(let p=0,g=f.length;p<g;++p)o=c[l][p],c[l][p]=o/u*255*i}return c}function fm(t,e,n,i){let r;const s=cd(t,n,!0),a=cd(e,n,!1),o=s.length,c=s;for(let u=0,l=s.length;u<l;++u){const h=s[u],f=a[u];for(let p=0,g=h.length;p<g;++p){const m=h[p],T=f[p];h[p]=m+T}}for(let u=0,l=c.length;u<l;++u){const h=c[u];for(let f=0,p=h.length;f<p;++f){r=h[f];const g=f*(o*4)+u*4;i[g]=r,i[g+1]=r,i[g+2]=r,i[g+3]=255}}}function ld(t,e){const n=t.length,i=t[0].length;let r=dm(t),s=t,a,o,c,u,l,h,f,p,g;for(let m=0;m<e;++m){const T=r;r=s,s=T;const w=lm(2,e-m-1);for(f=0;f<n;++f)for(p=0;p<i;++p){for(a=[f,p],c=[(r[f-w]||[])[p-w]||at,(r[f]||[])[p-w]||at,(r[f+w]||[])[p-w]||at,(r[f-w]||[])[p]||at,(r[f]||[])[p]||at,(r[f+w]||[])[p]||at,(r[f-w]||[])[p+w]||at,(r[f]||[])[p+w]||at,(r[f+w]||[])[p+w]||at],l=0,u=Number.MAX_VALUE,g=0;g<9;++g){const y=c[g];y!==at&&(o=ye(y,a),h=Di(o,o),h<u&&(u=h,l=g))}s[f][p]=c[l]}}return s}function pm(t,e=fm){const{width:n,height:i}=t,r=t.getContext("2d");if(!r)return;const s=r.getImageData(0,0,n,i).data,a=od(n,i),o=om(cm(a)),c=hm(t,s),u=ld(c.seed,o),l=ld(c.inverse,o),h=new ImageData(n,i);e(u,l,at,h.data),r.putImageData(h,0,0)}function gm(t){}const Js=Ie("performance");var ea=(t=>(t[t.BITMAP=0]="BITMAP",t[t.SDF=1]="SDF",t[t.MSDF=2]="MSDF",t))(ea||{});class ud extends yi{constructor(e){super(e),this.dynamic=!1,this.glyphCount=0,this.glyphMap={},this.kerning={},this.spaceWidth=0,this.type=le.FONT,this.dynamic=e.dynamic||!1,this.fontSource=e.fontSource,e.characters&&e.characters.forEach(i=>{this.doRegisterGlyph(i[0],i[1])});const n=e.fontMapSize?e.fontMapSize:[lt._1024,lt._1024];this.makeGlyphTypeTextureSettings(e.glyphType),this.createTexture(n),this.packing=new Qe(0,0,n[0],n[1]),this.addCachedKerning()}get fontString(){return`${this.fontSource.size}px ${this.fontSource.family}`}getKerningCacheName(){return`__deltav_kerning_cache_${this.fontSource.family}__`}addCachedKerning(){if(this.fontSource.localKerningCache){const e=localStorage.getItem(this.getKerningCacheName());if(e){Js("Loading cached kerning items:",this.getKerningCacheName());try{const n=JSON.parse(e);let i=0;for(const r in n){let s=typeof r=="string"&&r.length===1;if(!s)continue;const a=n[r],o=this.kerning[r]||{};this.kerning[r]=o;for(const c in a)s=typeof r=="string"&&r.length===1,s&&(o[c]=a[c],i++)}Js("Found kerning items in the cache!","Count:",i)}catch{}}}}addKerning(e){let n=!1;for(const i in e){const r=e[i],s=this.kerning[i]||{};this.kerning[i]||(n=!0),this.kerning[i]=s;for(const a in r)s[a]||(n=!0),s[a]=r[a]}if(n&&this.fontSource.localKerningCache)try{Js("Storing kerning info in cache...");const i=JSON.stringify(this.kerning);localStorage.setItem(this.getKerningCacheName(),i)}catch{Js("Could not cache kerning info")}}createTexture(e){if(this.texture)return;let n;this.textureSettings?n={generateMipMaps:!0,premultiplyAlpha:!0,...this.textureSettings}:n={generateMipMaps:!0,premultiplyAlpha:!0},this.texture=new ie({data:{width:e[0],height:e[1],buffer:null},...n})}destroy(){var e;(e=this.texture)==null||e.destroy()}doRegisterGlyph(e,n){const i=e[0];this.glyphMap[i]?console.warn("A Glyph is already registered with a rendering"):this.glyphMap[i]=n}findMissingCharacters(e){const n=new Set;let i="";for(let r=0,s=e.length;r<s;++r){const a=e[r];!this.glyphMap[a]&&!n.has(a)&&(n.add(a),i+=a)}return i}getGlyphTexture(e){return this.glyphMap[e[0]]||null}getGlyphKerning(e,n){const i=this.kerning[e];return i?i[n]||[0,0]:[0,0]}getGlyphWidth(e,n,i){const r=e.positions[n],s=e.positions[i];if(!n||!i)return 0;const a=this.glyphMap[e.glyphs[i]];return a?s[0]+a.pixelWidth-r[0]:0}async getTruncatedLayout(e,n,i,r,s,a){if(e.size[0]>i){let o="",c=0;for(let g=0,m=n.length;g<m;++g)c+=this.glyphMap[n[g]].pixelWidth;if(c>i)return{fontScale:1,glyphs:"",positions:[],size:[0,0],text:""};let u=0,l=e.positions.length,h=0,f=0,p="";for(;u!==l;){if(h=Math.floor((l-u)/2)+u,p=e.glyphs[h],f=e.positions[h][0]+this.glyphMap[p].pixelWidth+c,f>i)l=h;else if(f<i)u=h;else break;if(Math.abs(u-l)<=1){if(f<i)break;for(;f>i&&h>=0;)h--,f=e.positions[h][0]+this.glyphMap[p].pixelWidth+c;break}}if(f=e.positions[h][0]+this.glyphMap[p].pixelWidth+c,f<i){let g=0,m=0;for(let y=0,b=e.text.length;y<b&&g<=h;++y){const A=e.text[y];m++,pi(A)||g++}const T=e.text[m-1];let w;for(let y=0,b=n.length;y<b;++y)if(!pi(n[y])){w=n[y];break}if(T&&w&&!this.kerning[T][w]){const y=await a.estimateKerning([T+w],this.fontString,this.fontSource.size,this.kerning,!1,this.fontSource.embed);this.addKerning(y.pairs)}o=`${e.text.substr(0,m)}${n}`}else o=n;return this.getStringLayout(o,r,s)}return e}getStringWidth(e,n,i){const r=e.text;let s=0,a=r.length;if(typeof n=="string"){const h=r.indexOf(n);if(h<0)return 0;s=h,a=s+n.length}else s=n;i!==void 0&&(a=i);let o=0;const c=Math.min(r.length,s),u=Math.min(r.length,a);for(;o<c;++o)pi(r[o])&&(s--,a--);for(;o<u;++o)pi(r[o])&&a--;const l=this.glyphMap[e.text[a]||""];return l?(e.positions[a]||[0,0])[0]-(e.positions[s]||[0,0])[0]+l.pixelWidth:0}getStringLayout(e,n,i){const r=[];let s="";const a=n/this.fontSource.size;let o=Number.MAX_SAFE_INTEGER,c=0,u=0,l=[0,0];const h=this.spaceWidth;let f=0,p="",g,m;for(let y=0,b=e.length;y<b;++y){const A=e[y];if(pi(A)){f++;continue}g=[0,0],p&&(g=this.kerning[p][A]||[0,0]),l=wn(wn(l,Re(g,a)),[f*h*a+(y===0?0:i),0]),r.push([l[0],l[1]]),s+=A,m=this.glyphMap[A],o=Math.min(l[1],o),c=Math.max(l[1]+m.pixelHeight*a,c),p=A,u=l[0]+m.pixelWidth*a,f=0}const T=c-o,w=[u,T];for(let y=0,b=r.length;y<b;++y)l=r[y],l[1]-=o;return{fontScale:a,glyphs:s,positions:r,size:w,text:e}}makeGlyphTypeTextureSettings(e){switch(e){case 0:this.textureSettings={magFilter:d.GLSettings.Texture.TextureMagFilter.Linear,minFilter:d.GLSettings.Texture.TextureMinFilter.LinearMipMapLinear,internalFormat:d.GLSettings.Texture.TexelDataType.LuminanceAlpha,format:d.GLSettings.Texture.TexelDataType.LuminanceAlpha};break;case 1:this.textureSettings={magFilter:d.GLSettings.Texture.TextureMagFilter.Linear,minFilter:d.GLSettings.Texture.TextureMinFilter.Linear,internalFormat:d.GLSettings.Texture.TexelDataType.Luminance,format:d.GLSettings.Texture.TexelDataType.Luminance};break;case 2:this.textureSettings={magFilter:d.GLSettings.Texture.TextureMagFilter.Linear,minFilter:d.GLSettings.Texture.TextureMinFilter.Linear,internalFormat:d.GLSettings.Texture.TexelDataType.RGB,format:d.GLSettings.Texture.TexelDataType.RGB};break}}registerGlyph(e,n){this.dynamic?this.doRegisterGlyph(e,n):console.warn("Attempted to register a new glyph with a non-dynamic FontMap")}supportsKerning(e){for(let n=1,i=e.length;n<i;++n){const r=e[n],s=e[n-1];if(this.kerning[s]){if(!this.kerning[s][r])return!1}else return!1}return!0}}const{min:hd,max:ta}=Math,xi=document.createElement("canvas");let Mn;function mm(t){const{width:e,height:n}=t.canvas,i=t.getImageData(0,0,e,n).data;let r,s=!1,a=Number.MAX_SAFE_INTEGER,o=Number.MAX_SAFE_INTEGER,c=Number.MIN_SAFE_INTEGER,u=Number.MIN_SAFE_INTEGER;for(let l=0;l<e;++l)for(let h=0;h<n;++h){const f=h*(e*4)+l*4;r=i[f],r>0&&(s=!0,a=hd(a,h),o=hd(o,l),c=ta(c,l),u=ta(u,h))}return s?(a-=1,u+=2,c+=2,o-=1,a=ta(a,0),o=ta(o,0),{minX:o,minY:a,maxX:c,maxY:u}):null}function Rc(t,e,n,i){if(t=t[0],(xi.width<e||xi.height<n)&&(xi.width=e,xi.height=n),!Mn){const c=xi.getContext("2d",{willReadFrequently:!0});if(c)Mn=c;else return null}Mn.clearRect(0,0,xi.width,xi.height),Mn.font=i,Mn.fillStyle="white",Mn.fillText(t,e/2,n/2);const r=mm(Mn);if(!r)return{data:Mn.getImageData(0,0,1,1),size:[0,0]};const s=r.maxX-r.minX,a=r.maxY-r.minY;return{data:Mn.getImageData(r.minX,r.minY,s,a),size:[s,a]}}const tn=document.createElement("img"),ot=document.createElement("canvas");function vm(t,e,n=400,i="normal",r="woff2"){return`
    @font-face {
      font-family: '${t}';
      src: url('${e}') ${r?`format('${r}')`:""};
      font-weight: ${n};
      font-style: ${i};
    }
  `}async function dd(t,e,n){const i=new ke;if(!tn||!ot)return null;if(n&&e){const h=document.createElementNS(e,"style");h.textContent=n.map(f=>vm(f.familyName,f.source,f.weight,f.style,f.fontType)).join(`
`),t.prepend(h)}const r=new XMLSerializer().serializeToString(t),o="data:image/svg+xml;base64,"+btoa(r);let c=!1;const u=async()=>{if(c)return;c=!0,ot.width=tn.width*window.devicePixelRatio,ot.height=tn.height*window.devicePixelRatio;const h=ot.getContext("2d",{willReadFrequently:!0});if(!h){i.resolve(null);return}h.clearRect(0,0,ot.width,ot.height),h.mozImageSmoothingEnabled=!1,h.webkitImageSmoothingEnabled=!1,h.msImageSmoothingEnabled=!1,h.imageSmoothingEnabled=!1,h.drawImage(tn,0,0,tn.width*window.devicePixelRatio,tn.height*window.devicePixelRatio),i.resolve(h.getImageData(0,0,ot.width,ot.height)),ot.style.position="absolute",ot.style.top="100px",ot.style.left="0px",ot.style.zIndex="9999",ot.id="svg-to-data"};return tn.onload=u,tn.src=o,tn.width>0&&tn.height>0&&u(),await i.promise}const na=Ie("performance"),{floor:xc}=Math;async function wm(t,e,n,i,r){const s="http://www.w3.org/2000/svg",a=L.MAX_TEXTURE_SIZE/window.devicePixelRatio,o=e*2,c=e*1.3,u=xc(a/o),l=document.createElementNS(s,"svg");l.setAttribute("width",`${a}px`),l.style.font=t,l.style.fontFamily="RedHatDisplay",l.style.position="relative",l.style.left="0px",l.style.top="0px";const h=[],f=Math.floor(a/c);let p=0,g=0,m=0,T,w,y=0;for(;g<n.all.length;){const D=document.createElementNS(s,"g");T=D,p=Math.floor(h.length/f),D.setAttribute("transform",`translate(0, ${(h.length-p*f)*c})`),h.push(D);let H=a;for(m=0;m<u&&g<n.all.length;m++){const z=document.createElementNS(s,"text");z.setAttribute("x",`${m*o}`),z.setAttribute("dy","1em");const V=n.all[g];g++;const re=V[0],W=V[1],oe=document.createElementNS(s,"tspan"),Y=document.createElementNS(s,"tspan");oe.setAttribute("fill","#ff0000"),Y.setAttribute("fill","#0000ff"),oe.textContent=re,Y.textContent=W,z.appendChild(oe),z.appendChild(Y),D.appendChild(z),H-=o}if(H>=0){const z=document.createElementNS(s,"text");z.setAttribute("width",`${H}px`),D.appendChild(z),w=z}else w=null;y=H}const b=[];for(let D=0;D<n.all.length;D++)b.push([Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER]);let A=0,R=!1;if(i){const D="M",H=document.createElementNS(s,"text");H.setAttribute("dy","1em"),H.style.width=`${o}`,H.style.height=`${c}`,H.setAttribute("x",`${o*m}`),H.style.font=t;const z=await Rc(D,128,128,t);if(z){A=z.size[0];const V=document.createElementNS(s,"tspan"),re=document.createElementNS(s,"tspan"),W=document.createElementNS(s,"tspan");if(V.setAttribute("fill","#ff0000"),W.setAttribute("fill","#0000ff"),V.textContent=D,W.textContent=D,re.textContent=" ",H.appendChild(V),H.appendChild(re),H.appendChild(W),m<u&&T)T.appendChild(H),y-=o,w&&(w.remove(),y>0&&(T.style.width=`${y}px`,T.appendChild(w)));else{const oe=document.createElement("g");p=Math.floor(h.length/f),oe.setAttribute("transform",`translate(0, ${(h.length-p*f)*c})`),T=oe,T.appendChild(H),h.push(oe),w=document.createElementNS(s,"text"),oe.appendChild(w)}b.push([Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER]),R=!0}}const N=h.length*c,I=Math.ceil(N/a);let S=null;na("Rendering table canvas batches for font kerning analysis",n,h);for(let D=0;D<I;++D){const H=h.splice(0,f),z=H.length*c;for(l.setAttribute("height",`${z}px`);l.lastElementChild;)l.lastElementChild.remove();for(let V=0,re=H.length;V<re;++V){const W=H[V];l.appendChild(W)}if(!S)S=await dd(l,s,r);else{const V=await dd(l,s,r);if(!V){console.warn("Font Renderer: Could not generate image data for analyzing font kerning");continue}const re=new Uint8ClampedArray(S.data.length+V.data.length);re.set(S.data),re.set(V.data,S.data.length),S=new ImageData(re,a*window.devicePixelRatio,S.height+V.height)}}na("Analyzing rendered data",S);const j=o*window.devicePixelRatio,Q=c*window.devicePixelRatio;if(S){const D=S.data;let H,z,V,re,W,oe;for(let Y=0,Le=S.height;Y<Le;Y++)for(let ee=0,Se=S.width;ee<Se;ee++)H=(Se*Y+ee)*4,z=D[H+0],V=D[H+1],re=D[H+2],oe=xc(Y/Q)*u+xc(ee/j),oe<b.length&&(W=b[oe],z>0&&V===0&&re===0&&(ee<W[0]&&(W[0]=ee),Y<W[1]&&(W[1]=Y)),z===0&&V===0&&re>0&&(ee<W[2]&&(W[2]=ee),Y<W[3]&&(W[3]=Y)));if(R){const Y=b.pop();if(Y){const Le=[Y[2]-Y[0],0],ee=Re(Le,1/window.devicePixelRatio);n.spaceWidth=Math.ceil(ee[0])-A}}for(let Y=0,Le=b.length;Y<Le;Y++){const ee=n.all[Y],Se=ee[0],Bn=ee[1],Un=b[Y],Gn=[Un[2]-Un[0],Un[3]-Un[1]],vn=n.pairs[Se];if(vn){const kn=Re(Gn,1/window.devicePixelRatio);vn[Bn]=[Math.ceil(kn[0]),kn[1]]}}}else console.warn("html2canvas did not produce a valid canvas context to analyze");na("Kerning rendering analysis complete",n.pairs)}function Tm(t,e,n){t=t.replace(/\s/g,"");const i=n&&n.all||[],r=n&&n.pairs||{};for(let s=0;s<t.length-1;s++){const a=t[s],o=t[s+1];let c=r[a];c||(c=r[a]={}),(!e[a]||!e[a][o])&&!c[o]&&(c[o]=[0,0],i.push(`${a}${o}`))}return{all:i,pairs:r,spaceWidth:0}}class fd{makeBitmapGlyphs(e,n,i){const r={},s=new Set;for(let o=0,c=e.length;o<c;++o)s.add(e[o]);const a=Array.from(s.values());for(let o=0,c=a.length;o<c;++o){const u=a[o],l=Rc(u,i*2,i*2,n);l?r[u]={glyph:l.data,glyphIndex:o}:console.warn("Unable to render character",u,"to font map for rendering.")}return r}async estimateKerning(e,n,i,r,s,a){const o={all:[],pairs:{},spaceWidth:0};na("Estimating Kerning for",e);for(let c=0,u=e.length;c<u;++c){const l=e[c];Tm(l,r,o)}return(o.all.length>0||s)&&await wm(n,i,o,s,a),o}}var Ai=(t=>(t[t.TEXCOORDS=0]="TEXCOORDS",t[t.IMAGE_SIZE=1]="IMAGE_SIZE",t))(Ai||{});function Si(t){return{type:le.FONT,...t}}function ym(){return".101112131415161718191.202122232425262728292.303132333435363738393.404142434445464748494.505152535455565758595.606162636465666768696.707172737475767778797.808182838485868788898.909192939495969798999.000102030405060708090.$0$1$2$3$4$5$6$7$8$9$%0%1%2%3%4%5%6%7%8%9%-0-1-2-3-4-5-6-7-8-9-+0+1+2+3+4+5+6+7+8+9+)0)1)2)3)4)5)6)7)8)9)(0(1(2(3(4(5(6(7(8(9("}async function bm(t,e){let n=0,i,r;try{if(!e)return;for(const s of e)i=s,n=0,!document.fonts.check(t)&&(n++,r=new FontFace(s.familyName,`url(${s.source})`,{weight:`${s.weight}`,style:s.style}),n++,await r.load(),n++,document.fonts.add(r));await document.fonts.ready}catch(s){switch(console.error("Font embedding Error:"),n){case 0:console.error("Font embedding failed check:",t);break;case 1:console.error("Font embedding failed to create the font face:",i);break;case 2:console.error("Font embedding failed to load the font face:",{fontFace:r,embedding:i});break;case 3:console.error("Font embedding failed to add the font face",{fontFace:r,embedding:i});break}s instanceof Error&&console.error(s.stack||s.message)}}const pd=Ie("performance");var gd=(t=>(t[t._16=16]="_16",t[t._32=32]="_32",t[t._64=64]="_64",t[t._128=128]="_128",t))(gd||{});function Ac(t){return t&&t.type===le.FONT}function Em(t){return t&&t.type===void 0}function Sc(t){return{key:"",type:le.FONT,...t}}class md{constructor(){this.fontMaps=new Map,this.fontRenderer=new fd}async calculateMetrics(e,n){pd("Calculating metrics for requests");const i=this.fontMaps.get(e);if(i)for(let r=0,s=n.length;r<s;++r){const o=n[r].metrics;o&&(o.layout=i.getStringLayout(o.text,o.fontSize,o.letterSpacing),o.maxWidth&&(pd("Calculating truncation for",o.text,o.maxWidth),o.layout=await i.getTruncatedLayout(o.layout,o.truncation||"",o.maxWidth,o.fontSize,o.letterSpacing,this.fontRenderer),o.truncatedText=o.layout.text))}}characterFilterToCharacters(e){const n=new Set;let i="";for(let r=0,s=e.length;r<s;++r){const a=e[r];n.has(a)||(n.add(a),i+=a)}return i}async createFontMap(e){const n=this.characterFilterToCharacters(e.characterFilter||""),i=e.fontSource;let r=ea.SDF;i&&(Em(i)?r=ea.BITMAP:r=i.type||r);const s=new ud({...e,glyphType:r});return await this.updateFontMapCharacters(n,s),this.fontMaps.set(e.key,s),e.fontSource.preload&&this.updateFontMap(e.key,[Si({key:e.key,character:"",kerningPairs:[e.fontSource.preload],metrics:{fontSize:12,text:e.fontSource.preload,letterSpacing:0}})]),s}destroy(){this.fontMaps.forEach(e=>e.destroy())}destroyFontMap(e){const n=this.fontMaps.get(e);n&&n.destroy()}async updateFontMap(e,n){const i=this.fontMaps.get(e);if(!i)return;let r=[];const s=new Set;for(let o=0,c=n.length;o<c;++o){const u=n[o];if(u.character&&s.add(u.character),u.kerningPairs&&(r=r.concat(u.kerningPairs)),u.metrics&&u.metrics.truncation){const l=u.metrics.truncation.replace(/\s/g,"");r.push(l);for(let h=0,f=u.metrics.truncation.length;h<f;++h)s.add(l)}}for(let o=0,c=r.length;o<c;++o)s.add(r[o]);let a="";s.forEach(o=>a+=o),await bm(i.fontString,i.fontSource.embed),await this.updateFontMapCharacters(a,i),await this.updateKerningPairs(r,i);for(let o=0,c=n.length;o<c;++o)n[o].fontMap=i}async updateKerningPairs(e,n){if(!n)return;const i=await this.fontRenderer.estimateKerning(e,n.fontString,n.fontSource.size,n.kerning,!n.spaceWidth,n.fontSource.embed);n.addKerning(i.pairs),n.spaceWidth=n.spaceWidth||i.spaceWidth}async updateFontMapCharacters(e,n){if(!n)return;const i=n.texture,r=n.findMissingCharacters(e);if(r.length<=0)return;const s=this.fontRenderer.makeBitmapGlyphs(r,n.fontString,n.fontSource.size);for(const a in s){const o=s[a];if(i!=null&&i.data){const c=new te({x:0,y:0,width:o.glyph.width,height:o.glyph.height}),u=new Sn,l=n.packing.insert({data:u,bounds:c});if(!l){console.warn("Font map is full and could not pack in any more glyphs");return}Qe.applyToSubTexture(n.packing,l,u,void 0,!0),i.update(o.glyph,{...l.bounds,y:n.packing.bounds.height-l.bounds.y-l.bounds.height}),u?n.registerGlyph(a,u):console.warn("Could not generate a subtexture for the font map registration.")}else console.warn("Can not update font map as the maps texture data is not defined.")}}async getPrerenderedImageData(e,n,i){const r=[];return i.forEach(s=>{let a=e.glyphs[s];if(a||(a=e.errorGlyph),!e.errorGlyph)return console.warn("The prerendered source provided did NOT provide a proper glyph for rendering when a glyph could not be located."),[];const o=new Image;let c;const u=new Promise(l=>c=l);return o.onload=function(){const l=document.createElement("canvas"),h=l.getContext("2d");if(!h)return;l.width=n,l.height=n,h.drawImage(o,0,0,n,n);const f=h.getImageData(0,0,n,n);c(f)},o.onerror=function(){console.warn("There was an issue with loading the glyph data for character:",s),c(null)},o.src=e.glyphs[s],r.push(u),[]}),await Promise.all(r)}}const Hr=Ie("performance");class vd extends Qi{constructor(){super(...arguments),this.requestLookup=new Map,this.requestQueue=new Map,this.resourceLookup=new Map,this.fontManager=new md}async dequeueRequests(){let e=!1;const n=[];this.requestQueue.forEach((i,r)=>{n.push([r,i])}),this.requestQueue.clear();for(let i=0,r=n.length;i<r;++i){const[s,a]=n[i];if(a.length>0){e=!0;const o=a.slice(0);a.length=0,Hr("Processing requests for resource '%s'",s),await this.fontManager.updateFontMap(s,o),await this.fontManager.calculateMetrics(s,o);const c=this.requestLookup.get(s);c?(o.forEach(u=>{const l=c.get(u);if(c.delete(u),l){for(let h=0,f=l.length;h<f;++h){const[p,g]=l[h];p.managesInstance(g)&&(g.active=!0)}kr(()=>{const h=new Set;for(let f=0,p=l.length;f<p;++f){const g=l[f][1];h.has(g)||(h.add(g),g.resourceTrigger())}})}}),Hr("All requests for resource '%s' are processed",s)):Hr("There were no Font requests waiting for completion for resource",s)}}return e}destroy(){this.fontManager.destroy()}destroyResource(e){const n=this.resourceLookup.get(e.key);n&&(this.fontManager.destroyFontMap(n.id),this.resourceLookup.delete(e.key))}getResource(e){return this.resourceLookup.get(e)||null}getIOExpansion(){return[new Zs(le.FONT,this)]}async initResource(e){if(Ac(e)){const n=await this.fontManager.createFontMap(e);n&&this.resourceLookup.set(e.key,n),Hr("Font map created->",n)}}request(e,n,i,r){const s=i,a=s.fontMap;let o=null;if(a)return s.character&&(o=a.getGlyphTexture(s.character)),o?s.fetch===Ai.IMAGE_SIZE?[o.pixelWidth,o.pixelHeight]:ti(o):s.fetch===Ai.IMAGE_SIZE?[0,0]:ti(null);const c=i.key;let u=this.requestLookup.get(c);if(u){const h=u.get(s);if(h)return h.push([e,n]),n.active=!1,s.fetch===Ai.IMAGE_SIZE?[0,0]:ti(o)}else u=new Map,this.requestLookup.set(c,u);n.active=!1;let l=this.requestQueue.get(c);return l||(l=[],this.requestQueue.set(c,l)),l.push(s),u.set(s,[[e,n]]),s.fetch?[0,0]:ti(o)}updateResource(e){if(!Ac(e))return;const n=this.resourceLookup.get(e.key);n&&(rc(e.fontSource,n.fontSource)||Hr("Font resources currently do not update. To update their properties simply destroy and recreate for now."))}}const _m=Ie("performance");class Mc{constructor(){this.managers=new Map,this.resourceKeyToType=new Map}async dequeueRequests(){let e=!1;const n=Array.from(this.managers.values());for(let i=0,r=n.length;i<r;++i){const a=await n[i].dequeueRequests();e=e||a}return e}destroy(){this.managers.forEach(e=>e.destroy()),this.resourceKeyToType.clear(),this.managers.clear(),delete this.webGLRenderer}async destroyResource(e){const n=this.managers.get(e.type);if(!n){console.warn(`A Resource is trying to be destroyed but has no manager to facilitate the operation: ${e.type}`);return}return this.resourceKeyToType.delete(e.key),await n.destroyResource(e)}getIOExpansion(){let e=[];return this.managers.forEach(n=>{e=e.concat(n.getIOExpansion())}),e}getManager(e){const n=this.managers.get(e);return n||(console.warn(`A manager was requested that does not exist for type ${e}`),$h)}getResourceType(e){return this.resourceKeyToType.get(e)}async initResource(e){const n=this.managers.get(e.type);if(!n){console.warn(`A Resource is trying to be created but has no manager to facilitate the operation: ${e.type}`);return}if(this.resourceKeyToType.has(e.key)){console.warn("Detected two resources with identical keys. The duplicate resource will not be generated:",e.key);return}return this.resourceKeyToType.set(e.key,e.type),await n.initResource(e)}request(e,n,i,r){const s=this.managers.get(i.type);return s?s.request(e,n,i,r):(console.warn(`A Layer is requesting a resource for which there is no manager set. Please make sure a Resource Manager is set for resource of type: ${i.type}`),[-1,-1,-1,-1])}resize(){this.managers.forEach(e=>e.resize())}setManager(e,n){this.managers.get(e)&&_m(`A manager was assigned to a resource type: ${e} that overrides another manager already set to that type.`),n.router=this,this.managers.set(e,n),n.webGLRenderer=this.webGLRenderer}setWebGLRenderer(e){this.webGLRenderer=e,this.managers.forEach(n=>n.webGLRenderer=e)}async updateResource(e){const n=this.managers.get(e.type);if(!n){console.warn(`A Resource is trying to be updated but has no manager to facilitate the operation: ${e.type}`);return}return await n.updateResource(e)}}const wd=new Mc,Rm={createFont:Sc,createAtlas:ed,createTexture:bc,createColorBuffer:Pg},xm={textureRequest:jr,atlasRequest:Yi,fontRequest:Si,colorBufferRequest:Tc};function Td(t){const e=t.canvas.height,n=t.canvas.width,r={aspectRatio:n/e,bottom:-e/2,far:1e7,left:-n/2,near:-100,right:n/2,top:e/2,viewSize:e},s=new An({type:xn.ORTHOGRAPHIC,left:r.left,right:r.right,top:r.top,bottom:r.bottom,near:r.near,far:r.far});return s.scale=[1,-1,1],s.position=[0,0,-300],s.update(),{camera:s,viewport:{bottom:0,left:0,right:0,top:0}}}const Am={[E.ONE]:be.FLOAT,[E.TWO]:be.VEC2,[E.THREE]:be.VEC3,[E.FOUR]:be.VEC4,[E.MATRIX3]:be.MATRIX3x3,[E.MATRIX4]:be.MATRIX4x4,[E.FLOAT_ARRAY]:be.FLOAT_ARRAY,[E.TEXTURE]:be.TEXTURE},Sm={[E.ONE]:[0],[E.TWO]:[0,0],[E.THREE]:[0,0,0],[E.FOUR]:[0,0,0,0],[E.MATRIX3]:[0,0,0,0,0,0,0,0,0],[E.MATRIX4]:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};function Mm(t){return{type:Am[t.size],value:Sm[t.size]}}function yd(t,e,n,i,r){const s=t.getMaterialOptions(),a=new Map;n.forEach((c,u)=>{a.set(u.renderTarget||null,c)}),Object.assign(s,t.props.materialOptions||{}),s.vertexShader=e,s.fragmentShader=a,s.name=t.id,s.uniforms={};for(let c=0,u=i.length;c<u;++c){const l=i[c],h=Mm(l);s.uniforms[l.name]=h}for(let c=0,u=r.length;c<u;++c){const l=r[c];s.uniforms[l.name]={type:l.type,value:l.value}}return new yr(s)}function Im(t){return!Array.isArray(t[0])}function bd(t,e,n,i){const r=[];(t.bufferType===xe.INSTANCE_ATTRIBUTE||t.bufferType===xe.INSTANCE_ATTRIBUTE_PACKING)&&(e=1);for(let h=0,f=n.length;h<f;++h){const p=n[h];r.push(new Float32Array(p.size*i*e))}const s=n.length;let a,o,c,u=!1;for(let h=0,f=i;h<f;++h)for(let p=0;p<s;++p)if(o=n[p],a=r[p],c=o.update(h),Im(c))for(let g=h*o.size,m=g+o.size,T=0;g<m;++g,++T)a[g]=c[T];else u=!0;u&&console.warn("A vertex buffer updating method should not use arrays of arrays of numbers.");for(let h=0,f=n.length;h<f;++h){const g=n[h].size*i;for(let m=1,T=e;m<T;++m)r[h].copyWithin(g*m,0,g)}if(t.bufferType===xe.UNIFORM){const h=r[0];for(let f=0,p=e;f<p;++f){const g=f*i;for(let m=0;m<i;++m)h[m+g]=f}}const l=new $n;for(let h=0,f=n.length;h<f;++h){const p=n[h],g=new yn(r[h],p.size);p.materialAttribute=g,l.addAttribute(p.name,g)}return l}function ia(t,e,n,i){const r=new Bo(t,e,n);return r.drawMode=i||d.GLSettings.Model.DrawMode.TRIANGLE_STRIP,r}const ni="EasingIOExpansion",{abs:Cm,max:Lm}=Math,Om={duration:0,start:[0],end:[0],startTime:0},Ed={1:"float",2:"vec2",3:"vec3",4:"vec4",9:"mat3",16:"mat4",99:"vec4"},Ic={easingMethod:"easingMethod",T:"T"};function Nm(t){return!!t&&t.easing&&t.size!==void 0&&t.size<=4}function Pm(t){return t}class _d extends $r{constructor(){super(...arguments),this.baseAttributeName=new Map}expand(e,n,i,r){const s=new Set,a=[],o=[];for(const u of n)Nm(u)&&a.push(u);const c={};e.easingId=c;for(let u=0,l=a.length;u<l;++u){const h=a[u],{cpu:f,loop:p,uid:g}=h.easing,{name:m,size:T,update:w}=h,y=g;this.baseAttributeName.set(h,h.name),h.name=`_${h.name}_end`,c[h.name]=y,s.has(y)&&console.error("Undefined behavior occurs if you reuse an IAutoEasingMethod. Please ensure you are using uid() from the util to give the IAutoEasingMethod its uid, or just use the default provided methods"),s.add(y);const b={values:Om};let A,R,N,I,S,j,Q,D,H,z,V,re,W;h.update=ee=>{if(H=e.surface.frameMetrics,R=h.easing.delay,N=h.easing.duration,Q=w(ee),D=H.currentTime,ee.easing=re=ee.easing||new Map,z=re.get(y),!V||!z?(V=B(Q),z=new jh({duration:N,end:V.copy(Q),start:V.copy(Q),startTime:D}),re.set(y,z)):ee.reactivate&&(V.copy(Q,z.end),V.copy(Q,z.end),z.startTime=D),S=z,I=N,A=R,S.isTimeSet&&(I=S.duration||N,A=S.delay||0),!S.isManualStart){switch(j=1,p){case Yt.CONTINUOUS:j=(D-S.startTime)/I,W=!0;break;case Yt.REPEAT:j=(D-S.startTime)/I%1,W=!0;break;case Yt.REFLECT:{const Se=(D-S.startTime)/I;j=Cm(Se/2%1-.5)*2,W=!0;break}case Yt.NONE:default:j=(D-S.startTime)/I,W=!1;break}S.start=f(S.start,S.end,j,S.start)}return S.startTime=D+A,V.copy(Q,S.end),b.values=S,e.animationEndTime=Lm(e.animationEndTime,S.startTime+I+H.frameDuration),e.alwaysDraw=W,Q},h.childAttributes=h.childAttributes||[];const oe={name:`_${m}_start`,parentAttribute:h,size:T,update:ee=>b.values.start};h.childAttributes.push(oe),o.push(oe);const Y={name:`_${m}_start_time`,parentAttribute:h,size:C.ONE,update:ee=>[b.values.startTime]};h.childAttributes.push(Y),o.push(Y);const Le={name:`_${m}_duration`,parentAttribute:h,size:C.ONE,update:ee=>[b.values.duration]};h.childAttributes.push(Le),o.push(Le)}return{instanceAttributes:o,vertexAttributes:[],uniforms:[]}}validate(e,n,i,r){let s=!1;return n.forEach(a=>{a.easing&&a.resource&&(console.warn("An instance attribute can not have both easing and resource properties. Undefined behavior will occur."),console.warn(a),s=!0),a.easing&&a.size===void 0&&console.warn("An Instance Attribute with easing MUST have a size declared")}),!s}processAttributeDestructuring(e,n,i,r,s,a){const o="";for(let c=0,u=s.length;c<u;++c){const l=s[c];if(!l.easing||!l.size)continue;const h=this.baseAttributeName.get(l);if(!h){console.warn("Could not determine a base name for an easing attribute.");continue}this.baseAttributeName.delete(l);const f=`_${h}_time`,p=`_${h}_duration`,g=`_${h}_start_time`;switch(l.easing.loop){case Yt.CONTINUOUS:{this.setDeclaration(n,f,`  float ${f} = (currentTime - ${g}) / ${p};
`,ni);break}case Yt.REPEAT:{this.setDeclaration(n,f,`  float ${f} = clamp(fract((currentTime - ${g}) / ${p}), 0.0, 1.0);
`,ni);break}case Yt.REFLECT:{const m=`_${h}_timePassed`,T=`_${h}_pingPong`;this.setDeclaration(n,m,`  float ${m} = (currentTime - ${g}) / ${p};
`,ni),this.setDeclaration(n,T,`  float ${T} = abs((fract(${m} / 2.0)) - 0.5) * 2.0;
`,ni),this.setDeclaration(n,f,`  float ${f} = clamp(${T}, 0.0, 1.0);
`,ni);break}case Yt.NONE:default:{this.setDeclaration(n,f,`  float ${f} = clamp((currentTime - ${g}) / ${p}, 0.0, 1.0);
`,ni);break}}this.setDeclaration(n,h,`  ${Ed[l.size]} ${h} = ${l.easing.methodName}(_${h}_start, _${h}_end, _${h}_time);
`,ni)}return o}processHeaderInjection(e,n,i,r,s,a,o){const c={injection:""};if(e!==x.VERTEX)return c;const u=new Map;if(c.injection=`// Auto Easing Methods specified by the layer
`,a.forEach(h=>{if(h.easing&&h.size){let f=u.get(h.easing.methodName);f||(f=new Map,u.set(h.easing.methodName,f)),f.set(h.size,h.easing.gpu)}}),u.size===0)return c.injection="",c;const l={name:"Easing Method Generation",values:[Ic.easingMethod]};return u.forEach((h,f)=>{h.forEach((p,g)=>{const m=Ed[g],T={[Ic.easingMethod]:`${m} ${f}(${m} start, ${m} end, float t)`,[Ic.T]:`${m}`},w=ei({options:T,required:l,shader:p});this.setDeclaration(n,`${m} ${f}`,`${w.shader}
`,ni)})}),c}}const Mi="BasicIOExpansion",Dm=["x","y","z","w"],Ii={[E.ONE]:"float",[E.TWO]:"vec2",[E.THREE]:"vec3",[E.FOUR]:"vec4",[E.MATRIX3]:"mat3",[E.MATRIX4]:"mat4",[E.FLOAT_ARRAY]:"float",[E.VEC4_ARRAY]:"vec4",[E.TEXTURE]:"vec4"};function Rd(t){return t&&t.length}function Fm(t){const e=t.size;if(e===E.FLOAT_ARRAY||e===E.VEC4_ARRAY){const n=t.update(t);if(Rd(n))return`#define ${t.name}_length ${n.length}
`}return""}function Bm(t){const e=t.size;if(e===E.FLOAT_ARRAY||e===E.VEC4_ARRAY){const n=t.update(t);if(Rd(n))return`[${t.name}_length]`}return""}function Um(t,e){return Dm.slice(t,t+e).join("")}class xd extends $r{processAttributeDestructuring(e,n,i,r,s,a){let o="";const c=s.slice(0);switch(e.bufferType){case xe.INSTANCE_ATTRIBUTE:o=this.processDestructuringInstanceAttribute(n,c);break;case xe.INSTANCE_ATTRIBUTE_PACKING:o=this.processDestructuringInstanceAttributePacking(n,c);break}return e.picking.type===X.SINGLE&&(o+=`
// This portion is where the shader assigns the picking color that gets passed to the fragment shader
_picking_color_pass_ = _pickingColor;
`),o}processDestructuringInstanceAttribute(e,n){return""}processDestructuringInstanceAttributePacking(e,n){let i="";return i+=this.processDestructureBlocks(e,n),i}processDestructureBlocks(e,n){const i="";return n.forEach(r=>{const s=r.block||0;r.size===C.MAT4X4?this.setDeclaration(e,r.name,`  ${Ii[r.size]} ${r.name} = mat4(block${s}, block${s+1}, block${s+2}, block${s+3});
`,Mi):r.size===C.FOUR?this.setDeclaration(e,r.name,`  ${Ii[r.size]} ${r.name} = block${s};
`,Mi):this.setDeclaration(e,r.name,`  ${Ii[r.size||1]} ${r.name} = block${s}.${Um(r.blockIndex||0,r.size||1)};
`,Mi)}),i}processHeaderInjection(e,n,i,r,s,a,o){let c={injection:""};e===x.VERTEX&&(c=this.processAttributeHeader(n,i,r,s,a));const u=this.processUniformHeader(n,o,e);return{...c,injection:c.injection+u}}processAttributeHeader(e,n,i,r,s){let o=`// Shader input
`;return o+=this.processVertexAttributes(e,r),n.bufferType===xe.INSTANCE_ATTRIBUTE&&s.length>0&&(o+=this.processInstanceAttributeBufferStrategy(e,s)),n.bufferType===xe.INSTANCE_ATTRIBUTE_PACKING&&s.length>0&&(o+=this.processInstanceAttributePackingBufferStrategy(e,i.instanceMaxBlock)),{injection:o,material:void 0}}processUniformHeader(e,n,i){const r="",s=i||x.VERTEX;return n.forEach(a=>{a.shaderInjection=a.shaderInjection||x.VERTEX,(a.shaderInjection===s||a.shaderInjection===x.ALL)&&this.setDeclaration(e,a.name,`${Fm(a)}uniform ${a.qualifier||""}${a.qualifier?" ":""}${Ii[a.size]} ${a.name}${Bm(a)};
`,Mi)}),r}processInstanceAttributeBufferStrategy(e,n){let i="attribute";return L.SHADERS_3_0&&(i="in"),n.forEach(r=>{this.setDeclaration(e,r.name,`${i} ${Ii[r.size||1]} ${r.qualifier||""}${r.qualifier&&" "||""} ${r.name};
`,Mi)}),""}processInstanceAttributePackingBufferStrategy(e,n){let i="attribute";L.SHADERS_3_0&&(i="in");for(let r=0,s=n+1;r<s;++r)this.setDeclaration(e,`block${r}`,`${i} ${Ii[C.FOUR]} block${r};
`,Mi);return""}processVertexAttributes(e,n){let i="attribute";return L.SHADERS_3_0&&(i="in"),n.forEach(r=>{this.setDeclaration(e,r.name,`${i} ${Ii[r.size]} ${r.qualifier||""}${r.qualifier&&" "||""}${r.name};
`,Mi)}),""}}const Gm=`
  // This is a special injected instance attribute. It lets the system
  // control specific instances ability to draw, which allows the backend
  // system greater control on how it optimizes draw calls and it's buffers.
  if (_active < 0.5) {
    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);

    // Quick exit to prevent any geometry from arising from the instance
    return;
  }

`,km="instanceData",zm="_active",Vm="ActiveIOExpansion";class Ad extends $r{processAttributeDestructuring(e,n,i,r,s,a){const o="";return s.find(c=>c.name===zm)&&this.setDeclaration(n,"__active_attribute_handler__",Gm,Vm),o}}function Wm(t){return t&&t.buffer&&t.buffer.value}function Sd(t){return t&&t.propertyToBufferLocation}class ra{constructor(e,n){this.add=()=>{},this.remove=i=>i,this.layer=e,this.scene=n}changesProcessed(){delete this.changeListContext}incomingChangeList(e){this.changeListContext=e}makeLayerMaterial(){const e=this.layer.shaderIOInfo;return yd(this.layer,e.vs,e.fs,e.uniforms,e.materialUniforms)}}let qi={};function nn(t,e){const n=qi[t]||[e,-1,0];qi[t]=n,n[2]++,clearTimeout(n[1]),n[1]=window.setTimeout(()=>{e(n[2],t),delete qi[t]},1)}function Md(){for(const t in qi){const e=qi[t];clearTimeout(e[1]),e[0](e[2],t)}qi={}}const Ki=Ie("performance"),{max:$m}=Math;function jm(t){return!!(t&&t.buffer&&t.buffer.value)}function Id(t){return Sd(t)}class Cd extends ra{constructor(e,n){super(e,n),this.allBufferLocations={},this.availableLocations=[],this.currentInstancedCount=0,this.instanceToBufferLocation={},this.maxInstancedCount=0,this.attributeToPropertyIds=new Map,this.updateAllPropertyIdList=[],this.activePropertyId=-1,this.currentAvailableLocation=-1,this.remove=i=>{const r=this.instanceToBufferLocation[i.uid];return r&&(delete this.instanceToBufferLocation[i.uid],this.availableLocations.push(r)),i},this.add=this.doAddWithRegistration}changesProcessed(){super.changesProcessed(),this.availableLocations.splice(0,this.currentAvailableLocation+1),this.currentAvailableLocation=-1}doAddWithRegistration(e){je.setObservableMonitor(!0),this.layer.shaderIOInfo.instanceAttributes.forEach(i=>{if(i.parentAttribute)return;i.update(e);const r=je.getObservableMonitorIds(!0);this.attributeToPropertyIds.set(i,[r[r.length-1]]),r.length>1&&Ki("Property has multiple observables. Only the last trigger will be retained as the feature is not complete yet"),i===this.layer.shaderIOInfo.activeAttribute&&(this.activePropertyId=r[0])}),je.setObservableMonitor(!1),this.makeUpdateAllPropertyIdList();const n=this.resizeBuffer();return this.gatherLocationsIntoGroups(n.newLocations,n.growth),this.add=this.doAdd,this.doAdd(e)}doAdd(e){if(this.availableLocations.length<=0||this.currentAvailableLocation>=this.availableLocations.length-1){const i=this.resizeBuffer();this.gatherLocationsIntoGroups(i.newLocations,i.growth)}const n=this.availableLocations[++this.currentAvailableLocation];return n&&this.geometry?(this.instanceToBufferLocation[e.uid]=n,this.currentInstancedCount=this.geometry.maxInstancedCount=$m(this.currentInstancedCount,n.instanceIndex+1),this.model&&(this.model.vertexDrawRange=[0,this.layer.shaderIOInfo.instanceVertexCount],this.model.drawInstances=this.currentInstancedCount,this.layer.shaderIOInfo.instanceVertexCount===0&&(this.model.vertexDrawRange[1]=this.model.drawInstances))):console.error("Add Error: Instance Attribute Buffer Manager failed to pair an instance with a buffer location"),n}destroy(){this.geometry&&this.geometry.destroy(),this.material&&this.material.dispose(),this.scene&&this.scene.container&&this.model&&this.scene.container.remove(this.model)}getBufferLocations(e){return this.instanceToBufferLocation[e.uid]}getActiveAttributePropertyId(){return this.activePropertyId}getUpdateAllPropertyIdList(){return this.updateAllPropertyIdList}managesInstance(e){return this.instanceToBufferLocation[e.uid]!==void 0}makeUpdateAllPropertyIdList(){const e={};this.attributeToPropertyIds.forEach(n=>{e[n[0]]=n[0]}),this.updateAllPropertyIdList=Object.values(e).filter(Boolean)}removeFromScene(){this.scene&&this.scene.container&&this.model&&this.scene.container.remove(this.model),delete this.scene}resizeBuffer(){var r;Ki("Gathering resize growth amount...");const e=this.layer.shaderIOInfo;let n=0;const i=new Map;if(this.changeListContext){n=1e3;for(let s=0,a=this.changeListContext.length;s<a;++s){const o=this.changeListContext[s];switch(o[1]){case Ce.CHANGE:case Ce.INSERT:this.instanceToBufferLocation[o[0].uid]||n++;break}}}if(Ki("BEGIN: Resizing unpacked attribute buffer by %d instances",n),this.geometry){this.geometry.destroy(),this.geometry=new $n;const s=this.maxInstancedCount;for(const a of e.vertexAttributes)a.materialAttribute&&this.geometry.addAttribute(a.name,a.materialAttribute);this.maxInstancedCount+=n,this.attributes=this.attributes||[];for(const a of this.attributes){const o=a.bufferAttribute,c=a.size||0;if(o.data instanceof Float32Array){let u=o.data;u.length<this.maxInstancedCount*c&&(u=new Float32Array(this.maxInstancedCount*c*2),u.set(o.data,0));const l=new yn(u,c,!0,!0);l.setDynamic(!0),a.bufferAttribute=l,this.geometry.addAttribute(a.name,l);let h=i.get(a.name);const f=this.allBufferLocations[a.name]||[];this.allBufferLocations[a.name]=f;for(let T=0,w=f.length;T<w;++T)f[T].buffer.value=u;h||(h=[],i.set(a.name,h));let p,g=h.length;const m=this.maxInstancedCount-s;h.length+=m,f.length+=m;for(let T=s,w=this.maxInstancedCount;T<w;++T,++g)p={attribute:a,buffer:{value:u},instanceIndex:T,range:[T*c,T*c+c]},h[g]=p,f[T]=p}}(r=this.scene)!=null&&r.container&&this.model&&this.scene.container.remove(this.model)}else{this.maxInstancedCount+=n,this.geometry=new $n;for(const s of e.vertexAttributes)s.materialAttribute&&this.geometry.addAttribute(s.name,s.materialAttribute);this.attributes=[];for(const s of e.instanceAttributes){const a=s.size||0,o=new Float32Array(a*this.maxInstancedCount),c=new yn(o,a,!0,!0);c.setDynamic(!0),this.geometry.addAttribute(s.name,c);let u=i.get(s.name);u||(u=[],i.set(s.name,u));const l=this.allBufferLocations[s.name]||[];this.allBufferLocations[s.name]=l;const h=Object.assign({},s,{uid:G(),bufferAttribute:c});for(let f=0;f<this.maxInstancedCount;++f){const p={attribute:h,buffer:{value:o},instanceIndex:f,range:[f*a,f*a+a]};u.push(p),l.push(p)}this.attributes.push(h)}this.geometry.maxInstancedCount=0,this.material=this.makeLayerMaterial();for(let s=0,a=e.uniforms.length;s<a;++s){const o=e.uniforms[s];o.materialUniforms.push(this.material.uniforms[o.name])}}return this.scene&&this.model&&this.scene.container&&this.scene.container.remove(this.model),this.material=this.material||this.makeLayerMaterial(),this.model=ia(this.layer.id,this.geometry,this.material,e.drawMode),this.scene&&this.scene.container&&this.model&&this.scene.container.add(this.model),Ki("COMPLETE: Resizing unpacked attribute buffer"),{growth:n,newLocations:i}}gatherLocationsIntoGroups(e,n){if(this.attributeToPropertyIds.size===0)return;Ki("BEGIN: Unpacked attribute manager grouping new buffer locations");const i=[];this.attributeToPropertyIds.forEach((l,h)=>{i.push({attribute:h,bufferLocationsForAttribute:e.get(h.name)||[],childBufferLocations:(h.childAttributes||[]).map(f=>({location:e.get(f.name)||[],bufferIndex:-1})),ids:l,bufferIndex:-1})});let r,s,a,o,c,u;for(let l=0;l<n;++l){const h={instanceIndex:-1,propertyToBufferLocation:{}};for(let f=0,p=i.length;f<p;++f){if(r=i[f],s=r.attribute,a=r.ids,o=r.bufferLocationsForAttribute,!o){nn("Instance Attribute Buffer Error",(g,m)=>{console.warn(`${m}: There is an error in forming buffer location groups in InstanceAttributeBufferManager. Error count: ${g}`)});continue}if(c=o[++r.bufferIndex],!c){nn("Instance Attribute Buffer Error",(g,m)=>{console.warn(`${m}: There is an error in forming buffer location groups in InstanceAttributeBufferManager. Error count: ${g}`)});continue}if(h.instanceIndex===-1)h.instanceIndex=c.instanceIndex;else if(c.instanceIndex!==h.instanceIndex){nn("Instance Attribute Parallelism Error",(g,m)=>{console.warn(`${m}: A buffer location does not have a matching instance index which means the buffer locations are not in parallel with each other somehow. Error count: ${g}`),console.warn(s.name,c)});continue}if(s.childAttributes){c.childLocations=[];for(let g=0,m=s.childAttributes.length;g<m;++g){const T=r.childBufferLocations[g];if(T){const w=T.location[++T.bufferIndex];w?c.childLocations.push(w):(u=s.childAttributes[g],nn("Instance Attribute Child Attribute Error",(y,b)=>{console.warn(`${b}: A child attribute does not have a buffer location available. Error count: ${y}`),console.warn(`Parent Attribute: ${s.name} Child Attribute: ${u.name}`)}))}}}for(let g=0,m=a.length;g<m;++g)h.propertyToBufferLocation[a[g]]=c}this.availableLocations.push(h)}Ki("COMPLETE: Unpacked attribute buffer manager buffer location grouping"),Md()}getInstanceCount(){return this.maxInstancedCount}}const{max:Hm}=Math,Zi=Ie("performance");class Ld extends ra{constructor(e,n){super(e,n),this.allBufferLocations={},this.availableLocations=[],this.currentInstancedCount=0,this.instanceToBufferLocation={},this.maxInstancedCount=1e3,this.blockSubAttributesLookup=new Map,this.attributeToPropertyIds=new Map,this.updateAllPropertyIdList=[],this.activePropertyId=-1,this.currentAvailableLocation=-1,this.remove=i=>{const r=this.instanceToBufferLocation[i.uid];return r&&(delete this.instanceToBufferLocation[i.uid],this.availableLocations.push(r)),i},this.add=this.doAddWithRegistration}changesProcessed(){super.changesProcessed(),this.availableLocations.splice(0,this.currentAvailableLocation+1),this.currentAvailableLocation=-1}doAddWithRegistration(e){this.layer.shaderIOInfo.instanceAttributes.forEach(i=>{if(i.parentAttribute)return;je.setObservableMonitor(!0),i.update(e);const r=je.getObservableMonitorIds(!0);this.attributeToPropertyIds.set(i,[r[r.length-1]]),r.length>1&&Zi("Property has multiple observables. Only the last trigger will be retained as the feature is not complete yet"),i===this.layer.shaderIOInfo.activeAttribute&&(this.activePropertyId=r[0])}),je.setObservableMonitor(!1),this.makeUpdateAllPropertyIdList();const n=this.resizeBuffer();return this.gatherLocationsIntoGroups(n.newLocations,n.growth),this.add=this.doAdd,this.doAdd(e)}doAdd(e){if(this.availableLocations.length<=0||this.currentAvailableLocation>=this.availableLocations.length-1){const i=this.resizeBuffer();this.gatherLocationsIntoGroups(i.newLocations,i.growth)}const n=this.availableLocations[++this.currentAvailableLocation];return n&&this.geometry?(this.instanceToBufferLocation[e.uid]=n,this.currentInstancedCount=this.geometry.maxInstancedCount=Hm(this.currentInstancedCount,n.instanceIndex+1),this.model&&(this.model.vertexDrawRange=[0,this.layer.shaderIOInfo.instanceVertexCount],this.model.drawInstances=this.currentInstancedCount,this.layer.shaderIOInfo.instanceVertexCount===0&&(this.model.vertexDrawRange[1]=this.model.drawInstances))):console.error("Add Error: Instance Attribute Buffer Manager failed to pair an instance with a buffer location"),n}destroy(){this.geometry&&this.geometry.destroy(),this.material&&this.material.dispose(),this.scene&&this.scene.container&&this.model&&this.scene.container.remove(this.model)}getBufferLocations(e){return this.instanceToBufferLocation[e.uid]}getActiveAttributePropertyId(){return this.activePropertyId}getUpdateAllPropertyIdList(){return this.updateAllPropertyIdList}managesInstance(e){return this.instanceToBufferLocation[e.uid]!==void 0}makeUpdateAllPropertyIdList(){const e={};this.attributeToPropertyIds.forEach(n=>{e[n[0]]=n[0]}),this.updateAllPropertyIdList=Object.values(e).filter(Boolean)}removeFromScene(){this.scene&&this.scene.container&&this.model&&this.scene.container.remove(this.model),delete this.scene}resizeBuffer(){const e=this.layer.shaderIOInfo;let n=0;const i=new Map;if(this.changeListContext){n=1e3;for(let r=0,s=this.changeListContext.length;r<s;++r){const a=this.changeListContext[r];switch(a[1]){case Ce.CHANGE:case Ce.INSERT:this.instanceToBufferLocation[a[0].uid]||n++;break}}}if(Zi("BEGIN: Resizing packed attribute buffer by %d instances",n),this.geometry){Zi(`Info: Vertex packing buffer is being resized for layer ${this.layer.id}`),this.geometry.destroy(),this.geometry=new $n;const r=this.maxInstancedCount;for(const s of e.vertexAttributes)s.materialAttribute&&this.geometry.addAttribute(s.name,s.materialAttribute);this.maxInstancedCount+=n,this.attributes=this.attributes||[],this.blockAttributes=this.blockAttributes||[];for(let s=0,a=this.blockAttributes.length;s<a;++s){const o=this.blockAttributes[s];let c=o.bufferAttribute;const u=o.size||0;if(c.data instanceof Float32Array){let l=c.data;l.length<this.maxInstancedCount*u&&(l=new Float32Array(this.maxInstancedCount*u*2),l.set(c.data,0)),l.set(c.data,0);const h=new yn(l,u,!0,!0);o.bufferAttribute=c=h,this.geometry.addAttribute(o.name,h);const f=this.blockSubAttributesLookup.get(s),p=o.size||0;if(f)for(let g=0,m=f.length;g<m;++g){const T=f[g];let w=i.get(T.name);w||(w=[],i.set(T.name,w));const y=this.allBufferLocations[T.name]||[];this.allBufferLocations[T.name]=y;const b=Object.assign({},T,{uid:G(),packUID:o.packUID,bufferAttribute:c}),A=T.blockIndex||0,R=T.size||1;let N;for(let Q=0,D=y.length;Q<D;++Q)N=y[Q],N.attribute=b,N.buffer.value=l;let I,S=w.length;const j=this.maxInstancedCount-r;w.length+=j,y.length+=j;for(let Q=r;Q<this.maxInstancedCount;++Q,++S)I={attribute:b,block:s,buffer:{value:l},instanceIndex:Q,range:[Q*p+A,Q*p+A+R]},w[S]=I,y[Q]=I}}}}else{this.maxInstancedCount+=n,this.geometry=new $n;for(const a of e.vertexAttributes)a.materialAttribute&&this.geometry.addAttribute(a.name,a.materialAttribute);this.attributes=[],this.blockAttributes=[];const r=new Map,s=new Map;this.blockSubAttributesLookup=s;for(let a=0,o=e.instanceAttributes.length;a<o;++a){const c=e.instanceAttributes[a],u=c.block||0;let l=r.get(u)||0;l=Math.max(l,(c.blockIndex||0)+(c.size||0)),r.set(u,l);let h=s.get(u);h||(h=[],s.set(u,h)),h.push(c)}s.forEach(a=>a.sort((o,c)=>(o.blockIndex||0)-(c.blockIndex||0)));for(let a=0,o=r.size;a<o;++a){const c=r.get(a)||0,u=G();c||console.warn("Instance Attribute Packing Error: The system tried to build an attribute with a size of zero.","These are the attributes used:",e.instanceAttributes,"These are the block sizes calculated",r,"This is the block to attribute lookup generated",s);const l=new Float32Array(c*this.maxInstancedCount),h=new yn(l,c,!0,!0);this.geometry.addAttribute(`block${a}`,h);const f=s.get(a);if(f){for(let p=0,g=f.length;p<g;++p){const m=f[p];let T=i.get(m.name);T||(T=[],i.set(m.name,T));const w=this.allBufferLocations[m.name]||[];this.allBufferLocations[m.name]=w;const y=Object.assign({},m,{uid:a,packUID:u,bufferAttribute:h,size:c}),b=m.blockIndex||0,A=m.size||1;for(let R=0;R<this.maxInstancedCount;++R){const N={attribute:y,block:a,buffer:{value:l},instanceIndex:R,range:[R*c+b,R*c+b+A]};T.push(N),w.push(N)}this.attributes.push(y)}this.blockAttributes.push({uid:G(),packUID:u,bufferAttribute:h,name:`block${a}`,size:c,update:()=>[0]})}else console.warn("Instance Attribute Packing Buffer Error: Somehow there are no attributes associated with a block.","These are the attributes used:",e.instanceAttributes,"These are the block sizes calculated",r,"This is the block to attribute lookup generated",s)}this.geometry.maxInstancedCount=0,this.material=this.makeLayerMaterial();for(let a=0,o=e.uniforms.length;a<o;++a){const c=e.uniforms[a];c.materialUniforms.push(this.material.uniforms[c.name])}}return this.scene&&this.model&&this.scene.container&&this.scene.container.remove(this.model),this.material=this.material||this.makeLayerMaterial(),this.model=ia(this.layer.id,this.geometry,this.material,this.layer.shaderIOInfo.drawMode),this.scene&&this.scene.container&&this.model&&this.scene.container.add(this.model),Zi("COMPLETE: Resizing unpacked attribute buffer"),{growth:n,newLocations:i}}gatherLocationsIntoGroups(e,n){if(this.attributeToPropertyIds.size===0)return;Zi("BEGIN: Packed attribute manager grouping new buffer locations");const i=[];this.attributeToPropertyIds.forEach((r,s)=>{i.push({attribute:s,bufferLocationsForAttribute:e.get(s.name)||[],childBufferLocations:(s.childAttributes||[]).map(a=>({location:e.get(a.name)||[],bufferIndex:-1})),ids:r,bufferIndex:-1})});for(let r=0;r<n;++r){const s={instanceIndex:-1,propertyToBufferLocation:{}};for(let a=0,o=i.length;a<o;++a){const c=i[a],u=c.attribute,l=c.ids,h=c.bufferLocationsForAttribute;if(!h){nn("Instance Attribute Buffer Error",(p,g)=>{console.warn(`${g}: There is an error in forming buffer location groups in InstanceAttributePackingBufferManager. Error count: ${p}`)});continue}const f=h[++c.bufferIndex];if(!f){nn("Instance Attribute Buffer Error",(p,g)=>{console.warn(`${g}: There is an error in forming buffer location groups in InstanceAttributePackingBufferManager. Error count: ${p}`)});continue}if(s.instanceIndex===-1)s.instanceIndex=f.instanceIndex;else if(f.instanceIndex!==s.instanceIndex){nn("Instance Attribute Parallelism Error",(p,g)=>{console.warn(`${g}: A buffer location does not have a matching instance index which means the buffer locations are not in parallel with each other somehow. Error count: ${p}`),console.warn(u.name,f)});continue}if(u.childAttributes){const p=[];for(let g=0,m=u.childAttributes.length;g<m;++g){const T=u.childAttributes[g],w=c.childBufferLocations[g];if(w){const y=w.location[++w.bufferIndex];y?p.push(y):nn("Instance Attribute Child Attribute Error",(b,A)=>{console.warn(`${A}: A child attribute does not have a buffer location available. Error count: ${b}`),console.warn(`Parent Attribute: ${u.name} Child Attribute: ${T.name}`)})}}f.childLocations=p}for(let p=0,g=l.length;p<g;++p){const m=l[p];s.propertyToBufferLocation[m]=f}}this.availableLocations.push(s)}Zi("COMPLETE: Packed attribute buffer manager buffer location grouping"),Md()}getInstanceCount(){return this.maxInstancedCount}}function Od(t){return t&&t.buffer&&t.buffer.value&&t.type===be.VEC4_ARRAY}class Nd extends ra{constructor(e,n){super(e,n),this.buffers=[],this.availableClusters=[],this.instanceToCluster={},this.clusterToBuffer=new Map,this.add=r=>{this.availableClusters.length<=0&&this.makeNewBuffer();const s=this.availableClusters.pop();return s?this.instanceToCluster[r.uid]=s:console.warn("No valid cluster available for instance added to uniform manager."),s},this.remove=r=>{const s=this.instanceToCluster[r.uid];return s&&(delete this.instanceToCluster[r.uid],this.availableClusters.push(s)),r};let i=0;e.shaderIOInfo.instanceAttributes.forEach(r=>{i=Math.max(r.block||0,i)}),this.uniformBlocksPerInstance=i+1}destroy(){this.buffers.forEach(e=>{e.geometry.destroy(),e.material.dispose()})}getBufferLocations(e){return this.instanceToCluster[e.uid]}getActiveAttributePropertyId(){return-1}getInstanceCount(){return-1}getUpdateAllPropertyIdList(){return[]}managesInstance(e){return this.instanceToCluster[e.uid]===void 0}removeFromScene(){const e=this.scene;if(e!=null&&e.container){for(let n=0,i=this.buffers.length;n<i;++n){const r=this.buffers[n];e.container.remove(r.model)}delete this.scene}}setScene(e){if(e.container){for(let n=0,i=this.buffers.length;n<i;++n){const r=this.buffers[n];e.container.add(r.model)}this.scene=e}else console.warn("Can not set a scene that has an undefined container.")}makeNewBuffer(){const e=this.layer.shaderIOInfo,n=new $n;e.vertexAttributes.forEach(l=>{l.materialAttribute&&n.addAttribute(l.name,l.materialAttribute)});const i=this.makeLayerMaterial(),r=ia(this.layer.id,n,i,e.drawMode);r.vertexDrawRange=[0,e.maxInstancesPerBuffer*e.instanceVertexCount];const s={activeInstances:[],clusters:[],firstInstance:0,geometry:n,lastInstance:0,material:i,model:r};this.buffers.push(s);let a=0;const o=km,c=i.uniforms[o];if(Xl(c))c.value=c.value.map(()=>[0,0,0,0]);else{console.warn("Material is utilizing an invalid uniform type for Uniform Buffer Management. Buffering will not be possible.");return}const u=Object.assign({},e.instanceAttributes[0],{bufferAttribute:new yn(new Float32Array(1),1),uid:G()});for(let l=0,h=e.maxInstancesPerBuffer;l<h;++l){const f={attribute:u,buffer:c,instanceIndex:l,range:[a,0]};a+=this.uniformBlocksPerInstance,f.range[1]=a,s.clusters.push(f),this.availableClusters.push(f),this.clusterToBuffer.set(f,s)}for(let l=0,h=e.uniforms.length;l<h;++l){const f=e.uniforms[l];f.materialUniforms.push(i.uniforms[f.name])}this.scene&&this.scene.container&&this.scene.container.add(s.model)}}class Pd{constructor(e,n){this.layer=e,this.bufferManager=n}}const sa=[],{min:Cc,max:Lc}=Math;class Qm extends Pd{constructor(){super(...arguments),this.diffMode=0,this.bufferAttributeUpdateRange={},this.bufferAttributeWillUpdate={},this.updateInstance=this.updateInstancePartial}addInstance(e,n,i,r){if(r)e.changeInstance(e,n,sa,r);else{const s=e.layer.bufferManager.add(n);Id(s)&&(n.active=!0,e.layer.onDiffAdd&&e.layer.onDiffAdd(n),e.updateInstance(e.layer,n,sa,s))}}changeInstance(e,n,i,r){r?e.updateInstance(e.layer,n,i,r):e.addInstance(e,n,sa,r)}removeInstance(e,n,i,r){r&&(n.active=!1,e.layer.onDiffRemove&&e.layer.onDiffRemove(n),e.updateInstance(e.layer,n,sa,r),e.layer.bufferManager.remove(n))}updateInstancePartial(e,n,i,r){const s=r.propertyToBufferLocation,a=this.bufferAttributeUpdateRange;let o,c,u,l,h,f;if(n.active){(i.length===0||n.reactivate)&&(i=this.bufferManager.getUpdateAllPropertyIdList());for(let p=0,g=i.length;p<g;++p)if(o=s[i[p]],!!o&&(h=o.attribute,f=h.packUID||h.uid,c=h.update(n),o.buffer.value.set(c,o.range[0]),u=a[f]||[null,Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER],u[0]=h,u[1]=Cc(o.range[0],u[1]),u[2]=Lc(o.range[1],u[2]),a[f]=u,o.childLocations)){l=o.childLocations;for(let m=0,T=l.length;m<T;++m)o=l[m],o&&(f=o.attribute.packUID||o.attribute.uid,c=o.attribute.update(n),o.buffer.value.set(c,o.range[0]),u=a[f]||[null,Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER],u[0]=o.attribute,u[1]=Cc(o.range[0],u[1]),u[2]=Lc(o.range[1],u[2]),a[f]=u)}}else o=s[this.bufferManager.getActiveAttributePropertyId()],h=o.attribute,f=h.packUID||h.uid,c=h.update(n),o.buffer.value.set(c,o.range[0]),u=a[f]||[null,Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER],u[0]=h,u[1]=Cc(o.range[0],u[1]),u[2]=Lc(o.range[1],u[2]),a[f]=u;n.reactivate=!1}updateInstanceFull(e,n,i,r){const s=r.propertyToBufferLocation,a=this.bufferAttributeWillUpdate;let o,c,u,l;if(n.active){(i.length===0||n.reactivate)&&(i=this.bufferManager.getUpdateAllPropertyIdList());for(let h=0,f=i.length;h<f;++h)if(o=s[i[h]],!!o&&(l=o.attribute,c=l.update(n),o.buffer.value.set(c,o.range[0]),a[l.packUID||l.uid]=l,o.childLocations)){u=o.childLocations;for(let p=0,g=u.length;p<g;++p)o=u[p],o&&(l=o.attribute,c=l.update(n),o.buffer.value.set(c,o.range[0]),a[l.packUID||l.uid]=l)}}else o=s[this.bufferManager.getActiveAttributePropertyId()],l=o.attribute,c=l.update(n),o.buffer.value.set(c,o.range[0]),a[l.packUID||l.uid]=l;n.reactivate=!1}commit(){if(this.diffMode===0){const e=Object.values(this.bufferAttributeUpdateRange);for(let n=0,i=e.length;n<i;++n){const r=e[n],s=r[0].bufferAttribute;s.updateRange={count:r[2]-r[1],offset:r[1]}}}else{const e=Object.values(this.bufferAttributeWillUpdate);for(let n=0,i=e.length;n<i;++n){const r=e[n].bufferAttribute;r.updateRange={count:-1,offset:0}}}this.bufferAttributeUpdateRange={}}incomingChangeList(e){e.length===0?this.diffMode=0:e.length>this.bufferManager.getInstanceCount()*.7?this.diffMode=1:this.diffMode=0,this.diffMode===0?this.updateInstance=this.updateInstancePartial:this.updateInstance=this.updateInstanceFull}}const Dd=[];class Xm extends Pd{addInstance(e,n,i,r){if(r)e.changeInstance(e,n,Dd,r);else{const s=e.layer.bufferManager.add(n);Od(s)&&(n.active=!0,e.layer.onDiffAdd&&e.layer.onDiffAdd(n),e.updateInstance(e.layer,n,s))}}changeInstance(e,n,i,r){r?e.updateInstance(e.layer,n,r):e.addInstance(e,n,Dd,r)}removeInstance(e,n,i,r){r&&(n.active=!1,e.layer.onDiffRemove&&e.layer.onDiffRemove(n),e.updateInstance(e.layer,n,r),e.layer.bufferManager.remove(n))}updateInstance(e,n,i){if(n.active){const r=i.buffer,s=i.range[0],a=r.value;let o,c,u,l,h,f;for(let p=0,g=e.shaderIOInfo.instanceAttributes.length;p<g;++p)if(o=e.shaderIOInfo.instanceAttributes[p],c=o.update(n),u=a[s+(o.block||0)],l=o.blockIndex,l!==void 0)for(h=l,f=c.length+l;h<f;++h)u[h]=c[h-l];r.value=a}else{const r=i.buffer,s=i.range[0],a=r.value,o=e.shaderIOInfo.activeAttribute,c=o.update(n),u=a[s+(o.block||0)],l=o.blockIndex;if(l!==void 0)for(let h=l,f=c.length+l;h<f;++h)u[h]=c[h-l];r.value=a}}commit(){}incomingChangeList(e){}}class Ym{makeProcessor(e,n){if(this.processing)return this.processing;if(e.bufferType===xe.INSTANCE_ATTRIBUTE||e.bufferType===xe.INSTANCE_ATTRIBUTE_PACKING?this.processor=new Qm(e,n):this.processor=new Xm(e,n),!this.processor)throw new Error("Failed to create a diff processor");return this.processing=[this.processor.changeInstance,this.processor.addInstance,this.processor.removeInstance],this.processing}}class Fd{constructor(e){this.index=0,this.available=4,this.index=e}setAttribute(e){return(e.size||0)<=this.available?(e.block=this.index,e.blockIndex=4-this.available,this.available-=e.size||0,!0):!1}}function qm(t){t.forEach(e=>{if(e.resource&&e.size===void 0&&(e.size=C.FOUR),!e.size)try{const n=e.update(new ze({}));n.length>0&&n.length<=C.FOUR&&(e.size=n.length)}catch{console.warn("The system could not determine the size of the provided attribute. Please provide the size of the attribute:",e)}})}function Bd(t){qm(t);const e=[];t.forEach(n=>{if(n.size&&n.size===C.MAT4X4){n.block=e.length,n.blockIndex=No.INVALID;for(let r=0;r<4;++r){const s=new Fd(e.length);s.available=0,s.index=0,e.push(s)}return}if(!e.find(r=>r.setAttribute(n)?!!r:!1)){const r=new Fd(e.length);e.push(r),r.setAttribute(n)||console.warn("There was a problem packing an attribute into a block. No block would accommodate it:",n)}})}function Ud(t){return!!t}function Gd(t){return!!t}function kd(t){return!!t}function Km(t){return Object.assign({},t,{materialAttribute:null})}function Zm(t){return Object.assign({},t,{materialUniforms:[]})}function Jm(t,e,n,i){e.forEach(r=>{r.name===void 0&&console.warn("All instance attributes MUST have a name on Layer:",t.id),e.find(s=>s!==r&&s.name===r.name)&&console.warn("An instance attribute can not have the same name used more than once:",r.name),n.find(s=>s.name===r.name)&&console.warn("An instance attribute and a vertex attribute in a layer can not share the same name:",r.name),r.resource||r.size===void 0&&(console.warn("An instance attribute requires the size to be defined."),console.warn(r))})}function e0(t,e,n){if(!n)return;let i=e.instanceAttributes||[],r=e.uniforms||[],s=e.vertexAttributes||[];n.shaderModuleUnits.forEach(u=>{u.instanceAttributes&&(i=i.concat(u.instanceAttributes(t))),u.uniforms&&(r=r.concat(u.uniforms(t))),u.vertexAttributes&&(s=s.concat(u.vertexAttributes(t)))});const a=new Set,o=new Set,c=new Set;r.filter(u=>u?a.has(u.name)?(console.warn("Included shader modules has introduced duplicate uniform names:",u.name,"One will be overridden thus causing a potential crash of the shader."),!1):(a.add(u.name),!0):!1),i.filter(u=>u?o.has(u.name)?(console.warn("Included shader modules has introduced duplicate Instance Attribute names:",u.name,"One will be overridden thus causing a potential crash of the shader."),!1):(o.add(u.name),!0):!1),s.filter(u=>u?c.has(u.name)?(console.warn("Included shader modules has introduced duplicate Vertex Attribute names:",u.name,"One will be overridden thus causing a potential crash of the shader."),!1):(c.add(u.name),!0):!1),e.instanceAttributes=i,e.uniforms=r,e.vertexAttributes=s}function zd(t,e,n,i,r,s){e0(e,n,s);const a=(n.instanceAttributes||[]).filter(Ud),o=(n.vertexAttributes||[]).filter(Gd),c=(n.uniforms||[]).filter(kd);for(let f=0,p=i.length;f<p;++f){const g=i[f];if(g.validate(e,a,o,c)){const m=g.expand(e,a,o,c);m.instanceAttributes.filter(Ud).forEach(T=>a.push(T)),m.vertexAttributes.filter(Gd).forEach(T=>o.push(T)),m.uniforms.filter(kd).forEach(T=>c.push(T))}}Jm(e,a,o);const u=a.slice(0),l=(o||[]).map(Km),h=c.map(Zm);return u.sort(r.sortInstanceAttributes),h.sort(r.sortUniforms),l.sort(r.sortVertexAttributes),Bd(u),e.getLayerBufferType(t,o,u),{instanceAttributes:u,uniforms:h,vertexAttributes:l}}class Oc{static calculateUniformBlockUseage(e){let n=0;for(let i=0,r=e.length;i<r;++i)n+=Math.ceil(e[i].size/4);return n}process(e,n){this.instanceMaxBlock=0,e.forEach(i=>{this.instanceMaxBlock=Math.max(this.instanceMaxBlock,i.block||0)}),this.blocksPerInstance=this.instanceMaxBlock+1,this.maxUniforms=L.MAX_VERTEX_UNIFORMS,this.maxUniformsForInstancing=this.maxUniforms-Oc.calculateUniformBlockUseage(n),this.maxInstancesPerUniformBuffer=Math.floor(this.maxUniformsForInstancing/this.blocksPerInstance),this.totalInstanceUniformBlocks=this.maxInstancesPerUniformBuffer*this.blocksPerInstance}}const Qr="Once a ShaderModuleUnit has been registered, you CAN NOT modify it! Module ID:";class aa{constructor(e){this._dependents=null,Object.assign(this,e)}get content(){return this._content}set content(e){if(this._isLocked){console.warn(Qr,this._moduleId);return}this._content=e}get compatibility(){return this._compatibility}set compatibility(e){if(this._isLocked){console.warn(Qr,this._moduleId);return}this._compatibility=e}get dependents(){return this._dependents}set dependents(e){if(this._isLocked&&this._dependents!==null){console.warn(Qr,this._moduleId);return}this._dependents=e}isLocked(){return this._isLocked}get moduleId(){return this._moduleId}set moduleId(e){if(this._isLocked){console.warn(Qr,this._moduleId);return}this._moduleId=e}applyAnalyzedContent(e){if(this._isLocked&&this.dependents!==null){console.warn(Qr,this._moduleId);return}this._content=e}lock(){this._isLocked=!0}}const Vd=Ie("performance"),t0=Ie("shader-module-vs"),n0=Ie("shader-module-fs"),Wd="import",$d=":";function jd(t,e){return!!t&&(t.compatibility===e||t.compatibility===x.ALL)}const ii=class{static register(t){if(!(t instanceof aa)){if(Array.isArray(t)){let a="";return t.forEach(o=>{const c=ii.register(o);c&&(a+=`${c}
`)}),a||null}return ii.register(new aa(t))}let e=ii.modules.get(t.moduleId);e||(e={},ii.modules.set(t.moduleId,e));const n=e.fs,i=e.vs,r=jd(t,x.FRAGMENT),s=jd(t,x.VERTEX);if(n&&r){if(n.isFinal)return`Module ID: ${t.moduleId} Can not override the module's existing Fragment registration as the exisitng module is marked as final`;Vd("A Shader Module Unit has overridden an existing module for the Fragment Shader Module ID: %o",t.moduleId)}if(i&&s){if(i.isFinal)return`Module ID: ${t.moduleId} Can not override the module's existing Vertex registration as the exisitng module is marked as final`;Vd("A Shader Module Unit has overridden an existing module for the Vertex Shader Module ID: %o",t.moduleId)}return r&&(e.fs=t),s&&(e.vs=t),t.lock(),null}static analyzeDependents(t){if(t.dependents&&t.isLocked())return[];const e=[],n=[],i=new Set,r=t.compatibility,s=t.moduleId,a=ei({options:{},shader:t.content,onToken:o=>{const c=o.trim();if(c.indexOf(Wd)===0){const u=c.substr(Wd.length).trim();if(u[0]===$d){let l=!1;const h=u.substr($d.length).trim().split(",");return h[h.length-1].trim().length===0&&h.pop(),h.forEach(f=>{f=f.trim();const p=ii.modules.get(f);p?((r===x.FRAGMENT||r===x.ALL)&&(p.fs?(l=!0,i.has(f)||n.push(f)):e.push(`Could not find requested target fragment module for Module ID: ${f} requested by module: ${s}`)),(r===x.VERTEX||r===x.ALL)&&(p.vs?(l=!0,i.has(f)||n.push(f)):e.push(`Could not find requested target vertex module for Module ID: ${f} requested by module: ${s}`)),!p.vs&&!p.fs&&e.push("Could not find a vertex or fragment shader within exisitng module"),l||e.push(`Error Processing module Module ID: ${f} requested by module: ${s}`)):e.push(`Could not find requested module: ${f} requested by module: ${s}`)}),""}}return`\${${o}}`}});return t.applyAnalyzedContent(a.shader),t.dependents=n,e}static process(t,e,n,i){const r=new Set,s=new Set,a=[],o=[],c=n===x.VERTEX?t0:n0;c("Processing Shader for context %o:",t);function u(g){const m=g.moduleId;c("%o: %o",m,a.slice(0).reverse().join(" -> "));const T=a.indexOf(m);if(a.unshift(m),T>-1){const w=a.slice(0,T+2).reverse();return o.push(`A Shader has detected a Circular dependency in import requests: ${w.join(" -> ")}`),a.shift(),!1}return!0}function l(g){const m=g.moduleId;if(!u(g))return null;if(m&&s.has(m))return a.shift(),"";let T="";ii.analyzeDependents(g).forEach(b=>o.push(b));const y=g.dependents;if(c("Module dependencies detected %o",y),y&&y.length>0)for(let b=0,A=y.length;b<A;++b){const R=y[b],N=ii.modules.get(R);if(N){let I;(n===x.FRAGMENT||n===x.ALL)&&(N.fs?(r.add(N.fs),I=l(N.fs)):o.push(`Could not find requested target fragment module for Module ID: ${R} requested by module: ${m}`)),(n===x.VERTEX||n===x.ALL)&&(N.vs?(r.add(N.vs),I=l(N.vs)):o.push(`Could not find requested target vertex module for Module ID: ${R} requested by module: ${m}`)),!N.vs&&!N.fs&&o.push("Could not find a vertex or fragment shader within exisitng module"),I===null&&o.push(`Error Processing module Module ID: ${R} requested by module: ${m}`),T+=I||""}else o.push(`Could not find requested module: ${R} requested by module: ${m}`)}return a.shift(),s.add(m||""),`${T.trim()}

${g.content.trim()}`}let h=e;if(i){let g="";i.forEach(m=>{g+=`\${import: ${m}}
`}),h=g+e}const f=new aa({content:h,compatibility:n,moduleId:`Layer "${t}" ${n===x.ALL?"fs vs":n===x.VERTEX?"vs":"fs"}`});return{errors:o,shader:l(f),shaderModuleUnits:r}}};let Ee=ii;Ee.modules=new Map;const Hd={attributes:"attributes",easingMethod:"easingMethod",extend:"extend",extendHeader:"extendHeader",T:"T"},oa="out",ca=":";class Qd{constructor(){this.metricsProcessing=new Oc}static mergeFragmentOutputsForMRT(e,n,i,r,s,a){let o="",c="",u="";const l=new Set,h=[],f=new Set;return L.MRT||(u=" = gl_FragColor"),i.forEach((p,g)=>{let m=!0,T=!1;if(s&&s.indexOf(p.outputType)<0&&(m=!1),a&&g<i.length-1&&(m=!1),!a&&r.indexOf(p.outputType)<0&&(m=!1),f.has(p.outputType))throw new Error("Can not use the same Output Fragment type multiple times");f.add(p.outputType);const w=r.indexOf(p.outputType);ei({shader:Wr(p.source),onToken(y){const b=y.trim();if(b.indexOf(oa)===0){if(T)throw console.error("Found multiple ${out} tokens in a single fragment shader. This is not supported nor logical","If you need to use the declared output multiple times, use the assigned name","and don't wrap it repeatedly in the shader.","eg-","void main() {","  ${out: myOutput} = value;","  vec4 somethingElse = myOutput;","}"),new Error("Invalid Shader Format");T=!0;const A=b.substr(oa.length).trim();if(A[0]===ca){const R=A.substr(ca.length).trim();if(!R)throw new Error("Output in a shader requires an identifier ${out: <name required>}");if(l.has(R))throw new Error("You can not declare the same output name in subsequent fragment shader outputs");if(R==="gl_FragColor")throw new Error("DO not use gl_FragColor as an identifier for an out. Choose something not used by the WebGL spec.");let N="";if(m)if(l.add(R),h.push(p.outputType),L.MRT_EXTENSION)u=` = gl_FragData[${w}]`,N="vec4 ";else if(L.MRT&&L.SHADERS_3_0)n.set(R,`layout(location = ${w}) out vec4 ${R};
`);else throw new Error(`Could not generate a proper output declaration for the fragment shader output: ${R}`);else N="vec4 ";return`${N}${R}${u}`}else throw new Error("Output in a shader requires an identifier ${out: <name required>}")}return`\${${y}}`},onMain(y,b){return!T&&y&&(y.match("gl_FragColor")?(h.push(p.outputType),L.MRT&&(L.SHADERS_3_0?(n.set("_FragColor",`layout(location = ${w}) out vec4 _FragColor;
`),y=y.replace(/gl_FragColor/g,"_FragColor")):(y=y.replace(/gl_FragColor\s+=/,`vec4 _FragColor = gl_FragData[${w}] =`),y=y.replace(/gl_FragColor\s+=/g,`_FragColor = gl_FragData[${w}] =`),y=y.replace(/gl_FragColor/g,"_FragColor"))),l.add("_FragColor")):h.push($.NONE)),o+=`
${(b||"").trim()}`,c+=`
  ${(y||"").trim()}`,(y||"").trim()}})}),{output:`${o}
void main() {
${c}
}`,outputNames:Array.from(l.values()),outputTypes:h}}static mergeOutputFragmentShaderForColor(e,n){if(n.length>1||n[0]!==$.COLOR)throw new Error("Merging fragment shaders for only COLOR output is only valid when the view has a single COLOR output target.");En(e)&&(e=[{outputType:$.COLOR,source:e}]);let i="",r="";const s=new Set,a=[];return e.some(o=>{const c=o.outputType===$.COLOR;let u=!1;return c&&a.push($.COLOR),ei({shader:Wr(o.source),onToken(l){const h=l.trim();if(h.indexOf(oa)===0){if(u)throw console.error("Found multiple ${out} tokens in a single fragment shader. This is not supported nor logical","If you need to use the declared output multiple times, use the assigned name","and don't wrap it repeatedly in the shader.","eg-","void main() {","  ${out: myOutput} = value;","  vec4 somethingElse = myOutput;","}"),new Error("Invalid Shader Format");u=!0;const f=h.substr(oa.length).trim();if(f[0]===ca){const p=f.substr(ca.length).trim();if(!p)throw new Error("Output in a shader requires an identifier ${out: <name required>}");if(s.has(p))throw new Error("You can not declare the same output name in subsequent fragment shader outputs");if(p==="gl_FragColor")throw new Error("DO not use gl_FragColor as an identifier for an out. Choose something not used by the WebGL spec.");return c?(s.add("gl_FragColor"),p!=="gl_FragColor"?`vec4 ${p} = gl_FragColor`:"gl_FragColor"):`vec4 ${p}`}}return`\${${l}}`},onMain(l,h){return r+=`
${(h||"").trim()}`,i+=`
  ${(l||"").trim()}`,(l||"").trim()}}),!!c}),{output:`${r}
void main() {
${i}
}`,outputNames:Array.from(s.values()),outputTypes:a}}static makeOutputFragmentShader(e,n,i,r){if(!i||En(i))if(En(r)){const s=this.mergeOutputFragmentShaderForColor([{source:r,outputType:$.COLOR}],[$.COLOR]);return{source:s.output,outputTypes:[$.COLOR],outputNames:s.outputNames}}else if(Array.isArray(r)){const s=r.find(c=>c.outputType===$.COLOR);let a=-1;s?a=r.indexOf(s):a=r.length-1;const o=this.mergeOutputFragmentShaderForColor(r.slice(0,a+1),[$.COLOR]);return{source:o.output,outputNames:o.outputNames,outputTypes:[$.COLOR]}}else return null;else if(Array.isArray(i)){if(!L.MRT)throw new Error("Multiple Render Targets were specified, but are not natively supported by user's hardware! MRT also does not have a fallback in deltav yet!");const s=i.map(a=>a.outputType);if(Array.isArray(r)){const a=new Map;for(let o=0,c=i.length;o<c;++o){const u=i[o];for(let l=0,h=r.length;l<h;++l)if(r[l].outputType===u.outputType){a.set(u.outputType,l);break}}if(L.MRT){let o=-1;const c=[];if(a.forEach((l,h)=>{c.push(h),o=Math.max(l,o)}),o===-1)return null;const u=this.mergeFragmentOutputsForMRT(e,n,r.slice(0,o+1),s,c);return{source:u.output,outputNames:u.outputNames,outputTypes:u.outputTypes}}else throw new Error("Fragment shader generation not supported for MRT systems on non MRT hardware...yet")}else if(i.find(o=>o.outputType===$.COLOR)&&r){const o=this.mergeFragmentOutputsForMRT(e,n,[{source:r,outputType:$.COLOR}],s);return{source:o.output,outputNames:o.outputNames,outputTypes:o.outputTypes}}}return null}process(e,n,i,r,s,a,o){try{if(!e.surface.gl)return console.warn("No WebGL context available for layer!"),null;const c=this.processImports(e,n,i);if(!c)return null;const{vertexAttributes:u,instanceAttributes:l,uniforms:h}=zd(e.surface.gl,e,n,s,o,c);e.getLayerBufferType(e.surface.gl,u,l),this.metricsProcessing.process(l,h);let f="",p="",g="";const m={uniforms:[]},T=r.vs||new Map,w=r.fs||new Map,y=r.destructure||new Map;for(let D=0,H=s.length;D<H;++D){const z=s[D],V=z.processHeaderInjection(x.VERTEX,T,e,this.metricsProcessing,u,l,h);f+=V.injection,V.material&&(m.uniforms=m.uniforms.concat(V.material.uniforms||[])),g+=z.processAttributeDestructuring(e,y,this.metricsProcessing,u,l,h)}let b="";T.forEach(D=>{b+=D}),f=b+f,b="",y.forEach(D=>{b+=D}),g=b+g;const A=this.processExtensions(),R=`precision highp float;

`,N=A+R+f+c.vs;let I={[Hd.attributes]:g},S=!1;const j=ei({options:I,required:void 0,shader:N,onToken(D,H){return D===Hd.attributes&&(S=!0),H},onMain(D){return S?D||"":D===null?(console.warn("The body of void main() could not be determined."),""):`${g}
${D}`}});return c.fs.forEach((D,H)=>{I={},p="",b="";const z=w.get(H)||new Map;for(let W=0,oe=s.length;W<oe;++W){const Le=s[W].processHeaderInjection(x.FRAGMENT,z,e,this.metricsProcessing,u,l,h);if(p+=Le.injection,Le.material){const ee=new Set;m.uniforms.forEach(Se=>ee.add(Se.name)),m.uniforms.forEach(Se=>{ee.has(Se.name)||m.uniforms.push(Se)})}}z.forEach(W=>{b+=W}),p=b+p;const V=A+R+p+D.source,re=ei({options:I,required:void 0,shader:V});D.source=re.shader.trim();for(let W=0,oe=a.length;W<oe;++W){const Y=a[W];j.shader=Y.vertex(j.shader),D.source=Y.fragment(D.source)}}),{fs:c.fs,materialUniforms:m.uniforms,maxInstancesPerBuffer:this.metricsProcessing.maxInstancesPerUniformBuffer,modules:Array.from(c.shaderModuleUnits),vs:j.shader.trim(),vertexAttributes:u,instanceAttributes:l,uniforms:h}}catch(c){return c instanceof Error&&(console.warn("An unknown error occurred while processing the shaders for layer:",e.id),console.warn("Error:"),console.warn(c&&(c.stack||c.message))),null}}processExtensions(){let e="";return L.SHADERS_3_0&&(e+="#version 300 es"),L.MRT_EXTENSION&&(e+="#extension GL_EXT_draw_buffers : require"),e&&(e+=`

`),e}processImports(e,n,i){const r=new Set;let s=e.baseShaderModules(n);e.props.baseShaderModules&&(s=e.props.baseShaderModules(n,s));const a=Ee.process(e.id,n.vs,x.VERTEX,s.vs);if(a.errors.length>0)return console.warn("Error processing imports for the vertex shader of layer:",e.id,"Errors",...a.errors.reverse()),null;const o=new Map;return i.forEach((c,u)=>{const l=Ee.process(e.id,c.source,x.FRAGMENT,s.fs);if(l.errors.length>0){console.warn("Error processing imports for the fragment shader of layer:",e.id,"Errors",...l.errors.reverse());return}l.shaderModuleUnits.forEach(f=>r.add(f));const h={source:l.shader||"",outputTypes:c.outputTypes,outputNames:c.outputNames};o.set(u,h)}),a.shaderModuleUnits.forEach(c=>r.add(c)),{fs:o,vs:a.shader||"",shaderModuleUnits:r}}}class Xd{constructor(e){this.isMouseOver=new Set,this.isMouseDown=new Set,this.isTouchOver=new Map,this.isTouchDown=new Map,this.layer=e}getColorPickInstance(e){return this.colorPicking&&this.layer.picking.type===X.SINGLE&&this.colorPicking.view===e?this.layer.uidToInstance.get(16777215-this.colorPicking.nearestColor):null}handleMouseOver(e,n){}handleTouchOver(e,n,i){}handleMouseDown(e,n){if(this.layer.picking&&this.layer.picking.type!==X.NONE){const{onMouseDown:i}=this.layer.props;if(i){const r=e.projection.screenToWorld(n.screen.position),s=[];if(this.layer.picking.type===X.SINGLE){const o=this.getColorPickInstance(e);o&&s.push(o)}const a={interaction:n,instances:s,layer:this.layer.id,projection:e.projection,screen:n.screen.position,world:r};i(a),this.isMouseDown.clear(),s.forEach(o=>this.isMouseDown.add(o))}}}handleTouchDown(e,n,i){const{onTouchDown:r,onTouchOver:s}=this.layer.props;if(!this.layer.picking||this.layer.picking.type===X.NONE||!r&&!s)return;const a=e.projection.screenToWorld(i.screen.position),o=[];if(this.layer.picking.type===X.SINGLE){const h=this.getColorPickInstance(e);h&&o.push(h)}const c={interaction:n,touch:i,instances:o,layer:this.layer.id,projection:e.projection,screen:i.screen.position,world:a},u=Jn(this.isTouchDown,i.touch.touch.identifier,()=>new Set),l=Jn(this.isTouchOver,i.touch.touch.identifier,()=>new Set);o.forEach(h=>{u.add(h),l.add(h)}),s&&s(c),r&&r(c)}handleMouseOut(e,n){if(this.layer.picking&&this.layer.picking.type!==X.NONE){const{onMouseOut:i}=this.layer.props;if(i){const r=e.projection.screenToWorld(n.screen.position),s={interaction:n,instances:Array.from(this.isMouseOver.keys()),layer:this.layer.id,projection:e.projection,screen:n.screen.position,world:r};i(s)}}this.isMouseOver.clear()}handleTouchOut(e,n,i){const{onTouchOut:r}=this.layer.props;if(!this.layer.picking||this.layer.picking.type===X.NONE||!r)return;const s=e.projection.screenToWorld(i.screen.position),a={interaction:n,touch:i,instances:Array.from(this.isMouseOver.keys()),layer:this.layer.id,projection:e.projection,screen:i.screen.position,world:s};r(a),this.isTouchOver.delete(i.touch.touch.identifier)}handleMouseUp(e,n){const{onMouseUp:i,onMouseUpOutside:r}=this.layer.props;if(!this.layer.picking||this.layer.picking.type===X.NONE||!i)return;const s=e.projection.screenToWorld(n.screen.position),a=[];if(this.layer.picking.type===X.SINGLE){const c=this.getColorPickInstance(e);c&&a.push(c)}let o={interaction:n,instances:a,layer:this.layer.id,projection:e.projection,screen:n.screen.position,world:s};i(o),a.forEach(c=>this.isMouseDown.delete(c)),!(this.isMouseDown.size<=0||!r)&&(o={interaction:n,instances:Array.from(this.isMouseDown.values()),layer:this.layer.id,projection:e.projection,screen:n.screen.position,world:s},r(o))}handleTouchUp(e,n,i){const{onTouchUp:r,onTouchUpOutside:s,onTouchOut:a,onTouchAllEnd:o}=this.layer.props;if(!this.layer.picking||this.layer.picking.type===X.NONE||!r&&!s&&!a&&!o)return;const c=e.projection.screenToWorld(i.screen.position),u=[];if(this.layer.picking.type===X.SINGLE){const f=this.getColorPickInstance(e);f&&u.push(f)}let l={interaction:n,touch:i,instances:u,layer:this.layer.id,projection:e.projection,screen:i.screen.position,world:c};a&&a(l),r&&r(l);const h=Ks(this.isTouchDown,i.touch.touch.identifier,new Set);u.forEach(f=>h.delete(f)),h.size>0&&s&&(l={interaction:n,touch:i,instances:Array.from(h.values()),layer:this.layer.id,projection:e.projection,screen:i.screen.position,world:c},s(l)),this.isTouchDown.delete(i.touch.touch.identifier),this.isTouchDown.size<=0&&o&&(l={interaction:n,touch:i,instances:[],layer:this.layer.id,projection:e.projection,screen:i.screen.position,world:c},o(l))}handleMouseMove(e,n){const{onMouseOver:i,onMouseMove:r,onMouseOut:s}=this.layer.props;if(this.layer.picking&&this.layer.picking.type!==X.NONE&&(i||r||s)){let a;const o=e.projection.screenToWorld(n.screen.position),c=[];if(this.layer.picking.type===X.SINGLE){const l=this.getColorPickInstance(e);l&&c.push(l)}const u=new Set;if(c.forEach(l=>u.add(l)),s){const l=[];this.isMouseOver.forEach(h=>{u.has(h)||l.push(h)}),a={interaction:n,instances:l,layer:this.layer.id,projection:e.projection,screen:n.screen.position,world:o},l.length>0&&s(a)}if(i){const l=c.filter(h=>!this.isMouseOver.has(h));a={interaction:n,instances:l,layer:this.layer.id,projection:e.projection,screen:n.screen.position,world:o},l.length>0&&i(a)}r&&(a={interaction:n,instances:c,layer:this.layer.id,projection:e.projection,screen:n.screen.position,world:o},r(a)),this.isMouseOver=u}}handleTouchMove(e,n,i){const{onTouchOver:r,onTouchMove:s,onTouchOut:a}=this.layer.props;if(this.layer.picking&&this.layer.picking.type!==X.NONE&&(r||s||a)){let o;const c=e.projection.screenToWorld(i.screen.position),u=[];if(this.layer.picking.type===X.SINGLE){const f=this.getColorPickInstance(e);f&&u.push(f)}const l=Ks(this.isTouchOver,i.touch.touch.identifier,new Set),h=new Set;if(u.forEach(f=>h.add(f)),a){const f=[];l.forEach(p=>{h.has(p)||f.push(p)}),o={interaction:n,touch:i,instances:f,layer:this.layer.id,projection:e.projection,screen:i.screen.position,world:c},f.length>0&&a(o)}if(r){const f=u.filter(p=>!l.has(p));o={interaction:n,touch:i,instances:f,layer:this.layer.id,projection:e.projection,screen:i.screen.position,world:c},f.length>0&&r(o)}s&&(o={interaction:n,touch:i,instances:u,layer:this.layer.id,projection:e.projection,screen:i.screen.position,world:c},s(o)),this.isMouseOver=h}}handleMouseClick(e,n){if(this.layer.picking&&this.layer.picking.type!==X.NONE){const{onMouseClick:i}=this.layer.props;if(i){const r=e.projection.screenToWorld(n.screen.position),s=[];if(this.layer.picking.type===X.SINGLE){const o=this.getColorPickInstance(e);o&&s.push(o)}const a={interaction:n,instances:s,layer:this.layer.id,projection:e.projection,screen:n.screen.position,world:r};i(a)}}}handleTap(e,n,i){if(this.layer.picking&&this.layer.picking.type!==X.NONE){const{onTap:r}=this.layer.props;if(r){const s=e.projection.screenToWorld(i.screen.position),a=[];if(this.layer.picking.type===X.SINGLE){const c=this.getColorPickInstance(e);c&&a.push(c)}const o={interaction:n,touch:i,instances:a,layer:this.layer.id,projection:e.projection,screen:i.screen.position,world:s};r(o)}}}handleMouseDrag(e,n){}}const Nc=Ie("performance"),Yd=class extends yi{constructor(t,e,n){super(n),this.animationEndTime=0,this.alwaysDraw=!1,this.depth=0,this._easingManager={easingComplete:new ke,complete:()=>this._easingManager.easingComplete.promise},this.lastFrameTime=0,this.needsViewDrawn=!1,this.picking={currentPickMode:X.NONE,type:X.SINGLE,uidToInstance:new Map},this.resource=wd,this.shaderIOInfo={},this.streamChanges={locked:!1,streamIndex:0},this._uid=G(),this.uidToInstance=new Map,this.willRebuildLayer=!1,this.surface=t,this.scene=e,this.props=Object.assign({},Yd.defaultProps||{},n)}get bufferManager(){return this._bufferManager}get bufferType(){return this._bufferType||xe.INSTANCE_ATTRIBUTE}get easingManager(){return this._easingManager}get uid(){return this._uid}static createRef(){return{easing:null}}validateShaderIO(t){if(!t)return this.picking&&(this.picking.type=X.NONE),Nc("Shell layer initialized. Nothing will be rendered for this layer",this.id),!0;if(!t.fs||!t.vs)return console.warn("Layer needs to specify the fragment and vertex shaders:",this.id),!1}cleanShaderIOElements(t){t.instanceAttributes=(t.instanceAttributes||[]).filter(me),t.vertexAttributes=(t.vertexAttributes||[]).filter(me),t.uniforms=(t.uniforms||[]).filter(me)}checkForDuplicateOutputTypes(t){let{mapOutput:e}=this.props;En(t.fs)&&(t.fs=[{outputType:$.COLOR,source:t.fs}]),e=e||{};const n=new Set;let i=!1,r=Number.MIN_SAFE_INTEGER;for(let s=0,a=t.fs.length;s<a;++s){const o=t.fs[s],c=e[o.outputType];if(c===void 0){n.has(o.outputType)&&(i=!0),n.add(o.outputType);continue}c===$.NONE?o.outputType=r++:o.outputType=c,n.has(o.outputType)&&(i=!0),n.add(o.outputType)}if(i)return console.warn("Layer has duplicate fragment shader output types"),!1}processFragmentShadersForEachView(t,e){En(t.fs)&&(t.fs=[{outputType:$.COLOR,source:t.fs}]);const n=this.picking.type===X.SINGLE&&!t.fs.find(a=>a.outputType===$.PICKING);if(this.picking.type===X.SINGLE&&!n)throw new Error("Do NOT specify picking prop on a layer when you have your own Picking output declared.");const i={outputType:$.PICKING,source:Wg},r=new Map,s={fs:new Map,vs:new Map,destructure:new Map};for(let a=0,o=e.length;a<o;++a){const c=e[a];if(n){const p=t.fs.findIndex(g=>g.outputType===$.PICKING);p>-1&&t.fs.splice(p,1)}const u=c.getOutputTargets();let l=0;t.fs.forEach((p,g)=>{u!=null&&u.find(m=>m.outputType===p.outputType)&&(l=g)}),n&&t.fs.splice(l+1,0,i);let h=Jn(s.fs,c,new Map);h||(h=new Map,s.fs.set(c,h));const f=Qd.makeOutputFragmentShader(s.vs,h,u,t.fs);if(!f)return console.warn("Could not generate output fragment shaders for the view specified."),!1;r.set(c,f)}return{outputFragmentShaders:r,declarations:s}}processLayerShaders(t,e,n){let i=null;if(i=new Qd().process(this,t,e,n,this.surface.getIOExpanders(),this.surface.getShaderTransforms(),this.surface.getIOSorting()),!i)return console.warn("The shader processor did not produce metrics for the layer."),!1;this.shaderIOInfo=Object.assign({activeAttribute:{name:"active",size:C.ONE,update:r=>[r.active?1:0]},instanceAttributes:i.instanceAttributes,instanceVertexCount:t.vertexCount,vs:i.vs,fs:i.fs,materialUniforms:i.materialUniforms,maxInstancesPerBuffer:i.maxInstancesPerBuffer,drawMode:t.drawMode||d.GLSettings.Model.DrawMode.TRIANGLE_STRIP,uniforms:i.uniforms,vertexAttributes:i.vertexAttributes},this.shaderIOInfo)}processVertexAttributes(t){bd(this,this.shaderIOInfo.maxInstancesPerBuffer,this.shaderIOInfo.vertexAttributes,t.vertexCount)}init(t){if(!this.surface.gl)return console.warn("The layer's surface does not have a valid WebGL context."),!1;const{picking:e=X.NONE}=this.props;e===X.SINGLE?this.picking={currentPickMode:X.NONE,type:X.SINGLE,uidToInstance:new Map}:this.picking={currentPickMode:X.NONE,type:X.NONE},this.resource=this.surface.resourceManager;const n=this.initShader();this.interactions=new Xd(this);const i=this.validateShaderIO(n);if(i!==void 0)return i;if(!n)return!1;let r;return this.surface.getShaderTransforms().forEach(a=>{n.vs=a.rawVertex(n.vs),n.fs=a.rawFragment(n.fs)}),r=this.cleanShaderIOElements(n),jn(r)||(r=this.checkForDuplicateOutputTypes(n),jn(r))||(r=this.processFragmentShadersForEachView(n,t),jn(r))||(r=this.processLayerShaders(n,r.outputFragmentShaders,r.declarations),jn(r))||(r=this.processVertexAttributes(n),jn(r))||(r=this.makeLayerBufferManager(this.surface.gl,this.scene),jn(r))||(r=this.updateDiffHandlers(),jn(r))?r:(this.layerShaderDebugging(),this.props.ref&&(this.props.ref.easing=this.easingManager),!0)}layerShaderDebugging(){this.props.printShader&&(console.warn(`Layer: ${this.props.key}`,`
Shader Configuration:`,this.shaderIOInfo),console.warn(`VERTEX SHADER
`),console.warn(`
${this.shaderIOInfo.vs}`),this.shaderIOInfo.fs.forEach((t,e)=>{console.warn(`FRAGMENT SHADER:
`,`view: ${e.id}):
Output Targets${JSON.stringify(t.outputNames)}
${JSON.stringify(t.outputTypes)}
`),console.warn(`
${t.source}`)}))}baseShaderModules(t){const e=[],n=[];return e.push("instancing"),this.picking.type===X.SINGLE&&e.push("picking"),(t.instanceAttributes||[]).find(r=>!!(r&&r.easing))&&e.push("frame"),{fs:n,vs:e}}childLayers(){return[]}destroy(){this.bufferManager&&(this.bufferManager.scene&&this.bufferManager.scene.removeLayer(this),this.bufferManager.removeFromScene(),this.bufferManager.destroy())}didUpdateProps(){}draw(){this.updateStreamLock();const t=this.getChangeList();t.length>0&&(this.needsViewDrawn=!0);let e,n,i;const r=this.diffManager;if(!r||!this.bufferManager)return;const s=r.processing,a=r.processor;if(!a){console.warn("A layer is atttempting to draw without a diff processor for analyzing changes.");return}a.incomingChangeList(t),this.bufferManager.incomingChangeList(t);for(let o=0,c=t.length;o<c;++o)e=t[o],n=e[0],i=this.bufferManager.getBufferLocations(n),s==null||s[e[1]](a,n,Object.values(e[2]),i),n.changes={};a.commit(),this.bufferManager.changesProcessed(),this.updateEasingManager(),this.updateUniforms()}updateEasingManager(){if(this.props.streamChanges){if(!this.streamChanges.stream||this.streamChanges.stream.length<=0){const t=this._easingManager.easingComplete;this._easingManager.easingComplete=new ke,Rn(()=>{t.resolve()},this.animationEndTime-this.surface.frameMetrics.currentTime)}}else{const t=this._easingManager.easingComplete;this._easingManager.easingComplete=new ke,Rn(()=>{t.resolve()},this.animationEndTime-this.surface.frameMetrics.currentTime)}}getNextStreamChanges(){let t;const{streamChanges:e={count:1e4,strategy:As.LINEAR}}=this.props,{stream:n=[],streamIndex:i}=this.streamChanges;switch(e.count===void 0&&(e.count=1e4),e.count<=0&&(e.count=Number.MAX_SAFE_INTEGER),e.strategy){case As.LINEAR:default:{t=n.slice(i,i+e.count),this.streamChanges.streamIndex+=e.count;break}}return this.streamChanges.stream&&this.streamChanges.streamIndex>=this.streamChanges.stream.length&&delete this.streamChanges.stream,t}updateStreamLock(){this.streamChanges.locked=!!(this.streamChanges.stream&&this.streamChanges.streamIndex<this.streamChanges.stream.length)}getChangeList(){let t;return this.streamChanges.locked?t=this.getNextStreamChanges():this.props.streamChanges?(this.streamChanges.streamIndex=0,this.streamChanges.locked=!0,this.streamChanges.stream=this.props.data.changeList,t=[],this.props.data.resolve(this.id)):(t=this.props.data.changeList,this.props.data.resolve(this.id)),this.updateStreamLock(),t}getInstanceObservableIds(t,e){const n={};for(let i=0,r=e.length;i<r;++i){je.setObservableMonitor(!0),t[e[i]];const s=je.getObservableMonitorIds(!0);s[0]!==void 0&&(n[e[i]]=s[0])}return je.setObservableMonitor(!1),n}getMaterialOptions(){return{}}initShader(){return{fs:"${import: no-op}",instanceAttributes:[],uniforms:[],vertexAttributes:[],vertexCount:0,vs:"${import: no-op}"}}managesInstance(t){return me(this.bufferManager)&&this.bufferManager.managesInstance(t)}getLayerBufferType(t,e,n){let i=xe.UNIFORM,r=0;if(this._bufferType!==void 0)return this._bufferType;if(L.HARDWARE_INSTANCING){for(let s=0,a=e.length;s<a;++s){const o=e[s];r+=Math.ceil(o.size/4)}for(let s=0,a=n.length;s<a;++s){const o=n[s];r+=Math.ceil($l[o.size||1]/4)}if(r>L.MAX_VERTEX_ATTRIBUTES){r=0;for(let s=0,a=n.length;s<a;++s){const o=n[s];r=Math.max(r,o.block||0)}for(let s=0,a=e.length;s<a;++s){const o=e[s];r+=Math.ceil(o.size/4)}r<L.MAX_VERTEX_ATTRIBUTES&&(i=xe.INSTANCE_ATTRIBUTE_PACKING,Nc(`Performance Issue (Moderate):
            Layer %o is utilizing too many vertex attributes and is now using vertex packing.
            Max Vertex units %o
            Used Vertex units %o
            Instance Attributes %o
            Vertex Attributes %o`,this.id,L.MAX_VERTEX_ATTRIBUTES,r,n,e))}else i=xe.INSTANCE_ATTRIBUTE}return i===xe.UNIFORM&&(Nc(`Performance Issue (High):
        Layer %o is utilizing too many vertex attributes and is now using a uniform buffer.
        Max Vertex units %o
        Used Vertex units %o
        Instance Attributes %o
        Vertex Attributes %o`,this.id,L.MAX_VERTEX_ATTRIBUTES,r,n,e),i=xe.UNIFORM),this.setBufferType(i),i}makeLayerBufferManager(t,e){switch(this.getLayerBufferType(t,this.shaderIOInfo.vertexAttributes,this.shaderIOInfo.instanceAttributes)){case xe.INSTANCE_ATTRIBUTE:{this.setBufferManager(new Cd(this,e));break}case xe.INSTANCE_ATTRIBUTE_PACKING:{this.setBufferManager(new Ld(this,e));break}default:{this.setBufferManager(new Nd(this,e));break}}}updateDiffHandlers(){(this.shaderIOInfo.instanceAttributes||[]).find(e=>!!(e&&e.easing))?this.picking.type===X.SINGLE?(this.onDiffAdd=this.handleDiffAddWithPickingAndEasing,this.onDiffRemove=this.handleDiffRemoveWithPickingAndEasing):(this.onDiffAdd=this.handleDiffAddWithEasing,this.onDiffRemove=this.handleDiffRemoveWithEasing):this.picking.type===X.SINGLE&&(this.onDiffAdd=this.handleDiffAddWithPicking,this.onDiffRemove=this.handleDiffRemoveWithPicking)}handleDiffAddWithEasing(t){t.easingId=this.easingId}handleDiffAddWithPicking(t){this.uidToInstance.set(t.uid,t)}handleDiffAddWithPickingAndEasing(t){this.uidToInstance.set(t.uid,t),t.easingId=this.easingId}handleDiffRemoveWithEasing(t){t.easing&&delete t.easing,delete t.easingId}handleDiffRemoveWithPicking(t){this.uidToInstance.delete(t.uid)}handleDiffRemoveWithPickingAndEasing(t){this.uidToInstance.delete(t.uid),t.easing&&delete t.easing,delete t.easingId}rebuildLayer(){if(this.willRebuildLayer=!0,this.children)for(let t=0,e=this.children.length;t<e;++t)this.children[t].rebuildLayer()}resolveChanges(t){const e=this.props.data.changeList;e.length>0&&(this.needsViewDrawn=!0),t||this.props.data.resolve(this.id);for(let n=0,i=e.length;n<i;++n)e[n][0].changes={};return e}setBufferManager(t){this._bufferManager?console.warn("You can not change a layer's buffer strategy once it has been instantiated."):(this._bufferManager=t,this.diffManager=new Ym,this.diffManager.makeProcessor(this,t))}setBufferType(t){this._bufferType===void 0?this._bufferType=t:console.warn("You can not change a layers buffer strategy once it has been instantiated.")}shouldDrawView(t,e){for(const n in e)if(e[n]!==t[n])return!0;return!1}updateUniforms(){let t,e;for(let n=0,i=this.shaderIOInfo.uniforms.length;n<i;++n)t=this.shaderIOInfo.uniforms[n],e=t.update(t),t.materialUniforms.forEach(r=>r.value=e)}willUpdateProps(t){t.picking!==this.props.picking&&this.rebuildLayer(),t.ref!==this.props.ref&&this.props.ref&&(this.props.ref.easing=this.easingManager)}};let rn=Yd;rn.defaultProps={};const qd=Ie("performance");class la extends yi{constructor(e,n){super(n),this.container=new Ms,this.surface=e,this.init(n)}get layers(){return this.layerDiffs.items}get views(){return this.viewDiffs.items}init(e){if(!this.surface||!this.surface.gl)return;this.container=new Ms;const n=Td(this.surface.gl);this.layerDiffs=new Vr({buildItem:async i=>{if(qd("Building layer",i.key),!this.surface)return null;const r=i.init[0],s=i.init[1],a=new r(this.surface,this,Object.assign({},r.defaultProps,s));if(a.initializer=i,a.props.data.sync(),a.parent=s.parent,s.parent&&(s.parent.children?s.parent.children.push(a):s.parent.children=[a]),!a.init(this.views))return console.warn("Error initializing layer:",s.key,"A layer was unable to be added to the surface. See previous warnings (if any) to determine why they could not be instantiated"),null;const o=a.childLayers();return this.layerDiffs.inline(o),a},destroyItem:async(i,r)=>(qd("Destroying layer",i.key),r.destroy(),!0),updateItem:async(i,r)=>{const s=i.init[1];if(r.willUpdateProps(s),s.data!==r.props.data&&s.data.sync(),r.shouldDrawView(r.props,s)&&(r.needsViewDrawn=!0),Object.assign(r.props,s),r.initializer.init[1]=r.props,r.didUpdateProps(),s.parent&&r.parent&&r.parent!==s.parent){const a=r.parent.children||[],o=a.indexOf(r)||-1;o>-1&&a.splice(o,1)}r.parent=s.parent,r.willRebuildLayer?(this.layerDiffs.rebuild(),r.willRebuildLayer=!1):this.layerDiffs.inline(r.childLayers())}}),this.viewDiffs=new Vr({buildItem:async i=>{if(!this.surface)return null;const r=new i.init[0](this,i.init[1]);return r.props.camera=r.props.camera||n.camera,r.pixelRatio=this.surface.pixelRatio,r.resource=this.surface.resourceManager,this.surface.userInputManager.waitingForRender=!0,r},destroyItem:async(i,r)=>!0,updateItem:async(i,r)=>{const s=i.init[1];r.willUpdateProps(s),r.shouldDrawView(r.props,s)&&(r.needsDraw=!0),Object.assign(r.props,s),r.didUpdateProps(),this.surface&&(this.surface.userInputManager.waitingForRender=!0)}}),this.update(e)}destroy(){delete this.container,this.layerDiffs.destroy(),this.viewDiffs.destroy()}removeLayer(e){if(this.layers){const n=this.layers.indexOf(e);if(n>=0){this.layers.splice(n,1);return}}}async update(e){this.order=e.order,await this.viewDiffs.diff(e.views),await this.layerDiffs.diff(e.layers),this.views.forEach(n=>n.createRenderTarget())}}la.DEFAULT_SCENE_ID="__default__";var Ji=(t=>(t[t.COLOR=1]="COLOR",t[t.DEPTH=2]="DEPTH",t[t.STENCIL=4]="STENCIL",t))(Ji||{});function Pc(t,e){const n=Object.assign(e,{key:e.key||"",viewport:e.viewport||{left:0,right:0,top:0,bottom:0}});return{get key(){return e.key||""},init:[t,n]}}const Kd=class extends yi{constructor(t,e){super(e),this.animationEndTime=0,this.depth=0,this.lastFrameTime=0,this.needsDraw=!1,this.optimizeRendering=!1,this._pixelRatio=1,this.scene=t,this.props=Object.assign({},Kd.defaultProps||{},e)}get pixelRatio(){return this.props.pixelRatio??this._pixelRatio}set pixelRatio(t){this._pixelRatio=t}get screenBounds(){return this.projection.screenBounds}set screenBounds(t){this.projection.screenBounds=t}get viewBounds(){return this.projection.viewBounds}set viewBounds(t){this.projection.viewBounds=t}get clearFlags(){return this.props.clearFlags||[]}get order(){return this.props.order||0}getOutputTargets(){const{output:t}=this.props;let e=[];return t?(bi(t.buffers)||Ys(t.buffers)?e=[{outputType:$.COLOR,resource:t.buffers}]:Object.keys(t.buffers).forEach(n=>{const i=Number.parseFloat(n),r=t.buffers[i];r&&e.push({outputType:i,resource:r})}),e):null}getRenderTargets(){return this.renderTarget?[this.renderTarget]:[]}createRenderTarget(){this.renderTarget&&(Array.isArray(this.renderTarget)?this.renderTarget.forEach(l=>l.dispose()):this.renderTarget.dispose());const{output:t}=this.props,e=this.scene.surface;if(!t||!e)return;const n=new Set;for(let l=0,h=this.scene.layers.length;l<h;++l){const p=this.scene.layers[l].shaderIOInfo.fs.get(this);p&&p.outputTypes.forEach(g=>n.add(g))}const i=new Map,r=new rn(e,this.scene,{key:"",data:new he}),s=new ze({}),a=this.getOutputTargets()||[];for(let l=0,h=a.length;l<h;++l){const f=a[l],p=f.resource;if(n.has(f.outputType))if(bi(p)){const g=jr({key:f.resource.key});if(this.resource.request(r,s,g),!g.texture)throw console.warn("A view has a RenderTexture output target with key:",f.resource.key,"however, no RenderTexture was found for the key.","Please ensure you have a 'resource' specified for the Surface with the proper key","Also ensure the resource is made via createTexture()"),new Error(`Output target unable to be constructed for view ${this.id}`);i.set(f.outputType,g.texture)}else{const g=Tc({key:f.resource.key});if(this.resource.request(r,s,g),!g.colorBuffer)throw console.warn("A view has a ColorBuffer output target with key:",f.resource.key,"however, no ColorBuffer was found for the key.","Please ensure you have a 'resource' specified for the Surface with the proper key","Also ensure the resource is made via createColorBuffer()"),new Error(`Output target unable to be constructed for view ${this.id}`);i.set(f.outputType,g.colorBuffer)}}let o,c;i.forEach(l=>{var h,f,p;if(l instanceof ie){if((o===void 0||c===void 0)&&(o=((h=l.data)==null?void 0:h.width)||0,c=((f=l.data)==null?void 0:f.height)||0),o===0||c===0)throw new Error("RenderTexture for View can NOT have a width or height of zero.");if(((p=l.data)==null?void 0:p.width)!==o||l.data.height!==c)throw new Error("When a view has multiple output targets: ALL RenderTextures and ColorBuffers that a view references MUST have the same dimensions")}else{if((o===void 0||c===void 0)&&(o=l.size[0]||0,c=l.size[1]||0),o===0||c===0)throw new Error("RenderTexture for View can NOT have a width or height of zero.");if(l.size[0]!==o||l.size[1]!==c)throw new Error("When a view has multiple output targets: ALL RenderTextures and ColorBuffers that a view references MUST have the same dimensions")}});let u;if(t.depth)if(bi(t.depth)){const l=jr({key:t.depth.key});if(this.resource.request(r,s,l),!l.texture)throw console.warn("A view has a depth buffer output target with key:",t.depth,"however, no RenderTexture was found for the key.","Please ensure you have a 'resource' specified for the Surface with the proper key","Also ensure the resource is made via createTexture()"),new Error(`Output target unable to be constructed for view ${this.id}`);u=l.texture}else if(Ys(t.depth)){const l=Tc({key:t.depth.key});if(this.resource.request(r,s,l),!l.colorBuffer)throw console.warn("A view has a depth buffer output target with key:",t.depth.key,"however, no ColorBuffer was found for the key.","Please ensure you have a 'resource' specified for the Surface with the proper key","Also ensure the resource is made via createColorBuffer()"),new Error(`Output target unable to be constructed for view ${this.id}`);u=l.colorBuffer}else u=d.GLSettings.RenderTarget.DepthBufferFormat.DEPTH_COMPONENT16;if(L.MRT){const l=[];i.forEach((h,f)=>l.push({buffer:h,outputType:f})),this.renderTarget=new Hn({buffers:{color:l,depth:u},retainTextureTargets:!0})}else throw new Error("MRT for non-MRT systems not supported yet.")}willUseView(){const t=this.getRenderTargets();this.props.screenScale&&(this.projection.screenScale=this.props.screenScale),t.some(n=>n.getBuffers().some(i=>!!i.buffer.destroyed))&&this.createRenderTarget()}shouldDrawView(t,e){for(const n in e)if(e[n]!==t[n])return!0;return!1}willUpdateProps(t){}didUpdateProps(){}};let Xr=Kd;Xr.defaultProps={key:"",camera:An.makeOrthographic(),viewport:{left:0,right:0,top:0,bottom:0}};class Zd extends Xr{constructor(){super(new la(void 0,{key:"error",layers:[],views:[]}),{key:"error",viewport:{},camera:An.makeOrthographic()}),this.projection=new hu,this.screenBounds=new te({x:0,y:0,width:100,height:100})}screenToWorld(e,n){return[0,0]}worldToScreen(e,n){return[0,0]}viewToWorld(e,n){return[0,0]}worldToView(e,n){return[0,0]}fitViewtoViewport(e,n){this.screenBounds=e}}const i0=1e3,r0=200,In=new Zd;In.fitViewtoViewport(new te({x:0,y:0,width:100,height:100}),new te({x:0,y:0,width:100,height:100}));function s0(t,e){return e.d&&t.d?e.d.depth-t.d.depth:0}function Dc(t,e){return t.touch.identifier-e.touch.identifier}class Jd{constructor(e,n,i,r){this.eventManagers=[],this.eventCleanup=[],this._waitingForRender=!0,this.getViewsUnderPosition=s=>{if(!this.quadTree)return[];const a=this.quadTree.query(s);return a.sort(s0),a},this.resize=()=>{this._waitingForRender=!0},this.context=e,this.surface=n,this.setControllers(i),this.addContextListeners(r)}get waitingForRender(){return this._waitingForRender}set waitingForRender(e){if(this._waitingForRender=e,!e){this.quadTree=new Kh(0,0,0,0);const n=this.scenes,i=[];for(let r=0,s=n.length;r<s;++r){const a=n[r];for(let o=0,c=a.views.length;o<c;++o){const u=a.views[o];i.push(u.screenBounds)}}this.quadTree.addAll(i)}}get scenes(){return!this.surface||!this.surface.sceneDiffs?[]:this.surface.sceneDiffs.items}addContextListeners(e){this.addMouseContextListeners(e),this.addTouchContextListeners()}addMouseContextListeners(e){const n=this.context;if(gi(n))return;let i,r=!1;if(e){const s=a=>{const o=Ct(a,n),c=this.getViewsUnderPosition(o);if(c.length<=0)return;i={canClick:!1,currentPosition:o,deltaPosition:[0,0],previousPosition:o,start:o,startTime:Date.now(),startView:c[0].d,event:a,wheel:this.makeWheel(a),button:-1};const u=this.makeMouseInteraction(i);this.eventManagers.forEach(l=>{l.handleWheel(u)}),a.stopPropagation(),a.preventDefault()};"onwheel"in n&&(n.onwheel=s),"addEventListener"in n&&(n.addEventListener("DOMMouseScroll",s),this.eventCleanup.push(["DOMMouseScroll",s]))}n.onmouseleave=s=>{if(this.waitingForRender||!i)return;const a=Ct(s,n);i.deltaPosition=ye(a,i.currentPosition),i.previousPosition=i.currentPosition,i.currentPosition=a;const o=this.makeMouseInteraction(i);this.eventManagers.forEach(c=>{c.handleMouseOut(o)})},n.onmousemove=s=>{if(this.waitingForRender)return;const a=Ct(s,n);if(!i){const c=this.getViewsUnderPosition(a);i={canClick:!1,currentPosition:a,deltaPosition:[0,0],previousPosition:a,start:a,startTime:Date.now(),startView:c[0].d,event:s,wheel:this.makeWheel(),button:-1}}i.deltaPosition=ye(a,i.currentPosition),i.previousPosition=i.currentPosition,i.currentPosition=a,i.canClick=!1;const o=this.makeMouseInteraction(i);this.eventManagers.forEach(c=>{c.handleMouseMove(o)}),r=!0},n.onmousedown=s=>{if(this.waitingForRender)return;const a=Ct(s,n),o=this.getViewsUnderPosition(a);if(o.length<=0)return;i={canClick:!0,currentPosition:a,deltaPosition:[0,0],previousPosition:a,start:a,startTime:Date.now(),startView:o[0].d,event:s,wheel:this.makeWheel(),button:s.button};const c=this.makeMouseInteraction(i);this.eventManagers.forEach(l=>{l.handleMouseDown(c)}),s.stopPropagation(),document.onmousemove=l=>{if(!i)return;if(!r){const f=Ct(l,n);i.deltaPosition=ye(f,i.currentPosition),i.previousPosition=i.currentPosition,i.currentPosition=f,i.canClick=!1}const h=this.makeMouseInteraction(i);this.eventManagers.forEach(f=>{f.handleDrag(h)}),l.preventDefault(),l.stopPropagation(),r=!1},document.onmouseup=l=>{document.onmousemove=null,document.onmouseup=null,document.onmouseover=null,i=void 0},document.onmouseover=l=>{if(!i)return;const h=Ct(l,n);i.deltaPosition=ye(h,i.currentPosition),i.previousPosition=i.currentPosition,i.currentPosition=h;const f=this.makeMouseInteraction(i);this.eventManagers.forEach(p=>{p.handleMouseOver(f)}),l.stopPropagation()},n.onmouseup=l=>{if(!i)return;const h=Ct(l,n);i.deltaPosition=ye(h,i.currentPosition),i.previousPosition=i.currentPosition,i.currentPosition=h,i.button=l.button;const f=this.makeMouseInteraction(i);this.eventManagers.forEach(p=>{p.handleMouseUp(f)}),i.canClick&&Date.now()-i.startTime<i0&&this.eventManagers.forEach(p=>{p.handleClick(f)}),i=void 0};const u=n;u.onselectstart!==void 0?u.onselectstart=function(){return!1}:n.addEventListener("selectstart",function(){s.preventDefault()})}}addTouchContextListeners(){const e=this.context;if(gi(e))return;const n=new Map,i=new Map;function r(l){return l.map(h=>h.touch)}function s(l){return l.reduce((h,f)=>f.touch.startTime>h.touch.startTime?f:h,l[0])}const a={center:l=>l.length<=0?[0,0]:this.getTouchCenter(r(l)),centerDelta:l=>{if(l.length<=0)return[0,0];const h=r(l),f=this.getTouchCenter(h,g=>g.previousPosition),p=this.getTouchCenter(h);return ye(p,f)},centerStart:l=>{if(l.length<=0)return[0,0];const h=s(l).touch;return this.getTouchCenter(r(l),f=>f===h?f.start:f.startRelative.get(h)||[0,0])},id:l=>r(l).sort(Dc).map(f=>f.touch.identifier).join("_"),rotation:l=>{if(l.length<=0)return 0;const h=r(l),f=this.getTouchCenter(h);return this.getAverageAngle(h,f)},rotationDelta:l=>{if(l.length<=0)return 0;const h=r(l),f=this.getTouchCenter(h,T=>T.previousPosition),p=this.getAverageAngle(h,f,T=>T.previousPosition),g=this.getTouchCenter(h);return this.getAverageAngle(h,g)-p},rotationStart:l=>{if(l.length<=0)return 0;const h=s(l).touch,f=r(l),p=this.getTouchCenter(f,g=>g===h?g.start:g.startRelative.get(h)||[0,0]);return this.getAverageAngle(f,p,g=>g===h?g.start:g.startRelative.get(h)||[0,0])},spread:l=>{if(l.length<=0)return 0;const h=r(l),f=this.getTouchCenter(h);return this.getAverageDistance(h,f)},spreadDelta:l=>{if(l.length<=0)return 0;const h=r(l),f=this.getTouchCenter(h,T=>T.previousPosition),p=this.getAverageDistance(h,f,T=>T.previousPosition),g=this.getTouchCenter(h);return this.getAverageDistance(h,g)-p},spreadStart:l=>{if(l.length<=0)return 0;const h=s(l).touch,f=r(l),p=this.getTouchCenter(f,g=>g===h?g.start:g.startRelative.get(h)||[0,0]);return this.getAverageDistance(f,p,g=>g===h?g.start:g.startRelative.get(h)||[0,0])}};e.ontouchstart=l=>{l.preventDefault(),l.stopPropagation();const h=this.getTouches(l),f=[],p=[];for(let g=0,m=h.length;g<m;++g){const T=h[g],w=n.get(T.identifier);if(w)f.push(w);else{const y=Ct(T),b=this.getViewsUnderPosition(y);if(b.length<=0)continue;const A=b[0].d,R={canTap:!0,currentPosition:y,deltaPosition:[0,0],startTime:Date.now(),start:y,startView:A,previousPosition:y,startRelative:new Map,touch:T};n.set(T.identifier,R),p.push(R)}}if(p.length>0){const g=p.concat(f),m=[];for(let w=0,y=p.length;w<y;++w){const b=p[w];for(let R=0,N=g.length;R<N;++R){const I=g[R];b!==I&&I.startRelative.set(b,I.currentPosition)}const A=this.makeSingleTouchInteraction(b);m.push(A),i.set(b.touch.identifier,A)}const T={touches:m,allTouches:g.map(w=>i.get(w.touch.identifier)).filter(me),multitouch:a};this.eventManagers.forEach(w=>{w.handleTouchDown(T)})}document.ontouchend=g=>{o.call(document,g),document.ontouchend=null,document.ontouchcancel=null,document.ontouchmove=null},document.ontouchcancel=g=>{u.call(document,g),document.ontouchend=null,document.ontouchcancel=null,document.ontouchmove=null},document.ontouchmove=c};const o=e.ontouchend=l=>{l.stopPropagation(),l.preventDefault();const h=this.getTouches(l,"changed"),f=Array.from(i.values()),p=[];for(let g=0,m=h.length;g<m;++g){const T=h[g],w=n.get(T.identifier);if(w){if(w.canTap&&Date.now()-w.startTime<r0){const b={touches:[this.makeSingleTouchInteraction(w)],allTouches:f,multitouch:a};this.eventManagers.forEach(A=>{A.handleTap(b)})}p.push(w),n.delete(T.identifier),i.delete(T.identifier)}}if(p.length>0){const m={touches:p.map(T=>this.makeSingleTouchInteraction(T)),allTouches:f,multitouch:a};this.eventManagers.forEach(T=>{T.handleTouchUp(m)})}},c=e.ontouchmove=l=>{l.stopPropagation(),l.preventDefault();const h=this.getTouches(l),f=[],p=[];for(let g=0,m=h.length;g<m;++g){const T=h[g],w=n.get(T.identifier);if(w){const y=Ct(T),b=ye(y,w.currentPosition);if(Vn(b)<=0){p.push(w),Object.assign(w,{currentPosition:y,deltaPosition:b,previousPosition:w.currentPosition,touch:T});continue}f.push(w),Object.assign(w,{canTap:!1,currentPosition:y,deltaPosition:b,previousPosition:w.currentPosition,touch:T})}}if(f.length>0){const g=f.concat(p),T={touches:f.map(w=>this.makeSingleTouchInteraction(w)),allTouches:g.map(w=>i.get(w.touch.identifier)).filter(me),multitouch:a};this.eventManagers.forEach(w=>{w.handleTouchDrag(T)})}},u=e.ontouchcancel=l=>{l.stopPropagation(),l.preventDefault();const h=this.getTouches(l,"changed"),f=Array.from(i.values()),p=[];for(let g=0,m=h.length;g<m;++g){const T=h[g],w=n.get(T.identifier);w&&(p.push(w),n.delete(T.identifier),i.delete(T.identifier))}if(p.length>0){const m={touches:p.map(T=>this.makeSingleTouchInteraction(T)),allTouches:f,multitouch:a};this.eventManagers.forEach(T=>{T.handleTouchCancelled(m)})}}}getAverageDistance(e,n,i){let r=0;if(e.length<=0)return r;i||(i=s=>s.currentPosition);for(let s=0,a=e.length;s<a;++s){const o=e[s];r+=Vn(ye(i(o),n))}return r/e.length}getAverageAngle(e,n,i){let r=0;if(e.length<=0)return r;i||(i=s=>s.currentPosition);for(let s=0,a=e.length;s<a;++s){const o=e[s],c=ye(i(o),n);let u=Math.atan2(c[1],c[0]);u<0&&(u+=Math.PI*2),r+=u}return r/e.length}getTouchCenter(e,n){let i=[0,0];if(e.length<=0)return i;n||(n=r=>r.currentPosition);for(let r=0,s=e.length;r<s;++r){const a=e[r],o=n(a);i=wn(i,o)}return Re(i,1/e.length)}getTouches(e,n){const i=new Map;if(e.touches&&e.touches.length>0&&(!n||n==="touches"))for(let r=0,s=e.touches.length;r<s;++r){const a=e.touches.item(r);a&&i.set(a.identifier,a)}if(e.changedTouches&&e.changedTouches.length>0&&(!n||n==="changed"))for(let r=0,s=e.changedTouches.length;r<s;++r){const a=e.changedTouches.item(r);a&&i.set(a.identifier,a)}if(e.targetTouches&&e.targetTouches.length>0&&(!n||n==="target"))for(let r=0,s=e.targetTouches.length;r<s;++r){const a=e.targetTouches.item(r);a&&i.set(a.identifier,a)}return Array.from(i.values())}getView(e){const n=this.scenes;for(let i=0,r=n.length;i<r;++i){const a=n[i].viewDiffs.getByKey(e);if(a)return a}return null}makeMouseInteraction(e){const n=this.getViewsUnderPosition(e.currentPosition);let i=n[0]&&n[0].d;i||(i=In);const r=this.getViewsUnderPosition(e.start);let s=e.startView;s||(s=In);const a={canvas:gi(this.context)?void 0:this.context,mouse:e,screen:{position:e.currentPosition},start:{position:s.projection.screenToView(e.start),view:s,views:r.map(o=>(o.d||(o.d=In),{position:o.d.projection.screenToView(e.start),view:o.d}))},target:{position:i.projection.screenToView(e.currentPosition),view:i,views:n.map(o=>(o.d||(o.d=In),{position:o.d.projection.screenToView(e.currentPosition),view:o.d}))}};return this.currentInteraction=a,a}makeSingleTouchInteraction(e){const n=e.currentPosition,i=this.getViewsUnderPosition(n);let r=i[0]&&i[0].d;r||(r=In);let s=e.startView;s||(s=In);const a={canvas:gi(this.context)?void 0:this.context,touch:e,screen:{position:n},start:{position:s.projection.screenToView(e.start),view:s,views:this.getViewsUnderPosition(e.start).map(o=>(o.d||(o.d=In),{position:o.d.projection.screenToView(e.start),view:o.d}))},target:{position:r.projection.screenToView(n),view:r,views:i.map(o=>(o.d||(o.d=In),{position:o.d.projection.screenToView(n),view:o.d}))}};return this.currentInteraction=a,a}makeMultiTouchInteractions(e,n){e.sort(Dc);const i=this.allTouchCombinations(e);for(let r=0,s=i.length;r<s;++r){const a=i[r],o=a.map(u=>u.touch.identifier).join("_");let c=n.get(o);if(!c){const u=this.getTouchCenter(a);c={touches:a,averageSpreadDelta:0,startCenter:u,currentCenter:u,currentRotation:this.getAverageAngle(a,u),centerDelta:[0,0],rotationDelta:0},n.set(o,c)}}}updateMultiTouchInteractions(e,n){e.sort(Dc);const i=this.allTouchCombinations(e);for(let r=0,s=i.length;r<s;++r){const a=i[r],o=a.map(u=>u.touch.identifier).join("_"),c=n.get(o);if(c){const u=this.getTouchCenter(a),l=this.getAverageAngle(a,u);c.centerDelta=ye(u,c.currentCenter),c.currentCenter=u,c.rotationDelta=l-c.currentRotation,c.currentRotation=l}}}allTouchCombinations(e){const n=[],i=e.length,r=1<<i;for(let s=1;s<r;s++){const a=[];for(let o=0;o<i;o++)s&1<<o&&a.push(e[o]);n.push(a)}return n}makeWheel(e){if(!e)return{delta:[0,0]};const n=Ho(e);return{delta:[n.pixelX,n.pixelY]}}setControllers(e){this.eventManagers=e;for(const n of this.eventManagers)n.setUserInputManager(this)}destroy(){delete this.quadTree,gi(this.context)||(this.context.onmousedown=null,this.context.onmousemove=null,this.context.onmouseleave=null);const e=this.context;e.onmousewheel&&(e.onmousewheel=null),this.eventCleanup.forEach(n=>{this.context.removeEventListener(n[0],n[1])})}}class Fc extends Pi{constructor(e,n=!1){super(),this.preserveQueueMouse=[],this.singleQueueMouse=new Map,this.preserveQueueTouch=[],this.singleQueueTouch=new Map,this.preserveEvents=!1,this.handlers=new is(e),this.preserveEvents=n}dequeue(){try{this.preserveEvents?(this.preserveQueueMouse.forEach(e=>{e[0](e[1])}),this.preserveQueueTouch.forEach(e=>{e[0](e[1])})):(this.singleQueueMouse.forEach((e,n)=>{n(e)}),this.singleQueueTouch.forEach((e,n)=>{n(e)}))}catch(e){console.error("Queued events had errors. Further events aborted"),e instanceof Error&&console.error(e.stack||e.message)}this.preserveQueueMouse=[],this.singleQueueMouse.clear(),this.preserveQueueTouch=[],this.singleQueueTouch.clear()}handleMouseDown(e){this.preserveEvents?this.preserveQueueMouse.push([this.handlers.handleMouseDown,e]):this.singleQueueMouse.set(this.handlers.handleMouseDown,e)}handleMouseUp(e){this.preserveEvents?this.preserveQueueMouse.push([this.handlers.handleMouseUp,e]):this.singleQueueMouse.set(this.handlers.handleMouseUp,e)}handleMouseOver(e){this.preserveEvents?this.preserveQueueMouse.push([this.handlers.handleMouseOver,e]):this.singleQueueMouse.set(this.handlers.handleMouseOver,e)}handleMouseOut(e){this.preserveEvents?this.preserveQueueMouse.push([this.handlers.handleMouseOut,e]):this.singleQueueMouse.set(this.handlers.handleMouseOut,e)}handleMouseMove(e){this.preserveEvents?this.preserveQueueMouse.push([this.handlers.handleMouseMove,e]):this.singleQueueMouse.set(this.handlers.handleMouseMove,e)}handleClick(e){this.preserveEvents?this.preserveQueueMouse.push([this.handlers.handleClick,e]):this.singleQueueMouse.set(this.handlers.handleClick,e)}handleDrag(e){this.preserveEvents?this.preserveQueueMouse.push([this.handlers.handleDrag,e]):this.singleQueueMouse.set(this.handlers.handleDrag,e)}handleWheel(e){this.preserveEvents?this.preserveQueueMouse.push([this.handlers.handleWheel,e]):this.singleQueueMouse.set(this.handlers.handleWheel,e)}handleTouchCancelled(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleTouchCancelled,e]):this.singleQueueTouch.set(this.handlers.handleTouchCancelled,e)}handleTouchDown(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleTouchDown,e]):this.singleQueueTouch.set(this.handlers.handleTouchDown,e)}handleTouchUp(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleTouchUp,e]):this.singleQueueTouch.set(this.handlers.handleTouchUp,e)}handleTouchOut(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleTouchOut,e]):this.singleQueueTouch.set(this.handlers.handleTouchOut,e)}handleTouchDrag(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleTouchDrag,e]):this.singleQueueTouch.set(this.handlers.handleTouchDrag,e)}handleTap(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleTap,e]):this.singleQueueTouch.set(this.handlers.handleTap,e)}handleDoubleTap(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleDoubleTap,e]):this.singleQueueTouch.set(this.handlers.handleDoubleTap,e)}handleLongTouch(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleLongTouch,e]):this.singleQueueTouch.set(this.handlers.handleLongTouch,e)}handleLongTap(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleLongTap,e]):this.singleQueueTouch.set(this.handlers.handleLongTap,e)}handlePinch(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handlePinch,e]):this.singleQueueTouch.set(this.handlers.handlePinch,e)}handleSpread(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleSpread,e]):this.singleQueueTouch.set(this.handlers.handleSpread,e)}handleTouchRotate(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleTouchRotate,e]):this.singleQueueTouch.set(this.handlers.handleTouchRotate,e)}handleSwipe(e){this.preserveEvents?this.preserveQueueTouch.push([this.handlers.handleSwipe,e]):this.singleQueueTouch.set(this.handlers.handleSwipe,e)}}const ef=`// These are projection methods utilizing the simpler camera 2d approach.
// This assumes we have a 3D camera projection which should be preferably orthographic layered with simpler 2D camera
// controls for manipulating the 2D world.
vec3 cameraSpace(vec3 world) {
  return (world + cameraOffset) * cameraScale2D;
}

vec3 cameraSpaceSize(vec3 worldSize) {
  return worldSize * cameraScale2D;
}

vec4 clipSpace(vec3 world) {
  return (viewProjection) * vec4(cameraSpace(world), 1.0);
}

vec4 clipSpaceSize(vec3 worldSize) {
  return (viewProjection) * vec4(cameraSpaceSize(worldSize), 0.0);
}
`,a0=Bs.immediate(0);class Cn{constructor(e,n){this._id=G(),this.animation=Bs.immediate(0),this.animationEndTime=0,this.offsetBroadcastTime=0,this.scaleBroadcastTime=0,this._offset=[0,0,0],this.startOffset=[0,0,0],this.startOffsetTime=0,this.offsetEndTime=0,this._scale=[1,1,1],this.startScale=[1,1,1],this.startScaleTime=0,this.scaleEndTime=0,this.needsBroadcast=!1,this.camera=e,n&&(this._offset=nt(n.offset||this._offset),this._scale=nt(n.scale||this._scale))}get id(){return this._id}broadcast(e){this.offset,this.scale,this.needsBroadcast&&(this.needsBroadcast=!1,this.onViewChange&&this.onViewChange(this.camera,e))}centerOn(e,n){var o;const i=(o=this.surface)==null?void 0:o.getViewSize(e);if(!i)return;const r=[i.width/2,i.height/2,0],s=St(n,ur(r,this._scale)),a=this.animation;this.setOffset(nt(this.offset)),this.animation=a0,this.setOffset(it(s,-1)),this.animation=a}getCurrentTime(){return this.surface?this.surface.frameMetrics.currentTime:0}getOffset(){return this._offset}getScale(){return this._scale}get offset(){const e=this.getCurrentTime();return this.onViewChange&&this.offsetBroadcastTime<this.offsetEndTime&&(this.offsetBroadcastTime=e,this.needsBroadcast=!0),this.animation.cpu(this.startOffset,this._offset,(e-this.startOffsetTime)/this.animation.duration)}setId(e){this._id=e,this.camera.needsViewDrawn=!0}setOffset(e){this.startOffset=nt(this.offset),this._offset=nt(e),this.startOffsetTime=this.getCurrentTime(),this.offsetEndTime=this.startOffsetTime+this.animation.duration,this.updateEndTime(),this.camera.needsViewDrawn=!0,this.onViewChange&&(this.offsetBroadcastTime=this.startOffsetTime,this.needsBroadcast=!0)}get scale(){const e=this.getCurrentTime();return this.onViewChange&&this.scaleBroadcastTime<this.scaleEndTime&&(this.scaleBroadcastTime=e,this.needsBroadcast=!0),this.animation.cpu(this.startScale,this._scale,(e-this.startScaleTime)/this.animation.duration)}setViewChangeHandler(e){this.onViewChange=e}setScale(e){this.startScale=nt(this.scale),this._scale=nt(e),this.startScaleTime=this.getCurrentTime(),this.scaleEndTime=this.startScaleTime+this.animation.duration,this.updateEndTime(),this.camera.needsViewDrawn=!0,this.onViewChange&&(this.scaleBroadcastTime=this.startScaleTime,this.needsBroadcast=!0)}resolve(){this.camera.needsViewDrawn=!1,this.needsBroadcast=!1}update(){this.camera.needsViewDrawn=!0}updateEndTime(){this.animationEndTime=Math.max(this.scaleEndTime,this.offsetEndTime)}}class sn extends An{constructor(e){super({left:-100,right:100,top:-100,bottom:100,near:-100,far:1e5,type:xn.ORTHOGRAPHIC}),this.control2D=new Cn(this,e)}get control2D(){return this._control2D}set control2D(e){this._control2D=e}get scale2D(){return this.control2D.scale}get offset(){return this.control2D.offset}}class tf{sortInstanceAttributes(e,n){return e.resource&&!n.resource||e.easing&&!n.easing?-1:1}sortVertexAttributes(e,n){return 1}sortUniforms(e,n){return 1}}class nf extends Fc{constructor(){super({handleClick:async e=>{var n,i;this.enablePicking(),await((n=this.willRenderResolver)==null?void 0:n.promise),this.enablePicking(),await((i=this.didRenderResolver)==null?void 0:i.promise),this.handleInteraction(e,(r,s)=>{var a;(a=r.interactions)==null||a.handleMouseClick(s,e)})},handleTap:async e=>{var n,i;this.enablePicking(),await((n=this.willRenderResolver)==null?void 0:n.promise),this.enablePicking(),await((i=this.didRenderResolver)==null?void 0:i.promise),e.touches.forEach(r=>{this.handleInteraction(r,(s,a)=>{var o;(o=s.interactions)==null||o.handleTap(a,e,r)})})},handleDrag:async e=>{var n;await((n=this.willRenderResolver)==null?void 0:n.promise),this.handleInteraction(e,(i,r)=>{var s;(s=i.interactions)==null||s.handleMouseDrag(r,e)})},handleMouseDown:async e=>{var n;this.enablePicking(),await((n=this.willRenderResolver)==null?void 0:n.promise),this.handleInteraction(e,(i,r)=>{var s;return(s=i.interactions)==null?void 0:s.handleMouseDown(r,e)})},handleTouchDown:async e=>{var n;this.enablePicking(),await((n=this.willRenderResolver)==null?void 0:n.promise),e.touches.forEach(i=>{this.handleInteraction(i,(r,s)=>{var a;return(a=r.interactions)==null?void 0:a.handleTouchDown(s,e,i)})})},handleMouseUp:async e=>{var n;await((n=this.willRenderResolver)==null?void 0:n.promise),this.handleInteraction(e,(i,r)=>{var s;return(s=i.interactions)==null?void 0:s.handleMouseUp(r,e)})},handleTouchUp:async e=>{var n;await((n=this.willRenderResolver)==null?void 0:n.promise),e.touches.forEach(i=>{this.handleInteraction(i,(r,s)=>{var a;return(a=r.interactions)==null?void 0:a.handleTouchUp(s,e,i)})})},handleMouseOut:async e=>{var n;await((n=this.willRenderResolver)==null?void 0:n.promise),this.isOver.forEach(i=>{this.handleView(i,(r,s)=>{var a;return(a=r.interactions)==null?void 0:a.handleMouseOut(s,e)})}),this.isOver.clear()},handleTouchOut:async e=>{var n;await((n=this.willRenderResolver)==null?void 0:n.promise),e.touches.forEach(i=>{Ks(this.isTouchOver,i.touch.touch.identifier,new Set).forEach(s=>{this.handleView(s,(a,o)=>{var c;return(c=a.interactions)==null?void 0:c.handleTouchOut(o,e,i)})}),this.isOver.clear()})},handleMouseMove:async e=>{var r;this.enablePicking(),await((r=this.willRenderResolver)==null?void 0:r.promise);const n=this.handleInteraction(e,(s,a)=>{var o;return(o=s.interactions)==null?void 0:o.handleMouseMove(a,e)}),i=new Set;n.forEach(s=>i.add(s)),this.isOver.forEach(s=>{i.has(s)||this.handleView(s,(a,o)=>{var c;return(c=a.interactions)==null?void 0:c.handleMouseOut(o,e)})}),i.forEach(s=>{this.isOver.has(s)||this.handleView(s,(a,o)=>{var c;return(c=a.interactions)==null?void 0:c.handleMouseOver(o,e)})}),this.isOver=i},handleTouchDrag:async e=>{var n;this.enablePicking(),await((n=this.willRenderResolver)==null?void 0:n.promise),e.touches.forEach(i=>{const r=this.handleInteraction(i,(o,c)=>{var u;return(u=o.interactions)==null?void 0:u.handleTouchMove(c,e,i)}),s=new Set;r.forEach(o=>s.add(o));const a=Jn(this.isTouchOver,i.touch.touch.identifier,new Set);a.forEach(o=>{s.has(o)||this.handleView(o,(c,u)=>{var l;return(l=c.interactions)==null?void 0:l.handleTouchOut(u,e,i)})}),s.forEach(o=>{a.has(o)||this.handleView(o,(c,u)=>{var l;return(l=c.interactions)==null?void 0:l.handleTouchOver(u,e,i)})}),this.isTouchOver.set(i.touch.touch.identifier,s)})}}),this.isOver=new Set,this.isTouchOver=new Map}get scenes(){return!this.surface||!this.surface.sceneDiffs?[]:this.surface.sceneDiffs.items}enablePicking(){this.surface&&this.surface.enableOptimizedOutput($.PICKING)}willRender(){var e;for(let n=0,i=this.scenes.length;n<i;++n){const r=this.scenes[n];for(let s=0,a=r.layers.length;s<a;++s)(e=r.layers[s].interactions)==null||delete e.colorPicking}this.willRenderResolver&&this.willRenderResolver.resolve(),this.willRenderResolver=new ke,this.dequeue()}async didRender(){this.didRenderResolver&&this.didRenderResolver.resolve(),this.didRenderResolver=new ke}getSceneViewsUnderMouse(e){const n=new Map;for(let i=0,r=this.scenes.length;i<r;++i){const s=this.scenes[i];for(let a=0,o=s.views.length;a<o;++a){const c=s.views[a];n.set(c.id,c)}}return e.target.views.map(i=>n.get(i.view.id)).filter(me)}handleInteraction(e,n){const i=this.getSceneViewsUnderMouse(e);for(let r=0,s=i.length;r<s;++r){const a=i[r];this.handleView(a,n)}return i}handleView(e,n){for(let i=0,r=e.scene.layers.length;i<r;++i){const s=e.scene.layers[i];s.picking&&s.picking.type!==X.NONE&&n(s,e)}}}class o0{rawVertex(e){return e}rawFragment(e){return e}}class c0 extends o0{vertex(e){let n=Wr(e);return L.SHADERS_3_0?(n=n.replace(/\s+varying\s+/g,`
out `),n=n.replace(/(texture2D(\s+)\(|texture2D\()/g,"texture(")):(n=n.replace(/^#version 300 es/g,""),n=n.replace(/\s+out\s+/g,`
varying `)),n}fragment(e){let n=Wr(e);if(L.SHADERS_3_0){if(n=n.replace(/\s+varying\s+/g,`
in `),n=n.replace(/(texture2D(\s+)\(|texture2D\()/g,"texture("),n.match(/gl_FragColor/g)&&(n=n.replace(/gl_FragColor/g,"_FragColor"),!n.match("out vec4 _FragColor"))){const i=n.split(`
`);i.splice(3,0,"layout(location = 0) out vec4 _FragColor;"),n=i.join(`
`)}}else n=n.replace(/^#version 300 es/g,""),n=n.replace(/\s+in\s+/g,`
varying `);return n}}function l0(t,e,n,i,r){const s={view:t,allColors:[],colorData:n,dataHeight:r,dataWidth:i,mouse:e,nearestColor:0,nearestColorBytes:[0,0,0,0]},a=new Map;let o=0;const c=i/2,u=r/2;let l=0,h=[0,0,0,0],f=Number.MAX_SAFE_INTEGER;for(let p=0;p<r;++p)for(let g=0;g<i;++g){const m=n[o],T=n[o+1],w=n[o+2];o+=4;const y=m<<16|T<<8|w;if(a.set(y,!0),y!==0){const b=g-c,A=p-u,R=b*b+A*A;R<f&&(f=R,l=y,h=[m,T,w,255])}}return s.allColors=Array.from(a.keys()),s.nearestColor=l,s.nearestColorBytes=h,s}class u0{constructor(e){this.pickingRenderTargets=new Map,this.surface=e.surface}analyzePickedPixels(e,n){if(n.optimizeRendering)return;const i=cr(Re(e,this.surface.pixelRatio),n.projection.screenScale),r=5,s=5,a=4,o=new Uint8Array(r*s*a);this.surface.renderer.readPixels(Math.floor(i[0]-r/2),Math.floor(i[1]-s/2),r,s,o);const c=l0(n,[i[0]-n.screenBounds.x,i[1]-n.screenBounds.y],o,r,s);for(let u=0,l=n.scene.layers.length;u<l;++u){const h=n.scene.layers[u];h.picking.type===X.SINGLE&&(h.interactions.colorPicking=c)}}decodePicking(){const e=this.surface.getCurrentInteraction();if(!e)return;const n=e.screen.position,i=e.target.views.map(s=>s.view),r=new Set;this.pickingRenderTargets.forEach((s,a)=>{const o=s.getBuffers()[0].buffer;o instanceof ie&&(!o.gl||o.destroyed)&&(s.dispose(),r.add(a))}),r.forEach(s=>this.pickingRenderTargets.delete(s)),i.forEach(s=>{let a=this.pickingRenderTargets.get(s);if(a||s.getRenderTargets().forEach(u=>{u.gl&&u.getBuffers().forEach(l=>{if(l.outputType===$.PICKING){if(l.buffer instanceof ie&&l.buffer.generateMipMaps&&nn("decode-picking-error",()=>{console.warn("The Texture you provided as the target for color picking has generateMipMaps enabled. This can cause accuracy issues and may make your picking experience poor.")}),a=new Hn({buffers:{color:l}}),a.width===0||a.height===0){a=void 0;return}this.pickingRenderTargets.set(s,a)}})}),!a)return;const o=this.surface.renderer.state.currentRenderTarget;let c=!1;o?(Array.isArray(o)||o.getBuffers()[0].buffer!==a.getBuffers()[0].buffer)&&(c=!0):c=!0,c&&this.surface.renderer.setRenderTarget(a),this.analyzePickedPixels(n,s)})}}const rf=()=>[new xd,new Ad,new _d],sf=()=>[{type:le.COLOR_BUFFER,manager:new Dg},{type:le.TEXTURE,manager:new ad},{type:le.ATLAS,manager:new sd({})},{type:le.FONT,manager:new vd}],af=()=>[new c0],h0=[0,0,0,0];function Bc(t,e){return(t.order||Number.MAX_SAFE_INTEGER)-(e.order||Number.MAX_SAFE_INTEGER)}class of{constructor(e){this.commands=new u0({surface:this}),this.frameMetrics={currentFrame:0,currentTime:Date.now()|0,frameDuration:1e3/60,previousTime:Date.now()|0},this.isBufferingResources=!1,this.ioExpanders=[],this.shaderTransforms=[],this.optimizedOutputs=new Set([$.PICKING]),this.ioSorting=new tf,this.pixelRatio=window.devicePixelRatio,this.enabledOptimizedOutputs=new Set,this.viewDrawDependencies=new Map,this.resourceDiffs=new Vr({buildItem:async n=>(await this.resourceManager.initResource(n),{id:n.key}),destroyItem:async(n,i)=>(await this.resourceManager.destroyResource(n),!0),updateItem:async(n,i)=>{await this.resourceManager.updateResource(n)}}),this.sceneDiffs=new Vr({buildItem:async n=>new la(this,{key:n.key,views:n.views,layers:n.layers}),destroyItem:async(n,i)=>(i.destroy(),!0),updateItem:async(n,i)=>{await i.update(n)}}),this.readyResolver=new ke,this.ready=this.readyResolver.promise,e&&this.init(e)}get gl(){return this.context}get scenes(){return this.sceneDiffs.items}broadcastEventManagerCycle(e){for(let n=0,i=this.userInputManager.eventManagers.length;n<i;++n){const r=this.userInputManager.eventManagers[n];switch(e){case 1:r.didRender();break;case 0:r.willRender();break}}}async commit(e,n,i){if(!this.gl)return;let r=!1;n&&this.frameMetrics.currentFrame++,this.frameMetrics.frameDuration=this.frameMetrics.currentTime-this.frameMetrics.previousTime,this.frameMetrics.previousTime=this.frameMetrics.currentTime,e===void 0?this.frameMetrics.currentTime=Date.now()|0:(this.frameMetrics.previousTime===this.frameMetrics.currentTime&&(this.frameMetrics.previousTime=e),this.frameMetrics.currentTime=e),e=this.frameMetrics.currentTime;const s=this.sceneDiffs.items;s.sort(Bc);const a={};for(let c=0,u=s.length;c<u;++c){const l=s[c],h=l.views,f=l.layers;h.sort(Bc),f.sort(Bc);for(let p=0,g=h.length;p<g;++p){const m=h[p],T={};f.length>0&&m.willUseView();const w=this.renderer.getRenderSize();let y=new te({width:w[0],height:w[1],x:0,y:0});if(m.renderTarget){const N=(Array.isArray(m.renderTarget)?m.renderTarget[0]:m.renderTarget).getSize();y=new te({width:N[0],height:N[1],x:0,y:0})}const b=Mo(m.props.viewport,y,this.pixelRatio);m.fitViewtoViewport(y,b);for(let R=0,N=f.length;R<N;++R){const I=f[R];I.view=m;try{I.draw(),(I.needsViewDrawn||I.alwaysDraw)&&(m.needsDraw=!0),T[I.id]=I,m.animationEndTime=Math.max(m.animationEndTime,I.animationEndTime,m.props.camera.animationEndTime),I.lastFrameTime=e}catch(S){S instanceof Error&&(a[I.id]||(a[I.id]=[I,S]))}}if(m.needsDraw||e&&e<m.lastFrameTime||e&&e<m.animationEndTime||m.props.camera.needsViewDrawn){m.needsDraw=!0,r=!0;const R=this.viewDrawDependencies.get(m);R&&R.forEach(N=>{N.needsDraw=!0})}const A=Object.values(T);f.length!==A.length&&l.layerDiffs.diff(A.map(R=>R.initializer)),l.container&&i&&i(r,l,m)}}const o=Object.values(a);this.printLayerErrors(o)}destroy(){this.resourceManager.destroy(),this.userInputManager.destroy(),this.sceneDiffs.destroy(),this.renderer.dispose(),delete this.context}async draw(e){if(this.gl){this.broadcastEventManagerCycle(0);for(let n=0,i=this.sceneDiffs.items.length;n<i;++n){const r=this.sceneDiffs.items[n];for(let s=0,a=r.views.length;s<a;++s){const o=r.views[s];o.props.camera.broadcast(o.id)}}if(await this.commit(e,!0,(n,i,r)=>{i.container&&n&&this.drawSceneView(i.container,r)}),this.userInputManager.waitingForRender&&(this.userInputManager.waitingForRender=!1),!this.isBufferingResources){this.isBufferingResources=!0;const n=await this.resourceManager.dequeueRequests();this.isBufferingResources=!1,n&&this.draw(await Rn())}for(let n=0,i=this.sceneDiffs.items.length;n<i;++n){const r=this.sceneDiffs.items[n];for(let s=0,a=r.views.length;s<a;++s){const o=r.views[s];o.needsDraw=!1,o.props.camera.resolve()}for(let s=0,a=r.layers.length;s<a;++s){const o=r.layers[s];o.needsViewDrawn=!1}}this.broadcastEventManagerCycle(1),this.enabledOptimizedOutputs.clear()}}drawSceneView(e,n,i,r){i=i||this.renderer;const s={x:n.viewBounds.left,y:n.viewBounds.top},a=n.viewBounds,o=n.props.background||h0,c=n.clearFlags.indexOf(Ji.COLOR)>-1,u=r||n.renderTarget||null;n.renderTarget&&(n.getRenderTargets().forEach(h=>this.optimizedOutputs.forEach(f=>h.disabledTargets.add(f))),this.enabledOptimizedOutputs.size>0&&n.getRenderTargets().forEach(f=>this.enabledOptimizedOutputs.forEach(p=>f.disabledTargets.delete(p)))),i.setRenderTarget(u),i.setScissor({x:s.x,y:s.y,width:a.width,height:a.height},u),c&&i.clearColor([o[0],o[1],o[2],o[3]]),i.setViewport({x:s.x,y:s.y,width:a.width,height:a.height}),n.clearFlags&&n.clearFlags.length>0?i.clear(c,n.clearFlags.indexOf(Ji.DEPTH)>-1,n.clearFlags.indexOf(Ji.STENCIL)>-1):i.clear(!1),i.render(e,u,n.props.glState),n.lastFrameTime=this.frameMetrics.currentTime}fitContainer(e){if(!this.context||gi(this.context.canvas))return;const n=this.context.canvas.parentElement;if(n){const i=this.context.canvas;i.className="",i.setAttribute("style",""),n.style.position="relative",i.style.position="absolute",i.style.left="0xp",i.style.top="0xp",i.style.width="100%",i.style.height="100%",i.setAttribute("width",""),i.setAttribute("height","");const r=n.getBoundingClientRect(),s=i.getBoundingClientRect();this.resize(s.width||100,r.height||100)}}gatherViewDrawDependencies(){if(!this.sceneDiffs)return;this.viewDrawDependencies.clear();const e=this.sceneDiffs.items,n=this.renderer.getRenderSize();for(let i=0,r=e.length;i<r;i++){const s=e[i];for(let a=0,o=s.views.length;a<o;++a){const c=s.views[a];c.willUseView();let u=new te({width:n[0],height:n[1],x:0,y:0});if(c.renderTarget){const f=(Array.isArray(c.renderTarget)?c.renderTarget[0]:c.renderTarget).getSize();u=new te({width:f[0],height:f[1],x:0,y:0})}const l=Mo(c.props.viewport,u,this.pixelRatio);c.fitViewtoViewport(u,l),c.props.camera.update(!0)}}for(let i=0,r=e.length;i<r;i++){const s=e[i];for(let a=0,o=s.views.length;a<o;++a){const c=s.views[a],u=[];for(let l=0,h=e.length;l<h;l++)if(l!==i){const f=e[l];for(let p=0,g=f.views.length;p<g;++p){const m=f.views[p];c.viewBounds.hitBounds(m.viewBounds)&&u.push(m)}}this.viewDrawDependencies.set(c,u)}}}getCurrentInteraction(){return this.userInputManager.currentInteraction}getIOExpanders(){return this.ioExpanders}getIOSorting(){return this.ioSorting}getShaderTransforms(){return this.shaderTransforms}getOptimizedOutputs(){return this.enabledOptimizedOutputs}getViewSize(e){for(let n=0,i=this.sceneDiffs.items.length;n<i;++n){const s=this.sceneDiffs.items[n].viewDiffs.getByKey(e);if(s)return s.renderTarget?s.viewBounds:s.screenBounds}return null}getViewWorldBounds(e){for(let n=0,i=this.sceneDiffs.items.length;n<i;++n){const s=this.sceneDiffs.items[n].viewDiffs.getByKey(e);if(s)if(s.screenBounds){const a=s.projection.viewToWorld([0,0]),o=s.projection.screenToWorld([s.screenBounds.right,s.screenBounds.bottom]);return new te({bottom:o[1],left:a[0],right:o[0],top:a[1]})}else return null}return null}getProjections(e){for(let n=0,i=this.sceneDiffs.items.length;n<i;++n){const s=this.sceneDiffs.items[n].viewDiffs.getByKey(e);if(s)return s.projection}return null}async init(e){var i;if(this.context)return this;this.pixelRatio=e.pixelRatio||this.pixelRatio,this.pixelRatio<1&&(this.pixelRatio=1);const n=this.initGL(e);return n?(this.context=n,this.gl?((i=e.optimizedOutputTargets)==null||i.forEach(r=>this.optimizedOutputs.add(r)),this.initUserInputManager(e),await this.initResources(e),await this.initIOExpanders(e),await this.initShaderTransforms(e)):console.warn("Could not establish a GL context. Layer Surface will be unable to render"),this.readyResolver.resolve(this),this):(this.readyResolver.reject({error:Fo.NO_WEBGL_CONTEXT,message:"Could not establish a webgl context. Surface is being destroyed to free resources."}),this.destroy(),this)}initGL(e){const n=e.context;if(!n)return null;const i=n.width,r=n.height;let s=!0;const a=Object.assign({alpha:!1,antialias:!1,preserveDrawingBuffer:!1,premultiplyAlpha:!1},e.rendererOptions);return this.renderer=new Zl({alpha:a.alpha,antialias:a.antialias,canvas:n,preserveDrawingBuffer:a.preserveDrawingBuffer,premultipliedAlpha:a.premultipliedAlpha,onNoContext:()=>{s=!1}}),!s||!this.renderer.gl?null:(this.context=this.renderer.gl,this.resourceManager&&this.resourceManager.setWebGLRenderer(this.renderer),this.setRendererSize(i,r),this.renderer.setPixelRatio(this.pixelRatio),this.renderer.gl)}initIOExpanders(e){const n=rf();Array.isArray(e.ioExpansion)||e.ioExpansion===void 0?this.ioExpanders=e.ioExpansion&&e.ioExpansion.slice(0)||n.slice(0)||[]:e.ioExpansion instanceof Function&&(this.ioExpanders=e.ioExpansion(n));const i=this.resourceManager.getIOExpansion();this.ioExpanders=this.ioExpanders.concat(i)}initShaderTransforms(e){const n=af();Array.isArray(e.shaderTransforms)||e.shaderTransforms===void 0?this.shaderTransforms=e.shaderTransforms&&e.shaderTransforms.slice(0)||n.slice(0)||[]:e.shaderTransforms instanceof Function&&(this.shaderTransforms=e.shaderTransforms(n))}initUserInputManager(e){if(!this.context)return;const n=[new nf].concat(e.eventManagers||[]);this.userInputManager=new Jd(this.context.canvas,this,n,e.handlesWheelEvents)}async initResources(e){const n=sf();this.resourceManager=new Mc,this.resourceManager.setWebGLRenderer(this.renderer),(e.resourceManagers&&e.resourceManagers.slice(0)||n.slice(0)||[]).forEach(r=>{this.resourceManager.setManager(r.type,r.manager)})}async pipeline(e){e.resources&&await this.resourceDiffs.diff(e.resources),e.scenes&&await this.sceneDiffs.diff(e.scenes),this.gatherViewDrawDependencies()}printLayerErrors(e){e.length>0&&(console.warn("Some layers errored during their draw update. These layers will be removed. They can be re-added if render() is called again:",e.map(n=>n[0].id)),e.forEach(n=>{if(console.warn(`Layer ${n[0].id} removed for the following error:`),n[1]){const i=n[1].stack||n[1].message;if(console.error(i),i.indexOf("RangeError")>-1||i.indexOf("Source is too large")>-1){const r=n[0],s=r.bufferManager.changeListContext||[];let a,o=0;for(let c=0,u=s.length;c<u;++c){const[l]=s[c];r.shaderIOInfo.instanceAttributes.forEach(h=>{h.update(l).length!==h.size&&(a||(a=["Example instance returned the wrong sized value for an attribute:",l,h]),o++)})}a&&(console.error("The following output shows discovered issues related to the specified error"),console.error(`Instances are returning too large IO for an attribute
`,a[0],a[1],a[2],"Total errors for too large IO values",o))}}}))}resize(e,n,i){if(this.pixelRatio=i||this.pixelRatio,this.pixelRatio<1&&(this.pixelRatio=1),this.setRendererSize(e,n),this.renderer.setPixelRatio(this.pixelRatio),this.userInputManager.resize(),this.resourceManager.resize(),this.sceneDiffs){const r=this.sceneDiffs.items;for(let s=0,a=r.length;s<a;++s){const o=r[s];for(let c=0,u=o.views.length;c<u;++c){const l=o.views[c];l.pixelRatio=this.pixelRatio,l.props.camera.update(!0)}}}this.gatherViewDrawDependencies()}redraw(){for(let e=0,n=this.sceneDiffs.items.length;e<n;++e){const i=this.sceneDiffs.items[e];for(let r=0,s=i.views.length;r<s;++r){const a=i.views[r];a.needsDraw=!0}}}setRendererSize(e,n){e=e||100,n=n||100,this.renderer.setSize(e,n)}enableOptimizedOutput(e){this.enabledOptimizedOutputs.add(e)}}class Uc extends rn{draw(){this.props.commands(this.surface)}initShader(){return null}}Uc.defaultProps={data:new he,key:"",commands:()=>{}};class Ne extends rn{constructor(e,n,i){super(e,n,i)}baseShaderModules(e){const n=super.baseShaderModules(e);return n.vs.push("world2D"),n}}const d0=`
These are projection methods and camera
related constants associated with a
View2D.

Methods:
vec3 cameraSpace(vec3 world);
vec3 cameraSpaceSize(vec3 worldSize);
vec4 clipSpace(vec3 world);
vec4 clipSpaceSize(vec3 worldSize);

Constants:
mat4 projection;
mat4 view;
mat4 viewProjection;
vec3 cameraOffset;
vec3 cameraPosition;
vec3 cameraScale;
vec3 cameraScale2D;
vec3 cameraRotation;
vec2 viewSize;
float pixelRatio;
`;Ee.register([{moduleId:"world2D",description:d0,content:ef,compatibility:x.ALL,uniforms:t=>t instanceof Ne?[{name:"projection",size:E.MATRIX4,update:()=>t.view.props.camera.projection},{name:"view",size:E.MATRIX4,update:()=>t.view.props.camera.view},{name:"viewProjection",size:E.MATRIX4,update:()=>t.view.props.camera.viewProjection},{name:"cameraOffset",size:E.THREE,update:()=>t.view.props.camera instanceof sn?t.view.props.camera.control2D.offset:[0,0,0]},{name:"cameraPosition",size:E.THREE,update:()=>t.view.props.camera.position},{name:"cameraScale",size:E.THREE,update:()=>t.view.props.camera.scale},{name:"cameraScale2D",size:E.THREE,update:()=>t.view.props.camera instanceof sn?t.view.props.camera.scale2D:[1,1,1]},{name:"cameraRotation",size:E.THREE,update:()=>t.view.props.camera.scale},{name:"viewSize",size:E.TWO,update:()=>[t.view.viewBounds.width,t.view.viewBounds.height]},{name:"pixelRatio",size:E.ONE,update:()=>[t.view.pixelRatio]}]:(console.warn("A shader requested the module world2D; however, the layer the shader comes from is NOT a Layer2D which is","required for the module to work."),[])}]);var P=(t=>(t[t.BottomLeft=0]="BottomLeft",t[t.BottomMiddle=1]="BottomMiddle",t[t.BottomRight=2]="BottomRight",t[t.Custom=3]="Custom",t[t.Middle=4]="Middle",t[t.MiddleLeft=5]="MiddleLeft",t[t.MiddleRight=6]="MiddleRight",t[t.TopLeft=7]="TopLeft",t[t.TopMiddle=8]="TopMiddle",t[t.TopRight=9]="TopRight",t))(P||{}),an=(t=>(t[t.ALWAYS=1]="ALWAYS",t[t.BOUND_MAX=2]="BOUND_MAX",t[t.NEVER=3]="NEVER",t))(an||{}),cf=(t=>(t[t.TOP_LEFT=0]="TOP_LEFT",t[t.TOP_MIDDLE=1]="TOP_MIDDLE",t[t.TOP_RIGHT=2]="TOP_RIGHT",t[t.MIDDLE_LEFT=3]="MIDDLE_LEFT",t[t.MIDDLE=4]="MIDDLE",t[t.MIDDLE_RIGHT=5]="MIDDLE_RIGHT",t[t.BOTTOM_LEFT=6]="BOTTOM_LEFT",t[t.BOTTOM_MIDDLE=7]="BOTTOM_MIDDLE",t[t.BOTTOM_RIGHT=8]="BOTTOM_RIGHT",t))(cf||{});class lf extends is{constructor(e){super({}),this._uid=G(),this.isPanning=!1,this.isScaling=!1,this.panFilter=(n,i,r)=>n,this.scaleFilter=(n,i,r)=>n,this.startViews=[],this.optimizedViews=new Set,this.cameraImmediateAnimation=Bs.immediate(0),this.targetTouches=new Set,this.onRangeChanged=(n,i)=>{},this.startViewDidStart=!1,this.applyBounds=()=>{if(this.bounds&&this.camera){const n=this.getView(this.bounds.view);this.applyScaleBounds(),n&&(this.camera.control2D.getOffset()[0]=this.boundsHorizontalOffset(n,this.bounds),this.camera.control2D.getOffset()[1]=this.boundsVerticalOffset(n,this.bounds))}},this.applyScaleBounds=()=>{this.camera&&this.bounds&&(this.bounds.scaleMin&&this.camera.control2D.setScale(ds(this.camera.control2D.getScale(),this.bounds.scaleMin)),this.bounds.scaleMax&&this.camera.control2D.setScale(fs(this.camera.control2D.getScale(),this.bounds.scaleMax)))},this.handleCameraViewChange=(n,i)=>{if(i!==this.startViews[0])return;const r=this.surface.getProjections(i);r&&this.onRangeChanged(n,r)},e.bounds&&this.setBounds(e.bounds),this._camera=e.camera,this.scaleFactor=e.scaleFactor||1e3,this.ignoreCoverViews=e.ignoreCoverViews||!1,this.twoFingerPan=e.twoFingerPan||!1,e.startView&&(Array.isArray(e.startView)?(this.startViews=e.startView,this._camera.control2D.setViewChangeHandler(this.handleCameraViewChange)):(this.startViews=[e.startView],this._camera.control2D.setViewChangeHandler(this.handleCameraViewChange))),this.panFilter=e.panFilter||this.panFilter,this.scaleFilter=e.scaleFilter||this.scaleFilter,this.onRangeChanged=e.onRangeChanged||this.onRangeChanged,e.wheelShouldScroll&&(this.wheelShouldScroll=e.wheelShouldScroll)}get uid(){return this._uid}get camera(){return this._camera}anchoredByBoundsHorizontal(e,n){switch(n.anchor){case 0:case 3:case 6:return-(n.worldBounds.left-n.screenPadding.left/this.camera.control2D.getScale()[0]);case 1:case 4:case 7:return-(n.worldBounds.right-n.worldBounds.width/2-.5*((e.screenBounds.width+n.screenPadding.right)/this.camera.control2D.getScale()[0]));case 2:case 5:case 8:return-(n.worldBounds.right-(e.screenBounds.width-n.screenPadding.right)/this.camera.control2D.getScale()[0])}}anchoredByBoundsVertical(e,n){switch(n.anchor){case 0:case 1:case 2:return-(n.worldBounds.top-n.screenPadding.top/this.camera.control2D.getScale()[1]);case 3:case 4:case 5:return-(n.worldBounds.bottom-n.worldBounds.height/2-.5*((e.screenBounds.height+n.screenPadding.bottom)/this.camera.control2D.getScale()[1]));case 6:case 7:case 8:return-(n.worldBounds.bottom-(e.screenBounds.height-n.screenPadding.bottom)/this.camera.control2D.getScale()[1])}}boundsHorizontalOffset(e,n){const i=e.projection.worldToScreen([n.worldBounds.left,n.worldBounds.top]),r=e.projection.worldToScreen([n.worldBounds.right,n.worldBounds.bottom]);return r[0]-i[0]+n.screenPadding.left+n.screenPadding.right-e.screenBounds.width<0?this.anchoredByBoundsHorizontal(e,n):r[0]<e.screenBounds.right-n.screenPadding.right?-n.worldBounds.right+(e.screenBounds.width-n.screenPadding.right)/this.camera.control2D.getScale()[0]:i[0]>e.screenBounds.left+n.screenPadding.left?-n.worldBounds.left+n.screenPadding.left/this.camera.control2D.getScale()[0]:this.camera.control2D.getOffset()[0]}boundsVerticalOffset(e,n){const i=e.projection.worldToScreen([n.worldBounds.left,n.worldBounds.top]),r=e.projection.worldToScreen([n.worldBounds.right,n.worldBounds.bottom]);return r[1]-i[1]+n.screenPadding.top+n.screenPadding.bottom-e.screenBounds.height<0?this.anchoredByBoundsVertical(e,n):r[1]<e.screenBounds.bottom-n.screenPadding.bottom?-n.worldBounds.bottom+(e.screenBounds.height-n.screenPadding.bottom)/this.camera.control2D.getScale()[1]:i[1]>e.screenBounds.top+n.screenPadding.top?-n.worldBounds.top+n.screenPadding.top/this.camera.control2D.getScale()[0]:this.camera.control2D.getOffset()[1]}canStart(e){return this.startViews.length===0||this.startViews&&this.startViews.indexOf(e)>-1||this.startViewDidStart&&this.ignoreCoverViews}centerOn(e,n){if(!this.camera.control2D.surface)return;const i=this.camera.control2D.surface.getViewSize(e);if(!i)return;const r=[i.width/2,i.height/2,0],s=St(n,ur(r,this.camera.control2D.getScale())),a=it(s,-1);this.setOffset(e,a)}doPan(e,n,i){let r=Wn(cr(i,this.camera.control2D.getScale()),0);this.panFilter&&(r=this.panFilter(r,n,e)),this.camera.control2D.getOffset()[0]+=r[0],this.camera.control2D.getOffset()[1]+=r[1],this.applyBounds(),this.onRangeChanged(this.camera,n.projection),this.applyBounds(),this.camera.control2D.update()}doScale(e,n,i,r){const s=n.projection.screenToWorld(e),a=this.camera.control2D.getScale()[0]||1,o=this.camera.control2D.getScale()[1]||1;this.scaleFilter&&(r=this.scaleFilter(r,n,i)),this.camera.control2D.getScale()[0]=a+r[0],this.camera.control2D.getScale()[1]=o+r[1],this.applyScaleBounds();const c=n.projection.screenToWorld(e),u=ye(s,c);this.camera.control2D.getOffset()[0]-=u[0],this.camera.control2D.getOffset()[1]-=u[1],this.applyBounds(),this.onRangeChanged(this.camera,n.projection),this.applyBounds(),this.camera.control2D.update(),this.camera.control2D.animation=this.cameraImmediateAnimation}filterTouchesByValidStart(e){return this.ignoreCoverViews?e.filter(uu(this.startViews)):e.filter(lu(this.startViews))}findCoveredStartView(e){const n=e.target.views.find(i=>this.startViews.indexOf(i.view.id)>-1);this.startViewDidStart=!!n,n&&(this.coveredStartView=n.view)}getRange(e){const n=this.getProjection(e),i=this.getViewScreenBounds(e);if(n&&i){const r=n.screenToWorld([i.x,i.y]),s=n.screenToWorld([i.right,i.bottom]);return new te({height:s[1]-r[1],width:s[0]-r[0],x:r[0],y:r[1]})}return new te({x:0,y:0,width:1,height:1})}getTargetView(e){return this.startViews&&!this.ignoreCoverViews?e.target.view:this.coveredStartView}handleMouseDown(e){this.startViews&&(this.findCoveredStartView(e),e.start&&(this.isPanning=this.canStart(e.start.view.id)||this.isPanning))}handleTouchDown(e){if(this.startViews){const n=this.filterTouchesByValidStart(e.allTouches);this.twoFingerPan?n.length>1&&(this.isPanning=!0):n.length>0&&(this.isPanning=!0),n.length>1&&(this.isScaling=!0);for(let i=0,r=n.length;i<r;++i){const s=n[i];this.targetTouches.add(s.touch.touch.identifier)}}}handleMouseUp(e){this.startViewDidStart=!1,this.isPanning=!1,this.optimizedViews.forEach(n=>n.optimizeRendering=!1),this.optimizedViews.clear()}handleTouchUp(e){e.touches.forEach(n=>{this.targetTouches.delete(n.touch.touch.identifier),this.targetTouches.size<=0&&(this.startViewDidStart=!1,this.isPanning=!1,this.optimizedViews.forEach(i=>i.optimizeRendering=!1),this.optimizedViews.clear())}),this.isPanning=!1,this.isScaling=!1,this.targetTouches.size>0&&(this.isPanning=!0),this.targetTouches.size>1&&(this.isScaling=!0)}handleTouchCancelled(e){e.touches.forEach(n=>{this.targetTouches.delete(n.touch.touch.identifier),this.targetTouches.size<=0&&(this.startViewDidStart=!1,this.isPanning=!1,this.optimizedViews.forEach(i=>i.optimizeRendering=!1),this.optimizedViews.clear())}),this.isPanning=!1,this.isScaling=!1,this.targetTouches.size>0&&(this.isPanning=!0),this.targetTouches.size>1&&(this.isScaling=!0)}handleDrag(e){e.start&&this.canStart(e.start.view.id)&&(e.target.views.forEach(n=>{n.view.optimizeRendering=!0,this.optimizedViews.add(n.view)}),this.doPan(e.target.views.map(n=>n.view),e.start.view,e.mouse.deltaPosition),this.camera.control2D.animation=this.cameraImmediateAnimation)}handleTouchDrag(e){const n=this.filterTouchesByValidStart(e.allTouches);if(n.length>0&&this.isPanning){for(let a=0,o=n.length;a<o;++a)n[a].target.views.forEach(u=>{u.view.optimizeRendering=!0,this.optimizedViews.add(u.view)});const i=new Set,s=n.reduce((a,o)=>{for(let c=0,u=o.target.views.length;c<u;++c){const l=o.target.views[c];i.add(l.view)}return o.touch.startTime<a.touch.startTime?o:a},n[0]).start.view;if(this.isPanning&&(this.doPan(Array.from(i.values()),s,e.multitouch.centerDelta(n)),this.camera.control2D.animation=this.cameraImmediateAnimation),this.isScaling){const a=e.multitouch.center(n),o=ye(n[0].touch.currentPosition,a),c=ye(a,e.multitouch.centerDelta(n)),u=ye(n[0].touch.previousPosition,c),l=Vn(o)/Vn(u),h=[l*this.camera.scale2D[0]-this.camera.scale2D[0],l*this.camera.scale2D[1]-this.camera.scale2D[1],0];l!==1&&this.doScale(a,s,Array.from(i.values()),h)}}}handleWheel(e){if(this.findCoveredStartView(e),this.canStart(e.target.view.id))if(this.wheelShouldScroll){const n=[-e.mouse.wheel.delta[0],e.mouse.wheel.delta[1]];e.start&&this.doPan(e.target.views.map(i=>i.view),e.start.view,n)}else{const n=this.camera.control2D.getScale()[0]||1,i=this.camera.control2D.getScale()[1]||1,r=this.getTargetView(e),s=[e.mouse.wheel.delta[1]/this.scaleFactor*n,e.mouse.wheel.delta[1]/this.scaleFactor*i,1];if(!r){console.warn("Could not find target view for wheel event");return}this.doScale(e.screen.position,r,e.target.views.map(a=>a.view),s)}}get pan(){return this.camera.control2D.offset}get scale(){return this.camera.control2D.getScale()}setBounds(e){this.bounds=e,this.applyBounds()}setOffset(e,n){const i=nt(this.camera.control2D.offset);if(this.camera.control2D.getOffset()[0]=n[0],this.camera.control2D.getOffset()[1]=n[1],this.camera.control2D.getOffset()[2]=n[2],this.applyBounds(),this.camera.control2D.surface){const a=this.camera.control2D.surface.getProjections(e);a&&this.onRangeChanged(this.camera,a)}this.applyBounds();const r=nt(this.camera.control2D.getOffset()),s=this.camera.control2D.animation;this.camera.control2D.setOffset(i),this.camera.control2D.animation=this.cameraImmediateAnimation,this.camera.control2D.setOffset(r),this.camera.control2D.animation=s}setRange(e,n){const i=this.getProjection(n),r=this.getViewScreenBounds(n),s=this.getView(n);if(i&&r&&s){const a=St([r.width/e.width,r.height/e.height,1],this.camera.control2D.getScale());this.camera.control2D.setScale(At(this.camera.control2D.getScale(),this.scaleFilter(a,s,[s])));const o=St([-e.x,-e.y,0],this.camera.control2D.offset);this.camera.control2D.setOffset(At(this.camera.control2D.offset,this.scaleFilter(o,s,[s]))),this.applyBounds(),this.onRangeChanged(this.camera,s.projection),this.applyBounds()}}setRangeChangeHandler(e){this.onRangeChanged=e}}class f0 extends Cn{constructor(e,n){super(e),this.offsetFilter=i=>i,this.scaleFilter=i=>i,this.base=n.base,this.offsetFilter=n.offsetFilter||this.offsetFilter,this.scaleFilter=n.scaleFilter||this.scaleFilter}set offset(e){}get offset(){return this.offsetFilter(this.base.offset)}set scale(e){}get scale(){return this.scaleFilter(this.base.scale)}}class p0 extends sn{constructor(e){super(),this.base=e.base,this._control2D=new f0(this.base,{base:this.base.control2D,offsetFilter:e.offsetFilter,scaleFilter:e.scaleFilter})}set control2D(e){}get control2D(){return this._control2D}}const g0=new sn;class m0 extends Ns{constructor(){super(...arguments),this.camera=g0}screenToWorld(e,n){const i=this.screenToView(e),r=n||[0,0];return r[0]=(i[0]-this.camera.control2D.offset[0]*this.camera.scale2D[0])/this.camera.scale2D[0],r[1]=(i[1]-this.camera.control2D.offset[1]*this.camera.scale2D[1])/this.camera.scale2D[1],r}screenRay(e){const n=this.screenToWorld(e);return[[n[0],n[1],0],[n[0],n[1],-1]]}worldToScreen(e,n){const i=[0,0];return i[0]=(e[0]*this.camera.scale2D[0]+this.camera.control2D.offset[0]*this.camera.scale2D[0])*this.pixelRatio,i[1]=(e[1]*this.camera.scale2D[1]+this.camera.control2D.offset[1]*this.camera.scale2D[1])*this.pixelRatio,this.viewToScreen(i,n)}viewToWorld(e,n){const i=n||[0,0],r=e;return i[0]=(r[0]-this.camera.control2D.offset[0]*this.camera.scale2D[0])/this.camera.scale2D[0],i[1]=(r[1]-this.camera.control2D.offset[1]*this.camera.scale2D[1])/this.camera.scale2D[1],i}worldToView(e,n){const i=n||[0,0];return i[0]=e[0]*this.camera.scale2D[0]+this.camera.control2D.offset[0]*this.camera.scale2D[0],i[1]=e[1]*this.camera.scale2D[1]+this.camera.control2D.offset[1]*this.camera.scale2D[1],i}}function uf(t){return t.projectionType===xn.ORTHOGRAPHIC}class ua extends Xr{constructor(e,n){super(e,n),this.projection=new m0,this.projection.camera=n.camera||new sn}fitViewtoViewport(e,n){if(uf(this.props.camera)){const i=n.width,r=n.height,s={bottom:-r/2,far:1e7,left:-i/2,near:-100,right:i/2,top:r/2},a=1/this.pixelRatio,o=1/this.pixelRatio,c=this.props.camera;c.projectionOptions=Object.assign(c.projectionOptions,s),c.position=[n.width/(2*this.pixelRatio),n.height/(2*this.pixelRatio),c.position[2]],c.scale=[a,-o,1],c.lookAt(At(c.position,[0,0,-1]),[0,1,0]),c.update(),this.projection.viewBounds=n,n.d=this,this.projection.screenBounds=new te({height:this.viewBounds.height/this.pixelRatio,width:this.viewBounds.width/this.pixelRatio,x:this.viewBounds.x/this.pixelRatio,y:this.viewBounds.y/this.pixelRatio}),this.screenBounds.d=this}else uf(this.props.camera)||console.warn("View2D does not support non-orthographic cameras.")}willUpdateProps(e){this.projection.camera=e.camera}}ua.defaultProps={key:"",camera:new sn,viewport:{left:0,right:0,bottom:0,top:0}};const v0=`precision highp float;

varying vec4 vertexColor;

void main() {
  gl_FragColor = vertexColor;
}
`,w0=`precision highp float;

/**
  This vertex shader calculates edges whose curve and width is in screen space where the curve is
  bezier curves with 0, 1, and 2 control points.
**/
varying vec4 vertexColor;

vec2 interpolation(float t, vec2 center, float radius, float start, float end) {
  float angle = (end - start) * t + start;
  return center + vec2(cos(angle) * radius, sin(angle) * radius);
}

void main() {
  // Destructure some of the vec injections
  float startAngle = angle.x;
  float endAngle = angle.y;
  float widthStart = thickness.x;
  float widthEnd = thickness.y;

  // Convert world points to screen space
  vec4 centerClip = clipSpace(vec3(center, depth));
  vec2 centerScreen = (centerClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;
  // Destructure position attribute
  float normal = position.x;
  float interpolationTime = position.y;
  float interpolationIncrement = 1.0 / position.z;
  // Get the position of the current vertex
  vec2 currentPosition = interpolation(interpolationTime, centerScreen, radius, startAngle, endAngle);
  // Get normal with currentPosition and center
  vec2 currentNormal = normalize(currentPosition - centerScreen);
  // Get the thickness based on the side we're on
  float lineThickness = mix(widthStart, widthEnd, interpolationTime) / 2.0;
  // Start on the calculated line and push out by the normal's value
  vec2 vertex = currentPosition + currentNormal * (normal * lineThickness);
  // Get the color based on where we are on the line
  vertexColor = mix(colorStart, colorEnd, interpolationTime);
  vertexColor *= vertexColor.a;

  gl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), centerClip.zw);
  gl_PointSize = 5.0;
}
`,T0=`\${import: arc}
precision highp float;

/**
  This vertex shader calculates edges whose curve and width is in screen space where the curve is
  bezier curves with 0, 1, and 2 control points.
**/
varying vec4 vertexColor;

void main() {
  // Destructure some of the vec injections
  float startAngle = angle.x + angleOffset;
  float endAngle = angle.y + angleOffset;
  float widthStart = thickness.x;
  float widthEnd = thickness.y;
  // Destructure vertex attribute
  float normal = vertex.x;
  float interpolationTime = vertex.y;
  float interpolationIncrement = 1.0 / vertex.z;
  // Get the position of the current vertex
  vec2 currentPosition = arc(interpolationTime, center, radius, startAngle, endAngle);
  // Get normal with currentPosition and center
  vec2 currentNormal = normalize(currentPosition - center);
  // Get the thickness based on the side we're on
  float lineThickness = mix(widthStart, widthEnd, interpolationTime) / 2.0;
  // Start on the calculated line and push out by the normal's value
  vec2 vertex = currentPosition + currentNormal * (normal * lineThickness);
  // Get the color based on where we are on the line
  vertexColor = mix(colorStart, colorEnd, interpolationTime);

  gl_Position = clipSpace(vec3(vertex, depth));
}
`;var hf=(t=>(t[t.NONE=0]="NONE",t[t.SCREEN_CURVE=1]="SCREEN_CURVE",t))(hf||{});const Ln=class extends Ne{initShader(){const{scaleType:t}=this.props,e=this.props.animate||{},{angle:n,angleOffset:i,center:r,radius:s,thickness:a,colorStart:o,colorEnd:c}=e,u=150,l={0:1,[u*2+2]:-1},h={0:0,[u*2+2]:1};let f=1;for(let g=0;g<u*2;++g)l[g+1]=f,h[g+1]=Math.floor(g/2)/(u-1),f*=-1;const p=t===0?T0:w0;return{fs:v0,instanceAttributes:[{easing:r,name:Ln.attributeNames.center,size:C.TWO,update:g=>g.center},{easing:s,name:Ln.attributeNames.radius,size:C.ONE,update:g=>[g.radius]},{name:Ln.attributeNames.depth,size:C.ONE,update:g=>[g.depth]},{easing:a,name:Ln.attributeNames.thickness,size:C.TWO,update:g=>g.thickness},{easing:n,name:Ln.attributeNames.angle,size:C.TWO,update:g=>g.angle},{easing:i,name:Ln.attributeNames.angleOffset,size:C.ONE,update:g=>[g.angleOffset]},{easing:o,name:Ln.attributeNames.colorStart,size:C.FOUR,update:g=>g.colorStart},{easing:c,name:Ln.attributeNames.colorEnd,size:C.FOUR,update:g=>g.colorEnd}],uniforms:[{name:"scaleFactor",size:E.ONE,update:g=>[1]}],vertexAttributes:[{name:"vertex",size:Be.THREE,update:g=>[l[g],h[g],u*2]}],vertexCount:u*2+2,vs:p}}getMaterialOptions(){return Object.assign({},tt.transparentShapeBlending,{culling:d.GLSettings.Material.CullSide.NONE})}};let Gc=Ln;Gc.defaultProps={data:new he,key:"",scaleType:0},Gc.attributeNames={angle:"angle",angleOffset:"angleOffset",center:"center",colorEnd:"colorEnd",colorStart:"colorStart",depth:"depth",radius:"radius",thickness:"thickness"};var y0=Object.defineProperty,b0=Object.getOwnPropertyDescriptor,ri=(t,e,n,i)=>{for(var r=i>1?void 0:i?b0(e,n):e,s=t.length-1,a;s>=0;s--)(a=t[s])&&(r=(i?a(e,n,r):a(r))||r);return i&&r&&y0(e,n,r),r};const df=class extends ze{constructor(t){super(t),this.angle=[0,Math.PI],this.colorEnd=[1,1,1,1],this.colorStart=[1,1,1,1],this.center=[0,0],this.depth=0,this.angleOffset=0,this.radius=1,this.thickness=[5,5],He(this,df),this.angle=t.angle||this.angle,this.colorEnd=t.colorEnd||this.colorEnd,this.colorStart=t.colorStart||this.colorStart,this.center=t.center||this.center,this.depth=t.depth||this.depth,this.radius=t.radius||this.radius,this.thickness=t.thickness||this.thickness}};let On=df;ri([M],On.prototype,"angle",2),ri([M],On.prototype,"colorEnd",2),ri([M],On.prototype,"colorStart",2),ri([M],On.prototype,"center",2),ri([M],On.prototype,"depth",2),ri([M],On.prototype,"angleOffset",2),ri([M],On.prototype,"radius",2),ri([M],On.prototype,"thickness",2);const E0=`precision highp float;

varying vec4 vertexColor;
varying float edgeSharpness;
varying float edgeSharpnessBase;
varying vec2 pointCoord;

float circle(vec2 coord, float radius){
  vec2 dist = coord - vec2(0.5);

  return 1.0 - smoothstep(
    radius - (radius * edgeSharpness),
    radius + (radius * edgeSharpnessBase),
    dot(dist, dist) * 4.0
  );
}

void main() {
  float step_factor = circle(pointCoord, 1.0);

  // \${out: color} = hey
  \${out: color} = mix(
    vec4(0.0, 0.0, 0.0, 0.0),
    vertexColor,
    step_factor
  );

  if (color.a == 0.0) discard;
}
`,_0=`precision highp float;

varying vec4 vertexColor;
varying float edgeSharpness;
varying float edgeSharpnessBase;

float circle(vec2 coord, float radius){
  vec2 dist = coord - vec2(0.5);

  return 1.0 - smoothstep(
    radius - (radius * edgeSharpness),
    radius + (radius * edgeSharpnessBase),
    dot(dist, dist) * 4.0
  );
}

void main() {
  float step_factor = circle(gl_PointCoord, 1.0);

  // \${out: color} = hey
  \${out: color} = mix(
    vec4(0.0, 0.0, 0.0, 0.0),
    vertexColor,
    step_factor
  );

  if (color.a == 0.0) discard;
}
`,R0=`// This shader renders our circles with POINTS mode. This can perform better for more intensive scenarios but comes at
// the cost of hardware limitations such as max POINT size and potential involuntary hardware culling decisions for the
// viewport.
precision highp float;

varying vec4 vertexColor;
varying float edgeSharpness;
varying float edgeSharpnessBase;

void main() {
  vertexColor = color;
  vertexColor.a *= layerOpacity;
  float size = radius * cameraScale2D.x;
  edgeSharpness = mix(0.8, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));
  edgeSharpnessBase = mix(0.1, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));

  // NOTE: for now we keep depth * vertex where vertex is always one since our gl layer does not
  // support drawing non-instanced data yet.
  gl_Position = clipSpace(vec3(center, depth));
  gl_PointSize = size * 2.0 * pixelRatio;
}
`,x0=`// Shader for rendering simple circles on a quad, using the fragment shader to create the 'roundness' of the shape.
precision highp float;

varying vec4 vertexColor;
varying float edgeSharpness;
varying float edgeSharpnessBase;
varying vec2 pointCoord;

void main() {
  vertexColor = color;
  vertexColor.a *= layerOpacity;
  float size = radius * cameraScale2D.x * pixelRatio;
  edgeSharpness = mix(0.8, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));
  edgeSharpnessBase = mix(0.1, 0.0, min((size * 6.0 * pixelRatio) / (45.0 * pixelRatio), 1.0));
  pointCoord = (normals.xy + vec2(1.0, 1.0)) / 2.0;

  // Center within clip space
  vec4 clipCenter = clipSpace(vec3(center, depth));
  // Center in screen space
  vec2 screenCenter = (clipCenter.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;
  // Position in screen space
  vec2 vertex = (normals.xy * size) + screenCenter;
  // Position back to clip space
  gl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), clipCenter.zw);
}
`,Yr=class extends Ne{initShader(){const{animate:t={},usePoints:e=!1,opacity:n=()=>1}=this.props,{center:i,radius:r,color:s}=t,a={0:1,1:1,2:-1,3:1,4:-1,5:-1},o={0:-1,1:-1,2:-1,3:1,4:1,5:1},c=[{name:"normals",size:Be.TWO,update:l=>[a[l],o[l]]}],u=6;return{drawMode:e?d.GLSettings.Model.DrawMode.POINTS:d.GLSettings.Model.DrawMode.TRIANGLE_STRIP,fs:e?[{outputType:$.COLOR,source:_0},{outputType:$.GLOW,source:`
              void main() {
                \${out: glow} = color;
              }
              `}]:[{outputType:$.COLOR,source:E0},{outputType:$.GLOW,source:`
              void main() {
                \${out: glow} = color;
              }
              `}],instanceAttributes:[{easing:i,name:Yr.attributeNames.center,size:C.TWO,update:l=>l.center},{easing:r,name:Yr.attributeNames.radius,size:C.ONE,update:l=>[l.radius]},{name:Yr.attributeNames.depth,size:C.ONE,update:l=>[l.depth]},{easing:s,name:Yr.attributeNames.color,size:C.FOUR,update:l=>l.color}],uniforms:[{name:"layerOpacity",size:E.ONE,shaderInjection:x.ALL,update:l=>[n()]}],vertexAttributes:e?void 0:c,vertexCount:e?0:u,vs:e?R0:x0}}getMaterialOptions(){return tt.transparentShapeBlending}};let kc=Yr;kc.defaultProps={data:new he,key:""},kc.attributeNames={center:"center",color:"color",depth:"depth",radius:"radius"};var A0=Object.defineProperty,S0=Object.getOwnPropertyDescriptor,ha=(t,e,n,i)=>{for(var r=i>1?void 0:i?S0(e,n):e,s=t.length-1,a;s>=0;s--)(a=t[s])&&(r=(i?a(e,n,r):a(r))||r);return i&&r&&A0(e,n,r),r};const ff=class extends ze{constructor(t){super(t),this.color=[1,1,1,1],this.depth=0,this.radius=0,this.center=[0,0],He(this,ff),this.color=t.color||this.color,this.radius=t.radius||this.radius,this.center=t.center||this.center,this.depth=t.depth||this.depth}get width(){return this.radius*2}get height(){return this.radius*2}};let qr=ff;ha([M],qr.prototype,"color",2),ha([M],qr.prototype,"depth",2),ha([M],qr.prototype,"radius",2),ha([M],qr.prototype,"center",2);var Kr=(t=>(t[t.NONE=0]="NONE",t[t.SCREEN_CURVE=1]="SCREEN_CURVE",t))(Kr||{}),on=(t=>(t[t.LINE=0]="LINE",t[t.BEZIER=1]="BEZIER",t[t.BEZIER2=2]="BEZIER2",t))(on||{}),zc=(t=>(t[t.ALL=0]="ALL",t[t.PASS_Y=1]="PASS_Y",t[t.PASS_X=2]="PASS_X",t))(zc||{});const M0=`

precision highp float;

/**
  This vertex shader calculates edges whose curve and width is in screen space where the curve is
  bezier curves with 0, 1, and 2 control points.
**/
varying vec4 vertexColor;

// Interpolation type injection
\${interpolation}

void main() {
  // Destructure vertex attribute
  float normal = vertex.x;
  float interpolationTime = vertex.y;
  float interpolationIncrement = 1.0 / vertex.z;
  // Get the position of the current vertex
  vec2 currentPosition = interpolation(interpolationTime, start, end, control.xy, control.zw);
  // Calculate the next and previous segment's location on the line
  vec2 prePosition = interpolation(interpolationTime - interpolationIncrement, start, end, control.xy, control.zw);
  vec2 nextPosition = interpolation(interpolationTime + interpolationIncrement, start, end, control.xy, control.zw);

  vec2 preLine = prePosition - currentPosition;
  vec2 nextLine = nextPosition - currentPosition;

  // Get a spliced nromal at the joining of two segments to make a crisper curve
  vec2 currentNormal = mix(
    // Pick this value if we're at the beginning of the line
    normalize(vec2(preLine.y, -preLine.x)),
    mix(
      // Pick this value when we're between the ends
      normalize(vec2(preLine.y, -preLine.x) + vec2(-nextLine.y, nextLine.x)),
      // Pick this value if we're at the end of the line
      normalize(vec2(-nextLine.y, nextLine.x)),
      float(vertex.x >= 1.0)
    ),
    float(vertex.x > 0.0)
  );

  // Get the thickness based on the side we're on
  float lineThickness = mix(thickness.x, thickness.y, interpolationTime) / 2.0;
  // Start on the calculated line and push out by the normal's value
  vec2 vertexPos = currentPosition + currentNormal * (normal * lineThickness);
  // Get the color based on where we are on the line
  vertexColor = mix(startColor, endColor, interpolationTime);

  gl_Position = clipSpace(vec3(vertexPos, depth));
  gl_PointSize = 5.0;

  // gl_Position = clipSpace(vec3(0., 0., 0.));
}
`,I0=`/**
 * Makes a linear interpolation between two points
 *
 * @param {vec2} s The start point
 * @param {vec2} e The end point
 * @param {vec2} c The bezier control point
 * @param {float} t The interpolation value [0, 1]
 *
 * @returns {vec2} A point interpolated between the two provided points
 */
vec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {
  float t1 = 1.0 - t;
  return pow(t1, 3.0) * p1 + 3.0 * t * pow(t1, 2.0) * c1 + 3.0 * pow(t, 2.0) * t1 * c2 + pow(t, 3.0) * p2;
}
`,C0=`/**
 * Makes a linear interpolation between two points
 *
 * @param {vec2} s The start point
 * @param {vec2} e The end point
 * @param {vec2} c The bezier control point
 * @param {float} t The interpolation value [0, 1]
 *
 * @returns {vec2} A point interpolated between the two provided points
 */
vec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {
  return (1.0 - t) * (1.0 - t) * p1 + 2.0 * t * (1.0 - t) * c1 + t * t * p2;
}
`,L0=`precision highp float;

varying vec4 vertexColor;

void main() {
  gl_FragColor = vertexColor;
}
`,O0=`/**
 * Makes a linear interpolation between two points
 *
 * @param {vec2} s The start point
 * @param {vec2} e The end point
 * @param {vec2} c The bezier control point
 * @param {float} t The interpolation value [0, 1]
 *
 * @returns {vec2} A point interpolated between the two provided points
 */
vec2 interpolation(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {
  return p1 + (p2 - p1) * t;
}
`,N0=`/**
  This vertex shader calculates edges based in world space to make an edge based on
  bezier curves with 0, 1, and 2 control points.
**/
precision highp float;



varying vec4 vertexColor;

// Interpolation type injection
\${interpolation}

void main() {
  // Destructure vertex attribute
  float normal = vertex.x;
  float interpolationTime = vertex.y;
  float interpolationIncrement = 1.0 / vertex.z;

  // Convert our world points to screen space
  vec4 startClip = clipSpace(vec3(start, depth));
  vec4 endClip = clipSpace(vec3(end, depth));
  vec2 startScreen = (startClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;
  vec2 endScreen = (endClip.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;
  // Controls for this mode are screen space deltas from the end points
  vec2 control1 = startScreen + vec2(control.x, -control.y) * scaleFactor;
  vec2 control2 = endScreen + vec2(control.z, -control.w) * scaleFactor;

  // Get the position of the current vertex
  vec2 currentPosition = interpolation(interpolationTime, startScreen, endScreen, control1, control2);
  // Calculate the next and previous segment's location on the line
  vec2 prePosition = interpolation(interpolationTime - interpolationIncrement, startScreen, endScreen, control1, control2);
  vec2 nextPosition = interpolation(interpolationTime + interpolationIncrement, startScreen, endScreen, control1, control2);

  vec2 preLine = prePosition - currentPosition;
  vec2 nextLine = nextPosition - currentPosition;

  // Get a spliced nromal at the joining of two segments to make a crisper curve
  vec2 currentNormal = mix(
    // Pick this value if we're at the beginning of the line
    normalize(vec2(preLine.y, -preLine.x)),
    mix(
      // Pick this value when we're between the ends
      normalize(vec2(preLine.y, -preLine.x) + vec2(-nextLine.y, nextLine.x)),
      // Pick this value if we're at the end of the line
      normalize(vec2(-nextLine.y, nextLine.x)),
      float(vertex.x >= 1.0)
    ),
    float(vertex.x > 0.0)
  );

  // Get the thickness based on the side we're on
  float lineThickness = mix(thickness.x, thickness.y, interpolationTime) / 2.0;
  // Start on the calculated line and push out by the normal's value
  vec2 vertexPos = currentPosition + currentNormal * (-normal * lineThickness * scaleFactor);
  // Get the color based on where we are on the line
  vertexColor = mix(startColor, endColor, interpolationTime);

  gl_Position = vec4((vertexPos / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), startClip.zw);
  gl_PointSize = 5.0;
}
`;function P0(t){return[t[0][0],t[0][1],t[1][0],t[1][1]]}const D0={[on.LINE]:O0,[on.BEZIER]:C0,[on.BEZIER2]:I0},cn=class extends Ne{initShader(){const{animate:t={},scaleFactor:e=()=>1,type:n,scaleType:i=Kr.NONE,smoothness:r=50}=this.props,{end:s,start:a,startColor:o,endColor:c,control:u,thickness:l}=t,h=n===on.LINE?2:r,f={0:1,[h*2+2]:-1},p={0:0,[h*2+2]:1};let g=1;for(let w=0;w<h*2;++w)f[w+1]=g,p[w+1]=Math.floor(w/2)/(h-1),g*=-1;const m={interpolation:D0[n]},T=ei({options:m,required:{name:"Edge Layer",values:["interpolation"]},shader:i===Kr.NONE?M0:N0,onToken:(w,y)=>w in m?y:`\${${w}}`});return{fs:L0,instanceAttributes:[{easing:o,name:cn.attributeNames.startColor,size:C.FOUR,update:w=>w.startColor},{easing:c,name:cn.attributeNames.endColor,size:C.FOUR,update:w=>w.endColor},{easing:a,name:cn.attributeNames.start,size:C.TWO,update:w=>w.start},{easing:s,name:cn.attributeNames.end,size:C.TWO,update:w=>w.end},{easing:l,name:cn.attributeNames.thickness,size:C.TWO,update:w=>w.thickness},{name:cn.attributeNames.depth,size:C.ONE,update:w=>[w.depth]},n===on.LINE?{easing:u,name:cn.attributeNames.control,size:C.FOUR,update:w=>[0,0,0,0]}:null,n===on.BEZIER?{easing:u,name:cn.attributeNames.control,size:C.FOUR,update:w=>[w.control[0][0],w.control[0][1],0,0]}:null,n===on.BEZIER2?{easing:u,name:cn.attributeNames.control,size:C.FOUR,update:w=>P0(w.control)}:null],uniforms:[{name:"scaleFactor",size:E.ONE,update:w=>[e()]},{name:"layerOpacity",size:E.ONE,update:w=>[this.props.opacity===void 0?1:this.props.opacity]}],vertexAttributes:[{name:"vertex",size:Be.THREE,update:w=>[f[w],p[w],h*2]}],vertexCount:h*2+2,vs:T.shader}}getMaterialOptions(){return tt.transparentShapeBlending}};let Vc=cn;Vc.defaultProps={broadphase:zc.ALL,data:new he,key:"none",scaleType:Kr.NONE,type:on.LINE},Vc.attributeNames={control:"control",depth:"depth",end:"end",endColor:"endColor",start:"start",startColor:"startColor",thickness:"thickness"};var F0=Object.defineProperty,B0=Object.getOwnPropertyDescriptor,Ci=(t,e,n,i)=>{for(var r=i>1?void 0:i?B0(e,n):e,s=t.length-1,a;s>=0;s--)(a=t[s])&&(r=(i?a(e,n,r):a(r))||r);return i&&r&&F0(e,n,r),r};const pf=class extends ze{constructor(t){super(t),this.control=[[0,0],[0,0]],this.depth=0,this.end=[0,0],this.endColor=[1,1,1,1],this.start=[0,0],this.startColor=[1,1,1,1],this.thickness=[1,1],He(this,pf),this.startColor=t.startColor||this.startColor,this.endColor=t.endColor||this.endColor,this.control=t.control||this.control,this.depth=t.depth||this.depth,this.end=t.end||this.end,this.thickness=t.thickness||this.thickness,this.start=t.start||this.start}get length(){const t=[this.end[0]-this.start[0],this.end[1]-this.start[1]];return Math.sqrt(t[0]*t[0]+t[1]*t[1])}get midpoint(){return 0}get perpendicular(){const t=this.length;return[(this.end[1]-this.start[1])/t,-(this.end[0]-this.start[0])/t]}setEdgeThickness(t){this.thickness=[t,t]}setColor(t){this.startColor=Mt(t),this.endColor=Mt(t)}};let si=pf;Ci([M],si.prototype,"control",2),Ci([M],si.prototype,"depth",2),Ci([M],si.prototype,"end",2),Ci([M],si.prototype,"endColor",2),Ci([M],si.prototype,"start",2),Ci([M],si.prototype,"startColor",2),Ci([M],si.prototype,"thickness",2);const Te=Ie("video");function U0(t){Te.enabled&&(t.addEventListener("abort",()=>Te("abort")),t.addEventListener("canplay",()=>Te("canplay")),t.addEventListener("canplaythrough",()=>Te("canplaythrough")),t.addEventListener("durationchange",()=>Te("durationchange")),t.addEventListener("emptied",()=>Te("emptied")),t.addEventListener("ended",()=>Te("ended")),t.addEventListener("error",()=>Te("error")),t.addEventListener("loadeddata",()=>Te("loadeddata")),t.addEventListener("loadedmetadata",()=>Te("loadedmetadata")),t.addEventListener("loadstart",()=>Te("loadstart")),t.addEventListener("pause",()=>Te("pause")),t.addEventListener("play",()=>Te("play")),t.addEventListener("playing",()=>Te("playing")),t.addEventListener("progress",()=>Te("progress")),t.addEventListener("ratechange",()=>Te("ratechange")),t.addEventListener("seeked",()=>Te("seeked")),t.addEventListener("seeking",()=>Te("seeking")),t.addEventListener("stalled",()=>Te("stalled")),t.addEventListener("suspend",()=>Te("suspend")),t.addEventListener("timeupdate",()=>Te("timeupdate")),t.addEventListener("volumechange",()=>Te("volumechange")),t.addEventListener("waiting",()=>Te("waiting")))}const G0=`precision highp float;

varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  gl_FragColor = texture2D(imageAtlas, texCoord) * vertexColor;
  gl_FragColor = gl_FragColor * gl_FragColor.a;
}
`,k0=`precision highp float;

varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  // Destructure the normal information
  float normal = normals.x;
  float side = normals.y;
  // Calculate the vertex before moving it to it's position
  vec2 vertex = vec2(side, float(normal == 1.0f)) * size - anchor;
  // Rotate the vertex by the rotation
  float crotation = cos(rotation);
  float srotation = sin(rotation);
  vertex = vec2(crotation * vertex.x - srotation * vertex.y, srotation * vertex.x + crotation * vertex.y);
  // Now move the vertex to the correct location (this should place the anchor
  // point of the image ON the location specified)
  vertex += location;

  // Finalize the projection of the vertex
  gl_Position = clipSpace(vec3(vertex, depth));
  // Outputs: Make sure our information for the fragment shader is ready
  // Get the tex coord from our inject texture info
  texCoord = texture.xy + ((texture.zw - texture.xy) * vec2(side, float(normal == -1.0f)));
  // Apply the image's tint as a tint to the image
  vertexColor = tint;
}
`,z0=`precision highp float;



varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  // Figure out the size of the image as it'd show on the screen
  vec3 screenSize = cameraSpaceSize(vec3(size, 1.0));
  // Do the test for when the image is larger on the screen than the font size
  bool largerOnScreen = screenSize.y > size.y;

  // Determines if a scale mode should be used or not for the vertex
  float useScaleMode = float(
    (
      scaling == 3.0 ||                  // NEVER mode - keep the image the same size always
      (largerOnScreen && scaling == 2.0) // BOUND_MAX mode - only if we're larger than the font size do we scale down
    ) &&
    scaling != 1.0                       // ALWAYS mode - the image stays completely in world space allowing it to scale freely
  );
  // If zooms are unequal, assume one is filtered to be 1.0
  float unequalZooms = float(cameraScale2D.x != cameraScale2D.y);

  // Destructure the normal information
  float normal = normals.x;
  float side = normals.y;

  // Get the location of the anchor in world space
  vec2 worldAnchor = location + anchor;

  // Get the tex coord from our inject texture info
  texCoord = texture.xy + ((texture.zw - texture.xy) * vec2(side, float(normal == -1.0)));
  // Apply the image's tint as a tint to the image
  vertexColor = tint;

  // Correct aspect ratio.
  vec2 adjustedSize = mix(
    size,
    (size * cameraScale2D.yx),
    unequalZooms
  );

  vec2 adjustedAnchor = mix(
    anchor,
    (anchor * cameraScale2D.yx),
    unequalZooms
  );

  vec2 vertex = vec2(side, float(normal == 1.0)) * adjustedSize + location - adjustedAnchor;

  // See how scaled the size on screen will be from the actual height of the image
  float imageScreenScale = mix(
    screenSize.y / adjustedSize.y,
    screenSize.x / adjustedSize.x,
    float((cameraScale2D.x < 1.0) || (cameraScale2D.x > 1.0))
  );

  // If our screen rendering is larger than the size the image is supposed to be, then we automagically
  // scale down our image to stay the correct size, centered on the anchor point
  vec2 anchorToVertex = vertex - location;

  // We now choose between keeping the same image size or keeping it in world space
  vertex = mix(
    // This option keeps the image size in world space
    vertex,
    // This option counters the scaling of the image on the screen keeping it a static size
    (anchorToVertex / imageScreenScale) + location,
    // This is the flag determining if a scale mode should be applied to the vertex
    useScaleMode
  );

  gl_Position = clipSpace(vec3(vertex, depth));
}
`,Nn=class extends Ne{constructor(t,e,n){super(t,e,n)}initShader(){const t=this.props.animate||{},{tint:e,location:n,size:i,rotation:r}=t,s={0:1,1:1,2:-1,3:1,4:-1,5:-1},a={0:0,1:0,2:0,3:1,4:1,5:1};return{fs:G0,instanceAttributes:[this.props.enableRotation?{easing:r,name:Nn.attributeNames.rotation,size:C.ONE,update:o=>[o.rotation]}:null,{easing:n,name:Nn.attributeNames.location,size:C.TWO,update:o=>o.origin},{name:Nn.attributeNames.anchor,size:C.TWO,update:o=>[o.anchor.x||0,o.anchor.y||0]},{easing:i,name:Nn.attributeNames.size,size:C.TWO,update:o=>[o.width,o.height]},{name:Nn.attributeNames.depth,size:C.ONE,update:o=>[o.depth]},{name:Nn.attributeNames.scaling,size:C.ONE,update:o=>[o.scaling]},{name:Nn.attributeNames.texture,resource:{key:()=>this.props.atlas||"",name:"imageAtlas"},update:o=>(o.source,o.request?this.resource.request(this,o,o.request):(console.warn("An image utilizing the image-render-layer does not have its request specified yet.","The image-render-layer does NOT manage requests and should be handled before this layer deals with the instance"),[0,0,0,0]))},{easing:e,name:Nn.attributeNames.tint,size:C.FOUR,update:o=>o.tint}],uniforms:[{name:"scaleFactor",size:E.ONE,update:o=>[1]}],vertexAttributes:[{name:"normals",size:Be.TWO,update:o=>[s[o],a[o]]}],vertexCount:6,vs:this.props.enableRotation?k0:z0}}getMaterialOptions(){return tt.transparentImageBlending}};let Wc=Nn;Wc.defaultProps={key:"",data:new he},Wc.attributeNames={location:"location",anchor:"anchor",size:"size",depth:"depth",scaling:"scaling",texture:"texture",tint:"tint",rotation:"rotation"};function Zr(t){return t&&t.videoSrc}const da=new Image;da.src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=";class gf extends Ne{constructor(){super(...arguments),this.childProvider=new he,this.imageToResource=new Map,this.sourceToRequest=new Map,this.sourceToVideo=new Map,this.usingVideo=new Map,this.waitingForVideo=new Map,this.waitForVideoSource=new Map,this.originalOnReadyCallbacks=new Map}childLayers(){return[_i(Wc,{...this.props,key:`${this.props.key}.image-render-layer`})]}destroy(){super.destroy(),this.sourceToVideo.forEach(e=>{e.pause(),this.sourceToVideo.clear(),this.waitingForVideo.clear(),this.waitForVideoSource.clear()})}draw(){const e=this.resolveChanges(!0);if(this.updateAnimationState(),e.length<=0)return;this.propertyIds||(this.propertyIds=this.getInstanceObservableIds(e[0][0],["source"]));const{source:n}=this.propertyIds;for(let r=0,s=e.length;r<s;++r){const[a,o,c]=e[r];switch(o){case Ce.CHANGE:if(c[n]!==void 0){const u=this.imageToResource.get(a);let l=this.getAtlasSource(a);if(l===u)break;if(u instanceof HTMLVideoElement){const h=this.waitForVideoSource.get(a);if(h){this.waitForVideoSource.delete(a);const p=this.waitingForVideo.get(h);p&&p.delete(a)}let f=this.usingVideo.get(u.getAttribute("data-source")||"");f||(f=new Set),f.delete(a),f.size<=0&&this.sourceToVideo.delete(u.getAttribute("data-source")||""),a.onReady=this.originalOnReadyCallbacks.get(a)}if(Zr(a.source)&&(this.prepareVideo(a,a.source),l=this.getAtlasSource(a),Jn(this.usingVideo,a.source.videoSrc,new Set).add(a)),this.imageToResource.set(a,l),this.resource.request(this,a,Yi({key:this.props.atlas||"",disposeResource:!0,source:u})),l){let h=this.sourceToRequest.get(l);(!h||h.texture&&!h.texture.isValid)&&(h=Yi({key:this.props.atlas||"",source:l,rasterizationScale:this.props.rasterizationScale}),this.sourceToRequest.set(l,h)),a.request=h,this.resource.request(this,a,h)}}break;case Ce.INSERT:if(a.source){let u=this.getAtlasSource(a);Zr(a.source)&&(this.prepareVideo(a,a.source),u=this.getAtlasSource(a),Jn(this.usingVideo,a.source.videoSrc,new Set).add(a));let l=this.sourceToRequest.get(u);(!l||l.texture&&!l.texture.isValid)&&(l=Yi({key:this.props.atlas||"",source:u,rasterizationScale:this.props.rasterizationScale}),this.sourceToRequest.set(u,l)),a.request=l}break;case Ce.REMOVE:{const u=this.getAtlasSource(a);if(this.imageToResource.delete(a),Zr(a.source)){const l=this.waitForVideoSource.get(a);if(l){this.waitForVideoSource.delete(a);const f=this.waitingForVideo.get(l);f&&f.delete(a)}let h=this.usingVideo.get(a.source.videoSrc);h||(h=new Set),h.delete(a),h.size<=0&&this.sourceToVideo.delete(a.source.videoSrc),this.originalOnReadyCallbacks.delete(a)}this.resource.request(this,a,Yi({key:this.props.atlas||"",disposeResource:!0,source:u}));break}}}const i=[];this.usingVideo.forEach((r,s)=>{r.size<=0&&i.push(s)});for(let r=0,s=i.length;r<s;++r){const a=i[r];this.usingVideo.delete(a),this.sourceToVideo.delete(a)}}getAtlasSource(e){return Zr(e.source)?this.sourceToVideo.get(e.source.videoSrc)||da:e.source}prepareVideo(e,n){const i=this.sourceToVideo.get(n.videoSrc);if(this.originalOnReadyCallbacks.get(e)||this.originalOnReadyCallbacks.set(e,e.onReady),i){const p=this.waitingForVideo.get(n.videoSrc);if(p)p.add(e),this.waitForVideoSource.set(e,n.videoSrc),e.onReady=void 0,e.source=da,e.videoLoad=()=>{i.load(),n.autoPlay&&i.play()};else{const g=this.originalOnReadyCallbacks.get(e)||e.onReady;if(!g)return;e.onReady=m=>{g(m,i)}}return}const s=document.createElement("video");this.sourceToVideo.set(n.videoSrc,s),s.setAttribute("data-source",n.videoSrc),U0(s);const a=new ke,o=new ke,c=()=>{s.removeEventListener("loadedmetadata",l),s.removeEventListener("loadeddata",u),s.removeEventListener("error",h),this.waitingForVideo.delete(n.videoSrc),this.waitForVideoSource.delete(e)},u=()=>{o.resolve()},l=()=>{a.resolve()},h=p=>{let g;p.path&&p.path[0]&&(g=p.path[0].error),p.originalTarget&&(g=p.originalTarget.error),console.warn("There was an error loading the video resource to the atlas texture context"),console.warn(g),a.reject({}),o.reject({})};s.addEventListener("loadedmetadata",l),s.addEventListener("loadeddata",u),s.addEventListener("error",h),e.onReady=void 0,Jn(this.waitingForVideo,n.videoSrc,new Set).add(e),this.waitForVideoSource.set(e,n.videoSrc),e.source=da,e.videoLoad=()=>{s.load(),n.autoPlay&&s.play()},s.muted=!0,s.src=n.videoSrc,Promise.all([a.promise,o.promise]).then(()=>{s.currentTime=0,n.autoPlay&&s.play();const p=this.waitingForVideo.get(n.videoSrc);p&&p.forEach(g=>{g.source=n,g.onReady=this.originalOnReadyCallbacks.get(g)}),c()}).catch(()=>{c()})}updateAnimationState(){let e=!1;this.sourceToVideo.forEach(n=>{n.paused||(e=!0)}),this.alwaysDraw=this.usingVideo.size>0&&e}initShader(){return null}}gf.defaultProps={atlas:"default",key:"",data:new he};var V0=Object.defineProperty,W0=Object.getOwnPropertyDescriptor,Pn=(t,e,n,i)=>{for(var r=i>1?void 0:i?W0(e,n):e,s=t.length-1,a;s>=0;s--)(a=t[s])&&(r=(i?a(e,n,r):a(r))||r);return i&&r&&V0(e,n,r),r};const{max:$0}=Math,j0={[P.TopLeft]:(t,e)=>{t.x=-t.padding,t.y=-t.padding},[P.TopMiddle]:(t,e)=>{t.x=e.width/2,t.y=-t.padding},[P.TopRight]:(t,e)=>{t.x=e.width+t.padding,t.y=-t.padding},[P.MiddleLeft]:(t,e)=>{t.x=-t.padding,t.y=e.height/2},[P.Middle]:(t,e)=>{t.x=e.width/2,t.y=e.height/2},[P.MiddleRight]:(t,e)=>{t.x=e.width+t.padding,t.y=e.height/2},[P.BottomLeft]:(t,e)=>{t.x=-t.padding,t.y=e.height+t.padding},[P.BottomMiddle]:(t,e)=>{t.x=e.width/2,t.y=e.height+t.padding},[P.BottomRight]:(t,e)=>{t.x=e.width+t.padding,t.y=e.height+t.padding},[P.Custom]:(t,e)=>{t.x=t.x||0,t.y=t.y||0}},mf=class extends ze{constructor(t){super(t),this.tint=[0,0,0,1],this.depth=0,this.height=1,this.origin=[0,0],this.scaling=an.BOUND_MAX,this.width=1,this.rotation=0,this.sourceWidth=0,this.sourceHeight=0,this._anchor={padding:0,type:P.TopLeft,x:0,y:0},this.videoLoad=xs,He(this,mf),this.depth=t.depth||this.depth,this.tint=t.tint||this.tint,this.scaling=t.scaling||this.scaling,this.origin=t.origin||this.origin,this.width=t.width||1,this.height=t.height||1,this.source=t.source,this.rotation=t.rotation||0,this.onReady=t.onReady,t.anchor&&this.setAnchor(t.anchor)}get maxSize(){return $0(this.width,this.height)}set maxSize(t){const e=this.width/this.height;this.width=t*e,this.height=t}get anchor(){return this._anchor}resourceTrigger(){this.source=this.source,this.request&&this.request.texture&&(this.sourceWidth=this.request.texture.pixelWidth,this.sourceHeight=this.request.texture.pixelHeight),this.onReady&&this.onReady(this)}setAnchor(t){const e={padding:t.padding||0,type:t.type,x:t.x||0,y:t.y||0};j0[e.type](e,this),this._anchor=e}};let ln=mf;Pn([M],ln.prototype,"tint",2),Pn([M],ln.prototype,"depth",2),Pn([M],ln.prototype,"height",2),Pn([M],ln.prototype,"origin",2),Pn([M],ln.prototype,"scaling",2),Pn([M],ln.prototype,"source",2),Pn([M],ln.prototype,"width",2),Pn([M],ln.prototype,"rotation",2),Pn([M],ln.prototype,"_anchor",2);var H0=Object.defineProperty,Q0=Object.getOwnPropertyDescriptor,Dn=(t,e,n,i)=>{for(var r=i>1?void 0:i?Q0(e,n):e,s=t.length-1,a;s>=0;s--)(a=t[s])&&(r=(i?a(e,n,r):a(r))||r);return i&&r&&H0(e,n,r),r};const $c=class extends ze{constructor(t){super(t),this.anchor=[0,0],this.character="a",this.color=[1,1,1,1],this.depth=0,this.fontScale=1,this.maxScale=1,this.offset=[0,0],this.origin=[0,0],this.padding=[0,0],He(this,$c),this.origin=t.origin||this.origin,this.offset=t.offset||this.offset,this.character=t.character||this.character,this.color=t.color||this.color,this.maxScale=t.maxScale||this.maxScale,this.padding=t.padding||this.padding,this.anchor=t.anchor||this.anchor,this.onReady=t.onReady}clone(){const t=new $c(this);t.onReady=this.onReady,t.request=this.request}resourceTrigger(){this.offset=this.offset,this.origin=this.origin,this.character=this.character,this.color=this.color,this.onReady&&this.onReady(this)}};let Tt=$c;Dn([M],Tt.prototype,"anchor",2),Dn([M],Tt.prototype,"character",2),Dn([M],Tt.prototype,"color",2),Dn([M],Tt.prototype,"depth",2),Dn([M],Tt.prototype,"fontScale",2),Dn([M],Tt.prototype,"maxScale",2),Dn([M],Tt.prototype,"offset",2),Dn([M],Tt.prototype,"origin",2),Dn([M],Tt.prototype,"padding",2);const vf=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  vec4 texColor = texture2D(fontMap, texCoord);
  if (texColor.r <= 0.0) discard;
  texColor.a = texColor.r;
  gl_FragColor = texColor * vertexColor;
}
`,wf=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  // Calculate in the anchor, the origin, glyph offset, and the quad pushout to make our quad geometry
  vec2 pushOut = normals * glyphSize * fontScale;
  vec3 position = vec3(origin + padding - anchor + offset + pushOut, depth);
  gl_Position = clipSpace(position);

  // Get the atlas position of the texture information
  texCoord = texture.xy + (texture.zw - texture.xy) * normals;
  // Apply the color of the glyph
  vertexColor = color * color.a;
}
`,X0=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  vec4 texColor = texture2D(fontMap, texCoord);
  if (texColor.r <= 0.0) discard;
  texColor.a = texColor.r;
  gl_FragColor = texColor * vertexColor;
}
`,Y0=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  vec2 scale = fontScale * cameraScale2D.xy;
  float scaleBy = max(scale.x, scale.y) / maxScale;
  vec2 pushOut = normals * glyphSize * fontScale;

  float vx = mix(
    (-anchor.x + offset.x + pushOut.x),
    (-anchor.x + offset.x + pushOut.x) / scaleBy,
    float(scale.x >= maxScale)
  );

  float vy = mix(
    (-anchor.y + offset.y + pushOut.y),
    (-anchor.y + offset.y + pushOut.y) / scaleBy,
    float(scale.y >= maxScale)
  );

  // Calculate in the anchor, the origin, glyph offset, and the quad pushout to make our quad geometry
  vec3 position = vec3(origin + padding + vec2(vx, vy), depth);
  gl_Position = clipSpace(position);

  // Get the atlas position of the texture information
  texCoord = texture.xy + (texture.zw - texture.xy) * normals;
  // Apply the color of the glyph
  vertexColor = color * color.a;
}
`,q0=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  vec4 texColor = texture2D(fontMap, texCoord);
  if (texColor.r <= 0.0) discard;
  texColor.a = texColor.r;
  gl_FragColor = texColor * vertexColor;
}
`,K0=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  // Calculate in the anchor, the origin, glyph offset, and the quad pushout to make our quad geometry
  vec2 pushOut = normals * glyphSize * fontScale;
  vec3 position = vec3(origin + padding + (-anchor + offset + pushOut) / cameraScale2D.xy, depth);
  gl_Position = clipSpace(position);

  // Get the atlas position of the texture information
  texCoord = texture.xy + (texture.zw - texture.xy) * normals;
  // Apply the color of the glyph
  vertexColor = color * color.a;
}
`,Z0=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  vec4 texColor = texture2D(fontMap, texCoord);
  if (texColor.r <= 0.0) discard;
  texColor.a = texColor.r;
  gl_FragColor = texColor * vertexColor;
}
`,J0=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  // Calculate in the anchor, the origin, glyph offset, and the quad pushout to make our quad geometry
  vec2 pushOut = normals * glyphSize * fontScale;
  vec3 position = vec3(origin + padding + offset + pushOut, depth);
  gl_Position = clipSpace(position);

  // Get the atlas position of the texture information
  texCoord = texture.xy + (texture.zw - texture.xy) * normals;
  // Apply the color of the glyph
  vertexColor = color * color.a;
}
`,ev=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  vec4 texColor = texture2D(fontMap, texCoord);
  if (texColor.r <= 0.0) discard;
  texColor.a = texColor.r;
  gl_FragColor = texColor * vertexColor;
}
`,tv=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  vec2 scale = fontScale * cameraScale2D.xy;
  float scaleBy = max(scale.x, scale.y) / maxScale;
  vec2 pushOut = normals * glyphSize * fontScale;

  float vx = mix(
    (origin.x + padding.x + offset.x + pushOut.x),
    origin.x + anchor.x + (padding.x - anchor.x + offset.x + pushOut.x) / scaleBy,
    float(scale.x >= maxScale)
  );

  float vy = mix(
    (origin.y + padding.y + offset.y + pushOut.y),
    origin.y + anchor.y + (padding.y - anchor.y + offset.y + pushOut.y) / scaleBy,
    float(scale.y >= maxScale)
  );

  // Calculate in the anchor, the origin, glyph offset, and the quad pushout to make our quad geometry
  vec3 position = vec3(vec2(vx, vy), depth);
  gl_Position = clipSpace(position);

  // Get the atlas position of the texture information
  texCoord = texture.xy + (texture.zw - texture.xy) * normals;
  // Apply the color of the glyph
  vertexColor = color * color.a;
}
`,nv=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  vec4 texColor = texture2D(fontMap, texCoord);
  if (texColor.r <= 0.0) discard;
  texColor.a = texColor.r;
  gl_FragColor = texColor * vertexColor;
}
`,iv=`varying vec4 vertexColor;
varying vec2 texCoord;

void main() {
  // Calculate in the anchor, the origin, glyph offset, and the quad pushout to make our quad geometry
  vec2 pushOut = normals * glyphSize * fontScale;
  vec3 position = vec3(origin + anchor + (padding - anchor + offset + pushOut) / cameraScale2D.xy , depth);
  gl_Position = clipSpace(position);

  // Get the atlas position of the texture information
  texCoord = texture.xy + (texture.zw - texture.xy) * normals;
  // Apply the color of the glyph
  vertexColor = color * color.a;
}
`,er=class extends Ne{constructor(){super(...arguments),this.glyphRequests={}}initShader(){const t=this.props.animate||{},{anchor:e,color:n,offset:i,origin:r}=t,s={0:[0,0],1:[0,0],2:[1,0],3:[0,1],4:[1,1],5:[1,1]},a={name:"texture",resource:{key:()=>this.props.resourceKey||"",name:"fontMap"},update:h=>{const f=h.character;return(!h.request||h.character!==h.request.character)&&(this.glyphRequests[h.character]?h.request=this.glyphRequests[h.character]:(h.request=Si({key:this.props.resourceKey||"",character:f}),this.glyphRequests[h.character]=h.request),h.request.fontMap&&h.onReady&&h.onReady(h)),h.request.fetch=Ai.TEXCOORDS,this.resource.request(this,h,h.request)}},o={name:"glyphSize",parentAttribute:a,resource:{key:()=>this.props.resourceKey||"",name:"fontMap"},size:C.TWO,update:h=>{const f=h.character;return(!h.request||h.character!==h.request.character)&&(this.glyphRequests[h.character]?h.request=this.glyphRequests[h.character]:(h.request=Si({key:this.props.resourceKey||"",character:f}),this.glyphRequests[h.character]=h.request),h.request.fontMap&&h.onReady&&h.onReady(h)),h.request.fetch=Ai.IMAGE_SIZE,this.resource.request(this,h,h.request)}};a.childAttributes=[o];let c,u;switch(this.props.scaleMode||an.ALWAYS){case an.BOUND_MAX:{c=this.props.inTextArea?ev:X0,u=this.props.inTextArea?tv:Y0;break}case an.NEVER:{c=this.props.inTextArea?q0:nv,u=this.props.inTextArea?iv:K0;break}case an.ALWAYS:{c=this.props.inTextArea?Z0:vf,u=this.props.inTextArea?J0:wf;break}default:{c=vf,u=wf;break}}return{fs:c,instanceAttributes:[{easing:n,name:er.attributeNames.color,size:C.FOUR,update:h=>h.color},{name:er.attributeNames.depth,size:C.ONE,update:h=>[h.depth]},{name:"fontScale",size:C.ONE,update:h=>[h.fontScale]},{easing:e,name:er.attributeNames.anchor,size:C.TWO,update:h=>h.anchor},{easing:r,name:er.attributeNames.origin,size:C.TWO,update:h=>h.origin},{easing:i,name:er.attributeNames.offset,size:C.TWO,update:h=>h.offset},{name:"padding",size:C.TWO,update:h=>h.padding},{name:"maxScale",size:C.ONE,update:h=>[h.maxScale]},o,a],uniforms:[],vertexAttributes:[{name:"normals",size:Be.TWO,update:h=>s[h]}],vertexCount:6,vs:u}}draw(){super.draw()}getMaterialOptions(){return Object.assign({},tt.transparentImageBlending,{depthTest:!1})}willUpdateProps(t){t.resourceKey!==this.props.resourceKey&&(Object.values(this.glyphRequests).forEach(e=>{delete e.fontMap,e.key=t.resourceKey||""}),this.rebuildLayer())}};let fa=er;fa.defaultProps={key:"",data:new he,resourceKey:"No resource specified"},fa.attributeNames={color:"color",depth:"depth",anchor:"anchor",origin:"origin",offset:"offset"};const rv="...",Tf={[P.TopLeft]:(t,e)=>{t.x=0,t.y=0},[P.TopMiddle]:(t,e)=>{t.x=e.size[0]/2,t.y=0},[P.TopRight]:(t,e)=>{t.x=e.size[0],t.y=0},[P.MiddleLeft]:(t,e)=>{t.x=0,t.y=e.size[1]/2},[P.Middle]:(t,e)=>{t.x=e.size[0]/2,t.y=e.size[1]/2},[P.MiddleRight]:(t,e)=>{t.x=e.size[0],t.y=e.size[1]/2},[P.BottomLeft]:(t,e)=>{t.x=0,t.y=e.size[1]},[P.BottomMiddle]:(t,e)=>{t.x=e.size[0]/2,t.y=e.size[1]},[P.BottomRight]:(t,e)=>{t.x=e.size[0],t.y=e.size[1]},[P.Custom]:(t,e)=>{t.x=t.x||0,t.y=t.y||0}},ai=[[-1,-1],[0,-1],[1,-1],[-1,0],[0,0],[1,0],[-1,1],[0,1],[1,1]].map(t=>{const e=Math.sqrt(Di(t,t));return Re(t,1/-e)}),yf={[P.TopLeft]:t=>{t.paddingDirection=Re(ai[0],t.padding)},[P.TopMiddle]:t=>{t.paddingDirection=Re(ai[1],t.padding)},[P.TopRight]:t=>{t.paddingDirection=Re(ai[2],t.padding)},[P.MiddleLeft]:t=>{t.paddingDirection=Re(ai[3],t.padding)},[P.Middle]:t=>{t.paddingDirection=[0,0]},[P.MiddleRight]:t=>{t.paddingDirection=Re(ai[5],t.padding)},[P.BottomLeft]:t=>{t.paddingDirection=Re(ai[6],t.padding)},[P.BottomMiddle]:t=>{t.paddingDirection=Re(ai[7],t.padding)},[P.BottomRight]:t=>{t.paddingDirection=Re(ai[8],t.padding)},[P.Custom]:t=>{t.paddingDirection=t.paddingDirection}};function Ve(t){if(t)return e=>{t({...e,instances:e.instances.map(n=>n.parentLabel).filter(me)})}}class jc extends Ne{constructor(){super(...arguments),this.fullUpdate=!1,this.glyphProvider=new he,this.labelToGlyphs=new Map,this.labelToKerningRequest=new Map,this.labelWaitingOnGlyph=new Map,this.truncationWidth=-1,this.handleGlyphReady=e=>{if(!e.parentLabel){delete e.onReady;return}const n=e.parentLabel,i=this.labelWaitingOnGlyph.get(e.parentLabel);if(i&&i.has(e)&&(i.delete(e),i.size<=0)){const r=n.onReady;r&&r(n)}}}childLayers(){return[_i(this.props.customGlyphLayer||fa,{animate:this.props.animate,data:this.glyphProvider,key:`${this.id}.glyphs`,resourceKey:this.props.resourceKey,scaleMode:this.props.scaleMode||an.BOUND_MAX,inTextArea:this.props.inTextArea,picking:this.props.picking,onMouseClick:Ve(this.props.onMouseClick),onMouseUp:Ve(this.props.onMouseUp),onMouseDown:Ve(this.props.onMouseDown),onMouseOut:Ve(this.props.onMouseOut),onMouseOver:Ve(this.props.onMouseOver),onMouseMove:Ve(this.props.onMouseMove),onMouseUpOutside:Ve(this.props.onMouseUpOutside),onTap:Ve(this.props.onTap),onTouchDown:Ve(this.props.onTouchDown),onTouchUp:Ve(this.props.onTouchUp),onTouchUpOutside:Ve(this.props.onTouchUpOutside),onTouchMove:Ve(this.props.onTouchMove),onTouchOut:Ve(this.props.onTouchOut),onTouchOver:Ve(this.props.onTouchOver),onTouchAllEnd:Ve(this.props.onTouchAllEnd),onTouchAllOut:Ve(this.props.onTouchAllOut)})]}draw(){const e=this.resolveChanges();if(e.length<=0)return;if(!this.propertyIds){const h=e[0][0];this.propertyIds=this.getInstanceObservableIds(h,["text","active","anchor","color","origin","fontSize","maxWidth","maxScale","letterSpacing"])}const{text:n,active:i,anchor:r,color:s,origin:a,fontSize:o,maxWidth:c,maxScale:u,letterSpacing:l}=this.propertyIds;for(let h=0,f=e.length;h<f;++h){const[p,g,m]=e[h];switch(g){case Ce.CHANGE:if(!this.labelToGlyphs.get(p)){this.insert(p);continue}m[n]!==void 0?(this.invalidateRequest(p),this.layoutGlyphs(p)):m[i]!==void 0&&(p.active?(this.layoutGlyphs(p),this.showGlyphs(p)):this.hideGlyphs(p)),m[r]&&this.updateAnchor(p),m[s]!==void 0&&this.updateGlyphColors(p),m[a]!==void 0&&this.updateGlyphOrigins(p),m[u]!==void 0&&this.updateGlyphMaxScales(p),m[o]!==void 0&&(this.invalidateRequest(p),this.layoutGlyphs(p)),m[c]!==void 0&&(this.invalidateRequest(p),this.layoutGlyphs(p)),m[l]!==void 0&&(this.invalidateRequest(p),this.layoutGlyphs(p));break;case Ce.INSERT:this.insert(p);break;case Ce.REMOVE:{const T=this.labelToGlyphs.get(p);if(T){for(let w=0,y=T.length;w<y;++w)this.glyphProvider.remove(T[w]);this.labelToGlyphs.delete(p),this.labelToKerningRequest.delete(p),this.labelWaitingOnGlyph.delete(p)}break}}}}insert(e){e.preload?this.props.data.remove(e):this.labelToGlyphs.get(e)||this.labelToGlyphs.set(e,[]),this.layoutGlyphs(e)}hideGlyphs(e){const n=this.labelToGlyphs.get(e);if(n)for(let i=0,r=n.length;i<r;++i)this.glyphProvider.remove(n[i])}initShader(){return null}invalidateRequest(e){this.labelToKerningRequest.delete(e)}layoutGlyphs(e){if(!this.updateKerning(e)||!e.active)return;const n=this.labelToKerningRequest.get(e);if(!n||!n.fontMap)return;const i=n.metrics;if(!i||!i.layout)return;const r=i.layout;this.updateGlyphs(e,r);const s=e.glyphs;e.size=r.size,Tf[e.anchor.type](e.anchor,e),yf[e.anchor.type](e.anchor);const a=e.anchor,o=e.anchor.paddingDirection;for(let c=0,u=Math.min(r.positions.length,s.length);c<u;++c){const l=r.positions[c],h=s[c];h.offset=l,h.fontScale=r.fontScale,h.anchor=[a.x||0,a.y||0],h.origin=os(e.origin),h.padding=o||[0,0],h.maxScale=e.maxScale}}managesInstance(e){return!!this.labelToGlyphs.get(e)}showGlyphs(e){const n=this.labelToGlyphs.get(e);if(n)for(let i=0,r=n.length;i<r;++i)this.glyphProvider.add(n[i])}updateAnchor(e){const n=e.glyphs;if(!n)return;Tf[e.anchor.type](e.anchor,e),yf[e.anchor.type](e.anchor);const i=e.anchor,r=e.anchor.paddingDirection;for(let s=0,a=n.length;s<a;++s)n[s].anchor=[i.x||0,i.y||0],n[s].padding=r||[0,0]}updateGlyphs(e,n){let i=this.labelToGlyphs.get(e);i||(i=[],this.labelToGlyphs.set(e,i));let r=this.labelWaitingOnGlyph.get(e);r||(r=new Set,this.labelWaitingOnGlyph.set(e,r));for(let s=0,a=Math.min(i.length,n.glyphs.length);s<a;++s){const o=i[s];o.character!==n.glyphs[s]&&(o.character=n.glyphs[s],(!o.request||!o.request.fontMap||!o.request.fontMap.glyphMap[o.character])&&r.add(o))}if(i.length<n.glyphs.length){let s=0;for(let a=i.length,o=n.glyphs.length;a<o;++a,++s){const c=n.glyphs[a],u=new Tt({character:c,color:e.color,origin:e.origin,maxScale:e.maxScale,onReady:this.handleGlyphReady});u.parentLabel=e,i.push(u),e.active&&this.glyphProvider.add(u),r.add(u)}}else if(i.length>n.glyphs.length){for(let s=n.glyphs.length,a=i.length;s<a;++s){const o=i[s];this.glyphProvider.remove(o)}for(;i.length>n.glyphs.length;)i.pop()}e.glyphs=i}updateGlyphColors(e){const n=e.glyphs;if(n)for(let i=0,r=n.length;i<r;++i)n[i].color=Mt(e.color)}updateGlyphOrigins(e){const n=e.glyphs;if(!n)return;const i=e.origin;for(let r=0,s=n.length;r<s;++r)n[r].origin=[i[0],i[1]]}updateGlyphMaxScales(e){const n=e.glyphs;if(!n)return;const i=e.maxScale;for(let r=0,s=n.length;r<s;++r)n[r].maxScale=i}updateKerning(e){let n=this.labelToKerningRequest.get(e);const i=e.text;if(n){if(n.kerningPairs&&n.kerningPairs.indexOf(i)>-1)return!!n.fontMap;if(n.fontMap&&!n.fontMap.supportsKerning(i.replace(/\s/g,"")))this.labelToKerningRequest.delete(e),n=void 0;else return!0}if(!n){const r={fontSize:e.fontSize,text:e.text,letterSpacing:e.letterSpacing};return e.maxWidth>0&&(r.maxWidth=e.maxWidth,r.truncation=this.props.truncation||rv),n=Si({key:this.props.resourceKey||"",character:"",kerningPairs:[i],metrics:r}),e.preload?(e.resourceTrigger=()=>{e.onReady&&e.onReady(e)},this.resource.request(this,e,n)):(this.resource.request(this,e,n,{resource:{type:le.FONT,key:this.props.resourceKey||""}}),this.labelToKerningRequest.set(e,n)),!1}return!0}willUpdateProps(e){e.data!==this.props.data&&delete this.propertyIds,e.scaleMode!==this.props.scaleMode&&this.rebuildLayer(),e.resourceKey!==this.props.resourceKey&&(this.fullUpdate=!0)}}jc.defaultProps={key:"",data:new he};var sv=Object.defineProperty,av=Object.getOwnPropertyDescriptor,un=(t,e,n,i)=>{for(var r=i>1?void 0:i?av(e,n):e,s=t.length-1,a;s>=0;s--)(a=t[s])&&(r=(i?a(e,n,r):a(r))||r);return i&&r&&sv(e,n,r),r};const bf=class extends ze{constructor(t){super(t),this.color=[0,0,0,1],this.depth=0,this.fontSize=12,this.maxScale=1,this.maxWidth=0,this.origin=[0,0],this.scale=1,this.text="",this.letterSpacing=0,this.preload=!1,this.glyphs=[],this.size=[0,0],this.truncatedText="",this.anchor={padding:0,paddingDirection:[0,0],type:P.TopLeft,x:0,y:0},He(this,bf),this.anchor=t.anchor||this.anchor,this.color=t.color||this.color,this.depth=t.depth||this.depth,this.fontSize=t.fontSize||this.fontSize,this.maxScale=t.maxScale||this.maxScale,this.maxWidth=t.maxWidth||0,this.onReady=t.onReady,this.origin=t.origin,this.preload=t.preload||!1,this.scale=t.scale||this.scale,this.text=t.text||this.text,this.letterSpacing=t.letterSpacing||this.letterSpacing,t.anchor&&this.setAnchor(t.anchor)}getWidth(){return this.size[0]}setAnchor(t){const e={padding:t.padding||0,paddingDirection:t.paddingDirection,type:t.type,x:t.x||0,y:t.y||0};this.anchor=e}subTextGlyphs(t){const e=[],n=this.text.indexOf(t);if(n<0)return e;let i=0;for(let r=0,s=Math.min(this.text.length,n+t.length);r<s;++r)pi(this.text[r])||(i++,r>=n&&e.push(this.glyphs[i]));return e}resourceTrigger(){}};let ae=bf;un([M],ae.prototype,"color",2),un([M],ae.prototype,"depth",2),un([M],ae.prototype,"fontSize",2),un([M],ae.prototype,"maxScale",2),un([M],ae.prototype,"maxWidth",2),un([M],ae.prototype,"origin",2),un([M],ae.prototype,"scale",2),un([M],ae.prototype,"text",2),un([M],ae.prototype,"letterSpacing",2),un([M],ae.prototype,"anchor",2);var ov=Object.defineProperty,cv=Object.getOwnPropertyDescriptor,Li=(t,e,n,i)=>{for(var r=i>1?void 0:i?cv(e,n):e,s=t.length-1,a;s>=0;s--)(a=t[s])&&(r=(i?a(e,n,r):a(r))||r);return i&&r&&ov(e,n,r),r},pa=(t=>(t[t.LEFT=0]="LEFT",t[t.RIGHT=1]="RIGHT",t[t.CENTERED=2]="CENTERED",t))(pa||{}),hn=(t=>(t[t.NONE=0]="NONE",t[t.CHARACTER=1]="CHARACTER",t[t.WORD=2]="WORD",t))(hn||{}),tr=(t=>(t[t.NEWLINE=0]="NEWLINE",t))(tr||{});const Ef=class extends ae{constructor(t){super(t),this.maxHeight=0,this.lineHeight=0,this.wordWrap=0,this.alignment=0,this.labels=[],this.newLabels=[],this.borders=[],this.padding=[0,0,0,0],this.borderWidth=6,this.hasBorder=!0,this.spaceWidth=0,He(this,Ef),this.color=t.color,this.origin=t.origin,this.oldOrigin=t.origin,this.text=t.text,this.fontSize=t.fontSize||this.fontSize,this.maxWidth=t.maxWidth||this.maxWidth,this.maxHeight=t.maxHeight||this.maxHeight,this.lineHeight=t.lineHeight||this.lineHeight,this.wordWrap=t.wordWrap||this.wordWrap,this.alignment=t.alignment||this.alignment,this.padding=t.padding||this.padding,this.borderWidth=t.borderWidth||this.borderWidth,this.hasBorder=t.hasBorder!==void 0?t.hasBorder:this.hasBorder,this.letterSpacing=t.letterSpacing||this.letterSpacing}};let oi=Ef;Li([M],oi.prototype,"maxHeight",2),Li([M],oi.prototype,"lineHeight",2),Li([M],oi.prototype,"wordWrap",2),Li([M],oi.prototype,"alignment",2),Li([M],oi.prototype,"padding",2),Li([M],oi.prototype,"borderWidth",2),Li([M],oi.prototype,"hasBorder",2);var lv=Object.defineProperty,uv=Object.getOwnPropertyDescriptor,dn=(t,e,n,i)=>{for(var r=i>1?void 0:i?uv(e,n):e,s=t.length-1,a;s>=0;s--)(a=t[s])&&(r=(i?a(e,n,r):a(r))||r);return i&&r&&lv(e,n,r),r};const hv={[P.TopLeft]:(t,e)=>{t.x=-t.padding,t.y=-t.padding},[P.TopMiddle]:(t,e)=>{t.x=e.size[0]/2,t.y=-t.padding},[P.TopRight]:(t,e)=>{t.x=e.size[0]+t.padding,t.y=-t.padding},[P.MiddleLeft]:(t,e)=>{t.x=-t.padding,t.y=e.size[1]/2},[P.Middle]:(t,e)=>{t.x=e.size[0]/2,t.y=e.size[1]/2},[P.MiddleRight]:(t,e)=>{t.x=e.size[0]+t.padding,t.y=e.size[1]/2},[P.BottomLeft]:(t,e)=>{t.x=-t.padding,t.y=e.size[1]+t.padding},[P.BottomMiddle]:(t,e)=>{t.x=e.size[0]/2,t.y=e.size[1]+t.padding},[P.BottomRight]:(t,e)=>{t.x=e.size[0]+t.padding,t.y=e.size[1]+t.padding},[P.Custom]:(t,e)=>{t.x=t.x||0,t.y=t.y||0}},_f=class extends ze{constructor(t){super(t),this.color=[0,0,0,1],this.depth=0,this.maxScale=1,this.scale=1,this.scaling=an.BOUND_MAX,this.size=[1,1],this.position=[0,0],this.outline=0,this.outlineColor=[0,0,0,1],this._anchor={padding:0,type:P.TopLeft,x:0,y:0},He(this,_f),this.depth=t.depth||this.depth,this.color=t.color||this.color,this.scaling=t.scaling||this.scaling,this.position=t.position||this.position,this.size=t.size||this.size,this.outline=t.outline||this.outline,this.outlineColor=t.outlineColor||this.outlineColor,t.anchor&&this.setAnchor(t.anchor)}get anchor(){return this._anchor}setAnchor(t){const e={padding:t.padding||0,type:t.type,x:t.x||0,y:t.y||0};hv[e.type](e,this),this._anchor=e}};let pt=_f;dn([M],pt.prototype,"color",2),dn([M],pt.prototype,"depth",2),dn([M],pt.prototype,"maxScale",2),dn([M],pt.prototype,"scale",2),dn([M],pt.prototype,"scaling",2),dn([M],pt.prototype,"size",2),dn([M],pt.prototype,"position",2),dn([M],pt.prototype,"outline",2),dn([M],pt.prototype,"outlineColor",2),dn([M],pt.prototype,"_anchor",2);var dv=Object.defineProperty,fv=Object.getOwnPropertyDescriptor,Hc=(t,e,n,i)=>{for(var r=i>1?void 0:i?fv(e,n):e,s=t.length-1,a;s>=0;s--)(a=t[s])&&(r=(i?a(e,n,r):a(r))||r);return i&&r&&dv(e,n,r),r};const Rf=class extends pt{constructor(t){super(t),this.fontScale=1,this.textAreaOrigin=[0,0],this.textAreaAnchor=[0,0],He(this,Rf),this.fontScale=t.fontScale||this.fontScale,this.textAreaOrigin=t.textAreaOrigin||this.textAreaOrigin,this.textAreaAnchor=t.textAreaAnchor||this.textAreaAnchor}};let Oi=Rf;Hc([M],Oi.prototype,"fontScale",2),Hc([M],Oi.prototype,"textAreaOrigin",2),Hc([M],Oi.prototype,"textAreaAnchor",2);const pv=`precision highp float;

varying vec4 vertexColor;

void main() {
  gl_FragColor = vertexColor;
}
`,gv=`precision highp float;

varying vec4 vertexColor;

void main() {
  float borderScale = mix(fontScale, 1.0, float(scaling == 3.0));

  // Determine final screen size of label
  vec3 screenSize = cameraSpaceSize(vec3(size * scale * borderScale / scaleFactor / maxScale, 1.0));

  // Test whether the label is larger on the screen than the font size
  bool largerOnScreen = screenSize.y > size.y || screenSize.x > size.x;

  // Determines if a scale mode should be used or not for the vertex
  float useScaleMode = float(
    (
      scaling == 3.0 ||                  // NEVER mode - keep the image the same size always
      (largerOnScreen && scaling == 2.0) // BOUND_MAX mode - only if we're larger than the font size do we scale down
    ) &&
    scaling != 1.0                       // ALWAYS mode - the image stays completely in world space allowing it to scale freely
  );

  // Correct aspect ratio. Sufficient fix for most applications.
  // Will need another solution in the case of:
  // (cameraScale2D y != cameraScale2D.x) && (cameraScale2D.x != 1 && cameraScale2D.y != 1)

  // If zooms are unequal, assume one is filtered to be 1.0
  float unequalZooms = float(cameraScale2D.x != cameraScale2D.y);

  vec2 adjustedSize = mix(
    size,
    (size * cameraScale2D.yx),
    unequalZooms
  );

  // Destructure the normals attribute
  float normal = normals.x;
  float side = normals.y;

  vec2 scaledAnchor = anchor * scale;

  // Get the location of the anchor in world space
  vec2 worldAnchor = location + scaledAnchor;

  vec2 adjustedAnchor = mix(
    scaledAnchor,
    (scaledAnchor * cameraScale2D.yx),
    unequalZooms
  );

  // Get the position of the current vertex
  vec2 vertex = vec2(side, float(normal == 1.0)) * scale * adjustedSize + location - adjustedAnchor;

  // See how scaled the size on screen will be from the actual height of the label
  float labelScreenScale = mix(
    screenSize.y / adjustedSize.y,
    screenSize.x / adjustedSize.x,
    float((cameraScale2D.x != 1.0))
  );

  float currentScale = labelScreenScale * scale;

  // If our screen rendering is larger than the size the label is supposed to be, then we automagically
  // scale down our label to stay the correct size, centered on the anchor point
  vec2 anchorToVertex = vertex - location;

  // We now choose between keeping the same image size or keeping it in world space
  vertex = mix(
    // This option keeps the image size in world space
    vertex + textAreaOrigin,
    // This option counters the scaling of the image on the screen keeping it a static size
    (anchorToVertex + location - textAreaAnchor) / labelScreenScale + textAreaOrigin + textAreaAnchor,
    // This is the flag determining if a scale mode should be applied to the vertex
    useScaleMode
  );

  // --Texture and Color
  // Apply the label's color as a tint to the label (all labels are rendered white to the base texture)
  vertexColor = color;

  gl_Position = clipSpace(vec3(vertex, depth));
}
`,fn=class extends Ne{initShader(){const t=this.props.animate||{},e={0:1,1:1,2:-1,3:1,4:-1,5:-1},n={0:0,1:0,2:0,3:1,4:1,5:1},{scaleFactor:i=()=>1}=this.props;return{fs:pv,instanceAttributes:[{easing:t.location,name:fn.attributeNames.location,size:C.TWO,update:r=>r.position},{name:fn.attributeNames.anchor,size:C.TWO,update:r=>[r.anchor.x||0,r.anchor.y||0]},{name:fn.attributeNames.size,size:C.TWO,update:r=>r.size},{name:fn.attributeNames.depth,size:C.ONE,update:r=>[r.depth]},{name:fn.attributeNames.scaling,size:C.ONE,update:r=>[r.scaling]},{easing:t.color,name:fn.attributeNames.color,size:C.FOUR,update:r=>r.color},{name:fn.attributeNames.scale,size:C.ONE,update:r=>[r.scale]},{name:fn.attributeNames.maxScale,size:C.ONE,update:r=>[r.maxScale]},{name:fn.attributeNames.fontScale,size:C.ONE,update:r=>[r.fontScale]},{name:"textAreaOrigin",size:C.TWO,update:r=>r.textAreaOrigin},{name:"textAreaAnchor",size:C.TWO,update:r=>r.textAreaAnchor}],uniforms:[{name:"scaleFactor",size:E.ONE,update:r=>[i()]}],vertexAttributes:[{name:"normals",size:Be.TWO,update:r=>[e[r],n[r]]}],vertexCount:6,vs:gv}}getMaterialOptions(){return tt.transparentShapeBlending}};let Qc=fn;Qc.defaultProps={key:"",data:new he},Qc.attributeNames={anchor:"anchor",color:"color",depth:"depth",fontScale:"fontScale",location:"location",maxScale:"maxScale",scale:"scale",scaling:"scaling",size:"size"};const ci={[P.TopLeft]:t=>[0,0],[P.TopMiddle]:t=>[t.maxWidth/2,0],[P.TopRight]:t=>[t.maxWidth,0],[P.MiddleLeft]:t=>[0,t.maxHeight/2],[P.Middle]:t=>[t.maxWidth/2,t.maxHeight/2],[P.MiddleRight]:t=>[t.maxWidth,t.maxHeight/2],[P.BottomLeft]:t=>[0,t.maxHeight],[P.BottomMiddle]:t=>[t.maxWidth/2,t.maxHeight],[P.BottomRight]:t=>[t.maxWidth,t.maxHeight],[P.Custom]:t=>[t.anchor.x||0,t.anchor.y||0]};function ga(t,e){let n=Number.MAX_SAFE_INTEGER;for(let i=0,r=t.length;i<r;i++){const s=t[i],a=e.get(s);a===0?n=0:a&&a<n&&(n=a)}return n===Number.MAX_SAFE_INTEGER?0:n}function mv(t){const e=[],n=t.split(jl);for(let s=0,a=n.length-1;s<a;s++)n[s].split(" ").forEach(u=>{u!==""&&e.push(u)}),e.push(`
`);return n[n.length-1].split(" ").forEach(s=>{s!==""&&e.push(s)}),e}function vv(t,e){const n=new Map;if(e.fontMap){const i=e.fontMap.fontSource.size,r=t.fontSize/i,s=e.fontMap,a=t.text.replace(/\s/g,"");let o=Number.MAX_SAFE_INTEGER,c=0,u,l="";for(let h=0,f=a.length;h<f;++h){const p=a[h];u=0,l&&(u=s.kerning[l][p][1]||0),c=c+u*r,n.set(p,c),o=Math.min(c,o),l=p}n.forEach((h,f)=>{n.set(f,h-o)})}return n}function wv(t,e,n){const i=[],r=n.fontMap?n.fontMap.fontSource.size:e.fontSize,s=e.fontSize/r;let a="",o=0,c=[0,0];for(let u=0,l=t.text.length;u<l;u++){const h=t.text[u];if(n.fontMap){let f=[0,0];a&&(f=n.fontMap.kerning[a][h]||[0,0]),c=wn(c,Re(f,s)),u!==0&&(c=wn(c,[e.letterSpacing,0]));const p=n.fontMap.glyphMap[h];o=c[0]+p.pixelWidth*s,i.push(o),a=h}}return i}class xf extends Ne{constructor(){super(...arguments),this.providers={labels:new he,borders:new he},this.fullUpdate=!1,this.areaToLabels=new Map,this.areaToLines=new Map,this.areaWaitingOnLabel=new Map,this.areaTokerningRequest=new Map,this.areaToWords=new Map,this.labelsInLine=[],this.handleLabelReady=e=>{if(!e.parentTextArea){delete e.onReady;return}const n=e.parentTextArea,i=this.areaWaitingOnLabel.get(n);if(i&&i.has(e)&&(i.delete(e),i.size<=0)){n.active=!0;const r=n.onReady;r&&r(n)}}}childLayers(){const e=this.props.animateLabel||{},n=this.props.animateBorder||{},i=this.props.scaling;return[_i(jc,{animate:e,customGlyphLayer:this.props.customGlyphLayer,data:this.providers.labels,key:`${this.id}.labels`,resourceKey:this.props.resourceKey,scaleMode:i,inTextArea:!0}),_i(Qc,{animate:{color:n.color,location:n.location},data:this.providers.borders,key:`${this.id}.border`})]}draw(){const e=this.resolveChanges();if(e.length<=0)return;if(!this.propertyIds){const T=e[0][0];this.propertyIds=this.getInstanceObservableIds(T,["active","alignment","borderWidth","color","fontSize","hasBorder","letterSpacing","lineHeight","maxHeight","maxWidth","origin","padding","text","wordWrap"])}const{active:n,alignment:i,borderWidth:r,color:s,fontSize:a,hasBorder:o,letterSpacing:c,lineHeight:u,maxHeight:l,maxWidth:h,origin:f,padding:p,text:g,wordWrap:m}=this.propertyIds;for(let T=0,w=e.length;T<w;++T){const[y,b,A]=e[T];switch(b){case Ce.CHANGE:if(!this.areaToLabels.get(y)){this.insert(y);continue}A[g]!==void 0?(this.clear(y),this.updateLabels(y),this.layout(y)):A[n]!==void 0&&(y.active?(this.layout(y),this.showLabels(y)):this.hideLabels(y)),A[i]!==void 0&&(this.clear(y),this.updateLabels(y),this.layoutLabels(y)),A[s]!==void 0&&this.updateLabelColors(y),A[f]!==void 0&&this.updateLabelOrigins(y),A[a]!==void 0&&this.updateLabelFontSizes(y),A[m]!==void 0&&this.updateLabelLineWrap(y),A[u]!==void 0&&this.updateLabelLineHeight(y),A[h]!==void 0&&this.updateTextAreaSize(y),A[l]!==void 0&&this.updateTextAreaSize(y),A[p]!==void 0&&this.updateTextAreaSize(y),A[r]!==void 0&&this.updateBorderWidth(y),A[o]!==void 0&&this.updateBorder(y),A[c]!==void 0&&this.updateLetterSpacing(y);break;case Ce.INSERT:this.insert(y);break;case Ce.REMOVE:{const R=this.areaToLabels.get(y);if(R){for(let N=0,I=R.length;N<I;++N){const S=R[N];S instanceof ae&&this.providers.labels.remove(S)}this.areaToLabels.delete(y),this.areaWaitingOnLabel.delete(y)}break}}}}insert(e){this.layout(e),this.updateLabels(e)}hideLabels(e){const n=this.areaToLabels.get(e);if(n)for(let i=0,r=n.length;i<r;++i){const s=n[i];s instanceof ae&&this.providers.labels.remove(s)}}initShader(){return null}clear(e){const n=e.labels;for(let r=0,s=n.length;r<s;r++){const a=n[r];a instanceof ae&&this.providers.labels.remove(a)}e.labels=[];const i=e.newLabels;for(let r=0,s=i.length;r<s;r++){const a=i[r];a instanceof ae&&this.providers.labels.remove(a)}e.newLabels=[],this.areaToLabels.delete(e),this.areaWaitingOnLabel.delete(e),this.areaToWords.delete(e)}seperateLabel(e,n,i,r,s,a,o,c,u){const l=e.padding[0],h=e.padding[1]||0,f=e.padding[2]||0,p=e.padding[3]||0,g=e.maxWidth-p-h,m=e.maxHeight-l-f,T=e.origin[0],w=e.origin[1];n.active=!1;const y=r.substring(0,s+1),b=ga(y,i),A=ci[e.anchor.type](e),R=new ae({anchor:{padding:0,type:P.Custom,paddingDirection:[a+p,o+l+b],x:A[0],y:A[1]},color:e.color,fontSize:e.fontSize,letterSpacing:e.letterSpacing,origin:[T,w],text:y});if(R.size=[u[s],n.size[1]],this.providers.labels.add(R),e.newLabels.push(R),this.labelsInLine.push(R),a+=R.getWidth()+c,e.wordWrap===hn.CHARACTER||e.wordWrap===hn.WORD){if(this.setTextAlignment(a,o,c,g,e.alignment),a=0,o+=e.lineHeight,o+e.lineHeight<=m){let N=u[u.length-1]-u[s];for(;N>g&&o+e.lineHeight<=m;){let I=u.length-1;for(;u[I]-u[s]>g;)I--;const S=r.substring(s+1,I+1),j=ga(S,i),Q=new ae({anchor:{padding:0,type:P.Custom,paddingDirection:[a+p,o+l+j],x:A[0],y:A[1]},color:e.color,fontSize:e.fontSize,letterSpacing:e.letterSpacing,origin:[T,w],text:S});Q.size=[u[I]-u[s],n.size[1]],a+=Q.getWidth()+c,this.labelsInLine.push(Q),this.providers.labels.add(Q),e.newLabels.push(Q),this.setTextAlignment(a,o,c,g,e.alignment),a=0,o+=e.lineHeight,s=I,N=u[u.length-1]-u[s]}if(o+e.lineHeight<=m){const I=r.substring(s+1),S=ga(I,i),j=new ae({anchor:{padding:0,type:P.Custom,paddingDirection:[a+p,o+l+S],x:A[0],y:A[1]},color:e.color,fontSize:e.fontSize,letterSpacing:e.letterSpacing,origin:[T,w],text:I});j.size=[u[u.length-1]-u[s],n.size[1]],this.labelsInLine.push(j);const Q=[];for(let D=s+1;D<u.length;D++)Q.push(u[D]-u[s]);this.providers.labels.add(j),e.newLabels.push(j),a+=j.getWidth()+c}}}else e.wordWrap===hn.NONE&&(a+=R.getWidth()+c);return[a,o]}updateLabelLineWrap(e){const n=this.areaToLabels.get(e);if(n){for(let i=0,r=n.length;i<r;++i){const s=n[i];s instanceof ae&&(s.active=!0)}for(let i=0,r=e.newLabels.length;i<r;++i){const s=e.newLabels[i];this.providers.labels.remove(s)}e.newLabels=[],this.layoutLabels(e)}}updateLabelLineHeight(e){const n=this.areaToLabels.get(e);if(n){for(let i=0,r=n.length;i<r;++i){const s=n[i];s instanceof ae&&(s.active=!0)}for(let i=0,r=e.newLabels.length;i<r;++i){const s=e.newLabels[i];this.providers.labels.remove(s)}e.newLabels=[],this.layoutLabels(e)}}updateTextAreaSize(e){const n=this.areaToLabels.get(e);if(n){for(let i=0,r=n.length;i<r;++i){const s=n[i];s instanceof ae&&(s.active=!0)}for(let i=0,r=e.newLabels.length;i<r;++i){const s=e.newLabels[i];this.providers.labels.remove(s)}e.newLabels=[];for(let i=0,r=e.borders.length;i<r;++i){const s=e.borders[i];this.providers.borders.remove(s)}e.borders=[],this.layoutBorder(e),this.layoutLabels(e)}}updateBorderWidth(e){for(let n=0,i=e.borders.length;n<i;++n){const r=e.borders[n];this.providers.borders.remove(r)}e.borders=[],this.layoutBorder(e)}updateBorder(e){if(e.hasBorder)this.layoutBorder(e);else{for(let n=0,i=e.borders.length;n<i;++n){const r=e.borders[n];this.providers.borders.remove(r)}e.borders=[]}}updateLetterSpacing(e){this.clear(e),this.updateLabels(e),this.layout(e)}setTextAlignment(e,n,i,r,s){if(e-i<r&&s!==pa.LEFT){const a=r-e+i,o=s===pa.RIGHT?a:a/2;this.labelsInLine.forEach(c=>{const u=c.anchor;c.anchor={padding:u.padding,type:P.Custom,paddingDirection:[(u.paddingDirection?u.paddingDirection[0]:0)+o,u.paddingDirection?u.paddingDirection[1]:n],x:u.x,y:u.y}})}this.labelsInLine=[]}layoutBorder(e){if(e.hasBorder){const n=this.areaTokerningRequest.get(e);if(!n)return;const i=n.fontMap?n.fontMap.fontSource.size:e.fontSize,r=e.fontSize/i,s=this.props.scaling,a=e.borderWidth,o=new Oi({color:e.color,fontScale:r,scaling:s,size:[e.maxWidth+2*a,a],textAreaOrigin:e.origin,textAreaAnchor:ci[e.anchor.type](e),position:[-a,-a]}),c=new Oi({color:e.color,fontScale:r,scaling:s,size:[a,e.maxHeight+2*a],textAreaOrigin:e.origin,textAreaAnchor:ci[e.anchor.type](e),position:[-a,-a]}),u=new Oi({color:e.color,fontScale:r,scaling:s,size:[a,e.maxHeight+2*a],textAreaOrigin:e.origin,textAreaAnchor:ci[e.anchor.type](e),position:[e.maxWidth,-a]}),l=new Oi({color:e.color,fontScale:r,scaling:s,size:[e.maxWidth+2*a,a],textAreaOrigin:e.origin,textAreaAnchor:ci[e.anchor.type](e),position:[-a,e.maxHeight]});this.providers.borders.add(o),this.providers.borders.add(c),this.providers.borders.add(u),this.providers.borders.add(l),e.borders.push(o),e.borders.push(c),e.borders.push(u),e.borders.push(l)}}layoutLabels(e){const n=this.areaTokerningRequest.get(e);if(!n)return;const i=e.padding[0],r=e.padding[1]||0,s=e.padding[2]||0,a=e.padding[3]||0,o=e.maxWidth-a-r,c=e.maxHeight-i-s,u=e.origin[0],l=e.origin[1];let h=0;if(e.spaceWidth)h=e.spaceWidth;else{if(n.fontMap){const m=n.fontMap.fontSource.size,T=e.fontSize/m;h=n.fontMap.spaceWidth*T}else h=this.props.whiteSpaceKerning||e.fontSize/2;e.spaceWidth=h}const f=vv(e,n);let p=0,g=0;this.labelsInLine=[];for(let m=0,T=e.labels.length;m<T;++m){const w=e.labels[m];if(w instanceof ae){const y=w.getWidth(),b=ga(w.text,f),A=wv(w,e,n);if(g+e.lineHeight<=c&&A[0]<=o)if(p+y<=o){w.origin=[u,l];const R=ci[e.anchor.type](e);w.anchor={padding:0,paddingDirection:[p+a,g+i+b],type:P.Custom,x:R[0],y:R[1]},p+=y+h,this.labelsInLine.push(w),p>=o&&e.wordWrap===hn.CHARACTER&&m+1<T&&e.labels[m+1]!==tr.NEWLINE&&(this.setTextAlignment(p,g,h,o,e.alignment),p=0,g+=e.lineHeight)}else if(e.wordWrap===hn.WORD&&w.getWidth()<=e.maxWidth)if(this.setTextAlignment(p,g,h,o,e.alignment),p=0,g+=e.lineHeight,g+e.lineHeight<=c){w.origin=[u,l];const R=ci[e.anchor.type](e);w.anchor={padding:0,paddingDirection:[p+a,g+i+b],type:P.Custom,x:R[0],y:R[1]},this.labelsInLine.push(w),p+=w.getWidth()+h}else w.active=!1;else{const R=o-p;let N=A.length-1;const I=w.text;for(;A[N]>R;)N--;if(N>=0){const S=this.seperateLabel(e,w,f,I,N,p,g,h,A);p=S[0],g=S[1]}else if(e.wordWrap===hn.CHARACTER||e.wordWrap===hn.WORD)if(this.setTextAlignment(p,g,h,o,e.alignment),g+=e.lineHeight,p=0,g+e.lineHeight<c)if(p+w.getWidth()<=o){w.origin=[u,l];const S=ci[e.anchor.type](e);w.anchor={padding:0,paddingDirection:[p+a,g+i+b],type:P.Custom,x:S[0],y:S[1]},this.labelsInLine.push(w),p+=w.getWidth()+h,p>=o&&m+1<T&&e.labels[m+1]!==tr.NEWLINE&&(this.setTextAlignment(p,g,h,o,e.alignment),p=0,g+=e.lineHeight)}else{const S=o-p;let j=A.length-1;const Q=w.text;for(;A[j]>S;)j--;if(j>=0){const D=this.seperateLabel(e,w,f,Q,j,p,g,h,A);p=D[0],g=D[1]}}else w.active=!1;else e.wordWrap===hn.NONE&&(w.active=!1)}else w.active=!1}else w===tr.NEWLINE&&(this.setTextAlignment(p,g,h,o,e.alignment),p=0,g+=e.lineHeight)}this.setTextAlignment(p,g,h,o,e.alignment)}layout(e){this.updateKerning(e);const n=this.areaTokerningRequest.get(e);if(!n||!n.fontMap)return;const i=this.areaWaitingOnLabel.get(e);if(i&&i.size>0||!e.active)return;const r=this.areaToLabels.get(e);!r||r.length===0||(this.updateLabels(e),this.layoutBorder(e),this.layoutLabels(e))}updateKerning(e){let n=this.areaTokerningRequest.get(e);const i=e.text;if(n){if(n.kerningPairs&&n.kerningPairs.indexOf(i)>-1)return!!n.fontMap;if(n.fontMap&&!n.fontMap.supportsKerning(i))this.areaTokerningRequest.delete(e),n=void 0;else return!1}else{const r={fontSize:e.fontSize,text:e.text,letterSpacing:e.letterSpacing};return n=Si({character:"",key:this.props.resourceKey||"",kerningPairs:[i],metrics:r}),e.preload?(e.resourceTrigger=()=>{e.onReady&&e.onReady(e)},this.resource.request(this,e,n)):(this.resource.request(this,e,n),this.areaTokerningRequest.set(e,n)),!1}return!0}managesInstance(e){return!!this.areaToLabels.get(e)}showLabels(e){const n=this.areaToLabels.get(e);if(n)for(let i=0,r=n.length;i<r;++i){const s=n[i];s instanceof ae&&this.providers.labels.add(s)}}updateLabels(e){let n=this.areaToLabels.get(e);const i=e.padding[0],r=e.padding[3]||0,s=e.origin[0]+r,a=e.origin[1]+i;n||(n=[],this.areaToLabels.set(e,n));let o=this.areaWaitingOnLabel.get(e);o||(o=new Set,this.areaWaitingOnLabel.set(e,o));let c=this.areaToWords.get(e);if(c||(c=mv(e.text)),n.length<c.length)for(let u=n.length,l=c.length;u<l;++u){const h=c[u];if(h===`
`)n.push(tr.NEWLINE);else{const f=new ae({active:!1,color:e.color,fontSize:e.fontSize,letterSpacing:e.letterSpacing,text:h,origin:[s,a],onReady:this.handleLabelReady});f.parentTextArea=e,n.push(f),this.providers.labels.add(f),o.add(f)}}e.labels=n}updateLabelColors(e){const n=this.areaToLabels.get(e);if(n){for(let i=0,r=n.length;i<r;++i){const s=n[i];s instanceof ae&&(s.color=Mt(e.color))}for(let i=0,r=e.newLabels.length;i<r;++i)e.newLabels[i].color=Mt(e.color);for(let i=0,r=e.borders.length;i<r;++i)e.borders[i].color=Mt(e.color)}}updateLabelFontSizes(e){this.clear(e),this.updateLabels(e),this.areaTokerningRequest.delete(e),this.layout(e)}updateLabelOrigins(e){const n=this.areaToLabels.get(e);if(!n)return;const i=e.origin,r=e.oldOrigin;for(let s=0,a=n.length;s<a;++s){const o=n[s];if(o instanceof ae){const c=o.origin;o.origin=[c[0]+i[0]-r[0],c[1]+i[1]-r[1]]}}for(let s=0,a=e.newLabels.length;s<a;++s){const o=e.newLabels[s];if(o instanceof ae){const c=o.origin;o.origin=[c[0]+i[0]-r[0],c[1]+i[1]-r[1]]}}for(let s=0,a=e.borders.length;s<a;++s){const o=e.borders[s];o.position=[o.position[0]+i[0]-r[0],o.position[1]+i[1]-r[1]]}e.oldOrigin=e.origin}willUpdateProps(e){e.data!==this.props.data&&delete this.propertyIds,e.resourceKey!==this.props.resourceKey&&(this.fullUpdate=!0)}}xf.defaultProps={key:"",data:new he,scaling:an.ALWAYS};const Tv=`precision highp float;

varying vec4 vertexColor;
varying vec4 _outlineColor;
varying vec2 _texCoord;
varying vec2 _boxSize;
varying float _outline;

void main() {
  // Get rid of tiny float errors
  if (_outline < 0.0000001) \${out: color} = vertexColor;
  else {
    _FragColor = mix(vertexColor, _outlineColor, float(_texCoord.x < _outline ||
      _texCoord.x > (_boxSize.x - _outline) ||
      _texCoord.y < _outline ||
      _texCoord.y > (_boxSize.y - _outline)));
  }
}
`,yv=`precision highp float;

varying vec4 vertexColor;
varying vec4 _outlineColor;
varying float _outline;
varying vec2 _texCoord;
// How large the rectangle is in normalized window space (0 - 1 space not -1 - 1)
varying vec2 _boxSize;

void main() {
  // Determine final screen size of label
  vec3 screenSize = cameraSpaceSize(vec3(size * scale / scaleFactor / maxScale, 1.0f));

  // Test whether the label is larger on the screen than the font size
  bool largerOnScreen = screenSize.y > size.y || screenSize.x > size.x;

  // Determines if a scale mode should be used or not for the vertex
  float useScaleMode = float((scaling == 3.0f ||                  // NEVER mode - keep the image the same size always
    (largerOnScreen && scaling == 2.0f) // BOUND_MAX mode - only if we're larger than the font size do we scale down
  ) &&
    scaling != 1.0f                       // ALWAYS mode - the image stays completely in world space allowing it to scale freely
  );

  // TODO: Correct aspect ratio. Sufficient fix for most applications.
  // Will need another solution in the case of:
  // (cameraScale2D.y != cameraScale2D.x) && (cameraScale2D.x != 1 && cameraScale2D.y != 1)

  // If zooms are unequal, assume one is filtered to be 1.0
  float unequalZooms = float(cameraScale2D.x != cameraScale2D.y);

  vec2 adjustedSize = mix(size, (size * cameraScale2D.yx), unequalZooms);

  // Destructure normals attribute
  float normal = normals.x;
  float side = normals.y;

  vec2 scaledAnchor = anchor * scale;

  // Get the location of the anchor in world space
  vec2 worldAnchor = location + scaledAnchor;

  vec2 adjustedAnchor = mix(scaledAnchor, (scaledAnchor * cameraScale2D.yx), unequalZooms);

  // Get the position of the current vertex
  vec2 vertex = vec2(side, float(normal == 1.0f)) * scale * adjustedSize + location - adjustedAnchor;

  // See how scaled the size on screen will be from the actual height of the label
  float labelScreenScale = mix(screenSize.y / adjustedSize.y, screenSize.x / adjustedSize.x, float((cameraScale2D.x != 1.0f)));

  float currentScale = labelScreenScale * scale;

  // If our screen rendering is larger than the size the label is supposed to be, then we automagically
  // scale down our label to stay the correct size, centered on the anchor point
  vec2 anchorToVertex = vertex - location;

  float usedScaling = mix(
    1.,
    1. / labelScreenScale,
    useScaleMode
  );

  // We now choose between keeping the same image size or keeping it in world space
  vertex = mix(
    // This option keeps the image size in world space
  vertex,
    // This option counters the scaling of the image on the screen keeping it a static size
  (anchorToVertex * usedScaling) + location,
    // This is the flag determining if a scale mode should be applied to the vertex
  useScaleMode);

  // --Texture and Color
  // Apply the label's color as a tint to the label (all labels are rendered white to the base texture)
  vertexColor = color;

  gl_Position = clipSpace(vec3(vertex, depth));

  vec2 clipSize = (cameraScale2D.xy * scale * adjustedSize * usedScaling);
  _outlineColor = outlineColor;
  _outline = outline;
  _boxSize = clipSize;
  // Send the tex coords in screen space which is 0 - width in normalized clip space
  _texCoord = vec2(side, (normal + 1.) * 0.5) * clipSize;
}
`,yt=class extends Ne{initShader(){const t=this.props.animate||{},e={0:1,1:1,2:-1,3:1,4:-1,5:-1},n={0:0,1:0,2:0,3:1,4:1,5:1},{scaleFactor:i=()=>1}=this.props;return{fs:Tv,instanceAttributes:[{easing:t.location,name:yt.attributeNames.location,size:C.TWO,update:r=>r.position},{name:yt.attributeNames.anchor,size:C.TWO,update:r=>[r.anchor.x||0,r.anchor.y||0]},{easing:t.size,name:yt.attributeNames.size,size:C.TWO,update:r=>r.size},{name:yt.attributeNames.depth,size:C.ONE,update:r=>[r.depth]},{name:yt.attributeNames.scaling,size:C.ONE,update:r=>[r.scaling]},{easing:t.color,name:yt.attributeNames.color,size:C.FOUR,update:r=>r.color},{name:yt.attributeNames.scale,size:C.ONE,update:r=>[r.scale]},{name:yt.attributeNames.maxScale,size:C.ONE,update:r=>[r.maxScale]},{easing:t.outline,name:yt.attributeNames.outline,size:C.ONE,update:r=>[r.outline]},{easing:t.outlineColor,name:yt.attributeNames.outlineColor,size:C.FOUR,update:r=>r.outlineColor}],uniforms:[{name:"scaleFactor",size:E.ONE,update:r=>[i()]}],vertexAttributes:[{name:"normals",size:Be.TWO,update:r=>[e[r],n[r]]}],vertexCount:6,vs:yv}}getMaterialOptions(){return tt.transparentShapeBlending}};let Xc=yt;Xc.defaultProps={key:"",data:new he},Xc.attributeNames={anchor:"anchor",color:"color",depth:"depth",location:"location",maxScale:"maxScale",scale:"scale",scaling:"scaling",size:"size",outline:"outline",outlineColor:"outlineColor"};var bv=Object.defineProperty,Ev=Object.getOwnPropertyDescriptor,Jr=(t,e,n,i)=>{for(var r=i>1?void 0:i?Ev(e,n):e,s=t.length-1,a;s>=0;s--)(a=t[s])&&(r=(i?a(e,n,r):a(r))||r);return i&&r&&bv(e,n,r),r};const Af=class extends ze{constructor(t){super(t),this.color=[1,1,1,1],this.depth=0,this.radius=0,this.thickness=1,this.center=[0,0],He(this,Af),this.color=t.color||this.color,this.depth=t.depth||this.depth,this.radius=t.radius||this.radius,this.thickness=t.thickness||this.thickness,this.center=t.center||this.center}get width(){return this.radius*2}get height(){return this.radius*2}get innerRadius(){return this.radius-this.thickness}};let nr=Af;Jr([M],nr.prototype,"color",2),Jr([M],nr.prototype,"depth",2),Jr([M],nr.prototype,"radius",2),Jr([M],nr.prototype,"thickness",2),Jr([M],nr.prototype,"center",2);const _v=`precision highp float;

/** This is the color of the ring */
varying vec4 vertexColor;
/**
 * This is how sharp the ring renders. For tiny rings, it's best to have
 * less sharpness to better convey the shape of a circle. A good starter setting:
 * edgeSharpness = mix(0.8, 0.01, min(gl_PointSize / 45.0, 1.0));
 */
varying float edgeSharpness;
/**
 * This should be a value that sets the thickness of the ring in normal space
 * relative to the PointSize
 */
varying float borderSize;
/**
 * Since this is now a quad instead of a point sprite, this provides what
 *gl_PointCoord used to provide.
 */
varying vec2 pointCoord;

varying float scale;

float circle(vec2 coord, float radius) {
  vec2 dist = coord - vec2(0.5f);

  return 1.0f - smoothstep(radius - (radius * edgeSharpness), radius, dot(dist, dist) * 4.0f);
}

void main() {
  float outer_step_factor = circle(pointCoord, 1.0f);
  float inner_step_factor = circle(pointCoord, 1.0f - borderSize * scale);

  gl_FragColor = mix(mix(                        // Select the outer color outside of the inner radius
  vec4(0.0f, 0.0f, 0.0f, 0.0f),    // Select invisible outside of inner and outer radius
  vertexColor,                  // Select outer color outside of inner, but inside outer
  outer_step_factor), vec4(0.0f, 0.0f, 0.0f, 0.0f),                 // Select inner color inside inner
  inner_step_factor);
}
`,Rv=`precision highp float;

varying vec4 vertexColor;
varying float edgeSharpness;
varying float borderSize;
varying vec2 pointCoord;

varying float scale;

void main() {
  scale = scaleFactor;

  vertexColor = color;
  float size = radius * scaleFactor * pixelRatio;

  float ringWidth = mix(2.0 , thickness, float(thickness > 2.0));

  borderSize = mix(
    (ringWidth) / size,
    ((ringWidth * pixelRatio) / size),
    float(pixelRatio > 1.0)
  );

  edgeSharpness = min(0.2 / (ringWidth * scale),  0.1);

  pointCoord = (normals.xy + vec2(1.0, 1.0)) / 2.0;

  // Center within clip space
  vec4 clipCenter = clipSpace(vec3(center, depth));
  // Center in screen space
  vec2 screenCenter = (clipCenter.xy + vec2(1.0, 1.0)) * vec2(0.5, 0.5) * viewSize;
  // Position in screen space
  vec2 vertex = (normals.xy * size) + screenCenter;
  // Position back to clip space
  gl_Position = vec4((vertex / viewSize) * vec2(2.0, 2.0) - vec2(1.0, 1.0), clipCenter.zw);
}
`,ir=class extends Ne{initShader(){const t=this.props.scaleFactor||(()=>1),e=this.props.animate||{},{color:n,center:i,radius:r}=e,s={0:1,1:1,2:-1,3:1,4:-1,5:-1},a={0:-1,1:-1,2:-1,3:1,4:1,5:1};return{fs:_v,instanceAttributes:[{easing:i,name:ir.attributeNames.center,size:C.TWO,update:o=>o.center},{easing:r,name:ir.attributeNames.radius,size:C.ONE,update:o=>[o.radius]},{name:ir.attributeNames.depth,size:C.ONE,update:o=>[o.depth]},{easing:n,name:ir.attributeNames.color,size:C.FOUR,update:o=>o.color},{name:ir.attributeNames.thickness,size:C.ONE,update:o=>[o.thickness]}],uniforms:[{name:"scaleFactor",size:E.ONE,update:o=>[t()]}],vertexAttributes:[{name:"normals",size:Be.TWO,update:o=>[s[o],a[o]]}],vertexCount:6,vs:Rv}}getMaterialOptions(){return tt.transparentShapeBlending}};let Yc=ir;Yc.defaultProps={key:"",data:new he},Yc.attributeNames={center:"center",radius:"radius",depth:"depth",color:"color",thickness:"thickness"};const xv=`// These are projection methods for basic camera operations
\${import: camera}

vec3 cameraSpace(vec3 world) {
  return (view * vec4(world, 1.0)).xyz;
}

vec3 cameraSpace(vec4 world) {
  return (view * world).xyz;
}

vec3 cameraSpaceDirection(vec3 world) {
  return (view * vec4(world, 0.0)).xyz;
}

vec3 cameraSpaceDirection(vec4 world) {
  return (view * world).xyz;
}

vec3 cameraSpaceSize(vec3 worldSize) {
  return (view * vec4(worldSize, 0.0)).xyz;
}

vec4 clipSpace(vec3 world) {
  return (viewProjection) * vec4(world, 1.0);
}

vec4 clipSpace(vec4 world) {
  return (viewProjection) * world;
}

vec4 clipSpaceDirection(vec3 worldSize) {
  return (viewProjection) * vec4(worldSize, 0.0);
}

vec4 clipSpaceDirection(vec4 worldSize) {
  return (viewProjection) * worldSize;
}

vec4 clipSpaceSize(vec3 worldSize) {
  return (viewProjection) * vec4(worldSize, 0.0);
}
`,Av=`
These are properties injected from the
current camera applied to the view.

Constants:
mat4 projection;
mat4 view;
mat4 viewProjection;
vec3 cameraOffset;
vec3 cameraPosition;
vec3 cameraScale;
vec3 cameraRotation;
vec2 viewSize;
float pixelRatio;
`;Ee.register([{moduleId:"camera",description:Av,content:"",compatibility:x.ALL,uniforms:t=>[{name:"projection",size:E.MATRIX4,update:()=>t.view.props.camera.projection},{name:"viewProjection",size:E.MATRIX4,update:()=>t.view.props.camera.viewProjection},{name:"view",size:E.MATRIX4,update:()=>t.view.props.camera.view},{name:"cameraPosition",size:E.THREE,update:()=>t.view.props.camera.position},{name:"cameraScale",size:E.THREE,update:()=>t.view.props.camera.scale},{name:"cameraRotation",size:E.THREE,update:()=>t.view.props.camera.scale},{shaderInjection:x.ALL,name:"viewSize",size:E.TWO,update:()=>[t.view.viewBounds.width,t.view.viewBounds.height]},{shaderInjection:x.ALL,name:"pixelRatio",size:E.ONE,update:()=>[t.view.pixelRatio]}]},{moduleId:"projection",content:xv,compatibility:x.ALL}]);const Sf=`
This provides frame timing information
or how many frames have been rendered.

Constants:
float currentTime;
float currentFrame;
`;Ee.register({moduleId:"frame",description:Sf,content:"",compatibility:x.ALL,uniforms:t=>[{name:"currentTime",size:E.ONE,shaderInjection:x.ALL,update:()=>[t.surface.frameMetrics.currentTime]},{name:"currentFrame",size:E.ONE,shaderInjection:x.ALL,update:()=>[t.surface.frameMetrics.currentFrame]}]}),Ee.register({moduleId:"time",description:Sf,content:"",compatibility:x.ALL,uniforms:t=>[{name:"time",size:E.ONE,shaderInjection:x.ALL,update:()=>[t.surface.frameMetrics.currentTime]}]});const Sv=`vec3 rgb2hsv(vec3 c) {
  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

  float d = q.x - min(q.w, q.y);
  float e = 1.0e-10;
  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c) {
  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
`,Mv=`
Provides methods that converts colors to
HSV values and back. This makes it
easier to deal with hue saturation and
lightness levels.

Methods:
vec3 rgb2hsv(vec3 c);
vec3 hsv2rgb(vec3 c);
`;Ee.register({moduleId:"hsv",description:Mv,content:Sv,compatibility:x.ALL});const Iv=`
This is an internal shader module that
helps establish the instancing system.
Not recommended for use unless you
really know how to utilize it properly.

Attributes:
float _active;
float instance;
`;Ee.register({moduleId:"instancing",description:Iv,content:"",compatibility:x.ALL,instanceAttributes:t=>{const e={name:"_active",size:C.ONE,update:n=>[n.active?1:0]};return t.shaderIOInfo.activeAttribute=e,[e]},vertexAttributes:t=>t.bufferType===xe.UNIFORM?[{name:"instance",size:Be.ONE,update:()=>[0]}]:[]});const Cv=`\${import: PI, PI2, fsin, fcos, wrap}

/**
 * A circular arc interpolator
 */
vec2 arc(float t, vec2 center, float radius, float start, float end) {
  float angle = wrap((end - start) * t + start, 0.0, PI2);
  return center + vec2(fcos(angle), fsin(angle)) * radius;
}
`,Lv=`/**
 * Single control point bezier curve
 */
vec2 bezier1(float t, vec2 p1, vec2 p2, vec2 c1) {
  return (1.0 - t) * (1.0 - t) * p1 + 2.0 * t * (1.0 - t) * c1 + t * t * p2;
}
`,Ov=`/**
 * Two control point bezier curve
 */
vec2 bezier2(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2) {
  float t1 = 1.0 - t;
  return pow(t1, 3.0) * p1 + 3.0 * t * pow(t1, 2.0) * c1 + 3.0 * pow(t, 2.0) * t1 * c2 + pow(t, 3.0) * p2;
}`,Nv=`\${import: PI, PI2, PI_2}

/**
 * This is an approximation of cos that allows us to bypass hardware precision
 * limitations for cos.
 *
 * http://lab.polygonal.de/2007/07/18/fast-and-accurate-sinecosine-approximation/
 * This is a GPU adaptation of this method to provide optimal GPU performance for the operation
 */
float fcos(float x) {
  float sine;
  // Cos is the same as sine but
  x += PI_2;

  // Always wrap input angle to -PI..PI
  x += mix(
    mix(
      0.0,
      -PI2, float(x > PI)
    ),
    PI2, float(x < -PI)
  );

  // Compute sine
  sine = 1.27323954 * x;
  sine += mix(-1.0, 1.0, float(x < 0.0)) * 0.405284735 * x * x;
  sine = 0.225 * (sine * (mix(1.0, -1.0, float(sine < 0.0)) * sine) - sine) + sine;

  return sine;
}
`,Pv=`float fmod(float x, float m, float m_inv) {
  return x - m * floor(x * m_inv);
}
`,Dv=`\${import: PI, PI2}

/**
 * This is an approximation of sin that allows us to bypass hardware precision
 * limitations for sin.
 *
 * http://lab.polygonal.de/2007/07/18/fast-and-accurate-sinecosine-approximation/
 * This is a GPU adaptation of this method to provide optimal GPU performance for the operation
 */
float fsin(float x) {
  float sine;

  // Always wrap input angle to -PI..PI
  x += mix(
    mix(
      0.0,
      -PI2, float(x > PI)
    ),
    PI2, float(x < -PI)
  );

  // Compute sine
  sine = 1.27323954 * x;
  sine += mix(-1.0, 1.0, float(x < 0.0)) * 0.405284735 * x * x;
  sine = 0.225 * (sine * (mix(1.0, -1.0, float(sine < 0.0)) * sine) - sine) + sine;

  return sine;
}
`,Fv=`float PI = 3.14159265;
`,Bv=`float PI2 = 6.2831853;
`,Uv=`// This is 1 / (pi * 2.0)
float PI2_INV = 0.1591549431;
`,Gv=`float PI_2 = 1.5707963268;
`,kv=`float PI_4 = 0.7853981634;
`,zv=`// This is 1 / pi
float PI_INV = 0.3183098862;
`,Vv=`float toDegrees = 57.2957795131;
`,Wv=`float toRadians = 0.01745329252;
`,$v=`float wrap(float value, float start, float end) {
  float width = end - start;
  float offsetValue = value - start;

  return (offsetValue - (floor(offsetValue / width) * width)) + start;
}
`,qc=[{moduleId:"PI_INV",description:"Provides: float PI_INV = 1.0 / pi",content:zv,compatibility:x.ALL},{moduleId:"PI2_INV",description:`Provides:
float PI2_INV = 1.0 / (pi * 2.0)`,content:Uv,compatibility:x.ALL},{moduleId:"PI_2",description:"Provides: float PI_2 = pi / 2.0",content:Gv,compatibility:x.ALL},{moduleId:"PI_4",description:"Provides: float PI_4 = pi / 4.0",content:kv,compatibility:x.ALL},{moduleId:"PI",description:"Provides: float PI = pi",content:Fv,compatibility:x.ALL},{moduleId:"PI2",description:"Provides: float PI2 = pi * 2.0",content:Bv,compatibility:x.ALL},{moduleId:"toDegrees",description:`Provides: float toDegrees;
Can be used to convert radians to degrees:
radians * toDegrees`,content:Vv,compatibility:x.ALL},{moduleId:"toRadians",description:`Provides: float toRadians;
Can be used to convert degrees to radians:
degress * toRadians`,content:Wv,compatibility:x.ALL}],jv={moduleId:"constants",description:`
Provides all the math constants you may
need as convenience. It's probably
better to include them individually, but
convenience sometimes beats practicality

Constants:
${qc.map(t=>t.moduleId).join(`
`)}
`,content:`\${import: ${qc.map(t=>t.moduleId).join(", ")}}`,compatibility:x.ALL},Hv=[{moduleId:"bezier1",description:`Provides the 2D single control
point bezier method:
vec2 bezier1(float t, vec2 p1, vec2 p2, vec2 c1)`,content:Lv,compatibility:x.ALL},{moduleId:"bezier2",description:`Provides the 2D single control
point bezier method:
vec2 bezier2(float t, vec2 p1, vec2 p2, vec2 c1, vec2 c2)`,content:Ov,compatibility:x.ALL},{moduleId:"arc",description:`Provides the 2D
arc interpolation method:
vec2 arc(float t,
	vec2 center,
	float radius,
	float start,
	float end
)`,content:Cv,compatibility:x.ALL},{moduleId:"fmod",description:`Provides the floating point
modulus method:
float fmod(float x, float m, float m_inv)`,content:Pv,compatibility:x.ALL},{moduleId:"wrap",description:`Provides a method that wraps
value overflows:
float wrap(float value, float start, float end)`,content:$v,compatibility:x.ALL},{moduleId:"fcos",description:`Provides a fcos method that also
has a higher precision than
some hardware cos implementations:
float fcos(float x)`,content:Nv,compatibility:x.ALL},{moduleId:"fsin",description:`Provides a fsin method that also
has a higher precision than
some hardware sin implementations:
float fsin(float x)`,content:Dv,compatibility:x.ALL}];Ee.register([...Hv,...qc,jv]);const Qv=`mat4 rotationFromQuaternion(vec4 q) {
  float x2 = q.y + q.y;
  float y2 = q.z + q.z;
  float z2 = q.w + q.w;
  float xx = q.y * x2;
  float xy = q.y * y2;
  float xz = q.y * z2;
  float yy = q.z * y2;
  float yz = q.z * z2;
  float zz = q.w * z2;
  float wx = q.x * x2;
  float wy = q.x * y2;
  float wz = q.x * z2;

  return mat4(
    1.0 - (yy + zz), xy - wz, xz + wy, 0.0,
    xy + wz, 1.0 - (xx + zz), yz - wx, 0.0,
    xz - wy, yz + wx, 1.0 - (xx + yy), 0.0,
    0, 0, 0, 1
  );
}
`,Xv=`mat4 scale(vec3 s) {
  return mat4(
    s.x, 0, 0, 0,
    0, s.y, 0, 0,
    0, 0, s.z, 0,
    0, 0, 0, 1
  );
}
`,Yv=`\${import: translation, rotation, scale}

mat4 transform(vec3 s, vec4 r, vec3 t) {
  return translation(t) * rotationFromQuaternion(r) * scale(s);
}
`,qv=`mat4 translation(vec3 t) {
  return mat4(
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    t.x, t.y, t.z, 1
  );
}
`;Ee.register([{moduleId:"translation",description:`Generates a translation matrix
from a vec3:
mat4 transform(vec3 s, vec4 r, vec3 t)`,compatibility:x.ALL,content:qv},{moduleId:"rotation",description:`Generates a rotation matrix
from a quaternion:
mat4 rotationFromQuaternion(vec4 q)`,compatibility:x.ALL,content:Qv},{moduleId:"scale",description:`Generates a scale matrix
from a vec3:
mat4 scale(vec3 s)`,compatibility:x.ALL,content:Xv},{moduleId:"transform",description:`Generates a full transform matrix
from a scale, quaternion, translation:
mat4 transform(vec3 s, vec4 r, vec3 t)`,compatibility:x.ALL,content:Yv}]);const Kv=`//
// Description : Array and textureless GLSL 2D simplex noise function.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : stegu
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//               https://github.com/stegu/webgl-noise
//

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0f / 289.0f)) * 289.0f;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0f / 289.0f)) * 289.0f;
}

vec3 permute(vec3 x) {
  return mod289(((x * 34.0f) + 10.0f) * x);
}

float simplexNoise2D(vec2 v) {
  // (3.0-sqrt(3.0))/6.0
  const vec4 C = vec4(0.211324865405187f,
  // 0.5*(sqrt(3.0)-1.0)
  0.366025403784439f,
  // -1.0 + 2.0 * C.x
  -0.577350269189626f,
  // 1.0 / 41.0
  0.024390243902439f);
  // First corner
  vec2 i = floor(v + dot(v, C.yy));
  vec2 x0 = v - i + dot(i, C.xx);

  // Other corners
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0f, 0.0f) : vec2(0.0f, 1.0f);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;

  // Permutations
  // Avoid truncation effects in permutation
  i = mod289(i);
  vec3 p = permute(permute(i.y + vec3(0.0f, i1.y, 1.0f)) + i.x + vec3(0.0f, i1.x, 1.0f));

  vec3 m = max(0.5f - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0f);
  // m ^ 4
  m = m * m;
  m = m * m;

  // Gradients: 41 points uniformly over a line, mapped onto a diamond.
  // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)
  vec3 x = 2.0f * fract(p * C.www) - 1.0f;
  vec3 h = abs(x) - 0.5f;
  vec3 ox = floor(x + 0.5f);
  vec3 a0 = x - ox;

  // Normalise gradients implicitly by scaling m
  // Approximation of: m *= inversesqrt( a0*a0 + h*h );
  m *= 1.79284291400159f - 0.85373472095314f * (a0 * a0 + h * h);

  // Compute final noise value at P
  vec3 g;
  g.x = a0.x * x0.x + h.x * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;

  return 130.0f * dot(m, g);
}
`,Zv=`//
// Description : Array and textureless GLSL 2D/3D/4D simplex
//               noise functions.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : stegu
//     Lastmod : 20201014 (stegu)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//               https://github.com/stegu/webgl-noise
//
vec3 mod289(vec3 x) {
  return x - floor(x * (1.0f / 289.0f)) * 289.0f;
}

vec4 mod289(vec4 x) {
  return x - floor(x * (1.0f / 289.0f)) * 289.0f;
}

vec4 permute(vec4 x) {
  return mod289(((x * 34.0f) + 10.0f) * x);
}

vec4 taylorInvSqrt(vec4 r) {
  return 1.79284291400159f - 0.85373472095314f * r;
}

float simplexNoise3D(vec3 v) {
  const vec2 C = vec2(1.0f / 6.0f, 1.0f / 3.0f);
  const vec4 D = vec4(0.0f, 0.5f, 1.0f, 2.0f);

  // First corner
  vec3 i = floor(v + dot(v, C.yyy));
  vec3 x0 = v - i + dot(i, C.xxx);

  // Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0f - g;
  vec3 i1 = min(g.xyz, l.zxy);
  vec3 i2 = max(g.xyz, l.zxy);

  // x0 = x0 - 0.0 + 0.0 * C.xxx;
  // x1 = x0 - i1  + 1.0 * C.xxx;
  // x2 = x0 - i2  + 2.0 * C.xxx;
  // x3 = x0 - 1.0 + 3.0 * C.xxx;
  vec3 x1 = x0 - i1 + C.xxx;
  // 2.0*C.x = 1/3 = C.y
  vec3 x2 = x0 - i2 + C.yyy;
  // -1.0+3.0*C.x = -0.5 = -D.y
  vec3 x3 = x0 - D.yyy;

  // Permutations
  i = mod289(i);
  vec4 p = permute(permute(permute(i.z + vec4(0.0f, i1.z, i2.z, 1.0f)) + i.y + vec4(0.0f, i1.y, i2.y, 1.0f)) + i.x + vec4(0.0f, i1.x, i2.x, 1.0f));

  // Gradients: 7x7 points over a square, mapped onto an octahedron.
  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
  float n_ = 0.142857142857f; // 1.0/7.0
  vec3 ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0f * floor(p * ns.z * ns.z);  //  mod(p,7*7)

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0f * x_);    // mod(j,N)

  vec4 x = x_ * ns.x + ns.yyyy;
  vec4 y = y_ * ns.x + ns.yyyy;
  vec4 h = 1.0f - abs(x) - abs(y);

  vec4 b0 = vec4(x.xy, y.xy);
  vec4 b1 = vec4(x.zw, y.zw);

  vec4 s0 = floor(b0) * 2.0f + 1.0f;
  vec4 s1 = floor(b1) * 2.0f + 1.0f;
  vec4 sh = -step(h, vec4(0.0f));

  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

  vec3 p0 = vec3(a0.xy, h.x);
  vec3 p1 = vec3(a0.zw, h.y);
  vec3 p2 = vec3(a1.xy, h.z);
  vec3 p3 = vec3(a1.zw, h.w);

  // Normalise gradients
  vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

  // Mix final noise value
  vec4 m = max(0.5f - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0f);
  m = m * m;
  return 105.0f * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
}
`;Ee.register({moduleId:"simplexNoise3D",content:Zv,compatibility:x.ALL,description:"Provides the simplex noise function for 3D coordinates."}),Ee.register({moduleId:"simplexNoise2D",content:Kv,compatibility:x.ALL,description:"Provides the simplex noise function for 2D coordinates."});const Jv=`vec4 bitSh = vec4(16777216., 65536., 256., 1.);
vec4 bitMsk = vec4(0., vec3(1. / 256.0));
vec4 bitShifts = vec4(1.) / vec4(16777216., 65536., 256., 1.);

vec4 packFloat(float value, float range) {
  value = (value + range) / (range * 2.);
  vec4 comp = fract(value * bitSh);
  comp -= comp.xxyz * bitMsk;
  return comp;
}

float unpackFloat(vec4 color, float range) {
  return dot(color , bitShifts) * (range * 2.) - range;
}
`,ew=`
This provides the ability to pack
a float value into a color RGBA
value. This is used to bypass the
lack of support for float textures.

Constants:
float currentTime;
float currentFrame;
`;Ee.register({moduleId:"packFloat",description:ew,content:Jv,compatibility:x.ALL});const tw=`// This is the varying auto generated for the fragment shader that is needed in the vertex shader to pass the
// color for the instance through to the fragment shader
varying highp vec4 _picking_color_pass_;
`;Ee.register([{moduleId:"picking",description:`Internal use only. Provides methods
and constants to make the picking processes work.`,content:tw,compatibility:x.VERTEX,instanceAttributes:t=>[{name:"_pickingColor",size:C.FOUR,shaderInjection:x.VERTEX,update:e=>{const n=16777215-e.uid;return[((n&16711680)>>16)/255,((n&65280)>>8)/255,(n&255)/255,1]}}]}]);const nw=`void main() {
  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
}
`,iw=`void main() {
  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
}
`,Mf=`
Makes a no-op shader where gl_Position
is [0, 0, 0, 0] and gl_FragColor is
[0, 0, 0, 0].

You can not import this if you specify
your own main() method.
`;Ee.register([{moduleId:"no-op",description:Mf,content:iw,compatibility:x.VERTEX},{moduleId:"no-op",description:Mf,content:nw,compatibility:x.FRAGMENT}]);const rw=`
This is a special helper module used by
the system to map View2D content into
a 3D world space. The system utilizes
this module automatically for you when
you utilize createLayer2Din3D.
`;Ee.register([{moduleId:"world2DXY",description:rw,content:ef,compatibility:x.ALL,uniforms:t=>t instanceof Ne?t.props.control2D?[{name:"projection",size:E.MATRIX4,update:()=>t.view.props.camera.projection},{name:"view",size:E.MATRIX4,update:()=>t.view.props.camera.view},{name:"cameraOffset",size:E.THREE,update:()=>t.props.control2D instanceof Cn?t.props.control2D.offset:[0,0,0]},{name:"cameraPosition",size:E.THREE,update:()=>t.view.props.camera.position},{name:"cameraScale",size:E.THREE,update:()=>t.view.props.camera.scale},{name:"cameraScale2D",size:E.THREE,update:()=>t.props.control2D instanceof Cn?t.props.control2D.scale:[1,1,1]},{name:"cameraRotation",size:E.FOUR,update:()=>t.view.props.camera.transform.rotation},{name:"viewSize",size:E.TWO,update:()=>[t.view.viewBounds.width,t.view.viewBounds.height]},{name:"pixelRatio",size:E.ONE,update:()=>[t.view.pixelRatio]}]:(console.warn("For a layer 2D to be compatible with a 3D View, the layer requires an additional prop of control2D"),[]):(console.warn("A shader requested the module world2DXZ; however, the layer the shader comes from is NOT a Layer2D which is","required for the module to work."),[])}]);const sw=`// These are projection methods utilizing the simpler camera 2d approach.
// This assumes we have a 3D camera projection which should be preferably orthographic layered with simpler 2D camera
// controls for manipulating the 2D world.
vec3 cameraSpace(vec3 world) {
  return (world + cameraOffset) * cameraScale2D;
}

vec3 cameraSpaceSize(vec3 worldSize) {
  return worldSize * cameraScale2D;
}

vec4 clipSpace(vec3 world) {
  return ((projection * view) * vec4(cameraSpace(world.xzy), 1.0));
}

vec4 clipSpaceSize(vec3 worldSize) {
  return ((projection * view) * vec4(cameraSpaceSize(worldSize.xzy), 0.0));
}
`,aw=`
This is a special helper module used by
the system to map View2D content into
a 3D world space. The system utilizes
this module automatically for you when
you utilize createLayer2Din3D.
`;Ee.register([{moduleId:"world2DXZ",description:aw,content:sw,compatibility:x.ALL,uniforms:t=>t instanceof Ne?t.props.control2D?[{name:"projection",size:E.MATRIX4,update:()=>t.view.props.camera.projection},{name:"view",size:E.MATRIX4,update:()=>t.view.props.camera.view},{name:"cameraOffset",size:E.THREE,update:()=>t.props.control2D instanceof Cn?t.props.control2D.offset:[0,0,0]},{name:"cameraPosition",size:E.THREE,update:()=>t.view.props.camera.position},{name:"cameraScale",size:E.THREE,update:()=>t.view.props.camera.scale},{name:"cameraScale2D",size:E.THREE,update:()=>t.props.control2D instanceof Cn?t.props.control2D.scale:[1,1,1]},{name:"cameraRotation",size:E.THREE,update:()=>t.view.props.camera.scale},{name:"viewSize",size:E.TWO,update:()=>[t.view.viewBounds.width,t.view.viewBounds.height]},{name:"pixelRatio",size:E.ONE,update:()=>[t.view.pixelRatio]}]:(console.warn("For a layer 2D to be compatible with a 3D View, the layer requires an additional prop of control2D"),[]):(console.warn("A shader requesed the module world2DXZ; however, the layer the shader comes from is NOT a Layer2D which is","required for the module to work."),[])}]);const ow=`// These are projection methods utilizing the simpler camera 2d approach.
// This assumes we have a 3D camera projection which should be preferably orthographic layered with simpler 2D camera
// controls for manipulating the 2D world.
vec3 cameraSpace(vec3 world) {
  return (world + cameraOffset) * cameraScale2D;
}

vec3 cameraSpaceSize(vec3 worldSize) {
  return worldSize * cameraScale2D;
}

vec4 clipSpace(vec3 world) {
  return ((projection * view) * vec4(cameraSpace(world.zyx), 1.0));
}

vec4 clipSpaceSize(vec3 worldSize) {
  return ((projection * view) * vec4(cameraSpaceSize(worldSize.zyx), 0.0));
}
`,cw=`
This is a special helper module used by
the system to map View2D content into
a 3D world space. The system utilizes
this module automatically for you when
you utilize createLayer2Din3D.
`;Ee.register([{moduleId:"world2DYZ",description:cw,content:ow,compatibility:x.ALL,uniforms:t=>t instanceof Ne?t.props.control2D?[{name:"projection",size:E.MATRIX4,update:()=>t.view.props.camera.projection},{name:"view",size:E.MATRIX4,update:()=>t.view.props.camera.view},{name:"cameraOffset",size:E.THREE,update:()=>t.props.control2D instanceof Cn?t.props.control2D.offset:[0,0,0]},{name:"cameraPosition",size:E.THREE,update:()=>t.view.props.camera.position},{name:"cameraScale",size:E.THREE,update:()=>t.view.props.camera.scale},{name:"cameraScale2D",size:E.THREE,update:()=>t.props.control2D instanceof Cn?t.props.control2D.scale:[1,1,1]},{name:"cameraRotation",size:E.THREE,update:()=>t.view.props.camera.scale},{name:"viewSize",size:E.TWO,update:()=>[t.view.viewBounds.width,t.view.viewBounds.height]},{name:"pixelRatio",size:E.ONE,update:()=>[t.view.pixelRatio]}]:(console.warn("For a layer 2D to be compatible with a 3D View, the layer requires an additional prop of control2D"),[]):(console.warn("A shader requesed the module world2DYZ; however, the layer the shader comes from is NOT a Layer2D which is","required for the module to work."),[])}]);class If extends Ns{screenToWorld(e,n){return n=n||[0,0,0],this.viewToWorld(this.screenToView(e),n),n}screenRay(e){if(this.camera.projectionType===xn.ORTHOGRAPHIC){const n=Wn(this.screenToWorld(e));return dc(n,this.camera.transform.forward)}else{const n=Wn(this.screenToWorld(e));return fc(Wn(this.camera.transform.position),n)}}worldToScreen(e,n){n=n||[0,0];const i=rt(this.camera.projection,this.camera.view),r=Ds(i,e,this.viewBounds.width,this.viewBounds.height);return de(n,r[0]/this.pixelRatio,r[1]/this.pixelRatio)}viewToWorld(e,n){n=n||[0,0,0];const{width:i,height:r}=this.viewBounds,{projectionOptions:s}=this.camera,a=Re(e,this.pixelRatio),{tan:o}=Math;if(s.type===xn.PERSPECTIVE){const{fov:c,near:u}=s,l=r/i,h=o(c/2)*u,f=(2*((a[0]+.5)/i)-1)*h,p=(1-2*((a[1]+.5)/r))*h*l,g=[f,p,-1],m=Or(this.camera.transform.matrix,dr(g,1));pe(n,m[0],m[1],m[2])}else{const c=ye(a,[i/2,r/2]),u=Or(this.camera.transform.viewMatrix,dr(c,-s.near));pe(n,u[0],-u[1],u[2])}return n}worldToView(e,n){n=n||[0,0];const i=rt(this.camera.projection,this.camera.view),r=Ds(i,e,this.viewBounds.width,this.viewBounds.height);return de(n,r[0]/this.pixelRatio,r[1]/this.pixelRatio)}}function lw(t){return t.projectionType===xn.ORTHOGRAPHIC}class Cf extends Xr{constructor(e,n){super(e,n),this.projection=new If,this.projection.camera=n.camera,this.projection.pixelRatio=this.pixelRatio}fitViewtoViewport(e,n){if(wc(this.props.camera)){const i=n.width,r=n.height,s=this.props.camera,a={near:s.projectionOptions.near,far:s.projectionOptions.far,width:i,height:r};this.props.preventCameraAdjustment||(s.projectionOptions=Object.assign(s.projectionOptions,a),s.update()),this.projection.pixelRatio=this.pixelRatio,this.projection.viewBounds=n,this.projection.viewBounds.d=this,this.projection.screenBounds=new te({height:this.projection.viewBounds.height/this.pixelRatio,width:this.projection.viewBounds.width/this.pixelRatio,x:this.projection.viewBounds.x/this.pixelRatio,y:this.projection.viewBounds.y/this.pixelRatio}),this.projection.screenBounds.d=this}else if(lw(this.props.camera)){const i=n.width,r=n.height,s=this.props.camera,a={near:s.projectionOptions.near,far:s.projectionOptions.far,left:-i/2,right:i/2,top:r/2,bottom:-r/2};this.props.preventCameraAdjustment||(s.projectionOptions=Object.assign(s.projectionOptions,a),s.update()),this.projection.pixelRatio=this.pixelRatio,this.projection.viewBounds=n,this.projection.viewBounds.d=this,this.projection.screenBounds=new te({height:this.projection.viewBounds.height/this.pixelRatio,width:this.projection.viewBounds.width/this.pixelRatio,x:this.projection.viewBounds.x/this.pixelRatio,y:this.projection.viewBounds.y/this.pixelRatio}),this.projection.screenBounds.d=this}}willUpdateProps(e){this.projection.camera=e.camera}}Cf.defaultProps={key:"",camera:new An({type:xn.PERSPECTIVE,width:100,height:100,fov:Math.PI/2,far:1e5,near:1}),viewport:{left:0,right:0,bottom:0,top:0}};var Lf=(t=>(t[t.XY=0]="XY",t[t.XZ=1]="XZ",t[t.YZ=2]="YZ",t))(Lf||{});function uw(t,e,n){if(!(e===Ne||e.prototype instanceof Ne))return console.warn("A Layer type was specified for createLayer2din3D that is NOT a Layer2D type, which is invalid.","The layer will be used without being modified."),Ei(e,n);let r;switch(t){case 0:r="world2DXY";break;case 1:r="world2DXZ";break;case 2:r="world2DYZ";break;default:return Ei(e,n)}const s=Object.assign({},n,{baseShaderModules:(a,o)=>{let c=o.vs.indexOf("world2D");return c>=0&&o.vs.splice(c,1,r),c=o.fs.indexOf("world2D"),c>=0&&o.fs.splice(c,1,r),o}});return Ei(e,s)}class Of extends rn{baseShaderModules(e){const n=super.baseShaderModules(e);return n.vs.push("parent-transform"),n}}const hw=`
When working with SceneGraphLayers, the
layer can have a transform applied to
the layer. This makes that transform
available in the parentTransform
constant.

mat4 parentTransform;
`;Ee.register({moduleId:"parent-transform",description:hw,compatibility:x.VERTEX,content:"",uniforms:t=>{const e=t;if(!(e instanceof Of))return console.warn("A shader requested the module parent-transform; however, the layer the","shader is generated from is NOT a SceneGraphLayer which is","required for the module to work."),[];const n=ue();return[{name:"parentTransform",size:E.MATRIX4,update:()=>{var i;return((i=e.props.parent)==null?void 0:i.matrix)||n}}]}});var dw=Object.defineProperty,fw=Object.getOwnPropertyDescriptor,li=(t,e,n,i)=>{for(var r=i>1?void 0:i?fw(e,n):e,s=t.length-1,a;s>=0;s--)(a=t[s])&&(r=(i?a(e,n,r):a(r))||r);return i&&r&&dw(e,n,r),r};const Kc=class extends ze{constructor(t){super(t),this.needsLocalUpdate=!1,this.needsWorldUpdate=!1,He(this,Kc);const e=t.transform||new Xs;this.transform=e,t.parent&&(t.parent instanceof Kc?this.parent=t.parent:this.transform.parent=t.parent)}get transform(){return this._transform}set transform(t){this._transform||(this._position=t.position,this._rotation=t.rotation,this._scale=t.scale,this._localPosition=t.localPosition,this._localRotation=t.localRotation,this._localScale=t.localScale,this._matrix=t.matrix,this._localMatrix=t.localMatrix),t.instance=this,this._transform=t}get matrix(){return this._transform.update(),this._matrix}get localMatrix(){return this._transform.update(),this._localMatrix}get localPosition(){return this.needsLocalUpdate=!0,this._localPosition}set localPosition(t){this.transform.localPosition=t}get localRotation(){return this.needsLocalUpdate=!0,this._localRotation}set localRotation(t){this.transform.localRotation=t}get localScale(){return this.needsLocalUpdate=!0,this._localScale}set localScale(t){this.transform.localScale=t}get position(){return this.needsWorldUpdate=!0,this.transform.update(),this._position}set position(t){this.transform.position=t}get rotation(){return this.needsWorldUpdate=!0,this.transform.update(),this._rotation}set rotation(t){this.transform.rotation=t}get scale(){return this.needsWorldUpdate=!0,this.transform.update(),this._scale}set scale(t){this.transform.scale=t}set parent(t){this.transform.parent=t.transform}optimize(){this.needsWorldUpdate=!1,this.needsLocalUpdate=!1,this.transform.optimize()}};let pn=Kc;li([M],pn.prototype,"_matrix",2),li([M],pn.prototype,"_localMatrix",2),li([M],pn.prototype,"_localPosition",2),li([M],pn.prototype,"_localRotation",2),li([M],pn.prototype,"_localScale",2),li([M],pn.prototype,"_position",2),li([M],pn.prototype,"_rotation",2),li([M],pn.prototype,"_scale",2);class pw extends vc{constructor(){super(...arguments),this.isQueuedForUpdate=!1,this.needsWorldOrientation=!1,this.needsWorldDecomposition=!1,this._instance=null,this._matrix={value:ue()},this._localMatrix={value:this._matrix.value},this._position={value:[0,0,0]},this._localPosition={value:this._position.value},this._rotation={value:Br()},this._localRotation={value:0},this.localRotationMatrix=Cr(),this._scale={value:[1,1,1]},this._localScale={value:this._scale.value}}set instance(e){this._instance!==e&&this._instance&&(this._instance.transform.instance=null,e&&(e.transform=this)),this._instance=e}get matrix(){return this.update(),this._matrix.value}get position(){return this.needsWorldOrientation=!0,this.update(),this._position.value}set position(e){this.parent?console.warn("NOT IMPLEMENTED: Setting world position is not supported yet. Use localPosition for now."):this.localPosition=e}get localPosition(){return this._localPosition.value}set localPosition(e){this._localPosition.value[0]=e[0],this._localPosition.value[1]=e[1],this._localPosition.didUpdate=!0,this.invalidate()}get rotation(){return this.needsWorldOrientation=!0,this.update(),this._rotation.value}set rotation(e){console.warn("NOT IMPLEMENTED: Setting world rotation for a 2D transform is not supported yet.")}get localRotation(){return this._localRotation.value}set localRotation(e){this._localRotation.value=e,this._localRotation.didUpdate=!0,this.invalidate()}get scale(){return this.needsWorldOrientation=!0,this.update(),this._scale.value}set scale(e){this.parent?console.warn("NOT IMPLEMENTED: Setting world scale is not supported yet. Use localScale for now."):this.localScale=e}get localScale(){return this._localScale.value}set localScale(e){de(this._localScale.value,e[0],e[1]),this._localScale.didUpdate=!0,this.invalidate()}decomposeWorldMatrix(){if(!this.parent||!this.needsWorldDecomposition||!this.needsWorldOrientation)return;this.needsWorldDecomposition=!1;const e=this._matrix.value,n=this._position.value,i=this._scale.value;this._position.didUpdate=n[0]!==e[12]||n[1]!==e[13]||n[2]!==e[14],this._position.didUpdate&&pe(n,e[12],e[13],e[14]);const r=Tn(e[0],e[1],e[2],e[3]),s=Tn(e[4],e[5],e[6],e[7]),a=Tn(e[8],e[9],e[10],e[11]);this._scale.didUpdate=i[0]!==r||i[1]!==s||i[2]!==a,pe(i,r,s,a),this._scale.didUpdate=!0;const[o,c,u,l]=this._rotation.value;$s(this._matrix.value,r,s,a,this._rotation.value);const h=this._rotation.value;this._rotation.didUpdate=h[0]!==o||h[1]!==c||h[2]!==u||h[3]!==l}queueForUpdate(){!this.isQueuedForUpdate&&this._instance&&this._instance.active&&(this.isQueuedForUpdate=!0,gc(this))}update(e){let n=!1;if(this.isQueuedForUpdate&&(mc(this),this.isQueuedForUpdate=!1),this.needsUpdate){const i=this.localRotationMatrix;this._localRotation.didUpdate&&Yo(this._localRotation.value,i),ic(this._localScale.value,i,this._localPosition.value,this._localMatrix.value),this._localMatrix.didUpdate=!0,n=!0}this.parent&&(this.parent.needsUpdate?(e||this.processParentUpdates(i=>{i.update(!0)}),n=!0):this.parent.childUpdate.has(this)&&(n=!0),n&&(rt(this.parent._matrix.value,this._localMatrix.value,this._matrix.value),this._matrix.didUpdate=!0,this.needsWorldDecomposition=!0)),this.decomposeWorldMatrix(),this._instance&&this._instance.active&&(this._localRotation.didUpdate&&(this._instance._localRotation=this._localRotation.value),this._localPosition.didUpdate&&(this._instance._localPosition=this._localPosition.value),this._localScale.didUpdate&&(this._instance._localScale=this._localScale.value),this.parent?(this._rotation.didUpdate&&(this._instance._rotation=this._rotation.value),this._scale.didUpdate&&(this._instance._scale=this._scale.value),this._position.didUpdate&&(this._instance._position=this._position.value)):(this._localRotation.didUpdate&&(this._instance._rotation=this._localRotation.value),this._localPosition.didUpdate&&(this._instance._position=this._localPosition.value),this._localScale.didUpdate&&(this._instance._scale=this._localScale.value)),(this._matrix.didUpdate||this._localMatrix.didUpdate)&&(this._instance.transform=this)),this._localScale.didUpdate=!1,this._localRotation.didUpdate=!1,this._localPosition.didUpdate=!1,this._rotation.didUpdate=!1,this._scale.didUpdate=!1,this._position.didUpdate=!1,this._matrix.didUpdate=!1,this._localMatrix.didUpdate=!1,this.resolve()}}const gw=`varying vec2 _texCoord;

void main() {
  gl_FragColor = mix(
    vec4(1.0, 0.0, 0.0, 1.0),
    vec4(0.0, 0.0, 0.0, 1.0),
    float(_texCoord.x <= 0.01 || _texCoord.x > 0.99 || _texCoord.y < 0.01 || _texCoord.y > 0.99)
  );
}
`,mw=`\${import: projection}

varying vec2 _texCoord;

void main() {
  vec4 pos = vec4(position * size, 1.0);
  vec4 world = transform * pos;
  _texCoord = texCoord;

  gl_Position = clipSpace(world.xyz);
}
`;class Nf extends rn{initShader(){const e=[1,1,1],n=[1,1,-1],i=[1,-1,-1],r=[1,-1,1],s=[-1,1,1],a=[-1,1,-1],o=[-1,-1,-1],c=[-1,-1,1],u=[e,n,i,e,i,r,s,e,r,s,r,c,s,o,a,s,c,o,a,i,n,a,o,i,s,n,e,s,a,n,c,r,i,c,i,o],l=[1,0,0],h=[0,0,1],f=[-1,0,0],p=[0,0,-1],g=[0,1,0],m=[0,-1,0],T=[l,l,l,l,l,l,h,h,h,h,h,h,f,f,f,f,f,f,p,p,p,p,p,p,g,g,g,g,g,g,m,m,m,m,m,m],w=[[0,0],[1,0],[1,1],[0,0],[1,1],[0,1],[0,0],[1,0],[1,1],[0,0],[1,1],[0,1],[0,0],[1,1],[1,0],[0,0],[0,1],[1,1],[0,0],[1,1],[1,0],[0,0],[0,1],[1,1],[0,0],[1,1],[1,0],[0,0],[0,1],[1,1],[0,0],[1,0],[1,1],[0,0],[1,1],[0,1]];return{drawMode:d.GLSettings.Model.DrawMode.TRIANGLES,fs:[{outputType:$.COLOR,source:gw}],instanceAttributes:[{name:"transform",size:C.MAT4X4,update:y=>(y.transform||kh).matrix},{name:"size",size:C.THREE,update:y=>y.size}],uniforms:[],vertexAttributes:[{name:"position",size:Be.THREE,update:y=>u[y]},{name:"normal",size:Be.THREE,update:y=>T[y]},{name:"texCoord",size:Be.TWO,update:y=>w[y]}],vertexCount:36,vs:mw}}getMaterialOptions(){return Object.assign({},tt.transparentShapeBlending,{cullSide:d.GLSettings.Material.CullSide.CCW})}}Nf.defaultProps={data:new he,key:"",materialOptions:tt.transparentShapeBlending};var vw=Object.defineProperty,ww=Object.getOwnPropertyDescriptor,Pf=(t,e,n,i)=>{for(var r=i>1?void 0:i?ww(e,n):e,s=t.length-1,a;s>=0;s--)(a=t[s])&&(r=(i?a(e,n,r):a(r))||r);return i&&r&&vw(e,n,r),r};const Df=class extends pn{constructor(t){super(t),this.size=[1,1,1],this.color=[1,1,1,1],He(this,Df),this.size=t.size||this.size,this.color=t.color||this.color}};let Zc=Df;Pf([M],Zc.prototype,"size",2),Pf([M],Zc.prototype,"color",2);var Jc={exports:{}},es={};/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ff;function Tw(){if(Ff)return es;Ff=1;var t=q,e=Symbol.for("react.element"),n=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,r=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,s={key:!0,ref:!0,__self:!0,__source:!0};function a(o,c,u){var l,h={},f=null,p=null;u!==void 0&&(f=""+u),c.key!==void 0&&(f=""+c.key),c.ref!==void 0&&(p=c.ref);for(l in c)i.call(c,l)&&!s.hasOwnProperty(l)&&(h[l]=c[l]);if(o&&o.defaultProps)for(l in c=o.defaultProps,c)h[l]===void 0&&(h[l]=c[l]);return{$$typeof:e,type:o,key:f,ref:p,props:h,_owner:r.current}}return es.Fragment=n,es.jsx=a,es.jsxs=a,es}var ts={};/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Bf;function yw(){return Bf||(Bf=1,process.env.NODE_ENV!=="production"&&function(){var t=q,e=Symbol.for("react.element"),n=Symbol.for("react.portal"),i=Symbol.for("react.fragment"),r=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),a=Symbol.for("react.provider"),o=Symbol.for("react.context"),c=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),l=Symbol.for("react.suspense_list"),h=Symbol.for("react.memo"),f=Symbol.for("react.lazy"),p=Symbol.for("react.offscreen"),g=Symbol.iterator,m="@@iterator";function T(v){if(v===null||typeof v!="object")return null;var _=g&&v[g]||v[m];return typeof _=="function"?_:null}var w=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;function y(v){{for(var _=arguments.length,O=new Array(_>1?_-1:0),k=1;k<_;k++)O[k-1]=arguments[k];b("error",v,O)}}function b(v,_,O){{var k=w.ReactDebugCurrentFrame,ne=k.getStackAddendum();ne!==""&&(_+="%s",O=O.concat([ne]));var ce=O.map(function(J){return String(J)});ce.unshift("Warning: "+_),Function.prototype.apply.call(console[v],console,ce)}}var A=!1,R=!1,N=!1,I=!1,S=!1,j;j=Symbol.for("react.module.reference");function Q(v){return!!(typeof v=="string"||typeof v=="function"||v===i||v===s||S||v===r||v===u||v===l||I||v===p||A||R||N||typeof v=="object"&&v!==null&&(v.$$typeof===f||v.$$typeof===h||v.$$typeof===a||v.$$typeof===o||v.$$typeof===c||v.$$typeof===j||v.getModuleId!==void 0))}function D(v,_,O){var k=v.displayName;if(k)return k;var ne=_.displayName||_.name||"";return ne!==""?O+"("+ne+")":O}function H(v){return v.displayName||"Context"}function z(v){if(v==null)return null;if(typeof v.tag=="number"&&y("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."),typeof v=="function")return v.displayName||v.name||null;if(typeof v=="string")return v;switch(v){case i:return"Fragment";case n:return"Portal";case s:return"Profiler";case r:return"StrictMode";case u:return"Suspense";case l:return"SuspenseList"}if(typeof v=="object")switch(v.$$typeof){case o:var _=v;return H(_)+".Consumer";case a:var O=v;return H(O._context)+".Provider";case c:return D(v,v.render,"ForwardRef");case h:var k=v.displayName||null;return k!==null?k:z(v.type)||"Memo";case f:{var ne=v,ce=ne._payload,J=ne._init;try{return z(J(ce))}catch{return null}}}return null}var V=Object.assign,re=0,W,oe,Y,Le,ee,Se,Bn;function Un(){}Un.__reactDisabledLog=!0;function Gn(){{if(re===0){W=console.log,oe=console.info,Y=console.warn,Le=console.error,ee=console.group,Se=console.groupCollapsed,Bn=console.groupEnd;var v={configurable:!0,enumerable:!0,value:Un,writable:!0};Object.defineProperties(console,{info:v,log:v,warn:v,error:v,group:v,groupCollapsed:v,groupEnd:v})}re++}}function vn(){{if(re--,re===0){var v={configurable:!0,enumerable:!0,writable:!0};Object.defineProperties(console,{log:V({},v,{value:W}),info:V({},v,{value:oe}),warn:V({},v,{value:Y}),error:V({},v,{value:Le}),group:V({},v,{value:ee}),groupCollapsed:V({},v,{value:Se}),groupEnd:V({},v,{value:Bn})})}re<0&&y("disabledDepth fell below zero. This is a bug in React. Please file an issue.")}}var kn=w.ReactCurrentDispatcher,sr;function Ni(v,_,O){{if(sr===void 0)try{throw Error()}catch(ne){var k=ne.stack.trim().match(/\n( *(at )?)/);sr=k&&k[1]||""}return`
`+sr+v}}var rl=!1,ya;{var Uw=typeof WeakMap=="function"?WeakMap:Map;ya=new Uw}function Yf(v,_){if(!v||rl)return"";{var O=ya.get(v);if(O!==void 0)return O}var k;rl=!0;var ne=Error.prepareStackTrace;Error.prepareStackTrace=void 0;var ce;ce=kn.current,kn.current=null,Gn();try{if(_){var J=function(){throw Error()};if(Object.defineProperty(J.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(J,[])}catch(zn){k=zn}Reflect.construct(v,[],J)}else{try{J.call()}catch(zn){k=zn}v.call(J.prototype)}}else{try{throw Error()}catch(zn){k=zn}v()}}catch(zn){if(zn&&k&&typeof zn.stack=="string"){for(var K=zn.stack.split(`
`),Xe=k.stack.split(`
`),_e=K.length-1,Me=Xe.length-1;_e>=1&&Me>=0&&K[_e]!==Xe[Me];)Me--;for(;_e>=1&&Me>=0;_e--,Me--)if(K[_e]!==Xe[Me]){if(_e!==1||Me!==1)do if(_e--,Me--,Me<0||K[_e]!==Xe[Me]){var gt=`
`+K[_e].replace(" at new "," at ");return v.displayName&&gt.includes("<anonymous>")&&(gt=gt.replace("<anonymous>",v.displayName)),typeof v=="function"&&ya.set(v,gt),gt}while(_e>=1&&Me>=0);break}}}finally{rl=!1,kn.current=ce,vn(),Error.prepareStackTrace=ne}var or=v?v.displayName||v.name:"",cp=or?Ni(or):"";return typeof v=="function"&&ya.set(v,cp),cp}function Gw(v,_,O){return Yf(v,!1)}function kw(v){var _=v.prototype;return!!(_&&_.isReactComponent)}function ba(v,_,O){if(v==null)return"";if(typeof v=="function")return Yf(v,kw(v));if(typeof v=="string")return Ni(v);switch(v){case u:return Ni("Suspense");case l:return Ni("SuspenseList")}if(typeof v=="object")switch(v.$$typeof){case c:return Gw(v.render);case h:return ba(v.type,_,O);case f:{var k=v,ne=k._payload,ce=k._init;try{return ba(ce(ne),_,O)}catch{}}}return""}var Ea=Object.prototype.hasOwnProperty,qf={},Kf=w.ReactDebugCurrentFrame;function _a(v){if(v){var _=v._owner,O=ba(v.type,v._source,_?_.type:null);Kf.setExtraStackFrame(O)}else Kf.setExtraStackFrame(null)}function zw(v,_,O,k,ne){{var ce=Function.call.bind(Ea);for(var J in v)if(ce(v,J)){var K=void 0;try{if(typeof v[J]!="function"){var Xe=Error((k||"React class")+": "+O+" type `"+J+"` is invalid; it must be a function, usually from the `prop-types` package, but received `"+typeof v[J]+"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");throw Xe.name="Invariant Violation",Xe}K=v[J](_,J,k,O,null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")}catch(_e){K=_e}K&&!(K instanceof Error)&&(_a(ne),y("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).",k||"React class",O,J,typeof K),_a(null)),K instanceof Error&&!(K.message in qf)&&(qf[K.message]=!0,_a(ne),y("Failed %s type: %s",O,K.message),_a(null))}}}var Vw=Array.isArray;function sl(v){return Vw(v)}function Ww(v){{var _=typeof Symbol=="function"&&Symbol.toStringTag,O=_&&v[Symbol.toStringTag]||v.constructor.name||"Object";return O}}function $w(v){try{return Zf(v),!1}catch{return!0}}function Zf(v){return""+v}function Jf(v){if($w(v))return y("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.",Ww(v)),Zf(v)}var ns=w.ReactCurrentOwner,jw={key:!0,ref:!0,__self:!0,__source:!0},ep,tp,al;al={};function Hw(v){if(Ea.call(v,"ref")){var _=Object.getOwnPropertyDescriptor(v,"ref").get;if(_&&_.isReactWarning)return!1}return v.ref!==void 0}function Qw(v){if(Ea.call(v,"key")){var _=Object.getOwnPropertyDescriptor(v,"key").get;if(_&&_.isReactWarning)return!1}return v.key!==void 0}function Xw(v,_){if(typeof v.ref=="string"&&ns.current&&_&&ns.current.stateNode!==_){var O=z(ns.current.type);al[O]||(y('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',z(ns.current.type),v.ref),al[O]=!0)}}function Yw(v,_){{var O=function(){ep||(ep=!0,y("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)",_))};O.isReactWarning=!0,Object.defineProperty(v,"key",{get:O,configurable:!0})}}function qw(v,_){{var O=function(){tp||(tp=!0,y("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)",_))};O.isReactWarning=!0,Object.defineProperty(v,"ref",{get:O,configurable:!0})}}var Kw=function(v,_,O,k,ne,ce,J){var K={$$typeof:e,type:v,key:_,ref:O,props:J,_owner:ce};return K._store={},Object.defineProperty(K._store,"validated",{configurable:!1,enumerable:!1,writable:!0,value:!1}),Object.defineProperty(K,"_self",{configurable:!1,enumerable:!1,writable:!1,value:k}),Object.defineProperty(K,"_source",{configurable:!1,enumerable:!1,writable:!1,value:ne}),Object.freeze&&(Object.freeze(K.props),Object.freeze(K)),K};function Zw(v,_,O,k,ne){{var ce,J={},K=null,Xe=null;O!==void 0&&(Jf(O),K=""+O),Qw(_)&&(Jf(_.key),K=""+_.key),Hw(_)&&(Xe=_.ref,Xw(_,ne));for(ce in _)Ea.call(_,ce)&&!jw.hasOwnProperty(ce)&&(J[ce]=_[ce]);if(v&&v.defaultProps){var _e=v.defaultProps;for(ce in _e)J[ce]===void 0&&(J[ce]=_e[ce])}if(K||Xe){var Me=typeof v=="function"?v.displayName||v.name||"Unknown":v;K&&Yw(J,Me),Xe&&qw(J,Me)}return Kw(v,K,Xe,ne,k,ns.current,J)}}var ol=w.ReactCurrentOwner,np=w.ReactDebugCurrentFrame;function ar(v){if(v){var _=v._owner,O=ba(v.type,v._source,_?_.type:null);np.setExtraStackFrame(O)}else np.setExtraStackFrame(null)}var cl;cl=!1;function ll(v){return typeof v=="object"&&v!==null&&v.$$typeof===e}function ip(){{if(ol.current){var v=z(ol.current.type);if(v)return`

Check the render method of \``+v+"`."}return""}}function Jw(v){{if(v!==void 0){var _=v.fileName.replace(/^.*[\\\/]/,""),O=v.lineNumber;return`

Check your code at `+_+":"+O+"."}return""}}var rp={};function e1(v){{var _=ip();if(!_){var O=typeof v=="string"?v:v.displayName||v.name;O&&(_=`

Check the top-level render call using <`+O+">.")}return _}}function sp(v,_){{if(!v._store||v._store.validated||v.key!=null)return;v._store.validated=!0;var O=e1(_);if(rp[O])return;rp[O]=!0;var k="";v&&v._owner&&v._owner!==ol.current&&(k=" It was passed a child from "+z(v._owner.type)+"."),ar(v),y('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.',O,k),ar(null)}}function ap(v,_){{if(typeof v!="object")return;if(sl(v))for(var O=0;O<v.length;O++){var k=v[O];ll(k)&&sp(k,_)}else if(ll(v))v._store&&(v._store.validated=!0);else if(v){var ne=T(v);if(typeof ne=="function"&&ne!==v.entries)for(var ce=ne.call(v),J;!(J=ce.next()).done;)ll(J.value)&&sp(J.value,_)}}}function t1(v){{var _=v.type;if(_==null||typeof _=="string")return;var O;if(typeof _=="function")O=_.propTypes;else if(typeof _=="object"&&(_.$$typeof===c||_.$$typeof===h))O=_.propTypes;else return;if(O){var k=z(_);zw(O,v.props,"prop",k,v)}else if(_.PropTypes!==void 0&&!cl){cl=!0;var ne=z(_);y("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?",ne||"Unknown")}typeof _.getDefaultProps=="function"&&!_.getDefaultProps.isReactClassApproved&&y("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.")}}function n1(v){{for(var _=Object.keys(v.props),O=0;O<_.length;O++){var k=_[O];if(k!=="children"&&k!=="key"){ar(v),y("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",k),ar(null);break}}v.ref!==null&&(ar(v),y("Invalid attribute `ref` supplied to `React.Fragment`."),ar(null))}}function op(v,_,O,k,ne,ce){{var J=Q(v);if(!J){var K="";(v===void 0||typeof v=="object"&&v!==null&&Object.keys(v).length===0)&&(K+=" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");var Xe=Jw(ne);Xe?K+=Xe:K+=ip();var _e;v===null?_e="null":sl(v)?_e="array":v!==void 0&&v.$$typeof===e?(_e="<"+(z(v.type)||"Unknown")+" />",K=" Did you accidentally export a JSX literal instead of a component?"):_e=typeof v,y("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",_e,K)}var Me=Zw(v,_,O,ne,ce);if(Me==null)return Me;if(J){var gt=_.children;if(gt!==void 0)if(k)if(sl(gt)){for(var or=0;or<gt.length;or++)ap(gt[or],v);Object.freeze&&Object.freeze(gt)}else y("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");else ap(gt,v)}return v===i?n1(Me):t1(Me),Me}}function i1(v,_,O){return op(v,_,O,!0)}function r1(v,_,O){return op(v,_,O,!1)}var s1=r1,a1=i1;ts.Fragment=i,ts.jsx=s1,ts.jsxs=a1}()),ts}process.env.NODE_ENV==="production"?Jc.exports=Tw():Jc.exports=yw();var Pe=Jc.exports;function ui(t,e,n,i={current:0},r=""){const s=e.get(n),a=new Set,o=q.useRef([]),c=new Set;o.current=[],r=r?`${r}.`:"";let u=[];return s&&(u=q.Children.map(s,l=>{if(q.isValidElement(l)){const h=l.key||i.current++,f=`${r}${l.props.name||`${h}`}`,p=t.get(f)||new ke;t.set(f,p),o.current.push(p),l.props.share&&(l.props.share.current=p);const g={key:h,name:f,resolver:p};return a.has(g.name)?c.add(g.name):a.add(g.name),q.cloneElement(l,g)}})),[u,Promise.all(o.current.map(l=>l==null?void 0:l.promise)),{resolvers:o,nameConflict:c}]}function el(...t){return t.filter(me).reduce((e,n)=>e.concat(n),[])}function bw(t){const{children:e,tagName:n,...i}=t,r=Object.keys(i).reduce((s,a)=>{try{En(a)&&(s[a.toLowerCase()]=JSON.stringify(i[a]))}catch{}return s},{});return{tagName:n,attributes:r,children:e}}const gn=t=>{const{tagName:e="",attributes:n,children:i}=bw(t),{writeToDom:r}=q.useContext(rr)||{};return r?q.createElement(e,n,i):t.children};var We=(t=>(t[t.EVENT_MANAGER=1]="EVENT_MANAGER",t[t.LAYER=2]="LAYER",t[t.CAMERA=3]="CAMERA",t[t.PROVIDER=4]="PROVIDER",t[t.RESOURCE=5]="RESOURCE",t[t.VIEW=6]="VIEW",t[t.SCENE=7]="SCENE",t))(We||{});function Uf(t,e,n){var s,a;const i=new Map,r=[];for(e&&e.forEach(o=>{i.set(o,[])}),q.Children.forEach(t,(o,c)=>{r.push(o)}),r.reverse();r.length>0;){const o=r.pop();if(q.isValidElement(o)){if(o!==void 0&&((o==null?void 0:o.type)===q.Fragment||o.props.surfaceJSXType===void 0)){if(!((s=o==null?void 0:o.props)!=null&&s.children)){n&&n.push(o);continue}const c=[];q.Children.forEach(((a=o==null?void 0:o.props)==null?void 0:a.children)||[],u=>{c.push(u)});for(let u=c.length-1;u>=0;--u)r.push(c[u]);continue}else if(o!==void 0){if(o.props.surfaceJSXType===void 0){n&&n.push(o);continue}if(e){const c=i.get(o.props.surfaceJSXType);if(!c){n&&n.push(o);continue}c.push(o)}else{let c=i.get(o.props.surfaceJSXType);c||(c=[],i.set(o.props.surfaceJSXType,c)),c.push(o)}}}}return i}function Ew(t){return t&&t.charCodeAt!==void 0}function _w(t){return t!=null}const Gf=()=>{};class Rw{constructor(e){this.resolver=Gf,this.rejector=Gf,this.promise=new Promise((n,i)=>(this.resolver=n,this.rejector=i))}resolve(e){this.resolver(e)}reject(e){this.rejector(e)}hijack(e){this.children=this.children||[],this.children.push(e),this.childResolvers=this.childResolvers||new Map,this.childResolvers.set(e,e.resolver),e.resolver=async n=>{this.childResolutions=this.childResolutions||new Map,this.childResolutions.set(e,n)}}}function Fn(t,e){var o,c;const[n,i]=q.useState(!0),[r,s]=q.useState(!1),a={store:t,shouldMount:n};if(!r&&_w(t.willMount)&&(a.shouldMount=!!((o=t.willMount)!=null&&o.call(t))),r){const u=(c=t.willUpdate)==null?void 0:c.call(t);u&&(async()=>await u())()}return q.useEffect(()=>{const u=new Rw;s(!0),i(a.shouldMount);let l;return(async()=>{var h;l=await((h=t.didMount)==null?void 0:h.call(t)),u.resolve(!0)})(),()=>{(async()=>(await u.promise,l==null||l()))()}},[]),q.useEffect(()=>{var u;r&&(a.shouldMount=!!((u=t.willMount)!=null&&u.call(t)))},e||[0]),a}const c1="",rr=q.createContext(void 0),xw=t=>{const e=q.useRef(null),n=q.useRef(null),i=q.useRef(0),r=q.useRef(null),s=q.useRef(null),a=q.useRef(-1),o=q.useRef(new Map),c=q.useRef(new Map),u=q.useRef(new Map),l=q.useRef(new Map),h=q.useRef(new Map),f=q.useRef(new ke),p={current:0},g=[],m=Uf(t.children,void 0,g);g.length&&console.warn("Surface found unsupported children",g);const[T,w]=ui(o.current,m,We.EVENT_MANAGER,p),[y,b]=ui(c.current,m,We.RESOURCE,p),[A,R,{nameConflict:N}]=ui(h.current,m,We.SCENE,p),[I,S,{nameConflict:j}]=ui(l.current,m,We.LAYER,p),[Q,D,{nameConflict:H}]=ui(u.current,m,We.VIEW,p);if(N.size>0){console.warn("Root Scene name conflict:",N);return}if(j.size>0){console.warn("Root Scene Layer name conflict:",j);return}if(H.size>0){console.warn("Root Scene View name conflict:",H);return}const z=async W=>{r.current&&(i.current=W,r.current.draw(W))},V=W=>{var oe,Y,Le,ee,Se,Bn;(oe=n.current)==null||oe.remove(),(ee=r.current)==null||ee.resize(((Y=e.current)==null?void 0:Y.offsetWidth)||0,((Le=e.current)==null?void 0:Le.offsetHeight)||0),n.current&&((Se=e.current)==null||Se.appendChild(n.current)),W||(Bn=r.current)==null||Bn.draw(i.current)},re=()=>{window.clearTimeout(a.current),a.current=window.setTimeout(()=>{V(!0)})};return Fn({async didMount(){var sr;if(!n.current||!e.current)return;const[W,oe,Y,Le,ee]=await Promise.all([w,b,R,S,D]),Se=Y.filter(me),Bn=W.filter(me),Un=oe.filter(me),Gn=Le.filter(me),vn=ee.filter(me);if(Y.length<=0&&(!(Gn!=null&&Gn.length)||!(vn!=null&&vn.length))){console.error("No scenes or root level Layers+Views provided to surface");return}vn.length&&Gn.length&&Se.unshift({key:"root",layers:Gn,views:vn});const kn=await new of({context:n.current,handlesWheelEvents:t.handlesWheelEvents!==void 0?t.handlesWheelEvents:!0,pixelRatio:t.pixelRatio||window.devicePixelRatio,eventManagers:Bn,ioExpansion:t.ioExpansion,shaderTransforms:t.shaderTransforms,resourceManagers:t.resourceManagers,rendererOptions:Object.assign({alpha:!0,antialias:!1},t.options)}).ready;return s.current=pc(z),kn.pipeline({resources:Un,scenes:Se}),r.current=kn,await Rn(),V(!0),(sr=t.ready)==null||sr.resolve(r.current),window.addEventListener("resize",re),()=>{var Ni;window.removeEventListener("resize",re),Uh(s.current),(Ni=r.current)==null||Ni.destroy()}}}),Pe.jsx("div",{ref:e,"data-deltav-version":"4.2.2",className:`SurfaceJSX ${t.className||""}`,...t.containerProps,children:Pe.jsx("canvas",{ref:n,children:Pe.jsx(rr.Provider,{value:{writeToDom:t.writeToDom,eventResolvers:o.current,resourceResolvers:c.current,viewResolvers:u.current,layerResolvers:l.current,sceneResolvers:h.current,resolversReady:f.current},children:Pe.jsx(gn,{tagName:"Surface",...t,children:el(T,y,Q,I,A)})})})})},kf=t=>(Fn({didMount(){var e;(e=t.resolver)==null||e.resolve(new Fc(t.handlers,t.preserveEvents))}}),Pe.jsx(gn,{tagName:"QueuedEventHandler",...t}));kf.defaultProps={surfaceJSXType:We.EVENT_MANAGER};const zf=t=>(Fn({didMount(){var e;(e=t.resolver)==null||e.resolve(new is(t.handlers))}}),Pe.jsx(gn,{tagName:"SimpleEventHandler",...t}));zf.defaultProps={surfaceJSXType:We.EVENT_MANAGER};const Vf=t=>(Fn({didMount(){var e;(e=t.resolver)==null||e.resolve(new lf(t.config))}}),Pe.jsx(gn,{tagName:"BasicCamera2DController",...t}));Vf.defaultProps={surfaceJSXType:We.EVENT_MANAGER};const Wf=t=>(Fn({didMount(){var e;(e=t.resolver)==null||e.resolve(bc({key:t.name,height:t.height,width:t.width,textureSettings:t.textureSettings}))}}),Pe.jsx(gn,{tagName:"Texture",...t}));Wf.defaultProps={surfaceJSXType:We.RESOURCE};const $f=t=>(Fn({didMount(){var e;(e=t.resolver)==null||e.resolve(Sc({key:t.name,fontSource:t.fontSource,characterFilter:t.characterFilter,dynamic:t.dynamic,fontMap:t.fontMap,fontMapSize:t.fontMapSize}))}}),Pe.jsx(gn,{tagName:"Font",...t}));$f.defaultProps={surfaceJSXType:We.RESOURCE};const ma=t=>{const e=q.useContext(rr);return Fn({async didMount(){var a,o;let n=t.config;const i=t.uses;if(i){await(e==null?void 0:e.resolversReady);const c={},u=i.names.map(async l=>{var p,g;const h=(p=e==null?void 0:e.resourceResolvers)==null?void 0:p.get(l);if(!h)return console.error(`A layer requested a resource: ${l} but the name identifier was not found in the available resources`),console.warn("Available resources:",Array.from(((g=e==null?void 0:e.resourceResolvers)==null?void 0:g.keys())||[])),null;const f=await h.promise;if(!f)return console.error(`The Layer requested a resource "${l}", but the resource did not resolve a value`),null;if(!bi(f))return console.error(`The Layer requested a resource "${l}", but the resource resolved to a value that is not a render texture resource`),null;c[l]=f}).filter(me);await Promise.all(u),n=i.apply(c,{...t.config})}const r=Ei(t.type,{key:t.name,...n});let s=((a=t.providerRef)==null?void 0:a.current)||r.init[1].data;s===r.init[0].defaultProps.data&&(s=new he),r.init[1].data=s,t.providerRef&&s instanceof he&&(t.providerRef.current=s),(o=t.resolver)==null||o.resolve(r)}}),Pe.jsx(gn,{tagName:"Layer",...t})};ma.defaultProps={surfaceJSXType:We.LAYER};function jf(t,e,n){var r,s;const i=(r=e==null?void 0:e.resourceResolvers)==null?void 0:r.get(n);return i||(console.error(`A View "${t}" requested a resource: ${n} but the name identifier was not found in the available resources`),console.warn("Available resources:",Array.from(((s=e==null?void 0:e.resourceResolvers)==null?void 0:s.keys())||[])),null)}const va=t=>{const e=q.useContext(rr);return Fn({async didMount(){var c,u,l;t.config.output&&!t.output&&console.warn("Do NOT use the output property in the config. Use the output property on the props of the JSX element"),await(e==null?void 0:e.resolversReady);const n=((c=t.output)==null?void 0:c.buffers)||{},i=Object.entries(n).map(([h,f])=>{const p=jf(t.name,e,f);return p?[Number.parseInt(h),p,f]:(console.warn("View props",t),null)}).filter(me),r={};await Promise.all(i.map(async h=>{const f=await h[1].promise;bi(f)||Ys(f)?r[h[0]]=f:(console.error(`A View "${t.name}" requested an output buffer for the resource with name: ${h[2]} but the resource indicated is not a valid output target type.`,"Ensure the resource is a RenderTextureResource or ColorBufferResource"),console.warn("View props",t))}));let s=!0;const a=(u=t.output)==null?void 0:u.depth;if(Ew(a)){const h=jf(t.name,e,a);if(!h)console.warn("View props",t),s=!1;else{const f=await h.promise;bi(f)||Ys(f)?s=f:(console.error(`A View "${t.name}" requested a depth buffer for the resource with name: ${a} but the resource indicated is not a valid output target type.`,"Ensure the resource is a RenderTextureResource or ColorBufferResource"),console.warn("View props",t))}}else me(a)&&(s=a);const o=Pc(t.type,{key:t.name,...t.config,output:t.output?{buffers:r,depth:s}:void 0});(l=t.resolver)==null||l.resolve(o)}}),Pe.jsx(gn,{tagName:"View",...t})};va.defaultProps={surfaceJSXType:We.VIEW};const wa=t=>{var l,h,f,p;const e=q.useContext(rr),n={current:0},i=Uf(t.children),[r,s,{nameConflict:a}]=ui((e==null?void 0:e.layerResolvers)||new Map,i,We.LAYER,n,t.name),[o,c,{nameConflict:u}]=ui((e==null?void 0:e.viewResolvers)||new Map,i,We.VIEW,n,t.name);if(a.size>0){console.warn(`Scene ${t.name} Layer name conflict:`,a),(l=t.resolver)==null||l.resolve(null);return}if(u.size>0){console.warn(`Scene ${t.name} View name conflict:`,u),(h=t.resolver)==null||h.resolve(null);return}if(!r){console.warn("A Scene had no Layers:",t.name),(f=t.resolver)==null||f.resolve(null);return}if(!o){console.warn("A Scene had no Views:",t.name),(p=t.resolver)==null||p.resolve(null);return}return Fn({async didMount(){var T;const[g,m]=await Promise.all([s,c]);(T=t.resolver)==null||T.resolve({key:t.name,layers:g.filter(me),views:m.filter(me)})}}),Pe.jsx(gn,{tagName:"Scene",...t,children:el(o,r)})};wa.defaultProps={surfaceJSXType:We.SCENE};function Aw(t){const e=[];for(let n=0,i=t.length;n<i;++n){const r=t[n];for(let s=0,a=r.length;s<a;++s)e.push(r[s])}return e}var Sw=Object.defineProperty,Mw=Object.getOwnPropertyDescriptor,Iw=(t,e,n,i)=>{for(var r=i>1?void 0:i?Mw(e,n):e,s=t.length-1,a;s>=0;s--)(a=t[s])&&(r=(i?a(e,n,r):a(r))||r);return i&&r&&Sw(e,n,r),r};const Hf=class extends ze{constructor(){super(),this.tint=[1,1,1,1],He(this,Hf)}};let tl=Hf;Iw([M],tl.prototype,"tint",2);const Qf=new ie({data:{width:2,height:2,buffer:new Uint8Array(16)}});class nl extends rn{initShader(){const{buffers:e,fs:n,data:i}=this.props,r=new tl;i instanceof he&&i.add(r),this.alwaysDraw=!0;const s=[[-1,-1],[1,-1],[-1,1],[1,1]],a=s.map(u=>[u[0]===1?1:0,u[1]===1?1:0]),o=Aw(Object.keys(e).map(u=>{const l=e[u];if(!l)return;const h=l.key,f=jr({key:h});return[{name:u,shaderInjection:x.FRAGMENT,size:E.TEXTURE,update:()=>(this.resource.request(this,r,f),f.texture||Qf)},{name:`${u}_size`,shaderInjection:x.FRAGMENT,size:E.TWO,update:()=>{this.props,this.resource.request(this,r,f);const p=(f.texture||Qf).data;return[(p==null?void 0:p.width)||1,(p==null?void 0:p.height)||1]}}]}).filter(me));let c=this.props.uniforms||[];return Array.isArray(c)||(c=c(this)),{drawMode:d.GLSettings.Model.DrawMode.TRIANGLE_STRIP,vs:`
        varying vec2 texCoord;

        void main() {
          gl_Position = vec4(vertex, 0.0, 1.0);
          texCoord = tex;
        }
      `,fs:n,instanceAttributes:[{name:"dummy",size:C.ONE,update:u=>[0]}],uniforms:o.concat(c),vertexAttributes:[{name:"vertex",size:Be.TWO,update:u=>s[u]},{name:"tex",size:Be.TWO,update:u=>a[u]}],vertexCount:4}}shouldDrawView(){return!this.props.preventDraw}getMaterialOptions(){return tt.transparentImageBlending.modify({depthTest:!1})}}nl.defaultProps={key:"",data:new he,buffers:{},baseShaderModules:()=>({fs:[],vs:[]}),fs:"void main() { gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);"};const mn=t=>{var e;return Pe.jsxs(wa,{name:t.name,children:[Pe.jsx(va,{name:"fullscreen",type:ua,...t.view,config:{camera:new sn,viewport:{left:0,top:0,width:"100%",height:"100%"},...(e=t.view)==null?void 0:e.config}}),Pe.jsx(ma,{name:"postprocess",type:nl,uses:{names:Object.values(t.buffers),apply:(n,i)=>{var r;return i.buffers={},Object.keys(t.buffers).map(s=>{i.buffers[s]=n[t.buffers[s]]}),(r=t.onResources)==null||r.call(t,n),i}},config:{printShader:t.printShader,buffers:{},fs:t.shader,uniforms:t.uniforms,materialOptions:t.material,preventDraw:t.preventDraw}})]},t.name)},Cw=t=>Pe.jsxs(wa,{name:t.name,children:[Pe.jsx(va,{type:ua,config:{camera:new sn}}),Pe.jsx(ma,{type:Uc,config:{commands:t.callback}})]}),Lw=`\${import: camera}
varying vec2 texCoord;

void main() {
  vec2 texelSize = 1.0 / viewSize;
  vec4 o = texelSize.xyxy * vec2(-delta, delta).xxyy;

  vec4 s =
    texture2D(color, texCoord + o.xy) + texture2D(color, texCoord + o.zy) +
    texture2D(color, texCoord + o.xw) + texture2D(color, texCoord + o.zw);

  gl_FragColor = s * 0.25;
}
`;var Ta=(t=>(t[t.DOWN=0]="DOWN",t[t.UP=1]="UP",t))(Ta||{});function il(t){const{output:e,input:n}=t;return mn({name:t.name,printShader:t.printShader,view:Object.assign(e?{output:{buffers:{[$.COLOR]:e},depth:!1}}:{},t.view),buffers:{color:n},shader:Lw,material:t.material,uniforms:[{name:"delta",size:E.ONE,shaderInjection:x.FRAGMENT,update:()=>t.direction===0?1:.5}]})}function Ow(t){const{compose:e,output:n,resources:i,view:r}=t,s={blending:{blendDst:d.GLSettings.Material.BlendingDstFactor.One,blendSrc:d.GLSettings.Material.BlendingSrcFactor.One,blendEquation:d.GLSettings.Material.BlendingEquations.Add}},a=[];for(let o=0,c=t.samples;o<c;++o){const u=il({name:`${t.name}.box-down${o}`,printShader:t.printShader,input:i[o],output:i[o+1],direction:Ta.DOWN,material:{blending:void 0}});a.push(u)}for(let o=t.samples-1;o>0;--o){const c=il({name:`${t.name}.box-up${o}`,printShader:t.printShader,input:i[o+1],output:i[o],direction:Ta.UP,material:s});a.push(c)}return e&&a.push(mn({name:`${t.name}.compose`,printShader:t.printShader,buffers:{color:e,glow:i[1]},material:s,view:{...n?{output:{buffers:{[$.COLOR]:n},depth:!1}}:void 0,...r},uniforms:[{name:"gamma",size:E.ONE,shaderInjection:x.ALL,update:()=>[t.gammaCorrection||1]}],shader:`
          varying vec2 texCoord;

          void main() {
            vec3 base = texture2D(color, texCoord).rgb;
            vec3 glow = texture2D(glow, texCoord).rgb;

            ${t.gammaCorrection!==void 0?`
              vec3 result = mix(
                base,
                glow + base,
                ((glow.r + glow.g + glow.b) * gamma)
              );
            `:`
              vec3 result = base + glow;
            `}

            gl_FragColor = vec4(result, 1.0);
          }
        `})),a}function Nw(t){return Array.isArray(t[0])}const Pw=t=>{const e=t.scale||us(1,1),i=(Nw(e)?e:[t.scale]).map(s=>ls(s)),r=1/i.length;if(me(t.drift)){const s=t.drift;return mn({name:t.name,buffers:{},view:{output:{buffers:{[$.COLOR]:t.output},depth:!1}},uniforms:[{name:"drift",size:E.THREE,shaderInjection:x.FRAGMENT,update:()=>s}],shader:`
        \${import: time, simplexNoise3D}

        void main() {
          float value = 0.;
          ${i.map(a=>`value += simplexNoise3D(vec3(gl_FragCoord.xy * vec2(${a[0]}f, ${a[1]}f), 0.) + (drift * time));`).join(`
`)}
          value *= ${r.toFixed(1)}f;
          \${out: color} = vec4(value, value, value, 1.);
        }
      `})}else if(me(t.zOffset)){const s=t.zOffset;return mn({name:t.name,buffers:{},view:{output:{buffers:{[$.COLOR]:t.output},depth:!1}},uniforms:[{name:"zOffset",size:E.ONE,update:Hl(s)?()=>[s]:()=>[s()]}],shader:`
        \${import: simplexNoise3D}

        void main() {
          float value = 0.;
          ${i.map(a=>`
            value += simplexNoise3D(vec3(gl_FragCoord.xy * vec2(${a[0]}f, ${a[1]}f), zOffset));
          `).join(`
`)}
          value *= ${r.toFixed(1)}f;
          \${out: color} = vec4(value, value, value, 1.);
        }
      `})}else return mn({name:t.name,buffers:{},view:{output:{buffers:{[$.COLOR]:t.output},depth:!1}},shader:`
        \${import: simplexNoise2D}

        void main() {
          float value = 0.;
          ${i.map(s=>`
            value += simplexNoise2D(gl_FragCoord.xy * vec2(${s[0]}f, ${s[1]}f));
          `).join(`
`)}
          value *= ${r.toFixed(1)}f;
          \${out: color} = vec4(value, value, value, 1.);
        }
      `})};function Dw(t){var s;const{output:e,input:n,channel:i,grayScale:r}=t;return mn({name:t.name,printShader:t.printShader,view:{output:e?{buffers:{[$.COLOR]:e||""},depth:!1}:void 0,...t.view,config:{camera:new sn,...(s=t.view)==null?void 0:s.config}},buffers:{color:n},shader:r&&i?`
      varying vec2 texCoord;

      void main() {
        gl_FragColor = vec4(texture2D(color, texCoord).${i}${i}${i}, 1.);
      }
    `:i?`
      varying vec2 texCoord;

      void main() {
        gl_FragColor = vec4(texture2D(color, texCoord).${i}, 0., 0., 1.);
      }
    `:`
      varying vec2 texCoord;

      void main() {
        gl_FragColor = texture2D(color, texCoord);
      }
    `,material:t.material,onResources:a=>{Object.values(a).forEach(o=>{(!o.textureSettings||o.textureSettings.generateMipMaps===void 0||o.textureSettings.generateMipMaps===!0)&&nn("drawjsx-resource-error",()=>{console.warn("POSSIBLE ERROR: for the draw post effect,","it is a common mistake to leave mipmaps enabled on the input texture.","Often the mipmaps are not available in the target resource and thus","you will get a blank output when rendering in certain scenarios.")})})}})}function Fw(t){const{output:e,input:n,view:i}=t,r=[];return r.push(mn({name:`${t.name}_base`,printShader:t.printShader,buffers:{trailTex:n.trail,addTex:n.add},material:{blending:null},view:{config:{clearFlags:[Ji.COLOR]},output:{buffers:{[$.COLOR]:e},depth:!1},...i},shader:`
          varying vec2 texCoord;

          void main() {
            // Add the trailTex and addTex but fade out the trailTex slightly
            vec4 addT = texture2D(addTex, texCoord);
            vec4 trailT = texture2D(trailTex, texCoord);

            // Blend the textures
            float alpha = addT.a + trailT.a * (1.0 - addT.a); // Compute final alpha
            vec3 color;
            if (alpha > 0.0) { // Avoid division by zero
              color = (addT.rgb * addT.a + trailT.rgb * trailT.a * (1.0 - addT.a)) / alpha;
            } else {
              color = vec3(0.0); // Fallback to black (or any other fallback color)
            }

            gl_FragColor = vec4(color, alpha);
          }
        `})),t.drift?t.drift&&r.push(mn({name:t.name,printShader:t.printShader,buffers:{tex:e},material:{blending:null},view:{output:{buffers:{[$.COLOR]:n.trail},depth:!1},...i},uniforms:[{name:"drift",size:E.TWO,shaderInjection:x.FRAGMENT,update:()=>{var s;return((s=t.drift)==null?void 0:s.direction)||[0,0]}}],shader:`
          varying vec2 texCoord;

          void main() {
            vec4 fade = texture2D(tex, texCoord + (drift / tex_size));
            fade.rgba *= ${t.intensity||.7};
            \${out: color} = fade;
          }
        `})):r.push(mn({name:t.name,printShader:t.printShader,buffers:{tex:e},material:{blending:null},view:{output:{buffers:{[$.COLOR]:n.trail},depth:!1},...i},shader:`
          varying vec2 texCoord;

          void main() {
            vec4 fade = texture2D(tex, texCoord);
            fade.rgba *= ${t.intensity||.7};
            \${out: color} = fade;
          }
        `})),r}class Xf extends rn{constructor(e,n,i){super(e,n,i),console.warn("Please ensure all debugLayer calls are removed for production:",i.key)}childLayers(){return this.props.wrap?(this.props.wrap.init[1].key=`debug-wrapper.${this.props.key}`,[this.props.wrap]):[]}draw(){if(!this.props.wrap)return;const e=this.resolveChanges(!0);if(e.length===0)return;const{messageHeader:n=()=>""}=this.props;console.warn(`${n()}
`,{totalChanges:e.length,changes:e})}initShader(){if(!this.props.wrap)return null;const e=new this.props.wrap.init[0](this.surface,this.scene,this.props.wrap.init[1]),n=e.childLayers(),i={};for(;n.length>0;){const r=n.pop();if(!r)continue;const s=new r.init[0](this.surface,this.scene,r.init[1]);i[s.id]={shaderIO:s.initShader()},s.childLayers().forEach(a=>n.push(a))}return console.warn(`Shader IO: ${this.id}
`,{shaderIO:e.initShader(),childLayers:i}),null}}Xf.defaultProps={data:new he,key:"default",messageHeader:()=>"",wrap:Ei(rn,{data:new he})};function Bw(t,e){const n=_i(Xf,{messageHeader:()=>`CHANGES FOR: ${n.init[1].key}`,wrap:_i(t,e),data:e.data});return n}d.ActiveIOExpansion=Ad,d.AnchorType=P,d.ArcInstance=On,d.ArcLayer=Gc,d.ArcScaleType=hf,d.Atlas=td,d.AtlasManager=id,d.AtlasResourceManager=sd,d.Attribute=yn,d.AutoEasingLoopStyle=Yt,d.AutoEasingMethod=Bs,d.Axis2D=Lf,d.BaseIOExpansion=$r,d.BaseIOSorting=tf,d.BaseProjection=Ns,d.BaseResourceManager=Qi,d.BaseShaderIOInjection=rd,d.BasicCamera2DController=lf,d.BasicCamera2DControllerJSX=Vf,d.BasicIOExpansion=xd,d.BasicInstance=Vg,d.BloomJSX=Ow,d.Bounds=te,d.BoxSampleJSX=il,d.BoxSampleJSXDirection=Ta,d.BufferManagerBase=ra,d.Camera=An,d.Camera2D=sn,d.CameraBoundsAnchor=cf,d.CameraProjectionType=xn,d.CircleInstance=qr,d.CircleLayer=kc,d.ClearFlags=Ji,d.CommandLayer=Uc,d.CommandsJSX=Cw,d.CommonMaterialOptions=tt,d.Control2D=Cn,d.CubeInstance=Zc,d.CubeLayer=Nf,d.CustomTag=gn,d.DEFAULT_IO_EXPANSION=rf,d.DEFAULT_RESOURCE_MANAGEMENT=sf,d.DEFAULT_RESOURCE_ROUTER=wd,d.DEFAULT_SHADER_TRANSFORM=af,d.DrawJSX=Dw,d.EasingIOExpansion=_d,d.EasingUtil=$g,d.EdgeBroadphase=zc,d.EdgeInstance=si,d.EdgeLayer=Vc,d.EdgeScaleType=Kr,d.EdgeType=on,d.EulerOrder=se,d.EventManager=Pi,d.FontGlyphRenderSize=gd,d.FontJSX=$f,d.FontManager=md,d.FontMap=ud,d.FontMapGlyphType=ea,d.FontRenderer=fd,d.FontResourceManager=vd,d.FontResourceRequestFetch=Ai,d.FragmentOutputType=$,d.GLProxy=Tr,d.GLState=ql,d.Geometry=$n,d.GlyphInstance=Tt,d.GlyphLayer=fa,d.Hadamard2x2=Iu,d.Hadamard3x3=Cu,d.Hadamard4x4=Lu,d.INVALID_RESOURCE_MANAGER=$h,d.IdentityTransform=kh,d.ImageInstance=ln,d.ImageLayer=gf,d.ImageRasterizer=Ri,d.Instance=ze,d.Instance3D=pn,d.InstanceAttributeBufferManager=Cd,d.InstanceAttributePackingBufferManager=Ld,d.InstanceAttributeSize=C,d.InstanceBlockIndex=No,d.InstanceDiffType=Ce,d.InstanceProvider=he,d.InstanceProviderWithList=Gg,d.InvalidResourceManager=Wh,d.LabelInstance=ae,d.LabelLayer=jc,d.Layer=rn,d.Layer2D=Ne,d.LayerBufferType=xe,d.LayerInteractionHandler=Xd,d.LayerJSX=ma,d.LayerMouseEvents=nf,d.LayerScene=la,d.M200=Qn,d.M201=Xn,d.M210=Yn,d.M211=qn,d.M300=br,d.M301=Er,d.M302=_r,d.M310=Rr,d.M311=xr,d.M312=Ar,d.M320=Sr,d.M321=Mr,d.M322=Ir,d.M3R=vi,d.M400=Ot,d.M401=Nt,d.M402=Pt,d.M403=Dt,d.M410=Ft,d.M411=Bt,d.M412=Ut,d.M413=Gt,d.M420=kt,d.M421=zt,d.M422=Vt,d.M423=Wt,d.M430=$t,d.M431=jt,d.M432=Ht,d.M433=Qt,d.M4R=Ue,d.Material=yr,d.MaterialUniformType=be,d.MatrixMath=Ig,d.Model=Bo,d.MouseButton=ul,d.NOOP=xs,d.NewLineCharacterMode=tr,d.NoView=Zd,d.ObservableMonitoring=je,d.PackNode=Qe,d.PickType=X,d.PostProcessInstance=tl,d.PostProcessJSX=mn,d.PostProcessLayer=nl,d.Projection3D=If,d.PromiseResolver=ke,d.QR1=rh,d.QR2=sh,d.QR3=ah,d.QR4=oh,d.QW=hh,d.QX=ch,d.QY=lh,d.QZ=uh,d.QuadTree=Kh,d.QuadTreeNode=Xi,d.QuadTreeQuadrants=qh,d.QuaternionMath=Cg,d.QueuedEventHandler=Fc,d.QueuedEventHandlerJSX=kf,d.REQUEST=xm,d.RESOURCE=Rm,d.RayMath=Lg,d.ReactiveDiff=Vr,d.RectangleInstance=pt,d.RectangleLayer=Xc,d.ReferenceCamera2D=p0,d.RenderTarget=Hn,d.RenderTexture=Ec,d.RenderTextureResourceManager=ad,d.ResourcePool=Kg,d.ResourceRouter=Mc,d.ResourceType=le,d.RingInstance=nr,d.RingLayer=Yc,d.SRT4x4=Fs,d.SRT4x4_2D=ic,d.ScaleMode=an,d.Scene=Ms,d.SceneGraphLayer=Of,d.SceneJSX=wa,d.ShaderInjectionTarget=x,d.ShaderModule=Ee,d.ShaderModuleUnit=aa,d.SimpleEventHandler=is,d.SimpleEventHandlerJSX=zf,d.SimpleProjection=hu,d.SimplexNoiseJSX=Pw,d.StreamChangeStrategy=As,d.SubTexture=Sn,d.Surface=of,d.SurfaceContext=rr,d.SurfaceErrorType=Fo,d.SurfaceJSX=xw,d.TRS4x4=Nr,d.TRS4x4_2D=Ju,d.TextAlignment=pa,d.TextAreaInstance=oi,d.TextAreaLayer=xf,d.Texture=ie,d.TextureIOExpansion=Zs,d.TextureJSX=Wf,d.TextureSize=lt,d.TrailJSX=Fw,d.Transform=Xs,d.Transform2D=pw,d.TreeNode=vc,d.UniformBufferManager=Nd,d.UniformSize=E,d.UseMaterialStatus=mt,d.UserInputEventManager=Jd,d.V3R=$e,d.V4R=hl,d.VecMath=B,d.VectorMath=Og,d.VertexAttributeSize=Be,d.View=Xr,d.View2D=ua,d.View3D=Cf,d.ViewJSX=va,d.WebGLRenderer=Zl,d.WebGLStat=L,d.WordWrap=hn,d.add1=rs,d.add2=wn,d.add2x2=_u,d.add3=At,d.add3x3=Ru,d.add4=ps,d.add4by3=Ml,d.add4x4=xu,d.addQuat=dh,d.affineInverse2x2=pu,d.affineInverse3x3=gu,d.affineInverse4x4=mu,d.angleQuat=xh,d.apply1=Fe,d.apply2=de,d.apply2x2=ft,d.apply3=pe,d.apply3x3=Ke,d.apply4=fe,d.apply4x4=ve,d.atlasRequest=Yi,d.axisQuat=Ah,d.ceil1=Sa,d.ceil2=ja,d.ceil3=io,d.ceil4=uo,d.clamp=et,d.color4FromHex3=Ol,d.color4FromHex4=Nl,d.colorBufferFormat=Gl,d.colorUID=Ip,d.compare1=Ma,d.compare2=cs,d.compare2x2=Yu,d.compare3=lr,d.compare3x3=qu,d.compare4=gs,d.compare4x4=nc,d.concat4x4=Eu,d.concatChildren=el,d.conjugateQuat=cc,d.convertToSDF=pm,d.copy1=Ia,d.copy2=os,d.copy2x2=Ku,d.copy3=nt,d.copy3x3=Zu,d.copy4=Mt,d.copy4x4=Gi,d.create=qg,d.createAtlas=ed,d.createAttribute=Xh,d.createChildLayer=_i,d.createEasingAttribute=Pm,d.createFont=Sc,d.createLayer=Ei,d.createLayer2Din3D=uw,d.createMaterialOptions=xp,d.createTexture=bc,d.createUniform=Zh,d.createVertex=Jh,d.createView=Pc,d.cross1=La,d.cross2=Qa,d.cross3=Ye,d.cross4=fo,d.debugLayer=Bw,d.decomposeRotation=$s,d.depthBufferFormat=kl,d.determinant2x2=ge,d.determinant3x3=wi,d.determinant4x4=Xo,d.diffUnitQuat=gh,d.divide1=Oa,d.divide2=cr,d.divide3=ur,d.divide4=po,d.divideQuat=fh,d.dot1=za,d.dot2=Di,d.dot3=hr,d.dot4=Ts,d.dotQuat=yh,d.down3=Sl,d.drawMode=_s,d.empty1=Na,d.empty2=Xa,d.empty3=ro,d.empty4=go,d.eulerToQuat=Ih,d.eventElementPosition=Ct,d.exponentQuat=ph,d.filterQuery=Qg,d.flatten1=Pa,d.flatten2=Ya,d.flatten3=so,d.flatten4=ms,d.floor1=Da,d.floor2=qa,d.floor3=ao,d.floor4=mo,d.fontRequest=Si,d.forward1=Ca,d.forward2=Ha,d.forward3=hi,d.forward4=ho,d.fromEulerAxisAngleToQuat=bh,d.fromOrderedEulerToQuat=uc,d.fuzzyCompare1=pl,d.fuzzyCompare2=vl,d.fuzzyCompare3=bl,d.fuzzyCompare4=Il,d.generateDefaultScene=Td,d.generateLayerGeometry=bd,d.generateLayerMaterial=yd,d.generateLayerModel=ia,d.getAbsolutePositionBounds=Mo,d.getProgramInfo=hp,d.iQuat=Ph,d.identity2=Cr,d.identity3=Xt,d.identity4=ue,d.imaginaryQuat=Th,d.indexToColorAttachment=pr,d.indexToTextureUnit=Vl,d.injectShaderIO=zd,d.inputImageFormat=fr,d.instanceAttributeSizeFloatCount=$l,d.inverse1=Fa,d.inverse2=ls,d.inverse3=Fi,d.inverse4=vo,d.inverseQuat=mh,d.isAtlasResource=_c,d.isBoolean=jn,d.isBufferLocation=Wm,d.isBufferLocationGroup=Sd,d.isDefined=me,d.isFontResource=Ac,d.isFunction=Ap,d.isInstanceAttributeBufferLocation=jm,d.isInstanceAttributeBufferLocationGroup=Id,d.isInstanceAttributeVector=bp,d.isNewline=Rp,d.isNumber=Hl,d.isOffscreenCanvas=gi,d.isOrthographic=zh,d.isPerspective=wc,d.isRenderTextureResource=bi,d.isResourceAttribute=Ep,d.isString=En,d.isUniformBufferLocation=Od,d.isUniformFloat=Bp,d.isUniformMat3=Pp,d.isUniformMat4=Dp,d.isUniformTexture=Fp,d.isUniformVec2=Lp,d.isUniformVec3=Op,d.isUniformVec4=Np,d.isUniformVec4Array=Xl,d.isVec1=dl,d.isVec2=Aa,d.isVec3=fl,d.isVec4=U,d.isVideoResource=Zr,d.isWhiteSpace=pi,d.jQuat=Dh,d.kQuat=Fh,d.left3=Al,d.length1=Wa,d.length1Components=ml,d.length2=Vn,d.length2Components=no,d.length3=hs,d.length3Components=lo,d.length4=ys,d.length4Components=Tn,d.lengthQuat=lc,d.linear1=Va,d.linear2=to,d.linear3=co,d.linear4=To,d.lookAtMatrix=Oh,d.lookAtQuat=hc,d.magFilter=fi,d.makeFontSDF=gm,d.makeObservable=He,d.mapGetWithDefault=Ks,d.mapInjectDefault=Jn,d.matrix3x3FromUnitQuatModel=Vs,d.matrix3x3FromUnitQuatView=Mh,d.matrix3x3ToQuaternion=Ch,d.matrix4x4FromUnitQuatModel=Sh,d.matrix4x4FromUnitQuatView=Ws,d.matrix4x4ToQuaternion=Lh,d.max1=Ba,d.max2=Ka,d.max3=ds,d.max4=yo,d.min1=Ua,d.min2=Za,d.min3=fs,d.min4=bo,d.minFilter=bn,d.multiply1=Ga,d.multiply2=Ja,d.multiply2x2=yu,d.multiply3=oo,d.multiply3x3=bu,d.multiply4=wo,d.multiply4x4=rt,d.multiplyQuat=ac,d.multiplyScalar2x2=vu,d.multiplyScalar3x3=wu,d.multiplyScalar4x4=Tu,d.newLineCharRegEx=Do,d.newLineRegEx=jl,d.nextFrame=kr,d.normalize1=ka,d.normalize2=eo,d.normalize3=ct,d.normalize4=Eo,d.normalizeQuat=vh,d.normalizeWheel=Ho,d.observable=M,d.onAnimationLoop=pc,d.onFrame=Rn,d.oneQuat=Br,d.orthographic4x4=ec,d.packAttributes=Bd,d.perspective4x4=Jo,d.perspectiveFOVY4x4=Xu,d.perspectiveFrustum4x4=Ps,d.preloadNumber=ym,d.project3As4ToScreen=Ds,d.projectToScreen=tc,d.ray=dc,d.rayFromPoints=fc,d.rayToLocation=Bh,d.realQuat=wh,d.removeComments=Wr,d.renderGlyph=Rc,d.resolveUpdate=mc,d.reverse2=yl,d.reverse3=_l,d.reverse4=Ll,d.right3=xl,d.rotateVectorByUnitQuat=js,d.rotation2x2=Yo,d.rotation4x4=qo,d.rotation4x4by3=ju,d.scale1=ss,d.scale2=Re,d.scale3=it,d.scale4=vs,d.scale4x4=Ko,d.scale4x4by3=Hu,d.scaleQuat=oc,d.scheduleUpdate=gc,d.shaderTemplate=ei,d.shallowCompare=rc,d.shearX2x2=Pu,d.shearX4x4=Fu,d.shearY2x2=Du,d.shearY4x4=Bu,d.shearZ4x4=Uu,d.slerpQuat=_o,d.slerpUnitQuat=Nh,d.stencilBufferFormat=zl,d.stopAllFrameCommands=Ng,d.stopAnimationLoop=Uh,d.subTextureIOValue=ti,d.subtract1=as,d.subtract2=ye,d.subtract2x2=Au,d.subtract3=St,d.subtract3x3=Su,d.subtract4=ws,d.subtract4x4=Mu,d.texelFormat=di,d.textureRequest=jr,d.textureUnitToIndex=Co,d.toEulerFromQuat=_h,d.toEulerXYZfromOrderedEuler=Eh,d.toOrderedEulerFromQuat=zs,d.toOrderedEulerFromQuat2=Rh,d.toString1=Pl,d.toString2=Dl,d.toString2x2=Vu,d.toString3=Fl,d.toString3x3=Wu,d.toString4=Bl,d.toString4x4=$u,d.tod1=gl,d.tod2=wl,d.tod3=El,d.tod4=Cl,d.tod_flip2=Tl,d.touchesContainsStartView=uu,d.touchesHasStartView=lu,d.transform2=Gu,d.transform3=ku,d.transform3as4=zu,d.transform4=Or,d.translation4x4=Zo,d.translation4x4by3=Qu,d.transpose2x2=Ou,d.transpose3x3=Lr,d.transpose4x4=Nu,d.uid=G,d.up3=Rl,d.useChildResolvers=ui,d.vec1=$a,d.vec1Methods=Ro,d.vec2=us,d.vec2Methods=xo,d.vec3=Wn,d.vec3Methods=Ao,d.vec4=dr,d.vec4Methods=So,d.wait=Xg,d.waitForValidDimensions=Yg,d.whiteSpaceCharRegEx=Po,d.whiteSpaceRegEx=_p,d.wrapMode=Io,d.zeroQuat=we,Object.defineProperty(d,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=index.js.map
